
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:19:12.289] plan(): Setting new future strategy stack:
[16:19:12.289] List of future strategies:
[16:19:12.289] 1. sequential:
[16:19:12.289]    - args: function (..., envir = parent.frame())
[16:19:12.289]    - tweaked: FALSE
[16:19:12.289]    - call: future::plan("sequential")
[16:19:12.303] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:19:12.409] plan(): Setting new future strategy stack:
[16:19:12.409] List of future strategies:
[16:19:12.409] 1. sequential:
[16:19:12.409]    - args: function (..., envir = parent.frame())
[16:19:12.409]    - tweaked: FALSE
[16:19:12.409]    - call: plan(strategy)
[16:19:12.421] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:19:12.426] future_lapply() ...
[16:19:12.432] Number of chunks: 1
[16:19:12.433] getGlobalsAndPackagesXApply() ...
[16:19:12.433]  - future.globals: TRUE
[16:19:12.434] getGlobalsAndPackages() ...
[16:19:12.434] Searching for globals...
[16:19:12.438] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:12.438] Searching for globals ... DONE
[16:19:12.438] Resolving globals: FALSE
[16:19:12.440] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:19:12.440] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.440] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.440] - packages: [1] ‘future.apply’
[16:19:12.441] getGlobalsAndPackages() ... DONE
[16:19:12.441]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.441]  - needed namespaces: [n=1] ‘future.apply’
[16:19:12.441] Finding globals ... DONE
[16:19:12.441]  - use_args: TRUE
[16:19:12.441]  - Getting '...' globals ...
[16:19:12.442] resolve() on list ...
[16:19:12.442]  recursive: 0
[16:19:12.442]  length: 1
[16:19:12.442]  elements: ‘...’
[16:19:12.443]  length: 0 (resolved future 1)
[16:19:12.443] resolve() on list ... DONE
[16:19:12.443]    - '...' content: [n=0] 
[16:19:12.443] List of 1
[16:19:12.443]  $ ...: list()
[16:19:12.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.443]  - attr(*, "where")=List of 1
[16:19:12.443]   ..$ ...:<environment: 0x56199d8fdb60> 
[16:19:12.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.443]  - attr(*, "resolved")= logi TRUE
[16:19:12.443]  - attr(*, "total_size")= num NA
[16:19:12.445]  - Getting '...' globals ... DONE
[16:19:12.446] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.446] List of 8
[16:19:12.446]  $ ...future.FUN:function (x, ...)  
[16:19:12.446]  $ x_FUN        :function (x)  
[16:19:12.446]  $ times        : int 1
[16:19:12.446]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.446]  $ stop_if_not  :function (...)  
[16:19:12.446]  $ dim          : NULL
[16:19:12.446]  $ valid_types  : chr "character"
[16:19:12.446]  $ ...          : list()
[16:19:12.446]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.446]  - attr(*, "where")=List of 8
[16:19:12.446]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.446]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.446]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.446]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.446]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.446]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.446]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.446]   ..$ ...          :<environment: 0x56199d8fdb60> 
[16:19:12.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.446]  - attr(*, "resolved")= logi FALSE
[16:19:12.446]  - attr(*, "total_size")= num 94208
[16:19:12.454] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:12.454] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.455] Number of futures (= number of chunks): 1
[16:19:12.455] Launching 1 futures (chunks) ...
[16:19:12.455] Chunk #1 of 1 ...
[16:19:12.455]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.455] getGlobalsAndPackages() ...
[16:19:12.455] Searching for globals...
[16:19:12.456] 
[16:19:12.456] Searching for globals ... DONE
[16:19:12.456] - globals: [0] <none>
[16:19:12.456] getGlobalsAndPackages() ... DONE
[16:19:12.456]    + additional globals found: [n=0] 
[16:19:12.456]    + additional namespaces needed: [n=0] 
[16:19:12.456]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.456]  - seeds: <none>
[16:19:12.456]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.457] getGlobalsAndPackages() ...
[16:19:12.457] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.457] Resolving globals: FALSE
[16:19:12.457] Tweak future expression to call with '...' arguments ...
[16:19:12.457] {
[16:19:12.457]     do.call(function(...) {
[16:19:12.457]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.457]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.457]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.457]             on.exit(options(oopts), add = TRUE)
[16:19:12.457]         }
[16:19:12.457]         {
[16:19:12.457]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.457]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.457]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.457]             })
[16:19:12.457]         }
[16:19:12.457]     }, args = future.call.arguments)
[16:19:12.457] }
[16:19:12.457] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.458] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.458] - packages: [1] ‘future.apply’
[16:19:12.458] getGlobalsAndPackages() ... DONE
[16:19:12.459] run() for ‘Future’ ...
[16:19:12.459] - state: ‘created’
[16:19:12.459] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.460] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.460]   - Field: ‘label’
[16:19:12.460]   - Field: ‘local’
[16:19:12.460]   - Field: ‘owner’
[16:19:12.460]   - Field: ‘envir’
[16:19:12.460]   - Field: ‘packages’
[16:19:12.460]   - Field: ‘gc’
[16:19:12.461]   - Field: ‘conditions’
[16:19:12.461]   - Field: ‘expr’
[16:19:12.461]   - Field: ‘uuid’
[16:19:12.461]   - Field: ‘seed’
[16:19:12.461]   - Field: ‘version’
[16:19:12.461]   - Field: ‘result’
[16:19:12.461]   - Field: ‘asynchronous’
[16:19:12.461]   - Field: ‘calls’
[16:19:12.461]   - Field: ‘globals’
[16:19:12.461]   - Field: ‘stdout’
[16:19:12.462]   - Field: ‘earlySignal’
[16:19:12.462]   - Field: ‘lazy’
[16:19:12.462]   - Field: ‘state’
[16:19:12.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.462] - Launch lazy future ...
[16:19:12.463] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:12.463] Packages needed by future strategies (n = 0): <none>
[16:19:12.464] {
[16:19:12.464]     {
[16:19:12.464]         {
[16:19:12.464]             ...future.startTime <- base::Sys.time()
[16:19:12.464]             {
[16:19:12.464]                 {
[16:19:12.464]                   {
[16:19:12.464]                     {
[16:19:12.464]                       base::local({
[16:19:12.464]                         has_future <- base::requireNamespace("future", 
[16:19:12.464]                           quietly = TRUE)
[16:19:12.464]                         if (has_future) {
[16:19:12.464]                           ns <- base::getNamespace("future")
[16:19:12.464]                           version <- ns[[".package"]][["version"]]
[16:19:12.464]                           if (is.null(version)) 
[16:19:12.464]                             version <- utils::packageVersion("future")
[16:19:12.464]                         }
[16:19:12.464]                         else {
[16:19:12.464]                           version <- NULL
[16:19:12.464]                         }
[16:19:12.464]                         if (!has_future || version < "1.8.0") {
[16:19:12.464]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.464]                             "", base::R.version$version.string), 
[16:19:12.464]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.464]                               "release", "version")], collapse = " "), 
[16:19:12.464]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.464]                             info)
[16:19:12.464]                           info <- base::paste(info, collapse = "; ")
[16:19:12.464]                           if (!has_future) {
[16:19:12.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.464]                               info)
[16:19:12.464]                           }
[16:19:12.464]                           else {
[16:19:12.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.464]                               info, version)
[16:19:12.464]                           }
[16:19:12.464]                           base::stop(msg)
[16:19:12.464]                         }
[16:19:12.464]                       })
[16:19:12.464]                     }
[16:19:12.464]                     base::local({
[16:19:12.464]                       for (pkg in "future.apply") {
[16:19:12.464]                         base::loadNamespace(pkg)
[16:19:12.464]                         base::library(pkg, character.only = TRUE)
[16:19:12.464]                       }
[16:19:12.464]                     })
[16:19:12.464]                   }
[16:19:12.464]                   ...future.strategy.old <- future::plan("list")
[16:19:12.464]                   options(future.plan = NULL)
[16:19:12.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.464]                 }
[16:19:12.464]                 ...future.workdir <- getwd()
[16:19:12.464]             }
[16:19:12.464]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.464]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.464]         }
[16:19:12.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.464]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.464]             base::names(...future.oldOptions))
[16:19:12.464]     }
[16:19:12.464]     if (FALSE) {
[16:19:12.464]     }
[16:19:12.464]     else {
[16:19:12.464]         if (TRUE) {
[16:19:12.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.464]                 open = "w")
[16:19:12.464]         }
[16:19:12.464]         else {
[16:19:12.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.464]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.464]         }
[16:19:12.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.464]             base::sink(type = "output", split = FALSE)
[16:19:12.464]             base::close(...future.stdout)
[16:19:12.464]         }, add = TRUE)
[16:19:12.464]     }
[16:19:12.464]     ...future.frame <- base::sys.nframe()
[16:19:12.464]     ...future.conditions <- base::list()
[16:19:12.464]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.464]     if (FALSE) {
[16:19:12.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.464]     }
[16:19:12.464]     ...future.result <- base::tryCatch({
[16:19:12.464]         base::withCallingHandlers({
[16:19:12.464]             ...future.value <- base::withVisible(base::local({
[16:19:12.464]                 do.call(function(...) {
[16:19:12.464]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.464]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.464]                     ...future.globals.maxSize)) {
[16:19:12.464]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.464]                     on.exit(options(oopts), add = TRUE)
[16:19:12.464]                   }
[16:19:12.464]                   {
[16:19:12.464]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.464]                       FUN = function(jj) {
[16:19:12.464]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.464]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.464]                       })
[16:19:12.464]                   }
[16:19:12.464]                 }, args = future.call.arguments)
[16:19:12.464]             }))
[16:19:12.464]             future::FutureResult(value = ...future.value$value, 
[16:19:12.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.464]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.464]                     ...future.globalenv.names))
[16:19:12.464]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.464]         }, condition = base::local({
[16:19:12.464]             c <- base::c
[16:19:12.464]             inherits <- base::inherits
[16:19:12.464]             invokeRestart <- base::invokeRestart
[16:19:12.464]             length <- base::length
[16:19:12.464]             list <- base::list
[16:19:12.464]             seq.int <- base::seq.int
[16:19:12.464]             signalCondition <- base::signalCondition
[16:19:12.464]             sys.calls <- base::sys.calls
[16:19:12.464]             `[[` <- base::`[[`
[16:19:12.464]             `+` <- base::`+`
[16:19:12.464]             `<<-` <- base::`<<-`
[16:19:12.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.464]                   3L)]
[16:19:12.464]             }
[16:19:12.464]             function(cond) {
[16:19:12.464]                 is_error <- inherits(cond, "error")
[16:19:12.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.464]                   NULL)
[16:19:12.464]                 if (is_error) {
[16:19:12.464]                   sessionInformation <- function() {
[16:19:12.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.464]                       search = base::search(), system = base::Sys.info())
[16:19:12.464]                   }
[16:19:12.464]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.464]                     cond$call), session = sessionInformation(), 
[16:19:12.464]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.464]                   signalCondition(cond)
[16:19:12.464]                 }
[16:19:12.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.464]                 "immediateCondition"))) {
[16:19:12.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.464]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.464]                   if (TRUE && !signal) {
[16:19:12.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.464]                     {
[16:19:12.464]                       inherits <- base::inherits
[16:19:12.464]                       invokeRestart <- base::invokeRestart
[16:19:12.464]                       is.null <- base::is.null
[16:19:12.464]                       muffled <- FALSE
[16:19:12.464]                       if (inherits(cond, "message")) {
[16:19:12.464]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.464]                         if (muffled) 
[16:19:12.464]                           invokeRestart("muffleMessage")
[16:19:12.464]                       }
[16:19:12.464]                       else if (inherits(cond, "warning")) {
[16:19:12.464]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.464]                         if (muffled) 
[16:19:12.464]                           invokeRestart("muffleWarning")
[16:19:12.464]                       }
[16:19:12.464]                       else if (inherits(cond, "condition")) {
[16:19:12.464]                         if (!is.null(pattern)) {
[16:19:12.464]                           computeRestarts <- base::computeRestarts
[16:19:12.464]                           grepl <- base::grepl
[16:19:12.464]                           restarts <- computeRestarts(cond)
[16:19:12.464]                           for (restart in restarts) {
[16:19:12.464]                             name <- restart$name
[16:19:12.464]                             if (is.null(name)) 
[16:19:12.464]                               next
[16:19:12.464]                             if (!grepl(pattern, name)) 
[16:19:12.464]                               next
[16:19:12.464]                             invokeRestart(restart)
[16:19:12.464]                             muffled <- TRUE
[16:19:12.464]                             break
[16:19:12.464]                           }
[16:19:12.464]                         }
[16:19:12.464]                       }
[16:19:12.464]                       invisible(muffled)
[16:19:12.464]                     }
[16:19:12.464]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.464]                   }
[16:19:12.464]                 }
[16:19:12.464]                 else {
[16:19:12.464]                   if (TRUE) {
[16:19:12.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.464]                     {
[16:19:12.464]                       inherits <- base::inherits
[16:19:12.464]                       invokeRestart <- base::invokeRestart
[16:19:12.464]                       is.null <- base::is.null
[16:19:12.464]                       muffled <- FALSE
[16:19:12.464]                       if (inherits(cond, "message")) {
[16:19:12.464]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.464]                         if (muffled) 
[16:19:12.464]                           invokeRestart("muffleMessage")
[16:19:12.464]                       }
[16:19:12.464]                       else if (inherits(cond, "warning")) {
[16:19:12.464]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.464]                         if (muffled) 
[16:19:12.464]                           invokeRestart("muffleWarning")
[16:19:12.464]                       }
[16:19:12.464]                       else if (inherits(cond, "condition")) {
[16:19:12.464]                         if (!is.null(pattern)) {
[16:19:12.464]                           computeRestarts <- base::computeRestarts
[16:19:12.464]                           grepl <- base::grepl
[16:19:12.464]                           restarts <- computeRestarts(cond)
[16:19:12.464]                           for (restart in restarts) {
[16:19:12.464]                             name <- restart$name
[16:19:12.464]                             if (is.null(name)) 
[16:19:12.464]                               next
[16:19:12.464]                             if (!grepl(pattern, name)) 
[16:19:12.464]                               next
[16:19:12.464]                             invokeRestart(restart)
[16:19:12.464]                             muffled <- TRUE
[16:19:12.464]                             break
[16:19:12.464]                           }
[16:19:12.464]                         }
[16:19:12.464]                       }
[16:19:12.464]                       invisible(muffled)
[16:19:12.464]                     }
[16:19:12.464]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.464]                   }
[16:19:12.464]                 }
[16:19:12.464]             }
[16:19:12.464]         }))
[16:19:12.464]     }, error = function(ex) {
[16:19:12.464]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.464]                 ...future.rng), started = ...future.startTime, 
[16:19:12.464]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.464]             version = "1.8"), class = "FutureResult")
[16:19:12.464]     }, finally = {
[16:19:12.464]         if (!identical(...future.workdir, getwd())) 
[16:19:12.464]             setwd(...future.workdir)
[16:19:12.464]         {
[16:19:12.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.464]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.464]             }
[16:19:12.464]             base::options(...future.oldOptions)
[16:19:12.464]             if (.Platform$OS.type == "windows") {
[16:19:12.464]                 old_names <- names(...future.oldEnvVars)
[16:19:12.464]                 envs <- base::Sys.getenv()
[16:19:12.464]                 names <- names(envs)
[16:19:12.464]                 common <- intersect(names, old_names)
[16:19:12.464]                 added <- setdiff(names, old_names)
[16:19:12.464]                 removed <- setdiff(old_names, names)
[16:19:12.464]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.464]                   envs[common]]
[16:19:12.464]                 NAMES <- toupper(changed)
[16:19:12.464]                 args <- list()
[16:19:12.464]                 for (kk in seq_along(NAMES)) {
[16:19:12.464]                   name <- changed[[kk]]
[16:19:12.464]                   NAME <- NAMES[[kk]]
[16:19:12.464]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.464]                     next
[16:19:12.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.464]                 }
[16:19:12.464]                 NAMES <- toupper(added)
[16:19:12.464]                 for (kk in seq_along(NAMES)) {
[16:19:12.464]                   name <- added[[kk]]
[16:19:12.464]                   NAME <- NAMES[[kk]]
[16:19:12.464]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.464]                     next
[16:19:12.464]                   args[[name]] <- ""
[16:19:12.464]                 }
[16:19:12.464]                 NAMES <- toupper(removed)
[16:19:12.464]                 for (kk in seq_along(NAMES)) {
[16:19:12.464]                   name <- removed[[kk]]
[16:19:12.464]                   NAME <- NAMES[[kk]]
[16:19:12.464]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.464]                     next
[16:19:12.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.464]                 }
[16:19:12.464]                 if (length(args) > 0) 
[16:19:12.464]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.464]             }
[16:19:12.464]             else {
[16:19:12.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.464]             }
[16:19:12.464]             {
[16:19:12.464]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.464]                   0L) {
[16:19:12.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.464]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.464]                   base::options(opts)
[16:19:12.464]                 }
[16:19:12.464]                 {
[16:19:12.464]                   {
[16:19:12.464]                     NULL
[16:19:12.464]                     RNGkind("Mersenne-Twister")
[16:19:12.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.464]                       inherits = FALSE)
[16:19:12.464]                   }
[16:19:12.464]                   options(future.plan = NULL)
[16:19:12.464]                   if (is.na(NA_character_)) 
[16:19:12.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.464]                     .init = FALSE)
[16:19:12.464]                 }
[16:19:12.464]             }
[16:19:12.464]         }
[16:19:12.464]     })
[16:19:12.464]     if (TRUE) {
[16:19:12.464]         base::sink(type = "output", split = FALSE)
[16:19:12.464]         if (TRUE) {
[16:19:12.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.464]         }
[16:19:12.464]         else {
[16:19:12.464]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.464]         }
[16:19:12.464]         base::close(...future.stdout)
[16:19:12.464]         ...future.stdout <- NULL
[16:19:12.464]     }
[16:19:12.464]     ...future.result$conditions <- ...future.conditions
[16:19:12.464]     ...future.result$finished <- base::Sys.time()
[16:19:12.464]     ...future.result
[16:19:12.464] }
[16:19:12.466] assign_globals() ...
[16:19:12.466] List of 11
[16:19:12.466]  $ ...future.FUN            :function (x, ...)  
[16:19:12.466]  $ x_FUN                    :function (x)  
[16:19:12.466]  $ times                    : int 1
[16:19:12.466]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.466]  $ stop_if_not              :function (...)  
[16:19:12.466]  $ dim                      : NULL
[16:19:12.466]  $ valid_types              : chr "character"
[16:19:12.466]  $ future.call.arguments    : list()
[16:19:12.466]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.466]  $ ...future.elements_ii    :List of 2
[16:19:12.466]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:19:12.466]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[16:19:12.466]  $ ...future.seeds_ii       : NULL
[16:19:12.466]  $ ...future.globals.maxSize: NULL
[16:19:12.466]  - attr(*, "where")=List of 11
[16:19:12.466]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.466]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.466]  - attr(*, "resolved")= logi FALSE
[16:19:12.466]  - attr(*, "total_size")= num 94208
[16:19:12.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.466]  - attr(*, "already-done")= logi TRUE
[16:19:12.474] - copied ‘...future.FUN’ to environment
[16:19:12.474] - copied ‘x_FUN’ to environment
[16:19:12.474] - copied ‘times’ to environment
[16:19:12.474] - copied ‘stopf’ to environment
[16:19:12.474] - copied ‘stop_if_not’ to environment
[16:19:12.474] - copied ‘dim’ to environment
[16:19:12.474] - copied ‘valid_types’ to environment
[16:19:12.474] - copied ‘future.call.arguments’ to environment
[16:19:12.475] - copied ‘...future.elements_ii’ to environment
[16:19:12.475] - copied ‘...future.seeds_ii’ to environment
[16:19:12.475] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.475] assign_globals() ... done
[16:19:12.475] plan(): Setting new future strategy stack:
[16:19:12.475] List of future strategies:
[16:19:12.475] 1. sequential:
[16:19:12.475]    - args: function (..., envir = parent.frame())
[16:19:12.475]    - tweaked: FALSE
[16:19:12.475]    - call: NULL
[16:19:12.476] plan(): nbrOfWorkers() = 1
[16:19:12.477] plan(): Setting new future strategy stack:
[16:19:12.477] List of future strategies:
[16:19:12.477] 1. sequential:
[16:19:12.477]    - args: function (..., envir = parent.frame())
[16:19:12.477]    - tweaked: FALSE
[16:19:12.477]    - call: plan(strategy)
[16:19:12.477] plan(): nbrOfWorkers() = 1
[16:19:12.478] SequentialFuture started (and completed)
[16:19:12.478] - Launch lazy future ... done
[16:19:12.478] run() for ‘SequentialFuture’ ... done
[16:19:12.478] Created future:
[16:19:12.478] SequentialFuture:
[16:19:12.478] Label: ‘future_vapply-1’
[16:19:12.478] Expression:
[16:19:12.478] {
[16:19:12.478]     do.call(function(...) {
[16:19:12.478]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.478]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.478]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.478]             on.exit(options(oopts), add = TRUE)
[16:19:12.478]         }
[16:19:12.478]         {
[16:19:12.478]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.478]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.478]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.478]             })
[16:19:12.478]         }
[16:19:12.478]     }, args = future.call.arguments)
[16:19:12.478] }
[16:19:12.478] Lazy evaluation: FALSE
[16:19:12.478] Asynchronous evaluation: FALSE
[16:19:12.478] Local evaluation: TRUE
[16:19:12.478] Environment: R_GlobalEnv
[16:19:12.478] Capture standard output: TRUE
[16:19:12.478] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.478] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.478] Packages: 1 packages (‘future.apply’)
[16:19:12.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.478] Resolved: TRUE
[16:19:12.478] Value: 232 bytes of class ‘list’
[16:19:12.478] Early signaling: FALSE
[16:19:12.478] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.478] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.480] Chunk #1 of 1 ... DONE
[16:19:12.480] Launching 1 futures (chunks) ... DONE
[16:19:12.480] Resolving 1 futures (chunks) ...
[16:19:12.480] resolve() on list ...
[16:19:12.481]  recursive: 0
[16:19:12.481]  length: 1
[16:19:12.481] 
[16:19:12.481] resolved() for ‘SequentialFuture’ ...
[16:19:12.481] - state: ‘finished’
[16:19:12.481] - run: TRUE
[16:19:12.481] - result: ‘FutureResult’
[16:19:12.481] resolved() for ‘SequentialFuture’ ... done
[16:19:12.484] Future #1
[16:19:12.484] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.484] - nx: 1
[16:19:12.484] - relay: TRUE
[16:19:12.484] - stdout: TRUE
[16:19:12.484] - signal: TRUE
[16:19:12.484] - resignal: FALSE
[16:19:12.485] - force: TRUE
[16:19:12.485] - relayed: [n=1] FALSE
[16:19:12.485] - queued futures: [n=1] FALSE
[16:19:12.485]  - until=1
[16:19:12.485]  - relaying element #1
[16:19:12.485] - relayed: [n=1] TRUE
[16:19:12.485] - queued futures: [n=1] TRUE
[16:19:12.485] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.486]  length: 0 (resolved future 1)
[16:19:12.486] Relaying remaining futures
[16:19:12.486] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.486] - nx: 1
[16:19:12.486] - relay: TRUE
[16:19:12.486] - stdout: TRUE
[16:19:12.486] - signal: TRUE
[16:19:12.486] - resignal: FALSE
[16:19:12.486] - force: TRUE
[16:19:12.486] - relayed: [n=1] TRUE
[16:19:12.486] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.487] - relayed: [n=1] TRUE
[16:19:12.487] - queued futures: [n=1] TRUE
[16:19:12.487] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.487] resolve() on list ... DONE
[16:19:12.487]  - Number of value chunks collected: 1
[16:19:12.487] Resolving 1 futures (chunks) ... DONE
[16:19:12.487] Reducing values from 1 chunks ...
[16:19:12.487]  - Number of values collected after concatenation: 2
[16:19:12.487]  - Number of values expected: 2
[16:19:12.488] Reducing values from 1 chunks ... DONE
[16:19:12.488] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:19:12.489] future_lapply() ...
[16:19:12.491] Number of chunks: 1
[16:19:12.491] getGlobalsAndPackagesXApply() ...
[16:19:12.491]  - future.globals: TRUE
[16:19:12.491] getGlobalsAndPackages() ...
[16:19:12.491] Searching for globals...
[16:19:12.494] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:19:12.495] Searching for globals ... DONE
[16:19:12.495] Resolving globals: FALSE
[16:19:12.495] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:19:12.496] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.496] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.496] - packages: [1] ‘future.apply’
[16:19:12.496] getGlobalsAndPackages() ... DONE
[16:19:12.496]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.496]  - needed namespaces: [n=1] ‘future.apply’
[16:19:12.497] Finding globals ... DONE
[16:19:12.497]  - use_args: TRUE
[16:19:12.497]  - Getting '...' globals ...
[16:19:12.497] resolve() on list ...
[16:19:12.497]  recursive: 0
[16:19:12.497]  length: 1
[16:19:12.497]  elements: ‘...’
[16:19:12.497]  length: 0 (resolved future 1)
[16:19:12.498] resolve() on list ... DONE
[16:19:12.498]    - '...' content: [n=0] 
[16:19:12.498] List of 1
[16:19:12.498]  $ ...: list()
[16:19:12.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.498]  - attr(*, "where")=List of 1
[16:19:12.498]   ..$ ...:<environment: 0x56199e55f478> 
[16:19:12.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.498]  - attr(*, "resolved")= logi TRUE
[16:19:12.498]  - attr(*, "total_size")= num NA
[16:19:12.500]  - Getting '...' globals ... DONE
[16:19:12.500] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.500] List of 8
[16:19:12.500]  $ ...future.FUN:function (x, ...)  
[16:19:12.500]  $ x_FUN        :function (x)  
[16:19:12.500]  $ times        : int 0
[16:19:12.500]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.500]  $ stop_if_not  :function (...)  
[16:19:12.500]  $ dim          : NULL
[16:19:12.500]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:12.500]  $ ...          : list()
[16:19:12.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.500]  - attr(*, "where")=List of 8
[16:19:12.500]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.500]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.500]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.500]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.500]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.500]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.500]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.500]   ..$ ...          :<environment: 0x56199e55f478> 
[16:19:12.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.500]  - attr(*, "resolved")= logi FALSE
[16:19:12.500]  - attr(*, "total_size")= num 95472
[16:19:12.507] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:12.507] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.508] Number of futures (= number of chunks): 1
[16:19:12.508] Launching 1 futures (chunks) ...
[16:19:12.508] Chunk #1 of 1 ...
[16:19:12.508]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.508] getGlobalsAndPackages() ...
[16:19:12.508] Searching for globals...
[16:19:12.508] 
[16:19:12.509] Searching for globals ... DONE
[16:19:12.509] - globals: [0] <none>
[16:19:12.509] getGlobalsAndPackages() ... DONE
[16:19:12.509]    + additional globals found: [n=0] 
[16:19:12.509]    + additional namespaces needed: [n=0] 
[16:19:12.509]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.509]  - seeds: <none>
[16:19:12.509]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.509] getGlobalsAndPackages() ...
[16:19:12.509] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.510] Resolving globals: FALSE
[16:19:12.510] Tweak future expression to call with '...' arguments ...
[16:19:12.510] {
[16:19:12.510]     do.call(function(...) {
[16:19:12.510]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.510]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.510]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.510]             on.exit(options(oopts), add = TRUE)
[16:19:12.510]         }
[16:19:12.510]         {
[16:19:12.510]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.510]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.510]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.510]             })
[16:19:12.510]         }
[16:19:12.510]     }, args = future.call.arguments)
[16:19:12.510] }
[16:19:12.510] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.511] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.511] - packages: [1] ‘future.apply’
[16:19:12.511] getGlobalsAndPackages() ... DONE
[16:19:12.511] run() for ‘Future’ ...
[16:19:12.511] - state: ‘created’
[16:19:12.511] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.512] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.512]   - Field: ‘label’
[16:19:12.512]   - Field: ‘local’
[16:19:12.512]   - Field: ‘owner’
[16:19:12.512]   - Field: ‘envir’
[16:19:12.512]   - Field: ‘packages’
[16:19:12.512]   - Field: ‘gc’
[16:19:12.512]   - Field: ‘conditions’
[16:19:12.512]   - Field: ‘expr’
[16:19:12.513]   - Field: ‘uuid’
[16:19:12.513]   - Field: ‘seed’
[16:19:12.513]   - Field: ‘version’
[16:19:12.513]   - Field: ‘result’
[16:19:12.513]   - Field: ‘asynchronous’
[16:19:12.513]   - Field: ‘calls’
[16:19:12.513]   - Field: ‘globals’
[16:19:12.513]   - Field: ‘stdout’
[16:19:12.513]   - Field: ‘earlySignal’
[16:19:12.513]   - Field: ‘lazy’
[16:19:12.513]   - Field: ‘state’
[16:19:12.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.514] - Launch lazy future ...
[16:19:12.514] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:12.514] Packages needed by future strategies (n = 0): <none>
[16:19:12.514] {
[16:19:12.514]     {
[16:19:12.514]         {
[16:19:12.514]             ...future.startTime <- base::Sys.time()
[16:19:12.514]             {
[16:19:12.514]                 {
[16:19:12.514]                   {
[16:19:12.514]                     {
[16:19:12.514]                       base::local({
[16:19:12.514]                         has_future <- base::requireNamespace("future", 
[16:19:12.514]                           quietly = TRUE)
[16:19:12.514]                         if (has_future) {
[16:19:12.514]                           ns <- base::getNamespace("future")
[16:19:12.514]                           version <- ns[[".package"]][["version"]]
[16:19:12.514]                           if (is.null(version)) 
[16:19:12.514]                             version <- utils::packageVersion("future")
[16:19:12.514]                         }
[16:19:12.514]                         else {
[16:19:12.514]                           version <- NULL
[16:19:12.514]                         }
[16:19:12.514]                         if (!has_future || version < "1.8.0") {
[16:19:12.514]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.514]                             "", base::R.version$version.string), 
[16:19:12.514]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.514]                               "release", "version")], collapse = " "), 
[16:19:12.514]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.514]                             info)
[16:19:12.514]                           info <- base::paste(info, collapse = "; ")
[16:19:12.514]                           if (!has_future) {
[16:19:12.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.514]                               info)
[16:19:12.514]                           }
[16:19:12.514]                           else {
[16:19:12.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.514]                               info, version)
[16:19:12.514]                           }
[16:19:12.514]                           base::stop(msg)
[16:19:12.514]                         }
[16:19:12.514]                       })
[16:19:12.514]                     }
[16:19:12.514]                     base::local({
[16:19:12.514]                       for (pkg in "future.apply") {
[16:19:12.514]                         base::loadNamespace(pkg)
[16:19:12.514]                         base::library(pkg, character.only = TRUE)
[16:19:12.514]                       }
[16:19:12.514]                     })
[16:19:12.514]                   }
[16:19:12.514]                   ...future.strategy.old <- future::plan("list")
[16:19:12.514]                   options(future.plan = NULL)
[16:19:12.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.514]                 }
[16:19:12.514]                 ...future.workdir <- getwd()
[16:19:12.514]             }
[16:19:12.514]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.514]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.514]         }
[16:19:12.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.514]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.514]             base::names(...future.oldOptions))
[16:19:12.514]     }
[16:19:12.514]     if (FALSE) {
[16:19:12.514]     }
[16:19:12.514]     else {
[16:19:12.514]         if (TRUE) {
[16:19:12.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.514]                 open = "w")
[16:19:12.514]         }
[16:19:12.514]         else {
[16:19:12.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.514]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.514]         }
[16:19:12.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.514]             base::sink(type = "output", split = FALSE)
[16:19:12.514]             base::close(...future.stdout)
[16:19:12.514]         }, add = TRUE)
[16:19:12.514]     }
[16:19:12.514]     ...future.frame <- base::sys.nframe()
[16:19:12.514]     ...future.conditions <- base::list()
[16:19:12.514]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.514]     if (FALSE) {
[16:19:12.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.514]     }
[16:19:12.514]     ...future.result <- base::tryCatch({
[16:19:12.514]         base::withCallingHandlers({
[16:19:12.514]             ...future.value <- base::withVisible(base::local({
[16:19:12.514]                 do.call(function(...) {
[16:19:12.514]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.514]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.514]                     ...future.globals.maxSize)) {
[16:19:12.514]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.514]                     on.exit(options(oopts), add = TRUE)
[16:19:12.514]                   }
[16:19:12.514]                   {
[16:19:12.514]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.514]                       FUN = function(jj) {
[16:19:12.514]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.514]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.514]                       })
[16:19:12.514]                   }
[16:19:12.514]                 }, args = future.call.arguments)
[16:19:12.514]             }))
[16:19:12.514]             future::FutureResult(value = ...future.value$value, 
[16:19:12.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.514]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.514]                     ...future.globalenv.names))
[16:19:12.514]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.514]         }, condition = base::local({
[16:19:12.514]             c <- base::c
[16:19:12.514]             inherits <- base::inherits
[16:19:12.514]             invokeRestart <- base::invokeRestart
[16:19:12.514]             length <- base::length
[16:19:12.514]             list <- base::list
[16:19:12.514]             seq.int <- base::seq.int
[16:19:12.514]             signalCondition <- base::signalCondition
[16:19:12.514]             sys.calls <- base::sys.calls
[16:19:12.514]             `[[` <- base::`[[`
[16:19:12.514]             `+` <- base::`+`
[16:19:12.514]             `<<-` <- base::`<<-`
[16:19:12.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.514]                   3L)]
[16:19:12.514]             }
[16:19:12.514]             function(cond) {
[16:19:12.514]                 is_error <- inherits(cond, "error")
[16:19:12.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.514]                   NULL)
[16:19:12.514]                 if (is_error) {
[16:19:12.514]                   sessionInformation <- function() {
[16:19:12.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.514]                       search = base::search(), system = base::Sys.info())
[16:19:12.514]                   }
[16:19:12.514]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.514]                     cond$call), session = sessionInformation(), 
[16:19:12.514]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.514]                   signalCondition(cond)
[16:19:12.514]                 }
[16:19:12.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.514]                 "immediateCondition"))) {
[16:19:12.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.514]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.514]                   if (TRUE && !signal) {
[16:19:12.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.514]                     {
[16:19:12.514]                       inherits <- base::inherits
[16:19:12.514]                       invokeRestart <- base::invokeRestart
[16:19:12.514]                       is.null <- base::is.null
[16:19:12.514]                       muffled <- FALSE
[16:19:12.514]                       if (inherits(cond, "message")) {
[16:19:12.514]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.514]                         if (muffled) 
[16:19:12.514]                           invokeRestart("muffleMessage")
[16:19:12.514]                       }
[16:19:12.514]                       else if (inherits(cond, "warning")) {
[16:19:12.514]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.514]                         if (muffled) 
[16:19:12.514]                           invokeRestart("muffleWarning")
[16:19:12.514]                       }
[16:19:12.514]                       else if (inherits(cond, "condition")) {
[16:19:12.514]                         if (!is.null(pattern)) {
[16:19:12.514]                           computeRestarts <- base::computeRestarts
[16:19:12.514]                           grepl <- base::grepl
[16:19:12.514]                           restarts <- computeRestarts(cond)
[16:19:12.514]                           for (restart in restarts) {
[16:19:12.514]                             name <- restart$name
[16:19:12.514]                             if (is.null(name)) 
[16:19:12.514]                               next
[16:19:12.514]                             if (!grepl(pattern, name)) 
[16:19:12.514]                               next
[16:19:12.514]                             invokeRestart(restart)
[16:19:12.514]                             muffled <- TRUE
[16:19:12.514]                             break
[16:19:12.514]                           }
[16:19:12.514]                         }
[16:19:12.514]                       }
[16:19:12.514]                       invisible(muffled)
[16:19:12.514]                     }
[16:19:12.514]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.514]                   }
[16:19:12.514]                 }
[16:19:12.514]                 else {
[16:19:12.514]                   if (TRUE) {
[16:19:12.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.514]                     {
[16:19:12.514]                       inherits <- base::inherits
[16:19:12.514]                       invokeRestart <- base::invokeRestart
[16:19:12.514]                       is.null <- base::is.null
[16:19:12.514]                       muffled <- FALSE
[16:19:12.514]                       if (inherits(cond, "message")) {
[16:19:12.514]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.514]                         if (muffled) 
[16:19:12.514]                           invokeRestart("muffleMessage")
[16:19:12.514]                       }
[16:19:12.514]                       else if (inherits(cond, "warning")) {
[16:19:12.514]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.514]                         if (muffled) 
[16:19:12.514]                           invokeRestart("muffleWarning")
[16:19:12.514]                       }
[16:19:12.514]                       else if (inherits(cond, "condition")) {
[16:19:12.514]                         if (!is.null(pattern)) {
[16:19:12.514]                           computeRestarts <- base::computeRestarts
[16:19:12.514]                           grepl <- base::grepl
[16:19:12.514]                           restarts <- computeRestarts(cond)
[16:19:12.514]                           for (restart in restarts) {
[16:19:12.514]                             name <- restart$name
[16:19:12.514]                             if (is.null(name)) 
[16:19:12.514]                               next
[16:19:12.514]                             if (!grepl(pattern, name)) 
[16:19:12.514]                               next
[16:19:12.514]                             invokeRestart(restart)
[16:19:12.514]                             muffled <- TRUE
[16:19:12.514]                             break
[16:19:12.514]                           }
[16:19:12.514]                         }
[16:19:12.514]                       }
[16:19:12.514]                       invisible(muffled)
[16:19:12.514]                     }
[16:19:12.514]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.514]                   }
[16:19:12.514]                 }
[16:19:12.514]             }
[16:19:12.514]         }))
[16:19:12.514]     }, error = function(ex) {
[16:19:12.514]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.514]                 ...future.rng), started = ...future.startTime, 
[16:19:12.514]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.514]             version = "1.8"), class = "FutureResult")
[16:19:12.514]     }, finally = {
[16:19:12.514]         if (!identical(...future.workdir, getwd())) 
[16:19:12.514]             setwd(...future.workdir)
[16:19:12.514]         {
[16:19:12.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.514]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.514]             }
[16:19:12.514]             base::options(...future.oldOptions)
[16:19:12.514]             if (.Platform$OS.type == "windows") {
[16:19:12.514]                 old_names <- names(...future.oldEnvVars)
[16:19:12.514]                 envs <- base::Sys.getenv()
[16:19:12.514]                 names <- names(envs)
[16:19:12.514]                 common <- intersect(names, old_names)
[16:19:12.514]                 added <- setdiff(names, old_names)
[16:19:12.514]                 removed <- setdiff(old_names, names)
[16:19:12.514]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.514]                   envs[common]]
[16:19:12.514]                 NAMES <- toupper(changed)
[16:19:12.514]                 args <- list()
[16:19:12.514]                 for (kk in seq_along(NAMES)) {
[16:19:12.514]                   name <- changed[[kk]]
[16:19:12.514]                   NAME <- NAMES[[kk]]
[16:19:12.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.514]                     next
[16:19:12.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.514]                 }
[16:19:12.514]                 NAMES <- toupper(added)
[16:19:12.514]                 for (kk in seq_along(NAMES)) {
[16:19:12.514]                   name <- added[[kk]]
[16:19:12.514]                   NAME <- NAMES[[kk]]
[16:19:12.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.514]                     next
[16:19:12.514]                   args[[name]] <- ""
[16:19:12.514]                 }
[16:19:12.514]                 NAMES <- toupper(removed)
[16:19:12.514]                 for (kk in seq_along(NAMES)) {
[16:19:12.514]                   name <- removed[[kk]]
[16:19:12.514]                   NAME <- NAMES[[kk]]
[16:19:12.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.514]                     next
[16:19:12.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.514]                 }
[16:19:12.514]                 if (length(args) > 0) 
[16:19:12.514]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.514]             }
[16:19:12.514]             else {
[16:19:12.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.514]             }
[16:19:12.514]             {
[16:19:12.514]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.514]                   0L) {
[16:19:12.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.514]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.514]                   base::options(opts)
[16:19:12.514]                 }
[16:19:12.514]                 {
[16:19:12.514]                   {
[16:19:12.514]                     NULL
[16:19:12.514]                     RNGkind("Mersenne-Twister")
[16:19:12.514]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.514]                       inherits = FALSE)
[16:19:12.514]                   }
[16:19:12.514]                   options(future.plan = NULL)
[16:19:12.514]                   if (is.na(NA_character_)) 
[16:19:12.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.514]                     .init = FALSE)
[16:19:12.514]                 }
[16:19:12.514]             }
[16:19:12.514]         }
[16:19:12.514]     })
[16:19:12.514]     if (TRUE) {
[16:19:12.514]         base::sink(type = "output", split = FALSE)
[16:19:12.514]         if (TRUE) {
[16:19:12.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.514]         }
[16:19:12.514]         else {
[16:19:12.514]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.514]         }
[16:19:12.514]         base::close(...future.stdout)
[16:19:12.514]         ...future.stdout <- NULL
[16:19:12.514]     }
[16:19:12.514]     ...future.result$conditions <- ...future.conditions
[16:19:12.514]     ...future.result$finished <- base::Sys.time()
[16:19:12.514]     ...future.result
[16:19:12.514] }
[16:19:12.516] assign_globals() ...
[16:19:12.516] List of 11
[16:19:12.516]  $ ...future.FUN            :function (x, ...)  
[16:19:12.516]  $ x_FUN                    :function (x)  
[16:19:12.516]  $ times                    : int 0
[16:19:12.516]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.516]  $ stop_if_not              :function (...)  
[16:19:12.516]  $ dim                      : NULL
[16:19:12.516]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:12.516]  $ future.call.arguments    : list()
[16:19:12.516]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.516]  $ ...future.elements_ii    :List of 10
[16:19:12.516]   ..$ : int 1
[16:19:12.516]   ..$ : int 2
[16:19:12.516]   ..$ : int 3
[16:19:12.516]   ..$ : int 4
[16:19:12.516]   ..$ : int 5
[16:19:12.516]   ..$ : int 6
[16:19:12.516]   ..$ : int 7
[16:19:12.516]   ..$ : int 8
[16:19:12.516]   ..$ : int 9
[16:19:12.516]   ..$ : int 10
[16:19:12.516]  $ ...future.seeds_ii       : NULL
[16:19:12.516]  $ ...future.globals.maxSize: NULL
[16:19:12.516]  - attr(*, "where")=List of 11
[16:19:12.516]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.516]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.516]  - attr(*, "resolved")= logi FALSE
[16:19:12.516]  - attr(*, "total_size")= num 95472
[16:19:12.516]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.516]  - attr(*, "already-done")= logi TRUE
[16:19:12.526] - copied ‘...future.FUN’ to environment
[16:19:12.526] - reassign environment for ‘x_FUN’
[16:19:12.526] - copied ‘x_FUN’ to environment
[16:19:12.526] - copied ‘times’ to environment
[16:19:12.526] - copied ‘stopf’ to environment
[16:19:12.526] - copied ‘stop_if_not’ to environment
[16:19:12.526] - copied ‘dim’ to environment
[16:19:12.526] - copied ‘valid_types’ to environment
[16:19:12.527] - copied ‘future.call.arguments’ to environment
[16:19:12.527] - copied ‘...future.elements_ii’ to environment
[16:19:12.527] - copied ‘...future.seeds_ii’ to environment
[16:19:12.527] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.527] assign_globals() ... done
[16:19:12.527] plan(): Setting new future strategy stack:
[16:19:12.527] List of future strategies:
[16:19:12.527] 1. sequential:
[16:19:12.527]    - args: function (..., envir = parent.frame())
[16:19:12.527]    - tweaked: FALSE
[16:19:12.527]    - call: NULL
[16:19:12.528] plan(): nbrOfWorkers() = 1
[16:19:12.530] plan(): Setting new future strategy stack:
[16:19:12.530] List of future strategies:
[16:19:12.530] 1. sequential:
[16:19:12.530]    - args: function (..., envir = parent.frame())
[16:19:12.530]    - tweaked: FALSE
[16:19:12.530]    - call: plan(strategy)
[16:19:12.530] plan(): nbrOfWorkers() = 1
[16:19:12.531] SequentialFuture started (and completed)
[16:19:12.531] - Launch lazy future ... done
[16:19:12.531] run() for ‘SequentialFuture’ ... done
[16:19:12.531] Created future:
[16:19:12.531] SequentialFuture:
[16:19:12.531] Label: ‘future_vapply-1’
[16:19:12.531] Expression:
[16:19:12.531] {
[16:19:12.531]     do.call(function(...) {
[16:19:12.531]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.531]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.531]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.531]             on.exit(options(oopts), add = TRUE)
[16:19:12.531]         }
[16:19:12.531]         {
[16:19:12.531]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.531]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.531]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.531]             })
[16:19:12.531]         }
[16:19:12.531]     }, args = future.call.arguments)
[16:19:12.531] }
[16:19:12.531] Lazy evaluation: FALSE
[16:19:12.531] Asynchronous evaluation: FALSE
[16:19:12.531] Local evaluation: TRUE
[16:19:12.531] Environment: R_GlobalEnv
[16:19:12.531] Capture standard output: TRUE
[16:19:12.531] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.531] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.531] Packages: 1 packages (‘future.apply’)
[16:19:12.531] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.531] Resolved: TRUE
[16:19:12.531] Value: 480 bytes of class ‘list’
[16:19:12.531] Early signaling: FALSE
[16:19:12.531] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.531] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.532] Chunk #1 of 1 ... DONE
[16:19:12.532] Launching 1 futures (chunks) ... DONE
[16:19:12.532] Resolving 1 futures (chunks) ...
[16:19:12.532] resolve() on list ...
[16:19:12.533]  recursive: 0
[16:19:12.533]  length: 1
[16:19:12.533] 
[16:19:12.533] resolved() for ‘SequentialFuture’ ...
[16:19:12.533] - state: ‘finished’
[16:19:12.533] - run: TRUE
[16:19:12.533] - result: ‘FutureResult’
[16:19:12.533] resolved() for ‘SequentialFuture’ ... done
[16:19:12.533] Future #1
[16:19:12.533] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.534] - nx: 1
[16:19:12.534] - relay: TRUE
[16:19:12.534] - stdout: TRUE
[16:19:12.534] - signal: TRUE
[16:19:12.534] - resignal: FALSE
[16:19:12.534] - force: TRUE
[16:19:12.534] - relayed: [n=1] FALSE
[16:19:12.534] - queued futures: [n=1] FALSE
[16:19:12.534]  - until=1
[16:19:12.534]  - relaying element #1
[16:19:12.535] - relayed: [n=1] TRUE
[16:19:12.535] - queued futures: [n=1] TRUE
[16:19:12.535] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.535]  length: 0 (resolved future 1)
[16:19:12.535] Relaying remaining futures
[16:19:12.535] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.535] - nx: 1
[16:19:12.535] - relay: TRUE
[16:19:12.535] - stdout: TRUE
[16:19:12.535] - signal: TRUE
[16:19:12.535] - resignal: FALSE
[16:19:12.535] - force: TRUE
[16:19:12.536] - relayed: [n=1] TRUE
[16:19:12.536] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.536] - relayed: [n=1] TRUE
[16:19:12.536] - queued futures: [n=1] TRUE
[16:19:12.536] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.536] resolve() on list ... DONE
[16:19:12.536]  - Number of value chunks collected: 1
[16:19:12.536] Resolving 1 futures (chunks) ... DONE
[16:19:12.536] Reducing values from 1 chunks ...
[16:19:12.536]  - Number of values collected after concatenation: 10
[16:19:12.537]  - Number of values expected: 10
[16:19:12.537] Reducing values from 1 chunks ... DONE
[16:19:12.537] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:19:12.538] future_lapply() ...
[16:19:12.539] Number of chunks: 1
[16:19:12.539] getGlobalsAndPackagesXApply() ...
[16:19:12.539]  - future.globals: TRUE
[16:19:12.540] getGlobalsAndPackages() ...
[16:19:12.540] Searching for globals...
[16:19:12.543] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:19:12.543] Searching for globals ... DONE
[16:19:12.543] Resolving globals: FALSE
[16:19:12.544] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:19:12.544] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.544] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.545] - packages: [1] ‘future.apply’
[16:19:12.545] getGlobalsAndPackages() ... DONE
[16:19:12.545]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.545]  - needed namespaces: [n=1] ‘future.apply’
[16:19:12.545] Finding globals ... DONE
[16:19:12.545]  - use_args: TRUE
[16:19:12.545]  - Getting '...' globals ...
[16:19:12.545] resolve() on list ...
[16:19:12.545]  recursive: 0
[16:19:12.546]  length: 1
[16:19:12.546]  elements: ‘...’
[16:19:12.546]  length: 0 (resolved future 1)
[16:19:12.546] resolve() on list ... DONE
[16:19:12.546]    - '...' content: [n=0] 
[16:19:12.546] List of 1
[16:19:12.546]  $ ...: list()
[16:19:12.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.546]  - attr(*, "where")=List of 1
[16:19:12.546]   ..$ ...:<environment: 0x56199e9d6098> 
[16:19:12.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.546]  - attr(*, "resolved")= logi TRUE
[16:19:12.546]  - attr(*, "total_size")= num NA
[16:19:12.548]  - Getting '...' globals ... DONE
[16:19:12.549] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.549] List of 8
[16:19:12.549]  $ ...future.FUN:function (x, ...)  
[16:19:12.549]  $ x_FUN        :function (x)  
[16:19:12.549]  $ times        : int 0
[16:19:12.549]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.549]  $ stop_if_not  :function (...)  
[16:19:12.549]  $ dim          : NULL
[16:19:12.549]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:12.549]  $ ...          : list()
[16:19:12.549]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.549]  - attr(*, "where")=List of 8
[16:19:12.549]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.549]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.549]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.549]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.549]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.549]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.549]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.549]   ..$ ...          :<environment: 0x56199e9d6098> 
[16:19:12.549]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.549]  - attr(*, "resolved")= logi FALSE
[16:19:12.549]  - attr(*, "total_size")= num 95400
[16:19:12.555] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:12.555] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.556] Number of futures (= number of chunks): 1
[16:19:12.556] Launching 1 futures (chunks) ...
[16:19:12.556] Chunk #1 of 1 ...
[16:19:12.556]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.556] getGlobalsAndPackages() ...
[16:19:12.556] Searching for globals...
[16:19:12.556] 
[16:19:12.556] Searching for globals ... DONE
[16:19:12.556] - globals: [0] <none>
[16:19:12.557] getGlobalsAndPackages() ... DONE
[16:19:12.557]    + additional globals found: [n=0] 
[16:19:12.557]    + additional namespaces needed: [n=0] 
[16:19:12.557]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.557]  - seeds: <none>
[16:19:12.557]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.557] getGlobalsAndPackages() ...
[16:19:12.557] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.557] Resolving globals: FALSE
[16:19:12.557] Tweak future expression to call with '...' arguments ...
[16:19:12.558] {
[16:19:12.558]     do.call(function(...) {
[16:19:12.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.558]             on.exit(options(oopts), add = TRUE)
[16:19:12.558]         }
[16:19:12.558]         {
[16:19:12.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.558]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.558]             })
[16:19:12.558]         }
[16:19:12.558]     }, args = future.call.arguments)
[16:19:12.558] }
[16:19:12.558] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.558] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.558] - packages: [1] ‘future.apply’
[16:19:12.559] getGlobalsAndPackages() ... DONE
[16:19:12.559] run() for ‘Future’ ...
[16:19:12.559] - state: ‘created’
[16:19:12.559] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.559] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.560]   - Field: ‘label’
[16:19:12.560]   - Field: ‘local’
[16:19:12.560]   - Field: ‘owner’
[16:19:12.560]   - Field: ‘envir’
[16:19:12.560]   - Field: ‘packages’
[16:19:12.560]   - Field: ‘gc’
[16:19:12.560]   - Field: ‘conditions’
[16:19:12.560]   - Field: ‘expr’
[16:19:12.560]   - Field: ‘uuid’
[16:19:12.560]   - Field: ‘seed’
[16:19:12.560]   - Field: ‘version’
[16:19:12.561]   - Field: ‘result’
[16:19:12.561]   - Field: ‘asynchronous’
[16:19:12.561]   - Field: ‘calls’
[16:19:12.561]   - Field: ‘globals’
[16:19:12.561]   - Field: ‘stdout’
[16:19:12.561]   - Field: ‘earlySignal’
[16:19:12.561]   - Field: ‘lazy’
[16:19:12.561]   - Field: ‘state’
[16:19:12.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.561] - Launch lazy future ...
[16:19:12.562] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:12.562] Packages needed by future strategies (n = 0): <none>
[16:19:12.562] {
[16:19:12.562]     {
[16:19:12.562]         {
[16:19:12.562]             ...future.startTime <- base::Sys.time()
[16:19:12.562]             {
[16:19:12.562]                 {
[16:19:12.562]                   {
[16:19:12.562]                     {
[16:19:12.562]                       base::local({
[16:19:12.562]                         has_future <- base::requireNamespace("future", 
[16:19:12.562]                           quietly = TRUE)
[16:19:12.562]                         if (has_future) {
[16:19:12.562]                           ns <- base::getNamespace("future")
[16:19:12.562]                           version <- ns[[".package"]][["version"]]
[16:19:12.562]                           if (is.null(version)) 
[16:19:12.562]                             version <- utils::packageVersion("future")
[16:19:12.562]                         }
[16:19:12.562]                         else {
[16:19:12.562]                           version <- NULL
[16:19:12.562]                         }
[16:19:12.562]                         if (!has_future || version < "1.8.0") {
[16:19:12.562]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.562]                             "", base::R.version$version.string), 
[16:19:12.562]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.562]                               "release", "version")], collapse = " "), 
[16:19:12.562]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.562]                             info)
[16:19:12.562]                           info <- base::paste(info, collapse = "; ")
[16:19:12.562]                           if (!has_future) {
[16:19:12.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.562]                               info)
[16:19:12.562]                           }
[16:19:12.562]                           else {
[16:19:12.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.562]                               info, version)
[16:19:12.562]                           }
[16:19:12.562]                           base::stop(msg)
[16:19:12.562]                         }
[16:19:12.562]                       })
[16:19:12.562]                     }
[16:19:12.562]                     base::local({
[16:19:12.562]                       for (pkg in "future.apply") {
[16:19:12.562]                         base::loadNamespace(pkg)
[16:19:12.562]                         base::library(pkg, character.only = TRUE)
[16:19:12.562]                       }
[16:19:12.562]                     })
[16:19:12.562]                   }
[16:19:12.562]                   ...future.strategy.old <- future::plan("list")
[16:19:12.562]                   options(future.plan = NULL)
[16:19:12.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.562]                 }
[16:19:12.562]                 ...future.workdir <- getwd()
[16:19:12.562]             }
[16:19:12.562]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.562]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.562]         }
[16:19:12.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.562]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.562]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.562]             base::names(...future.oldOptions))
[16:19:12.562]     }
[16:19:12.562]     if (FALSE) {
[16:19:12.562]     }
[16:19:12.562]     else {
[16:19:12.562]         if (TRUE) {
[16:19:12.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.562]                 open = "w")
[16:19:12.562]         }
[16:19:12.562]         else {
[16:19:12.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.562]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.562]         }
[16:19:12.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.562]             base::sink(type = "output", split = FALSE)
[16:19:12.562]             base::close(...future.stdout)
[16:19:12.562]         }, add = TRUE)
[16:19:12.562]     }
[16:19:12.562]     ...future.frame <- base::sys.nframe()
[16:19:12.562]     ...future.conditions <- base::list()
[16:19:12.562]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.562]     if (FALSE) {
[16:19:12.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.562]     }
[16:19:12.562]     ...future.result <- base::tryCatch({
[16:19:12.562]         base::withCallingHandlers({
[16:19:12.562]             ...future.value <- base::withVisible(base::local({
[16:19:12.562]                 do.call(function(...) {
[16:19:12.562]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.562]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.562]                     ...future.globals.maxSize)) {
[16:19:12.562]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.562]                     on.exit(options(oopts), add = TRUE)
[16:19:12.562]                   }
[16:19:12.562]                   {
[16:19:12.562]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.562]                       FUN = function(jj) {
[16:19:12.562]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.562]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.562]                       })
[16:19:12.562]                   }
[16:19:12.562]                 }, args = future.call.arguments)
[16:19:12.562]             }))
[16:19:12.562]             future::FutureResult(value = ...future.value$value, 
[16:19:12.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.562]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.562]                     ...future.globalenv.names))
[16:19:12.562]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.562]         }, condition = base::local({
[16:19:12.562]             c <- base::c
[16:19:12.562]             inherits <- base::inherits
[16:19:12.562]             invokeRestart <- base::invokeRestart
[16:19:12.562]             length <- base::length
[16:19:12.562]             list <- base::list
[16:19:12.562]             seq.int <- base::seq.int
[16:19:12.562]             signalCondition <- base::signalCondition
[16:19:12.562]             sys.calls <- base::sys.calls
[16:19:12.562]             `[[` <- base::`[[`
[16:19:12.562]             `+` <- base::`+`
[16:19:12.562]             `<<-` <- base::`<<-`
[16:19:12.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.562]                   3L)]
[16:19:12.562]             }
[16:19:12.562]             function(cond) {
[16:19:12.562]                 is_error <- inherits(cond, "error")
[16:19:12.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.562]                   NULL)
[16:19:12.562]                 if (is_error) {
[16:19:12.562]                   sessionInformation <- function() {
[16:19:12.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.562]                       search = base::search(), system = base::Sys.info())
[16:19:12.562]                   }
[16:19:12.562]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.562]                     cond$call), session = sessionInformation(), 
[16:19:12.562]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.562]                   signalCondition(cond)
[16:19:12.562]                 }
[16:19:12.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.562]                 "immediateCondition"))) {
[16:19:12.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.562]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.562]                   if (TRUE && !signal) {
[16:19:12.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.562]                     {
[16:19:12.562]                       inherits <- base::inherits
[16:19:12.562]                       invokeRestart <- base::invokeRestart
[16:19:12.562]                       is.null <- base::is.null
[16:19:12.562]                       muffled <- FALSE
[16:19:12.562]                       if (inherits(cond, "message")) {
[16:19:12.562]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.562]                         if (muffled) 
[16:19:12.562]                           invokeRestart("muffleMessage")
[16:19:12.562]                       }
[16:19:12.562]                       else if (inherits(cond, "warning")) {
[16:19:12.562]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.562]                         if (muffled) 
[16:19:12.562]                           invokeRestart("muffleWarning")
[16:19:12.562]                       }
[16:19:12.562]                       else if (inherits(cond, "condition")) {
[16:19:12.562]                         if (!is.null(pattern)) {
[16:19:12.562]                           computeRestarts <- base::computeRestarts
[16:19:12.562]                           grepl <- base::grepl
[16:19:12.562]                           restarts <- computeRestarts(cond)
[16:19:12.562]                           for (restart in restarts) {
[16:19:12.562]                             name <- restart$name
[16:19:12.562]                             if (is.null(name)) 
[16:19:12.562]                               next
[16:19:12.562]                             if (!grepl(pattern, name)) 
[16:19:12.562]                               next
[16:19:12.562]                             invokeRestart(restart)
[16:19:12.562]                             muffled <- TRUE
[16:19:12.562]                             break
[16:19:12.562]                           }
[16:19:12.562]                         }
[16:19:12.562]                       }
[16:19:12.562]                       invisible(muffled)
[16:19:12.562]                     }
[16:19:12.562]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.562]                   }
[16:19:12.562]                 }
[16:19:12.562]                 else {
[16:19:12.562]                   if (TRUE) {
[16:19:12.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.562]                     {
[16:19:12.562]                       inherits <- base::inherits
[16:19:12.562]                       invokeRestart <- base::invokeRestart
[16:19:12.562]                       is.null <- base::is.null
[16:19:12.562]                       muffled <- FALSE
[16:19:12.562]                       if (inherits(cond, "message")) {
[16:19:12.562]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.562]                         if (muffled) 
[16:19:12.562]                           invokeRestart("muffleMessage")
[16:19:12.562]                       }
[16:19:12.562]                       else if (inherits(cond, "warning")) {
[16:19:12.562]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.562]                         if (muffled) 
[16:19:12.562]                           invokeRestart("muffleWarning")
[16:19:12.562]                       }
[16:19:12.562]                       else if (inherits(cond, "condition")) {
[16:19:12.562]                         if (!is.null(pattern)) {
[16:19:12.562]                           computeRestarts <- base::computeRestarts
[16:19:12.562]                           grepl <- base::grepl
[16:19:12.562]                           restarts <- computeRestarts(cond)
[16:19:12.562]                           for (restart in restarts) {
[16:19:12.562]                             name <- restart$name
[16:19:12.562]                             if (is.null(name)) 
[16:19:12.562]                               next
[16:19:12.562]                             if (!grepl(pattern, name)) 
[16:19:12.562]                               next
[16:19:12.562]                             invokeRestart(restart)
[16:19:12.562]                             muffled <- TRUE
[16:19:12.562]                             break
[16:19:12.562]                           }
[16:19:12.562]                         }
[16:19:12.562]                       }
[16:19:12.562]                       invisible(muffled)
[16:19:12.562]                     }
[16:19:12.562]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.562]                   }
[16:19:12.562]                 }
[16:19:12.562]             }
[16:19:12.562]         }))
[16:19:12.562]     }, error = function(ex) {
[16:19:12.562]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.562]                 ...future.rng), started = ...future.startTime, 
[16:19:12.562]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.562]             version = "1.8"), class = "FutureResult")
[16:19:12.562]     }, finally = {
[16:19:12.562]         if (!identical(...future.workdir, getwd())) 
[16:19:12.562]             setwd(...future.workdir)
[16:19:12.562]         {
[16:19:12.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.562]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.562]             }
[16:19:12.562]             base::options(...future.oldOptions)
[16:19:12.562]             if (.Platform$OS.type == "windows") {
[16:19:12.562]                 old_names <- names(...future.oldEnvVars)
[16:19:12.562]                 envs <- base::Sys.getenv()
[16:19:12.562]                 names <- names(envs)
[16:19:12.562]                 common <- intersect(names, old_names)
[16:19:12.562]                 added <- setdiff(names, old_names)
[16:19:12.562]                 removed <- setdiff(old_names, names)
[16:19:12.562]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.562]                   envs[common]]
[16:19:12.562]                 NAMES <- toupper(changed)
[16:19:12.562]                 args <- list()
[16:19:12.562]                 for (kk in seq_along(NAMES)) {
[16:19:12.562]                   name <- changed[[kk]]
[16:19:12.562]                   NAME <- NAMES[[kk]]
[16:19:12.562]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.562]                     next
[16:19:12.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.562]                 }
[16:19:12.562]                 NAMES <- toupper(added)
[16:19:12.562]                 for (kk in seq_along(NAMES)) {
[16:19:12.562]                   name <- added[[kk]]
[16:19:12.562]                   NAME <- NAMES[[kk]]
[16:19:12.562]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.562]                     next
[16:19:12.562]                   args[[name]] <- ""
[16:19:12.562]                 }
[16:19:12.562]                 NAMES <- toupper(removed)
[16:19:12.562]                 for (kk in seq_along(NAMES)) {
[16:19:12.562]                   name <- removed[[kk]]
[16:19:12.562]                   NAME <- NAMES[[kk]]
[16:19:12.562]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.562]                     next
[16:19:12.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.562]                 }
[16:19:12.562]                 if (length(args) > 0) 
[16:19:12.562]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.562]             }
[16:19:12.562]             else {
[16:19:12.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.562]             }
[16:19:12.562]             {
[16:19:12.562]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.562]                   0L) {
[16:19:12.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.562]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.562]                   base::options(opts)
[16:19:12.562]                 }
[16:19:12.562]                 {
[16:19:12.562]                   {
[16:19:12.562]                     NULL
[16:19:12.562]                     RNGkind("Mersenne-Twister")
[16:19:12.562]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.562]                       inherits = FALSE)
[16:19:12.562]                   }
[16:19:12.562]                   options(future.plan = NULL)
[16:19:12.562]                   if (is.na(NA_character_)) 
[16:19:12.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.562]                     .init = FALSE)
[16:19:12.562]                 }
[16:19:12.562]             }
[16:19:12.562]         }
[16:19:12.562]     })
[16:19:12.562]     if (TRUE) {
[16:19:12.562]         base::sink(type = "output", split = FALSE)
[16:19:12.562]         if (TRUE) {
[16:19:12.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.562]         }
[16:19:12.562]         else {
[16:19:12.562]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.562]         }
[16:19:12.562]         base::close(...future.stdout)
[16:19:12.562]         ...future.stdout <- NULL
[16:19:12.562]     }
[16:19:12.562]     ...future.result$conditions <- ...future.conditions
[16:19:12.562]     ...future.result$finished <- base::Sys.time()
[16:19:12.562]     ...future.result
[16:19:12.562] }
[16:19:12.564] assign_globals() ...
[16:19:12.564] List of 11
[16:19:12.564]  $ ...future.FUN            :function (x, ...)  
[16:19:12.564]  $ x_FUN                    :function (x)  
[16:19:12.564]  $ times                    : int 0
[16:19:12.564]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.564]  $ stop_if_not              :function (...)  
[16:19:12.564]  $ dim                      : NULL
[16:19:12.564]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:12.564]  $ future.call.arguments    : list()
[16:19:12.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.564]  $ ...future.elements_ii    :List of 10
[16:19:12.564]   ..$ : int 1
[16:19:12.564]   ..$ : int 2
[16:19:12.564]   ..$ : int 3
[16:19:12.564]   ..$ : int 4
[16:19:12.564]   ..$ : int 5
[16:19:12.564]   ..$ : int 6
[16:19:12.564]   ..$ : int 7
[16:19:12.564]   ..$ : int 8
[16:19:12.564]   ..$ : int 9
[16:19:12.564]   ..$ : int 10
[16:19:12.564]  $ ...future.seeds_ii       : NULL
[16:19:12.564]  $ ...future.globals.maxSize: NULL
[16:19:12.564]  - attr(*, "where")=List of 11
[16:19:12.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.564]  - attr(*, "resolved")= logi FALSE
[16:19:12.564]  - attr(*, "total_size")= num 95400
[16:19:12.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.564]  - attr(*, "already-done")= logi TRUE
[16:19:12.575] - copied ‘...future.FUN’ to environment
[16:19:12.575] - reassign environment for ‘x_FUN’
[16:19:12.575] - copied ‘x_FUN’ to environment
[16:19:12.576] - copied ‘times’ to environment
[16:19:12.576] - copied ‘stopf’ to environment
[16:19:12.576] - copied ‘stop_if_not’ to environment
[16:19:12.576] - copied ‘dim’ to environment
[16:19:12.576] - copied ‘valid_types’ to environment
[16:19:12.576] - copied ‘future.call.arguments’ to environment
[16:19:12.576] - copied ‘...future.elements_ii’ to environment
[16:19:12.576] - copied ‘...future.seeds_ii’ to environment
[16:19:12.576] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.576] assign_globals() ... done
[16:19:12.577] plan(): Setting new future strategy stack:
[16:19:12.577] List of future strategies:
[16:19:12.577] 1. sequential:
[16:19:12.577]    - args: function (..., envir = parent.frame())
[16:19:12.577]    - tweaked: FALSE
[16:19:12.577]    - call: NULL
[16:19:12.577] plan(): nbrOfWorkers() = 1
[16:19:12.578] plan(): Setting new future strategy stack:
[16:19:12.578] List of future strategies:
[16:19:12.578] 1. sequential:
[16:19:12.578]    - args: function (..., envir = parent.frame())
[16:19:12.578]    - tweaked: FALSE
[16:19:12.578]    - call: plan(strategy)
[16:19:12.578] plan(): nbrOfWorkers() = 1
[16:19:12.579] SequentialFuture started (and completed)
[16:19:12.579] - Launch lazy future ... done
[16:19:12.579] run() for ‘SequentialFuture’ ... done
[16:19:12.579] Created future:
[16:19:12.579] SequentialFuture:
[16:19:12.579] Label: ‘future_vapply-1’
[16:19:12.579] Expression:
[16:19:12.579] {
[16:19:12.579]     do.call(function(...) {
[16:19:12.579]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.579]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.579]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.579]             on.exit(options(oopts), add = TRUE)
[16:19:12.579]         }
[16:19:12.579]         {
[16:19:12.579]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.579]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.579]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.579]             })
[16:19:12.579]         }
[16:19:12.579]     }, args = future.call.arguments)
[16:19:12.579] }
[16:19:12.579] Lazy evaluation: FALSE
[16:19:12.579] Asynchronous evaluation: FALSE
[16:19:12.579] Local evaluation: TRUE
[16:19:12.579] Environment: R_GlobalEnv
[16:19:12.579] Capture standard output: TRUE
[16:19:12.579] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.579] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.579] Packages: 1 packages (‘future.apply’)
[16:19:12.579] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.579] Resolved: TRUE
[16:19:12.579] Value: 480 bytes of class ‘list’
[16:19:12.579] Early signaling: FALSE
[16:19:12.579] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.579] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.580] Chunk #1 of 1 ... DONE
[16:19:12.580] Launching 1 futures (chunks) ... DONE
[16:19:12.580] Resolving 1 futures (chunks) ...
[16:19:12.581] resolve() on list ...
[16:19:12.581]  recursive: 0
[16:19:12.581]  length: 1
[16:19:12.581] 
[16:19:12.581] resolved() for ‘SequentialFuture’ ...
[16:19:12.581] - state: ‘finished’
[16:19:12.581] - run: TRUE
[16:19:12.581] - result: ‘FutureResult’
[16:19:12.581] resolved() for ‘SequentialFuture’ ... done
[16:19:12.581] Future #1
[16:19:12.581] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.582] - nx: 1
[16:19:12.582] - relay: TRUE
[16:19:12.582] - stdout: TRUE
[16:19:12.582] - signal: TRUE
[16:19:12.582] - resignal: FALSE
[16:19:12.582] - force: TRUE
[16:19:12.582] - relayed: [n=1] FALSE
[16:19:12.582] - queued futures: [n=1] FALSE
[16:19:12.582]  - until=1
[16:19:12.582]  - relaying element #1
[16:19:12.582] - relayed: [n=1] TRUE
[16:19:12.583] - queued futures: [n=1] TRUE
[16:19:12.583] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.583]  length: 0 (resolved future 1)
[16:19:12.583] Relaying remaining futures
[16:19:12.583] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.583] - nx: 1
[16:19:12.583] - relay: TRUE
[16:19:12.583] - stdout: TRUE
[16:19:12.583] - signal: TRUE
[16:19:12.583] - resignal: FALSE
[16:19:12.583] - force: TRUE
[16:19:12.583] - relayed: [n=1] TRUE
[16:19:12.584] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.584] - relayed: [n=1] TRUE
[16:19:12.584] - queued futures: [n=1] TRUE
[16:19:12.584] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.584] resolve() on list ... DONE
[16:19:12.584]  - Number of value chunks collected: 1
[16:19:12.584] Resolving 1 futures (chunks) ... DONE
[16:19:12.584] Reducing values from 1 chunks ...
[16:19:12.584]  - Number of values collected after concatenation: 10
[16:19:12.584]  - Number of values expected: 10
[16:19:12.585] Reducing values from 1 chunks ... DONE
[16:19:12.585] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:19:12.585] future_lapply() ...
[16:19:12.587] Number of chunks: 1
[16:19:12.587] getGlobalsAndPackagesXApply() ...
[16:19:12.587]  - future.globals: TRUE
[16:19:12.587] getGlobalsAndPackages() ...
[16:19:12.587] Searching for globals...
[16:19:12.590] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:12.590] Searching for globals ... DONE
[16:19:12.590] Resolving globals: FALSE
[16:19:12.591] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:19:12.592] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.592] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.592] - packages: [1] ‘future.apply’
[16:19:12.592] getGlobalsAndPackages() ... DONE
[16:19:12.592]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.592]  - needed namespaces: [n=1] ‘future.apply’
[16:19:12.592] Finding globals ... DONE
[16:19:12.592]  - use_args: TRUE
[16:19:12.593]  - Getting '...' globals ...
[16:19:12.593] resolve() on list ...
[16:19:12.593]  recursive: 0
[16:19:12.593]  length: 1
[16:19:12.593]  elements: ‘...’
[16:19:12.593]  length: 0 (resolved future 1)
[16:19:12.593] resolve() on list ... DONE
[16:19:12.593]    - '...' content: [n=0] 
[16:19:12.594] List of 1
[16:19:12.594]  $ ...: list()
[16:19:12.594]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.594]  - attr(*, "where")=List of 1
[16:19:12.594]   ..$ ...:<environment: 0x56199f0b0460> 
[16:19:12.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.594]  - attr(*, "resolved")= logi TRUE
[16:19:12.594]  - attr(*, "total_size")= num NA
[16:19:12.597]  - Getting '...' globals ... DONE
[16:19:12.597] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.598] List of 8
[16:19:12.598]  $ ...future.FUN:function (x, ...)  
[16:19:12.598]  $ x_FUN        :function (x)  
[16:19:12.598]  $ times        : int 1
[16:19:12.598]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.598]  $ stop_if_not  :function (...)  
[16:19:12.598]  $ dim          : NULL
[16:19:12.598]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:12.598]  $ ...          : list()
[16:19:12.598]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.598]  - attr(*, "where")=List of 8
[16:19:12.598]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.598]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.598]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.598]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.598]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.598]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.598]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.598]   ..$ ...          :<environment: 0x56199f0b0460> 
[16:19:12.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.598]  - attr(*, "resolved")= logi FALSE
[16:19:12.598]  - attr(*, "total_size")= num 94336
[16:19:12.603] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:12.603] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.603] Number of futures (= number of chunks): 1
[16:19:12.603] Launching 1 futures (chunks) ...
[16:19:12.603] Chunk #1 of 1 ...
[16:19:12.603]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.603] getGlobalsAndPackages() ...
[16:19:12.604] Searching for globals...
[16:19:12.604] 
[16:19:12.604] Searching for globals ... DONE
[16:19:12.604] - globals: [0] <none>
[16:19:12.604] getGlobalsAndPackages() ... DONE
[16:19:12.604]    + additional globals found: [n=0] 
[16:19:12.604]    + additional namespaces needed: [n=0] 
[16:19:12.604]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.604]  - seeds: <none>
[16:19:12.605]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.605] getGlobalsAndPackages() ...
[16:19:12.605] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.605] Resolving globals: FALSE
[16:19:12.605] Tweak future expression to call with '...' arguments ...
[16:19:12.605] {
[16:19:12.605]     do.call(function(...) {
[16:19:12.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.605]             on.exit(options(oopts), add = TRUE)
[16:19:12.605]         }
[16:19:12.605]         {
[16:19:12.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.605]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.605]             })
[16:19:12.605]         }
[16:19:12.605]     }, args = future.call.arguments)
[16:19:12.605] }
[16:19:12.605] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.606] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.606] - packages: [1] ‘future.apply’
[16:19:12.606] getGlobalsAndPackages() ... DONE
[16:19:12.606] run() for ‘Future’ ...
[16:19:12.606] - state: ‘created’
[16:19:12.607] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.607] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.607]   - Field: ‘label’
[16:19:12.607]   - Field: ‘local’
[16:19:12.607]   - Field: ‘owner’
[16:19:12.607]   - Field: ‘envir’
[16:19:12.607]   - Field: ‘packages’
[16:19:12.607]   - Field: ‘gc’
[16:19:12.608]   - Field: ‘conditions’
[16:19:12.608]   - Field: ‘expr’
[16:19:12.608]   - Field: ‘uuid’
[16:19:12.608]   - Field: ‘seed’
[16:19:12.608]   - Field: ‘version’
[16:19:12.608]   - Field: ‘result’
[16:19:12.608]   - Field: ‘asynchronous’
[16:19:12.608]   - Field: ‘calls’
[16:19:12.608]   - Field: ‘globals’
[16:19:12.608]   - Field: ‘stdout’
[16:19:12.608]   - Field: ‘earlySignal’
[16:19:12.609]   - Field: ‘lazy’
[16:19:12.609]   - Field: ‘state’
[16:19:12.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.609] - Launch lazy future ...
[16:19:12.609] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:12.609] Packages needed by future strategies (n = 0): <none>
[16:19:12.610] {
[16:19:12.610]     {
[16:19:12.610]         {
[16:19:12.610]             ...future.startTime <- base::Sys.time()
[16:19:12.610]             {
[16:19:12.610]                 {
[16:19:12.610]                   {
[16:19:12.610]                     {
[16:19:12.610]                       base::local({
[16:19:12.610]                         has_future <- base::requireNamespace("future", 
[16:19:12.610]                           quietly = TRUE)
[16:19:12.610]                         if (has_future) {
[16:19:12.610]                           ns <- base::getNamespace("future")
[16:19:12.610]                           version <- ns[[".package"]][["version"]]
[16:19:12.610]                           if (is.null(version)) 
[16:19:12.610]                             version <- utils::packageVersion("future")
[16:19:12.610]                         }
[16:19:12.610]                         else {
[16:19:12.610]                           version <- NULL
[16:19:12.610]                         }
[16:19:12.610]                         if (!has_future || version < "1.8.0") {
[16:19:12.610]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.610]                             "", base::R.version$version.string), 
[16:19:12.610]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.610]                               "release", "version")], collapse = " "), 
[16:19:12.610]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.610]                             info)
[16:19:12.610]                           info <- base::paste(info, collapse = "; ")
[16:19:12.610]                           if (!has_future) {
[16:19:12.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.610]                               info)
[16:19:12.610]                           }
[16:19:12.610]                           else {
[16:19:12.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.610]                               info, version)
[16:19:12.610]                           }
[16:19:12.610]                           base::stop(msg)
[16:19:12.610]                         }
[16:19:12.610]                       })
[16:19:12.610]                     }
[16:19:12.610]                     base::local({
[16:19:12.610]                       for (pkg in "future.apply") {
[16:19:12.610]                         base::loadNamespace(pkg)
[16:19:12.610]                         base::library(pkg, character.only = TRUE)
[16:19:12.610]                       }
[16:19:12.610]                     })
[16:19:12.610]                   }
[16:19:12.610]                   ...future.strategy.old <- future::plan("list")
[16:19:12.610]                   options(future.plan = NULL)
[16:19:12.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.610]                 }
[16:19:12.610]                 ...future.workdir <- getwd()
[16:19:12.610]             }
[16:19:12.610]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.610]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.610]         }
[16:19:12.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.610]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.610]             base::names(...future.oldOptions))
[16:19:12.610]     }
[16:19:12.610]     if (FALSE) {
[16:19:12.610]     }
[16:19:12.610]     else {
[16:19:12.610]         if (TRUE) {
[16:19:12.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.610]                 open = "w")
[16:19:12.610]         }
[16:19:12.610]         else {
[16:19:12.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.610]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.610]         }
[16:19:12.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.610]             base::sink(type = "output", split = FALSE)
[16:19:12.610]             base::close(...future.stdout)
[16:19:12.610]         }, add = TRUE)
[16:19:12.610]     }
[16:19:12.610]     ...future.frame <- base::sys.nframe()
[16:19:12.610]     ...future.conditions <- base::list()
[16:19:12.610]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.610]     if (FALSE) {
[16:19:12.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.610]     }
[16:19:12.610]     ...future.result <- base::tryCatch({
[16:19:12.610]         base::withCallingHandlers({
[16:19:12.610]             ...future.value <- base::withVisible(base::local({
[16:19:12.610]                 do.call(function(...) {
[16:19:12.610]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.610]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.610]                     ...future.globals.maxSize)) {
[16:19:12.610]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.610]                     on.exit(options(oopts), add = TRUE)
[16:19:12.610]                   }
[16:19:12.610]                   {
[16:19:12.610]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.610]                       FUN = function(jj) {
[16:19:12.610]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.610]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.610]                       })
[16:19:12.610]                   }
[16:19:12.610]                 }, args = future.call.arguments)
[16:19:12.610]             }))
[16:19:12.610]             future::FutureResult(value = ...future.value$value, 
[16:19:12.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.610]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.610]                     ...future.globalenv.names))
[16:19:12.610]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.610]         }, condition = base::local({
[16:19:12.610]             c <- base::c
[16:19:12.610]             inherits <- base::inherits
[16:19:12.610]             invokeRestart <- base::invokeRestart
[16:19:12.610]             length <- base::length
[16:19:12.610]             list <- base::list
[16:19:12.610]             seq.int <- base::seq.int
[16:19:12.610]             signalCondition <- base::signalCondition
[16:19:12.610]             sys.calls <- base::sys.calls
[16:19:12.610]             `[[` <- base::`[[`
[16:19:12.610]             `+` <- base::`+`
[16:19:12.610]             `<<-` <- base::`<<-`
[16:19:12.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.610]                   3L)]
[16:19:12.610]             }
[16:19:12.610]             function(cond) {
[16:19:12.610]                 is_error <- inherits(cond, "error")
[16:19:12.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.610]                   NULL)
[16:19:12.610]                 if (is_error) {
[16:19:12.610]                   sessionInformation <- function() {
[16:19:12.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.610]                       search = base::search(), system = base::Sys.info())
[16:19:12.610]                   }
[16:19:12.610]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.610]                     cond$call), session = sessionInformation(), 
[16:19:12.610]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.610]                   signalCondition(cond)
[16:19:12.610]                 }
[16:19:12.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.610]                 "immediateCondition"))) {
[16:19:12.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.610]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.610]                   if (TRUE && !signal) {
[16:19:12.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.610]                     {
[16:19:12.610]                       inherits <- base::inherits
[16:19:12.610]                       invokeRestart <- base::invokeRestart
[16:19:12.610]                       is.null <- base::is.null
[16:19:12.610]                       muffled <- FALSE
[16:19:12.610]                       if (inherits(cond, "message")) {
[16:19:12.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.610]                         if (muffled) 
[16:19:12.610]                           invokeRestart("muffleMessage")
[16:19:12.610]                       }
[16:19:12.610]                       else if (inherits(cond, "warning")) {
[16:19:12.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.610]                         if (muffled) 
[16:19:12.610]                           invokeRestart("muffleWarning")
[16:19:12.610]                       }
[16:19:12.610]                       else if (inherits(cond, "condition")) {
[16:19:12.610]                         if (!is.null(pattern)) {
[16:19:12.610]                           computeRestarts <- base::computeRestarts
[16:19:12.610]                           grepl <- base::grepl
[16:19:12.610]                           restarts <- computeRestarts(cond)
[16:19:12.610]                           for (restart in restarts) {
[16:19:12.610]                             name <- restart$name
[16:19:12.610]                             if (is.null(name)) 
[16:19:12.610]                               next
[16:19:12.610]                             if (!grepl(pattern, name)) 
[16:19:12.610]                               next
[16:19:12.610]                             invokeRestart(restart)
[16:19:12.610]                             muffled <- TRUE
[16:19:12.610]                             break
[16:19:12.610]                           }
[16:19:12.610]                         }
[16:19:12.610]                       }
[16:19:12.610]                       invisible(muffled)
[16:19:12.610]                     }
[16:19:12.610]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.610]                   }
[16:19:12.610]                 }
[16:19:12.610]                 else {
[16:19:12.610]                   if (TRUE) {
[16:19:12.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.610]                     {
[16:19:12.610]                       inherits <- base::inherits
[16:19:12.610]                       invokeRestart <- base::invokeRestart
[16:19:12.610]                       is.null <- base::is.null
[16:19:12.610]                       muffled <- FALSE
[16:19:12.610]                       if (inherits(cond, "message")) {
[16:19:12.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.610]                         if (muffled) 
[16:19:12.610]                           invokeRestart("muffleMessage")
[16:19:12.610]                       }
[16:19:12.610]                       else if (inherits(cond, "warning")) {
[16:19:12.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.610]                         if (muffled) 
[16:19:12.610]                           invokeRestart("muffleWarning")
[16:19:12.610]                       }
[16:19:12.610]                       else if (inherits(cond, "condition")) {
[16:19:12.610]                         if (!is.null(pattern)) {
[16:19:12.610]                           computeRestarts <- base::computeRestarts
[16:19:12.610]                           grepl <- base::grepl
[16:19:12.610]                           restarts <- computeRestarts(cond)
[16:19:12.610]                           for (restart in restarts) {
[16:19:12.610]                             name <- restart$name
[16:19:12.610]                             if (is.null(name)) 
[16:19:12.610]                               next
[16:19:12.610]                             if (!grepl(pattern, name)) 
[16:19:12.610]                               next
[16:19:12.610]                             invokeRestart(restart)
[16:19:12.610]                             muffled <- TRUE
[16:19:12.610]                             break
[16:19:12.610]                           }
[16:19:12.610]                         }
[16:19:12.610]                       }
[16:19:12.610]                       invisible(muffled)
[16:19:12.610]                     }
[16:19:12.610]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.610]                   }
[16:19:12.610]                 }
[16:19:12.610]             }
[16:19:12.610]         }))
[16:19:12.610]     }, error = function(ex) {
[16:19:12.610]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.610]                 ...future.rng), started = ...future.startTime, 
[16:19:12.610]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.610]             version = "1.8"), class = "FutureResult")
[16:19:12.610]     }, finally = {
[16:19:12.610]         if (!identical(...future.workdir, getwd())) 
[16:19:12.610]             setwd(...future.workdir)
[16:19:12.610]         {
[16:19:12.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.610]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.610]             }
[16:19:12.610]             base::options(...future.oldOptions)
[16:19:12.610]             if (.Platform$OS.type == "windows") {
[16:19:12.610]                 old_names <- names(...future.oldEnvVars)
[16:19:12.610]                 envs <- base::Sys.getenv()
[16:19:12.610]                 names <- names(envs)
[16:19:12.610]                 common <- intersect(names, old_names)
[16:19:12.610]                 added <- setdiff(names, old_names)
[16:19:12.610]                 removed <- setdiff(old_names, names)
[16:19:12.610]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.610]                   envs[common]]
[16:19:12.610]                 NAMES <- toupper(changed)
[16:19:12.610]                 args <- list()
[16:19:12.610]                 for (kk in seq_along(NAMES)) {
[16:19:12.610]                   name <- changed[[kk]]
[16:19:12.610]                   NAME <- NAMES[[kk]]
[16:19:12.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.610]                     next
[16:19:12.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.610]                 }
[16:19:12.610]                 NAMES <- toupper(added)
[16:19:12.610]                 for (kk in seq_along(NAMES)) {
[16:19:12.610]                   name <- added[[kk]]
[16:19:12.610]                   NAME <- NAMES[[kk]]
[16:19:12.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.610]                     next
[16:19:12.610]                   args[[name]] <- ""
[16:19:12.610]                 }
[16:19:12.610]                 NAMES <- toupper(removed)
[16:19:12.610]                 for (kk in seq_along(NAMES)) {
[16:19:12.610]                   name <- removed[[kk]]
[16:19:12.610]                   NAME <- NAMES[[kk]]
[16:19:12.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.610]                     next
[16:19:12.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.610]                 }
[16:19:12.610]                 if (length(args) > 0) 
[16:19:12.610]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.610]             }
[16:19:12.610]             else {
[16:19:12.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.610]             }
[16:19:12.610]             {
[16:19:12.610]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.610]                   0L) {
[16:19:12.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.610]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.610]                   base::options(opts)
[16:19:12.610]                 }
[16:19:12.610]                 {
[16:19:12.610]                   {
[16:19:12.610]                     NULL
[16:19:12.610]                     RNGkind("Mersenne-Twister")
[16:19:12.610]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.610]                       inherits = FALSE)
[16:19:12.610]                   }
[16:19:12.610]                   options(future.plan = NULL)
[16:19:12.610]                   if (is.na(NA_character_)) 
[16:19:12.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.610]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.610]                     .init = FALSE)
[16:19:12.610]                 }
[16:19:12.610]             }
[16:19:12.610]         }
[16:19:12.610]     })
[16:19:12.610]     if (TRUE) {
[16:19:12.610]         base::sink(type = "output", split = FALSE)
[16:19:12.610]         if (TRUE) {
[16:19:12.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.610]         }
[16:19:12.610]         else {
[16:19:12.610]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.610]         }
[16:19:12.610]         base::close(...future.stdout)
[16:19:12.610]         ...future.stdout <- NULL
[16:19:12.610]     }
[16:19:12.610]     ...future.result$conditions <- ...future.conditions
[16:19:12.610]     ...future.result$finished <- base::Sys.time()
[16:19:12.610]     ...future.result
[16:19:12.610] }
[16:19:12.611] assign_globals() ...
[16:19:12.611] List of 11
[16:19:12.611]  $ ...future.FUN            :function (x, ...)  
[16:19:12.611]  $ x_FUN                    :function (x)  
[16:19:12.611]  $ times                    : int 1
[16:19:12.611]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.611]  $ stop_if_not              :function (...)  
[16:19:12.611]  $ dim                      : NULL
[16:19:12.611]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:12.611]  $ future.call.arguments    : list()
[16:19:12.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.611]  $ ...future.elements_ii    :List of 10
[16:19:12.611]   ..$ : int 1
[16:19:12.611]   ..$ : int 2
[16:19:12.611]   ..$ : int 3
[16:19:12.611]   ..$ : int 4
[16:19:12.611]   ..$ : int 5
[16:19:12.611]   ..$ : int 6
[16:19:12.611]   ..$ : int 7
[16:19:12.611]   ..$ : int 8
[16:19:12.611]   ..$ : int 9
[16:19:12.611]   ..$ : int 10
[16:19:12.611]  $ ...future.seeds_ii       : NULL
[16:19:12.611]  $ ...future.globals.maxSize: NULL
[16:19:12.611]  - attr(*, "where")=List of 11
[16:19:12.611]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.611]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.611]  - attr(*, "resolved")= logi FALSE
[16:19:12.611]  - attr(*, "total_size")= num 94336
[16:19:12.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.611]  - attr(*, "already-done")= logi TRUE
[16:19:12.622] - copied ‘...future.FUN’ to environment
[16:19:12.622] - copied ‘x_FUN’ to environment
[16:19:12.623] - copied ‘times’ to environment
[16:19:12.623] - copied ‘stopf’ to environment
[16:19:12.623] - copied ‘stop_if_not’ to environment
[16:19:12.623] - copied ‘dim’ to environment
[16:19:12.623] - copied ‘valid_types’ to environment
[16:19:12.623] - copied ‘future.call.arguments’ to environment
[16:19:12.623] - copied ‘...future.elements_ii’ to environment
[16:19:12.623] - copied ‘...future.seeds_ii’ to environment
[16:19:12.623] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.623] assign_globals() ... done
[16:19:12.624] plan(): Setting new future strategy stack:
[16:19:12.624] List of future strategies:
[16:19:12.624] 1. sequential:
[16:19:12.624]    - args: function (..., envir = parent.frame())
[16:19:12.624]    - tweaked: FALSE
[16:19:12.624]    - call: NULL
[16:19:12.624] plan(): nbrOfWorkers() = 1
[16:19:12.625] plan(): Setting new future strategy stack:
[16:19:12.625] List of future strategies:
[16:19:12.625] 1. sequential:
[16:19:12.625]    - args: function (..., envir = parent.frame())
[16:19:12.625]    - tweaked: FALSE
[16:19:12.625]    - call: plan(strategy)
[16:19:12.625] plan(): nbrOfWorkers() = 1
[16:19:12.626] SequentialFuture started (and completed)
[16:19:12.626] - Launch lazy future ... done
[16:19:12.626] run() for ‘SequentialFuture’ ... done
[16:19:12.626] Created future:
[16:19:12.626] SequentialFuture:
[16:19:12.626] Label: ‘future_vapply-1’
[16:19:12.626] Expression:
[16:19:12.626] {
[16:19:12.626]     do.call(function(...) {
[16:19:12.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.626]             on.exit(options(oopts), add = TRUE)
[16:19:12.626]         }
[16:19:12.626]         {
[16:19:12.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.626]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.626]             })
[16:19:12.626]         }
[16:19:12.626]     }, args = future.call.arguments)
[16:19:12.626] }
[16:19:12.626] Lazy evaluation: FALSE
[16:19:12.626] Asynchronous evaluation: FALSE
[16:19:12.626] Local evaluation: TRUE
[16:19:12.626] Environment: R_GlobalEnv
[16:19:12.626] Capture standard output: TRUE
[16:19:12.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.626] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.626] Packages: 1 packages (‘future.apply’)
[16:19:12.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.626] Resolved: TRUE
[16:19:12.626] Value: 560 bytes of class ‘list’
[16:19:12.626] Early signaling: FALSE
[16:19:12.626] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.626] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.627] Chunk #1 of 1 ... DONE
[16:19:12.627] Launching 1 futures (chunks) ... DONE
[16:19:12.627] Resolving 1 futures (chunks) ...
[16:19:12.627] resolve() on list ...
[16:19:12.627]  recursive: 0
[16:19:12.628]  length: 1
[16:19:12.628] 
[16:19:12.628] resolved() for ‘SequentialFuture’ ...
[16:19:12.628] - state: ‘finished’
[16:19:12.628] - run: TRUE
[16:19:12.628] - result: ‘FutureResult’
[16:19:12.628] resolved() for ‘SequentialFuture’ ... done
[16:19:12.628] Future #1
[16:19:12.628] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.628] - nx: 1
[16:19:12.628] - relay: TRUE
[16:19:12.629] - stdout: TRUE
[16:19:12.629] - signal: TRUE
[16:19:12.629] - resignal: FALSE
[16:19:12.629] - force: TRUE
[16:19:12.629] - relayed: [n=1] FALSE
[16:19:12.629] - queued futures: [n=1] FALSE
[16:19:12.629]  - until=1
[16:19:12.629]  - relaying element #1
[16:19:12.629] - relayed: [n=1] TRUE
[16:19:12.629] - queued futures: [n=1] TRUE
[16:19:12.629] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.630]  length: 0 (resolved future 1)
[16:19:12.630] Relaying remaining futures
[16:19:12.630] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.630] - nx: 1
[16:19:12.630] - relay: TRUE
[16:19:12.630] - stdout: TRUE
[16:19:12.630] - signal: TRUE
[16:19:12.630] - resignal: FALSE
[16:19:12.630] - force: TRUE
[16:19:12.630] - relayed: [n=1] TRUE
[16:19:12.630] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.631] - relayed: [n=1] TRUE
[16:19:12.631] - queued futures: [n=1] TRUE
[16:19:12.631] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.631] resolve() on list ... DONE
[16:19:12.631]  - Number of value chunks collected: 1
[16:19:12.631] Resolving 1 futures (chunks) ... DONE
[16:19:12.631] Reducing values from 1 chunks ...
[16:19:12.631]  - Number of values collected after concatenation: 10
[16:19:12.631]  - Number of values expected: 10
[16:19:12.631] Reducing values from 1 chunks ... DONE
[16:19:12.631] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:19:12.632] future_lapply() ...
[16:19:12.634] Number of chunks: 1
[16:19:12.634] getGlobalsAndPackagesXApply() ...
[16:19:12.634]  - future.globals: TRUE
[16:19:12.634] getGlobalsAndPackages() ...
[16:19:12.634] Searching for globals...
[16:19:12.639] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:19:12.639] Searching for globals ... DONE
[16:19:12.639] Resolving globals: FALSE
[16:19:12.640] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:19:12.640] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.640] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.641] - packages: [1] ‘future.apply’
[16:19:12.641] getGlobalsAndPackages() ... DONE
[16:19:12.641]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.641]  - needed namespaces: [n=1] ‘future.apply’
[16:19:12.641] Finding globals ... DONE
[16:19:12.641]  - use_args: TRUE
[16:19:12.641]  - Getting '...' globals ...
[16:19:12.641] resolve() on list ...
[16:19:12.642]  recursive: 0
[16:19:12.642]  length: 1
[16:19:12.642]  elements: ‘...’
[16:19:12.642]  length: 0 (resolved future 1)
[16:19:12.642] resolve() on list ... DONE
[16:19:12.642]    - '...' content: [n=0] 
[16:19:12.642] List of 1
[16:19:12.642]  $ ...: list()
[16:19:12.642]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.642]  - attr(*, "where")=List of 1
[16:19:12.642]   ..$ ...:<environment: 0x56199f332958> 
[16:19:12.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.642]  - attr(*, "resolved")= logi TRUE
[16:19:12.642]  - attr(*, "total_size")= num NA
[16:19:12.645]  - Getting '...' globals ... DONE
[16:19:12.645] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.645] List of 8
[16:19:12.645]  $ ...future.FUN:function (x, ...)  
[16:19:12.645]  $ x_FUN        :function (x)  
[16:19:12.645]  $ times        : int 2
[16:19:12.645]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.645]  $ stop_if_not  :function (...)  
[16:19:12.645]  $ dim          : NULL
[16:19:12.645]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:12.645]  $ ...          : list()
[16:19:12.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.645]  - attr(*, "where")=List of 8
[16:19:12.645]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.645]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.645]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.645]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.645]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.645]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.645]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.645]   ..$ ...          :<environment: 0x56199f332958> 
[16:19:12.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.645]  - attr(*, "resolved")= logi FALSE
[16:19:12.645]  - attr(*, "total_size")= num 96456
[16:19:12.650] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:12.650] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.650] Number of futures (= number of chunks): 1
[16:19:12.650] Launching 1 futures (chunks) ...
[16:19:12.650] Chunk #1 of 1 ...
[16:19:12.651]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.651] getGlobalsAndPackages() ...
[16:19:12.651] Searching for globals...
[16:19:12.651] 
[16:19:12.651] Searching for globals ... DONE
[16:19:12.651] - globals: [0] <none>
[16:19:12.651] getGlobalsAndPackages() ... DONE
[16:19:12.651]    + additional globals found: [n=0] 
[16:19:12.651]    + additional namespaces needed: [n=0] 
[16:19:12.652]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.652]  - seeds: <none>
[16:19:12.652]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.652] getGlobalsAndPackages() ...
[16:19:12.652] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.652] Resolving globals: FALSE
[16:19:12.652] Tweak future expression to call with '...' arguments ...
[16:19:12.652] {
[16:19:12.652]     do.call(function(...) {
[16:19:12.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.652]             on.exit(options(oopts), add = TRUE)
[16:19:12.652]         }
[16:19:12.652]         {
[16:19:12.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.652]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.652]             })
[16:19:12.652]         }
[16:19:12.652]     }, args = future.call.arguments)
[16:19:12.652] }
[16:19:12.653] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.653] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.653] - packages: [1] ‘future.apply’
[16:19:12.653] getGlobalsAndPackages() ... DONE
[16:19:12.654] run() for ‘Future’ ...
[16:19:12.654] - state: ‘created’
[16:19:12.654] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.654] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.654] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.654]   - Field: ‘label’
[16:19:12.654]   - Field: ‘local’
[16:19:12.654]   - Field: ‘owner’
[16:19:12.655]   - Field: ‘envir’
[16:19:12.655]   - Field: ‘packages’
[16:19:12.655]   - Field: ‘gc’
[16:19:12.655]   - Field: ‘conditions’
[16:19:12.655]   - Field: ‘expr’
[16:19:12.655]   - Field: ‘uuid’
[16:19:12.655]   - Field: ‘seed’
[16:19:12.655]   - Field: ‘version’
[16:19:12.655]   - Field: ‘result’
[16:19:12.655]   - Field: ‘asynchronous’
[16:19:12.655]   - Field: ‘calls’
[16:19:12.656]   - Field: ‘globals’
[16:19:12.656]   - Field: ‘stdout’
[16:19:12.656]   - Field: ‘earlySignal’
[16:19:12.656]   - Field: ‘lazy’
[16:19:12.656]   - Field: ‘state’
[16:19:12.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.656] - Launch lazy future ...
[16:19:12.656] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:12.656] Packages needed by future strategies (n = 0): <none>
[16:19:12.659] {
[16:19:12.659]     {
[16:19:12.659]         {
[16:19:12.659]             ...future.startTime <- base::Sys.time()
[16:19:12.659]             {
[16:19:12.659]                 {
[16:19:12.659]                   {
[16:19:12.659]                     {
[16:19:12.659]                       base::local({
[16:19:12.659]                         has_future <- base::requireNamespace("future", 
[16:19:12.659]                           quietly = TRUE)
[16:19:12.659]                         if (has_future) {
[16:19:12.659]                           ns <- base::getNamespace("future")
[16:19:12.659]                           version <- ns[[".package"]][["version"]]
[16:19:12.659]                           if (is.null(version)) 
[16:19:12.659]                             version <- utils::packageVersion("future")
[16:19:12.659]                         }
[16:19:12.659]                         else {
[16:19:12.659]                           version <- NULL
[16:19:12.659]                         }
[16:19:12.659]                         if (!has_future || version < "1.8.0") {
[16:19:12.659]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.659]                             "", base::R.version$version.string), 
[16:19:12.659]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.659]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.659]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.659]                               "release", "version")], collapse = " "), 
[16:19:12.659]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.659]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.659]                             info)
[16:19:12.659]                           info <- base::paste(info, collapse = "; ")
[16:19:12.659]                           if (!has_future) {
[16:19:12.659]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.659]                               info)
[16:19:12.659]                           }
[16:19:12.659]                           else {
[16:19:12.659]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.659]                               info, version)
[16:19:12.659]                           }
[16:19:12.659]                           base::stop(msg)
[16:19:12.659]                         }
[16:19:12.659]                       })
[16:19:12.659]                     }
[16:19:12.659]                     base::local({
[16:19:12.659]                       for (pkg in "future.apply") {
[16:19:12.659]                         base::loadNamespace(pkg)
[16:19:12.659]                         base::library(pkg, character.only = TRUE)
[16:19:12.659]                       }
[16:19:12.659]                     })
[16:19:12.659]                   }
[16:19:12.659]                   ...future.strategy.old <- future::plan("list")
[16:19:12.659]                   options(future.plan = NULL)
[16:19:12.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.659]                 }
[16:19:12.659]                 ...future.workdir <- getwd()
[16:19:12.659]             }
[16:19:12.659]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.659]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.659]         }
[16:19:12.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.659]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.659]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.659]             base::names(...future.oldOptions))
[16:19:12.659]     }
[16:19:12.659]     if (FALSE) {
[16:19:12.659]     }
[16:19:12.659]     else {
[16:19:12.659]         if (TRUE) {
[16:19:12.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.659]                 open = "w")
[16:19:12.659]         }
[16:19:12.659]         else {
[16:19:12.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.659]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.659]         }
[16:19:12.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.659]             base::sink(type = "output", split = FALSE)
[16:19:12.659]             base::close(...future.stdout)
[16:19:12.659]         }, add = TRUE)
[16:19:12.659]     }
[16:19:12.659]     ...future.frame <- base::sys.nframe()
[16:19:12.659]     ...future.conditions <- base::list()
[16:19:12.659]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.659]     if (FALSE) {
[16:19:12.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.659]     }
[16:19:12.659]     ...future.result <- base::tryCatch({
[16:19:12.659]         base::withCallingHandlers({
[16:19:12.659]             ...future.value <- base::withVisible(base::local({
[16:19:12.659]                 do.call(function(...) {
[16:19:12.659]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.659]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.659]                     ...future.globals.maxSize)) {
[16:19:12.659]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.659]                     on.exit(options(oopts), add = TRUE)
[16:19:12.659]                   }
[16:19:12.659]                   {
[16:19:12.659]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.659]                       FUN = function(jj) {
[16:19:12.659]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.659]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.659]                       })
[16:19:12.659]                   }
[16:19:12.659]                 }, args = future.call.arguments)
[16:19:12.659]             }))
[16:19:12.659]             future::FutureResult(value = ...future.value$value, 
[16:19:12.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.659]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.659]                     ...future.globalenv.names))
[16:19:12.659]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.659]         }, condition = base::local({
[16:19:12.659]             c <- base::c
[16:19:12.659]             inherits <- base::inherits
[16:19:12.659]             invokeRestart <- base::invokeRestart
[16:19:12.659]             length <- base::length
[16:19:12.659]             list <- base::list
[16:19:12.659]             seq.int <- base::seq.int
[16:19:12.659]             signalCondition <- base::signalCondition
[16:19:12.659]             sys.calls <- base::sys.calls
[16:19:12.659]             `[[` <- base::`[[`
[16:19:12.659]             `+` <- base::`+`
[16:19:12.659]             `<<-` <- base::`<<-`
[16:19:12.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.659]                   3L)]
[16:19:12.659]             }
[16:19:12.659]             function(cond) {
[16:19:12.659]                 is_error <- inherits(cond, "error")
[16:19:12.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.659]                   NULL)
[16:19:12.659]                 if (is_error) {
[16:19:12.659]                   sessionInformation <- function() {
[16:19:12.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.659]                       search = base::search(), system = base::Sys.info())
[16:19:12.659]                   }
[16:19:12.659]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.659]                     cond$call), session = sessionInformation(), 
[16:19:12.659]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.659]                   signalCondition(cond)
[16:19:12.659]                 }
[16:19:12.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.659]                 "immediateCondition"))) {
[16:19:12.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.659]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.659]                   if (TRUE && !signal) {
[16:19:12.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.659]                     {
[16:19:12.659]                       inherits <- base::inherits
[16:19:12.659]                       invokeRestart <- base::invokeRestart
[16:19:12.659]                       is.null <- base::is.null
[16:19:12.659]                       muffled <- FALSE
[16:19:12.659]                       if (inherits(cond, "message")) {
[16:19:12.659]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.659]                         if (muffled) 
[16:19:12.659]                           invokeRestart("muffleMessage")
[16:19:12.659]                       }
[16:19:12.659]                       else if (inherits(cond, "warning")) {
[16:19:12.659]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.659]                         if (muffled) 
[16:19:12.659]                           invokeRestart("muffleWarning")
[16:19:12.659]                       }
[16:19:12.659]                       else if (inherits(cond, "condition")) {
[16:19:12.659]                         if (!is.null(pattern)) {
[16:19:12.659]                           computeRestarts <- base::computeRestarts
[16:19:12.659]                           grepl <- base::grepl
[16:19:12.659]                           restarts <- computeRestarts(cond)
[16:19:12.659]                           for (restart in restarts) {
[16:19:12.659]                             name <- restart$name
[16:19:12.659]                             if (is.null(name)) 
[16:19:12.659]                               next
[16:19:12.659]                             if (!grepl(pattern, name)) 
[16:19:12.659]                               next
[16:19:12.659]                             invokeRestart(restart)
[16:19:12.659]                             muffled <- TRUE
[16:19:12.659]                             break
[16:19:12.659]                           }
[16:19:12.659]                         }
[16:19:12.659]                       }
[16:19:12.659]                       invisible(muffled)
[16:19:12.659]                     }
[16:19:12.659]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.659]                   }
[16:19:12.659]                 }
[16:19:12.659]                 else {
[16:19:12.659]                   if (TRUE) {
[16:19:12.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.659]                     {
[16:19:12.659]                       inherits <- base::inherits
[16:19:12.659]                       invokeRestart <- base::invokeRestart
[16:19:12.659]                       is.null <- base::is.null
[16:19:12.659]                       muffled <- FALSE
[16:19:12.659]                       if (inherits(cond, "message")) {
[16:19:12.659]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.659]                         if (muffled) 
[16:19:12.659]                           invokeRestart("muffleMessage")
[16:19:12.659]                       }
[16:19:12.659]                       else if (inherits(cond, "warning")) {
[16:19:12.659]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.659]                         if (muffled) 
[16:19:12.659]                           invokeRestart("muffleWarning")
[16:19:12.659]                       }
[16:19:12.659]                       else if (inherits(cond, "condition")) {
[16:19:12.659]                         if (!is.null(pattern)) {
[16:19:12.659]                           computeRestarts <- base::computeRestarts
[16:19:12.659]                           grepl <- base::grepl
[16:19:12.659]                           restarts <- computeRestarts(cond)
[16:19:12.659]                           for (restart in restarts) {
[16:19:12.659]                             name <- restart$name
[16:19:12.659]                             if (is.null(name)) 
[16:19:12.659]                               next
[16:19:12.659]                             if (!grepl(pattern, name)) 
[16:19:12.659]                               next
[16:19:12.659]                             invokeRestart(restart)
[16:19:12.659]                             muffled <- TRUE
[16:19:12.659]                             break
[16:19:12.659]                           }
[16:19:12.659]                         }
[16:19:12.659]                       }
[16:19:12.659]                       invisible(muffled)
[16:19:12.659]                     }
[16:19:12.659]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.659]                   }
[16:19:12.659]                 }
[16:19:12.659]             }
[16:19:12.659]         }))
[16:19:12.659]     }, error = function(ex) {
[16:19:12.659]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.659]                 ...future.rng), started = ...future.startTime, 
[16:19:12.659]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.659]             version = "1.8"), class = "FutureResult")
[16:19:12.659]     }, finally = {
[16:19:12.659]         if (!identical(...future.workdir, getwd())) 
[16:19:12.659]             setwd(...future.workdir)
[16:19:12.659]         {
[16:19:12.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.659]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.659]             }
[16:19:12.659]             base::options(...future.oldOptions)
[16:19:12.659]             if (.Platform$OS.type == "windows") {
[16:19:12.659]                 old_names <- names(...future.oldEnvVars)
[16:19:12.659]                 envs <- base::Sys.getenv()
[16:19:12.659]                 names <- names(envs)
[16:19:12.659]                 common <- intersect(names, old_names)
[16:19:12.659]                 added <- setdiff(names, old_names)
[16:19:12.659]                 removed <- setdiff(old_names, names)
[16:19:12.659]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.659]                   envs[common]]
[16:19:12.659]                 NAMES <- toupper(changed)
[16:19:12.659]                 args <- list()
[16:19:12.659]                 for (kk in seq_along(NAMES)) {
[16:19:12.659]                   name <- changed[[kk]]
[16:19:12.659]                   NAME <- NAMES[[kk]]
[16:19:12.659]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.659]                     next
[16:19:12.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.659]                 }
[16:19:12.659]                 NAMES <- toupper(added)
[16:19:12.659]                 for (kk in seq_along(NAMES)) {
[16:19:12.659]                   name <- added[[kk]]
[16:19:12.659]                   NAME <- NAMES[[kk]]
[16:19:12.659]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.659]                     next
[16:19:12.659]                   args[[name]] <- ""
[16:19:12.659]                 }
[16:19:12.659]                 NAMES <- toupper(removed)
[16:19:12.659]                 for (kk in seq_along(NAMES)) {
[16:19:12.659]                   name <- removed[[kk]]
[16:19:12.659]                   NAME <- NAMES[[kk]]
[16:19:12.659]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.659]                     next
[16:19:12.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.659]                 }
[16:19:12.659]                 if (length(args) > 0) 
[16:19:12.659]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.659]             }
[16:19:12.659]             else {
[16:19:12.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.659]             }
[16:19:12.659]             {
[16:19:12.659]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.659]                   0L) {
[16:19:12.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.659]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.659]                   base::options(opts)
[16:19:12.659]                 }
[16:19:12.659]                 {
[16:19:12.659]                   {
[16:19:12.659]                     NULL
[16:19:12.659]                     RNGkind("Mersenne-Twister")
[16:19:12.659]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.659]                       inherits = FALSE)
[16:19:12.659]                   }
[16:19:12.659]                   options(future.plan = NULL)
[16:19:12.659]                   if (is.na(NA_character_)) 
[16:19:12.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.659]                     .init = FALSE)
[16:19:12.659]                 }
[16:19:12.659]             }
[16:19:12.659]         }
[16:19:12.659]     })
[16:19:12.659]     if (TRUE) {
[16:19:12.659]         base::sink(type = "output", split = FALSE)
[16:19:12.659]         if (TRUE) {
[16:19:12.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.659]         }
[16:19:12.659]         else {
[16:19:12.659]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.659]         }
[16:19:12.659]         base::close(...future.stdout)
[16:19:12.659]         ...future.stdout <- NULL
[16:19:12.659]     }
[16:19:12.659]     ...future.result$conditions <- ...future.conditions
[16:19:12.659]     ...future.result$finished <- base::Sys.time()
[16:19:12.659]     ...future.result
[16:19:12.659] }
[16:19:12.660] assign_globals() ...
[16:19:12.661] List of 11
[16:19:12.661]  $ ...future.FUN            :function (x, ...)  
[16:19:12.661]  $ x_FUN                    :function (x)  
[16:19:12.661]  $ times                    : int 2
[16:19:12.661]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.661]  $ stop_if_not              :function (...)  
[16:19:12.661]  $ dim                      : NULL
[16:19:12.661]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:12.661]  $ future.call.arguments    : list()
[16:19:12.661]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.661]  $ ...future.elements_ii    :List of 10
[16:19:12.661]   ..$ : int 1
[16:19:12.661]   ..$ : int 2
[16:19:12.661]   ..$ : int 3
[16:19:12.661]   ..$ : int 4
[16:19:12.661]   ..$ : int 5
[16:19:12.661]   ..$ : int 6
[16:19:12.661]   ..$ : int 7
[16:19:12.661]   ..$ : int 8
[16:19:12.661]   ..$ : int 9
[16:19:12.661]   ..$ : int 10
[16:19:12.661]  $ ...future.seeds_ii       : NULL
[16:19:12.661]  $ ...future.globals.maxSize: NULL
[16:19:12.661]  - attr(*, "where")=List of 11
[16:19:12.661]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.661]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.661]  - attr(*, "resolved")= logi FALSE
[16:19:12.661]  - attr(*, "total_size")= num 96456
[16:19:12.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.661]  - attr(*, "already-done")= logi TRUE
[16:19:12.671] - copied ‘...future.FUN’ to environment
[16:19:12.671] - reassign environment for ‘x_FUN’
[16:19:12.671] - copied ‘x_FUN’ to environment
[16:19:12.671] - copied ‘times’ to environment
[16:19:12.671] - copied ‘stopf’ to environment
[16:19:12.671] - copied ‘stop_if_not’ to environment
[16:19:12.671] - copied ‘dim’ to environment
[16:19:12.671] - copied ‘valid_types’ to environment
[16:19:12.671] - copied ‘future.call.arguments’ to environment
[16:19:12.672] - copied ‘...future.elements_ii’ to environment
[16:19:12.672] - copied ‘...future.seeds_ii’ to environment
[16:19:12.672] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.672] assign_globals() ... done
[16:19:12.672] plan(): Setting new future strategy stack:
[16:19:12.672] List of future strategies:
[16:19:12.672] 1. sequential:
[16:19:12.672]    - args: function (..., envir = parent.frame())
[16:19:12.672]    - tweaked: FALSE
[16:19:12.672]    - call: NULL
[16:19:12.673] plan(): nbrOfWorkers() = 1
[16:19:12.674] plan(): Setting new future strategy stack:
[16:19:12.674] List of future strategies:
[16:19:12.674] 1. sequential:
[16:19:12.674]    - args: function (..., envir = parent.frame())
[16:19:12.674]    - tweaked: FALSE
[16:19:12.674]    - call: plan(strategy)
[16:19:12.674] plan(): nbrOfWorkers() = 1
[16:19:12.674] SequentialFuture started (and completed)
[16:19:12.675] - Launch lazy future ... done
[16:19:12.675] run() for ‘SequentialFuture’ ... done
[16:19:12.675] Created future:
[16:19:12.675] SequentialFuture:
[16:19:12.675] Label: ‘future_vapply-1’
[16:19:12.675] Expression:
[16:19:12.675] {
[16:19:12.675]     do.call(function(...) {
[16:19:12.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.675]             on.exit(options(oopts), add = TRUE)
[16:19:12.675]         }
[16:19:12.675]         {
[16:19:12.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.675]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.675]             })
[16:19:12.675]         }
[16:19:12.675]     }, args = future.call.arguments)
[16:19:12.675] }
[16:19:12.675] Lazy evaluation: FALSE
[16:19:12.675] Asynchronous evaluation: FALSE
[16:19:12.675] Local evaluation: TRUE
[16:19:12.675] Environment: R_GlobalEnv
[16:19:12.675] Capture standard output: TRUE
[16:19:12.675] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.675] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.675] Packages: 1 packages (‘future.apply’)
[16:19:12.675] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.675] Resolved: TRUE
[16:19:12.675] Value: 640 bytes of class ‘list’
[16:19:12.675] Early signaling: FALSE
[16:19:12.675] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.675] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.676] Chunk #1 of 1 ... DONE
[16:19:12.676] Launching 1 futures (chunks) ... DONE
[16:19:12.676] Resolving 1 futures (chunks) ...
[16:19:12.676] resolve() on list ...
[16:19:12.676]  recursive: 0
[16:19:12.677]  length: 1
[16:19:12.677] 
[16:19:12.677] resolved() for ‘SequentialFuture’ ...
[16:19:12.677] - state: ‘finished’
[16:19:12.677] - run: TRUE
[16:19:12.677] - result: ‘FutureResult’
[16:19:12.677] resolved() for ‘SequentialFuture’ ... done
[16:19:12.677] Future #1
[16:19:12.677] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.678] - nx: 1
[16:19:12.678] - relay: TRUE
[16:19:12.678] - stdout: TRUE
[16:19:12.678] - signal: TRUE
[16:19:12.678] - resignal: FALSE
[16:19:12.678] - force: TRUE
[16:19:12.678] - relayed: [n=1] FALSE
[16:19:12.678] - queued futures: [n=1] FALSE
[16:19:12.678]  - until=1
[16:19:12.678]  - relaying element #1
[16:19:12.678] - relayed: [n=1] TRUE
[16:19:12.679] - queued futures: [n=1] TRUE
[16:19:12.679] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.679]  length: 0 (resolved future 1)
[16:19:12.679] Relaying remaining futures
[16:19:12.679] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.679] - nx: 1
[16:19:12.679] - relay: TRUE
[16:19:12.679] - stdout: TRUE
[16:19:12.679] - signal: TRUE
[16:19:12.679] - resignal: FALSE
[16:19:12.679] - force: TRUE
[16:19:12.680] - relayed: [n=1] TRUE
[16:19:12.680] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.680] - relayed: [n=1] TRUE
[16:19:12.680] - queued futures: [n=1] TRUE
[16:19:12.680] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.680] resolve() on list ... DONE
[16:19:12.680]  - Number of value chunks collected: 1
[16:19:12.680] Resolving 1 futures (chunks) ... DONE
[16:19:12.682] Reducing values from 1 chunks ...
[16:19:12.682]  - Number of values collected after concatenation: 10
[16:19:12.683]  - Number of values expected: 10
[16:19:12.683] Reducing values from 1 chunks ... DONE
[16:19:12.683] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:19:12.684] future_lapply() ...
[16:19:12.686] Number of chunks: 1
[16:19:12.686] getGlobalsAndPackagesXApply() ...
[16:19:12.686]  - future.globals: TRUE
[16:19:12.686] getGlobalsAndPackages() ...
[16:19:12.686] Searching for globals...
[16:19:12.689] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:19:12.690] Searching for globals ... DONE
[16:19:12.690] Resolving globals: FALSE
[16:19:12.691] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:19:12.691] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.691] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.691] - packages: [1] ‘future.apply’
[16:19:12.691] getGlobalsAndPackages() ... DONE
[16:19:12.691]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.692]  - needed namespaces: [n=1] ‘future.apply’
[16:19:12.692] Finding globals ... DONE
[16:19:12.692]  - use_args: TRUE
[16:19:12.692]  - Getting '...' globals ...
[16:19:12.692] resolve() on list ...
[16:19:12.692]  recursive: 0
[16:19:12.692]  length: 1
[16:19:12.692]  elements: ‘...’
[16:19:12.693]  length: 0 (resolved future 1)
[16:19:12.693] resolve() on list ... DONE
[16:19:12.693]    - '...' content: [n=0] 
[16:19:12.693] List of 1
[16:19:12.693]  $ ...: list()
[16:19:12.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.693]  - attr(*, "where")=List of 1
[16:19:12.693]   ..$ ...:<environment: 0x56199de86f50> 
[16:19:12.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.693]  - attr(*, "resolved")= logi TRUE
[16:19:12.693]  - attr(*, "total_size")= num NA
[16:19:12.695]  - Getting '...' globals ... DONE
[16:19:12.695] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.696] List of 8
[16:19:12.696]  $ ...future.FUN:function (x, ...)  
[16:19:12.696]  $ x_FUN        :function (x)  
[16:19:12.696]  $ times        : int 4
[16:19:12.696]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.696]  $ stop_if_not  :function (...)  
[16:19:12.696]  $ dim          : int [1:2] 2 2
[16:19:12.696]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:12.696]  $ ...          : list()
[16:19:12.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.696]  - attr(*, "where")=List of 8
[16:19:12.696]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.696]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.696]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.696]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.696]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.696]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.696]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.696]   ..$ ...          :<environment: 0x56199de86f50> 
[16:19:12.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.696]  - attr(*, "resolved")= logi FALSE
[16:19:12.696]  - attr(*, "total_size")= num 97232
[16:19:12.701] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:12.701] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.701] Number of futures (= number of chunks): 1
[16:19:12.701] Launching 1 futures (chunks) ...
[16:19:12.702] Chunk #1 of 1 ...
[16:19:12.702]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.704] getGlobalsAndPackages() ...
[16:19:12.704] Searching for globals...
[16:19:12.704] 
[16:19:12.704] Searching for globals ... DONE
[16:19:12.704] - globals: [0] <none>
[16:19:12.704] getGlobalsAndPackages() ... DONE
[16:19:12.704]    + additional globals found: [n=0] 
[16:19:12.704]    + additional namespaces needed: [n=0] 
[16:19:12.704]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.705]  - seeds: <none>
[16:19:12.705]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.705] getGlobalsAndPackages() ...
[16:19:12.705] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.705] Resolving globals: FALSE
[16:19:12.705] Tweak future expression to call with '...' arguments ...
[16:19:12.705] {
[16:19:12.705]     do.call(function(...) {
[16:19:12.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.705]             on.exit(options(oopts), add = TRUE)
[16:19:12.705]         }
[16:19:12.705]         {
[16:19:12.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.705]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.705]             })
[16:19:12.705]         }
[16:19:12.705]     }, args = future.call.arguments)
[16:19:12.705] }
[16:19:12.706] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.706] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.706] - packages: [1] ‘future.apply’
[16:19:12.706] getGlobalsAndPackages() ... DONE
[16:19:12.707] run() for ‘Future’ ...
[16:19:12.707] - state: ‘created’
[16:19:12.707] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.707] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.707] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.707]   - Field: ‘label’
[16:19:12.707]   - Field: ‘local’
[16:19:12.708]   - Field: ‘owner’
[16:19:12.708]   - Field: ‘envir’
[16:19:12.708]   - Field: ‘packages’
[16:19:12.708]   - Field: ‘gc’
[16:19:12.708]   - Field: ‘conditions’
[16:19:12.708]   - Field: ‘expr’
[16:19:12.708]   - Field: ‘uuid’
[16:19:12.708]   - Field: ‘seed’
[16:19:12.708]   - Field: ‘version’
[16:19:12.708]   - Field: ‘result’
[16:19:12.709]   - Field: ‘asynchronous’
[16:19:12.709]   - Field: ‘calls’
[16:19:12.709]   - Field: ‘globals’
[16:19:12.709]   - Field: ‘stdout’
[16:19:12.709]   - Field: ‘earlySignal’
[16:19:12.709]   - Field: ‘lazy’
[16:19:12.709]   - Field: ‘state’
[16:19:12.709] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.709] - Launch lazy future ...
[16:19:12.710] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:12.710] Packages needed by future strategies (n = 0): <none>
[16:19:12.710] {
[16:19:12.710]     {
[16:19:12.710]         {
[16:19:12.710]             ...future.startTime <- base::Sys.time()
[16:19:12.710]             {
[16:19:12.710]                 {
[16:19:12.710]                   {
[16:19:12.710]                     {
[16:19:12.710]                       base::local({
[16:19:12.710]                         has_future <- base::requireNamespace("future", 
[16:19:12.710]                           quietly = TRUE)
[16:19:12.710]                         if (has_future) {
[16:19:12.710]                           ns <- base::getNamespace("future")
[16:19:12.710]                           version <- ns[[".package"]][["version"]]
[16:19:12.710]                           if (is.null(version)) 
[16:19:12.710]                             version <- utils::packageVersion("future")
[16:19:12.710]                         }
[16:19:12.710]                         else {
[16:19:12.710]                           version <- NULL
[16:19:12.710]                         }
[16:19:12.710]                         if (!has_future || version < "1.8.0") {
[16:19:12.710]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.710]                             "", base::R.version$version.string), 
[16:19:12.710]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.710]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.710]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.710]                               "release", "version")], collapse = " "), 
[16:19:12.710]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.710]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.710]                             info)
[16:19:12.710]                           info <- base::paste(info, collapse = "; ")
[16:19:12.710]                           if (!has_future) {
[16:19:12.710]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.710]                               info)
[16:19:12.710]                           }
[16:19:12.710]                           else {
[16:19:12.710]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.710]                               info, version)
[16:19:12.710]                           }
[16:19:12.710]                           base::stop(msg)
[16:19:12.710]                         }
[16:19:12.710]                       })
[16:19:12.710]                     }
[16:19:12.710]                     base::local({
[16:19:12.710]                       for (pkg in "future.apply") {
[16:19:12.710]                         base::loadNamespace(pkg)
[16:19:12.710]                         base::library(pkg, character.only = TRUE)
[16:19:12.710]                       }
[16:19:12.710]                     })
[16:19:12.710]                   }
[16:19:12.710]                   ...future.strategy.old <- future::plan("list")
[16:19:12.710]                   options(future.plan = NULL)
[16:19:12.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.710]                 }
[16:19:12.710]                 ...future.workdir <- getwd()
[16:19:12.710]             }
[16:19:12.710]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.710]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.710]         }
[16:19:12.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.710]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.710]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.710]             base::names(...future.oldOptions))
[16:19:12.710]     }
[16:19:12.710]     if (FALSE) {
[16:19:12.710]     }
[16:19:12.710]     else {
[16:19:12.710]         if (TRUE) {
[16:19:12.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.710]                 open = "w")
[16:19:12.710]         }
[16:19:12.710]         else {
[16:19:12.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.710]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.710]         }
[16:19:12.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.710]             base::sink(type = "output", split = FALSE)
[16:19:12.710]             base::close(...future.stdout)
[16:19:12.710]         }, add = TRUE)
[16:19:12.710]     }
[16:19:12.710]     ...future.frame <- base::sys.nframe()
[16:19:12.710]     ...future.conditions <- base::list()
[16:19:12.710]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.710]     if (FALSE) {
[16:19:12.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.710]     }
[16:19:12.710]     ...future.result <- base::tryCatch({
[16:19:12.710]         base::withCallingHandlers({
[16:19:12.710]             ...future.value <- base::withVisible(base::local({
[16:19:12.710]                 do.call(function(...) {
[16:19:12.710]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.710]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.710]                     ...future.globals.maxSize)) {
[16:19:12.710]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.710]                     on.exit(options(oopts), add = TRUE)
[16:19:12.710]                   }
[16:19:12.710]                   {
[16:19:12.710]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.710]                       FUN = function(jj) {
[16:19:12.710]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.710]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.710]                       })
[16:19:12.710]                   }
[16:19:12.710]                 }, args = future.call.arguments)
[16:19:12.710]             }))
[16:19:12.710]             future::FutureResult(value = ...future.value$value, 
[16:19:12.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.710]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.710]                     ...future.globalenv.names))
[16:19:12.710]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.710]         }, condition = base::local({
[16:19:12.710]             c <- base::c
[16:19:12.710]             inherits <- base::inherits
[16:19:12.710]             invokeRestart <- base::invokeRestart
[16:19:12.710]             length <- base::length
[16:19:12.710]             list <- base::list
[16:19:12.710]             seq.int <- base::seq.int
[16:19:12.710]             signalCondition <- base::signalCondition
[16:19:12.710]             sys.calls <- base::sys.calls
[16:19:12.710]             `[[` <- base::`[[`
[16:19:12.710]             `+` <- base::`+`
[16:19:12.710]             `<<-` <- base::`<<-`
[16:19:12.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.710]                   3L)]
[16:19:12.710]             }
[16:19:12.710]             function(cond) {
[16:19:12.710]                 is_error <- inherits(cond, "error")
[16:19:12.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.710]                   NULL)
[16:19:12.710]                 if (is_error) {
[16:19:12.710]                   sessionInformation <- function() {
[16:19:12.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.710]                       search = base::search(), system = base::Sys.info())
[16:19:12.710]                   }
[16:19:12.710]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.710]                     cond$call), session = sessionInformation(), 
[16:19:12.710]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.710]                   signalCondition(cond)
[16:19:12.710]                 }
[16:19:12.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.710]                 "immediateCondition"))) {
[16:19:12.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.710]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.710]                   if (TRUE && !signal) {
[16:19:12.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.710]                     {
[16:19:12.710]                       inherits <- base::inherits
[16:19:12.710]                       invokeRestart <- base::invokeRestart
[16:19:12.710]                       is.null <- base::is.null
[16:19:12.710]                       muffled <- FALSE
[16:19:12.710]                       if (inherits(cond, "message")) {
[16:19:12.710]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.710]                         if (muffled) 
[16:19:12.710]                           invokeRestart("muffleMessage")
[16:19:12.710]                       }
[16:19:12.710]                       else if (inherits(cond, "warning")) {
[16:19:12.710]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.710]                         if (muffled) 
[16:19:12.710]                           invokeRestart("muffleWarning")
[16:19:12.710]                       }
[16:19:12.710]                       else if (inherits(cond, "condition")) {
[16:19:12.710]                         if (!is.null(pattern)) {
[16:19:12.710]                           computeRestarts <- base::computeRestarts
[16:19:12.710]                           grepl <- base::grepl
[16:19:12.710]                           restarts <- computeRestarts(cond)
[16:19:12.710]                           for (restart in restarts) {
[16:19:12.710]                             name <- restart$name
[16:19:12.710]                             if (is.null(name)) 
[16:19:12.710]                               next
[16:19:12.710]                             if (!grepl(pattern, name)) 
[16:19:12.710]                               next
[16:19:12.710]                             invokeRestart(restart)
[16:19:12.710]                             muffled <- TRUE
[16:19:12.710]                             break
[16:19:12.710]                           }
[16:19:12.710]                         }
[16:19:12.710]                       }
[16:19:12.710]                       invisible(muffled)
[16:19:12.710]                     }
[16:19:12.710]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.710]                   }
[16:19:12.710]                 }
[16:19:12.710]                 else {
[16:19:12.710]                   if (TRUE) {
[16:19:12.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.710]                     {
[16:19:12.710]                       inherits <- base::inherits
[16:19:12.710]                       invokeRestart <- base::invokeRestart
[16:19:12.710]                       is.null <- base::is.null
[16:19:12.710]                       muffled <- FALSE
[16:19:12.710]                       if (inherits(cond, "message")) {
[16:19:12.710]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.710]                         if (muffled) 
[16:19:12.710]                           invokeRestart("muffleMessage")
[16:19:12.710]                       }
[16:19:12.710]                       else if (inherits(cond, "warning")) {
[16:19:12.710]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.710]                         if (muffled) 
[16:19:12.710]                           invokeRestart("muffleWarning")
[16:19:12.710]                       }
[16:19:12.710]                       else if (inherits(cond, "condition")) {
[16:19:12.710]                         if (!is.null(pattern)) {
[16:19:12.710]                           computeRestarts <- base::computeRestarts
[16:19:12.710]                           grepl <- base::grepl
[16:19:12.710]                           restarts <- computeRestarts(cond)
[16:19:12.710]                           for (restart in restarts) {
[16:19:12.710]                             name <- restart$name
[16:19:12.710]                             if (is.null(name)) 
[16:19:12.710]                               next
[16:19:12.710]                             if (!grepl(pattern, name)) 
[16:19:12.710]                               next
[16:19:12.710]                             invokeRestart(restart)
[16:19:12.710]                             muffled <- TRUE
[16:19:12.710]                             break
[16:19:12.710]                           }
[16:19:12.710]                         }
[16:19:12.710]                       }
[16:19:12.710]                       invisible(muffled)
[16:19:12.710]                     }
[16:19:12.710]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.710]                   }
[16:19:12.710]                 }
[16:19:12.710]             }
[16:19:12.710]         }))
[16:19:12.710]     }, error = function(ex) {
[16:19:12.710]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.710]                 ...future.rng), started = ...future.startTime, 
[16:19:12.710]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.710]             version = "1.8"), class = "FutureResult")
[16:19:12.710]     }, finally = {
[16:19:12.710]         if (!identical(...future.workdir, getwd())) 
[16:19:12.710]             setwd(...future.workdir)
[16:19:12.710]         {
[16:19:12.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.710]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.710]             }
[16:19:12.710]             base::options(...future.oldOptions)
[16:19:12.710]             if (.Platform$OS.type == "windows") {
[16:19:12.710]                 old_names <- names(...future.oldEnvVars)
[16:19:12.710]                 envs <- base::Sys.getenv()
[16:19:12.710]                 names <- names(envs)
[16:19:12.710]                 common <- intersect(names, old_names)
[16:19:12.710]                 added <- setdiff(names, old_names)
[16:19:12.710]                 removed <- setdiff(old_names, names)
[16:19:12.710]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.710]                   envs[common]]
[16:19:12.710]                 NAMES <- toupper(changed)
[16:19:12.710]                 args <- list()
[16:19:12.710]                 for (kk in seq_along(NAMES)) {
[16:19:12.710]                   name <- changed[[kk]]
[16:19:12.710]                   NAME <- NAMES[[kk]]
[16:19:12.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.710]                     next
[16:19:12.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.710]                 }
[16:19:12.710]                 NAMES <- toupper(added)
[16:19:12.710]                 for (kk in seq_along(NAMES)) {
[16:19:12.710]                   name <- added[[kk]]
[16:19:12.710]                   NAME <- NAMES[[kk]]
[16:19:12.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.710]                     next
[16:19:12.710]                   args[[name]] <- ""
[16:19:12.710]                 }
[16:19:12.710]                 NAMES <- toupper(removed)
[16:19:12.710]                 for (kk in seq_along(NAMES)) {
[16:19:12.710]                   name <- removed[[kk]]
[16:19:12.710]                   NAME <- NAMES[[kk]]
[16:19:12.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.710]                     next
[16:19:12.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.710]                 }
[16:19:12.710]                 if (length(args) > 0) 
[16:19:12.710]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.710]             }
[16:19:12.710]             else {
[16:19:12.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.710]             }
[16:19:12.710]             {
[16:19:12.710]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.710]                   0L) {
[16:19:12.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.710]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.710]                   base::options(opts)
[16:19:12.710]                 }
[16:19:12.710]                 {
[16:19:12.710]                   {
[16:19:12.710]                     NULL
[16:19:12.710]                     RNGkind("Mersenne-Twister")
[16:19:12.710]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.710]                       inherits = FALSE)
[16:19:12.710]                   }
[16:19:12.710]                   options(future.plan = NULL)
[16:19:12.710]                   if (is.na(NA_character_)) 
[16:19:12.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.710]                     .init = FALSE)
[16:19:12.710]                 }
[16:19:12.710]             }
[16:19:12.710]         }
[16:19:12.710]     })
[16:19:12.710]     if (TRUE) {
[16:19:12.710]         base::sink(type = "output", split = FALSE)
[16:19:12.710]         if (TRUE) {
[16:19:12.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.710]         }
[16:19:12.710]         else {
[16:19:12.710]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.710]         }
[16:19:12.710]         base::close(...future.stdout)
[16:19:12.710]         ...future.stdout <- NULL
[16:19:12.710]     }
[16:19:12.710]     ...future.result$conditions <- ...future.conditions
[16:19:12.710]     ...future.result$finished <- base::Sys.time()
[16:19:12.710]     ...future.result
[16:19:12.710] }
[16:19:12.712] assign_globals() ...
[16:19:12.712] List of 11
[16:19:12.712]  $ ...future.FUN            :function (x, ...)  
[16:19:12.712]  $ x_FUN                    :function (x)  
[16:19:12.712]  $ times                    : int 4
[16:19:12.712]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.712]  $ stop_if_not              :function (...)  
[16:19:12.712]  $ dim                      : int [1:2] 2 2
[16:19:12.712]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:12.712]  $ future.call.arguments    : list()
[16:19:12.712]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.712]  $ ...future.elements_ii    :List of 10
[16:19:12.712]   ..$ : int 1
[16:19:12.712]   ..$ : int 2
[16:19:12.712]   ..$ : int 3
[16:19:12.712]   ..$ : int 4
[16:19:12.712]   ..$ : int 5
[16:19:12.712]   ..$ : int 6
[16:19:12.712]   ..$ : int 7
[16:19:12.712]   ..$ : int 8
[16:19:12.712]   ..$ : int 9
[16:19:12.712]   ..$ : int 10
[16:19:12.712]  $ ...future.seeds_ii       : NULL
[16:19:12.712]  $ ...future.globals.maxSize: NULL
[16:19:12.712]  - attr(*, "where")=List of 11
[16:19:12.712]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.712]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.712]  - attr(*, "resolved")= logi FALSE
[16:19:12.712]  - attr(*, "total_size")= num 97232
[16:19:12.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.712]  - attr(*, "already-done")= logi TRUE
[16:19:12.722] - copied ‘...future.FUN’ to environment
[16:19:12.722] - reassign environment for ‘x_FUN’
[16:19:12.722] - copied ‘x_FUN’ to environment
[16:19:12.722] - copied ‘times’ to environment
[16:19:12.722] - copied ‘stopf’ to environment
[16:19:12.722] - copied ‘stop_if_not’ to environment
[16:19:12.722] - copied ‘dim’ to environment
[16:19:12.722] - copied ‘valid_types’ to environment
[16:19:12.723] - copied ‘future.call.arguments’ to environment
[16:19:12.723] - copied ‘...future.elements_ii’ to environment
[16:19:12.723] - copied ‘...future.seeds_ii’ to environment
[16:19:12.723] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.723] assign_globals() ... done
[16:19:12.723] plan(): Setting new future strategy stack:
[16:19:12.723] List of future strategies:
[16:19:12.723] 1. sequential:
[16:19:12.723]    - args: function (..., envir = parent.frame())
[16:19:12.723]    - tweaked: FALSE
[16:19:12.723]    - call: NULL
[16:19:12.724] plan(): nbrOfWorkers() = 1
[16:19:12.726] plan(): Setting new future strategy stack:
[16:19:12.727] List of future strategies:
[16:19:12.727] 1. sequential:
[16:19:12.727]    - args: function (..., envir = parent.frame())
[16:19:12.727]    - tweaked: FALSE
[16:19:12.727]    - call: plan(strategy)
[16:19:12.727] plan(): nbrOfWorkers() = 1
[16:19:12.727] SequentialFuture started (and completed)
[16:19:12.727] - Launch lazy future ... done
[16:19:12.727] run() for ‘SequentialFuture’ ... done
[16:19:12.727] Created future:
[16:19:12.728] SequentialFuture:
[16:19:12.728] Label: ‘future_vapply-1’
[16:19:12.728] Expression:
[16:19:12.728] {
[16:19:12.728]     do.call(function(...) {
[16:19:12.728]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.728]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.728]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.728]             on.exit(options(oopts), add = TRUE)
[16:19:12.728]         }
[16:19:12.728]         {
[16:19:12.728]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.728]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.728]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.728]             })
[16:19:12.728]         }
[16:19:12.728]     }, args = future.call.arguments)
[16:19:12.728] }
[16:19:12.728] Lazy evaluation: FALSE
[16:19:12.728] Asynchronous evaluation: FALSE
[16:19:12.728] Local evaluation: TRUE
[16:19:12.728] Environment: R_GlobalEnv
[16:19:12.728] Capture standard output: TRUE
[16:19:12.728] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.728] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.728] Packages: 1 packages (‘future.apply’)
[16:19:12.728] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.728] Resolved: TRUE
[16:19:12.728] Value: 2.27 KiB of class ‘list’
[16:19:12.728] Early signaling: FALSE
[16:19:12.728] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.728] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.729] Chunk #1 of 1 ... DONE
[16:19:12.729] Launching 1 futures (chunks) ... DONE
[16:19:12.729] Resolving 1 futures (chunks) ...
[16:19:12.729] resolve() on list ...
[16:19:12.729]  recursive: 0
[16:19:12.729]  length: 1
[16:19:12.729] 
[16:19:12.729] resolved() for ‘SequentialFuture’ ...
[16:19:12.730] - state: ‘finished’
[16:19:12.730] - run: TRUE
[16:19:12.730] - result: ‘FutureResult’
[16:19:12.730] resolved() for ‘SequentialFuture’ ... done
[16:19:12.730] Future #1
[16:19:12.730] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.730] - nx: 1
[16:19:12.730] - relay: TRUE
[16:19:12.730] - stdout: TRUE
[16:19:12.730] - signal: TRUE
[16:19:12.731] - resignal: FALSE
[16:19:12.731] - force: TRUE
[16:19:12.731] - relayed: [n=1] FALSE
[16:19:12.731] - queued futures: [n=1] FALSE
[16:19:12.731]  - until=1
[16:19:12.731]  - relaying element #1
[16:19:12.731] - relayed: [n=1] TRUE
[16:19:12.731] - queued futures: [n=1] TRUE
[16:19:12.731] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.731]  length: 0 (resolved future 1)
[16:19:12.732] Relaying remaining futures
[16:19:12.732] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.732] - nx: 1
[16:19:12.732] - relay: TRUE
[16:19:12.732] - stdout: TRUE
[16:19:12.732] - signal: TRUE
[16:19:12.732] - resignal: FALSE
[16:19:12.732] - force: TRUE
[16:19:12.732] - relayed: [n=1] TRUE
[16:19:12.732] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.733] - relayed: [n=1] TRUE
[16:19:12.733] - queued futures: [n=1] TRUE
[16:19:12.733] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.733] resolve() on list ... DONE
[16:19:12.733]  - Number of value chunks collected: 1
[16:19:12.733] Resolving 1 futures (chunks) ... DONE
[16:19:12.733] Reducing values from 1 chunks ...
[16:19:12.733]  - Number of values collected after concatenation: 10
[16:19:12.733]  - Number of values expected: 10
[16:19:12.733] Reducing values from 1 chunks ... DONE
[16:19:12.733] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:19:12.734] future_lapply() ...
[16:19:12.736] Number of chunks: 1
[16:19:12.736] getGlobalsAndPackagesXApply() ...
[16:19:12.736]  - future.globals: TRUE
[16:19:12.736] getGlobalsAndPackages() ...
[16:19:12.737] Searching for globals...
[16:19:12.740] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:19:12.740] Searching for globals ... DONE
[16:19:12.740] Resolving globals: FALSE
[16:19:12.741] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:19:12.741] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.742] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.742] - packages: [1] ‘future.apply’
[16:19:12.742] getGlobalsAndPackages() ... DONE
[16:19:12.742]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.742]  - needed namespaces: [n=1] ‘future.apply’
[16:19:12.742] Finding globals ... DONE
[16:19:12.742]  - use_args: TRUE
[16:19:12.742]  - Getting '...' globals ...
[16:19:12.743] resolve() on list ...
[16:19:12.743]  recursive: 0
[16:19:12.743]  length: 1
[16:19:12.743]  elements: ‘...’
[16:19:12.743]  length: 0 (resolved future 1)
[16:19:12.743] resolve() on list ... DONE
[16:19:12.743]    - '...' content: [n=0] 
[16:19:12.743] List of 1
[16:19:12.743]  $ ...: list()
[16:19:12.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.743]  - attr(*, "where")=List of 1
[16:19:12.743]   ..$ ...:<environment: 0x56199e9b4a38> 
[16:19:12.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.743]  - attr(*, "resolved")= logi TRUE
[16:19:12.743]  - attr(*, "total_size")= num NA
[16:19:12.746]  - Getting '...' globals ... DONE
[16:19:12.746] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.746] List of 8
[16:19:12.746]  $ ...future.FUN:function (x, ...)  
[16:19:12.746]  $ x_FUN        :function (x)  
[16:19:12.746]  $ times        : int 4
[16:19:12.746]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.746]  $ stop_if_not  :function (...)  
[16:19:12.746]  $ dim          : int [1:2] 2 2
[16:19:12.746]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:12.746]  $ ...          : list()
[16:19:12.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.746]  - attr(*, "where")=List of 8
[16:19:12.746]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.746]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.746]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.746]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.746]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.746]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.746]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.746]   ..$ ...          :<environment: 0x56199e9b4a38> 
[16:19:12.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.746]  - attr(*, "resolved")= logi FALSE
[16:19:12.746]  - attr(*, "total_size")= num 97304
[16:19:12.753] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:12.753] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.753] Number of futures (= number of chunks): 1
[16:19:12.754] Launching 1 futures (chunks) ...
[16:19:12.754] Chunk #1 of 1 ...
[16:19:12.754]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.754] getGlobalsAndPackages() ...
[16:19:12.754] Searching for globals...
[16:19:12.754] 
[16:19:12.754] Searching for globals ... DONE
[16:19:12.754] - globals: [0] <none>
[16:19:12.754] getGlobalsAndPackages() ... DONE
[16:19:12.755]    + additional globals found: [n=0] 
[16:19:12.755]    + additional namespaces needed: [n=0] 
[16:19:12.755]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.755]  - seeds: <none>
[16:19:12.755]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.755] getGlobalsAndPackages() ...
[16:19:12.755] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.755] Resolving globals: FALSE
[16:19:12.755] Tweak future expression to call with '...' arguments ...
[16:19:12.755] {
[16:19:12.755]     do.call(function(...) {
[16:19:12.755]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.755]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.755]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.755]             on.exit(options(oopts), add = TRUE)
[16:19:12.755]         }
[16:19:12.755]         {
[16:19:12.755]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.755]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.755]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.755]             })
[16:19:12.755]         }
[16:19:12.755]     }, args = future.call.arguments)
[16:19:12.755] }
[16:19:12.756] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.756] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.756] - packages: [1] ‘future.apply’
[16:19:12.756] getGlobalsAndPackages() ... DONE
[16:19:12.757] run() for ‘Future’ ...
[16:19:12.757] - state: ‘created’
[16:19:12.757] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.757] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.757] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.758]   - Field: ‘label’
[16:19:12.758]   - Field: ‘local’
[16:19:12.758]   - Field: ‘owner’
[16:19:12.758]   - Field: ‘envir’
[16:19:12.758]   - Field: ‘packages’
[16:19:12.758]   - Field: ‘gc’
[16:19:12.758]   - Field: ‘conditions’
[16:19:12.758]   - Field: ‘expr’
[16:19:12.758]   - Field: ‘uuid’
[16:19:12.758]   - Field: ‘seed’
[16:19:12.758]   - Field: ‘version’
[16:19:12.759]   - Field: ‘result’
[16:19:12.759]   - Field: ‘asynchronous’
[16:19:12.759]   - Field: ‘calls’
[16:19:12.759]   - Field: ‘globals’
[16:19:12.759]   - Field: ‘stdout’
[16:19:12.759]   - Field: ‘earlySignal’
[16:19:12.759]   - Field: ‘lazy’
[16:19:12.759]   - Field: ‘state’
[16:19:12.759] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.759] - Launch lazy future ...
[16:19:12.760] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:12.760] Packages needed by future strategies (n = 0): <none>
[16:19:12.760] {
[16:19:12.760]     {
[16:19:12.760]         {
[16:19:12.760]             ...future.startTime <- base::Sys.time()
[16:19:12.760]             {
[16:19:12.760]                 {
[16:19:12.760]                   {
[16:19:12.760]                     {
[16:19:12.760]                       base::local({
[16:19:12.760]                         has_future <- base::requireNamespace("future", 
[16:19:12.760]                           quietly = TRUE)
[16:19:12.760]                         if (has_future) {
[16:19:12.760]                           ns <- base::getNamespace("future")
[16:19:12.760]                           version <- ns[[".package"]][["version"]]
[16:19:12.760]                           if (is.null(version)) 
[16:19:12.760]                             version <- utils::packageVersion("future")
[16:19:12.760]                         }
[16:19:12.760]                         else {
[16:19:12.760]                           version <- NULL
[16:19:12.760]                         }
[16:19:12.760]                         if (!has_future || version < "1.8.0") {
[16:19:12.760]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.760]                             "", base::R.version$version.string), 
[16:19:12.760]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.760]                               "release", "version")], collapse = " "), 
[16:19:12.760]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.760]                             info)
[16:19:12.760]                           info <- base::paste(info, collapse = "; ")
[16:19:12.760]                           if (!has_future) {
[16:19:12.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.760]                               info)
[16:19:12.760]                           }
[16:19:12.760]                           else {
[16:19:12.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.760]                               info, version)
[16:19:12.760]                           }
[16:19:12.760]                           base::stop(msg)
[16:19:12.760]                         }
[16:19:12.760]                       })
[16:19:12.760]                     }
[16:19:12.760]                     base::local({
[16:19:12.760]                       for (pkg in "future.apply") {
[16:19:12.760]                         base::loadNamespace(pkg)
[16:19:12.760]                         base::library(pkg, character.only = TRUE)
[16:19:12.760]                       }
[16:19:12.760]                     })
[16:19:12.760]                   }
[16:19:12.760]                   ...future.strategy.old <- future::plan("list")
[16:19:12.760]                   options(future.plan = NULL)
[16:19:12.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.760]                 }
[16:19:12.760]                 ...future.workdir <- getwd()
[16:19:12.760]             }
[16:19:12.760]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.760]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.760]         }
[16:19:12.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.760]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.760]             base::names(...future.oldOptions))
[16:19:12.760]     }
[16:19:12.760]     if (FALSE) {
[16:19:12.760]     }
[16:19:12.760]     else {
[16:19:12.760]         if (TRUE) {
[16:19:12.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.760]                 open = "w")
[16:19:12.760]         }
[16:19:12.760]         else {
[16:19:12.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.760]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.760]         }
[16:19:12.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.760]             base::sink(type = "output", split = FALSE)
[16:19:12.760]             base::close(...future.stdout)
[16:19:12.760]         }, add = TRUE)
[16:19:12.760]     }
[16:19:12.760]     ...future.frame <- base::sys.nframe()
[16:19:12.760]     ...future.conditions <- base::list()
[16:19:12.760]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.760]     if (FALSE) {
[16:19:12.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.760]     }
[16:19:12.760]     ...future.result <- base::tryCatch({
[16:19:12.760]         base::withCallingHandlers({
[16:19:12.760]             ...future.value <- base::withVisible(base::local({
[16:19:12.760]                 do.call(function(...) {
[16:19:12.760]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.760]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.760]                     ...future.globals.maxSize)) {
[16:19:12.760]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.760]                     on.exit(options(oopts), add = TRUE)
[16:19:12.760]                   }
[16:19:12.760]                   {
[16:19:12.760]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.760]                       FUN = function(jj) {
[16:19:12.760]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.760]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.760]                       })
[16:19:12.760]                   }
[16:19:12.760]                 }, args = future.call.arguments)
[16:19:12.760]             }))
[16:19:12.760]             future::FutureResult(value = ...future.value$value, 
[16:19:12.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.760]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.760]                     ...future.globalenv.names))
[16:19:12.760]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.760]         }, condition = base::local({
[16:19:12.760]             c <- base::c
[16:19:12.760]             inherits <- base::inherits
[16:19:12.760]             invokeRestart <- base::invokeRestart
[16:19:12.760]             length <- base::length
[16:19:12.760]             list <- base::list
[16:19:12.760]             seq.int <- base::seq.int
[16:19:12.760]             signalCondition <- base::signalCondition
[16:19:12.760]             sys.calls <- base::sys.calls
[16:19:12.760]             `[[` <- base::`[[`
[16:19:12.760]             `+` <- base::`+`
[16:19:12.760]             `<<-` <- base::`<<-`
[16:19:12.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.760]                   3L)]
[16:19:12.760]             }
[16:19:12.760]             function(cond) {
[16:19:12.760]                 is_error <- inherits(cond, "error")
[16:19:12.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.760]                   NULL)
[16:19:12.760]                 if (is_error) {
[16:19:12.760]                   sessionInformation <- function() {
[16:19:12.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.760]                       search = base::search(), system = base::Sys.info())
[16:19:12.760]                   }
[16:19:12.760]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.760]                     cond$call), session = sessionInformation(), 
[16:19:12.760]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.760]                   signalCondition(cond)
[16:19:12.760]                 }
[16:19:12.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.760]                 "immediateCondition"))) {
[16:19:12.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.760]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.760]                   if (TRUE && !signal) {
[16:19:12.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.760]                     {
[16:19:12.760]                       inherits <- base::inherits
[16:19:12.760]                       invokeRestart <- base::invokeRestart
[16:19:12.760]                       is.null <- base::is.null
[16:19:12.760]                       muffled <- FALSE
[16:19:12.760]                       if (inherits(cond, "message")) {
[16:19:12.760]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.760]                         if (muffled) 
[16:19:12.760]                           invokeRestart("muffleMessage")
[16:19:12.760]                       }
[16:19:12.760]                       else if (inherits(cond, "warning")) {
[16:19:12.760]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.760]                         if (muffled) 
[16:19:12.760]                           invokeRestart("muffleWarning")
[16:19:12.760]                       }
[16:19:12.760]                       else if (inherits(cond, "condition")) {
[16:19:12.760]                         if (!is.null(pattern)) {
[16:19:12.760]                           computeRestarts <- base::computeRestarts
[16:19:12.760]                           grepl <- base::grepl
[16:19:12.760]                           restarts <- computeRestarts(cond)
[16:19:12.760]                           for (restart in restarts) {
[16:19:12.760]                             name <- restart$name
[16:19:12.760]                             if (is.null(name)) 
[16:19:12.760]                               next
[16:19:12.760]                             if (!grepl(pattern, name)) 
[16:19:12.760]                               next
[16:19:12.760]                             invokeRestart(restart)
[16:19:12.760]                             muffled <- TRUE
[16:19:12.760]                             break
[16:19:12.760]                           }
[16:19:12.760]                         }
[16:19:12.760]                       }
[16:19:12.760]                       invisible(muffled)
[16:19:12.760]                     }
[16:19:12.760]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.760]                   }
[16:19:12.760]                 }
[16:19:12.760]                 else {
[16:19:12.760]                   if (TRUE) {
[16:19:12.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.760]                     {
[16:19:12.760]                       inherits <- base::inherits
[16:19:12.760]                       invokeRestart <- base::invokeRestart
[16:19:12.760]                       is.null <- base::is.null
[16:19:12.760]                       muffled <- FALSE
[16:19:12.760]                       if (inherits(cond, "message")) {
[16:19:12.760]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.760]                         if (muffled) 
[16:19:12.760]                           invokeRestart("muffleMessage")
[16:19:12.760]                       }
[16:19:12.760]                       else if (inherits(cond, "warning")) {
[16:19:12.760]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.760]                         if (muffled) 
[16:19:12.760]                           invokeRestart("muffleWarning")
[16:19:12.760]                       }
[16:19:12.760]                       else if (inherits(cond, "condition")) {
[16:19:12.760]                         if (!is.null(pattern)) {
[16:19:12.760]                           computeRestarts <- base::computeRestarts
[16:19:12.760]                           grepl <- base::grepl
[16:19:12.760]                           restarts <- computeRestarts(cond)
[16:19:12.760]                           for (restart in restarts) {
[16:19:12.760]                             name <- restart$name
[16:19:12.760]                             if (is.null(name)) 
[16:19:12.760]                               next
[16:19:12.760]                             if (!grepl(pattern, name)) 
[16:19:12.760]                               next
[16:19:12.760]                             invokeRestart(restart)
[16:19:12.760]                             muffled <- TRUE
[16:19:12.760]                             break
[16:19:12.760]                           }
[16:19:12.760]                         }
[16:19:12.760]                       }
[16:19:12.760]                       invisible(muffled)
[16:19:12.760]                     }
[16:19:12.760]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.760]                   }
[16:19:12.760]                 }
[16:19:12.760]             }
[16:19:12.760]         }))
[16:19:12.760]     }, error = function(ex) {
[16:19:12.760]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.760]                 ...future.rng), started = ...future.startTime, 
[16:19:12.760]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.760]             version = "1.8"), class = "FutureResult")
[16:19:12.760]     }, finally = {
[16:19:12.760]         if (!identical(...future.workdir, getwd())) 
[16:19:12.760]             setwd(...future.workdir)
[16:19:12.760]         {
[16:19:12.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.760]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.760]             }
[16:19:12.760]             base::options(...future.oldOptions)
[16:19:12.760]             if (.Platform$OS.type == "windows") {
[16:19:12.760]                 old_names <- names(...future.oldEnvVars)
[16:19:12.760]                 envs <- base::Sys.getenv()
[16:19:12.760]                 names <- names(envs)
[16:19:12.760]                 common <- intersect(names, old_names)
[16:19:12.760]                 added <- setdiff(names, old_names)
[16:19:12.760]                 removed <- setdiff(old_names, names)
[16:19:12.760]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.760]                   envs[common]]
[16:19:12.760]                 NAMES <- toupper(changed)
[16:19:12.760]                 args <- list()
[16:19:12.760]                 for (kk in seq_along(NAMES)) {
[16:19:12.760]                   name <- changed[[kk]]
[16:19:12.760]                   NAME <- NAMES[[kk]]
[16:19:12.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.760]                     next
[16:19:12.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.760]                 }
[16:19:12.760]                 NAMES <- toupper(added)
[16:19:12.760]                 for (kk in seq_along(NAMES)) {
[16:19:12.760]                   name <- added[[kk]]
[16:19:12.760]                   NAME <- NAMES[[kk]]
[16:19:12.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.760]                     next
[16:19:12.760]                   args[[name]] <- ""
[16:19:12.760]                 }
[16:19:12.760]                 NAMES <- toupper(removed)
[16:19:12.760]                 for (kk in seq_along(NAMES)) {
[16:19:12.760]                   name <- removed[[kk]]
[16:19:12.760]                   NAME <- NAMES[[kk]]
[16:19:12.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.760]                     next
[16:19:12.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.760]                 }
[16:19:12.760]                 if (length(args) > 0) 
[16:19:12.760]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.760]             }
[16:19:12.760]             else {
[16:19:12.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.760]             }
[16:19:12.760]             {
[16:19:12.760]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.760]                   0L) {
[16:19:12.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.760]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.760]                   base::options(opts)
[16:19:12.760]                 }
[16:19:12.760]                 {
[16:19:12.760]                   {
[16:19:12.760]                     NULL
[16:19:12.760]                     RNGkind("Mersenne-Twister")
[16:19:12.760]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.760]                       inherits = FALSE)
[16:19:12.760]                   }
[16:19:12.760]                   options(future.plan = NULL)
[16:19:12.760]                   if (is.na(NA_character_)) 
[16:19:12.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.760]                     .init = FALSE)
[16:19:12.760]                 }
[16:19:12.760]             }
[16:19:12.760]         }
[16:19:12.760]     })
[16:19:12.760]     if (TRUE) {
[16:19:12.760]         base::sink(type = "output", split = FALSE)
[16:19:12.760]         if (TRUE) {
[16:19:12.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.760]         }
[16:19:12.760]         else {
[16:19:12.760]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.760]         }
[16:19:12.760]         base::close(...future.stdout)
[16:19:12.760]         ...future.stdout <- NULL
[16:19:12.760]     }
[16:19:12.760]     ...future.result$conditions <- ...future.conditions
[16:19:12.760]     ...future.result$finished <- base::Sys.time()
[16:19:12.760]     ...future.result
[16:19:12.760] }
[16:19:12.762] assign_globals() ...
[16:19:12.762] List of 11
[16:19:12.762]  $ ...future.FUN            :function (x, ...)  
[16:19:12.762]  $ x_FUN                    :function (x)  
[16:19:12.762]  $ times                    : int 4
[16:19:12.762]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.762]  $ stop_if_not              :function (...)  
[16:19:12.762]  $ dim                      : int [1:2] 2 2
[16:19:12.762]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:12.762]  $ future.call.arguments    : list()
[16:19:12.762]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.762]  $ ...future.elements_ii    :List of 10
[16:19:12.762]   ..$ : int 1
[16:19:12.762]   ..$ : int 2
[16:19:12.762]   ..$ : int 3
[16:19:12.762]   ..$ : int 4
[16:19:12.762]   ..$ : int 5
[16:19:12.762]   ..$ : int 6
[16:19:12.762]   ..$ : int 7
[16:19:12.762]   ..$ : int 8
[16:19:12.762]   ..$ : int 9
[16:19:12.762]   ..$ : int 10
[16:19:12.762]  $ ...future.seeds_ii       : NULL
[16:19:12.762]  $ ...future.globals.maxSize: NULL
[16:19:12.762]  - attr(*, "where")=List of 11
[16:19:12.762]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.762]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.762]  - attr(*, "resolved")= logi FALSE
[16:19:12.762]  - attr(*, "total_size")= num 97304
[16:19:12.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.762]  - attr(*, "already-done")= logi TRUE
[16:19:12.800] - copied ‘...future.FUN’ to environment
[16:19:12.800] - reassign environment for ‘x_FUN’
[16:19:12.800] - copied ‘x_FUN’ to environment
[16:19:12.800] - copied ‘times’ to environment
[16:19:12.800] - copied ‘stopf’ to environment
[16:19:12.800] - copied ‘stop_if_not’ to environment
[16:19:12.800] - copied ‘dim’ to environment
[16:19:12.801] - copied ‘valid_types’ to environment
[16:19:12.801] - copied ‘future.call.arguments’ to environment
[16:19:12.801] - copied ‘...future.elements_ii’ to environment
[16:19:12.801] - copied ‘...future.seeds_ii’ to environment
[16:19:12.801] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.801] assign_globals() ... done
[16:19:12.801] plan(): Setting new future strategy stack:
[16:19:12.802] List of future strategies:
[16:19:12.802] 1. sequential:
[16:19:12.802]    - args: function (..., envir = parent.frame())
[16:19:12.802]    - tweaked: FALSE
[16:19:12.802]    - call: NULL
[16:19:12.802] plan(): nbrOfWorkers() = 1
[16:19:12.803] plan(): Setting new future strategy stack:
[16:19:12.803] List of future strategies:
[16:19:12.803] 1. sequential:
[16:19:12.803]    - args: function (..., envir = parent.frame())
[16:19:12.803]    - tweaked: FALSE
[16:19:12.803]    - call: plan(strategy)
[16:19:12.803] plan(): nbrOfWorkers() = 1
[16:19:12.803] SequentialFuture started (and completed)
[16:19:12.804] - Launch lazy future ... done
[16:19:12.804] run() for ‘SequentialFuture’ ... done
[16:19:12.804] Created future:
[16:19:12.804] SequentialFuture:
[16:19:12.804] Label: ‘future_vapply-1’
[16:19:12.804] Expression:
[16:19:12.804] {
[16:19:12.804]     do.call(function(...) {
[16:19:12.804]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.804]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.804]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.804]             on.exit(options(oopts), add = TRUE)
[16:19:12.804]         }
[16:19:12.804]         {
[16:19:12.804]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.804]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.804]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.804]             })
[16:19:12.804]         }
[16:19:12.804]     }, args = future.call.arguments)
[16:19:12.804] }
[16:19:12.804] Lazy evaluation: FALSE
[16:19:12.804] Asynchronous evaluation: FALSE
[16:19:12.804] Local evaluation: TRUE
[16:19:12.804] Environment: R_GlobalEnv
[16:19:12.804] Capture standard output: TRUE
[16:19:12.804] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.804] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.804] Packages: 1 packages (‘future.apply’)
[16:19:12.804] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.804] Resolved: TRUE
[16:19:12.804] Value: 2.27 KiB of class ‘list’
[16:19:12.804] Early signaling: FALSE
[16:19:12.804] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.804] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.805] Chunk #1 of 1 ... DONE
[16:19:12.805] Launching 1 futures (chunks) ... DONE
[16:19:12.805] Resolving 1 futures (chunks) ...
[16:19:12.805] resolve() on list ...
[16:19:12.806]  recursive: 0
[16:19:12.806]  length: 1
[16:19:12.806] 
[16:19:12.806] resolved() for ‘SequentialFuture’ ...
[16:19:12.806] - state: ‘finished’
[16:19:12.806] - run: TRUE
[16:19:12.806] - result: ‘FutureResult’
[16:19:12.806] resolved() for ‘SequentialFuture’ ... done
[16:19:12.806] Future #1
[16:19:12.807] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.807] - nx: 1
[16:19:12.807] - relay: TRUE
[16:19:12.807] - stdout: TRUE
[16:19:12.807] - signal: TRUE
[16:19:12.807] - resignal: FALSE
[16:19:12.807] - force: TRUE
[16:19:12.807] - relayed: [n=1] FALSE
[16:19:12.807] - queued futures: [n=1] FALSE
[16:19:12.807]  - until=1
[16:19:12.807]  - relaying element #1
[16:19:12.808] - relayed: [n=1] TRUE
[16:19:12.808] - queued futures: [n=1] TRUE
[16:19:12.808] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.808]  length: 0 (resolved future 1)
[16:19:12.808] Relaying remaining futures
[16:19:12.808] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.808] - nx: 1
[16:19:12.808] - relay: TRUE
[16:19:12.808] - stdout: TRUE
[16:19:12.808] - signal: TRUE
[16:19:12.808] - resignal: FALSE
[16:19:12.809] - force: TRUE
[16:19:12.809] - relayed: [n=1] TRUE
[16:19:12.809] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.809] - relayed: [n=1] TRUE
[16:19:12.809] - queued futures: [n=1] TRUE
[16:19:12.809] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.809] resolve() on list ... DONE
[16:19:12.809]  - Number of value chunks collected: 1
[16:19:12.809] Resolving 1 futures (chunks) ... DONE
[16:19:12.809] Reducing values from 1 chunks ...
[16:19:12.810]  - Number of values collected after concatenation: 10
[16:19:12.810]  - Number of values expected: 10
[16:19:12.810] Reducing values from 1 chunks ... DONE
[16:19:12.810] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:19:12.812] future_lapply() ...
[16:19:12.814] Number of chunks: 1
[16:19:12.814] getGlobalsAndPackagesXApply() ...
[16:19:12.814]  - future.globals: TRUE
[16:19:12.814] getGlobalsAndPackages() ...
[16:19:12.814] Searching for globals...
[16:19:12.818] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:19:12.818] Searching for globals ... DONE
[16:19:12.818] Resolving globals: FALSE
[16:19:12.821] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:19:12.821] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.821] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.821] - packages: [1] ‘future.apply’
[16:19:12.822] getGlobalsAndPackages() ... DONE
[16:19:12.822]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.822]  - needed namespaces: [n=1] ‘future.apply’
[16:19:12.822] Finding globals ... DONE
[16:19:12.822]  - use_args: TRUE
[16:19:12.822]  - Getting '...' globals ...
[16:19:12.822] resolve() on list ...
[16:19:12.823]  recursive: 0
[16:19:12.823]  length: 1
[16:19:12.823]  elements: ‘...’
[16:19:12.823]  length: 0 (resolved future 1)
[16:19:12.823] resolve() on list ... DONE
[16:19:12.823]    - '...' content: [n=0] 
[16:19:12.823] List of 1
[16:19:12.823]  $ ...: list()
[16:19:12.823]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.823]  - attr(*, "where")=List of 1
[16:19:12.823]   ..$ ...:<environment: 0x56199f229fe8> 
[16:19:12.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.823]  - attr(*, "resolved")= logi TRUE
[16:19:12.823]  - attr(*, "total_size")= num NA
[16:19:12.826]  - Getting '...' globals ... DONE
[16:19:12.826] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.826] List of 8
[16:19:12.826]  $ ...future.FUN:function (x, ...)  
[16:19:12.826]  $ x_FUN        :function (x)  
[16:19:12.826]  $ times        : int 4
[16:19:12.826]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.826]  $ stop_if_not  :function (...)  
[16:19:12.826]  $ dim          : int [1:2] 2 2
[16:19:12.826]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:12.826]  $ ...          : list()
[16:19:12.826]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.826]  - attr(*, "where")=List of 8
[16:19:12.826]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.826]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.826]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.826]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.826]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.826]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.826]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.826]   ..$ ...          :<environment: 0x56199f229fe8> 
[16:19:12.826]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.826]  - attr(*, "resolved")= logi FALSE
[16:19:12.826]  - attr(*, "total_size")= num 105552
[16:19:12.831] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:12.832] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.832] Number of futures (= number of chunks): 1
[16:19:12.832] Launching 1 futures (chunks) ...
[16:19:12.832] Chunk #1 of 1 ...
[16:19:12.832]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.832] getGlobalsAndPackages() ...
[16:19:12.832] Searching for globals...
[16:19:12.833] 
[16:19:12.833] Searching for globals ... DONE
[16:19:12.833] - globals: [0] <none>
[16:19:12.833] getGlobalsAndPackages() ... DONE
[16:19:12.833]    + additional globals found: [n=0] 
[16:19:12.833]    + additional namespaces needed: [n=0] 
[16:19:12.833]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.833]  - seeds: <none>
[16:19:12.833]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.833] getGlobalsAndPackages() ...
[16:19:12.833] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.834] Resolving globals: FALSE
[16:19:12.834] Tweak future expression to call with '...' arguments ...
[16:19:12.834] {
[16:19:12.834]     do.call(function(...) {
[16:19:12.834]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.834]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.834]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.834]             on.exit(options(oopts), add = TRUE)
[16:19:12.834]         }
[16:19:12.834]         {
[16:19:12.834]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.834]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.834]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.834]             })
[16:19:12.834]         }
[16:19:12.834]     }, args = future.call.arguments)
[16:19:12.834] }
[16:19:12.834] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.835] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.835] - packages: [1] ‘future.apply’
[16:19:12.835] getGlobalsAndPackages() ... DONE
[16:19:12.835] run() for ‘Future’ ...
[16:19:12.835] - state: ‘created’
[16:19:12.835] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.836]   - Field: ‘label’
[16:19:12.836]   - Field: ‘local’
[16:19:12.836]   - Field: ‘owner’
[16:19:12.836]   - Field: ‘envir’
[16:19:12.836]   - Field: ‘packages’
[16:19:12.836]   - Field: ‘gc’
[16:19:12.836]   - Field: ‘conditions’
[16:19:12.837]   - Field: ‘expr’
[16:19:12.837]   - Field: ‘uuid’
[16:19:12.837]   - Field: ‘seed’
[16:19:12.837]   - Field: ‘version’
[16:19:12.837]   - Field: ‘result’
[16:19:12.837]   - Field: ‘asynchronous’
[16:19:12.837]   - Field: ‘calls’
[16:19:12.837]   - Field: ‘globals’
[16:19:12.837]   - Field: ‘stdout’
[16:19:12.837]   - Field: ‘earlySignal’
[16:19:12.837]   - Field: ‘lazy’
[16:19:12.838]   - Field: ‘state’
[16:19:12.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.838] - Launch lazy future ...
[16:19:12.838] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:12.838] Packages needed by future strategies (n = 0): <none>
[16:19:12.839] {
[16:19:12.839]     {
[16:19:12.839]         {
[16:19:12.839]             ...future.startTime <- base::Sys.time()
[16:19:12.839]             {
[16:19:12.839]                 {
[16:19:12.839]                   {
[16:19:12.839]                     {
[16:19:12.839]                       base::local({
[16:19:12.839]                         has_future <- base::requireNamespace("future", 
[16:19:12.839]                           quietly = TRUE)
[16:19:12.839]                         if (has_future) {
[16:19:12.839]                           ns <- base::getNamespace("future")
[16:19:12.839]                           version <- ns[[".package"]][["version"]]
[16:19:12.839]                           if (is.null(version)) 
[16:19:12.839]                             version <- utils::packageVersion("future")
[16:19:12.839]                         }
[16:19:12.839]                         else {
[16:19:12.839]                           version <- NULL
[16:19:12.839]                         }
[16:19:12.839]                         if (!has_future || version < "1.8.0") {
[16:19:12.839]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.839]                             "", base::R.version$version.string), 
[16:19:12.839]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.839]                               "release", "version")], collapse = " "), 
[16:19:12.839]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.839]                             info)
[16:19:12.839]                           info <- base::paste(info, collapse = "; ")
[16:19:12.839]                           if (!has_future) {
[16:19:12.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.839]                               info)
[16:19:12.839]                           }
[16:19:12.839]                           else {
[16:19:12.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.839]                               info, version)
[16:19:12.839]                           }
[16:19:12.839]                           base::stop(msg)
[16:19:12.839]                         }
[16:19:12.839]                       })
[16:19:12.839]                     }
[16:19:12.839]                     base::local({
[16:19:12.839]                       for (pkg in "future.apply") {
[16:19:12.839]                         base::loadNamespace(pkg)
[16:19:12.839]                         base::library(pkg, character.only = TRUE)
[16:19:12.839]                       }
[16:19:12.839]                     })
[16:19:12.839]                   }
[16:19:12.839]                   ...future.strategy.old <- future::plan("list")
[16:19:12.839]                   options(future.plan = NULL)
[16:19:12.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.839]                 }
[16:19:12.839]                 ...future.workdir <- getwd()
[16:19:12.839]             }
[16:19:12.839]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.839]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.839]         }
[16:19:12.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.839]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.839]             base::names(...future.oldOptions))
[16:19:12.839]     }
[16:19:12.839]     if (FALSE) {
[16:19:12.839]     }
[16:19:12.839]     else {
[16:19:12.839]         if (TRUE) {
[16:19:12.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.839]                 open = "w")
[16:19:12.839]         }
[16:19:12.839]         else {
[16:19:12.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.839]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.839]         }
[16:19:12.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.839]             base::sink(type = "output", split = FALSE)
[16:19:12.839]             base::close(...future.stdout)
[16:19:12.839]         }, add = TRUE)
[16:19:12.839]     }
[16:19:12.839]     ...future.frame <- base::sys.nframe()
[16:19:12.839]     ...future.conditions <- base::list()
[16:19:12.839]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.839]     if (FALSE) {
[16:19:12.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.839]     }
[16:19:12.839]     ...future.result <- base::tryCatch({
[16:19:12.839]         base::withCallingHandlers({
[16:19:12.839]             ...future.value <- base::withVisible(base::local({
[16:19:12.839]                 do.call(function(...) {
[16:19:12.839]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.839]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.839]                     ...future.globals.maxSize)) {
[16:19:12.839]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.839]                     on.exit(options(oopts), add = TRUE)
[16:19:12.839]                   }
[16:19:12.839]                   {
[16:19:12.839]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.839]                       FUN = function(jj) {
[16:19:12.839]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.839]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.839]                       })
[16:19:12.839]                   }
[16:19:12.839]                 }, args = future.call.arguments)
[16:19:12.839]             }))
[16:19:12.839]             future::FutureResult(value = ...future.value$value, 
[16:19:12.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.839]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.839]                     ...future.globalenv.names))
[16:19:12.839]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.839]         }, condition = base::local({
[16:19:12.839]             c <- base::c
[16:19:12.839]             inherits <- base::inherits
[16:19:12.839]             invokeRestart <- base::invokeRestart
[16:19:12.839]             length <- base::length
[16:19:12.839]             list <- base::list
[16:19:12.839]             seq.int <- base::seq.int
[16:19:12.839]             signalCondition <- base::signalCondition
[16:19:12.839]             sys.calls <- base::sys.calls
[16:19:12.839]             `[[` <- base::`[[`
[16:19:12.839]             `+` <- base::`+`
[16:19:12.839]             `<<-` <- base::`<<-`
[16:19:12.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.839]                   3L)]
[16:19:12.839]             }
[16:19:12.839]             function(cond) {
[16:19:12.839]                 is_error <- inherits(cond, "error")
[16:19:12.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.839]                   NULL)
[16:19:12.839]                 if (is_error) {
[16:19:12.839]                   sessionInformation <- function() {
[16:19:12.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.839]                       search = base::search(), system = base::Sys.info())
[16:19:12.839]                   }
[16:19:12.839]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.839]                     cond$call), session = sessionInformation(), 
[16:19:12.839]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.839]                   signalCondition(cond)
[16:19:12.839]                 }
[16:19:12.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.839]                 "immediateCondition"))) {
[16:19:12.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.839]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.839]                   if (TRUE && !signal) {
[16:19:12.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.839]                     {
[16:19:12.839]                       inherits <- base::inherits
[16:19:12.839]                       invokeRestart <- base::invokeRestart
[16:19:12.839]                       is.null <- base::is.null
[16:19:12.839]                       muffled <- FALSE
[16:19:12.839]                       if (inherits(cond, "message")) {
[16:19:12.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.839]                         if (muffled) 
[16:19:12.839]                           invokeRestart("muffleMessage")
[16:19:12.839]                       }
[16:19:12.839]                       else if (inherits(cond, "warning")) {
[16:19:12.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.839]                         if (muffled) 
[16:19:12.839]                           invokeRestart("muffleWarning")
[16:19:12.839]                       }
[16:19:12.839]                       else if (inherits(cond, "condition")) {
[16:19:12.839]                         if (!is.null(pattern)) {
[16:19:12.839]                           computeRestarts <- base::computeRestarts
[16:19:12.839]                           grepl <- base::grepl
[16:19:12.839]                           restarts <- computeRestarts(cond)
[16:19:12.839]                           for (restart in restarts) {
[16:19:12.839]                             name <- restart$name
[16:19:12.839]                             if (is.null(name)) 
[16:19:12.839]                               next
[16:19:12.839]                             if (!grepl(pattern, name)) 
[16:19:12.839]                               next
[16:19:12.839]                             invokeRestart(restart)
[16:19:12.839]                             muffled <- TRUE
[16:19:12.839]                             break
[16:19:12.839]                           }
[16:19:12.839]                         }
[16:19:12.839]                       }
[16:19:12.839]                       invisible(muffled)
[16:19:12.839]                     }
[16:19:12.839]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.839]                   }
[16:19:12.839]                 }
[16:19:12.839]                 else {
[16:19:12.839]                   if (TRUE) {
[16:19:12.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.839]                     {
[16:19:12.839]                       inherits <- base::inherits
[16:19:12.839]                       invokeRestart <- base::invokeRestart
[16:19:12.839]                       is.null <- base::is.null
[16:19:12.839]                       muffled <- FALSE
[16:19:12.839]                       if (inherits(cond, "message")) {
[16:19:12.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.839]                         if (muffled) 
[16:19:12.839]                           invokeRestart("muffleMessage")
[16:19:12.839]                       }
[16:19:12.839]                       else if (inherits(cond, "warning")) {
[16:19:12.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.839]                         if (muffled) 
[16:19:12.839]                           invokeRestart("muffleWarning")
[16:19:12.839]                       }
[16:19:12.839]                       else if (inherits(cond, "condition")) {
[16:19:12.839]                         if (!is.null(pattern)) {
[16:19:12.839]                           computeRestarts <- base::computeRestarts
[16:19:12.839]                           grepl <- base::grepl
[16:19:12.839]                           restarts <- computeRestarts(cond)
[16:19:12.839]                           for (restart in restarts) {
[16:19:12.839]                             name <- restart$name
[16:19:12.839]                             if (is.null(name)) 
[16:19:12.839]                               next
[16:19:12.839]                             if (!grepl(pattern, name)) 
[16:19:12.839]                               next
[16:19:12.839]                             invokeRestart(restart)
[16:19:12.839]                             muffled <- TRUE
[16:19:12.839]                             break
[16:19:12.839]                           }
[16:19:12.839]                         }
[16:19:12.839]                       }
[16:19:12.839]                       invisible(muffled)
[16:19:12.839]                     }
[16:19:12.839]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.839]                   }
[16:19:12.839]                 }
[16:19:12.839]             }
[16:19:12.839]         }))
[16:19:12.839]     }, error = function(ex) {
[16:19:12.839]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.839]                 ...future.rng), started = ...future.startTime, 
[16:19:12.839]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.839]             version = "1.8"), class = "FutureResult")
[16:19:12.839]     }, finally = {
[16:19:12.839]         if (!identical(...future.workdir, getwd())) 
[16:19:12.839]             setwd(...future.workdir)
[16:19:12.839]         {
[16:19:12.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.839]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.839]             }
[16:19:12.839]             base::options(...future.oldOptions)
[16:19:12.839]             if (.Platform$OS.type == "windows") {
[16:19:12.839]                 old_names <- names(...future.oldEnvVars)
[16:19:12.839]                 envs <- base::Sys.getenv()
[16:19:12.839]                 names <- names(envs)
[16:19:12.839]                 common <- intersect(names, old_names)
[16:19:12.839]                 added <- setdiff(names, old_names)
[16:19:12.839]                 removed <- setdiff(old_names, names)
[16:19:12.839]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.839]                   envs[common]]
[16:19:12.839]                 NAMES <- toupper(changed)
[16:19:12.839]                 args <- list()
[16:19:12.839]                 for (kk in seq_along(NAMES)) {
[16:19:12.839]                   name <- changed[[kk]]
[16:19:12.839]                   NAME <- NAMES[[kk]]
[16:19:12.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.839]                     next
[16:19:12.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.839]                 }
[16:19:12.839]                 NAMES <- toupper(added)
[16:19:12.839]                 for (kk in seq_along(NAMES)) {
[16:19:12.839]                   name <- added[[kk]]
[16:19:12.839]                   NAME <- NAMES[[kk]]
[16:19:12.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.839]                     next
[16:19:12.839]                   args[[name]] <- ""
[16:19:12.839]                 }
[16:19:12.839]                 NAMES <- toupper(removed)
[16:19:12.839]                 for (kk in seq_along(NAMES)) {
[16:19:12.839]                   name <- removed[[kk]]
[16:19:12.839]                   NAME <- NAMES[[kk]]
[16:19:12.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.839]                     next
[16:19:12.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.839]                 }
[16:19:12.839]                 if (length(args) > 0) 
[16:19:12.839]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.839]             }
[16:19:12.839]             else {
[16:19:12.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.839]             }
[16:19:12.839]             {
[16:19:12.839]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.839]                   0L) {
[16:19:12.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.839]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.839]                   base::options(opts)
[16:19:12.839]                 }
[16:19:12.839]                 {
[16:19:12.839]                   {
[16:19:12.839]                     NULL
[16:19:12.839]                     RNGkind("Mersenne-Twister")
[16:19:12.839]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.839]                       inherits = FALSE)
[16:19:12.839]                   }
[16:19:12.839]                   options(future.plan = NULL)
[16:19:12.839]                   if (is.na(NA_character_)) 
[16:19:12.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.839]                     .init = FALSE)
[16:19:12.839]                 }
[16:19:12.839]             }
[16:19:12.839]         }
[16:19:12.839]     })
[16:19:12.839]     if (TRUE) {
[16:19:12.839]         base::sink(type = "output", split = FALSE)
[16:19:12.839]         if (TRUE) {
[16:19:12.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.839]         }
[16:19:12.839]         else {
[16:19:12.839]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.839]         }
[16:19:12.839]         base::close(...future.stdout)
[16:19:12.839]         ...future.stdout <- NULL
[16:19:12.839]     }
[16:19:12.839]     ...future.result$conditions <- ...future.conditions
[16:19:12.839]     ...future.result$finished <- base::Sys.time()
[16:19:12.839]     ...future.result
[16:19:12.839] }
[16:19:12.840] assign_globals() ...
[16:19:12.840] List of 11
[16:19:12.840]  $ ...future.FUN            :function (x, ...)  
[16:19:12.840]  $ x_FUN                    :function (x)  
[16:19:12.840]  $ times                    : int 4
[16:19:12.840]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.840]  $ stop_if_not              :function (...)  
[16:19:12.840]  $ dim                      : int [1:2] 2 2
[16:19:12.840]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:12.840]  $ future.call.arguments    : list()
[16:19:12.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.840]  $ ...future.elements_ii    :List of 10
[16:19:12.840]   ..$ : int 1
[16:19:12.840]   ..$ : int 2
[16:19:12.840]   ..$ : int 3
[16:19:12.840]   ..$ : int 4
[16:19:12.840]   ..$ : int 5
[16:19:12.840]   ..$ : int 6
[16:19:12.840]   ..$ : int 7
[16:19:12.840]   ..$ : int 8
[16:19:12.840]   ..$ : int 9
[16:19:12.840]   ..$ : int 10
[16:19:12.840]  $ ...future.seeds_ii       : NULL
[16:19:12.840]  $ ...future.globals.maxSize: NULL
[16:19:12.840]  - attr(*, "where")=List of 11
[16:19:12.840]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.840]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.840]  - attr(*, "resolved")= logi FALSE
[16:19:12.840]  - attr(*, "total_size")= num 105552
[16:19:12.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.840]  - attr(*, "already-done")= logi TRUE
[16:19:12.852] - copied ‘...future.FUN’ to environment
[16:19:12.852] - reassign environment for ‘x_FUN’
[16:19:12.852] - copied ‘x_FUN’ to environment
[16:19:12.852] - copied ‘times’ to environment
[16:19:12.852] - copied ‘stopf’ to environment
[16:19:12.852] - copied ‘stop_if_not’ to environment
[16:19:12.852] - copied ‘dim’ to environment
[16:19:12.853] - copied ‘valid_types’ to environment
[16:19:12.853] - copied ‘future.call.arguments’ to environment
[16:19:12.853] - copied ‘...future.elements_ii’ to environment
[16:19:12.853] - copied ‘...future.seeds_ii’ to environment
[16:19:12.853] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.853] assign_globals() ... done
[16:19:12.853] plan(): Setting new future strategy stack:
[16:19:12.853] List of future strategies:
[16:19:12.853] 1. sequential:
[16:19:12.853]    - args: function (..., envir = parent.frame())
[16:19:12.853]    - tweaked: FALSE
[16:19:12.853]    - call: NULL
[16:19:12.854] plan(): nbrOfWorkers() = 1
[16:19:12.855] plan(): Setting new future strategy stack:
[16:19:12.855] List of future strategies:
[16:19:12.855] 1. sequential:
[16:19:12.855]    - args: function (..., envir = parent.frame())
[16:19:12.855]    - tweaked: FALSE
[16:19:12.855]    - call: plan(strategy)
[16:19:12.855] plan(): nbrOfWorkers() = 1
[16:19:12.855] SequentialFuture started (and completed)
[16:19:12.855] - Launch lazy future ... done
[16:19:12.855] run() for ‘SequentialFuture’ ... done
[16:19:12.856] Created future:
[16:19:12.856] SequentialFuture:
[16:19:12.856] Label: ‘future_vapply-1’
[16:19:12.856] Expression:
[16:19:12.856] {
[16:19:12.856]     do.call(function(...) {
[16:19:12.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.856]             on.exit(options(oopts), add = TRUE)
[16:19:12.856]         }
[16:19:12.856]         {
[16:19:12.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.856]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.856]             })
[16:19:12.856]         }
[16:19:12.856]     }, args = future.call.arguments)
[16:19:12.856] }
[16:19:12.856] Lazy evaluation: FALSE
[16:19:12.856] Asynchronous evaluation: FALSE
[16:19:12.856] Local evaluation: TRUE
[16:19:12.856] Environment: R_GlobalEnv
[16:19:12.856] Capture standard output: TRUE
[16:19:12.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.856] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.856] Packages: 1 packages (‘future.apply’)
[16:19:12.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.856] Resolved: TRUE
[16:19:12.856] Value: 7.42 KiB of class ‘list’
[16:19:12.856] Early signaling: FALSE
[16:19:12.856] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.856] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.857] Chunk #1 of 1 ... DONE
[16:19:12.857] Launching 1 futures (chunks) ... DONE
[16:19:12.857] Resolving 1 futures (chunks) ...
[16:19:12.857] resolve() on list ...
[16:19:12.857]  recursive: 0
[16:19:12.857]  length: 1
[16:19:12.857] 
[16:19:12.858] resolved() for ‘SequentialFuture’ ...
[16:19:12.858] - state: ‘finished’
[16:19:12.858] - run: TRUE
[16:19:12.858] - result: ‘FutureResult’
[16:19:12.858] resolved() for ‘SequentialFuture’ ... done
[16:19:12.858] Future #1
[16:19:12.858] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.858] - nx: 1
[16:19:12.858] - relay: TRUE
[16:19:12.858] - stdout: TRUE
[16:19:12.858] - signal: TRUE
[16:19:12.859] - resignal: FALSE
[16:19:12.859] - force: TRUE
[16:19:12.859] - relayed: [n=1] FALSE
[16:19:12.859] - queued futures: [n=1] FALSE
[16:19:12.859]  - until=1
[16:19:12.859]  - relaying element #1
[16:19:12.859] - relayed: [n=1] TRUE
[16:19:12.859] - queued futures: [n=1] TRUE
[16:19:12.859] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.859]  length: 0 (resolved future 1)
[16:19:12.860] Relaying remaining futures
[16:19:12.860] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.860] - nx: 1
[16:19:12.860] - relay: TRUE
[16:19:12.860] - stdout: TRUE
[16:19:12.860] - signal: TRUE
[16:19:12.860] - resignal: FALSE
[16:19:12.860] - force: TRUE
[16:19:12.860] - relayed: [n=1] TRUE
[16:19:12.860] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.860] - relayed: [n=1] TRUE
[16:19:12.861] - queued futures: [n=1] TRUE
[16:19:12.861] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.861] resolve() on list ... DONE
[16:19:12.861]  - Number of value chunks collected: 1
[16:19:12.861] Resolving 1 futures (chunks) ... DONE
[16:19:12.861] Reducing values from 1 chunks ...
[16:19:12.861]  - Number of values collected after concatenation: 10
[16:19:12.861]  - Number of values expected: 10
[16:19:12.861] Reducing values from 1 chunks ... DONE
[16:19:12.861] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:19:12.865] future_lapply() ...
[16:19:12.867] Number of chunks: 1
[16:19:12.867] getGlobalsAndPackagesXApply() ...
[16:19:12.867]  - future.globals: TRUE
[16:19:12.868] getGlobalsAndPackages() ...
[16:19:12.869] Searching for globals...
[16:19:12.872] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:19:12.872] Searching for globals ... DONE
[16:19:12.872] Resolving globals: FALSE
[16:19:12.873] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:19:12.874] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:12.874] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.874] - packages: [2] ‘stats’, ‘future.apply’
[16:19:12.874] getGlobalsAndPackages() ... DONE
[16:19:12.874]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.874]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:19:12.874] Finding globals ... DONE
[16:19:12.874]  - use_args: TRUE
[16:19:12.875]  - Getting '...' globals ...
[16:19:12.875] resolve() on list ...
[16:19:12.875]  recursive: 0
[16:19:12.875]  length: 1
[16:19:12.875]  elements: ‘...’
[16:19:12.875]  length: 0 (resolved future 1)
[16:19:12.875] resolve() on list ... DONE
[16:19:12.875]    - '...' content: [n=0] 
[16:19:12.876] List of 1
[16:19:12.876]  $ ...: list()
[16:19:12.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.876]  - attr(*, "where")=List of 1
[16:19:12.876]   ..$ ...:<environment: 0x56199f52ac20> 
[16:19:12.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.876]  - attr(*, "resolved")= logi TRUE
[16:19:12.876]  - attr(*, "total_size")= num NA
[16:19:12.878]  - Getting '...' globals ... DONE
[16:19:12.878] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.878] List of 8
[16:19:12.878]  $ ...future.FUN:function (x, ...)  
[16:19:12.878]  $ x_FUN        :function (x, ...)  
[16:19:12.878]  $ times        : int 5
[16:19:12.878]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.878]  $ stop_if_not  :function (...)  
[16:19:12.878]  $ dim          : NULL
[16:19:12.878]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:12.878]  $ ...          : list()
[16:19:12.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.878]  - attr(*, "where")=List of 8
[16:19:12.878]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.878]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.878]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.878]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.878]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.878]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.878]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.878]   ..$ ...          :<environment: 0x56199f52ac20> 
[16:19:12.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.878]  - attr(*, "resolved")= logi FALSE
[16:19:12.878]  - attr(*, "total_size")= num 95528
[16:19:12.883] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:19:12.884] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.884] Number of futures (= number of chunks): 1
[16:19:12.884] Launching 1 futures (chunks) ...
[16:19:12.884] Chunk #1 of 1 ...
[16:19:12.884]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.884] getGlobalsAndPackages() ...
[16:19:12.884] Searching for globals...
[16:19:12.885] 
[16:19:12.885] Searching for globals ... DONE
[16:19:12.885] - globals: [0] <none>
[16:19:12.885] getGlobalsAndPackages() ... DONE
[16:19:12.885]    + additional globals found: [n=0] 
[16:19:12.885]    + additional namespaces needed: [n=0] 
[16:19:12.885]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.885]  - seeds: <none>
[16:19:12.885]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.885] getGlobalsAndPackages() ...
[16:19:12.885] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.886] Resolving globals: FALSE
[16:19:12.886] Tweak future expression to call with '...' arguments ...
[16:19:12.886] {
[16:19:12.886]     do.call(function(...) {
[16:19:12.886]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.886]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.886]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.886]             on.exit(options(oopts), add = TRUE)
[16:19:12.886]         }
[16:19:12.886]         {
[16:19:12.886]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.886]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.886]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.886]             })
[16:19:12.886]         }
[16:19:12.886]     }, args = future.call.arguments)
[16:19:12.886] }
[16:19:12.886] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.887] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.887] - packages: [2] ‘stats’, ‘future.apply’
[16:19:12.887] getGlobalsAndPackages() ... DONE
[16:19:12.887] run() for ‘Future’ ...
[16:19:12.887] - state: ‘created’
[16:19:12.887] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.888] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.888]   - Field: ‘label’
[16:19:12.888]   - Field: ‘local’
[16:19:12.888]   - Field: ‘owner’
[16:19:12.888]   - Field: ‘envir’
[16:19:12.888]   - Field: ‘packages’
[16:19:12.888]   - Field: ‘gc’
[16:19:12.889]   - Field: ‘conditions’
[16:19:12.889]   - Field: ‘expr’
[16:19:12.889]   - Field: ‘uuid’
[16:19:12.889]   - Field: ‘seed’
[16:19:12.889]   - Field: ‘version’
[16:19:12.889]   - Field: ‘result’
[16:19:12.891]   - Field: ‘asynchronous’
[16:19:12.891]   - Field: ‘calls’
[16:19:12.891]   - Field: ‘globals’
[16:19:12.891]   - Field: ‘stdout’
[16:19:12.891]   - Field: ‘earlySignal’
[16:19:12.891]   - Field: ‘lazy’
[16:19:12.891]   - Field: ‘state’
[16:19:12.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.892] - Launch lazy future ...
[16:19:12.892] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:12.892] Packages needed by future strategies (n = 0): <none>
[16:19:12.893] {
[16:19:12.893]     {
[16:19:12.893]         {
[16:19:12.893]             ...future.startTime <- base::Sys.time()
[16:19:12.893]             {
[16:19:12.893]                 {
[16:19:12.893]                   {
[16:19:12.893]                     {
[16:19:12.893]                       base::local({
[16:19:12.893]                         has_future <- base::requireNamespace("future", 
[16:19:12.893]                           quietly = TRUE)
[16:19:12.893]                         if (has_future) {
[16:19:12.893]                           ns <- base::getNamespace("future")
[16:19:12.893]                           version <- ns[[".package"]][["version"]]
[16:19:12.893]                           if (is.null(version)) 
[16:19:12.893]                             version <- utils::packageVersion("future")
[16:19:12.893]                         }
[16:19:12.893]                         else {
[16:19:12.893]                           version <- NULL
[16:19:12.893]                         }
[16:19:12.893]                         if (!has_future || version < "1.8.0") {
[16:19:12.893]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.893]                             "", base::R.version$version.string), 
[16:19:12.893]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.893]                               "release", "version")], collapse = " "), 
[16:19:12.893]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.893]                             info)
[16:19:12.893]                           info <- base::paste(info, collapse = "; ")
[16:19:12.893]                           if (!has_future) {
[16:19:12.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.893]                               info)
[16:19:12.893]                           }
[16:19:12.893]                           else {
[16:19:12.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.893]                               info, version)
[16:19:12.893]                           }
[16:19:12.893]                           base::stop(msg)
[16:19:12.893]                         }
[16:19:12.893]                       })
[16:19:12.893]                     }
[16:19:12.893]                     base::local({
[16:19:12.893]                       for (pkg in c("stats", "future.apply")) {
[16:19:12.893]                         base::loadNamespace(pkg)
[16:19:12.893]                         base::library(pkg, character.only = TRUE)
[16:19:12.893]                       }
[16:19:12.893]                     })
[16:19:12.893]                   }
[16:19:12.893]                   ...future.strategy.old <- future::plan("list")
[16:19:12.893]                   options(future.plan = NULL)
[16:19:12.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.893]                 }
[16:19:12.893]                 ...future.workdir <- getwd()
[16:19:12.893]             }
[16:19:12.893]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.893]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.893]         }
[16:19:12.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.893]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.893]             base::names(...future.oldOptions))
[16:19:12.893]     }
[16:19:12.893]     if (FALSE) {
[16:19:12.893]     }
[16:19:12.893]     else {
[16:19:12.893]         if (TRUE) {
[16:19:12.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.893]                 open = "w")
[16:19:12.893]         }
[16:19:12.893]         else {
[16:19:12.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.893]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.893]         }
[16:19:12.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.893]             base::sink(type = "output", split = FALSE)
[16:19:12.893]             base::close(...future.stdout)
[16:19:12.893]         }, add = TRUE)
[16:19:12.893]     }
[16:19:12.893]     ...future.frame <- base::sys.nframe()
[16:19:12.893]     ...future.conditions <- base::list()
[16:19:12.893]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.893]     if (FALSE) {
[16:19:12.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.893]     }
[16:19:12.893]     ...future.result <- base::tryCatch({
[16:19:12.893]         base::withCallingHandlers({
[16:19:12.893]             ...future.value <- base::withVisible(base::local({
[16:19:12.893]                 do.call(function(...) {
[16:19:12.893]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.893]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.893]                     ...future.globals.maxSize)) {
[16:19:12.893]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.893]                     on.exit(options(oopts), add = TRUE)
[16:19:12.893]                   }
[16:19:12.893]                   {
[16:19:12.893]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.893]                       FUN = function(jj) {
[16:19:12.893]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.893]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.893]                       })
[16:19:12.893]                   }
[16:19:12.893]                 }, args = future.call.arguments)
[16:19:12.893]             }))
[16:19:12.893]             future::FutureResult(value = ...future.value$value, 
[16:19:12.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.893]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.893]                     ...future.globalenv.names))
[16:19:12.893]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.893]         }, condition = base::local({
[16:19:12.893]             c <- base::c
[16:19:12.893]             inherits <- base::inherits
[16:19:12.893]             invokeRestart <- base::invokeRestart
[16:19:12.893]             length <- base::length
[16:19:12.893]             list <- base::list
[16:19:12.893]             seq.int <- base::seq.int
[16:19:12.893]             signalCondition <- base::signalCondition
[16:19:12.893]             sys.calls <- base::sys.calls
[16:19:12.893]             `[[` <- base::`[[`
[16:19:12.893]             `+` <- base::`+`
[16:19:12.893]             `<<-` <- base::`<<-`
[16:19:12.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.893]                   3L)]
[16:19:12.893]             }
[16:19:12.893]             function(cond) {
[16:19:12.893]                 is_error <- inherits(cond, "error")
[16:19:12.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.893]                   NULL)
[16:19:12.893]                 if (is_error) {
[16:19:12.893]                   sessionInformation <- function() {
[16:19:12.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.893]                       search = base::search(), system = base::Sys.info())
[16:19:12.893]                   }
[16:19:12.893]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.893]                     cond$call), session = sessionInformation(), 
[16:19:12.893]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.893]                   signalCondition(cond)
[16:19:12.893]                 }
[16:19:12.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.893]                 "immediateCondition"))) {
[16:19:12.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.893]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.893]                   if (TRUE && !signal) {
[16:19:12.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.893]                     {
[16:19:12.893]                       inherits <- base::inherits
[16:19:12.893]                       invokeRestart <- base::invokeRestart
[16:19:12.893]                       is.null <- base::is.null
[16:19:12.893]                       muffled <- FALSE
[16:19:12.893]                       if (inherits(cond, "message")) {
[16:19:12.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.893]                         if (muffled) 
[16:19:12.893]                           invokeRestart("muffleMessage")
[16:19:12.893]                       }
[16:19:12.893]                       else if (inherits(cond, "warning")) {
[16:19:12.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.893]                         if (muffled) 
[16:19:12.893]                           invokeRestart("muffleWarning")
[16:19:12.893]                       }
[16:19:12.893]                       else if (inherits(cond, "condition")) {
[16:19:12.893]                         if (!is.null(pattern)) {
[16:19:12.893]                           computeRestarts <- base::computeRestarts
[16:19:12.893]                           grepl <- base::grepl
[16:19:12.893]                           restarts <- computeRestarts(cond)
[16:19:12.893]                           for (restart in restarts) {
[16:19:12.893]                             name <- restart$name
[16:19:12.893]                             if (is.null(name)) 
[16:19:12.893]                               next
[16:19:12.893]                             if (!grepl(pattern, name)) 
[16:19:12.893]                               next
[16:19:12.893]                             invokeRestart(restart)
[16:19:12.893]                             muffled <- TRUE
[16:19:12.893]                             break
[16:19:12.893]                           }
[16:19:12.893]                         }
[16:19:12.893]                       }
[16:19:12.893]                       invisible(muffled)
[16:19:12.893]                     }
[16:19:12.893]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.893]                   }
[16:19:12.893]                 }
[16:19:12.893]                 else {
[16:19:12.893]                   if (TRUE) {
[16:19:12.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.893]                     {
[16:19:12.893]                       inherits <- base::inherits
[16:19:12.893]                       invokeRestart <- base::invokeRestart
[16:19:12.893]                       is.null <- base::is.null
[16:19:12.893]                       muffled <- FALSE
[16:19:12.893]                       if (inherits(cond, "message")) {
[16:19:12.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.893]                         if (muffled) 
[16:19:12.893]                           invokeRestart("muffleMessage")
[16:19:12.893]                       }
[16:19:12.893]                       else if (inherits(cond, "warning")) {
[16:19:12.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.893]                         if (muffled) 
[16:19:12.893]                           invokeRestart("muffleWarning")
[16:19:12.893]                       }
[16:19:12.893]                       else if (inherits(cond, "condition")) {
[16:19:12.893]                         if (!is.null(pattern)) {
[16:19:12.893]                           computeRestarts <- base::computeRestarts
[16:19:12.893]                           grepl <- base::grepl
[16:19:12.893]                           restarts <- computeRestarts(cond)
[16:19:12.893]                           for (restart in restarts) {
[16:19:12.893]                             name <- restart$name
[16:19:12.893]                             if (is.null(name)) 
[16:19:12.893]                               next
[16:19:12.893]                             if (!grepl(pattern, name)) 
[16:19:12.893]                               next
[16:19:12.893]                             invokeRestart(restart)
[16:19:12.893]                             muffled <- TRUE
[16:19:12.893]                             break
[16:19:12.893]                           }
[16:19:12.893]                         }
[16:19:12.893]                       }
[16:19:12.893]                       invisible(muffled)
[16:19:12.893]                     }
[16:19:12.893]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.893]                   }
[16:19:12.893]                 }
[16:19:12.893]             }
[16:19:12.893]         }))
[16:19:12.893]     }, error = function(ex) {
[16:19:12.893]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.893]                 ...future.rng), started = ...future.startTime, 
[16:19:12.893]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.893]             version = "1.8"), class = "FutureResult")
[16:19:12.893]     }, finally = {
[16:19:12.893]         if (!identical(...future.workdir, getwd())) 
[16:19:12.893]             setwd(...future.workdir)
[16:19:12.893]         {
[16:19:12.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.893]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.893]             }
[16:19:12.893]             base::options(...future.oldOptions)
[16:19:12.893]             if (.Platform$OS.type == "windows") {
[16:19:12.893]                 old_names <- names(...future.oldEnvVars)
[16:19:12.893]                 envs <- base::Sys.getenv()
[16:19:12.893]                 names <- names(envs)
[16:19:12.893]                 common <- intersect(names, old_names)
[16:19:12.893]                 added <- setdiff(names, old_names)
[16:19:12.893]                 removed <- setdiff(old_names, names)
[16:19:12.893]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.893]                   envs[common]]
[16:19:12.893]                 NAMES <- toupper(changed)
[16:19:12.893]                 args <- list()
[16:19:12.893]                 for (kk in seq_along(NAMES)) {
[16:19:12.893]                   name <- changed[[kk]]
[16:19:12.893]                   NAME <- NAMES[[kk]]
[16:19:12.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.893]                     next
[16:19:12.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.893]                 }
[16:19:12.893]                 NAMES <- toupper(added)
[16:19:12.893]                 for (kk in seq_along(NAMES)) {
[16:19:12.893]                   name <- added[[kk]]
[16:19:12.893]                   NAME <- NAMES[[kk]]
[16:19:12.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.893]                     next
[16:19:12.893]                   args[[name]] <- ""
[16:19:12.893]                 }
[16:19:12.893]                 NAMES <- toupper(removed)
[16:19:12.893]                 for (kk in seq_along(NAMES)) {
[16:19:12.893]                   name <- removed[[kk]]
[16:19:12.893]                   NAME <- NAMES[[kk]]
[16:19:12.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.893]                     next
[16:19:12.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.893]                 }
[16:19:12.893]                 if (length(args) > 0) 
[16:19:12.893]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.893]             }
[16:19:12.893]             else {
[16:19:12.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.893]             }
[16:19:12.893]             {
[16:19:12.893]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.893]                   0L) {
[16:19:12.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.893]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.893]                   base::options(opts)
[16:19:12.893]                 }
[16:19:12.893]                 {
[16:19:12.893]                   {
[16:19:12.893]                     NULL
[16:19:12.893]                     RNGkind("Mersenne-Twister")
[16:19:12.893]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.893]                       inherits = FALSE)
[16:19:12.893]                   }
[16:19:12.893]                   options(future.plan = NULL)
[16:19:12.893]                   if (is.na(NA_character_)) 
[16:19:12.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.893]                     .init = FALSE)
[16:19:12.893]                 }
[16:19:12.893]             }
[16:19:12.893]         }
[16:19:12.893]     })
[16:19:12.893]     if (TRUE) {
[16:19:12.893]         base::sink(type = "output", split = FALSE)
[16:19:12.893]         if (TRUE) {
[16:19:12.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.893]         }
[16:19:12.893]         else {
[16:19:12.893]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.893]         }
[16:19:12.893]         base::close(...future.stdout)
[16:19:12.893]         ...future.stdout <- NULL
[16:19:12.893]     }
[16:19:12.893]     ...future.result$conditions <- ...future.conditions
[16:19:12.893]     ...future.result$finished <- base::Sys.time()
[16:19:12.893]     ...future.result
[16:19:12.893] }
[16:19:12.895] assign_globals() ...
[16:19:12.895] List of 11
[16:19:12.895]  $ ...future.FUN            :function (x, ...)  
[16:19:12.895]  $ x_FUN                    :function (x, ...)  
[16:19:12.895]  $ times                    : int 5
[16:19:12.895]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.895]  $ stop_if_not              :function (...)  
[16:19:12.895]  $ dim                      : NULL
[16:19:12.895]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:12.895]  $ future.call.arguments    : list()
[16:19:12.895]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.895]  $ ...future.elements_ii    :List of 3
[16:19:12.895]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:19:12.895]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:19:12.895]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:19:12.895]  $ ...future.seeds_ii       : NULL
[16:19:12.895]  $ ...future.globals.maxSize: NULL
[16:19:12.895]  - attr(*, "where")=List of 11
[16:19:12.895]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.895]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.895]  - attr(*, "resolved")= logi FALSE
[16:19:12.895]  - attr(*, "total_size")= num 95528
[16:19:12.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.895]  - attr(*, "already-done")= logi TRUE
[16:19:12.903] - copied ‘...future.FUN’ to environment
[16:19:12.904] - copied ‘x_FUN’ to environment
[16:19:12.904] - copied ‘times’ to environment
[16:19:12.904] - copied ‘stopf’ to environment
[16:19:12.904] - copied ‘stop_if_not’ to environment
[16:19:12.904] - copied ‘dim’ to environment
[16:19:12.904] - copied ‘valid_types’ to environment
[16:19:12.904] - copied ‘future.call.arguments’ to environment
[16:19:12.904] - copied ‘...future.elements_ii’ to environment
[16:19:12.904] - copied ‘...future.seeds_ii’ to environment
[16:19:12.905] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.905] assign_globals() ... done
[16:19:12.905] plan(): Setting new future strategy stack:
[16:19:12.905] List of future strategies:
[16:19:12.905] 1. sequential:
[16:19:12.905]    - args: function (..., envir = parent.frame())
[16:19:12.905]    - tweaked: FALSE
[16:19:12.905]    - call: NULL
[16:19:12.906] plan(): nbrOfWorkers() = 1
[16:19:12.907] plan(): Setting new future strategy stack:
[16:19:12.907] List of future strategies:
[16:19:12.907] 1. sequential:
[16:19:12.907]    - args: function (..., envir = parent.frame())
[16:19:12.907]    - tweaked: FALSE
[16:19:12.907]    - call: plan(strategy)
[16:19:12.908] plan(): nbrOfWorkers() = 1
[16:19:12.908] SequentialFuture started (and completed)
[16:19:12.908] - Launch lazy future ... done
[16:19:12.908] run() for ‘SequentialFuture’ ... done
[16:19:12.908] Created future:
[16:19:12.908] SequentialFuture:
[16:19:12.908] Label: ‘future_vapply-1’
[16:19:12.908] Expression:
[16:19:12.908] {
[16:19:12.908]     do.call(function(...) {
[16:19:12.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.908]             on.exit(options(oopts), add = TRUE)
[16:19:12.908]         }
[16:19:12.908]         {
[16:19:12.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.908]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.908]             })
[16:19:12.908]         }
[16:19:12.908]     }, args = future.call.arguments)
[16:19:12.908] }
[16:19:12.908] Lazy evaluation: FALSE
[16:19:12.908] Asynchronous evaluation: FALSE
[16:19:12.908] Local evaluation: TRUE
[16:19:12.908] Environment: R_GlobalEnv
[16:19:12.908] Capture standard output: TRUE
[16:19:12.908] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.908] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:12.908] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:12.908] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.908] Resolved: TRUE
[16:19:12.908] Value: 1.71 KiB of class ‘list’
[16:19:12.908] Early signaling: FALSE
[16:19:12.908] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.908] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.909] Chunk #1 of 1 ... DONE
[16:19:12.910] Launching 1 futures (chunks) ... DONE
[16:19:12.910] Resolving 1 futures (chunks) ...
[16:19:12.910] resolve() on list ...
[16:19:12.910]  recursive: 0
[16:19:12.910]  length: 1
[16:19:12.910] 
[16:19:12.910] resolved() for ‘SequentialFuture’ ...
[16:19:12.910] - state: ‘finished’
[16:19:12.910] - run: TRUE
[16:19:12.910] - result: ‘FutureResult’
[16:19:12.911] resolved() for ‘SequentialFuture’ ... done
[16:19:12.911] Future #1
[16:19:12.911] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.911] - nx: 1
[16:19:12.911] - relay: TRUE
[16:19:12.911] - stdout: TRUE
[16:19:12.911] - signal: TRUE
[16:19:12.911] - resignal: FALSE
[16:19:12.911] - force: TRUE
[16:19:12.911] - relayed: [n=1] FALSE
[16:19:12.912] - queued futures: [n=1] FALSE
[16:19:12.912]  - until=1
[16:19:12.912]  - relaying element #1
[16:19:12.912] - relayed: [n=1] TRUE
[16:19:12.912] - queued futures: [n=1] TRUE
[16:19:12.912] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.912]  length: 0 (resolved future 1)
[16:19:12.912] Relaying remaining futures
[16:19:12.912] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.913] - nx: 1
[16:19:12.913] - relay: TRUE
[16:19:12.913] - stdout: TRUE
[16:19:12.913] - signal: TRUE
[16:19:12.913] - resignal: FALSE
[16:19:12.913] - force: TRUE
[16:19:12.913] - relayed: [n=1] TRUE
[16:19:12.913] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.913] - relayed: [n=1] TRUE
[16:19:12.913] - queued futures: [n=1] TRUE
[16:19:12.913] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.914] resolve() on list ... DONE
[16:19:12.914]  - Number of value chunks collected: 1
[16:19:12.914] Resolving 1 futures (chunks) ... DONE
[16:19:12.914] Reducing values from 1 chunks ...
[16:19:12.914]  - Number of values collected after concatenation: 3
[16:19:12.914]  - Number of values expected: 3
[16:19:12.914] Reducing values from 1 chunks ... DONE
[16:19:12.914] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:19:12.918] future_lapply() ...
[16:19:12.923] Number of chunks: 1
[16:19:12.923] getGlobalsAndPackagesXApply() ...
[16:19:12.923]  - future.globals: TRUE
[16:19:12.923] getGlobalsAndPackages() ...
[16:19:12.923] Searching for globals...
[16:19:12.929] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:19:12.929] Searching for globals ... DONE
[16:19:12.929] Resolving globals: FALSE
[16:19:12.930] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:19:12.930] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:19:12.931] - globals: [1] ‘FUN’
[16:19:12.931] - packages: [1] ‘stats’
[16:19:12.931] getGlobalsAndPackages() ... DONE
[16:19:12.931]  - globals found/used: [n=1] ‘FUN’
[16:19:12.931]  - needed namespaces: [n=1] ‘stats’
[16:19:12.931] Finding globals ... DONE
[16:19:12.931]  - use_args: TRUE
[16:19:12.931]  - Getting '...' globals ...
[16:19:12.932] resolve() on list ...
[16:19:12.932]  recursive: 0
[16:19:12.932]  length: 1
[16:19:12.932]  elements: ‘...’
[16:19:12.932]  length: 0 (resolved future 1)
[16:19:12.932] resolve() on list ... DONE
[16:19:12.932]    - '...' content: [n=0] 
[16:19:12.932] List of 1
[16:19:12.932]  $ ...: list()
[16:19:12.932]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.932]  - attr(*, "where")=List of 1
[16:19:12.932]   ..$ ...:<environment: 0x56199e6b99f8> 
[16:19:12.932]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.932]  - attr(*, "resolved")= logi TRUE
[16:19:12.932]  - attr(*, "total_size")= num NA
[16:19:12.936]  - Getting '...' globals ... DONE
[16:19:12.936] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:12.936] List of 2
[16:19:12.936]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:19:12.936]  $ ...          : list()
[16:19:12.936]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.936]  - attr(*, "where")=List of 2
[16:19:12.936]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.936]   ..$ ...          :<environment: 0x56199e6b99f8> 
[16:19:12.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.936]  - attr(*, "resolved")= logi FALSE
[16:19:12.936]  - attr(*, "total_size")= num 46960
[16:19:12.940] Packages to be attached in all futures: [n=1] ‘stats’
[16:19:12.940] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.940] Number of futures (= number of chunks): 1
[16:19:12.940] Launching 1 futures (chunks) ...
[16:19:12.940] Chunk #1 of 1 ...
[16:19:12.942]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.942] getGlobalsAndPackages() ...
[16:19:12.943] Searching for globals...
[16:19:12.943] 
[16:19:12.943] Searching for globals ... DONE
[16:19:12.943] - globals: [0] <none>
[16:19:12.943] getGlobalsAndPackages() ... DONE
[16:19:12.943]    + additional globals found: [n=0] 
[16:19:12.943]    + additional namespaces needed: [n=0] 
[16:19:12.944]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.944]  - seeds: <none>
[16:19:12.944]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.944] getGlobalsAndPackages() ...
[16:19:12.944] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.944] Resolving globals: FALSE
[16:19:12.944] Tweak future expression to call with '...' arguments ...
[16:19:12.944] {
[16:19:12.944]     do.call(function(...) {
[16:19:12.944]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.944]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.944]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.944]             on.exit(options(oopts), add = TRUE)
[16:19:12.944]         }
[16:19:12.944]         {
[16:19:12.944]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.944]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.944]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.944]             })
[16:19:12.944]         }
[16:19:12.944]     }, args = future.call.arguments)
[16:19:12.944] }
[16:19:12.945] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.945] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.945] - packages: [1] ‘stats’
[16:19:12.945] getGlobalsAndPackages() ... DONE
[16:19:12.946] run() for ‘Future’ ...
[16:19:12.946] - state: ‘created’
[16:19:12.946] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.946]   - Field: ‘label’
[16:19:12.947]   - Field: ‘local’
[16:19:12.947]   - Field: ‘owner’
[16:19:12.947]   - Field: ‘envir’
[16:19:12.947]   - Field: ‘packages’
[16:19:12.947]   - Field: ‘gc’
[16:19:12.947]   - Field: ‘conditions’
[16:19:12.947]   - Field: ‘expr’
[16:19:12.947]   - Field: ‘uuid’
[16:19:12.947]   - Field: ‘seed’
[16:19:12.947]   - Field: ‘version’
[16:19:12.948]   - Field: ‘result’
[16:19:12.948]   - Field: ‘asynchronous’
[16:19:12.948]   - Field: ‘calls’
[16:19:12.948]   - Field: ‘globals’
[16:19:12.948]   - Field: ‘stdout’
[16:19:12.948]   - Field: ‘earlySignal’
[16:19:12.948]   - Field: ‘lazy’
[16:19:12.948]   - Field: ‘state’
[16:19:12.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.948] - Launch lazy future ...
[16:19:12.949] Packages needed by the future expression (n = 1): ‘stats’
[16:19:12.949] Packages needed by future strategies (n = 0): <none>
[16:19:12.949] {
[16:19:12.949]     {
[16:19:12.949]         {
[16:19:12.949]             ...future.startTime <- base::Sys.time()
[16:19:12.949]             {
[16:19:12.949]                 {
[16:19:12.949]                   {
[16:19:12.949]                     {
[16:19:12.949]                       base::local({
[16:19:12.949]                         has_future <- base::requireNamespace("future", 
[16:19:12.949]                           quietly = TRUE)
[16:19:12.949]                         if (has_future) {
[16:19:12.949]                           ns <- base::getNamespace("future")
[16:19:12.949]                           version <- ns[[".package"]][["version"]]
[16:19:12.949]                           if (is.null(version)) 
[16:19:12.949]                             version <- utils::packageVersion("future")
[16:19:12.949]                         }
[16:19:12.949]                         else {
[16:19:12.949]                           version <- NULL
[16:19:12.949]                         }
[16:19:12.949]                         if (!has_future || version < "1.8.0") {
[16:19:12.949]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.949]                             "", base::R.version$version.string), 
[16:19:12.949]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.949]                               "release", "version")], collapse = " "), 
[16:19:12.949]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.949]                             info)
[16:19:12.949]                           info <- base::paste(info, collapse = "; ")
[16:19:12.949]                           if (!has_future) {
[16:19:12.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.949]                               info)
[16:19:12.949]                           }
[16:19:12.949]                           else {
[16:19:12.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.949]                               info, version)
[16:19:12.949]                           }
[16:19:12.949]                           base::stop(msg)
[16:19:12.949]                         }
[16:19:12.949]                       })
[16:19:12.949]                     }
[16:19:12.949]                     base::local({
[16:19:12.949]                       for (pkg in "stats") {
[16:19:12.949]                         base::loadNamespace(pkg)
[16:19:12.949]                         base::library(pkg, character.only = TRUE)
[16:19:12.949]                       }
[16:19:12.949]                     })
[16:19:12.949]                   }
[16:19:12.949]                   ...future.strategy.old <- future::plan("list")
[16:19:12.949]                   options(future.plan = NULL)
[16:19:12.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.949]                 }
[16:19:12.949]                 ...future.workdir <- getwd()
[16:19:12.949]             }
[16:19:12.949]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.949]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.949]         }
[16:19:12.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.949]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.949]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.949]             base::names(...future.oldOptions))
[16:19:12.949]     }
[16:19:12.949]     if (FALSE) {
[16:19:12.949]     }
[16:19:12.949]     else {
[16:19:12.949]         if (TRUE) {
[16:19:12.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.949]                 open = "w")
[16:19:12.949]         }
[16:19:12.949]         else {
[16:19:12.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.949]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.949]         }
[16:19:12.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.949]             base::sink(type = "output", split = FALSE)
[16:19:12.949]             base::close(...future.stdout)
[16:19:12.949]         }, add = TRUE)
[16:19:12.949]     }
[16:19:12.949]     ...future.frame <- base::sys.nframe()
[16:19:12.949]     ...future.conditions <- base::list()
[16:19:12.949]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.949]     if (FALSE) {
[16:19:12.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.949]     }
[16:19:12.949]     ...future.result <- base::tryCatch({
[16:19:12.949]         base::withCallingHandlers({
[16:19:12.949]             ...future.value <- base::withVisible(base::local({
[16:19:12.949]                 do.call(function(...) {
[16:19:12.949]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.949]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.949]                     ...future.globals.maxSize)) {
[16:19:12.949]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.949]                     on.exit(options(oopts), add = TRUE)
[16:19:12.949]                   }
[16:19:12.949]                   {
[16:19:12.949]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.949]                       FUN = function(jj) {
[16:19:12.949]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.949]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.949]                       })
[16:19:12.949]                   }
[16:19:12.949]                 }, args = future.call.arguments)
[16:19:12.949]             }))
[16:19:12.949]             future::FutureResult(value = ...future.value$value, 
[16:19:12.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.949]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.949]                     ...future.globalenv.names))
[16:19:12.949]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.949]         }, condition = base::local({
[16:19:12.949]             c <- base::c
[16:19:12.949]             inherits <- base::inherits
[16:19:12.949]             invokeRestart <- base::invokeRestart
[16:19:12.949]             length <- base::length
[16:19:12.949]             list <- base::list
[16:19:12.949]             seq.int <- base::seq.int
[16:19:12.949]             signalCondition <- base::signalCondition
[16:19:12.949]             sys.calls <- base::sys.calls
[16:19:12.949]             `[[` <- base::`[[`
[16:19:12.949]             `+` <- base::`+`
[16:19:12.949]             `<<-` <- base::`<<-`
[16:19:12.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.949]                   3L)]
[16:19:12.949]             }
[16:19:12.949]             function(cond) {
[16:19:12.949]                 is_error <- inherits(cond, "error")
[16:19:12.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.949]                   NULL)
[16:19:12.949]                 if (is_error) {
[16:19:12.949]                   sessionInformation <- function() {
[16:19:12.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.949]                       search = base::search(), system = base::Sys.info())
[16:19:12.949]                   }
[16:19:12.949]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.949]                     cond$call), session = sessionInformation(), 
[16:19:12.949]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.949]                   signalCondition(cond)
[16:19:12.949]                 }
[16:19:12.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.949]                 "immediateCondition"))) {
[16:19:12.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.949]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.949]                   if (TRUE && !signal) {
[16:19:12.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.949]                     {
[16:19:12.949]                       inherits <- base::inherits
[16:19:12.949]                       invokeRestart <- base::invokeRestart
[16:19:12.949]                       is.null <- base::is.null
[16:19:12.949]                       muffled <- FALSE
[16:19:12.949]                       if (inherits(cond, "message")) {
[16:19:12.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.949]                         if (muffled) 
[16:19:12.949]                           invokeRestart("muffleMessage")
[16:19:12.949]                       }
[16:19:12.949]                       else if (inherits(cond, "warning")) {
[16:19:12.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.949]                         if (muffled) 
[16:19:12.949]                           invokeRestart("muffleWarning")
[16:19:12.949]                       }
[16:19:12.949]                       else if (inherits(cond, "condition")) {
[16:19:12.949]                         if (!is.null(pattern)) {
[16:19:12.949]                           computeRestarts <- base::computeRestarts
[16:19:12.949]                           grepl <- base::grepl
[16:19:12.949]                           restarts <- computeRestarts(cond)
[16:19:12.949]                           for (restart in restarts) {
[16:19:12.949]                             name <- restart$name
[16:19:12.949]                             if (is.null(name)) 
[16:19:12.949]                               next
[16:19:12.949]                             if (!grepl(pattern, name)) 
[16:19:12.949]                               next
[16:19:12.949]                             invokeRestart(restart)
[16:19:12.949]                             muffled <- TRUE
[16:19:12.949]                             break
[16:19:12.949]                           }
[16:19:12.949]                         }
[16:19:12.949]                       }
[16:19:12.949]                       invisible(muffled)
[16:19:12.949]                     }
[16:19:12.949]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.949]                   }
[16:19:12.949]                 }
[16:19:12.949]                 else {
[16:19:12.949]                   if (TRUE) {
[16:19:12.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.949]                     {
[16:19:12.949]                       inherits <- base::inherits
[16:19:12.949]                       invokeRestart <- base::invokeRestart
[16:19:12.949]                       is.null <- base::is.null
[16:19:12.949]                       muffled <- FALSE
[16:19:12.949]                       if (inherits(cond, "message")) {
[16:19:12.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.949]                         if (muffled) 
[16:19:12.949]                           invokeRestart("muffleMessage")
[16:19:12.949]                       }
[16:19:12.949]                       else if (inherits(cond, "warning")) {
[16:19:12.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.949]                         if (muffled) 
[16:19:12.949]                           invokeRestart("muffleWarning")
[16:19:12.949]                       }
[16:19:12.949]                       else if (inherits(cond, "condition")) {
[16:19:12.949]                         if (!is.null(pattern)) {
[16:19:12.949]                           computeRestarts <- base::computeRestarts
[16:19:12.949]                           grepl <- base::grepl
[16:19:12.949]                           restarts <- computeRestarts(cond)
[16:19:12.949]                           for (restart in restarts) {
[16:19:12.949]                             name <- restart$name
[16:19:12.949]                             if (is.null(name)) 
[16:19:12.949]                               next
[16:19:12.949]                             if (!grepl(pattern, name)) 
[16:19:12.949]                               next
[16:19:12.949]                             invokeRestart(restart)
[16:19:12.949]                             muffled <- TRUE
[16:19:12.949]                             break
[16:19:12.949]                           }
[16:19:12.949]                         }
[16:19:12.949]                       }
[16:19:12.949]                       invisible(muffled)
[16:19:12.949]                     }
[16:19:12.949]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.949]                   }
[16:19:12.949]                 }
[16:19:12.949]             }
[16:19:12.949]         }))
[16:19:12.949]     }, error = function(ex) {
[16:19:12.949]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.949]                 ...future.rng), started = ...future.startTime, 
[16:19:12.949]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.949]             version = "1.8"), class = "FutureResult")
[16:19:12.949]     }, finally = {
[16:19:12.949]         if (!identical(...future.workdir, getwd())) 
[16:19:12.949]             setwd(...future.workdir)
[16:19:12.949]         {
[16:19:12.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.949]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.949]             }
[16:19:12.949]             base::options(...future.oldOptions)
[16:19:12.949]             if (.Platform$OS.type == "windows") {
[16:19:12.949]                 old_names <- names(...future.oldEnvVars)
[16:19:12.949]                 envs <- base::Sys.getenv()
[16:19:12.949]                 names <- names(envs)
[16:19:12.949]                 common <- intersect(names, old_names)
[16:19:12.949]                 added <- setdiff(names, old_names)
[16:19:12.949]                 removed <- setdiff(old_names, names)
[16:19:12.949]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.949]                   envs[common]]
[16:19:12.949]                 NAMES <- toupper(changed)
[16:19:12.949]                 args <- list()
[16:19:12.949]                 for (kk in seq_along(NAMES)) {
[16:19:12.949]                   name <- changed[[kk]]
[16:19:12.949]                   NAME <- NAMES[[kk]]
[16:19:12.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.949]                     next
[16:19:12.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.949]                 }
[16:19:12.949]                 NAMES <- toupper(added)
[16:19:12.949]                 for (kk in seq_along(NAMES)) {
[16:19:12.949]                   name <- added[[kk]]
[16:19:12.949]                   NAME <- NAMES[[kk]]
[16:19:12.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.949]                     next
[16:19:12.949]                   args[[name]] <- ""
[16:19:12.949]                 }
[16:19:12.949]                 NAMES <- toupper(removed)
[16:19:12.949]                 for (kk in seq_along(NAMES)) {
[16:19:12.949]                   name <- removed[[kk]]
[16:19:12.949]                   NAME <- NAMES[[kk]]
[16:19:12.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.949]                     next
[16:19:12.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.949]                 }
[16:19:12.949]                 if (length(args) > 0) 
[16:19:12.949]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.949]             }
[16:19:12.949]             else {
[16:19:12.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.949]             }
[16:19:12.949]             {
[16:19:12.949]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.949]                   0L) {
[16:19:12.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.949]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.949]                   base::options(opts)
[16:19:12.949]                 }
[16:19:12.949]                 {
[16:19:12.949]                   {
[16:19:12.949]                     NULL
[16:19:12.949]                     RNGkind("Mersenne-Twister")
[16:19:12.949]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.949]                       inherits = FALSE)
[16:19:12.949]                   }
[16:19:12.949]                   options(future.plan = NULL)
[16:19:12.949]                   if (is.na(NA_character_)) 
[16:19:12.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.949]                     .init = FALSE)
[16:19:12.949]                 }
[16:19:12.949]             }
[16:19:12.949]         }
[16:19:12.949]     })
[16:19:12.949]     if (TRUE) {
[16:19:12.949]         base::sink(type = "output", split = FALSE)
[16:19:12.949]         if (TRUE) {
[16:19:12.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.949]         }
[16:19:12.949]         else {
[16:19:12.949]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.949]         }
[16:19:12.949]         base::close(...future.stdout)
[16:19:12.949]         ...future.stdout <- NULL
[16:19:12.949]     }
[16:19:12.949]     ...future.result$conditions <- ...future.conditions
[16:19:12.949]     ...future.result$finished <- base::Sys.time()
[16:19:12.949]     ...future.result
[16:19:12.949] }
[16:19:12.951] assign_globals() ...
[16:19:12.951] List of 5
[16:19:12.951]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:19:12.951]  $ future.call.arguments    : list()
[16:19:12.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.951]  $ ...future.elements_ii    :List of 7
[16:19:12.951]   ..$ : int [1:3] 1 2 3
[16:19:12.951]   ..$ : int [1:4] 1 2 3 4
[16:19:12.951]   ..$ : int [1:5] 1 2 3 4 5
[16:19:12.951]   ..$ : int [1:6] 1 2 3 4 5 6
[16:19:12.951]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:19:12.951]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:19:12.951]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:19:12.951]  $ ...future.seeds_ii       : NULL
[16:19:12.951]  $ ...future.globals.maxSize: NULL
[16:19:12.951]  - attr(*, "where")=List of 5
[16:19:12.951]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:12.951]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:12.951]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:12.951]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:12.951]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:12.951]  - attr(*, "resolved")= logi FALSE
[16:19:12.951]  - attr(*, "total_size")= num 46960
[16:19:12.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.951]  - attr(*, "already-done")= logi TRUE
[16:19:12.958] - copied ‘...future.FUN’ to environment
[16:19:12.958] - copied ‘future.call.arguments’ to environment
[16:19:12.958] - copied ‘...future.elements_ii’ to environment
[16:19:12.958] - copied ‘...future.seeds_ii’ to environment
[16:19:12.958] - copied ‘...future.globals.maxSize’ to environment
[16:19:12.958] assign_globals() ... done
[16:19:12.959] plan(): Setting new future strategy stack:
[16:19:12.959] List of future strategies:
[16:19:12.959] 1. sequential:
[16:19:12.959]    - args: function (..., envir = parent.frame())
[16:19:12.959]    - tweaked: FALSE
[16:19:12.959]    - call: NULL
[16:19:12.959] plan(): nbrOfWorkers() = 1
[16:19:12.960] plan(): Setting new future strategy stack:
[16:19:12.960] List of future strategies:
[16:19:12.960] 1. sequential:
[16:19:12.960]    - args: function (..., envir = parent.frame())
[16:19:12.960]    - tweaked: FALSE
[16:19:12.960]    - call: plan(strategy)
[16:19:12.960] plan(): nbrOfWorkers() = 1
[16:19:12.961] SequentialFuture started (and completed)
[16:19:12.961] - Launch lazy future ... done
[16:19:12.961] run() for ‘SequentialFuture’ ... done
[16:19:12.961] Created future:
[16:19:12.961] SequentialFuture:
[16:19:12.961] Label: ‘future_sapply-1’
[16:19:12.961] Expression:
[16:19:12.961] {
[16:19:12.961]     do.call(function(...) {
[16:19:12.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.961]             on.exit(options(oopts), add = TRUE)
[16:19:12.961]         }
[16:19:12.961]         {
[16:19:12.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.961]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.961]             })
[16:19:12.961]         }
[16:19:12.961]     }, args = future.call.arguments)
[16:19:12.961] }
[16:19:12.961] Lazy evaluation: FALSE
[16:19:12.961] Asynchronous evaluation: FALSE
[16:19:12.961] Local evaluation: TRUE
[16:19:12.961] Environment: R_GlobalEnv
[16:19:12.961] Capture standard output: TRUE
[16:19:12.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:12.961] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:12.961] Packages: 1 packages (‘stats’)
[16:19:12.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:12.961] Resolved: TRUE
[16:19:12.961] Value: 672 bytes of class ‘list’
[16:19:12.961] Early signaling: FALSE
[16:19:12.961] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:12.961] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.962] Chunk #1 of 1 ... DONE
[16:19:12.962] Launching 1 futures (chunks) ... DONE
[16:19:12.962] Resolving 1 futures (chunks) ...
[16:19:12.962] resolve() on list ...
[16:19:12.962]  recursive: 0
[16:19:12.963]  length: 1
[16:19:12.963] 
[16:19:12.963] resolved() for ‘SequentialFuture’ ...
[16:19:12.963] - state: ‘finished’
[16:19:12.963] - run: TRUE
[16:19:12.963] - result: ‘FutureResult’
[16:19:12.963] resolved() for ‘SequentialFuture’ ... done
[16:19:12.963] Future #1
[16:19:12.963] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:12.963] - nx: 1
[16:19:12.964] - relay: TRUE
[16:19:12.964] - stdout: TRUE
[16:19:12.964] - signal: TRUE
[16:19:12.964] - resignal: FALSE
[16:19:12.964] - force: TRUE
[16:19:12.964] - relayed: [n=1] FALSE
[16:19:12.964] - queued futures: [n=1] FALSE
[16:19:12.964]  - until=1
[16:19:12.964]  - relaying element #1
[16:19:12.964] - relayed: [n=1] TRUE
[16:19:12.965] - queued futures: [n=1] TRUE
[16:19:12.965] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:12.965]  length: 0 (resolved future 1)
[16:19:12.965] Relaying remaining futures
[16:19:12.965] signalConditionsASAP(NULL, pos=0) ...
[16:19:12.965] - nx: 1
[16:19:12.965] - relay: TRUE
[16:19:12.965] - stdout: TRUE
[16:19:12.965] - signal: TRUE
[16:19:12.965] - resignal: FALSE
[16:19:12.965] - force: TRUE
[16:19:12.966] - relayed: [n=1] TRUE
[16:19:12.966] - queued futures: [n=1] TRUE
 - flush all
[16:19:12.966] - relayed: [n=1] TRUE
[16:19:12.966] - queued futures: [n=1] TRUE
[16:19:12.967] signalConditionsASAP(NULL, pos=0) ... done
[16:19:12.968] resolve() on list ... DONE
[16:19:12.968]  - Number of value chunks collected: 1
[16:19:12.968] Resolving 1 futures (chunks) ... DONE
[16:19:12.968] Reducing values from 1 chunks ...
[16:19:12.968]  - Number of values collected after concatenation: 7
[16:19:12.968]  - Number of values expected: 7
[16:19:12.968] Reducing values from 1 chunks ... DONE
[16:19:12.968] future_lapply() ... DONE
[16:19:12.969] future_lapply() ...
[16:19:12.971] Number of chunks: 1
[16:19:12.971] getGlobalsAndPackagesXApply() ...
[16:19:12.971]  - future.globals: TRUE
[16:19:12.971] getGlobalsAndPackages() ...
[16:19:12.971] Searching for globals...
[16:19:12.978] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:19:12.978] Searching for globals ... DONE
[16:19:12.978] Resolving globals: FALSE
[16:19:12.979] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:19:12.980] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:19:12.980] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.980] - packages: [2] ‘stats’, ‘future.apply’
[16:19:12.980] getGlobalsAndPackages() ... DONE
[16:19:12.980]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:12.980]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:19:12.981] Finding globals ... DONE
[16:19:12.981]  - use_args: TRUE
[16:19:12.981]  - Getting '...' globals ...
[16:19:12.981] resolve() on list ...
[16:19:12.981]  recursive: 0
[16:19:12.981]  length: 1
[16:19:12.981]  elements: ‘...’
[16:19:12.981]  length: 0 (resolved future 1)
[16:19:12.982] resolve() on list ... DONE
[16:19:12.982]    - '...' content: [n=0] 
[16:19:12.982] List of 1
[16:19:12.982]  $ ...: list()
[16:19:12.982]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.982]  - attr(*, "where")=List of 1
[16:19:12.982]   ..$ ...:<environment: 0x56199f1fad78> 
[16:19:12.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.982]  - attr(*, "resolved")= logi TRUE
[16:19:12.982]  - attr(*, "total_size")= num NA
[16:19:12.984]  - Getting '...' globals ... DONE
[16:19:12.984] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:12.984] List of 8
[16:19:12.984]  $ ...future.FUN:function (x, ...)  
[16:19:12.984]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:19:12.984]  $ times        : int 5
[16:19:12.984]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:12.984]  $ stop_if_not  :function (...)  
[16:19:12.984]  $ dim          : NULL
[16:19:12.984]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:12.984]  $ ...          : list()
[16:19:12.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:12.984]  - attr(*, "where")=List of 8
[16:19:12.984]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:12.984]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:12.984]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:12.984]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:12.984]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:12.984]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:12.984]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:12.984]   ..$ ...          :<environment: 0x56199f1fad78> 
[16:19:12.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:12.984]  - attr(*, "resolved")= logi FALSE
[16:19:12.984]  - attr(*, "total_size")= num 141240
[16:19:12.991] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:19:12.991] getGlobalsAndPackagesXApply() ... DONE
[16:19:12.992] Number of futures (= number of chunks): 1
[16:19:12.992] Launching 1 futures (chunks) ...
[16:19:12.992] Chunk #1 of 1 ...
[16:19:12.992]  - Finding globals in 'X' for chunk #1 ...
[16:19:12.992] getGlobalsAndPackages() ...
[16:19:12.992] Searching for globals...
[16:19:12.993] 
[16:19:12.993] Searching for globals ... DONE
[16:19:12.993] - globals: [0] <none>
[16:19:12.993] getGlobalsAndPackages() ... DONE
[16:19:12.993]    + additional globals found: [n=0] 
[16:19:12.993]    + additional namespaces needed: [n=0] 
[16:19:12.993]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:12.993]  - seeds: <none>
[16:19:12.993]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.993] getGlobalsAndPackages() ...
[16:19:12.993] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.994] Resolving globals: FALSE
[16:19:12.994] Tweak future expression to call with '...' arguments ...
[16:19:12.994] {
[16:19:12.994]     do.call(function(...) {
[16:19:12.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:12.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.994]             on.exit(options(oopts), add = TRUE)
[16:19:12.994]         }
[16:19:12.994]         {
[16:19:12.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:12.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.994]                 ...future.FUN(...future.X_jj, ...)
[16:19:12.994]             })
[16:19:12.994]         }
[16:19:12.994]     }, args = future.call.arguments)
[16:19:12.994] }
[16:19:12.994] Tweak future expression to call with '...' arguments ... DONE
[16:19:12.995] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:12.995] - packages: [2] ‘stats’, ‘future.apply’
[16:19:12.995] getGlobalsAndPackages() ... DONE
[16:19:12.995] run() for ‘Future’ ...
[16:19:12.995] - state: ‘created’
[16:19:12.995] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:12.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:12.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:12.996]   - Field: ‘label’
[16:19:12.996]   - Field: ‘local’
[16:19:12.996]   - Field: ‘owner’
[16:19:12.996]   - Field: ‘envir’
[16:19:12.996]   - Field: ‘packages’
[16:19:12.996]   - Field: ‘gc’
[16:19:12.996]   - Field: ‘conditions’
[16:19:12.997]   - Field: ‘expr’
[16:19:12.997]   - Field: ‘uuid’
[16:19:12.997]   - Field: ‘seed’
[16:19:12.997]   - Field: ‘version’
[16:19:12.997]   - Field: ‘result’
[16:19:12.997]   - Field: ‘asynchronous’
[16:19:12.997]   - Field: ‘calls’
[16:19:12.997]   - Field: ‘globals’
[16:19:12.997]   - Field: ‘stdout’
[16:19:12.997]   - Field: ‘earlySignal’
[16:19:12.997]   - Field: ‘lazy’
[16:19:12.998]   - Field: ‘state’
[16:19:12.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:12.998] - Launch lazy future ...
[16:19:12.998] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:12.998] Packages needed by future strategies (n = 0): <none>
[16:19:12.999] {
[16:19:12.999]     {
[16:19:12.999]         {
[16:19:12.999]             ...future.startTime <- base::Sys.time()
[16:19:12.999]             {
[16:19:12.999]                 {
[16:19:12.999]                   {
[16:19:12.999]                     {
[16:19:12.999]                       base::local({
[16:19:12.999]                         has_future <- base::requireNamespace("future", 
[16:19:12.999]                           quietly = TRUE)
[16:19:12.999]                         if (has_future) {
[16:19:12.999]                           ns <- base::getNamespace("future")
[16:19:12.999]                           version <- ns[[".package"]][["version"]]
[16:19:12.999]                           if (is.null(version)) 
[16:19:12.999]                             version <- utils::packageVersion("future")
[16:19:12.999]                         }
[16:19:12.999]                         else {
[16:19:12.999]                           version <- NULL
[16:19:12.999]                         }
[16:19:12.999]                         if (!has_future || version < "1.8.0") {
[16:19:12.999]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:12.999]                             "", base::R.version$version.string), 
[16:19:12.999]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:12.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:12.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:12.999]                               "release", "version")], collapse = " "), 
[16:19:12.999]                             hostname = base::Sys.info()[["nodename"]])
[16:19:12.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:12.999]                             info)
[16:19:12.999]                           info <- base::paste(info, collapse = "; ")
[16:19:12.999]                           if (!has_future) {
[16:19:12.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:12.999]                               info)
[16:19:12.999]                           }
[16:19:12.999]                           else {
[16:19:12.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:12.999]                               info, version)
[16:19:12.999]                           }
[16:19:12.999]                           base::stop(msg)
[16:19:12.999]                         }
[16:19:12.999]                       })
[16:19:12.999]                     }
[16:19:12.999]                     base::local({
[16:19:12.999]                       for (pkg in c("stats", "future.apply")) {
[16:19:12.999]                         base::loadNamespace(pkg)
[16:19:12.999]                         base::library(pkg, character.only = TRUE)
[16:19:12.999]                       }
[16:19:12.999]                     })
[16:19:12.999]                   }
[16:19:12.999]                   ...future.strategy.old <- future::plan("list")
[16:19:12.999]                   options(future.plan = NULL)
[16:19:12.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:12.999]                 }
[16:19:12.999]                 ...future.workdir <- getwd()
[16:19:12.999]             }
[16:19:12.999]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:12.999]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:12.999]         }
[16:19:12.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:12.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:12.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:12.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:12.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:12.999]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:12.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:12.999]             base::names(...future.oldOptions))
[16:19:12.999]     }
[16:19:12.999]     if (FALSE) {
[16:19:12.999]     }
[16:19:12.999]     else {
[16:19:12.999]         if (TRUE) {
[16:19:12.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:12.999]                 open = "w")
[16:19:12.999]         }
[16:19:12.999]         else {
[16:19:12.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:12.999]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:12.999]         }
[16:19:12.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:12.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:12.999]             base::sink(type = "output", split = FALSE)
[16:19:12.999]             base::close(...future.stdout)
[16:19:12.999]         }, add = TRUE)
[16:19:12.999]     }
[16:19:12.999]     ...future.frame <- base::sys.nframe()
[16:19:12.999]     ...future.conditions <- base::list()
[16:19:12.999]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:12.999]     if (FALSE) {
[16:19:12.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:12.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:12.999]     }
[16:19:12.999]     ...future.result <- base::tryCatch({
[16:19:12.999]         base::withCallingHandlers({
[16:19:12.999]             ...future.value <- base::withVisible(base::local({
[16:19:12.999]                 do.call(function(...) {
[16:19:12.999]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:12.999]                   if (!identical(...future.globals.maxSize.org, 
[16:19:12.999]                     ...future.globals.maxSize)) {
[16:19:12.999]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:12.999]                     on.exit(options(oopts), add = TRUE)
[16:19:12.999]                   }
[16:19:12.999]                   {
[16:19:12.999]                     lapply(seq_along(...future.elements_ii), 
[16:19:12.999]                       FUN = function(jj) {
[16:19:12.999]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:12.999]                         ...future.FUN(...future.X_jj, ...)
[16:19:12.999]                       })
[16:19:12.999]                   }
[16:19:12.999]                 }, args = future.call.arguments)
[16:19:12.999]             }))
[16:19:12.999]             future::FutureResult(value = ...future.value$value, 
[16:19:12.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.999]                   ...future.rng), globalenv = if (FALSE) 
[16:19:12.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:12.999]                     ...future.globalenv.names))
[16:19:12.999]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:12.999]         }, condition = base::local({
[16:19:12.999]             c <- base::c
[16:19:12.999]             inherits <- base::inherits
[16:19:12.999]             invokeRestart <- base::invokeRestart
[16:19:12.999]             length <- base::length
[16:19:12.999]             list <- base::list
[16:19:12.999]             seq.int <- base::seq.int
[16:19:12.999]             signalCondition <- base::signalCondition
[16:19:12.999]             sys.calls <- base::sys.calls
[16:19:12.999]             `[[` <- base::`[[`
[16:19:12.999]             `+` <- base::`+`
[16:19:12.999]             `<<-` <- base::`<<-`
[16:19:12.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:12.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:12.999]                   3L)]
[16:19:12.999]             }
[16:19:12.999]             function(cond) {
[16:19:12.999]                 is_error <- inherits(cond, "error")
[16:19:12.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:12.999]                   NULL)
[16:19:12.999]                 if (is_error) {
[16:19:12.999]                   sessionInformation <- function() {
[16:19:12.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:12.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:12.999]                       search = base::search(), system = base::Sys.info())
[16:19:12.999]                   }
[16:19:12.999]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:12.999]                     cond$call), session = sessionInformation(), 
[16:19:12.999]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:12.999]                   signalCondition(cond)
[16:19:12.999]                 }
[16:19:12.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:12.999]                 "immediateCondition"))) {
[16:19:12.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:12.999]                   ...future.conditions[[length(...future.conditions) + 
[16:19:12.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:12.999]                   if (TRUE && !signal) {
[16:19:12.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.999]                     {
[16:19:12.999]                       inherits <- base::inherits
[16:19:12.999]                       invokeRestart <- base::invokeRestart
[16:19:12.999]                       is.null <- base::is.null
[16:19:12.999]                       muffled <- FALSE
[16:19:12.999]                       if (inherits(cond, "message")) {
[16:19:12.999]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.999]                         if (muffled) 
[16:19:12.999]                           invokeRestart("muffleMessage")
[16:19:12.999]                       }
[16:19:12.999]                       else if (inherits(cond, "warning")) {
[16:19:12.999]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.999]                         if (muffled) 
[16:19:12.999]                           invokeRestart("muffleWarning")
[16:19:12.999]                       }
[16:19:12.999]                       else if (inherits(cond, "condition")) {
[16:19:12.999]                         if (!is.null(pattern)) {
[16:19:12.999]                           computeRestarts <- base::computeRestarts
[16:19:12.999]                           grepl <- base::grepl
[16:19:12.999]                           restarts <- computeRestarts(cond)
[16:19:12.999]                           for (restart in restarts) {
[16:19:12.999]                             name <- restart$name
[16:19:12.999]                             if (is.null(name)) 
[16:19:12.999]                               next
[16:19:12.999]                             if (!grepl(pattern, name)) 
[16:19:12.999]                               next
[16:19:12.999]                             invokeRestart(restart)
[16:19:12.999]                             muffled <- TRUE
[16:19:12.999]                             break
[16:19:12.999]                           }
[16:19:12.999]                         }
[16:19:12.999]                       }
[16:19:12.999]                       invisible(muffled)
[16:19:12.999]                     }
[16:19:12.999]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.999]                   }
[16:19:12.999]                 }
[16:19:12.999]                 else {
[16:19:12.999]                   if (TRUE) {
[16:19:12.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:12.999]                     {
[16:19:12.999]                       inherits <- base::inherits
[16:19:12.999]                       invokeRestart <- base::invokeRestart
[16:19:12.999]                       is.null <- base::is.null
[16:19:12.999]                       muffled <- FALSE
[16:19:12.999]                       if (inherits(cond, "message")) {
[16:19:12.999]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:12.999]                         if (muffled) 
[16:19:12.999]                           invokeRestart("muffleMessage")
[16:19:12.999]                       }
[16:19:12.999]                       else if (inherits(cond, "warning")) {
[16:19:12.999]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:12.999]                         if (muffled) 
[16:19:12.999]                           invokeRestart("muffleWarning")
[16:19:12.999]                       }
[16:19:12.999]                       else if (inherits(cond, "condition")) {
[16:19:12.999]                         if (!is.null(pattern)) {
[16:19:12.999]                           computeRestarts <- base::computeRestarts
[16:19:12.999]                           grepl <- base::grepl
[16:19:12.999]                           restarts <- computeRestarts(cond)
[16:19:12.999]                           for (restart in restarts) {
[16:19:12.999]                             name <- restart$name
[16:19:12.999]                             if (is.null(name)) 
[16:19:12.999]                               next
[16:19:12.999]                             if (!grepl(pattern, name)) 
[16:19:12.999]                               next
[16:19:12.999]                             invokeRestart(restart)
[16:19:12.999]                             muffled <- TRUE
[16:19:12.999]                             break
[16:19:12.999]                           }
[16:19:12.999]                         }
[16:19:12.999]                       }
[16:19:12.999]                       invisible(muffled)
[16:19:12.999]                     }
[16:19:12.999]                     muffleCondition(cond, pattern = "^muffle")
[16:19:12.999]                   }
[16:19:12.999]                 }
[16:19:12.999]             }
[16:19:12.999]         }))
[16:19:12.999]     }, error = function(ex) {
[16:19:12.999]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:12.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:12.999]                 ...future.rng), started = ...future.startTime, 
[16:19:12.999]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:12.999]             version = "1.8"), class = "FutureResult")
[16:19:12.999]     }, finally = {
[16:19:12.999]         if (!identical(...future.workdir, getwd())) 
[16:19:12.999]             setwd(...future.workdir)
[16:19:12.999]         {
[16:19:12.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:12.999]                 ...future.oldOptions$nwarnings <- NULL
[16:19:12.999]             }
[16:19:12.999]             base::options(...future.oldOptions)
[16:19:12.999]             if (.Platform$OS.type == "windows") {
[16:19:12.999]                 old_names <- names(...future.oldEnvVars)
[16:19:12.999]                 envs <- base::Sys.getenv()
[16:19:12.999]                 names <- names(envs)
[16:19:12.999]                 common <- intersect(names, old_names)
[16:19:12.999]                 added <- setdiff(names, old_names)
[16:19:12.999]                 removed <- setdiff(old_names, names)
[16:19:12.999]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:12.999]                   envs[common]]
[16:19:12.999]                 NAMES <- toupper(changed)
[16:19:12.999]                 args <- list()
[16:19:12.999]                 for (kk in seq_along(NAMES)) {
[16:19:12.999]                   name <- changed[[kk]]
[16:19:12.999]                   NAME <- NAMES[[kk]]
[16:19:12.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.999]                     next
[16:19:12.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.999]                 }
[16:19:12.999]                 NAMES <- toupper(added)
[16:19:12.999]                 for (kk in seq_along(NAMES)) {
[16:19:12.999]                   name <- added[[kk]]
[16:19:12.999]                   NAME <- NAMES[[kk]]
[16:19:12.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.999]                     next
[16:19:12.999]                   args[[name]] <- ""
[16:19:12.999]                 }
[16:19:12.999]                 NAMES <- toupper(removed)
[16:19:12.999]                 for (kk in seq_along(NAMES)) {
[16:19:12.999]                   name <- removed[[kk]]
[16:19:12.999]                   NAME <- NAMES[[kk]]
[16:19:12.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:12.999]                     next
[16:19:12.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:12.999]                 }
[16:19:12.999]                 if (length(args) > 0) 
[16:19:12.999]                   base::do.call(base::Sys.setenv, args = args)
[16:19:12.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:12.999]             }
[16:19:12.999]             else {
[16:19:12.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:12.999]             }
[16:19:12.999]             {
[16:19:12.999]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:12.999]                   0L) {
[16:19:12.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:12.999]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:12.999]                   base::options(opts)
[16:19:12.999]                 }
[16:19:12.999]                 {
[16:19:12.999]                   {
[16:19:12.999]                     NULL
[16:19:12.999]                     RNGkind("Mersenne-Twister")
[16:19:12.999]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:12.999]                       inherits = FALSE)
[16:19:12.999]                   }
[16:19:12.999]                   options(future.plan = NULL)
[16:19:12.999]                   if (is.na(NA_character_)) 
[16:19:12.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:12.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:12.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:12.999]                     .init = FALSE)
[16:19:12.999]                 }
[16:19:12.999]             }
[16:19:12.999]         }
[16:19:12.999]     })
[16:19:12.999]     if (TRUE) {
[16:19:12.999]         base::sink(type = "output", split = FALSE)
[16:19:12.999]         if (TRUE) {
[16:19:12.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:12.999]         }
[16:19:12.999]         else {
[16:19:12.999]             ...future.result["stdout"] <- base::list(NULL)
[16:19:12.999]         }
[16:19:12.999]         base::close(...future.stdout)
[16:19:12.999]         ...future.stdout <- NULL
[16:19:12.999]     }
[16:19:12.999]     ...future.result$conditions <- ...future.conditions
[16:19:12.999]     ...future.result$finished <- base::Sys.time()
[16:19:12.999]     ...future.result
[16:19:12.999] }
[16:19:13.000] assign_globals() ...
[16:19:13.000] List of 11
[16:19:13.000]  $ ...future.FUN            :function (x, ...)  
[16:19:13.000]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:19:13.000]  $ times                    : int 5
[16:19:13.000]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.000]  $ stop_if_not              :function (...)  
[16:19:13.000]  $ dim                      : NULL
[16:19:13.000]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.000]  $ future.call.arguments    : list()
[16:19:13.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.000]  $ ...future.elements_ii    :List of 7
[16:19:13.000]   ..$ : int [1:3] 1 2 3
[16:19:13.000]   ..$ : int [1:4] 1 2 3 4
[16:19:13.000]   ..$ : int [1:5] 1 2 3 4 5
[16:19:13.000]   ..$ : int [1:6] 1 2 3 4 5 6
[16:19:13.000]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:19:13.000]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:19:13.000]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:19:13.000]  $ ...future.seeds_ii       : NULL
[16:19:13.000]  $ ...future.globals.maxSize: NULL
[16:19:13.000]  - attr(*, "where")=List of 11
[16:19:13.000]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.000]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.000]  - attr(*, "resolved")= logi FALSE
[16:19:13.000]  - attr(*, "total_size")= num 141240
[16:19:13.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.000]  - attr(*, "already-done")= logi TRUE
[16:19:13.011] - copied ‘...future.FUN’ to environment
[16:19:13.011] - copied ‘x_FUN’ to environment
[16:19:13.011] - copied ‘times’ to environment
[16:19:13.011] - copied ‘stopf’ to environment
[16:19:13.011] - copied ‘stop_if_not’ to environment
[16:19:13.011] - copied ‘dim’ to environment
[16:19:13.011] - copied ‘valid_types’ to environment
[16:19:13.012] - copied ‘future.call.arguments’ to environment
[16:19:13.012] - copied ‘...future.elements_ii’ to environment
[16:19:13.012] - copied ‘...future.seeds_ii’ to environment
[16:19:13.012] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.012] assign_globals() ... done
[16:19:13.013] plan(): Setting new future strategy stack:
[16:19:13.013] List of future strategies:
[16:19:13.013] 1. sequential:
[16:19:13.013]    - args: function (..., envir = parent.frame())
[16:19:13.013]    - tweaked: FALSE
[16:19:13.013]    - call: NULL
[16:19:13.013] plan(): nbrOfWorkers() = 1
[16:19:13.014] plan(): Setting new future strategy stack:
[16:19:13.014] List of future strategies:
[16:19:13.014] 1. sequential:
[16:19:13.014]    - args: function (..., envir = parent.frame())
[16:19:13.014]    - tweaked: FALSE
[16:19:13.014]    - call: plan(strategy)
[16:19:13.014] plan(): nbrOfWorkers() = 1
[16:19:13.015] SequentialFuture started (and completed)
[16:19:13.015] - Launch lazy future ... done
[16:19:13.015] run() for ‘SequentialFuture’ ... done
[16:19:13.015] Created future:
[16:19:13.015] SequentialFuture:
[16:19:13.015] Label: ‘future_vapply-1’
[16:19:13.015] Expression:
[16:19:13.015] {
[16:19:13.015]     do.call(function(...) {
[16:19:13.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.015]             on.exit(options(oopts), add = TRUE)
[16:19:13.015]         }
[16:19:13.015]         {
[16:19:13.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.015]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.015]             })
[16:19:13.015]         }
[16:19:13.015]     }, args = future.call.arguments)
[16:19:13.015] }
[16:19:13.015] Lazy evaluation: FALSE
[16:19:13.015] Asynchronous evaluation: FALSE
[16:19:13.015] Local evaluation: TRUE
[16:19:13.015] Environment: R_GlobalEnv
[16:19:13.015] Capture standard output: TRUE
[16:19:13.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.015] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.015] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:13.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.015] Resolved: TRUE
[16:19:13.015] Value: 672 bytes of class ‘list’
[16:19:13.015] Early signaling: FALSE
[16:19:13.015] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.015] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.016] Chunk #1 of 1 ... DONE
[16:19:13.016] Launching 1 futures (chunks) ... DONE
[16:19:13.016] Resolving 1 futures (chunks) ...
[16:19:13.017] resolve() on list ...
[16:19:13.017]  recursive: 0
[16:19:13.017]  length: 1
[16:19:13.017] 
[16:19:13.017] resolved() for ‘SequentialFuture’ ...
[16:19:13.017] - state: ‘finished’
[16:19:13.017] - run: TRUE
[16:19:13.017] - result: ‘FutureResult’
[16:19:13.017] resolved() for ‘SequentialFuture’ ... done
[16:19:13.017] Future #1
[16:19:13.018] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:13.018] - nx: 1
[16:19:13.018] - relay: TRUE
[16:19:13.018] - stdout: TRUE
[16:19:13.018] - signal: TRUE
[16:19:13.018] - resignal: FALSE
[16:19:13.018] - force: TRUE
[16:19:13.018] - relayed: [n=1] FALSE
[16:19:13.018] - queued futures: [n=1] FALSE
[16:19:13.018]  - until=1
[16:19:13.018]  - relaying element #1
[16:19:13.019] - relayed: [n=1] TRUE
[16:19:13.019] - queued futures: [n=1] TRUE
[16:19:13.019] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:13.019]  length: 0 (resolved future 1)
[16:19:13.019] Relaying remaining futures
[16:19:13.019] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.019] - nx: 1
[16:19:13.019] - relay: TRUE
[16:19:13.019] - stdout: TRUE
[16:19:13.019] - signal: TRUE
[16:19:13.020] - resignal: FALSE
[16:19:13.020] - force: TRUE
[16:19:13.020] - relayed: [n=1] TRUE
[16:19:13.020] - queued futures: [n=1] TRUE
 - flush all
[16:19:13.020] - relayed: [n=1] TRUE
[16:19:13.020] - queued futures: [n=1] TRUE
[16:19:13.020] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.020] resolve() on list ... DONE
[16:19:13.020]  - Number of value chunks collected: 1
[16:19:13.020] Resolving 1 futures (chunks) ... DONE
[16:19:13.021] Reducing values from 1 chunks ...
[16:19:13.021]  - Number of values collected after concatenation: 7
[16:19:13.021]  - Number of values expected: 7
[16:19:13.021] Reducing values from 1 chunks ... DONE
[16:19:13.021] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:19:13.023] future_lapply() ...
[16:19:13.023] Number of chunks: 1
[16:19:13.023] getGlobalsAndPackagesXApply() ...
[16:19:13.023]  - future.globals: TRUE
[16:19:13.024] getGlobalsAndPackages() ...
[16:19:13.024] Searching for globals...
[16:19:13.025] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:19:13.025] Searching for globals ... DONE
[16:19:13.025] Resolving globals: FALSE
[16:19:13.025] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:19:13.026] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:19:13.026] - globals: [1] ‘FUN’
[16:19:13.026] 
[16:19:13.026] getGlobalsAndPackages() ... DONE
[16:19:13.026]  - globals found/used: [n=1] ‘FUN’
[16:19:13.026]  - needed namespaces: [n=0] 
[16:19:13.026] Finding globals ... DONE
[16:19:13.026]  - use_args: TRUE
[16:19:13.027]  - Getting '...' globals ...
[16:19:13.027] resolve() on list ...
[16:19:13.027]  recursive: 0
[16:19:13.027]  length: 1
[16:19:13.027]  elements: ‘...’
[16:19:13.027]  length: 0 (resolved future 1)
[16:19:13.027] resolve() on list ... DONE
[16:19:13.027]    - '...' content: [n=1] ‘y’
[16:19:13.028] List of 1
[16:19:13.028]  $ ...:List of 1
[16:19:13.028]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:13.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.028]  - attr(*, "where")=List of 1
[16:19:13.028]   ..$ ...:<environment: 0x56199ef43f98> 
[16:19:13.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.028]  - attr(*, "resolved")= logi TRUE
[16:19:13.028]  - attr(*, "total_size")= num NA
[16:19:13.030]  - Getting '...' globals ... DONE
[16:19:13.031] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:13.031] List of 2
[16:19:13.031]  $ ...future.FUN:function (x, y)  
[16:19:13.031]  $ ...          :List of 1
[16:19:13.031]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:13.031]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.031]  - attr(*, "where")=List of 2
[16:19:13.031]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.031]   ..$ ...          :<environment: 0x56199ef43f98> 
[16:19:13.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.031]  - attr(*, "resolved")= logi FALSE
[16:19:13.031]  - attr(*, "total_size")= num 4264
[16:19:13.036] Packages to be attached in all futures: [n=0] 
[16:19:13.036] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.036] Number of futures (= number of chunks): 1
[16:19:13.036] Launching 1 futures (chunks) ...
[16:19:13.036] Chunk #1 of 1 ...
[16:19:13.036]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.036] getGlobalsAndPackages() ...
[16:19:13.036] Searching for globals...
[16:19:13.037] 
[16:19:13.037] Searching for globals ... DONE
[16:19:13.037] - globals: [0] <none>
[16:19:13.037] getGlobalsAndPackages() ... DONE
[16:19:13.037]    + additional globals found: [n=0] 
[16:19:13.037]    + additional namespaces needed: [n=0] 
[16:19:13.037]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.037]  - seeds: <none>
[16:19:13.037]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.038] getGlobalsAndPackages() ...
[16:19:13.038] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.038] Resolving globals: FALSE
[16:19:13.038] Tweak future expression to call with '...' arguments ...
[16:19:13.038] {
[16:19:13.038]     do.call(function(...) {
[16:19:13.038]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.038]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.038]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.038]             on.exit(options(oopts), add = TRUE)
[16:19:13.038]         }
[16:19:13.038]         {
[16:19:13.038]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.038]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.038]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.038]             })
[16:19:13.038]         }
[16:19:13.038]     }, args = future.call.arguments)
[16:19:13.038] }
[16:19:13.038] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.039] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.039] 
[16:19:13.039] getGlobalsAndPackages() ... DONE
[16:19:13.039] run() for ‘Future’ ...
[16:19:13.039] - state: ‘created’
[16:19:13.039] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:13.040] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:13.040]   - Field: ‘label’
[16:19:13.040]   - Field: ‘local’
[16:19:13.040]   - Field: ‘owner’
[16:19:13.040]   - Field: ‘envir’
[16:19:13.040]   - Field: ‘packages’
[16:19:13.040]   - Field: ‘gc’
[16:19:13.040]   - Field: ‘conditions’
[16:19:13.041]   - Field: ‘expr’
[16:19:13.041]   - Field: ‘uuid’
[16:19:13.041]   - Field: ‘seed’
[16:19:13.041]   - Field: ‘version’
[16:19:13.041]   - Field: ‘result’
[16:19:13.041]   - Field: ‘asynchronous’
[16:19:13.041]   - Field: ‘calls’
[16:19:13.041]   - Field: ‘globals’
[16:19:13.041]   - Field: ‘stdout’
[16:19:13.041]   - Field: ‘earlySignal’
[16:19:13.041]   - Field: ‘lazy’
[16:19:13.042]   - Field: ‘state’
[16:19:13.042] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:13.042] - Launch lazy future ...
[16:19:13.042] Packages needed by the future expression (n = 0): <none>
[16:19:13.042] Packages needed by future strategies (n = 0): <none>
[16:19:13.042] {
[16:19:13.042]     {
[16:19:13.042]         {
[16:19:13.042]             ...future.startTime <- base::Sys.time()
[16:19:13.042]             {
[16:19:13.042]                 {
[16:19:13.042]                   {
[16:19:13.042]                     base::local({
[16:19:13.042]                       has_future <- base::requireNamespace("future", 
[16:19:13.042]                         quietly = TRUE)
[16:19:13.042]                       if (has_future) {
[16:19:13.042]                         ns <- base::getNamespace("future")
[16:19:13.042]                         version <- ns[[".package"]][["version"]]
[16:19:13.042]                         if (is.null(version)) 
[16:19:13.042]                           version <- utils::packageVersion("future")
[16:19:13.042]                       }
[16:19:13.042]                       else {
[16:19:13.042]                         version <- NULL
[16:19:13.042]                       }
[16:19:13.042]                       if (!has_future || version < "1.8.0") {
[16:19:13.042]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.042]                           "", base::R.version$version.string), 
[16:19:13.042]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:13.042]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:13.042]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.042]                             "release", "version")], collapse = " "), 
[16:19:13.042]                           hostname = base::Sys.info()[["nodename"]])
[16:19:13.042]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.042]                           info)
[16:19:13.042]                         info <- base::paste(info, collapse = "; ")
[16:19:13.042]                         if (!has_future) {
[16:19:13.042]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.042]                             info)
[16:19:13.042]                         }
[16:19:13.042]                         else {
[16:19:13.042]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.042]                             info, version)
[16:19:13.042]                         }
[16:19:13.042]                         base::stop(msg)
[16:19:13.042]                       }
[16:19:13.042]                     })
[16:19:13.042]                   }
[16:19:13.042]                   ...future.strategy.old <- future::plan("list")
[16:19:13.042]                   options(future.plan = NULL)
[16:19:13.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.042]                 }
[16:19:13.042]                 ...future.workdir <- getwd()
[16:19:13.042]             }
[16:19:13.042]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.042]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.042]         }
[16:19:13.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.042]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:13.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.042]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.042]             base::names(...future.oldOptions))
[16:19:13.042]     }
[16:19:13.042]     if (FALSE) {
[16:19:13.042]     }
[16:19:13.042]     else {
[16:19:13.042]         if (TRUE) {
[16:19:13.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.042]                 open = "w")
[16:19:13.042]         }
[16:19:13.042]         else {
[16:19:13.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.042]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.042]         }
[16:19:13.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.042]             base::sink(type = "output", split = FALSE)
[16:19:13.042]             base::close(...future.stdout)
[16:19:13.042]         }, add = TRUE)
[16:19:13.042]     }
[16:19:13.042]     ...future.frame <- base::sys.nframe()
[16:19:13.042]     ...future.conditions <- base::list()
[16:19:13.042]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.042]     if (FALSE) {
[16:19:13.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.042]     }
[16:19:13.042]     ...future.result <- base::tryCatch({
[16:19:13.042]         base::withCallingHandlers({
[16:19:13.042]             ...future.value <- base::withVisible(base::local({
[16:19:13.042]                 do.call(function(...) {
[16:19:13.042]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.042]                   if (!identical(...future.globals.maxSize.org, 
[16:19:13.042]                     ...future.globals.maxSize)) {
[16:19:13.042]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.042]                     on.exit(options(oopts), add = TRUE)
[16:19:13.042]                   }
[16:19:13.042]                   {
[16:19:13.042]                     lapply(seq_along(...future.elements_ii), 
[16:19:13.042]                       FUN = function(jj) {
[16:19:13.042]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.042]                         ...future.FUN(...future.X_jj, ...)
[16:19:13.042]                       })
[16:19:13.042]                   }
[16:19:13.042]                 }, args = future.call.arguments)
[16:19:13.042]             }))
[16:19:13.042]             future::FutureResult(value = ...future.value$value, 
[16:19:13.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.042]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.042]                     ...future.globalenv.names))
[16:19:13.042]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.042]         }, condition = base::local({
[16:19:13.042]             c <- base::c
[16:19:13.042]             inherits <- base::inherits
[16:19:13.042]             invokeRestart <- base::invokeRestart
[16:19:13.042]             length <- base::length
[16:19:13.042]             list <- base::list
[16:19:13.042]             seq.int <- base::seq.int
[16:19:13.042]             signalCondition <- base::signalCondition
[16:19:13.042]             sys.calls <- base::sys.calls
[16:19:13.042]             `[[` <- base::`[[`
[16:19:13.042]             `+` <- base::`+`
[16:19:13.042]             `<<-` <- base::`<<-`
[16:19:13.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.042]                   3L)]
[16:19:13.042]             }
[16:19:13.042]             function(cond) {
[16:19:13.042]                 is_error <- inherits(cond, "error")
[16:19:13.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.042]                   NULL)
[16:19:13.042]                 if (is_error) {
[16:19:13.042]                   sessionInformation <- function() {
[16:19:13.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.042]                       search = base::search(), system = base::Sys.info())
[16:19:13.042]                   }
[16:19:13.042]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.042]                     cond$call), session = sessionInformation(), 
[16:19:13.042]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.042]                   signalCondition(cond)
[16:19:13.042]                 }
[16:19:13.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.042]                 "immediateCondition"))) {
[16:19:13.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.042]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.042]                   if (TRUE && !signal) {
[16:19:13.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.042]                     {
[16:19:13.042]                       inherits <- base::inherits
[16:19:13.042]                       invokeRestart <- base::invokeRestart
[16:19:13.042]                       is.null <- base::is.null
[16:19:13.042]                       muffled <- FALSE
[16:19:13.042]                       if (inherits(cond, "message")) {
[16:19:13.042]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.042]                         if (muffled) 
[16:19:13.042]                           invokeRestart("muffleMessage")
[16:19:13.042]                       }
[16:19:13.042]                       else if (inherits(cond, "warning")) {
[16:19:13.042]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.042]                         if (muffled) 
[16:19:13.042]                           invokeRestart("muffleWarning")
[16:19:13.042]                       }
[16:19:13.042]                       else if (inherits(cond, "condition")) {
[16:19:13.042]                         if (!is.null(pattern)) {
[16:19:13.042]                           computeRestarts <- base::computeRestarts
[16:19:13.042]                           grepl <- base::grepl
[16:19:13.042]                           restarts <- computeRestarts(cond)
[16:19:13.042]                           for (restart in restarts) {
[16:19:13.042]                             name <- restart$name
[16:19:13.042]                             if (is.null(name)) 
[16:19:13.042]                               next
[16:19:13.042]                             if (!grepl(pattern, name)) 
[16:19:13.042]                               next
[16:19:13.042]                             invokeRestart(restart)
[16:19:13.042]                             muffled <- TRUE
[16:19:13.042]                             break
[16:19:13.042]                           }
[16:19:13.042]                         }
[16:19:13.042]                       }
[16:19:13.042]                       invisible(muffled)
[16:19:13.042]                     }
[16:19:13.042]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.042]                   }
[16:19:13.042]                 }
[16:19:13.042]                 else {
[16:19:13.042]                   if (TRUE) {
[16:19:13.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.042]                     {
[16:19:13.042]                       inherits <- base::inherits
[16:19:13.042]                       invokeRestart <- base::invokeRestart
[16:19:13.042]                       is.null <- base::is.null
[16:19:13.042]                       muffled <- FALSE
[16:19:13.042]                       if (inherits(cond, "message")) {
[16:19:13.042]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.042]                         if (muffled) 
[16:19:13.042]                           invokeRestart("muffleMessage")
[16:19:13.042]                       }
[16:19:13.042]                       else if (inherits(cond, "warning")) {
[16:19:13.042]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.042]                         if (muffled) 
[16:19:13.042]                           invokeRestart("muffleWarning")
[16:19:13.042]                       }
[16:19:13.042]                       else if (inherits(cond, "condition")) {
[16:19:13.042]                         if (!is.null(pattern)) {
[16:19:13.042]                           computeRestarts <- base::computeRestarts
[16:19:13.042]                           grepl <- base::grepl
[16:19:13.042]                           restarts <- computeRestarts(cond)
[16:19:13.042]                           for (restart in restarts) {
[16:19:13.042]                             name <- restart$name
[16:19:13.042]                             if (is.null(name)) 
[16:19:13.042]                               next
[16:19:13.042]                             if (!grepl(pattern, name)) 
[16:19:13.042]                               next
[16:19:13.042]                             invokeRestart(restart)
[16:19:13.042]                             muffled <- TRUE
[16:19:13.042]                             break
[16:19:13.042]                           }
[16:19:13.042]                         }
[16:19:13.042]                       }
[16:19:13.042]                       invisible(muffled)
[16:19:13.042]                     }
[16:19:13.042]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.042]                   }
[16:19:13.042]                 }
[16:19:13.042]             }
[16:19:13.042]         }))
[16:19:13.042]     }, error = function(ex) {
[16:19:13.042]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.042]                 ...future.rng), started = ...future.startTime, 
[16:19:13.042]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.042]             version = "1.8"), class = "FutureResult")
[16:19:13.042]     }, finally = {
[16:19:13.042]         if (!identical(...future.workdir, getwd())) 
[16:19:13.042]             setwd(...future.workdir)
[16:19:13.042]         {
[16:19:13.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.042]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.042]             }
[16:19:13.042]             base::options(...future.oldOptions)
[16:19:13.042]             if (.Platform$OS.type == "windows") {
[16:19:13.042]                 old_names <- names(...future.oldEnvVars)
[16:19:13.042]                 envs <- base::Sys.getenv()
[16:19:13.042]                 names <- names(envs)
[16:19:13.042]                 common <- intersect(names, old_names)
[16:19:13.042]                 added <- setdiff(names, old_names)
[16:19:13.042]                 removed <- setdiff(old_names, names)
[16:19:13.042]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.042]                   envs[common]]
[16:19:13.042]                 NAMES <- toupper(changed)
[16:19:13.042]                 args <- list()
[16:19:13.042]                 for (kk in seq_along(NAMES)) {
[16:19:13.042]                   name <- changed[[kk]]
[16:19:13.042]                   NAME <- NAMES[[kk]]
[16:19:13.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.042]                     next
[16:19:13.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.042]                 }
[16:19:13.042]                 NAMES <- toupper(added)
[16:19:13.042]                 for (kk in seq_along(NAMES)) {
[16:19:13.042]                   name <- added[[kk]]
[16:19:13.042]                   NAME <- NAMES[[kk]]
[16:19:13.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.042]                     next
[16:19:13.042]                   args[[name]] <- ""
[16:19:13.042]                 }
[16:19:13.042]                 NAMES <- toupper(removed)
[16:19:13.042]                 for (kk in seq_along(NAMES)) {
[16:19:13.042]                   name <- removed[[kk]]
[16:19:13.042]                   NAME <- NAMES[[kk]]
[16:19:13.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.042]                     next
[16:19:13.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.042]                 }
[16:19:13.042]                 if (length(args) > 0) 
[16:19:13.042]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.042]             }
[16:19:13.042]             else {
[16:19:13.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.042]             }
[16:19:13.042]             {
[16:19:13.042]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.042]                   0L) {
[16:19:13.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.042]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.042]                   base::options(opts)
[16:19:13.042]                 }
[16:19:13.042]                 {
[16:19:13.042]                   {
[16:19:13.042]                     NULL
[16:19:13.042]                     RNGkind("Mersenne-Twister")
[16:19:13.042]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:13.042]                       inherits = FALSE)
[16:19:13.042]                   }
[16:19:13.042]                   options(future.plan = NULL)
[16:19:13.042]                   if (is.na(NA_character_)) 
[16:19:13.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.042]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.042]                     .init = FALSE)
[16:19:13.042]                 }
[16:19:13.042]             }
[16:19:13.042]         }
[16:19:13.042]     })
[16:19:13.042]     if (TRUE) {
[16:19:13.042]         base::sink(type = "output", split = FALSE)
[16:19:13.042]         if (TRUE) {
[16:19:13.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.042]         }
[16:19:13.042]         else {
[16:19:13.042]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.042]         }
[16:19:13.042]         base::close(...future.stdout)
[16:19:13.042]         ...future.stdout <- NULL
[16:19:13.042]     }
[16:19:13.042]     ...future.result$conditions <- ...future.conditions
[16:19:13.042]     ...future.result$finished <- base::Sys.time()
[16:19:13.042]     ...future.result
[16:19:13.042] }
[16:19:13.044] assign_globals() ...
[16:19:13.044] List of 5
[16:19:13.044]  $ ...future.FUN            :function (x, y)  
[16:19:13.044]  $ future.call.arguments    :List of 1
[16:19:13.044]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:13.044]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.044]  $ ...future.elements_ii    :List of 4
[16:19:13.044]   ..$ A: num 50
[16:19:13.044]   ..$ B: num 60
[16:19:13.044]   ..$ C: num 70
[16:19:13.044]   ..$ D: num 80
[16:19:13.044]  $ ...future.seeds_ii       : NULL
[16:19:13.044]  $ ...future.globals.maxSize: NULL
[16:19:13.044]  - attr(*, "where")=List of 5
[16:19:13.044]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.044]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.044]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.044]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.044]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.044]  - attr(*, "resolved")= logi FALSE
[16:19:13.044]  - attr(*, "total_size")= num 4264
[16:19:13.044]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.044]  - attr(*, "already-done")= logi TRUE
[16:19:13.050] - reassign environment for ‘...future.FUN’
[16:19:13.050] - copied ‘...future.FUN’ to environment
[16:19:13.050] - copied ‘future.call.arguments’ to environment
[16:19:13.050] - copied ‘...future.elements_ii’ to environment
[16:19:13.050] - copied ‘...future.seeds_ii’ to environment
[16:19:13.051] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.051] assign_globals() ... done
[16:19:13.051] plan(): Setting new future strategy stack:
[16:19:13.051] List of future strategies:
[16:19:13.051] 1. sequential:
[16:19:13.051]    - args: function (..., envir = parent.frame())
[16:19:13.051]    - tweaked: FALSE
[16:19:13.051]    - call: NULL
[16:19:13.051] plan(): nbrOfWorkers() = 1
[16:19:13.052] plan(): Setting new future strategy stack:
[16:19:13.052] List of future strategies:
[16:19:13.052] 1. sequential:
[16:19:13.052]    - args: function (..., envir = parent.frame())
[16:19:13.052]    - tweaked: FALSE
[16:19:13.052]    - call: plan(strategy)
[16:19:13.053] plan(): nbrOfWorkers() = 1
[16:19:13.053] SequentialFuture started (and completed)
[16:19:13.053] - Launch lazy future ... done
[16:19:13.053] run() for ‘SequentialFuture’ ... done
[16:19:13.053] Created future:
[16:19:13.053] SequentialFuture:
[16:19:13.053] Label: ‘future_sapply-1’
[16:19:13.053] Expression:
[16:19:13.053] {
[16:19:13.053]     do.call(function(...) {
[16:19:13.053]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.053]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.053]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.053]             on.exit(options(oopts), add = TRUE)
[16:19:13.053]         }
[16:19:13.053]         {
[16:19:13.053]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.053]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.053]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.053]             })
[16:19:13.053]         }
[16:19:13.053]     }, args = future.call.arguments)
[16:19:13.053] }
[16:19:13.053] Lazy evaluation: FALSE
[16:19:13.053] Asynchronous evaluation: FALSE
[16:19:13.053] Local evaluation: TRUE
[16:19:13.053] Environment: R_GlobalEnv
[16:19:13.053] Capture standard output: TRUE
[16:19:13.053] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.053] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:13.053] Packages: <none>
[16:19:13.053] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.053] Resolved: TRUE
[16:19:13.053] Value: 1.34 KiB of class ‘list’
[16:19:13.053] Early signaling: FALSE
[16:19:13.053] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.053] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.054] Chunk #1 of 1 ... DONE
[16:19:13.054] Launching 1 futures (chunks) ... DONE
[16:19:13.055] Resolving 1 futures (chunks) ...
[16:19:13.055] resolve() on list ...
[16:19:13.055]  recursive: 0
[16:19:13.055]  length: 1
[16:19:13.055] 
[16:19:13.055] resolved() for ‘SequentialFuture’ ...
[16:19:13.055] - state: ‘finished’
[16:19:13.055] - run: TRUE
[16:19:13.055] - result: ‘FutureResult’
[16:19:13.055] resolved() for ‘SequentialFuture’ ... done
[16:19:13.055] Future #1
[16:19:13.056] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:13.056] - nx: 1
[16:19:13.057] - relay: TRUE
[16:19:13.058] - stdout: TRUE
[16:19:13.058] - signal: TRUE
[16:19:13.058] - resignal: FALSE
[16:19:13.058] - force: TRUE
[16:19:13.058] - relayed: [n=1] FALSE
[16:19:13.058] - queued futures: [n=1] FALSE
[16:19:13.058]  - until=1
[16:19:13.058]  - relaying element #1
[16:19:13.059] - relayed: [n=1] TRUE
[16:19:13.059] - queued futures: [n=1] TRUE
[16:19:13.059] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:13.059]  length: 0 (resolved future 1)
[16:19:13.059] Relaying remaining futures
[16:19:13.059] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.059] - nx: 1
[16:19:13.059] - relay: TRUE
[16:19:13.059] - stdout: TRUE
[16:19:13.060] - signal: TRUE
[16:19:13.060] - resignal: FALSE
[16:19:13.060] - force: TRUE
[16:19:13.060] - relayed: [n=1] TRUE
[16:19:13.060] - queued futures: [n=1] TRUE
 - flush all
[16:19:13.060] - relayed: [n=1] TRUE
[16:19:13.060] - queued futures: [n=1] TRUE
[16:19:13.060] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.060] resolve() on list ... DONE
[16:19:13.060]  - Number of value chunks collected: 1
[16:19:13.061] Resolving 1 futures (chunks) ... DONE
[16:19:13.061] Reducing values from 1 chunks ...
[16:19:13.061]  - Number of values collected after concatenation: 4
[16:19:13.061]  - Number of values expected: 4
[16:19:13.061] Reducing values from 1 chunks ... DONE
[16:19:13.061] future_lapply() ... DONE
[16:19:13.061] future_lapply() ...
[16:19:13.063] Number of chunks: 1
[16:19:13.063] getGlobalsAndPackagesXApply() ...
[16:19:13.063]  - future.globals: TRUE
[16:19:13.064] getGlobalsAndPackages() ...
[16:19:13.064] Searching for globals...
[16:19:13.067] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:19:13.067] Searching for globals ... DONE
[16:19:13.068] Resolving globals: FALSE
[16:19:13.068] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:19:13.069] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.069] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.069] - packages: [1] ‘future.apply’
[16:19:13.069] getGlobalsAndPackages() ... DONE
[16:19:13.069]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.069]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.070] Finding globals ... DONE
[16:19:13.070]  - use_args: TRUE
[16:19:13.070]  - Getting '...' globals ...
[16:19:13.070] resolve() on list ...
[16:19:13.070]  recursive: 0
[16:19:13.070]  length: 1
[16:19:13.070]  elements: ‘...’
[16:19:13.070]  length: 0 (resolved future 1)
[16:19:13.071] resolve() on list ... DONE
[16:19:13.071]    - '...' content: [n=1] ‘y’
[16:19:13.071] List of 1
[16:19:13.071]  $ ...:List of 1
[16:19:13.071]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:13.071]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.071]  - attr(*, "where")=List of 1
[16:19:13.071]   ..$ ...:<environment: 0x56199db8a250> 
[16:19:13.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.071]  - attr(*, "resolved")= logi TRUE
[16:19:13.071]  - attr(*, "total_size")= num NA
[16:19:13.074]  - Getting '...' globals ... DONE
[16:19:13.074] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.074] List of 8
[16:19:13.074]  $ ...future.FUN:function (x, ...)  
[16:19:13.074]  $ x_FUN        :function (x, y)  
[16:19:13.074]  $ times        : int 15
[16:19:13.074]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.074]  $ stop_if_not  :function (...)  
[16:19:13.074]  $ dim          : int [1:2] 3 5
[16:19:13.074]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:13.074]  $ ...          :List of 1
[16:19:13.074]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:13.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.074]  - attr(*, "where")=List of 8
[16:19:13.074]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.074]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.074]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.074]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.074]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.074]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.074]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.074]   ..$ ...          :<environment: 0x56199db8a250> 
[16:19:13.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.074]  - attr(*, "resolved")= logi FALSE
[16:19:13.074]  - attr(*, "total_size")= num 98600
[16:19:13.082] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.082] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.082] Number of futures (= number of chunks): 1
[16:19:13.082] Launching 1 futures (chunks) ...
[16:19:13.082] Chunk #1 of 1 ...
[16:19:13.082]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.082] getGlobalsAndPackages() ...
[16:19:13.083] Searching for globals...
[16:19:13.083] 
[16:19:13.083] Searching for globals ... DONE
[16:19:13.083] - globals: [0] <none>
[16:19:13.083] getGlobalsAndPackages() ... DONE
[16:19:13.083]    + additional globals found: [n=0] 
[16:19:13.083]    + additional namespaces needed: [n=0] 
[16:19:13.083]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.083]  - seeds: <none>
[16:19:13.084]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.084] getGlobalsAndPackages() ...
[16:19:13.084] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.084] Resolving globals: FALSE
[16:19:13.084] Tweak future expression to call with '...' arguments ...
[16:19:13.084] {
[16:19:13.084]     do.call(function(...) {
[16:19:13.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.084]             on.exit(options(oopts), add = TRUE)
[16:19:13.084]         }
[16:19:13.084]         {
[16:19:13.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.084]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.084]             })
[16:19:13.084]         }
[16:19:13.084]     }, args = future.call.arguments)
[16:19:13.084] }
[16:19:13.084] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.085] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.085] - packages: [1] ‘future.apply’
[16:19:13.085] getGlobalsAndPackages() ... DONE
[16:19:13.085] run() for ‘Future’ ...
[16:19:13.086] - state: ‘created’
[16:19:13.086] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:13.086] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.086] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:13.086]   - Field: ‘label’
[16:19:13.086]   - Field: ‘local’
[16:19:13.086]   - Field: ‘owner’
[16:19:13.086]   - Field: ‘envir’
[16:19:13.087]   - Field: ‘packages’
[16:19:13.087]   - Field: ‘gc’
[16:19:13.087]   - Field: ‘conditions’
[16:19:13.087]   - Field: ‘expr’
[16:19:13.087]   - Field: ‘uuid’
[16:19:13.087]   - Field: ‘seed’
[16:19:13.087]   - Field: ‘version’
[16:19:13.087]   - Field: ‘result’
[16:19:13.087]   - Field: ‘asynchronous’
[16:19:13.087]   - Field: ‘calls’
[16:19:13.087]   - Field: ‘globals’
[16:19:13.088]   - Field: ‘stdout’
[16:19:13.088]   - Field: ‘earlySignal’
[16:19:13.088]   - Field: ‘lazy’
[16:19:13.088]   - Field: ‘state’
[16:19:13.088] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:13.088] - Launch lazy future ...
[16:19:13.088] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.088] Packages needed by future strategies (n = 0): <none>
[16:19:13.089] {
[16:19:13.089]     {
[16:19:13.089]         {
[16:19:13.089]             ...future.startTime <- base::Sys.time()
[16:19:13.089]             {
[16:19:13.089]                 {
[16:19:13.089]                   {
[16:19:13.089]                     {
[16:19:13.089]                       base::local({
[16:19:13.089]                         has_future <- base::requireNamespace("future", 
[16:19:13.089]                           quietly = TRUE)
[16:19:13.089]                         if (has_future) {
[16:19:13.089]                           ns <- base::getNamespace("future")
[16:19:13.089]                           version <- ns[[".package"]][["version"]]
[16:19:13.089]                           if (is.null(version)) 
[16:19:13.089]                             version <- utils::packageVersion("future")
[16:19:13.089]                         }
[16:19:13.089]                         else {
[16:19:13.089]                           version <- NULL
[16:19:13.089]                         }
[16:19:13.089]                         if (!has_future || version < "1.8.0") {
[16:19:13.089]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.089]                             "", base::R.version$version.string), 
[16:19:13.089]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:13.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:13.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.089]                               "release", "version")], collapse = " "), 
[16:19:13.089]                             hostname = base::Sys.info()[["nodename"]])
[16:19:13.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.089]                             info)
[16:19:13.089]                           info <- base::paste(info, collapse = "; ")
[16:19:13.089]                           if (!has_future) {
[16:19:13.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.089]                               info)
[16:19:13.089]                           }
[16:19:13.089]                           else {
[16:19:13.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.089]                               info, version)
[16:19:13.089]                           }
[16:19:13.089]                           base::stop(msg)
[16:19:13.089]                         }
[16:19:13.089]                       })
[16:19:13.089]                     }
[16:19:13.089]                     base::local({
[16:19:13.089]                       for (pkg in "future.apply") {
[16:19:13.089]                         base::loadNamespace(pkg)
[16:19:13.089]                         base::library(pkg, character.only = TRUE)
[16:19:13.089]                       }
[16:19:13.089]                     })
[16:19:13.089]                   }
[16:19:13.089]                   ...future.strategy.old <- future::plan("list")
[16:19:13.089]                   options(future.plan = NULL)
[16:19:13.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.089]                 }
[16:19:13.089]                 ...future.workdir <- getwd()
[16:19:13.089]             }
[16:19:13.089]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.089]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.089]         }
[16:19:13.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:13.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.089]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.089]             base::names(...future.oldOptions))
[16:19:13.089]     }
[16:19:13.089]     if (FALSE) {
[16:19:13.089]     }
[16:19:13.089]     else {
[16:19:13.089]         if (TRUE) {
[16:19:13.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.089]                 open = "w")
[16:19:13.089]         }
[16:19:13.089]         else {
[16:19:13.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.089]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.089]         }
[16:19:13.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.089]             base::sink(type = "output", split = FALSE)
[16:19:13.089]             base::close(...future.stdout)
[16:19:13.089]         }, add = TRUE)
[16:19:13.089]     }
[16:19:13.089]     ...future.frame <- base::sys.nframe()
[16:19:13.089]     ...future.conditions <- base::list()
[16:19:13.089]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.089]     if (FALSE) {
[16:19:13.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.089]     }
[16:19:13.089]     ...future.result <- base::tryCatch({
[16:19:13.089]         base::withCallingHandlers({
[16:19:13.089]             ...future.value <- base::withVisible(base::local({
[16:19:13.089]                 do.call(function(...) {
[16:19:13.089]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.089]                   if (!identical(...future.globals.maxSize.org, 
[16:19:13.089]                     ...future.globals.maxSize)) {
[16:19:13.089]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.089]                     on.exit(options(oopts), add = TRUE)
[16:19:13.089]                   }
[16:19:13.089]                   {
[16:19:13.089]                     lapply(seq_along(...future.elements_ii), 
[16:19:13.089]                       FUN = function(jj) {
[16:19:13.089]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.089]                         ...future.FUN(...future.X_jj, ...)
[16:19:13.089]                       })
[16:19:13.089]                   }
[16:19:13.089]                 }, args = future.call.arguments)
[16:19:13.089]             }))
[16:19:13.089]             future::FutureResult(value = ...future.value$value, 
[16:19:13.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.089]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.089]                     ...future.globalenv.names))
[16:19:13.089]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.089]         }, condition = base::local({
[16:19:13.089]             c <- base::c
[16:19:13.089]             inherits <- base::inherits
[16:19:13.089]             invokeRestart <- base::invokeRestart
[16:19:13.089]             length <- base::length
[16:19:13.089]             list <- base::list
[16:19:13.089]             seq.int <- base::seq.int
[16:19:13.089]             signalCondition <- base::signalCondition
[16:19:13.089]             sys.calls <- base::sys.calls
[16:19:13.089]             `[[` <- base::`[[`
[16:19:13.089]             `+` <- base::`+`
[16:19:13.089]             `<<-` <- base::`<<-`
[16:19:13.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.089]                   3L)]
[16:19:13.089]             }
[16:19:13.089]             function(cond) {
[16:19:13.089]                 is_error <- inherits(cond, "error")
[16:19:13.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.089]                   NULL)
[16:19:13.089]                 if (is_error) {
[16:19:13.089]                   sessionInformation <- function() {
[16:19:13.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.089]                       search = base::search(), system = base::Sys.info())
[16:19:13.089]                   }
[16:19:13.089]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.089]                     cond$call), session = sessionInformation(), 
[16:19:13.089]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.089]                   signalCondition(cond)
[16:19:13.089]                 }
[16:19:13.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.089]                 "immediateCondition"))) {
[16:19:13.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.089]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.089]                   if (TRUE && !signal) {
[16:19:13.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.089]                     {
[16:19:13.089]                       inherits <- base::inherits
[16:19:13.089]                       invokeRestart <- base::invokeRestart
[16:19:13.089]                       is.null <- base::is.null
[16:19:13.089]                       muffled <- FALSE
[16:19:13.089]                       if (inherits(cond, "message")) {
[16:19:13.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.089]                         if (muffled) 
[16:19:13.089]                           invokeRestart("muffleMessage")
[16:19:13.089]                       }
[16:19:13.089]                       else if (inherits(cond, "warning")) {
[16:19:13.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.089]                         if (muffled) 
[16:19:13.089]                           invokeRestart("muffleWarning")
[16:19:13.089]                       }
[16:19:13.089]                       else if (inherits(cond, "condition")) {
[16:19:13.089]                         if (!is.null(pattern)) {
[16:19:13.089]                           computeRestarts <- base::computeRestarts
[16:19:13.089]                           grepl <- base::grepl
[16:19:13.089]                           restarts <- computeRestarts(cond)
[16:19:13.089]                           for (restart in restarts) {
[16:19:13.089]                             name <- restart$name
[16:19:13.089]                             if (is.null(name)) 
[16:19:13.089]                               next
[16:19:13.089]                             if (!grepl(pattern, name)) 
[16:19:13.089]                               next
[16:19:13.089]                             invokeRestart(restart)
[16:19:13.089]                             muffled <- TRUE
[16:19:13.089]                             break
[16:19:13.089]                           }
[16:19:13.089]                         }
[16:19:13.089]                       }
[16:19:13.089]                       invisible(muffled)
[16:19:13.089]                     }
[16:19:13.089]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.089]                   }
[16:19:13.089]                 }
[16:19:13.089]                 else {
[16:19:13.089]                   if (TRUE) {
[16:19:13.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.089]                     {
[16:19:13.089]                       inherits <- base::inherits
[16:19:13.089]                       invokeRestart <- base::invokeRestart
[16:19:13.089]                       is.null <- base::is.null
[16:19:13.089]                       muffled <- FALSE
[16:19:13.089]                       if (inherits(cond, "message")) {
[16:19:13.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.089]                         if (muffled) 
[16:19:13.089]                           invokeRestart("muffleMessage")
[16:19:13.089]                       }
[16:19:13.089]                       else if (inherits(cond, "warning")) {
[16:19:13.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.089]                         if (muffled) 
[16:19:13.089]                           invokeRestart("muffleWarning")
[16:19:13.089]                       }
[16:19:13.089]                       else if (inherits(cond, "condition")) {
[16:19:13.089]                         if (!is.null(pattern)) {
[16:19:13.089]                           computeRestarts <- base::computeRestarts
[16:19:13.089]                           grepl <- base::grepl
[16:19:13.089]                           restarts <- computeRestarts(cond)
[16:19:13.089]                           for (restart in restarts) {
[16:19:13.089]                             name <- restart$name
[16:19:13.089]                             if (is.null(name)) 
[16:19:13.089]                               next
[16:19:13.089]                             if (!grepl(pattern, name)) 
[16:19:13.089]                               next
[16:19:13.089]                             invokeRestart(restart)
[16:19:13.089]                             muffled <- TRUE
[16:19:13.089]                             break
[16:19:13.089]                           }
[16:19:13.089]                         }
[16:19:13.089]                       }
[16:19:13.089]                       invisible(muffled)
[16:19:13.089]                     }
[16:19:13.089]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.089]                   }
[16:19:13.089]                 }
[16:19:13.089]             }
[16:19:13.089]         }))
[16:19:13.089]     }, error = function(ex) {
[16:19:13.089]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.089]                 ...future.rng), started = ...future.startTime, 
[16:19:13.089]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.089]             version = "1.8"), class = "FutureResult")
[16:19:13.089]     }, finally = {
[16:19:13.089]         if (!identical(...future.workdir, getwd())) 
[16:19:13.089]             setwd(...future.workdir)
[16:19:13.089]         {
[16:19:13.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.089]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.089]             }
[16:19:13.089]             base::options(...future.oldOptions)
[16:19:13.089]             if (.Platform$OS.type == "windows") {
[16:19:13.089]                 old_names <- names(...future.oldEnvVars)
[16:19:13.089]                 envs <- base::Sys.getenv()
[16:19:13.089]                 names <- names(envs)
[16:19:13.089]                 common <- intersect(names, old_names)
[16:19:13.089]                 added <- setdiff(names, old_names)
[16:19:13.089]                 removed <- setdiff(old_names, names)
[16:19:13.089]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.089]                   envs[common]]
[16:19:13.089]                 NAMES <- toupper(changed)
[16:19:13.089]                 args <- list()
[16:19:13.089]                 for (kk in seq_along(NAMES)) {
[16:19:13.089]                   name <- changed[[kk]]
[16:19:13.089]                   NAME <- NAMES[[kk]]
[16:19:13.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.089]                     next
[16:19:13.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.089]                 }
[16:19:13.089]                 NAMES <- toupper(added)
[16:19:13.089]                 for (kk in seq_along(NAMES)) {
[16:19:13.089]                   name <- added[[kk]]
[16:19:13.089]                   NAME <- NAMES[[kk]]
[16:19:13.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.089]                     next
[16:19:13.089]                   args[[name]] <- ""
[16:19:13.089]                 }
[16:19:13.089]                 NAMES <- toupper(removed)
[16:19:13.089]                 for (kk in seq_along(NAMES)) {
[16:19:13.089]                   name <- removed[[kk]]
[16:19:13.089]                   NAME <- NAMES[[kk]]
[16:19:13.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.089]                     next
[16:19:13.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.089]                 }
[16:19:13.089]                 if (length(args) > 0) 
[16:19:13.089]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.089]             }
[16:19:13.089]             else {
[16:19:13.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.089]             }
[16:19:13.089]             {
[16:19:13.089]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.089]                   0L) {
[16:19:13.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.089]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.089]                   base::options(opts)
[16:19:13.089]                 }
[16:19:13.089]                 {
[16:19:13.089]                   {
[16:19:13.089]                     NULL
[16:19:13.089]                     RNGkind("Mersenne-Twister")
[16:19:13.089]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:13.089]                       inherits = FALSE)
[16:19:13.089]                   }
[16:19:13.089]                   options(future.plan = NULL)
[16:19:13.089]                   if (is.na(NA_character_)) 
[16:19:13.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.089]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.089]                     .init = FALSE)
[16:19:13.089]                 }
[16:19:13.089]             }
[16:19:13.089]         }
[16:19:13.089]     })
[16:19:13.089]     if (TRUE) {
[16:19:13.089]         base::sink(type = "output", split = FALSE)
[16:19:13.089]         if (TRUE) {
[16:19:13.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.089]         }
[16:19:13.089]         else {
[16:19:13.089]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.089]         }
[16:19:13.089]         base::close(...future.stdout)
[16:19:13.089]         ...future.stdout <- NULL
[16:19:13.089]     }
[16:19:13.089]     ...future.result$conditions <- ...future.conditions
[16:19:13.089]     ...future.result$finished <- base::Sys.time()
[16:19:13.089]     ...future.result
[16:19:13.089] }
[16:19:13.091] assign_globals() ...
[16:19:13.091] List of 11
[16:19:13.091]  $ ...future.FUN            :function (x, ...)  
[16:19:13.091]  $ x_FUN                    :function (x, y)  
[16:19:13.091]  $ times                    : int 15
[16:19:13.091]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.091]  $ stop_if_not              :function (...)  
[16:19:13.091]  $ dim                      : int [1:2] 3 5
[16:19:13.091]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.091]  $ future.call.arguments    :List of 1
[16:19:13.091]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:13.091]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.091]  $ ...future.elements_ii    :List of 4
[16:19:13.091]   ..$ A: num 50
[16:19:13.091]   ..$ B: num 60
[16:19:13.091]   ..$ C: num 70
[16:19:13.091]   ..$ D: num 80
[16:19:13.091]  $ ...future.seeds_ii       : NULL
[16:19:13.091]  $ ...future.globals.maxSize: NULL
[16:19:13.091]  - attr(*, "where")=List of 11
[16:19:13.091]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.091]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.091]  - attr(*, "resolved")= logi FALSE
[16:19:13.091]  - attr(*, "total_size")= num 98600
[16:19:13.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.091]  - attr(*, "already-done")= logi TRUE
[16:19:13.099] - copied ‘...future.FUN’ to environment
[16:19:13.099] - reassign environment for ‘x_FUN’
[16:19:13.099] - copied ‘x_FUN’ to environment
[16:19:13.099] - copied ‘times’ to environment
[16:19:13.101] - copied ‘stopf’ to environment
[16:19:13.101] - copied ‘stop_if_not’ to environment
[16:19:13.101] - copied ‘dim’ to environment
[16:19:13.101] - copied ‘valid_types’ to environment
[16:19:13.101] - copied ‘future.call.arguments’ to environment
[16:19:13.102] - copied ‘...future.elements_ii’ to environment
[16:19:13.102] - copied ‘...future.seeds_ii’ to environment
[16:19:13.102] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.102] assign_globals() ... done
[16:19:13.102] plan(): Setting new future strategy stack:
[16:19:13.102] List of future strategies:
[16:19:13.102] 1. sequential:
[16:19:13.102]    - args: function (..., envir = parent.frame())
[16:19:13.102]    - tweaked: FALSE
[16:19:13.102]    - call: NULL
[16:19:13.103] plan(): nbrOfWorkers() = 1
[16:19:13.104] plan(): Setting new future strategy stack:
[16:19:13.104] List of future strategies:
[16:19:13.104] 1. sequential:
[16:19:13.104]    - args: function (..., envir = parent.frame())
[16:19:13.104]    - tweaked: FALSE
[16:19:13.104]    - call: plan(strategy)
[16:19:13.104] plan(): nbrOfWorkers() = 1
[16:19:13.104] SequentialFuture started (and completed)
[16:19:13.104] - Launch lazy future ... done
[16:19:13.104] run() for ‘SequentialFuture’ ... done
[16:19:13.105] Created future:
[16:19:13.105] SequentialFuture:
[16:19:13.105] Label: ‘future_vapply-1’
[16:19:13.105] Expression:
[16:19:13.105] {
[16:19:13.105]     do.call(function(...) {
[16:19:13.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.105]             on.exit(options(oopts), add = TRUE)
[16:19:13.105]         }
[16:19:13.105]         {
[16:19:13.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.105]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.105]             })
[16:19:13.105]         }
[16:19:13.105]     }, args = future.call.arguments)
[16:19:13.105] }
[16:19:13.105] Lazy evaluation: FALSE
[16:19:13.105] Asynchronous evaluation: FALSE
[16:19:13.105] Local evaluation: TRUE
[16:19:13.105] Environment: R_GlobalEnv
[16:19:13.105] Capture standard output: TRUE
[16:19:13.105] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.105] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.105] Packages: 1 packages (‘future.apply’)
[16:19:13.105] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.105] Resolved: TRUE
[16:19:13.105] Value: 1.34 KiB of class ‘list’
[16:19:13.105] Early signaling: FALSE
[16:19:13.105] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.105] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.106] Chunk #1 of 1 ... DONE
[16:19:13.106] Launching 1 futures (chunks) ... DONE
[16:19:13.106] Resolving 1 futures (chunks) ...
[16:19:13.106] resolve() on list ...
[16:19:13.106]  recursive: 0
[16:19:13.106]  length: 1
[16:19:13.106] 
[16:19:13.106] resolved() for ‘SequentialFuture’ ...
[16:19:13.106] - state: ‘finished’
[16:19:13.107] - run: TRUE
[16:19:13.107] - result: ‘FutureResult’
[16:19:13.107] resolved() for ‘SequentialFuture’ ... done
[16:19:13.107] Future #1
[16:19:13.107] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:13.107] - nx: 1
[16:19:13.107] - relay: TRUE
[16:19:13.107] - stdout: TRUE
[16:19:13.107] - signal: TRUE
[16:19:13.107] - resignal: FALSE
[16:19:13.108] - force: TRUE
[16:19:13.108] - relayed: [n=1] FALSE
[16:19:13.108] - queued futures: [n=1] FALSE
[16:19:13.108]  - until=1
[16:19:13.108]  - relaying element #1
[16:19:13.108] - relayed: [n=1] TRUE
[16:19:13.108] - queued futures: [n=1] TRUE
[16:19:13.108] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:13.108]  length: 0 (resolved future 1)
[16:19:13.108] Relaying remaining futures
[16:19:13.109] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.109] - nx: 1
[16:19:13.109] - relay: TRUE
[16:19:13.109] - stdout: TRUE
[16:19:13.109] - signal: TRUE
[16:19:13.109] - resignal: FALSE
[16:19:13.109] - force: TRUE
[16:19:13.109] - relayed: [n=1] TRUE
[16:19:13.109] - queued futures: [n=1] TRUE
 - flush all
[16:19:13.109] - relayed: [n=1] TRUE
[16:19:13.109] - queued futures: [n=1] TRUE
[16:19:13.109] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.110] resolve() on list ... DONE
[16:19:13.110]  - Number of value chunks collected: 1
[16:19:13.110] Resolving 1 futures (chunks) ... DONE
[16:19:13.110] Reducing values from 1 chunks ...
[16:19:13.110]  - Number of values collected after concatenation: 4
[16:19:13.110]  - Number of values expected: 4
[16:19:13.110] Reducing values from 1 chunks ... DONE
[16:19:13.110] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:19:13.112] future_lapply() ...
[16:19:13.114] Number of chunks: 1
[16:19:13.114] getGlobalsAndPackagesXApply() ...
[16:19:13.114]  - future.globals: TRUE
[16:19:13.114] getGlobalsAndPackages() ...
[16:19:13.114] Searching for globals...
[16:19:13.117] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:13.117] Searching for globals ... DONE
[16:19:13.117] Resolving globals: FALSE
[16:19:13.118] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:19:13.118] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.118] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.119] - packages: [1] ‘future.apply’
[16:19:13.119] getGlobalsAndPackages() ... DONE
[16:19:13.119]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.119]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.119] Finding globals ... DONE
[16:19:13.119]  - use_args: TRUE
[16:19:13.119]  - Getting '...' globals ...
[16:19:13.119] resolve() on list ...
[16:19:13.120]  recursive: 0
[16:19:13.120]  length: 1
[16:19:13.120]  elements: ‘...’
[16:19:13.120]  length: 0 (resolved future 1)
[16:19:13.120] resolve() on list ... DONE
[16:19:13.120]    - '...' content: [n=0] 
[16:19:13.120] List of 1
[16:19:13.120]  $ ...: list()
[16:19:13.120]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.120]  - attr(*, "where")=List of 1
[16:19:13.120]   ..$ ...:<environment: 0x56199eeb1048> 
[16:19:13.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.120]  - attr(*, "resolved")= logi TRUE
[16:19:13.120]  - attr(*, "total_size")= num NA
[16:19:13.124]  - Getting '...' globals ... DONE
[16:19:13.125] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.125] List of 8
[16:19:13.125]  $ ...future.FUN:function (x, ...)  
[16:19:13.125]  $ x_FUN        :function (x)  
[16:19:13.125]  $ times        : int 1
[16:19:13.125]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.125]  $ stop_if_not  :function (...)  
[16:19:13.125]  $ dim          : NULL
[16:19:13.125]  $ valid_types  : chr "logical"
[16:19:13.125]  $ ...          : list()
[16:19:13.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.125]  - attr(*, "where")=List of 8
[16:19:13.125]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.125]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.125]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.125]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.125]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.125]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.125]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.125]   ..$ ...          :<environment: 0x56199eeb1048> 
[16:19:13.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.125]  - attr(*, "resolved")= logi FALSE
[16:19:13.125]  - attr(*, "total_size")= num 94200
[16:19:13.130] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.130] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.130] Number of futures (= number of chunks): 1
[16:19:13.130] Launching 1 futures (chunks) ...
[16:19:13.131] Chunk #1 of 1 ...
[16:19:13.131]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.131] getGlobalsAndPackages() ...
[16:19:13.131] Searching for globals...
[16:19:13.131] 
[16:19:13.131] Searching for globals ... DONE
[16:19:13.131] - globals: [0] <none>
[16:19:13.131] getGlobalsAndPackages() ... DONE
[16:19:13.131]    + additional globals found: [n=0] 
[16:19:13.132]    + additional namespaces needed: [n=0] 
[16:19:13.132]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.132]  - seeds: <none>
[16:19:13.132]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.132] getGlobalsAndPackages() ...
[16:19:13.132] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.132] Resolving globals: FALSE
[16:19:13.132] Tweak future expression to call with '...' arguments ...
[16:19:13.132] {
[16:19:13.132]     do.call(function(...) {
[16:19:13.132]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.132]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.132]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.132]             on.exit(options(oopts), add = TRUE)
[16:19:13.132]         }
[16:19:13.132]         {
[16:19:13.132]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.132]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.132]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.132]             })
[16:19:13.132]         }
[16:19:13.132]     }, args = future.call.arguments)
[16:19:13.132] }
[16:19:13.133] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.133] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.133] - packages: [1] ‘future.apply’
[16:19:13.133] getGlobalsAndPackages() ... DONE
[16:19:13.134] run() for ‘Future’ ...
[16:19:13.134] - state: ‘created’
[16:19:13.134] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:13.134] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.134] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:13.134]   - Field: ‘label’
[16:19:13.134]   - Field: ‘local’
[16:19:13.135]   - Field: ‘owner’
[16:19:13.135]   - Field: ‘envir’
[16:19:13.135]   - Field: ‘packages’
[16:19:13.135]   - Field: ‘gc’
[16:19:13.135]   - Field: ‘conditions’
[16:19:13.135]   - Field: ‘expr’
[16:19:13.135]   - Field: ‘uuid’
[16:19:13.135]   - Field: ‘seed’
[16:19:13.135]   - Field: ‘version’
[16:19:13.135]   - Field: ‘result’
[16:19:13.135]   - Field: ‘asynchronous’
[16:19:13.136]   - Field: ‘calls’
[16:19:13.136]   - Field: ‘globals’
[16:19:13.136]   - Field: ‘stdout’
[16:19:13.136]   - Field: ‘earlySignal’
[16:19:13.136]   - Field: ‘lazy’
[16:19:13.136]   - Field: ‘state’
[16:19:13.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:13.136] - Launch lazy future ...
[16:19:13.136] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.137] Packages needed by future strategies (n = 0): <none>
[16:19:13.137] {
[16:19:13.137]     {
[16:19:13.137]         {
[16:19:13.137]             ...future.startTime <- base::Sys.time()
[16:19:13.137]             {
[16:19:13.137]                 {
[16:19:13.137]                   {
[16:19:13.137]                     {
[16:19:13.137]                       base::local({
[16:19:13.137]                         has_future <- base::requireNamespace("future", 
[16:19:13.137]                           quietly = TRUE)
[16:19:13.137]                         if (has_future) {
[16:19:13.137]                           ns <- base::getNamespace("future")
[16:19:13.137]                           version <- ns[[".package"]][["version"]]
[16:19:13.137]                           if (is.null(version)) 
[16:19:13.137]                             version <- utils::packageVersion("future")
[16:19:13.137]                         }
[16:19:13.137]                         else {
[16:19:13.137]                           version <- NULL
[16:19:13.137]                         }
[16:19:13.137]                         if (!has_future || version < "1.8.0") {
[16:19:13.137]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.137]                             "", base::R.version$version.string), 
[16:19:13.137]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:13.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:13.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.137]                               "release", "version")], collapse = " "), 
[16:19:13.137]                             hostname = base::Sys.info()[["nodename"]])
[16:19:13.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.137]                             info)
[16:19:13.137]                           info <- base::paste(info, collapse = "; ")
[16:19:13.137]                           if (!has_future) {
[16:19:13.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.137]                               info)
[16:19:13.137]                           }
[16:19:13.137]                           else {
[16:19:13.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.137]                               info, version)
[16:19:13.137]                           }
[16:19:13.137]                           base::stop(msg)
[16:19:13.137]                         }
[16:19:13.137]                       })
[16:19:13.137]                     }
[16:19:13.137]                     base::local({
[16:19:13.137]                       for (pkg in "future.apply") {
[16:19:13.137]                         base::loadNamespace(pkg)
[16:19:13.137]                         base::library(pkg, character.only = TRUE)
[16:19:13.137]                       }
[16:19:13.137]                     })
[16:19:13.137]                   }
[16:19:13.137]                   ...future.strategy.old <- future::plan("list")
[16:19:13.137]                   options(future.plan = NULL)
[16:19:13.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.137]                 }
[16:19:13.137]                 ...future.workdir <- getwd()
[16:19:13.137]             }
[16:19:13.137]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.137]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.137]         }
[16:19:13.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:13.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.137]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.137]             base::names(...future.oldOptions))
[16:19:13.137]     }
[16:19:13.137]     if (FALSE) {
[16:19:13.137]     }
[16:19:13.137]     else {
[16:19:13.137]         if (TRUE) {
[16:19:13.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.137]                 open = "w")
[16:19:13.137]         }
[16:19:13.137]         else {
[16:19:13.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.137]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.137]         }
[16:19:13.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.137]             base::sink(type = "output", split = FALSE)
[16:19:13.137]             base::close(...future.stdout)
[16:19:13.137]         }, add = TRUE)
[16:19:13.137]     }
[16:19:13.137]     ...future.frame <- base::sys.nframe()
[16:19:13.137]     ...future.conditions <- base::list()
[16:19:13.137]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.137]     if (FALSE) {
[16:19:13.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.137]     }
[16:19:13.137]     ...future.result <- base::tryCatch({
[16:19:13.137]         base::withCallingHandlers({
[16:19:13.137]             ...future.value <- base::withVisible(base::local({
[16:19:13.137]                 do.call(function(...) {
[16:19:13.137]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.137]                   if (!identical(...future.globals.maxSize.org, 
[16:19:13.137]                     ...future.globals.maxSize)) {
[16:19:13.137]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.137]                     on.exit(options(oopts), add = TRUE)
[16:19:13.137]                   }
[16:19:13.137]                   {
[16:19:13.137]                     lapply(seq_along(...future.elements_ii), 
[16:19:13.137]                       FUN = function(jj) {
[16:19:13.137]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.137]                         ...future.FUN(...future.X_jj, ...)
[16:19:13.137]                       })
[16:19:13.137]                   }
[16:19:13.137]                 }, args = future.call.arguments)
[16:19:13.137]             }))
[16:19:13.137]             future::FutureResult(value = ...future.value$value, 
[16:19:13.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.137]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.137]                     ...future.globalenv.names))
[16:19:13.137]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.137]         }, condition = base::local({
[16:19:13.137]             c <- base::c
[16:19:13.137]             inherits <- base::inherits
[16:19:13.137]             invokeRestart <- base::invokeRestart
[16:19:13.137]             length <- base::length
[16:19:13.137]             list <- base::list
[16:19:13.137]             seq.int <- base::seq.int
[16:19:13.137]             signalCondition <- base::signalCondition
[16:19:13.137]             sys.calls <- base::sys.calls
[16:19:13.137]             `[[` <- base::`[[`
[16:19:13.137]             `+` <- base::`+`
[16:19:13.137]             `<<-` <- base::`<<-`
[16:19:13.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.137]                   3L)]
[16:19:13.137]             }
[16:19:13.137]             function(cond) {
[16:19:13.137]                 is_error <- inherits(cond, "error")
[16:19:13.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.137]                   NULL)
[16:19:13.137]                 if (is_error) {
[16:19:13.137]                   sessionInformation <- function() {
[16:19:13.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.137]                       search = base::search(), system = base::Sys.info())
[16:19:13.137]                   }
[16:19:13.137]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.137]                     cond$call), session = sessionInformation(), 
[16:19:13.137]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.137]                   signalCondition(cond)
[16:19:13.137]                 }
[16:19:13.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.137]                 "immediateCondition"))) {
[16:19:13.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.137]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.137]                   if (TRUE && !signal) {
[16:19:13.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.137]                     {
[16:19:13.137]                       inherits <- base::inherits
[16:19:13.137]                       invokeRestart <- base::invokeRestart
[16:19:13.137]                       is.null <- base::is.null
[16:19:13.137]                       muffled <- FALSE
[16:19:13.137]                       if (inherits(cond, "message")) {
[16:19:13.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.137]                         if (muffled) 
[16:19:13.137]                           invokeRestart("muffleMessage")
[16:19:13.137]                       }
[16:19:13.137]                       else if (inherits(cond, "warning")) {
[16:19:13.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.137]                         if (muffled) 
[16:19:13.137]                           invokeRestart("muffleWarning")
[16:19:13.137]                       }
[16:19:13.137]                       else if (inherits(cond, "condition")) {
[16:19:13.137]                         if (!is.null(pattern)) {
[16:19:13.137]                           computeRestarts <- base::computeRestarts
[16:19:13.137]                           grepl <- base::grepl
[16:19:13.137]                           restarts <- computeRestarts(cond)
[16:19:13.137]                           for (restart in restarts) {
[16:19:13.137]                             name <- restart$name
[16:19:13.137]                             if (is.null(name)) 
[16:19:13.137]                               next
[16:19:13.137]                             if (!grepl(pattern, name)) 
[16:19:13.137]                               next
[16:19:13.137]                             invokeRestart(restart)
[16:19:13.137]                             muffled <- TRUE
[16:19:13.137]                             break
[16:19:13.137]                           }
[16:19:13.137]                         }
[16:19:13.137]                       }
[16:19:13.137]                       invisible(muffled)
[16:19:13.137]                     }
[16:19:13.137]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.137]                   }
[16:19:13.137]                 }
[16:19:13.137]                 else {
[16:19:13.137]                   if (TRUE) {
[16:19:13.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.137]                     {
[16:19:13.137]                       inherits <- base::inherits
[16:19:13.137]                       invokeRestart <- base::invokeRestart
[16:19:13.137]                       is.null <- base::is.null
[16:19:13.137]                       muffled <- FALSE
[16:19:13.137]                       if (inherits(cond, "message")) {
[16:19:13.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.137]                         if (muffled) 
[16:19:13.137]                           invokeRestart("muffleMessage")
[16:19:13.137]                       }
[16:19:13.137]                       else if (inherits(cond, "warning")) {
[16:19:13.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.137]                         if (muffled) 
[16:19:13.137]                           invokeRestart("muffleWarning")
[16:19:13.137]                       }
[16:19:13.137]                       else if (inherits(cond, "condition")) {
[16:19:13.137]                         if (!is.null(pattern)) {
[16:19:13.137]                           computeRestarts <- base::computeRestarts
[16:19:13.137]                           grepl <- base::grepl
[16:19:13.137]                           restarts <- computeRestarts(cond)
[16:19:13.137]                           for (restart in restarts) {
[16:19:13.137]                             name <- restart$name
[16:19:13.137]                             if (is.null(name)) 
[16:19:13.137]                               next
[16:19:13.137]                             if (!grepl(pattern, name)) 
[16:19:13.137]                               next
[16:19:13.137]                             invokeRestart(restart)
[16:19:13.137]                             muffled <- TRUE
[16:19:13.137]                             break
[16:19:13.137]                           }
[16:19:13.137]                         }
[16:19:13.137]                       }
[16:19:13.137]                       invisible(muffled)
[16:19:13.137]                     }
[16:19:13.137]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.137]                   }
[16:19:13.137]                 }
[16:19:13.137]             }
[16:19:13.137]         }))
[16:19:13.137]     }, error = function(ex) {
[16:19:13.137]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.137]                 ...future.rng), started = ...future.startTime, 
[16:19:13.137]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.137]             version = "1.8"), class = "FutureResult")
[16:19:13.137]     }, finally = {
[16:19:13.137]         if (!identical(...future.workdir, getwd())) 
[16:19:13.137]             setwd(...future.workdir)
[16:19:13.137]         {
[16:19:13.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.137]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.137]             }
[16:19:13.137]             base::options(...future.oldOptions)
[16:19:13.137]             if (.Platform$OS.type == "windows") {
[16:19:13.137]                 old_names <- names(...future.oldEnvVars)
[16:19:13.137]                 envs <- base::Sys.getenv()
[16:19:13.137]                 names <- names(envs)
[16:19:13.137]                 common <- intersect(names, old_names)
[16:19:13.137]                 added <- setdiff(names, old_names)
[16:19:13.137]                 removed <- setdiff(old_names, names)
[16:19:13.137]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.137]                   envs[common]]
[16:19:13.137]                 NAMES <- toupper(changed)
[16:19:13.137]                 args <- list()
[16:19:13.137]                 for (kk in seq_along(NAMES)) {
[16:19:13.137]                   name <- changed[[kk]]
[16:19:13.137]                   NAME <- NAMES[[kk]]
[16:19:13.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.137]                     next
[16:19:13.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.137]                 }
[16:19:13.137]                 NAMES <- toupper(added)
[16:19:13.137]                 for (kk in seq_along(NAMES)) {
[16:19:13.137]                   name <- added[[kk]]
[16:19:13.137]                   NAME <- NAMES[[kk]]
[16:19:13.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.137]                     next
[16:19:13.137]                   args[[name]] <- ""
[16:19:13.137]                 }
[16:19:13.137]                 NAMES <- toupper(removed)
[16:19:13.137]                 for (kk in seq_along(NAMES)) {
[16:19:13.137]                   name <- removed[[kk]]
[16:19:13.137]                   NAME <- NAMES[[kk]]
[16:19:13.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.137]                     next
[16:19:13.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.137]                 }
[16:19:13.137]                 if (length(args) > 0) 
[16:19:13.137]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.137]             }
[16:19:13.137]             else {
[16:19:13.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.137]             }
[16:19:13.137]             {
[16:19:13.137]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.137]                   0L) {
[16:19:13.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.137]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.137]                   base::options(opts)
[16:19:13.137]                 }
[16:19:13.137]                 {
[16:19:13.137]                   {
[16:19:13.137]                     NULL
[16:19:13.137]                     RNGkind("Mersenne-Twister")
[16:19:13.137]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:13.137]                       inherits = FALSE)
[16:19:13.137]                   }
[16:19:13.137]                   options(future.plan = NULL)
[16:19:13.137]                   if (is.na(NA_character_)) 
[16:19:13.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.137]                     .init = FALSE)
[16:19:13.137]                 }
[16:19:13.137]             }
[16:19:13.137]         }
[16:19:13.137]     })
[16:19:13.137]     if (TRUE) {
[16:19:13.137]         base::sink(type = "output", split = FALSE)
[16:19:13.137]         if (TRUE) {
[16:19:13.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.137]         }
[16:19:13.137]         else {
[16:19:13.137]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.137]         }
[16:19:13.137]         base::close(...future.stdout)
[16:19:13.137]         ...future.stdout <- NULL
[16:19:13.137]     }
[16:19:13.137]     ...future.result$conditions <- ...future.conditions
[16:19:13.137]     ...future.result$finished <- base::Sys.time()
[16:19:13.137]     ...future.result
[16:19:13.137] }
[16:19:13.139] assign_globals() ...
[16:19:13.139] List of 11
[16:19:13.139]  $ ...future.FUN            :function (x, ...)  
[16:19:13.139]  $ x_FUN                    :function (x)  
[16:19:13.139]  $ times                    : int 1
[16:19:13.139]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.139]  $ stop_if_not              :function (...)  
[16:19:13.139]  $ dim                      : NULL
[16:19:13.139]  $ valid_types              : chr "logical"
[16:19:13.139]  $ future.call.arguments    : list()
[16:19:13.139]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.139]  $ ...future.elements_ii    :List of 11
[16:19:13.139]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[16:19:13.139]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[16:19:13.139]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[16:19:13.139]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[16:19:13.139]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[16:19:13.139]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[16:19:13.139]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[16:19:13.139]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[16:19:13.139]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[16:19:13.139]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[16:19:13.139]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[16:19:13.139]  $ ...future.seeds_ii       : NULL
[16:19:13.139]  $ ...future.globals.maxSize: NULL
[16:19:13.139]  - attr(*, "where")=List of 11
[16:19:13.139]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.139]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.139]  - attr(*, "resolved")= logi FALSE
[16:19:13.139]  - attr(*, "total_size")= num 94200
[16:19:13.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.139]  - attr(*, "already-done")= logi TRUE
[16:19:13.151] - copied ‘...future.FUN’ to environment
[16:19:13.151] - copied ‘x_FUN’ to environment
[16:19:13.151] - copied ‘times’ to environment
[16:19:13.151] - copied ‘stopf’ to environment
[16:19:13.151] - copied ‘stop_if_not’ to environment
[16:19:13.152] - copied ‘dim’ to environment
[16:19:13.152] - copied ‘valid_types’ to environment
[16:19:13.152] - copied ‘future.call.arguments’ to environment
[16:19:13.152] - copied ‘...future.elements_ii’ to environment
[16:19:13.152] - copied ‘...future.seeds_ii’ to environment
[16:19:13.152] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.152] assign_globals() ... done
[16:19:13.153] plan(): Setting new future strategy stack:
[16:19:13.153] List of future strategies:
[16:19:13.153] 1. sequential:
[16:19:13.153]    - args: function (..., envir = parent.frame())
[16:19:13.153]    - tweaked: FALSE
[16:19:13.153]    - call: NULL
[16:19:13.153] plan(): nbrOfWorkers() = 1
[16:19:13.154] plan(): Setting new future strategy stack:
[16:19:13.154] List of future strategies:
[16:19:13.154] 1. sequential:
[16:19:13.154]    - args: function (..., envir = parent.frame())
[16:19:13.154]    - tweaked: FALSE
[16:19:13.154]    - call: plan(strategy)
[16:19:13.154] plan(): nbrOfWorkers() = 1
[16:19:13.154] SequentialFuture started (and completed)
[16:19:13.155] - Launch lazy future ... done
[16:19:13.155] run() for ‘SequentialFuture’ ... done
[16:19:13.155] Created future:
[16:19:13.155] SequentialFuture:
[16:19:13.155] Label: ‘future_vapply-1’
[16:19:13.155] Expression:
[16:19:13.155] {
[16:19:13.155]     do.call(function(...) {
[16:19:13.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.155]             on.exit(options(oopts), add = TRUE)
[16:19:13.155]         }
[16:19:13.155]         {
[16:19:13.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.155]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.155]             })
[16:19:13.155]         }
[16:19:13.155]     }, args = future.call.arguments)
[16:19:13.155] }
[16:19:13.155] Lazy evaluation: FALSE
[16:19:13.155] Asynchronous evaluation: FALSE
[16:19:13.155] Local evaluation: TRUE
[16:19:13.155] Environment: R_GlobalEnv
[16:19:13.155] Capture standard output: TRUE
[16:19:13.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.155] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.155] Packages: 1 packages (‘future.apply’)
[16:19:13.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.155] Resolved: TRUE
[16:19:13.155] Value: 616 bytes of class ‘list’
[16:19:13.155] Early signaling: FALSE
[16:19:13.155] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.155] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.156] Chunk #1 of 1 ... DONE
[16:19:13.156] Launching 1 futures (chunks) ... DONE
[16:19:13.156] Resolving 1 futures (chunks) ...
[16:19:13.156] resolve() on list ...
[16:19:13.156]  recursive: 0
[16:19:13.156]  length: 1
[16:19:13.157] 
[16:19:13.157] resolved() for ‘SequentialFuture’ ...
[16:19:13.157] - state: ‘finished’
[16:19:13.157] - run: TRUE
[16:19:13.157] - result: ‘FutureResult’
[16:19:13.157] resolved() for ‘SequentialFuture’ ... done
[16:19:13.157] Future #1
[16:19:13.157] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:13.157] - nx: 1
[16:19:13.157] - relay: TRUE
[16:19:13.158] - stdout: TRUE
[16:19:13.158] - signal: TRUE
[16:19:13.158] - resignal: FALSE
[16:19:13.158] - force: TRUE
[16:19:13.158] - relayed: [n=1] FALSE
[16:19:13.158] - queued futures: [n=1] FALSE
[16:19:13.158]  - until=1
[16:19:13.158]  - relaying element #1
[16:19:13.158] - relayed: [n=1] TRUE
[16:19:13.158] - queued futures: [n=1] TRUE
[16:19:13.158] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:13.159]  length: 0 (resolved future 1)
[16:19:13.159] Relaying remaining futures
[16:19:13.159] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.159] - nx: 1
[16:19:13.159] - relay: TRUE
[16:19:13.159] - stdout: TRUE
[16:19:13.159] - signal: TRUE
[16:19:13.159] - resignal: FALSE
[16:19:13.159] - force: TRUE
[16:19:13.159] - relayed: [n=1] TRUE
[16:19:13.159] - queued futures: [n=1] TRUE
 - flush all
[16:19:13.160] - relayed: [n=1] TRUE
[16:19:13.160] - queued futures: [n=1] TRUE
[16:19:13.160] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.160] resolve() on list ... DONE
[16:19:13.160]  - Number of value chunks collected: 1
[16:19:13.160] Resolving 1 futures (chunks) ... DONE
[16:19:13.160] Reducing values from 1 chunks ...
[16:19:13.160]  - Number of values collected after concatenation: 11
[16:19:13.160]  - Number of values expected: 11
[16:19:13.160] Reducing values from 1 chunks ... DONE
[16:19:13.160] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:19:13.161] future_lapply() ...
[16:19:13.163] Number of chunks: 1
[16:19:13.163] getGlobalsAndPackagesXApply() ...
[16:19:13.163]  - future.globals: TRUE
[16:19:13.163] getGlobalsAndPackages() ...
[16:19:13.163] Searching for globals...
[16:19:13.168] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:13.168] Searching for globals ... DONE
[16:19:13.168] Resolving globals: FALSE
[16:19:13.169] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:19:13.169] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.169] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.169] - packages: [1] ‘future.apply’
[16:19:13.170] getGlobalsAndPackages() ... DONE
[16:19:13.170]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.170]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.170] Finding globals ... DONE
[16:19:13.170]  - use_args: TRUE
[16:19:13.170]  - Getting '...' globals ...
[16:19:13.170] resolve() on list ...
[16:19:13.170]  recursive: 0
[16:19:13.170]  length: 1
[16:19:13.171]  elements: ‘...’
[16:19:13.171]  length: 0 (resolved future 1)
[16:19:13.171] resolve() on list ... DONE
[16:19:13.171]    - '...' content: [n=0] 
[16:19:13.171] List of 1
[16:19:13.171]  $ ...: list()
[16:19:13.171]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.171]  - attr(*, "where")=List of 1
[16:19:13.171]   ..$ ...:<environment: 0x56199f376ca0> 
[16:19:13.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.171]  - attr(*, "resolved")= logi TRUE
[16:19:13.171]  - attr(*, "total_size")= num NA
[16:19:13.173]  - Getting '...' globals ... DONE
[16:19:13.174] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.174] List of 8
[16:19:13.174]  $ ...future.FUN:function (x, ...)  
[16:19:13.174]  $ x_FUN        :function (x)  
[16:19:13.174]  $ times        : int 1
[16:19:13.174]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.174]  $ stop_if_not  :function (...)  
[16:19:13.174]  $ dim          : NULL
[16:19:13.174]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:13.174]  $ ...          : list()
[16:19:13.174]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.174]  - attr(*, "where")=List of 8
[16:19:13.174]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.174]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.174]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.174]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.174]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.174]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.174]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.174]   ..$ ...          :<environment: 0x56199f376ca0> 
[16:19:13.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.174]  - attr(*, "resolved")= logi FALSE
[16:19:13.174]  - attr(*, "total_size")= num 94264
[16:19:13.179] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.179] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.179] Number of futures (= number of chunks): 1
[16:19:13.179] Launching 1 futures (chunks) ...
[16:19:13.179] Chunk #1 of 1 ...
[16:19:13.179]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.179] getGlobalsAndPackages() ...
[16:19:13.179] Searching for globals...
[16:19:13.180] 
[16:19:13.180] Searching for globals ... DONE
[16:19:13.180] - globals: [0] <none>
[16:19:13.180] getGlobalsAndPackages() ... DONE
[16:19:13.180]    + additional globals found: [n=0] 
[16:19:13.180]    + additional namespaces needed: [n=0] 
[16:19:13.180]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.180]  - seeds: <none>
[16:19:13.180]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.181] getGlobalsAndPackages() ...
[16:19:13.181] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.181] Resolving globals: FALSE
[16:19:13.181] Tweak future expression to call with '...' arguments ...
[16:19:13.181] {
[16:19:13.181]     do.call(function(...) {
[16:19:13.181]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.181]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.181]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.181]             on.exit(options(oopts), add = TRUE)
[16:19:13.181]         }
[16:19:13.181]         {
[16:19:13.181]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.181]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.181]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.181]             })
[16:19:13.181]         }
[16:19:13.181]     }, args = future.call.arguments)
[16:19:13.181] }
[16:19:13.181] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.182] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.182] - packages: [1] ‘future.apply’
[16:19:13.182] getGlobalsAndPackages() ... DONE
[16:19:13.182] run() for ‘Future’ ...
[16:19:13.182] - state: ‘created’
[16:19:13.182] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:13.183] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.183] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:13.183]   - Field: ‘label’
[16:19:13.183]   - Field: ‘local’
[16:19:13.184]   - Field: ‘owner’
[16:19:13.185]   - Field: ‘envir’
[16:19:13.185]   - Field: ‘packages’
[16:19:13.185]   - Field: ‘gc’
[16:19:13.185]   - Field: ‘conditions’
[16:19:13.185]   - Field: ‘expr’
[16:19:13.185]   - Field: ‘uuid’
[16:19:13.185]   - Field: ‘seed’
[16:19:13.185]   - Field: ‘version’
[16:19:13.185]   - Field: ‘result’
[16:19:13.185]   - Field: ‘asynchronous’
[16:19:13.186]   - Field: ‘calls’
[16:19:13.186]   - Field: ‘globals’
[16:19:13.186]   - Field: ‘stdout’
[16:19:13.186]   - Field: ‘earlySignal’
[16:19:13.186]   - Field: ‘lazy’
[16:19:13.186]   - Field: ‘state’
[16:19:13.186] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:13.186] - Launch lazy future ...
[16:19:13.186] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.187] Packages needed by future strategies (n = 0): <none>
[16:19:13.187] {
[16:19:13.187]     {
[16:19:13.187]         {
[16:19:13.187]             ...future.startTime <- base::Sys.time()
[16:19:13.187]             {
[16:19:13.187]                 {
[16:19:13.187]                   {
[16:19:13.187]                     {
[16:19:13.187]                       base::local({
[16:19:13.187]                         has_future <- base::requireNamespace("future", 
[16:19:13.187]                           quietly = TRUE)
[16:19:13.187]                         if (has_future) {
[16:19:13.187]                           ns <- base::getNamespace("future")
[16:19:13.187]                           version <- ns[[".package"]][["version"]]
[16:19:13.187]                           if (is.null(version)) 
[16:19:13.187]                             version <- utils::packageVersion("future")
[16:19:13.187]                         }
[16:19:13.187]                         else {
[16:19:13.187]                           version <- NULL
[16:19:13.187]                         }
[16:19:13.187]                         if (!has_future || version < "1.8.0") {
[16:19:13.187]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.187]                             "", base::R.version$version.string), 
[16:19:13.187]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:13.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:13.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.187]                               "release", "version")], collapse = " "), 
[16:19:13.187]                             hostname = base::Sys.info()[["nodename"]])
[16:19:13.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.187]                             info)
[16:19:13.187]                           info <- base::paste(info, collapse = "; ")
[16:19:13.187]                           if (!has_future) {
[16:19:13.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.187]                               info)
[16:19:13.187]                           }
[16:19:13.187]                           else {
[16:19:13.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.187]                               info, version)
[16:19:13.187]                           }
[16:19:13.187]                           base::stop(msg)
[16:19:13.187]                         }
[16:19:13.187]                       })
[16:19:13.187]                     }
[16:19:13.187]                     base::local({
[16:19:13.187]                       for (pkg in "future.apply") {
[16:19:13.187]                         base::loadNamespace(pkg)
[16:19:13.187]                         base::library(pkg, character.only = TRUE)
[16:19:13.187]                       }
[16:19:13.187]                     })
[16:19:13.187]                   }
[16:19:13.187]                   ...future.strategy.old <- future::plan("list")
[16:19:13.187]                   options(future.plan = NULL)
[16:19:13.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.187]                 }
[16:19:13.187]                 ...future.workdir <- getwd()
[16:19:13.187]             }
[16:19:13.187]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.187]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.187]         }
[16:19:13.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:13.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.187]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.187]             base::names(...future.oldOptions))
[16:19:13.187]     }
[16:19:13.187]     if (FALSE) {
[16:19:13.187]     }
[16:19:13.187]     else {
[16:19:13.187]         if (TRUE) {
[16:19:13.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.187]                 open = "w")
[16:19:13.187]         }
[16:19:13.187]         else {
[16:19:13.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.187]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.187]         }
[16:19:13.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.187]             base::sink(type = "output", split = FALSE)
[16:19:13.187]             base::close(...future.stdout)
[16:19:13.187]         }, add = TRUE)
[16:19:13.187]     }
[16:19:13.187]     ...future.frame <- base::sys.nframe()
[16:19:13.187]     ...future.conditions <- base::list()
[16:19:13.187]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.187]     if (FALSE) {
[16:19:13.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.187]     }
[16:19:13.187]     ...future.result <- base::tryCatch({
[16:19:13.187]         base::withCallingHandlers({
[16:19:13.187]             ...future.value <- base::withVisible(base::local({
[16:19:13.187]                 do.call(function(...) {
[16:19:13.187]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.187]                   if (!identical(...future.globals.maxSize.org, 
[16:19:13.187]                     ...future.globals.maxSize)) {
[16:19:13.187]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.187]                     on.exit(options(oopts), add = TRUE)
[16:19:13.187]                   }
[16:19:13.187]                   {
[16:19:13.187]                     lapply(seq_along(...future.elements_ii), 
[16:19:13.187]                       FUN = function(jj) {
[16:19:13.187]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.187]                         ...future.FUN(...future.X_jj, ...)
[16:19:13.187]                       })
[16:19:13.187]                   }
[16:19:13.187]                 }, args = future.call.arguments)
[16:19:13.187]             }))
[16:19:13.187]             future::FutureResult(value = ...future.value$value, 
[16:19:13.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.187]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.187]                     ...future.globalenv.names))
[16:19:13.187]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.187]         }, condition = base::local({
[16:19:13.187]             c <- base::c
[16:19:13.187]             inherits <- base::inherits
[16:19:13.187]             invokeRestart <- base::invokeRestart
[16:19:13.187]             length <- base::length
[16:19:13.187]             list <- base::list
[16:19:13.187]             seq.int <- base::seq.int
[16:19:13.187]             signalCondition <- base::signalCondition
[16:19:13.187]             sys.calls <- base::sys.calls
[16:19:13.187]             `[[` <- base::`[[`
[16:19:13.187]             `+` <- base::`+`
[16:19:13.187]             `<<-` <- base::`<<-`
[16:19:13.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.187]                   3L)]
[16:19:13.187]             }
[16:19:13.187]             function(cond) {
[16:19:13.187]                 is_error <- inherits(cond, "error")
[16:19:13.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.187]                   NULL)
[16:19:13.187]                 if (is_error) {
[16:19:13.187]                   sessionInformation <- function() {
[16:19:13.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.187]                       search = base::search(), system = base::Sys.info())
[16:19:13.187]                   }
[16:19:13.187]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.187]                     cond$call), session = sessionInformation(), 
[16:19:13.187]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.187]                   signalCondition(cond)
[16:19:13.187]                 }
[16:19:13.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.187]                 "immediateCondition"))) {
[16:19:13.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.187]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.187]                   if (TRUE && !signal) {
[16:19:13.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.187]                     {
[16:19:13.187]                       inherits <- base::inherits
[16:19:13.187]                       invokeRestart <- base::invokeRestart
[16:19:13.187]                       is.null <- base::is.null
[16:19:13.187]                       muffled <- FALSE
[16:19:13.187]                       if (inherits(cond, "message")) {
[16:19:13.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.187]                         if (muffled) 
[16:19:13.187]                           invokeRestart("muffleMessage")
[16:19:13.187]                       }
[16:19:13.187]                       else if (inherits(cond, "warning")) {
[16:19:13.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.187]                         if (muffled) 
[16:19:13.187]                           invokeRestart("muffleWarning")
[16:19:13.187]                       }
[16:19:13.187]                       else if (inherits(cond, "condition")) {
[16:19:13.187]                         if (!is.null(pattern)) {
[16:19:13.187]                           computeRestarts <- base::computeRestarts
[16:19:13.187]                           grepl <- base::grepl
[16:19:13.187]                           restarts <- computeRestarts(cond)
[16:19:13.187]                           for (restart in restarts) {
[16:19:13.187]                             name <- restart$name
[16:19:13.187]                             if (is.null(name)) 
[16:19:13.187]                               next
[16:19:13.187]                             if (!grepl(pattern, name)) 
[16:19:13.187]                               next
[16:19:13.187]                             invokeRestart(restart)
[16:19:13.187]                             muffled <- TRUE
[16:19:13.187]                             break
[16:19:13.187]                           }
[16:19:13.187]                         }
[16:19:13.187]                       }
[16:19:13.187]                       invisible(muffled)
[16:19:13.187]                     }
[16:19:13.187]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.187]                   }
[16:19:13.187]                 }
[16:19:13.187]                 else {
[16:19:13.187]                   if (TRUE) {
[16:19:13.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.187]                     {
[16:19:13.187]                       inherits <- base::inherits
[16:19:13.187]                       invokeRestart <- base::invokeRestart
[16:19:13.187]                       is.null <- base::is.null
[16:19:13.187]                       muffled <- FALSE
[16:19:13.187]                       if (inherits(cond, "message")) {
[16:19:13.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.187]                         if (muffled) 
[16:19:13.187]                           invokeRestart("muffleMessage")
[16:19:13.187]                       }
[16:19:13.187]                       else if (inherits(cond, "warning")) {
[16:19:13.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.187]                         if (muffled) 
[16:19:13.187]                           invokeRestart("muffleWarning")
[16:19:13.187]                       }
[16:19:13.187]                       else if (inherits(cond, "condition")) {
[16:19:13.187]                         if (!is.null(pattern)) {
[16:19:13.187]                           computeRestarts <- base::computeRestarts
[16:19:13.187]                           grepl <- base::grepl
[16:19:13.187]                           restarts <- computeRestarts(cond)
[16:19:13.187]                           for (restart in restarts) {
[16:19:13.187]                             name <- restart$name
[16:19:13.187]                             if (is.null(name)) 
[16:19:13.187]                               next
[16:19:13.187]                             if (!grepl(pattern, name)) 
[16:19:13.187]                               next
[16:19:13.187]                             invokeRestart(restart)
[16:19:13.187]                             muffled <- TRUE
[16:19:13.187]                             break
[16:19:13.187]                           }
[16:19:13.187]                         }
[16:19:13.187]                       }
[16:19:13.187]                       invisible(muffled)
[16:19:13.187]                     }
[16:19:13.187]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.187]                   }
[16:19:13.187]                 }
[16:19:13.187]             }
[16:19:13.187]         }))
[16:19:13.187]     }, error = function(ex) {
[16:19:13.187]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.187]                 ...future.rng), started = ...future.startTime, 
[16:19:13.187]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.187]             version = "1.8"), class = "FutureResult")
[16:19:13.187]     }, finally = {
[16:19:13.187]         if (!identical(...future.workdir, getwd())) 
[16:19:13.187]             setwd(...future.workdir)
[16:19:13.187]         {
[16:19:13.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.187]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.187]             }
[16:19:13.187]             base::options(...future.oldOptions)
[16:19:13.187]             if (.Platform$OS.type == "windows") {
[16:19:13.187]                 old_names <- names(...future.oldEnvVars)
[16:19:13.187]                 envs <- base::Sys.getenv()
[16:19:13.187]                 names <- names(envs)
[16:19:13.187]                 common <- intersect(names, old_names)
[16:19:13.187]                 added <- setdiff(names, old_names)
[16:19:13.187]                 removed <- setdiff(old_names, names)
[16:19:13.187]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.187]                   envs[common]]
[16:19:13.187]                 NAMES <- toupper(changed)
[16:19:13.187]                 args <- list()
[16:19:13.187]                 for (kk in seq_along(NAMES)) {
[16:19:13.187]                   name <- changed[[kk]]
[16:19:13.187]                   NAME <- NAMES[[kk]]
[16:19:13.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.187]                     next
[16:19:13.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.187]                 }
[16:19:13.187]                 NAMES <- toupper(added)
[16:19:13.187]                 for (kk in seq_along(NAMES)) {
[16:19:13.187]                   name <- added[[kk]]
[16:19:13.187]                   NAME <- NAMES[[kk]]
[16:19:13.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.187]                     next
[16:19:13.187]                   args[[name]] <- ""
[16:19:13.187]                 }
[16:19:13.187]                 NAMES <- toupper(removed)
[16:19:13.187]                 for (kk in seq_along(NAMES)) {
[16:19:13.187]                   name <- removed[[kk]]
[16:19:13.187]                   NAME <- NAMES[[kk]]
[16:19:13.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.187]                     next
[16:19:13.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.187]                 }
[16:19:13.187]                 if (length(args) > 0) 
[16:19:13.187]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.187]             }
[16:19:13.187]             else {
[16:19:13.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.187]             }
[16:19:13.187]             {
[16:19:13.187]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.187]                   0L) {
[16:19:13.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.187]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.187]                   base::options(opts)
[16:19:13.187]                 }
[16:19:13.187]                 {
[16:19:13.187]                   {
[16:19:13.187]                     NULL
[16:19:13.187]                     RNGkind("Mersenne-Twister")
[16:19:13.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:13.187]                       inherits = FALSE)
[16:19:13.187]                   }
[16:19:13.187]                   options(future.plan = NULL)
[16:19:13.187]                   if (is.na(NA_character_)) 
[16:19:13.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.187]                     .init = FALSE)
[16:19:13.187]                 }
[16:19:13.187]             }
[16:19:13.187]         }
[16:19:13.187]     })
[16:19:13.187]     if (TRUE) {
[16:19:13.187]         base::sink(type = "output", split = FALSE)
[16:19:13.187]         if (TRUE) {
[16:19:13.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.187]         }
[16:19:13.187]         else {
[16:19:13.187]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.187]         }
[16:19:13.187]         base::close(...future.stdout)
[16:19:13.187]         ...future.stdout <- NULL
[16:19:13.187]     }
[16:19:13.187]     ...future.result$conditions <- ...future.conditions
[16:19:13.187]     ...future.result$finished <- base::Sys.time()
[16:19:13.187]     ...future.result
[16:19:13.187] }
[16:19:13.189] assign_globals() ...
[16:19:13.189] List of 11
[16:19:13.189]  $ ...future.FUN            :function (x, ...)  
[16:19:13.189]  $ x_FUN                    :function (x)  
[16:19:13.189]  $ times                    : int 1
[16:19:13.189]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.189]  $ stop_if_not              :function (...)  
[16:19:13.189]  $ dim                      : NULL
[16:19:13.189]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:13.189]  $ future.call.arguments    : list()
[16:19:13.189]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.189]  $ ...future.elements_ii    :List of 3
[16:19:13.189]   ..$ a: num 1
[16:19:13.189]   ..$ b: num 2
[16:19:13.189]   ..$ c: num 3
[16:19:13.189]  $ ...future.seeds_ii       : NULL
[16:19:13.189]  $ ...future.globals.maxSize: NULL
[16:19:13.189]  - attr(*, "where")=List of 11
[16:19:13.189]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.189]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.189]  - attr(*, "resolved")= logi FALSE
[16:19:13.189]  - attr(*, "total_size")= num 94264
[16:19:13.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.189]  - attr(*, "already-done")= logi TRUE
[16:19:13.196] - copied ‘...future.FUN’ to environment
[16:19:13.196] - copied ‘x_FUN’ to environment
[16:19:13.197] - copied ‘times’ to environment
[16:19:13.197] - copied ‘stopf’ to environment
[16:19:13.197] - copied ‘stop_if_not’ to environment
[16:19:13.197] - copied ‘dim’ to environment
[16:19:13.197] - copied ‘valid_types’ to environment
[16:19:13.197] - copied ‘future.call.arguments’ to environment
[16:19:13.197] - copied ‘...future.elements_ii’ to environment
[16:19:13.197] - copied ‘...future.seeds_ii’ to environment
[16:19:13.197] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.197] assign_globals() ... done
[16:19:13.198] plan(): Setting new future strategy stack:
[16:19:13.198] List of future strategies:
[16:19:13.198] 1. sequential:
[16:19:13.198]    - args: function (..., envir = parent.frame())
[16:19:13.198]    - tweaked: FALSE
[16:19:13.198]    - call: NULL
[16:19:13.198] plan(): nbrOfWorkers() = 1
[16:19:13.199] plan(): Setting new future strategy stack:
[16:19:13.199] List of future strategies:
[16:19:13.199] 1. sequential:
[16:19:13.199]    - args: function (..., envir = parent.frame())
[16:19:13.199]    - tweaked: FALSE
[16:19:13.199]    - call: plan(strategy)
[16:19:13.199] plan(): nbrOfWorkers() = 1
[16:19:13.200] SequentialFuture started (and completed)
[16:19:13.200] - Launch lazy future ... done
[16:19:13.200] run() for ‘SequentialFuture’ ... done
[16:19:13.200] Created future:
[16:19:13.200] SequentialFuture:
[16:19:13.200] Label: ‘future_vapply-1’
[16:19:13.200] Expression:
[16:19:13.200] {
[16:19:13.200]     do.call(function(...) {
[16:19:13.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.200]             on.exit(options(oopts), add = TRUE)
[16:19:13.200]         }
[16:19:13.200]         {
[16:19:13.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.200]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.200]             })
[16:19:13.200]         }
[16:19:13.200]     }, args = future.call.arguments)
[16:19:13.200] }
[16:19:13.200] Lazy evaluation: FALSE
[16:19:13.200] Asynchronous evaluation: FALSE
[16:19:13.200] Local evaluation: TRUE
[16:19:13.200] Environment: R_GlobalEnv
[16:19:13.200] Capture standard output: TRUE
[16:19:13.200] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.200] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.200] Packages: 1 packages (‘future.apply’)
[16:19:13.200] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.200] Resolved: TRUE
[16:19:13.200] Value: 168 bytes of class ‘list’
[16:19:13.200] Early signaling: FALSE
[16:19:13.200] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.200] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.201] Chunk #1 of 1 ... DONE
[16:19:13.201] Launching 1 futures (chunks) ... DONE
[16:19:13.201] Resolving 1 futures (chunks) ...
[16:19:13.201] resolve() on list ...
[16:19:13.201]  recursive: 0
[16:19:13.202]  length: 1
[16:19:13.202] 
[16:19:13.202] resolved() for ‘SequentialFuture’ ...
[16:19:13.202] - state: ‘finished’
[16:19:13.202] - run: TRUE
[16:19:13.202] - result: ‘FutureResult’
[16:19:13.202] resolved() for ‘SequentialFuture’ ... done
[16:19:13.202] Future #1
[16:19:13.202] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:13.202] - nx: 1
[16:19:13.203] - relay: TRUE
[16:19:13.203] - stdout: TRUE
[16:19:13.203] - signal: TRUE
[16:19:13.203] - resignal: FALSE
[16:19:13.203] - force: TRUE
[16:19:13.203] - relayed: [n=1] FALSE
[16:19:13.203] - queued futures: [n=1] FALSE
[16:19:13.203]  - until=1
[16:19:13.203]  - relaying element #1
[16:19:13.203] - relayed: [n=1] TRUE
[16:19:13.203] - queued futures: [n=1] TRUE
[16:19:13.204] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:13.204]  length: 0 (resolved future 1)
[16:19:13.204] Relaying remaining futures
[16:19:13.204] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.204] - nx: 1
[16:19:13.204] - relay: TRUE
[16:19:13.204] - stdout: TRUE
[16:19:13.204] - signal: TRUE
[16:19:13.206] - resignal: FALSE
[16:19:13.206] - force: TRUE
[16:19:13.206] - relayed: [n=1] TRUE
[16:19:13.206] - queued futures: [n=1] TRUE
 - flush all
[16:19:13.206] - relayed: [n=1] TRUE
[16:19:13.206] - queued futures: [n=1] TRUE
[16:19:13.206] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.206] resolve() on list ... DONE
[16:19:13.206]  - Number of value chunks collected: 1
[16:19:13.207] Resolving 1 futures (chunks) ... DONE
[16:19:13.207] Reducing values from 1 chunks ...
[16:19:13.207]  - Number of values collected after concatenation: 3
[16:19:13.207]  - Number of values expected: 3
[16:19:13.207] Reducing values from 1 chunks ... DONE
[16:19:13.207] future_lapply() ... DONE
- exceptions ...
[16:19:13.207] future_lapply() ...
[16:19:13.209] Number of chunks: 1
[16:19:13.209] getGlobalsAndPackagesXApply() ...
[16:19:13.209]  - future.globals: TRUE
[16:19:13.209] getGlobalsAndPackages() ...
[16:19:13.209] Searching for globals...
[16:19:13.213] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:13.213] Searching for globals ... DONE
[16:19:13.213] Resolving globals: FALSE
[16:19:13.214] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:19:13.214] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.214] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.214] - packages: [1] ‘future.apply’
[16:19:13.214] getGlobalsAndPackages() ... DONE
[16:19:13.214]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.215]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.215] Finding globals ... DONE
[16:19:13.215]  - use_args: TRUE
[16:19:13.215]  - Getting '...' globals ...
[16:19:13.215] resolve() on list ...
[16:19:13.215]  recursive: 0
[16:19:13.215]  length: 1
[16:19:13.215]  elements: ‘...’
[16:19:13.215]  length: 0 (resolved future 1)
[16:19:13.216] resolve() on list ... DONE
[16:19:13.216]    - '...' content: [n=0] 
[16:19:13.216] List of 1
[16:19:13.216]  $ ...: list()
[16:19:13.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.216]  - attr(*, "where")=List of 1
[16:19:13.216]   ..$ ...:<environment: 0x56199d998a78> 
[16:19:13.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.216]  - attr(*, "resolved")= logi TRUE
[16:19:13.216]  - attr(*, "total_size")= num NA
[16:19:13.218]  - Getting '...' globals ... DONE
[16:19:13.218] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.218] List of 8
[16:19:13.218]  $ ...future.FUN:function (x, ...)  
[16:19:13.218]  $ x_FUN        :function (x)  
[16:19:13.218]  $ times        : int 2
[16:19:13.218]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.218]  $ stop_if_not  :function (...)  
[16:19:13.218]  $ dim          : NULL
[16:19:13.218]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:13.218]  $ ...          : list()
[16:19:13.218]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.218]  - attr(*, "where")=List of 8
[16:19:13.218]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.218]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.218]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.218]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.218]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.218]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.218]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.218]   ..$ ...          :<environment: 0x56199d998a78> 
[16:19:13.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.218]  - attr(*, "resolved")= logi FALSE
[16:19:13.218]  - attr(*, "total_size")= num 95128
[16:19:13.225] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.225] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.225] Number of futures (= number of chunks): 1
[16:19:13.225] Launching 1 futures (chunks) ...
[16:19:13.225] Chunk #1 of 1 ...
[16:19:13.225]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.225] getGlobalsAndPackages() ...
[16:19:13.226] Searching for globals...
[16:19:13.226] 
[16:19:13.226] Searching for globals ... DONE
[16:19:13.226] - globals: [0] <none>
[16:19:13.226] getGlobalsAndPackages() ... DONE
[16:19:13.226]    + additional globals found: [n=0] 
[16:19:13.226]    + additional namespaces needed: [n=0] 
[16:19:13.226]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.226]  - seeds: <none>
[16:19:13.226]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.227] getGlobalsAndPackages() ...
[16:19:13.227] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.227] Resolving globals: FALSE
[16:19:13.227] Tweak future expression to call with '...' arguments ...
[16:19:13.227] {
[16:19:13.227]     do.call(function(...) {
[16:19:13.227]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.227]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.227]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.227]             on.exit(options(oopts), add = TRUE)
[16:19:13.227]         }
[16:19:13.227]         {
[16:19:13.227]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.227]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.227]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.227]             })
[16:19:13.227]         }
[16:19:13.227]     }, args = future.call.arguments)
[16:19:13.227] }
[16:19:13.227] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.228] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.228] - packages: [1] ‘future.apply’
[16:19:13.228] getGlobalsAndPackages() ... DONE
[16:19:13.228] run() for ‘Future’ ...
[16:19:13.228] - state: ‘created’
[16:19:13.229] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:13.229] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:13.229]   - Field: ‘label’
[16:19:13.229]   - Field: ‘local’
[16:19:13.229]   - Field: ‘owner’
[16:19:13.229]   - Field: ‘envir’
[16:19:13.229]   - Field: ‘packages’
[16:19:13.229]   - Field: ‘gc’
[16:19:13.230]   - Field: ‘conditions’
[16:19:13.230]   - Field: ‘expr’
[16:19:13.230]   - Field: ‘uuid’
[16:19:13.230]   - Field: ‘seed’
[16:19:13.230]   - Field: ‘version’
[16:19:13.230]   - Field: ‘result’
[16:19:13.230]   - Field: ‘asynchronous’
[16:19:13.230]   - Field: ‘calls’
[16:19:13.230]   - Field: ‘globals’
[16:19:13.230]   - Field: ‘stdout’
[16:19:13.230]   - Field: ‘earlySignal’
[16:19:13.231]   - Field: ‘lazy’
[16:19:13.231]   - Field: ‘state’
[16:19:13.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:13.231] - Launch lazy future ...
[16:19:13.231] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.231] Packages needed by future strategies (n = 0): <none>
[16:19:13.232] {
[16:19:13.232]     {
[16:19:13.232]         {
[16:19:13.232]             ...future.startTime <- base::Sys.time()
[16:19:13.232]             {
[16:19:13.232]                 {
[16:19:13.232]                   {
[16:19:13.232]                     {
[16:19:13.232]                       base::local({
[16:19:13.232]                         has_future <- base::requireNamespace("future", 
[16:19:13.232]                           quietly = TRUE)
[16:19:13.232]                         if (has_future) {
[16:19:13.232]                           ns <- base::getNamespace("future")
[16:19:13.232]                           version <- ns[[".package"]][["version"]]
[16:19:13.232]                           if (is.null(version)) 
[16:19:13.232]                             version <- utils::packageVersion("future")
[16:19:13.232]                         }
[16:19:13.232]                         else {
[16:19:13.232]                           version <- NULL
[16:19:13.232]                         }
[16:19:13.232]                         if (!has_future || version < "1.8.0") {
[16:19:13.232]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.232]                             "", base::R.version$version.string), 
[16:19:13.232]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:13.232]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:13.232]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.232]                               "release", "version")], collapse = " "), 
[16:19:13.232]                             hostname = base::Sys.info()[["nodename"]])
[16:19:13.232]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.232]                             info)
[16:19:13.232]                           info <- base::paste(info, collapse = "; ")
[16:19:13.232]                           if (!has_future) {
[16:19:13.232]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.232]                               info)
[16:19:13.232]                           }
[16:19:13.232]                           else {
[16:19:13.232]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.232]                               info, version)
[16:19:13.232]                           }
[16:19:13.232]                           base::stop(msg)
[16:19:13.232]                         }
[16:19:13.232]                       })
[16:19:13.232]                     }
[16:19:13.232]                     base::local({
[16:19:13.232]                       for (pkg in "future.apply") {
[16:19:13.232]                         base::loadNamespace(pkg)
[16:19:13.232]                         base::library(pkg, character.only = TRUE)
[16:19:13.232]                       }
[16:19:13.232]                     })
[16:19:13.232]                   }
[16:19:13.232]                   ...future.strategy.old <- future::plan("list")
[16:19:13.232]                   options(future.plan = NULL)
[16:19:13.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.232]                 }
[16:19:13.232]                 ...future.workdir <- getwd()
[16:19:13.232]             }
[16:19:13.232]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.232]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.232]         }
[16:19:13.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:13.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.232]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.232]             base::names(...future.oldOptions))
[16:19:13.232]     }
[16:19:13.232]     if (FALSE) {
[16:19:13.232]     }
[16:19:13.232]     else {
[16:19:13.232]         if (TRUE) {
[16:19:13.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.232]                 open = "w")
[16:19:13.232]         }
[16:19:13.232]         else {
[16:19:13.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.232]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.232]         }
[16:19:13.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.232]             base::sink(type = "output", split = FALSE)
[16:19:13.232]             base::close(...future.stdout)
[16:19:13.232]         }, add = TRUE)
[16:19:13.232]     }
[16:19:13.232]     ...future.frame <- base::sys.nframe()
[16:19:13.232]     ...future.conditions <- base::list()
[16:19:13.232]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.232]     if (FALSE) {
[16:19:13.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.232]     }
[16:19:13.232]     ...future.result <- base::tryCatch({
[16:19:13.232]         base::withCallingHandlers({
[16:19:13.232]             ...future.value <- base::withVisible(base::local({
[16:19:13.232]                 do.call(function(...) {
[16:19:13.232]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.232]                   if (!identical(...future.globals.maxSize.org, 
[16:19:13.232]                     ...future.globals.maxSize)) {
[16:19:13.232]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.232]                     on.exit(options(oopts), add = TRUE)
[16:19:13.232]                   }
[16:19:13.232]                   {
[16:19:13.232]                     lapply(seq_along(...future.elements_ii), 
[16:19:13.232]                       FUN = function(jj) {
[16:19:13.232]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.232]                         ...future.FUN(...future.X_jj, ...)
[16:19:13.232]                       })
[16:19:13.232]                   }
[16:19:13.232]                 }, args = future.call.arguments)
[16:19:13.232]             }))
[16:19:13.232]             future::FutureResult(value = ...future.value$value, 
[16:19:13.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.232]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.232]                     ...future.globalenv.names))
[16:19:13.232]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.232]         }, condition = base::local({
[16:19:13.232]             c <- base::c
[16:19:13.232]             inherits <- base::inherits
[16:19:13.232]             invokeRestart <- base::invokeRestart
[16:19:13.232]             length <- base::length
[16:19:13.232]             list <- base::list
[16:19:13.232]             seq.int <- base::seq.int
[16:19:13.232]             signalCondition <- base::signalCondition
[16:19:13.232]             sys.calls <- base::sys.calls
[16:19:13.232]             `[[` <- base::`[[`
[16:19:13.232]             `+` <- base::`+`
[16:19:13.232]             `<<-` <- base::`<<-`
[16:19:13.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.232]                   3L)]
[16:19:13.232]             }
[16:19:13.232]             function(cond) {
[16:19:13.232]                 is_error <- inherits(cond, "error")
[16:19:13.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.232]                   NULL)
[16:19:13.232]                 if (is_error) {
[16:19:13.232]                   sessionInformation <- function() {
[16:19:13.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.232]                       search = base::search(), system = base::Sys.info())
[16:19:13.232]                   }
[16:19:13.232]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.232]                     cond$call), session = sessionInformation(), 
[16:19:13.232]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.232]                   signalCondition(cond)
[16:19:13.232]                 }
[16:19:13.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.232]                 "immediateCondition"))) {
[16:19:13.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.232]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.232]                   if (TRUE && !signal) {
[16:19:13.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.232]                     {
[16:19:13.232]                       inherits <- base::inherits
[16:19:13.232]                       invokeRestart <- base::invokeRestart
[16:19:13.232]                       is.null <- base::is.null
[16:19:13.232]                       muffled <- FALSE
[16:19:13.232]                       if (inherits(cond, "message")) {
[16:19:13.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.232]                         if (muffled) 
[16:19:13.232]                           invokeRestart("muffleMessage")
[16:19:13.232]                       }
[16:19:13.232]                       else if (inherits(cond, "warning")) {
[16:19:13.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.232]                         if (muffled) 
[16:19:13.232]                           invokeRestart("muffleWarning")
[16:19:13.232]                       }
[16:19:13.232]                       else if (inherits(cond, "condition")) {
[16:19:13.232]                         if (!is.null(pattern)) {
[16:19:13.232]                           computeRestarts <- base::computeRestarts
[16:19:13.232]                           grepl <- base::grepl
[16:19:13.232]                           restarts <- computeRestarts(cond)
[16:19:13.232]                           for (restart in restarts) {
[16:19:13.232]                             name <- restart$name
[16:19:13.232]                             if (is.null(name)) 
[16:19:13.232]                               next
[16:19:13.232]                             if (!grepl(pattern, name)) 
[16:19:13.232]                               next
[16:19:13.232]                             invokeRestart(restart)
[16:19:13.232]                             muffled <- TRUE
[16:19:13.232]                             break
[16:19:13.232]                           }
[16:19:13.232]                         }
[16:19:13.232]                       }
[16:19:13.232]                       invisible(muffled)
[16:19:13.232]                     }
[16:19:13.232]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.232]                   }
[16:19:13.232]                 }
[16:19:13.232]                 else {
[16:19:13.232]                   if (TRUE) {
[16:19:13.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.232]                     {
[16:19:13.232]                       inherits <- base::inherits
[16:19:13.232]                       invokeRestart <- base::invokeRestart
[16:19:13.232]                       is.null <- base::is.null
[16:19:13.232]                       muffled <- FALSE
[16:19:13.232]                       if (inherits(cond, "message")) {
[16:19:13.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.232]                         if (muffled) 
[16:19:13.232]                           invokeRestart("muffleMessage")
[16:19:13.232]                       }
[16:19:13.232]                       else if (inherits(cond, "warning")) {
[16:19:13.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.232]                         if (muffled) 
[16:19:13.232]                           invokeRestart("muffleWarning")
[16:19:13.232]                       }
[16:19:13.232]                       else if (inherits(cond, "condition")) {
[16:19:13.232]                         if (!is.null(pattern)) {
[16:19:13.232]                           computeRestarts <- base::computeRestarts
[16:19:13.232]                           grepl <- base::grepl
[16:19:13.232]                           restarts <- computeRestarts(cond)
[16:19:13.232]                           for (restart in restarts) {
[16:19:13.232]                             name <- restart$name
[16:19:13.232]                             if (is.null(name)) 
[16:19:13.232]                               next
[16:19:13.232]                             if (!grepl(pattern, name)) 
[16:19:13.232]                               next
[16:19:13.232]                             invokeRestart(restart)
[16:19:13.232]                             muffled <- TRUE
[16:19:13.232]                             break
[16:19:13.232]                           }
[16:19:13.232]                         }
[16:19:13.232]                       }
[16:19:13.232]                       invisible(muffled)
[16:19:13.232]                     }
[16:19:13.232]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.232]                   }
[16:19:13.232]                 }
[16:19:13.232]             }
[16:19:13.232]         }))
[16:19:13.232]     }, error = function(ex) {
[16:19:13.232]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.232]                 ...future.rng), started = ...future.startTime, 
[16:19:13.232]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.232]             version = "1.8"), class = "FutureResult")
[16:19:13.232]     }, finally = {
[16:19:13.232]         if (!identical(...future.workdir, getwd())) 
[16:19:13.232]             setwd(...future.workdir)
[16:19:13.232]         {
[16:19:13.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.232]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.232]             }
[16:19:13.232]             base::options(...future.oldOptions)
[16:19:13.232]             if (.Platform$OS.type == "windows") {
[16:19:13.232]                 old_names <- names(...future.oldEnvVars)
[16:19:13.232]                 envs <- base::Sys.getenv()
[16:19:13.232]                 names <- names(envs)
[16:19:13.232]                 common <- intersect(names, old_names)
[16:19:13.232]                 added <- setdiff(names, old_names)
[16:19:13.232]                 removed <- setdiff(old_names, names)
[16:19:13.232]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.232]                   envs[common]]
[16:19:13.232]                 NAMES <- toupper(changed)
[16:19:13.232]                 args <- list()
[16:19:13.232]                 for (kk in seq_along(NAMES)) {
[16:19:13.232]                   name <- changed[[kk]]
[16:19:13.232]                   NAME <- NAMES[[kk]]
[16:19:13.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.232]                     next
[16:19:13.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.232]                 }
[16:19:13.232]                 NAMES <- toupper(added)
[16:19:13.232]                 for (kk in seq_along(NAMES)) {
[16:19:13.232]                   name <- added[[kk]]
[16:19:13.232]                   NAME <- NAMES[[kk]]
[16:19:13.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.232]                     next
[16:19:13.232]                   args[[name]] <- ""
[16:19:13.232]                 }
[16:19:13.232]                 NAMES <- toupper(removed)
[16:19:13.232]                 for (kk in seq_along(NAMES)) {
[16:19:13.232]                   name <- removed[[kk]]
[16:19:13.232]                   NAME <- NAMES[[kk]]
[16:19:13.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.232]                     next
[16:19:13.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.232]                 }
[16:19:13.232]                 if (length(args) > 0) 
[16:19:13.232]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.232]             }
[16:19:13.232]             else {
[16:19:13.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.232]             }
[16:19:13.232]             {
[16:19:13.232]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.232]                   0L) {
[16:19:13.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.232]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.232]                   base::options(opts)
[16:19:13.232]                 }
[16:19:13.232]                 {
[16:19:13.232]                   {
[16:19:13.232]                     NULL
[16:19:13.232]                     RNGkind("Mersenne-Twister")
[16:19:13.232]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:13.232]                       inherits = FALSE)
[16:19:13.232]                   }
[16:19:13.232]                   options(future.plan = NULL)
[16:19:13.232]                   if (is.na(NA_character_)) 
[16:19:13.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.232]                     .init = FALSE)
[16:19:13.232]                 }
[16:19:13.232]             }
[16:19:13.232]         }
[16:19:13.232]     })
[16:19:13.232]     if (TRUE) {
[16:19:13.232]         base::sink(type = "output", split = FALSE)
[16:19:13.232]         if (TRUE) {
[16:19:13.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.232]         }
[16:19:13.232]         else {
[16:19:13.232]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.232]         }
[16:19:13.232]         base::close(...future.stdout)
[16:19:13.232]         ...future.stdout <- NULL
[16:19:13.232]     }
[16:19:13.232]     ...future.result$conditions <- ...future.conditions
[16:19:13.232]     ...future.result$finished <- base::Sys.time()
[16:19:13.232]     ...future.result
[16:19:13.232] }
[16:19:13.233] assign_globals() ...
[16:19:13.233] List of 11
[16:19:13.233]  $ ...future.FUN            :function (x, ...)  
[16:19:13.233]  $ x_FUN                    :function (x)  
[16:19:13.233]  $ times                    : int 2
[16:19:13.233]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.233]  $ stop_if_not              :function (...)  
[16:19:13.233]  $ dim                      : NULL
[16:19:13.233]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.233]  $ future.call.arguments    : list()
[16:19:13.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.233]  $ ...future.elements_ii    :List of 3
[16:19:13.233]   ..$ : int 1
[16:19:13.233]   ..$ : int 2
[16:19:13.233]   ..$ : int 3
[16:19:13.233]  $ ...future.seeds_ii       : NULL
[16:19:13.233]  $ ...future.globals.maxSize: NULL
[16:19:13.233]  - attr(*, "where")=List of 11
[16:19:13.233]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.233]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.233]  - attr(*, "resolved")= logi FALSE
[16:19:13.233]  - attr(*, "total_size")= num 95128
[16:19:13.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.233]  - attr(*, "already-done")= logi TRUE
[16:19:13.241] - copied ‘...future.FUN’ to environment
[16:19:13.241] - copied ‘x_FUN’ to environment
[16:19:13.241] - copied ‘times’ to environment
[16:19:13.241] - copied ‘stopf’ to environment
[16:19:13.241] - copied ‘stop_if_not’ to environment
[16:19:13.242] - copied ‘dim’ to environment
[16:19:13.242] - copied ‘valid_types’ to environment
[16:19:13.242] - copied ‘future.call.arguments’ to environment
[16:19:13.242] - copied ‘...future.elements_ii’ to environment
[16:19:13.242] - copied ‘...future.seeds_ii’ to environment
[16:19:13.242] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.242] assign_globals() ... done
[16:19:13.243] plan(): Setting new future strategy stack:
[16:19:13.243] List of future strategies:
[16:19:13.243] 1. sequential:
[16:19:13.243]    - args: function (..., envir = parent.frame())
[16:19:13.243]    - tweaked: FALSE
[16:19:13.243]    - call: NULL
[16:19:13.243] plan(): nbrOfWorkers() = 1
[16:19:13.244] plan(): Setting new future strategy stack:
[16:19:13.244] List of future strategies:
[16:19:13.244] 1. sequential:
[16:19:13.244]    - args: function (..., envir = parent.frame())
[16:19:13.244]    - tweaked: FALSE
[16:19:13.244]    - call: plan(strategy)
[16:19:13.246] plan(): nbrOfWorkers() = 1
[16:19:13.246] SequentialFuture started (and completed)
[16:19:13.247] signalConditions() ...
[16:19:13.247]  - include = ‘immediateCondition’
[16:19:13.247]  - exclude = 
[16:19:13.247]  - resignal = FALSE
[16:19:13.247]  - Number of conditions: 1
[16:19:13.247] signalConditions() ... done
[16:19:13.247] - Launch lazy future ... done
[16:19:13.247] run() for ‘SequentialFuture’ ... done
[16:19:13.247] Created future:
[16:19:13.247] SequentialFuture:
[16:19:13.247] Label: ‘future_vapply-1’
[16:19:13.247] Expression:
[16:19:13.247] {
[16:19:13.247]     do.call(function(...) {
[16:19:13.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.247]             on.exit(options(oopts), add = TRUE)
[16:19:13.247]         }
[16:19:13.247]         {
[16:19:13.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.247]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.247]             })
[16:19:13.247]         }
[16:19:13.247]     }, args = future.call.arguments)
[16:19:13.247] }
[16:19:13.247] Lazy evaluation: FALSE
[16:19:13.247] Asynchronous evaluation: FALSE
[16:19:13.247] Local evaluation: TRUE
[16:19:13.247] Environment: R_GlobalEnv
[16:19:13.247] Capture standard output: TRUE
[16:19:13.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.247] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.247] Packages: 1 packages (‘future.apply’)
[16:19:13.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.247] Resolved: TRUE
[16:19:13.247] Value: 0 bytes of class ‘NULL’
[16:19:13.247] Conditions captured: [n=1] ‘simpleError’
[16:19:13.247] Early signaling: FALSE
[16:19:13.247] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.247] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:13.249] Chunk #1 of 1 ... DONE
[16:19:13.249] Launching 1 futures (chunks) ... DONE
[16:19:13.249] Resolving 1 futures (chunks) ...
[16:19:13.249] resolve() on list ...
[16:19:13.249]  recursive: 0
[16:19:13.249]  length: 1
[16:19:13.249] 
[16:19:13.249] resolved() for ‘SequentialFuture’ ...
[16:19:13.249] - state: ‘finished’
[16:19:13.250] - run: TRUE
[16:19:13.250] - result: ‘FutureResult’
[16:19:13.250] resolved() for ‘SequentialFuture’ ... done
[16:19:13.250] Future #1
[16:19:13.250] signalConditions() ...
[16:19:13.250]  - include = ‘immediateCondition’
[16:19:13.250]  - exclude = 
[16:19:13.250]  - resignal = FALSE
[16:19:13.250]  - Number of conditions: 1
[16:19:13.250] signalConditions() ... done
[16:19:13.251] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:13.251] - nx: 1
[16:19:13.251] - relay: TRUE
[16:19:13.251] - stdout: TRUE
[16:19:13.251] - signal: TRUE
[16:19:13.251] - resignal: FALSE
[16:19:13.251] - force: TRUE
[16:19:13.251] - relayed: [n=1] FALSE
[16:19:13.251] - queued futures: [n=1] FALSE
[16:19:13.251]  - until=1
[16:19:13.251]  - relaying element #1
[16:19:13.252] signalConditions() ...
[16:19:13.252]  - include = ‘immediateCondition’
[16:19:13.252]  - exclude = 
[16:19:13.252]  - resignal = FALSE
[16:19:13.252]  - Number of conditions: 1
[16:19:13.252] signalConditions() ... done
[16:19:13.252] signalConditions() ...
[16:19:13.252]  - include = ‘immediateCondition’
[16:19:13.252]  - exclude = 
[16:19:13.252]  - resignal = FALSE
[16:19:13.253]  - Number of conditions: 1
[16:19:13.253] signalConditions() ... done
[16:19:13.253] signalConditions() ...
[16:19:13.253]  - include = ‘condition’
[16:19:13.253]  - exclude = ‘immediateCondition’
[16:19:13.253]  - resignal = TRUE
[16:19:13.253]  - Number of conditions: 1
[16:19:13.253]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:19:13.253] signalConditions() ... done
[16:19:13.253] - relayed: [n=1] FALSE
[16:19:13.253] - queued futures: [n=1] TRUE
[16:19:13.254] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:13.254] plan(): Setting new future strategy stack:
[16:19:13.254] List of future strategies:
[16:19:13.254] 1. sequential:
[16:19:13.254]    - args: function (..., envir = parent.frame())
[16:19:13.254]    - tweaked: FALSE
[16:19:13.254]    - call: plan(sequential)
[16:19:13.254] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:19:13.255] plan(): Setting new future strategy stack:
[16:19:13.255] List of future strategies:
[16:19:13.255] 1. multicore:
[16:19:13.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.255]    - tweaked: FALSE
[16:19:13.255]    - call: plan(strategy)
[16:19:13.259] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:19:13.261] future_lapply() ...
[16:19:13.266] Number of chunks: 2
[16:19:13.267] getGlobalsAndPackagesXApply() ...
[16:19:13.267]  - future.globals: TRUE
[16:19:13.267] getGlobalsAndPackages() ...
[16:19:13.267] Searching for globals...
[16:19:13.270] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:13.270] Searching for globals ... DONE
[16:19:13.273] Resolving globals: FALSE
[16:19:13.274] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:19:13.275] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.275] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.275] - packages: [1] ‘future.apply’
[16:19:13.275] getGlobalsAndPackages() ... DONE
[16:19:13.275]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.275]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.275] Finding globals ... DONE
[16:19:13.276]  - use_args: TRUE
[16:19:13.276]  - Getting '...' globals ...
[16:19:13.276] resolve() on list ...
[16:19:13.276]  recursive: 0
[16:19:13.276]  length: 1
[16:19:13.276]  elements: ‘...’
[16:19:13.277]  length: 0 (resolved future 1)
[16:19:13.277] resolve() on list ... DONE
[16:19:13.277]    - '...' content: [n=0] 
[16:19:13.277] List of 1
[16:19:13.277]  $ ...: list()
[16:19:13.277]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.277]  - attr(*, "where")=List of 1
[16:19:13.277]   ..$ ...:<environment: 0x56199efeba18> 
[16:19:13.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.277]  - attr(*, "resolved")= logi TRUE
[16:19:13.277]  - attr(*, "total_size")= num NA
[16:19:13.279]  - Getting '...' globals ... DONE
[16:19:13.280] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.280] List of 8
[16:19:13.280]  $ ...future.FUN:function (x, ...)  
[16:19:13.280]  $ x_FUN        :function (x)  
[16:19:13.280]  $ times        : int 1
[16:19:13.280]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.280]  $ stop_if_not  :function (...)  
[16:19:13.280]  $ dim          : NULL
[16:19:13.280]  $ valid_types  : chr "character"
[16:19:13.280]  $ ...          : list()
[16:19:13.280]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.280]  - attr(*, "where")=List of 8
[16:19:13.280]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.280]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.280]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.280]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.280]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.280]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.280]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.280]   ..$ ...          :<environment: 0x56199efeba18> 
[16:19:13.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.280]  - attr(*, "resolved")= logi FALSE
[16:19:13.280]  - attr(*, "total_size")= num 94208
[16:19:13.285] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.285] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.285] Number of futures (= number of chunks): 2
[16:19:13.285] Launching 2 futures (chunks) ...
[16:19:13.286] Chunk #1 of 2 ...
[16:19:13.286]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.286] getGlobalsAndPackages() ...
[16:19:13.286] Searching for globals...
[16:19:13.286] 
[16:19:13.286] Searching for globals ... DONE
[16:19:13.286] - globals: [0] <none>
[16:19:13.286] getGlobalsAndPackages() ... DONE
[16:19:13.286]    + additional globals found: [n=0] 
[16:19:13.286]    + additional namespaces needed: [n=0] 
[16:19:13.287]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.287]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.287]  - seeds: <none>
[16:19:13.287]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.287] getGlobalsAndPackages() ...
[16:19:13.287] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.287] Resolving globals: FALSE
[16:19:13.287] Tweak future expression to call with '...' arguments ...
[16:19:13.287] {
[16:19:13.287]     do.call(function(...) {
[16:19:13.287]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.287]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.287]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.287]             on.exit(options(oopts), add = TRUE)
[16:19:13.287]         }
[16:19:13.287]         {
[16:19:13.287]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.287]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.287]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.287]             })
[16:19:13.287]         }
[16:19:13.287]     }, args = future.call.arguments)
[16:19:13.287] }
[16:19:13.288] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.288] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.288] - packages: [1] ‘future.apply’
[16:19:13.288] getGlobalsAndPackages() ... DONE
[16:19:13.289] run() for ‘Future’ ...
[16:19:13.289] - state: ‘created’
[16:19:13.289] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.292] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.293]   - Field: ‘label’
[16:19:13.293]   - Field: ‘local’
[16:19:13.293]   - Field: ‘owner’
[16:19:13.293]   - Field: ‘envir’
[16:19:13.293]   - Field: ‘workers’
[16:19:13.293]   - Field: ‘packages’
[16:19:13.293]   - Field: ‘gc’
[16:19:13.293]   - Field: ‘job’
[16:19:13.293]   - Field: ‘conditions’
[16:19:13.293]   - Field: ‘expr’
[16:19:13.294]   - Field: ‘uuid’
[16:19:13.294]   - Field: ‘seed’
[16:19:13.294]   - Field: ‘version’
[16:19:13.294]   - Field: ‘result’
[16:19:13.294]   - Field: ‘asynchronous’
[16:19:13.294]   - Field: ‘calls’
[16:19:13.294]   - Field: ‘globals’
[16:19:13.294]   - Field: ‘stdout’
[16:19:13.294]   - Field: ‘earlySignal’
[16:19:13.294]   - Field: ‘lazy’
[16:19:13.294]   - Field: ‘state’
[16:19:13.295] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.295] - Launch lazy future ...
[16:19:13.296] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.296] Packages needed by future strategies (n = 0): <none>
[16:19:13.296] {
[16:19:13.296]     {
[16:19:13.296]         {
[16:19:13.296]             ...future.startTime <- base::Sys.time()
[16:19:13.296]             {
[16:19:13.296]                 {
[16:19:13.296]                   {
[16:19:13.296]                     {
[16:19:13.296]                       {
[16:19:13.296]                         base::local({
[16:19:13.296]                           has_future <- base::requireNamespace("future", 
[16:19:13.296]                             quietly = TRUE)
[16:19:13.296]                           if (has_future) {
[16:19:13.296]                             ns <- base::getNamespace("future")
[16:19:13.296]                             version <- ns[[".package"]][["version"]]
[16:19:13.296]                             if (is.null(version)) 
[16:19:13.296]                               version <- utils::packageVersion("future")
[16:19:13.296]                           }
[16:19:13.296]                           else {
[16:19:13.296]                             version <- NULL
[16:19:13.296]                           }
[16:19:13.296]                           if (!has_future || version < "1.8.0") {
[16:19:13.296]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.296]                               "", base::R.version$version.string), 
[16:19:13.296]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.296]                                 base::R.version$platform, 8 * 
[16:19:13.296]                                   base::.Machine$sizeof.pointer), 
[16:19:13.296]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.296]                                 "release", "version")], collapse = " "), 
[16:19:13.296]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.296]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.296]                               info)
[16:19:13.296]                             info <- base::paste(info, collapse = "; ")
[16:19:13.296]                             if (!has_future) {
[16:19:13.296]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.296]                                 info)
[16:19:13.296]                             }
[16:19:13.296]                             else {
[16:19:13.296]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.296]                                 info, version)
[16:19:13.296]                             }
[16:19:13.296]                             base::stop(msg)
[16:19:13.296]                           }
[16:19:13.296]                         })
[16:19:13.296]                       }
[16:19:13.296]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.296]                       base::options(mc.cores = 1L)
[16:19:13.296]                     }
[16:19:13.296]                     base::local({
[16:19:13.296]                       for (pkg in "future.apply") {
[16:19:13.296]                         base::loadNamespace(pkg)
[16:19:13.296]                         base::library(pkg, character.only = TRUE)
[16:19:13.296]                       }
[16:19:13.296]                     })
[16:19:13.296]                   }
[16:19:13.296]                   ...future.strategy.old <- future::plan("list")
[16:19:13.296]                   options(future.plan = NULL)
[16:19:13.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.296]                 }
[16:19:13.296]                 ...future.workdir <- getwd()
[16:19:13.296]             }
[16:19:13.296]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.296]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.296]         }
[16:19:13.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.296]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.296]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.296]             base::names(...future.oldOptions))
[16:19:13.296]     }
[16:19:13.296]     if (FALSE) {
[16:19:13.296]     }
[16:19:13.296]     else {
[16:19:13.296]         if (TRUE) {
[16:19:13.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.296]                 open = "w")
[16:19:13.296]         }
[16:19:13.296]         else {
[16:19:13.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.296]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.296]         }
[16:19:13.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.296]             base::sink(type = "output", split = FALSE)
[16:19:13.296]             base::close(...future.stdout)
[16:19:13.296]         }, add = TRUE)
[16:19:13.296]     }
[16:19:13.296]     ...future.frame <- base::sys.nframe()
[16:19:13.296]     ...future.conditions <- base::list()
[16:19:13.296]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.296]     if (FALSE) {
[16:19:13.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.296]     }
[16:19:13.296]     ...future.result <- base::tryCatch({
[16:19:13.296]         base::withCallingHandlers({
[16:19:13.296]             ...future.value <- base::withVisible(base::local({
[16:19:13.296]                 withCallingHandlers({
[16:19:13.296]                   {
[16:19:13.296]                     do.call(function(...) {
[16:19:13.296]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.296]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.296]                         ...future.globals.maxSize)) {
[16:19:13.296]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.296]                         on.exit(options(oopts), add = TRUE)
[16:19:13.296]                       }
[16:19:13.296]                       {
[16:19:13.296]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.296]                           FUN = function(jj) {
[16:19:13.296]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.296]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.296]                           })
[16:19:13.296]                       }
[16:19:13.296]                     }, args = future.call.arguments)
[16:19:13.296]                   }
[16:19:13.296]                 }, immediateCondition = function(cond) {
[16:19:13.296]                   save_rds <- function (object, pathname, ...) 
[16:19:13.296]                   {
[16:19:13.296]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.296]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.296]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.296]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.296]                         fi_tmp[["mtime"]])
[16:19:13.296]                     }
[16:19:13.296]                     tryCatch({
[16:19:13.296]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.296]                     }, error = function(ex) {
[16:19:13.296]                       msg <- conditionMessage(ex)
[16:19:13.296]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.296]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.296]                         fi_tmp[["mtime"]], msg)
[16:19:13.296]                       ex$message <- msg
[16:19:13.296]                       stop(ex)
[16:19:13.296]                     })
[16:19:13.296]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.296]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.296]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.296]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.296]                       fi <- file.info(pathname)
[16:19:13.296]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.296]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.296]                         fi[["size"]], fi[["mtime"]])
[16:19:13.296]                       stop(msg)
[16:19:13.296]                     }
[16:19:13.296]                     invisible(pathname)
[16:19:13.296]                   }
[16:19:13.296]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.296]                     rootPath = tempdir()) 
[16:19:13.296]                   {
[16:19:13.296]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.296]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.296]                       tmpdir = path, fileext = ".rds")
[16:19:13.296]                     save_rds(obj, file)
[16:19:13.296]                   }
[16:19:13.296]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.296]                   {
[16:19:13.296]                     inherits <- base::inherits
[16:19:13.296]                     invokeRestart <- base::invokeRestart
[16:19:13.296]                     is.null <- base::is.null
[16:19:13.296]                     muffled <- FALSE
[16:19:13.296]                     if (inherits(cond, "message")) {
[16:19:13.296]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.296]                       if (muffled) 
[16:19:13.296]                         invokeRestart("muffleMessage")
[16:19:13.296]                     }
[16:19:13.296]                     else if (inherits(cond, "warning")) {
[16:19:13.296]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.296]                       if (muffled) 
[16:19:13.296]                         invokeRestart("muffleWarning")
[16:19:13.296]                     }
[16:19:13.296]                     else if (inherits(cond, "condition")) {
[16:19:13.296]                       if (!is.null(pattern)) {
[16:19:13.296]                         computeRestarts <- base::computeRestarts
[16:19:13.296]                         grepl <- base::grepl
[16:19:13.296]                         restarts <- computeRestarts(cond)
[16:19:13.296]                         for (restart in restarts) {
[16:19:13.296]                           name <- restart$name
[16:19:13.296]                           if (is.null(name)) 
[16:19:13.296]                             next
[16:19:13.296]                           if (!grepl(pattern, name)) 
[16:19:13.296]                             next
[16:19:13.296]                           invokeRestart(restart)
[16:19:13.296]                           muffled <- TRUE
[16:19:13.296]                           break
[16:19:13.296]                         }
[16:19:13.296]                       }
[16:19:13.296]                     }
[16:19:13.296]                     invisible(muffled)
[16:19:13.296]                   }
[16:19:13.296]                   muffleCondition(cond)
[16:19:13.296]                 })
[16:19:13.296]             }))
[16:19:13.296]             future::FutureResult(value = ...future.value$value, 
[16:19:13.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.296]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.296]                     ...future.globalenv.names))
[16:19:13.296]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.296]         }, condition = base::local({
[16:19:13.296]             c <- base::c
[16:19:13.296]             inherits <- base::inherits
[16:19:13.296]             invokeRestart <- base::invokeRestart
[16:19:13.296]             length <- base::length
[16:19:13.296]             list <- base::list
[16:19:13.296]             seq.int <- base::seq.int
[16:19:13.296]             signalCondition <- base::signalCondition
[16:19:13.296]             sys.calls <- base::sys.calls
[16:19:13.296]             `[[` <- base::`[[`
[16:19:13.296]             `+` <- base::`+`
[16:19:13.296]             `<<-` <- base::`<<-`
[16:19:13.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.296]                   3L)]
[16:19:13.296]             }
[16:19:13.296]             function(cond) {
[16:19:13.296]                 is_error <- inherits(cond, "error")
[16:19:13.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.296]                   NULL)
[16:19:13.296]                 if (is_error) {
[16:19:13.296]                   sessionInformation <- function() {
[16:19:13.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.296]                       search = base::search(), system = base::Sys.info())
[16:19:13.296]                   }
[16:19:13.296]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.296]                     cond$call), session = sessionInformation(), 
[16:19:13.296]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.296]                   signalCondition(cond)
[16:19:13.296]                 }
[16:19:13.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.296]                 "immediateCondition"))) {
[16:19:13.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.296]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.296]                   if (TRUE && !signal) {
[16:19:13.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.296]                     {
[16:19:13.296]                       inherits <- base::inherits
[16:19:13.296]                       invokeRestart <- base::invokeRestart
[16:19:13.296]                       is.null <- base::is.null
[16:19:13.296]                       muffled <- FALSE
[16:19:13.296]                       if (inherits(cond, "message")) {
[16:19:13.296]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.296]                         if (muffled) 
[16:19:13.296]                           invokeRestart("muffleMessage")
[16:19:13.296]                       }
[16:19:13.296]                       else if (inherits(cond, "warning")) {
[16:19:13.296]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.296]                         if (muffled) 
[16:19:13.296]                           invokeRestart("muffleWarning")
[16:19:13.296]                       }
[16:19:13.296]                       else if (inherits(cond, "condition")) {
[16:19:13.296]                         if (!is.null(pattern)) {
[16:19:13.296]                           computeRestarts <- base::computeRestarts
[16:19:13.296]                           grepl <- base::grepl
[16:19:13.296]                           restarts <- computeRestarts(cond)
[16:19:13.296]                           for (restart in restarts) {
[16:19:13.296]                             name <- restart$name
[16:19:13.296]                             if (is.null(name)) 
[16:19:13.296]                               next
[16:19:13.296]                             if (!grepl(pattern, name)) 
[16:19:13.296]                               next
[16:19:13.296]                             invokeRestart(restart)
[16:19:13.296]                             muffled <- TRUE
[16:19:13.296]                             break
[16:19:13.296]                           }
[16:19:13.296]                         }
[16:19:13.296]                       }
[16:19:13.296]                       invisible(muffled)
[16:19:13.296]                     }
[16:19:13.296]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.296]                   }
[16:19:13.296]                 }
[16:19:13.296]                 else {
[16:19:13.296]                   if (TRUE) {
[16:19:13.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.296]                     {
[16:19:13.296]                       inherits <- base::inherits
[16:19:13.296]                       invokeRestart <- base::invokeRestart
[16:19:13.296]                       is.null <- base::is.null
[16:19:13.296]                       muffled <- FALSE
[16:19:13.296]                       if (inherits(cond, "message")) {
[16:19:13.296]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.296]                         if (muffled) 
[16:19:13.296]                           invokeRestart("muffleMessage")
[16:19:13.296]                       }
[16:19:13.296]                       else if (inherits(cond, "warning")) {
[16:19:13.296]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.296]                         if (muffled) 
[16:19:13.296]                           invokeRestart("muffleWarning")
[16:19:13.296]                       }
[16:19:13.296]                       else if (inherits(cond, "condition")) {
[16:19:13.296]                         if (!is.null(pattern)) {
[16:19:13.296]                           computeRestarts <- base::computeRestarts
[16:19:13.296]                           grepl <- base::grepl
[16:19:13.296]                           restarts <- computeRestarts(cond)
[16:19:13.296]                           for (restart in restarts) {
[16:19:13.296]                             name <- restart$name
[16:19:13.296]                             if (is.null(name)) 
[16:19:13.296]                               next
[16:19:13.296]                             if (!grepl(pattern, name)) 
[16:19:13.296]                               next
[16:19:13.296]                             invokeRestart(restart)
[16:19:13.296]                             muffled <- TRUE
[16:19:13.296]                             break
[16:19:13.296]                           }
[16:19:13.296]                         }
[16:19:13.296]                       }
[16:19:13.296]                       invisible(muffled)
[16:19:13.296]                     }
[16:19:13.296]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.296]                   }
[16:19:13.296]                 }
[16:19:13.296]             }
[16:19:13.296]         }))
[16:19:13.296]     }, error = function(ex) {
[16:19:13.296]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.296]                 ...future.rng), started = ...future.startTime, 
[16:19:13.296]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.296]             version = "1.8"), class = "FutureResult")
[16:19:13.296]     }, finally = {
[16:19:13.296]         if (!identical(...future.workdir, getwd())) 
[16:19:13.296]             setwd(...future.workdir)
[16:19:13.296]         {
[16:19:13.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.296]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.296]             }
[16:19:13.296]             base::options(...future.oldOptions)
[16:19:13.296]             if (.Platform$OS.type == "windows") {
[16:19:13.296]                 old_names <- names(...future.oldEnvVars)
[16:19:13.296]                 envs <- base::Sys.getenv()
[16:19:13.296]                 names <- names(envs)
[16:19:13.296]                 common <- intersect(names, old_names)
[16:19:13.296]                 added <- setdiff(names, old_names)
[16:19:13.296]                 removed <- setdiff(old_names, names)
[16:19:13.296]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.296]                   envs[common]]
[16:19:13.296]                 NAMES <- toupper(changed)
[16:19:13.296]                 args <- list()
[16:19:13.296]                 for (kk in seq_along(NAMES)) {
[16:19:13.296]                   name <- changed[[kk]]
[16:19:13.296]                   NAME <- NAMES[[kk]]
[16:19:13.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.296]                     next
[16:19:13.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.296]                 }
[16:19:13.296]                 NAMES <- toupper(added)
[16:19:13.296]                 for (kk in seq_along(NAMES)) {
[16:19:13.296]                   name <- added[[kk]]
[16:19:13.296]                   NAME <- NAMES[[kk]]
[16:19:13.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.296]                     next
[16:19:13.296]                   args[[name]] <- ""
[16:19:13.296]                 }
[16:19:13.296]                 NAMES <- toupper(removed)
[16:19:13.296]                 for (kk in seq_along(NAMES)) {
[16:19:13.296]                   name <- removed[[kk]]
[16:19:13.296]                   NAME <- NAMES[[kk]]
[16:19:13.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.296]                     next
[16:19:13.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.296]                 }
[16:19:13.296]                 if (length(args) > 0) 
[16:19:13.296]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.296]             }
[16:19:13.296]             else {
[16:19:13.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.296]             }
[16:19:13.296]             {
[16:19:13.296]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.296]                   0L) {
[16:19:13.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.296]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.296]                   base::options(opts)
[16:19:13.296]                 }
[16:19:13.296]                 {
[16:19:13.296]                   {
[16:19:13.296]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.296]                     NULL
[16:19:13.296]                   }
[16:19:13.296]                   options(future.plan = NULL)
[16:19:13.296]                   if (is.na(NA_character_)) 
[16:19:13.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.296]                     .init = FALSE)
[16:19:13.296]                 }
[16:19:13.296]             }
[16:19:13.296]         }
[16:19:13.296]     })
[16:19:13.296]     if (TRUE) {
[16:19:13.296]         base::sink(type = "output", split = FALSE)
[16:19:13.296]         if (TRUE) {
[16:19:13.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.296]         }
[16:19:13.296]         else {
[16:19:13.296]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.296]         }
[16:19:13.296]         base::close(...future.stdout)
[16:19:13.296]         ...future.stdout <- NULL
[16:19:13.296]     }
[16:19:13.296]     ...future.result$conditions <- ...future.conditions
[16:19:13.296]     ...future.result$finished <- base::Sys.time()
[16:19:13.296]     ...future.result
[16:19:13.296] }
[16:19:13.299] assign_globals() ...
[16:19:13.300] List of 11
[16:19:13.300]  $ ...future.FUN            :function (x, ...)  
[16:19:13.300]  $ x_FUN                    :function (x)  
[16:19:13.300]  $ times                    : int 1
[16:19:13.300]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.300]  $ stop_if_not              :function (...)  
[16:19:13.300]  $ dim                      : NULL
[16:19:13.300]  $ valid_types              : chr "character"
[16:19:13.300]  $ future.call.arguments    : list()
[16:19:13.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.300]  $ ...future.elements_ii    :List of 1
[16:19:13.300]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:19:13.300]  $ ...future.seeds_ii       : NULL
[16:19:13.300]  $ ...future.globals.maxSize: NULL
[16:19:13.300]  - attr(*, "where")=List of 11
[16:19:13.300]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.300]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.300]  - attr(*, "resolved")= logi FALSE
[16:19:13.300]  - attr(*, "total_size")= num 94208
[16:19:13.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.300]  - attr(*, "already-done")= logi TRUE
[16:19:13.309] - copied ‘...future.FUN’ to environment
[16:19:13.309] - copied ‘x_FUN’ to environment
[16:19:13.309] - copied ‘times’ to environment
[16:19:13.309] - copied ‘stopf’ to environment
[16:19:13.309] - copied ‘stop_if_not’ to environment
[16:19:13.309] - copied ‘dim’ to environment
[16:19:13.309] - copied ‘valid_types’ to environment
[16:19:13.309] - copied ‘future.call.arguments’ to environment
[16:19:13.309] - copied ‘...future.elements_ii’ to environment
[16:19:13.310] - copied ‘...future.seeds_ii’ to environment
[16:19:13.310] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.310] assign_globals() ... done
[16:19:13.310] requestCore(): workers = 2
[16:19:13.313] MulticoreFuture started
[16:19:13.314] - Launch lazy future ... done
[16:19:13.314] run() for ‘MulticoreFuture’ ... done
[16:19:13.314] Created future:
[16:19:13.314] plan(): Setting new future strategy stack:
[16:19:13.315] List of future strategies:
[16:19:13.315] 1. sequential:
[16:19:13.315]    - args: function (..., envir = parent.frame())
[16:19:13.315]    - tweaked: FALSE
[16:19:13.315]    - call: NULL
[16:19:13.316] plan(): nbrOfWorkers() = 1
[16:19:13.318] plan(): Setting new future strategy stack:
[16:19:13.318] List of future strategies:
[16:19:13.318] 1. multicore:
[16:19:13.318]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.318]    - tweaked: FALSE
[16:19:13.318]    - call: plan(strategy)
[16:19:13.324] plan(): nbrOfWorkers() = 2
[16:19:13.315] MulticoreFuture:
[16:19:13.315] Label: ‘future_vapply-1’
[16:19:13.315] Expression:
[16:19:13.315] {
[16:19:13.315]     do.call(function(...) {
[16:19:13.315]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.315]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.315]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.315]             on.exit(options(oopts), add = TRUE)
[16:19:13.315]         }
[16:19:13.315]         {
[16:19:13.315]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.315]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.315]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.315]             })
[16:19:13.315]         }
[16:19:13.315]     }, args = future.call.arguments)
[16:19:13.315] }
[16:19:13.315] Lazy evaluation: FALSE
[16:19:13.315] Asynchronous evaluation: TRUE
[16:19:13.315] Local evaluation: TRUE
[16:19:13.315] Environment: R_GlobalEnv
[16:19:13.315] Capture standard output: TRUE
[16:19:13.315] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.315] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.315] Packages: 1 packages (‘future.apply’)
[16:19:13.315] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.315] Resolved: TRUE
[16:19:13.315] Value: <not collected>
[16:19:13.315] Conditions captured: <none>
[16:19:13.315] Early signaling: FALSE
[16:19:13.315] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.315] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.325] Chunk #1 of 2 ... DONE
[16:19:13.325] Chunk #2 of 2 ...
[16:19:13.326]  - Finding globals in 'X' for chunk #2 ...
[16:19:13.326] getGlobalsAndPackages() ...
[16:19:13.326] Searching for globals...
[16:19:13.326] 
[16:19:13.326] Searching for globals ... DONE
[16:19:13.327] - globals: [0] <none>
[16:19:13.327] getGlobalsAndPackages() ... DONE
[16:19:13.327]    + additional globals found: [n=0] 
[16:19:13.327]    + additional namespaces needed: [n=0] 
[16:19:13.327]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:13.327]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.327]  - seeds: <none>
[16:19:13.328]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.328] getGlobalsAndPackages() ...
[16:19:13.328] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.328] Resolving globals: FALSE
[16:19:13.328] Tweak future expression to call with '...' arguments ...
[16:19:13.329] {
[16:19:13.329]     do.call(function(...) {
[16:19:13.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.329]             on.exit(options(oopts), add = TRUE)
[16:19:13.329]         }
[16:19:13.329]         {
[16:19:13.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.329]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.329]             })
[16:19:13.329]         }
[16:19:13.329]     }, args = future.call.arguments)
[16:19:13.329] }
[16:19:13.329] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.330] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.330] - packages: [1] ‘future.apply’
[16:19:13.330] getGlobalsAndPackages() ... DONE
[16:19:13.331] run() for ‘Future’ ...
[16:19:13.331] - state: ‘created’
[16:19:13.331] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.336] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.336]   - Field: ‘label’
[16:19:13.336]   - Field: ‘local’
[16:19:13.336]   - Field: ‘owner’
[16:19:13.336]   - Field: ‘envir’
[16:19:13.337]   - Field: ‘workers’
[16:19:13.337]   - Field: ‘packages’
[16:19:13.337]   - Field: ‘gc’
[16:19:13.337]   - Field: ‘job’
[16:19:13.337]   - Field: ‘conditions’
[16:19:13.337]   - Field: ‘expr’
[16:19:13.337]   - Field: ‘uuid’
[16:19:13.338]   - Field: ‘seed’
[16:19:13.338]   - Field: ‘version’
[16:19:13.338]   - Field: ‘result’
[16:19:13.338]   - Field: ‘asynchronous’
[16:19:13.338]   - Field: ‘calls’
[16:19:13.338]   - Field: ‘globals’
[16:19:13.338]   - Field: ‘stdout’
[16:19:13.338]   - Field: ‘earlySignal’
[16:19:13.339]   - Field: ‘lazy’
[16:19:13.339]   - Field: ‘state’
[16:19:13.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.339] - Launch lazy future ...
[16:19:13.339] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.340] Packages needed by future strategies (n = 0): <none>
[16:19:13.340] {
[16:19:13.340]     {
[16:19:13.340]         {
[16:19:13.340]             ...future.startTime <- base::Sys.time()
[16:19:13.340]             {
[16:19:13.340]                 {
[16:19:13.340]                   {
[16:19:13.340]                     {
[16:19:13.340]                       {
[16:19:13.340]                         base::local({
[16:19:13.340]                           has_future <- base::requireNamespace("future", 
[16:19:13.340]                             quietly = TRUE)
[16:19:13.340]                           if (has_future) {
[16:19:13.340]                             ns <- base::getNamespace("future")
[16:19:13.340]                             version <- ns[[".package"]][["version"]]
[16:19:13.340]                             if (is.null(version)) 
[16:19:13.340]                               version <- utils::packageVersion("future")
[16:19:13.340]                           }
[16:19:13.340]                           else {
[16:19:13.340]                             version <- NULL
[16:19:13.340]                           }
[16:19:13.340]                           if (!has_future || version < "1.8.0") {
[16:19:13.340]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.340]                               "", base::R.version$version.string), 
[16:19:13.340]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.340]                                 base::R.version$platform, 8 * 
[16:19:13.340]                                   base::.Machine$sizeof.pointer), 
[16:19:13.340]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.340]                                 "release", "version")], collapse = " "), 
[16:19:13.340]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.340]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.340]                               info)
[16:19:13.340]                             info <- base::paste(info, collapse = "; ")
[16:19:13.340]                             if (!has_future) {
[16:19:13.340]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.340]                                 info)
[16:19:13.340]                             }
[16:19:13.340]                             else {
[16:19:13.340]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.340]                                 info, version)
[16:19:13.340]                             }
[16:19:13.340]                             base::stop(msg)
[16:19:13.340]                           }
[16:19:13.340]                         })
[16:19:13.340]                       }
[16:19:13.340]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.340]                       base::options(mc.cores = 1L)
[16:19:13.340]                     }
[16:19:13.340]                     base::local({
[16:19:13.340]                       for (pkg in "future.apply") {
[16:19:13.340]                         base::loadNamespace(pkg)
[16:19:13.340]                         base::library(pkg, character.only = TRUE)
[16:19:13.340]                       }
[16:19:13.340]                     })
[16:19:13.340]                   }
[16:19:13.340]                   ...future.strategy.old <- future::plan("list")
[16:19:13.340]                   options(future.plan = NULL)
[16:19:13.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.340]                 }
[16:19:13.340]                 ...future.workdir <- getwd()
[16:19:13.340]             }
[16:19:13.340]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.340]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.340]         }
[16:19:13.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.340]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.340]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.340]             base::names(...future.oldOptions))
[16:19:13.340]     }
[16:19:13.340]     if (FALSE) {
[16:19:13.340]     }
[16:19:13.340]     else {
[16:19:13.340]         if (TRUE) {
[16:19:13.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.340]                 open = "w")
[16:19:13.340]         }
[16:19:13.340]         else {
[16:19:13.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.340]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.340]         }
[16:19:13.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.340]             base::sink(type = "output", split = FALSE)
[16:19:13.340]             base::close(...future.stdout)
[16:19:13.340]         }, add = TRUE)
[16:19:13.340]     }
[16:19:13.340]     ...future.frame <- base::sys.nframe()
[16:19:13.340]     ...future.conditions <- base::list()
[16:19:13.340]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.340]     if (FALSE) {
[16:19:13.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.340]     }
[16:19:13.340]     ...future.result <- base::tryCatch({
[16:19:13.340]         base::withCallingHandlers({
[16:19:13.340]             ...future.value <- base::withVisible(base::local({
[16:19:13.340]                 withCallingHandlers({
[16:19:13.340]                   {
[16:19:13.340]                     do.call(function(...) {
[16:19:13.340]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.340]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.340]                         ...future.globals.maxSize)) {
[16:19:13.340]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.340]                         on.exit(options(oopts), add = TRUE)
[16:19:13.340]                       }
[16:19:13.340]                       {
[16:19:13.340]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.340]                           FUN = function(jj) {
[16:19:13.340]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.340]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.340]                           })
[16:19:13.340]                       }
[16:19:13.340]                     }, args = future.call.arguments)
[16:19:13.340]                   }
[16:19:13.340]                 }, immediateCondition = function(cond) {
[16:19:13.340]                   save_rds <- function (object, pathname, ...) 
[16:19:13.340]                   {
[16:19:13.340]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.340]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.340]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.340]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.340]                         fi_tmp[["mtime"]])
[16:19:13.340]                     }
[16:19:13.340]                     tryCatch({
[16:19:13.340]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.340]                     }, error = function(ex) {
[16:19:13.340]                       msg <- conditionMessage(ex)
[16:19:13.340]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.340]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.340]                         fi_tmp[["mtime"]], msg)
[16:19:13.340]                       ex$message <- msg
[16:19:13.340]                       stop(ex)
[16:19:13.340]                     })
[16:19:13.340]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.340]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.340]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.340]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.340]                       fi <- file.info(pathname)
[16:19:13.340]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.340]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.340]                         fi[["size"]], fi[["mtime"]])
[16:19:13.340]                       stop(msg)
[16:19:13.340]                     }
[16:19:13.340]                     invisible(pathname)
[16:19:13.340]                   }
[16:19:13.340]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.340]                     rootPath = tempdir()) 
[16:19:13.340]                   {
[16:19:13.340]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.340]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.340]                       tmpdir = path, fileext = ".rds")
[16:19:13.340]                     save_rds(obj, file)
[16:19:13.340]                   }
[16:19:13.340]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.340]                   {
[16:19:13.340]                     inherits <- base::inherits
[16:19:13.340]                     invokeRestart <- base::invokeRestart
[16:19:13.340]                     is.null <- base::is.null
[16:19:13.340]                     muffled <- FALSE
[16:19:13.340]                     if (inherits(cond, "message")) {
[16:19:13.340]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.340]                       if (muffled) 
[16:19:13.340]                         invokeRestart("muffleMessage")
[16:19:13.340]                     }
[16:19:13.340]                     else if (inherits(cond, "warning")) {
[16:19:13.340]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.340]                       if (muffled) 
[16:19:13.340]                         invokeRestart("muffleWarning")
[16:19:13.340]                     }
[16:19:13.340]                     else if (inherits(cond, "condition")) {
[16:19:13.340]                       if (!is.null(pattern)) {
[16:19:13.340]                         computeRestarts <- base::computeRestarts
[16:19:13.340]                         grepl <- base::grepl
[16:19:13.340]                         restarts <- computeRestarts(cond)
[16:19:13.340]                         for (restart in restarts) {
[16:19:13.340]                           name <- restart$name
[16:19:13.340]                           if (is.null(name)) 
[16:19:13.340]                             next
[16:19:13.340]                           if (!grepl(pattern, name)) 
[16:19:13.340]                             next
[16:19:13.340]                           invokeRestart(restart)
[16:19:13.340]                           muffled <- TRUE
[16:19:13.340]                           break
[16:19:13.340]                         }
[16:19:13.340]                       }
[16:19:13.340]                     }
[16:19:13.340]                     invisible(muffled)
[16:19:13.340]                   }
[16:19:13.340]                   muffleCondition(cond)
[16:19:13.340]                 })
[16:19:13.340]             }))
[16:19:13.340]             future::FutureResult(value = ...future.value$value, 
[16:19:13.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.340]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.340]                     ...future.globalenv.names))
[16:19:13.340]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.340]         }, condition = base::local({
[16:19:13.340]             c <- base::c
[16:19:13.340]             inherits <- base::inherits
[16:19:13.340]             invokeRestart <- base::invokeRestart
[16:19:13.340]             length <- base::length
[16:19:13.340]             list <- base::list
[16:19:13.340]             seq.int <- base::seq.int
[16:19:13.340]             signalCondition <- base::signalCondition
[16:19:13.340]             sys.calls <- base::sys.calls
[16:19:13.340]             `[[` <- base::`[[`
[16:19:13.340]             `+` <- base::`+`
[16:19:13.340]             `<<-` <- base::`<<-`
[16:19:13.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.340]                   3L)]
[16:19:13.340]             }
[16:19:13.340]             function(cond) {
[16:19:13.340]                 is_error <- inherits(cond, "error")
[16:19:13.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.340]                   NULL)
[16:19:13.340]                 if (is_error) {
[16:19:13.340]                   sessionInformation <- function() {
[16:19:13.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.340]                       search = base::search(), system = base::Sys.info())
[16:19:13.340]                   }
[16:19:13.340]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.340]                     cond$call), session = sessionInformation(), 
[16:19:13.340]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.340]                   signalCondition(cond)
[16:19:13.340]                 }
[16:19:13.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.340]                 "immediateCondition"))) {
[16:19:13.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.340]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.340]                   if (TRUE && !signal) {
[16:19:13.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.340]                     {
[16:19:13.340]                       inherits <- base::inherits
[16:19:13.340]                       invokeRestart <- base::invokeRestart
[16:19:13.340]                       is.null <- base::is.null
[16:19:13.340]                       muffled <- FALSE
[16:19:13.340]                       if (inherits(cond, "message")) {
[16:19:13.340]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.340]                         if (muffled) 
[16:19:13.340]                           invokeRestart("muffleMessage")
[16:19:13.340]                       }
[16:19:13.340]                       else if (inherits(cond, "warning")) {
[16:19:13.340]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.340]                         if (muffled) 
[16:19:13.340]                           invokeRestart("muffleWarning")
[16:19:13.340]                       }
[16:19:13.340]                       else if (inherits(cond, "condition")) {
[16:19:13.340]                         if (!is.null(pattern)) {
[16:19:13.340]                           computeRestarts <- base::computeRestarts
[16:19:13.340]                           grepl <- base::grepl
[16:19:13.340]                           restarts <- computeRestarts(cond)
[16:19:13.340]                           for (restart in restarts) {
[16:19:13.340]                             name <- restart$name
[16:19:13.340]                             if (is.null(name)) 
[16:19:13.340]                               next
[16:19:13.340]                             if (!grepl(pattern, name)) 
[16:19:13.340]                               next
[16:19:13.340]                             invokeRestart(restart)
[16:19:13.340]                             muffled <- TRUE
[16:19:13.340]                             break
[16:19:13.340]                           }
[16:19:13.340]                         }
[16:19:13.340]                       }
[16:19:13.340]                       invisible(muffled)
[16:19:13.340]                     }
[16:19:13.340]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.340]                   }
[16:19:13.340]                 }
[16:19:13.340]                 else {
[16:19:13.340]                   if (TRUE) {
[16:19:13.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.340]                     {
[16:19:13.340]                       inherits <- base::inherits
[16:19:13.340]                       invokeRestart <- base::invokeRestart
[16:19:13.340]                       is.null <- base::is.null
[16:19:13.340]                       muffled <- FALSE
[16:19:13.340]                       if (inherits(cond, "message")) {
[16:19:13.340]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.340]                         if (muffled) 
[16:19:13.340]                           invokeRestart("muffleMessage")
[16:19:13.340]                       }
[16:19:13.340]                       else if (inherits(cond, "warning")) {
[16:19:13.340]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.340]                         if (muffled) 
[16:19:13.340]                           invokeRestart("muffleWarning")
[16:19:13.340]                       }
[16:19:13.340]                       else if (inherits(cond, "condition")) {
[16:19:13.340]                         if (!is.null(pattern)) {
[16:19:13.340]                           computeRestarts <- base::computeRestarts
[16:19:13.340]                           grepl <- base::grepl
[16:19:13.340]                           restarts <- computeRestarts(cond)
[16:19:13.340]                           for (restart in restarts) {
[16:19:13.340]                             name <- restart$name
[16:19:13.340]                             if (is.null(name)) 
[16:19:13.340]                               next
[16:19:13.340]                             if (!grepl(pattern, name)) 
[16:19:13.340]                               next
[16:19:13.340]                             invokeRestart(restart)
[16:19:13.340]                             muffled <- TRUE
[16:19:13.340]                             break
[16:19:13.340]                           }
[16:19:13.340]                         }
[16:19:13.340]                       }
[16:19:13.340]                       invisible(muffled)
[16:19:13.340]                     }
[16:19:13.340]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.340]                   }
[16:19:13.340]                 }
[16:19:13.340]             }
[16:19:13.340]         }))
[16:19:13.340]     }, error = function(ex) {
[16:19:13.340]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.340]                 ...future.rng), started = ...future.startTime, 
[16:19:13.340]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.340]             version = "1.8"), class = "FutureResult")
[16:19:13.340]     }, finally = {
[16:19:13.340]         if (!identical(...future.workdir, getwd())) 
[16:19:13.340]             setwd(...future.workdir)
[16:19:13.340]         {
[16:19:13.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.340]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.340]             }
[16:19:13.340]             base::options(...future.oldOptions)
[16:19:13.340]             if (.Platform$OS.type == "windows") {
[16:19:13.340]                 old_names <- names(...future.oldEnvVars)
[16:19:13.340]                 envs <- base::Sys.getenv()
[16:19:13.340]                 names <- names(envs)
[16:19:13.340]                 common <- intersect(names, old_names)
[16:19:13.340]                 added <- setdiff(names, old_names)
[16:19:13.340]                 removed <- setdiff(old_names, names)
[16:19:13.340]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.340]                   envs[common]]
[16:19:13.340]                 NAMES <- toupper(changed)
[16:19:13.340]                 args <- list()
[16:19:13.340]                 for (kk in seq_along(NAMES)) {
[16:19:13.340]                   name <- changed[[kk]]
[16:19:13.340]                   NAME <- NAMES[[kk]]
[16:19:13.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.340]                     next
[16:19:13.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.340]                 }
[16:19:13.340]                 NAMES <- toupper(added)
[16:19:13.340]                 for (kk in seq_along(NAMES)) {
[16:19:13.340]                   name <- added[[kk]]
[16:19:13.340]                   NAME <- NAMES[[kk]]
[16:19:13.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.340]                     next
[16:19:13.340]                   args[[name]] <- ""
[16:19:13.340]                 }
[16:19:13.340]                 NAMES <- toupper(removed)
[16:19:13.340]                 for (kk in seq_along(NAMES)) {
[16:19:13.340]                   name <- removed[[kk]]
[16:19:13.340]                   NAME <- NAMES[[kk]]
[16:19:13.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.340]                     next
[16:19:13.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.340]                 }
[16:19:13.340]                 if (length(args) > 0) 
[16:19:13.340]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.340]             }
[16:19:13.340]             else {
[16:19:13.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.340]             }
[16:19:13.340]             {
[16:19:13.340]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.340]                   0L) {
[16:19:13.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.340]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.340]                   base::options(opts)
[16:19:13.340]                 }
[16:19:13.340]                 {
[16:19:13.340]                   {
[16:19:13.340]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.340]                     NULL
[16:19:13.340]                   }
[16:19:13.340]                   options(future.plan = NULL)
[16:19:13.340]                   if (is.na(NA_character_)) 
[16:19:13.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.340]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.340]                     .init = FALSE)
[16:19:13.340]                 }
[16:19:13.340]             }
[16:19:13.340]         }
[16:19:13.340]     })
[16:19:13.340]     if (TRUE) {
[16:19:13.340]         base::sink(type = "output", split = FALSE)
[16:19:13.340]         if (TRUE) {
[16:19:13.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.340]         }
[16:19:13.340]         else {
[16:19:13.340]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.340]         }
[16:19:13.340]         base::close(...future.stdout)
[16:19:13.340]         ...future.stdout <- NULL
[16:19:13.340]     }
[16:19:13.340]     ...future.result$conditions <- ...future.conditions
[16:19:13.340]     ...future.result$finished <- base::Sys.time()
[16:19:13.340]     ...future.result
[16:19:13.340] }
[16:19:13.344] assign_globals() ...
[16:19:13.344] List of 11
[16:19:13.344]  $ ...future.FUN            :function (x, ...)  
[16:19:13.344]  $ x_FUN                    :function (x)  
[16:19:13.344]  $ times                    : int 1
[16:19:13.344]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.344]  $ stop_if_not              :function (...)  
[16:19:13.344]  $ dim                      : NULL
[16:19:13.344]  $ valid_types              : chr "character"
[16:19:13.344]  $ future.call.arguments    : list()
[16:19:13.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.344]  $ ...future.elements_ii    :List of 1
[16:19:13.344]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[16:19:13.344]  $ ...future.seeds_ii       : NULL
[16:19:13.344]  $ ...future.globals.maxSize: NULL
[16:19:13.344]  - attr(*, "where")=List of 11
[16:19:13.344]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.344]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.344]  - attr(*, "resolved")= logi FALSE
[16:19:13.344]  - attr(*, "total_size")= num 94208
[16:19:13.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.344]  - attr(*, "already-done")= logi TRUE
[16:19:13.361] - copied ‘...future.FUN’ to environment
[16:19:13.362] - copied ‘x_FUN’ to environment
[16:19:13.362] - copied ‘times’ to environment
[16:19:13.362] - copied ‘stopf’ to environment
[16:19:13.362] - copied ‘stop_if_not’ to environment
[16:19:13.362] - copied ‘dim’ to environment
[16:19:13.362] - copied ‘valid_types’ to environment
[16:19:13.362] - copied ‘future.call.arguments’ to environment
[16:19:13.363] - copied ‘...future.elements_ii’ to environment
[16:19:13.363] - copied ‘...future.seeds_ii’ to environment
[16:19:13.363] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.363] assign_globals() ... done
[16:19:13.363] requestCore(): workers = 2
[16:19:13.368] MulticoreFuture started
[16:19:13.369] - Launch lazy future ... done
[16:19:13.369] run() for ‘MulticoreFuture’ ... done
[16:19:13.369] Created future:
[16:19:13.370] plan(): Setting new future strategy stack:
[16:19:13.370] List of future strategies:
[16:19:13.370] 1. sequential:
[16:19:13.370]    - args: function (..., envir = parent.frame())
[16:19:13.370]    - tweaked: FALSE
[16:19:13.370]    - call: NULL
[16:19:13.371] plan(): nbrOfWorkers() = 1
[16:19:13.373] plan(): Setting new future strategy stack:
[16:19:13.373] List of future strategies:
[16:19:13.373] 1. multicore:
[16:19:13.373]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.373]    - tweaked: FALSE
[16:19:13.373]    - call: plan(strategy)
[16:19:13.378] plan(): nbrOfWorkers() = 2
[16:19:13.370] MulticoreFuture:
[16:19:13.370] Label: ‘future_vapply-2’
[16:19:13.370] Expression:
[16:19:13.370] {
[16:19:13.370]     do.call(function(...) {
[16:19:13.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.370]             on.exit(options(oopts), add = TRUE)
[16:19:13.370]         }
[16:19:13.370]         {
[16:19:13.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.370]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.370]             })
[16:19:13.370]         }
[16:19:13.370]     }, args = future.call.arguments)
[16:19:13.370] }
[16:19:13.370] Lazy evaluation: FALSE
[16:19:13.370] Asynchronous evaluation: TRUE
[16:19:13.370] Local evaluation: TRUE
[16:19:13.370] Environment: R_GlobalEnv
[16:19:13.370] Capture standard output: TRUE
[16:19:13.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.370] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.370] Packages: 1 packages (‘future.apply’)
[16:19:13.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.370] Resolved: TRUE
[16:19:13.370] Value: <not collected>
[16:19:13.370] Conditions captured: <none>
[16:19:13.370] Early signaling: FALSE
[16:19:13.370] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.370] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.379] Chunk #2 of 2 ... DONE
[16:19:13.380] Launching 2 futures (chunks) ... DONE
[16:19:13.380] Resolving 2 futures (chunks) ...
[16:19:13.380] resolve() on list ...
[16:19:13.380]  recursive: 0
[16:19:13.380]  length: 2
[16:19:13.380] 
[16:19:13.381] Future #1
[16:19:13.381] result() for MulticoreFuture ...
[16:19:13.383] result() for MulticoreFuture ...
[16:19:13.383] result() for MulticoreFuture ... done
[16:19:13.383] result() for MulticoreFuture ... done
[16:19:13.384] result() for MulticoreFuture ...
[16:19:13.384] result() for MulticoreFuture ... done
[16:19:13.384] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:13.384] - nx: 2
[16:19:13.384] - relay: TRUE
[16:19:13.384] - stdout: TRUE
[16:19:13.384] - signal: TRUE
[16:19:13.385] - resignal: FALSE
[16:19:13.385] - force: TRUE
[16:19:13.385] - relayed: [n=2] FALSE, FALSE
[16:19:13.385] - queued futures: [n=2] FALSE, FALSE
[16:19:13.385]  - until=1
[16:19:13.385]  - relaying element #1
[16:19:13.385] result() for MulticoreFuture ...
[16:19:13.386] result() for MulticoreFuture ... done
[16:19:13.386] result() for MulticoreFuture ...
[16:19:13.386] result() for MulticoreFuture ... done
[16:19:13.386] result() for MulticoreFuture ...
[16:19:13.386] result() for MulticoreFuture ... done
[16:19:13.386] result() for MulticoreFuture ...
[16:19:13.387] result() for MulticoreFuture ... done
[16:19:13.387] - relayed: [n=2] TRUE, FALSE
[16:19:13.387] - queued futures: [n=2] TRUE, FALSE
[16:19:13.387] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:13.387]  length: 1 (resolved future 1)
[16:19:13.388] Future #2
[16:19:13.388] result() for MulticoreFuture ...
[16:19:13.388] result() for MulticoreFuture ...
[16:19:13.388] result() for MulticoreFuture ... done
[16:19:13.389] result() for MulticoreFuture ... done
[16:19:13.389] result() for MulticoreFuture ...
[16:19:13.389] result() for MulticoreFuture ... done
[16:19:13.389] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:13.389] - nx: 2
[16:19:13.389] - relay: TRUE
[16:19:13.389] - stdout: TRUE
[16:19:13.390] - signal: TRUE
[16:19:13.390] - resignal: FALSE
[16:19:13.390] - force: TRUE
[16:19:13.390] - relayed: [n=2] TRUE, FALSE
[16:19:13.390] - queued futures: [n=2] TRUE, FALSE
[16:19:13.390]  - until=2
[16:19:13.390]  - relaying element #2
[16:19:13.390] result() for MulticoreFuture ...
[16:19:13.391] result() for MulticoreFuture ... done
[16:19:13.391] result() for MulticoreFuture ...
[16:19:13.391] result() for MulticoreFuture ... done
[16:19:13.393] result() for MulticoreFuture ...
[16:19:13.394] result() for MulticoreFuture ... done
[16:19:13.394] result() for MulticoreFuture ...
[16:19:13.394] result() for MulticoreFuture ... done
[16:19:13.394] - relayed: [n=2] TRUE, TRUE
[16:19:13.394] - queued futures: [n=2] TRUE, TRUE
[16:19:13.394] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:13.395]  length: 0 (resolved future 2)
[16:19:13.395] Relaying remaining futures
[16:19:13.395] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.395] - nx: 2
[16:19:13.395] - relay: TRUE
[16:19:13.395] - stdout: TRUE
[16:19:13.396] - signal: TRUE
[16:19:13.396] - resignal: FALSE
[16:19:13.396] - force: TRUE
[16:19:13.396] - relayed: [n=2] TRUE, TRUE
[16:19:13.396] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:13.397] - relayed: [n=2] TRUE, TRUE
[16:19:13.397] - queued futures: [n=2] TRUE, TRUE
[16:19:13.397] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.397] resolve() on list ... DONE
[16:19:13.397] result() for MulticoreFuture ...
[16:19:13.397] result() for MulticoreFuture ... done
[16:19:13.398] result() for MulticoreFuture ...
[16:19:13.398] result() for MulticoreFuture ... done
[16:19:13.398] result() for MulticoreFuture ...
[16:19:13.398] result() for MulticoreFuture ... done
[16:19:13.398] result() for MulticoreFuture ...
[16:19:13.398] result() for MulticoreFuture ... done
[16:19:13.399]  - Number of value chunks collected: 2
[16:19:13.399] Resolving 2 futures (chunks) ... DONE
[16:19:13.399] Reducing values from 2 chunks ...
[16:19:13.399]  - Number of values collected after concatenation: 2
[16:19:13.399]  - Number of values expected: 2
[16:19:13.399] Reducing values from 2 chunks ... DONE
[16:19:13.399] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:19:13.401] future_lapply() ...
[16:19:13.407] Number of chunks: 2
[16:19:13.407] getGlobalsAndPackagesXApply() ...
[16:19:13.408]  - future.globals: TRUE
[16:19:13.408] getGlobalsAndPackages() ...
[16:19:13.408] Searching for globals...
[16:19:13.412] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:19:13.412] Searching for globals ... DONE
[16:19:13.412] Resolving globals: FALSE
[16:19:13.413] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:19:13.413] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.413] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.414] - packages: [1] ‘future.apply’
[16:19:13.414] getGlobalsAndPackages() ... DONE
[16:19:13.414]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.414]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.414] Finding globals ... DONE
[16:19:13.414]  - use_args: TRUE
[16:19:13.414]  - Getting '...' globals ...
[16:19:13.415] resolve() on list ...
[16:19:13.415]  recursive: 0
[16:19:13.415]  length: 1
[16:19:13.415]  elements: ‘...’
[16:19:13.415]  length: 0 (resolved future 1)
[16:19:13.415] resolve() on list ... DONE
[16:19:13.415]    - '...' content: [n=0] 
[16:19:13.415] List of 1
[16:19:13.415]  $ ...: list()
[16:19:13.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.415]  - attr(*, "where")=List of 1
[16:19:13.415]   ..$ ...:<environment: 0x56199e586fc8> 
[16:19:13.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.415]  - attr(*, "resolved")= logi TRUE
[16:19:13.415]  - attr(*, "total_size")= num NA
[16:19:13.418]  - Getting '...' globals ... DONE
[16:19:13.418] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.418] List of 8
[16:19:13.418]  $ ...future.FUN:function (x, ...)  
[16:19:13.418]  $ x_FUN        :function (x)  
[16:19:13.418]  $ times        : int 0
[16:19:13.418]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.418]  $ stop_if_not  :function (...)  
[16:19:13.418]  $ dim          : NULL
[16:19:13.418]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:13.418]  $ ...          : list()
[16:19:13.418]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.418]  - attr(*, "where")=List of 8
[16:19:13.418]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.418]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.418]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.418]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.418]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.418]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.418]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.418]   ..$ ...          :<environment: 0x56199e586fc8> 
[16:19:13.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.418]  - attr(*, "resolved")= logi FALSE
[16:19:13.418]  - attr(*, "total_size")= num 95472
[16:19:13.426] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.426] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.426] Number of futures (= number of chunks): 2
[16:19:13.426] Launching 2 futures (chunks) ...
[16:19:13.426] Chunk #1 of 2 ...
[16:19:13.426]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.427] getGlobalsAndPackages() ...
[16:19:13.427] Searching for globals...
[16:19:13.427] 
[16:19:13.427] Searching for globals ... DONE
[16:19:13.427] - globals: [0] <none>
[16:19:13.427] getGlobalsAndPackages() ... DONE
[16:19:13.427]    + additional globals found: [n=0] 
[16:19:13.427]    + additional namespaces needed: [n=0] 
[16:19:13.427]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.428]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.428]  - seeds: <none>
[16:19:13.428]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.428] getGlobalsAndPackages() ...
[16:19:13.428] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.428] Resolving globals: FALSE
[16:19:13.428] Tweak future expression to call with '...' arguments ...
[16:19:13.428] {
[16:19:13.428]     do.call(function(...) {
[16:19:13.428]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.428]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.428]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.428]             on.exit(options(oopts), add = TRUE)
[16:19:13.428]         }
[16:19:13.428]         {
[16:19:13.428]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.428]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.428]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.428]             })
[16:19:13.428]         }
[16:19:13.428]     }, args = future.call.arguments)
[16:19:13.428] }
[16:19:13.429] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.429] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.429] - packages: [1] ‘future.apply’
[16:19:13.429] getGlobalsAndPackages() ... DONE
[16:19:13.430] run() for ‘Future’ ...
[16:19:13.430] - state: ‘created’
[16:19:13.430] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.434] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.434] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.434]   - Field: ‘label’
[16:19:13.434]   - Field: ‘local’
[16:19:13.434]   - Field: ‘owner’
[16:19:13.434]   - Field: ‘envir’
[16:19:13.434]   - Field: ‘workers’
[16:19:13.434]   - Field: ‘packages’
[16:19:13.434]   - Field: ‘gc’
[16:19:13.435]   - Field: ‘job’
[16:19:13.435]   - Field: ‘conditions’
[16:19:13.435]   - Field: ‘expr’
[16:19:13.435]   - Field: ‘uuid’
[16:19:13.435]   - Field: ‘seed’
[16:19:13.435]   - Field: ‘version’
[16:19:13.435]   - Field: ‘result’
[16:19:13.435]   - Field: ‘asynchronous’
[16:19:13.435]   - Field: ‘calls’
[16:19:13.435]   - Field: ‘globals’
[16:19:13.435]   - Field: ‘stdout’
[16:19:13.436]   - Field: ‘earlySignal’
[16:19:13.436]   - Field: ‘lazy’
[16:19:13.436]   - Field: ‘state’
[16:19:13.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.436] - Launch lazy future ...
[16:19:13.436] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.436] Packages needed by future strategies (n = 0): <none>
[16:19:13.437] {
[16:19:13.437]     {
[16:19:13.437]         {
[16:19:13.437]             ...future.startTime <- base::Sys.time()
[16:19:13.437]             {
[16:19:13.437]                 {
[16:19:13.437]                   {
[16:19:13.437]                     {
[16:19:13.437]                       {
[16:19:13.437]                         base::local({
[16:19:13.437]                           has_future <- base::requireNamespace("future", 
[16:19:13.437]                             quietly = TRUE)
[16:19:13.437]                           if (has_future) {
[16:19:13.437]                             ns <- base::getNamespace("future")
[16:19:13.437]                             version <- ns[[".package"]][["version"]]
[16:19:13.437]                             if (is.null(version)) 
[16:19:13.437]                               version <- utils::packageVersion("future")
[16:19:13.437]                           }
[16:19:13.437]                           else {
[16:19:13.437]                             version <- NULL
[16:19:13.437]                           }
[16:19:13.437]                           if (!has_future || version < "1.8.0") {
[16:19:13.437]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.437]                               "", base::R.version$version.string), 
[16:19:13.437]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.437]                                 base::R.version$platform, 8 * 
[16:19:13.437]                                   base::.Machine$sizeof.pointer), 
[16:19:13.437]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.437]                                 "release", "version")], collapse = " "), 
[16:19:13.437]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.437]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.437]                               info)
[16:19:13.437]                             info <- base::paste(info, collapse = "; ")
[16:19:13.437]                             if (!has_future) {
[16:19:13.437]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.437]                                 info)
[16:19:13.437]                             }
[16:19:13.437]                             else {
[16:19:13.437]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.437]                                 info, version)
[16:19:13.437]                             }
[16:19:13.437]                             base::stop(msg)
[16:19:13.437]                           }
[16:19:13.437]                         })
[16:19:13.437]                       }
[16:19:13.437]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.437]                       base::options(mc.cores = 1L)
[16:19:13.437]                     }
[16:19:13.437]                     base::local({
[16:19:13.437]                       for (pkg in "future.apply") {
[16:19:13.437]                         base::loadNamespace(pkg)
[16:19:13.437]                         base::library(pkg, character.only = TRUE)
[16:19:13.437]                       }
[16:19:13.437]                     })
[16:19:13.437]                   }
[16:19:13.437]                   ...future.strategy.old <- future::plan("list")
[16:19:13.437]                   options(future.plan = NULL)
[16:19:13.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.437]                 }
[16:19:13.437]                 ...future.workdir <- getwd()
[16:19:13.437]             }
[16:19:13.437]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.437]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.437]         }
[16:19:13.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.437]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.437]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.437]             base::names(...future.oldOptions))
[16:19:13.437]     }
[16:19:13.437]     if (FALSE) {
[16:19:13.437]     }
[16:19:13.437]     else {
[16:19:13.437]         if (TRUE) {
[16:19:13.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.437]                 open = "w")
[16:19:13.437]         }
[16:19:13.437]         else {
[16:19:13.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.437]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.437]         }
[16:19:13.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.437]             base::sink(type = "output", split = FALSE)
[16:19:13.437]             base::close(...future.stdout)
[16:19:13.437]         }, add = TRUE)
[16:19:13.437]     }
[16:19:13.437]     ...future.frame <- base::sys.nframe()
[16:19:13.437]     ...future.conditions <- base::list()
[16:19:13.437]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.437]     if (FALSE) {
[16:19:13.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.437]     }
[16:19:13.437]     ...future.result <- base::tryCatch({
[16:19:13.437]         base::withCallingHandlers({
[16:19:13.437]             ...future.value <- base::withVisible(base::local({
[16:19:13.437]                 withCallingHandlers({
[16:19:13.437]                   {
[16:19:13.437]                     do.call(function(...) {
[16:19:13.437]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.437]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.437]                         ...future.globals.maxSize)) {
[16:19:13.437]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.437]                         on.exit(options(oopts), add = TRUE)
[16:19:13.437]                       }
[16:19:13.437]                       {
[16:19:13.437]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.437]                           FUN = function(jj) {
[16:19:13.437]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.437]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.437]                           })
[16:19:13.437]                       }
[16:19:13.437]                     }, args = future.call.arguments)
[16:19:13.437]                   }
[16:19:13.437]                 }, immediateCondition = function(cond) {
[16:19:13.437]                   save_rds <- function (object, pathname, ...) 
[16:19:13.437]                   {
[16:19:13.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.437]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.437]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.437]                         fi_tmp[["mtime"]])
[16:19:13.437]                     }
[16:19:13.437]                     tryCatch({
[16:19:13.437]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.437]                     }, error = function(ex) {
[16:19:13.437]                       msg <- conditionMessage(ex)
[16:19:13.437]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.437]                         fi_tmp[["mtime"]], msg)
[16:19:13.437]                       ex$message <- msg
[16:19:13.437]                       stop(ex)
[16:19:13.437]                     })
[16:19:13.437]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.437]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.437]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.437]                       fi <- file.info(pathname)
[16:19:13.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.437]                         fi[["size"]], fi[["mtime"]])
[16:19:13.437]                       stop(msg)
[16:19:13.437]                     }
[16:19:13.437]                     invisible(pathname)
[16:19:13.437]                   }
[16:19:13.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.437]                     rootPath = tempdir()) 
[16:19:13.437]                   {
[16:19:13.437]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.437]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.437]                       tmpdir = path, fileext = ".rds")
[16:19:13.437]                     save_rds(obj, file)
[16:19:13.437]                   }
[16:19:13.437]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.437]                   {
[16:19:13.437]                     inherits <- base::inherits
[16:19:13.437]                     invokeRestart <- base::invokeRestart
[16:19:13.437]                     is.null <- base::is.null
[16:19:13.437]                     muffled <- FALSE
[16:19:13.437]                     if (inherits(cond, "message")) {
[16:19:13.437]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.437]                       if (muffled) 
[16:19:13.437]                         invokeRestart("muffleMessage")
[16:19:13.437]                     }
[16:19:13.437]                     else if (inherits(cond, "warning")) {
[16:19:13.437]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.437]                       if (muffled) 
[16:19:13.437]                         invokeRestart("muffleWarning")
[16:19:13.437]                     }
[16:19:13.437]                     else if (inherits(cond, "condition")) {
[16:19:13.437]                       if (!is.null(pattern)) {
[16:19:13.437]                         computeRestarts <- base::computeRestarts
[16:19:13.437]                         grepl <- base::grepl
[16:19:13.437]                         restarts <- computeRestarts(cond)
[16:19:13.437]                         for (restart in restarts) {
[16:19:13.437]                           name <- restart$name
[16:19:13.437]                           if (is.null(name)) 
[16:19:13.437]                             next
[16:19:13.437]                           if (!grepl(pattern, name)) 
[16:19:13.437]                             next
[16:19:13.437]                           invokeRestart(restart)
[16:19:13.437]                           muffled <- TRUE
[16:19:13.437]                           break
[16:19:13.437]                         }
[16:19:13.437]                       }
[16:19:13.437]                     }
[16:19:13.437]                     invisible(muffled)
[16:19:13.437]                   }
[16:19:13.437]                   muffleCondition(cond)
[16:19:13.437]                 })
[16:19:13.437]             }))
[16:19:13.437]             future::FutureResult(value = ...future.value$value, 
[16:19:13.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.437]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.437]                     ...future.globalenv.names))
[16:19:13.437]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.437]         }, condition = base::local({
[16:19:13.437]             c <- base::c
[16:19:13.437]             inherits <- base::inherits
[16:19:13.437]             invokeRestart <- base::invokeRestart
[16:19:13.437]             length <- base::length
[16:19:13.437]             list <- base::list
[16:19:13.437]             seq.int <- base::seq.int
[16:19:13.437]             signalCondition <- base::signalCondition
[16:19:13.437]             sys.calls <- base::sys.calls
[16:19:13.437]             `[[` <- base::`[[`
[16:19:13.437]             `+` <- base::`+`
[16:19:13.437]             `<<-` <- base::`<<-`
[16:19:13.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.437]                   3L)]
[16:19:13.437]             }
[16:19:13.437]             function(cond) {
[16:19:13.437]                 is_error <- inherits(cond, "error")
[16:19:13.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.437]                   NULL)
[16:19:13.437]                 if (is_error) {
[16:19:13.437]                   sessionInformation <- function() {
[16:19:13.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.437]                       search = base::search(), system = base::Sys.info())
[16:19:13.437]                   }
[16:19:13.437]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.437]                     cond$call), session = sessionInformation(), 
[16:19:13.437]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.437]                   signalCondition(cond)
[16:19:13.437]                 }
[16:19:13.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.437]                 "immediateCondition"))) {
[16:19:13.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.437]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.437]                   if (TRUE && !signal) {
[16:19:13.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.437]                     {
[16:19:13.437]                       inherits <- base::inherits
[16:19:13.437]                       invokeRestart <- base::invokeRestart
[16:19:13.437]                       is.null <- base::is.null
[16:19:13.437]                       muffled <- FALSE
[16:19:13.437]                       if (inherits(cond, "message")) {
[16:19:13.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.437]                         if (muffled) 
[16:19:13.437]                           invokeRestart("muffleMessage")
[16:19:13.437]                       }
[16:19:13.437]                       else if (inherits(cond, "warning")) {
[16:19:13.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.437]                         if (muffled) 
[16:19:13.437]                           invokeRestart("muffleWarning")
[16:19:13.437]                       }
[16:19:13.437]                       else if (inherits(cond, "condition")) {
[16:19:13.437]                         if (!is.null(pattern)) {
[16:19:13.437]                           computeRestarts <- base::computeRestarts
[16:19:13.437]                           grepl <- base::grepl
[16:19:13.437]                           restarts <- computeRestarts(cond)
[16:19:13.437]                           for (restart in restarts) {
[16:19:13.437]                             name <- restart$name
[16:19:13.437]                             if (is.null(name)) 
[16:19:13.437]                               next
[16:19:13.437]                             if (!grepl(pattern, name)) 
[16:19:13.437]                               next
[16:19:13.437]                             invokeRestart(restart)
[16:19:13.437]                             muffled <- TRUE
[16:19:13.437]                             break
[16:19:13.437]                           }
[16:19:13.437]                         }
[16:19:13.437]                       }
[16:19:13.437]                       invisible(muffled)
[16:19:13.437]                     }
[16:19:13.437]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.437]                   }
[16:19:13.437]                 }
[16:19:13.437]                 else {
[16:19:13.437]                   if (TRUE) {
[16:19:13.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.437]                     {
[16:19:13.437]                       inherits <- base::inherits
[16:19:13.437]                       invokeRestart <- base::invokeRestart
[16:19:13.437]                       is.null <- base::is.null
[16:19:13.437]                       muffled <- FALSE
[16:19:13.437]                       if (inherits(cond, "message")) {
[16:19:13.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.437]                         if (muffled) 
[16:19:13.437]                           invokeRestart("muffleMessage")
[16:19:13.437]                       }
[16:19:13.437]                       else if (inherits(cond, "warning")) {
[16:19:13.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.437]                         if (muffled) 
[16:19:13.437]                           invokeRestart("muffleWarning")
[16:19:13.437]                       }
[16:19:13.437]                       else if (inherits(cond, "condition")) {
[16:19:13.437]                         if (!is.null(pattern)) {
[16:19:13.437]                           computeRestarts <- base::computeRestarts
[16:19:13.437]                           grepl <- base::grepl
[16:19:13.437]                           restarts <- computeRestarts(cond)
[16:19:13.437]                           for (restart in restarts) {
[16:19:13.437]                             name <- restart$name
[16:19:13.437]                             if (is.null(name)) 
[16:19:13.437]                               next
[16:19:13.437]                             if (!grepl(pattern, name)) 
[16:19:13.437]                               next
[16:19:13.437]                             invokeRestart(restart)
[16:19:13.437]                             muffled <- TRUE
[16:19:13.437]                             break
[16:19:13.437]                           }
[16:19:13.437]                         }
[16:19:13.437]                       }
[16:19:13.437]                       invisible(muffled)
[16:19:13.437]                     }
[16:19:13.437]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.437]                   }
[16:19:13.437]                 }
[16:19:13.437]             }
[16:19:13.437]         }))
[16:19:13.437]     }, error = function(ex) {
[16:19:13.437]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.437]                 ...future.rng), started = ...future.startTime, 
[16:19:13.437]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.437]             version = "1.8"), class = "FutureResult")
[16:19:13.437]     }, finally = {
[16:19:13.437]         if (!identical(...future.workdir, getwd())) 
[16:19:13.437]             setwd(...future.workdir)
[16:19:13.437]         {
[16:19:13.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.437]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.437]             }
[16:19:13.437]             base::options(...future.oldOptions)
[16:19:13.437]             if (.Platform$OS.type == "windows") {
[16:19:13.437]                 old_names <- names(...future.oldEnvVars)
[16:19:13.437]                 envs <- base::Sys.getenv()
[16:19:13.437]                 names <- names(envs)
[16:19:13.437]                 common <- intersect(names, old_names)
[16:19:13.437]                 added <- setdiff(names, old_names)
[16:19:13.437]                 removed <- setdiff(old_names, names)
[16:19:13.437]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.437]                   envs[common]]
[16:19:13.437]                 NAMES <- toupper(changed)
[16:19:13.437]                 args <- list()
[16:19:13.437]                 for (kk in seq_along(NAMES)) {
[16:19:13.437]                   name <- changed[[kk]]
[16:19:13.437]                   NAME <- NAMES[[kk]]
[16:19:13.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.437]                     next
[16:19:13.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.437]                 }
[16:19:13.437]                 NAMES <- toupper(added)
[16:19:13.437]                 for (kk in seq_along(NAMES)) {
[16:19:13.437]                   name <- added[[kk]]
[16:19:13.437]                   NAME <- NAMES[[kk]]
[16:19:13.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.437]                     next
[16:19:13.437]                   args[[name]] <- ""
[16:19:13.437]                 }
[16:19:13.437]                 NAMES <- toupper(removed)
[16:19:13.437]                 for (kk in seq_along(NAMES)) {
[16:19:13.437]                   name <- removed[[kk]]
[16:19:13.437]                   NAME <- NAMES[[kk]]
[16:19:13.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.437]                     next
[16:19:13.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.437]                 }
[16:19:13.437]                 if (length(args) > 0) 
[16:19:13.437]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.437]             }
[16:19:13.437]             else {
[16:19:13.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.437]             }
[16:19:13.437]             {
[16:19:13.437]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.437]                   0L) {
[16:19:13.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.437]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.437]                   base::options(opts)
[16:19:13.437]                 }
[16:19:13.437]                 {
[16:19:13.437]                   {
[16:19:13.437]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.437]                     NULL
[16:19:13.437]                   }
[16:19:13.437]                   options(future.plan = NULL)
[16:19:13.437]                   if (is.na(NA_character_)) 
[16:19:13.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.437]                     .init = FALSE)
[16:19:13.437]                 }
[16:19:13.437]             }
[16:19:13.437]         }
[16:19:13.437]     })
[16:19:13.437]     if (TRUE) {
[16:19:13.437]         base::sink(type = "output", split = FALSE)
[16:19:13.437]         if (TRUE) {
[16:19:13.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.437]         }
[16:19:13.437]         else {
[16:19:13.437]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.437]         }
[16:19:13.437]         base::close(...future.stdout)
[16:19:13.437]         ...future.stdout <- NULL
[16:19:13.437]     }
[16:19:13.437]     ...future.result$conditions <- ...future.conditions
[16:19:13.437]     ...future.result$finished <- base::Sys.time()
[16:19:13.437]     ...future.result
[16:19:13.437] }
[16:19:13.439] assign_globals() ...
[16:19:13.439] List of 11
[16:19:13.439]  $ ...future.FUN            :function (x, ...)  
[16:19:13.439]  $ x_FUN                    :function (x)  
[16:19:13.439]  $ times                    : int 0
[16:19:13.439]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.439]  $ stop_if_not              :function (...)  
[16:19:13.439]  $ dim                      : NULL
[16:19:13.439]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.439]  $ future.call.arguments    : list()
[16:19:13.439]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.439]  $ ...future.elements_ii    :List of 5
[16:19:13.439]   ..$ : int 1
[16:19:13.439]   ..$ : int 2
[16:19:13.439]   ..$ : int 3
[16:19:13.439]   ..$ : int 4
[16:19:13.439]   ..$ : int 5
[16:19:13.439]  $ ...future.seeds_ii       : NULL
[16:19:13.439]  $ ...future.globals.maxSize: NULL
[16:19:13.439]  - attr(*, "where")=List of 11
[16:19:13.439]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.439]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.439]  - attr(*, "resolved")= logi FALSE
[16:19:13.439]  - attr(*, "total_size")= num 95472
[16:19:13.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.439]  - attr(*, "already-done")= logi TRUE
[16:19:13.449] - copied ‘...future.FUN’ to environment
[16:19:13.449] - reassign environment for ‘x_FUN’
[16:19:13.450] - copied ‘x_FUN’ to environment
[16:19:13.450] - copied ‘times’ to environment
[16:19:13.450] - copied ‘stopf’ to environment
[16:19:13.450] - copied ‘stop_if_not’ to environment
[16:19:13.450] - copied ‘dim’ to environment
[16:19:13.450] - copied ‘valid_types’ to environment
[16:19:13.450] - copied ‘future.call.arguments’ to environment
[16:19:13.450] - copied ‘...future.elements_ii’ to environment
[16:19:13.450] - copied ‘...future.seeds_ii’ to environment
[16:19:13.450] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.451] assign_globals() ... done
[16:19:13.451] requestCore(): workers = 2
[16:19:13.453] MulticoreFuture started
[16:19:13.453] - Launch lazy future ... done
[16:19:13.454] run() for ‘MulticoreFuture’ ... done
[16:19:13.454] Created future:
[16:19:13.455] plan(): Setting new future strategy stack:
[16:19:13.455] List of future strategies:
[16:19:13.455] 1. sequential:
[16:19:13.455]    - args: function (..., envir = parent.frame())
[16:19:13.455]    - tweaked: FALSE
[16:19:13.455]    - call: NULL
[16:19:13.456] plan(): nbrOfWorkers() = 1
[16:19:13.458] plan(): Setting new future strategy stack:
[16:19:13.458] List of future strategies:
[16:19:13.458] 1. multicore:
[16:19:13.458]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.458]    - tweaked: FALSE
[16:19:13.458]    - call: plan(strategy)
[16:19:13.464] plan(): nbrOfWorkers() = 2
[16:19:13.455] MulticoreFuture:
[16:19:13.455] Label: ‘future_vapply-1’
[16:19:13.455] Expression:
[16:19:13.455] {
[16:19:13.455]     do.call(function(...) {
[16:19:13.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.455]             on.exit(options(oopts), add = TRUE)
[16:19:13.455]         }
[16:19:13.455]         {
[16:19:13.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.455]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.455]             })
[16:19:13.455]         }
[16:19:13.455]     }, args = future.call.arguments)
[16:19:13.455] }
[16:19:13.455] Lazy evaluation: FALSE
[16:19:13.455] Asynchronous evaluation: TRUE
[16:19:13.455] Local evaluation: TRUE
[16:19:13.455] Environment: R_GlobalEnv
[16:19:13.455] Capture standard output: TRUE
[16:19:13.455] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.455] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.455] Packages: 1 packages (‘future.apply’)
[16:19:13.455] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.455] Resolved: TRUE
[16:19:13.455] Value: <not collected>
[16:19:13.455] Conditions captured: <none>
[16:19:13.455] Early signaling: FALSE
[16:19:13.455] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.455] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.466] Chunk #1 of 2 ... DONE
[16:19:13.466] Chunk #2 of 2 ...
[16:19:13.466]  - Finding globals in 'X' for chunk #2 ...
[16:19:13.466] getGlobalsAndPackages() ...
[16:19:13.466] Searching for globals...
[16:19:13.467] 
[16:19:13.467] Searching for globals ... DONE
[16:19:13.467] - globals: [0] <none>
[16:19:13.467] getGlobalsAndPackages() ... DONE
[16:19:13.468]    + additional globals found: [n=0] 
[16:19:13.468]    + additional namespaces needed: [n=0] 
[16:19:13.468]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:13.468]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.468]  - seeds: <none>
[16:19:13.468]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.469] getGlobalsAndPackages() ...
[16:19:13.469] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.469] Resolving globals: FALSE
[16:19:13.469] Tweak future expression to call with '...' arguments ...
[16:19:13.469] {
[16:19:13.469]     do.call(function(...) {
[16:19:13.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.469]             on.exit(options(oopts), add = TRUE)
[16:19:13.469]         }
[16:19:13.469]         {
[16:19:13.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.469]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.469]             })
[16:19:13.469]         }
[16:19:13.469]     }, args = future.call.arguments)
[16:19:13.469] }
[16:19:13.470] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.471] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.471] - packages: [1] ‘future.apply’
[16:19:13.471] getGlobalsAndPackages() ... DONE
[16:19:13.472] run() for ‘Future’ ...
[16:19:13.472] - state: ‘created’
[16:19:13.472] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.477] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.477]   - Field: ‘label’
[16:19:13.477]   - Field: ‘local’
[16:19:13.478]   - Field: ‘owner’
[16:19:13.478]   - Field: ‘envir’
[16:19:13.478]   - Field: ‘workers’
[16:19:13.478]   - Field: ‘packages’
[16:19:13.478]   - Field: ‘gc’
[16:19:13.478]   - Field: ‘job’
[16:19:13.478]   - Field: ‘conditions’
[16:19:13.479]   - Field: ‘expr’
[16:19:13.479]   - Field: ‘uuid’
[16:19:13.479]   - Field: ‘seed’
[16:19:13.479]   - Field: ‘version’
[16:19:13.479]   - Field: ‘result’
[16:19:13.479]   - Field: ‘asynchronous’
[16:19:13.479]   - Field: ‘calls’
[16:19:13.480]   - Field: ‘globals’
[16:19:13.480]   - Field: ‘stdout’
[16:19:13.480]   - Field: ‘earlySignal’
[16:19:13.480]   - Field: ‘lazy’
[16:19:13.480]   - Field: ‘state’
[16:19:13.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.480] - Launch lazy future ...
[16:19:13.481] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.481] Packages needed by future strategies (n = 0): <none>
[16:19:13.482] {
[16:19:13.482]     {
[16:19:13.482]         {
[16:19:13.482]             ...future.startTime <- base::Sys.time()
[16:19:13.482]             {
[16:19:13.482]                 {
[16:19:13.482]                   {
[16:19:13.482]                     {
[16:19:13.482]                       {
[16:19:13.482]                         base::local({
[16:19:13.482]                           has_future <- base::requireNamespace("future", 
[16:19:13.482]                             quietly = TRUE)
[16:19:13.482]                           if (has_future) {
[16:19:13.482]                             ns <- base::getNamespace("future")
[16:19:13.482]                             version <- ns[[".package"]][["version"]]
[16:19:13.482]                             if (is.null(version)) 
[16:19:13.482]                               version <- utils::packageVersion("future")
[16:19:13.482]                           }
[16:19:13.482]                           else {
[16:19:13.482]                             version <- NULL
[16:19:13.482]                           }
[16:19:13.482]                           if (!has_future || version < "1.8.0") {
[16:19:13.482]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.482]                               "", base::R.version$version.string), 
[16:19:13.482]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.482]                                 base::R.version$platform, 8 * 
[16:19:13.482]                                   base::.Machine$sizeof.pointer), 
[16:19:13.482]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.482]                                 "release", "version")], collapse = " "), 
[16:19:13.482]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.482]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.482]                               info)
[16:19:13.482]                             info <- base::paste(info, collapse = "; ")
[16:19:13.482]                             if (!has_future) {
[16:19:13.482]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.482]                                 info)
[16:19:13.482]                             }
[16:19:13.482]                             else {
[16:19:13.482]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.482]                                 info, version)
[16:19:13.482]                             }
[16:19:13.482]                             base::stop(msg)
[16:19:13.482]                           }
[16:19:13.482]                         })
[16:19:13.482]                       }
[16:19:13.482]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.482]                       base::options(mc.cores = 1L)
[16:19:13.482]                     }
[16:19:13.482]                     base::local({
[16:19:13.482]                       for (pkg in "future.apply") {
[16:19:13.482]                         base::loadNamespace(pkg)
[16:19:13.482]                         base::library(pkg, character.only = TRUE)
[16:19:13.482]                       }
[16:19:13.482]                     })
[16:19:13.482]                   }
[16:19:13.482]                   ...future.strategy.old <- future::plan("list")
[16:19:13.482]                   options(future.plan = NULL)
[16:19:13.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.482]                 }
[16:19:13.482]                 ...future.workdir <- getwd()
[16:19:13.482]             }
[16:19:13.482]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.482]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.482]         }
[16:19:13.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.482]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.482]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.482]             base::names(...future.oldOptions))
[16:19:13.482]     }
[16:19:13.482]     if (FALSE) {
[16:19:13.482]     }
[16:19:13.482]     else {
[16:19:13.482]         if (TRUE) {
[16:19:13.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.482]                 open = "w")
[16:19:13.482]         }
[16:19:13.482]         else {
[16:19:13.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.482]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.482]         }
[16:19:13.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.482]             base::sink(type = "output", split = FALSE)
[16:19:13.482]             base::close(...future.stdout)
[16:19:13.482]         }, add = TRUE)
[16:19:13.482]     }
[16:19:13.482]     ...future.frame <- base::sys.nframe()
[16:19:13.482]     ...future.conditions <- base::list()
[16:19:13.482]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.482]     if (FALSE) {
[16:19:13.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.482]     }
[16:19:13.482]     ...future.result <- base::tryCatch({
[16:19:13.482]         base::withCallingHandlers({
[16:19:13.482]             ...future.value <- base::withVisible(base::local({
[16:19:13.482]                 withCallingHandlers({
[16:19:13.482]                   {
[16:19:13.482]                     do.call(function(...) {
[16:19:13.482]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.482]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.482]                         ...future.globals.maxSize)) {
[16:19:13.482]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.482]                         on.exit(options(oopts), add = TRUE)
[16:19:13.482]                       }
[16:19:13.482]                       {
[16:19:13.482]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.482]                           FUN = function(jj) {
[16:19:13.482]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.482]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.482]                           })
[16:19:13.482]                       }
[16:19:13.482]                     }, args = future.call.arguments)
[16:19:13.482]                   }
[16:19:13.482]                 }, immediateCondition = function(cond) {
[16:19:13.482]                   save_rds <- function (object, pathname, ...) 
[16:19:13.482]                   {
[16:19:13.482]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.482]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.482]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.482]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.482]                         fi_tmp[["mtime"]])
[16:19:13.482]                     }
[16:19:13.482]                     tryCatch({
[16:19:13.482]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.482]                     }, error = function(ex) {
[16:19:13.482]                       msg <- conditionMessage(ex)
[16:19:13.482]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.482]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.482]                         fi_tmp[["mtime"]], msg)
[16:19:13.482]                       ex$message <- msg
[16:19:13.482]                       stop(ex)
[16:19:13.482]                     })
[16:19:13.482]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.482]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.482]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.482]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.482]                       fi <- file.info(pathname)
[16:19:13.482]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.482]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.482]                         fi[["size"]], fi[["mtime"]])
[16:19:13.482]                       stop(msg)
[16:19:13.482]                     }
[16:19:13.482]                     invisible(pathname)
[16:19:13.482]                   }
[16:19:13.482]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.482]                     rootPath = tempdir()) 
[16:19:13.482]                   {
[16:19:13.482]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.482]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.482]                       tmpdir = path, fileext = ".rds")
[16:19:13.482]                     save_rds(obj, file)
[16:19:13.482]                   }
[16:19:13.482]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.482]                   {
[16:19:13.482]                     inherits <- base::inherits
[16:19:13.482]                     invokeRestart <- base::invokeRestart
[16:19:13.482]                     is.null <- base::is.null
[16:19:13.482]                     muffled <- FALSE
[16:19:13.482]                     if (inherits(cond, "message")) {
[16:19:13.482]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.482]                       if (muffled) 
[16:19:13.482]                         invokeRestart("muffleMessage")
[16:19:13.482]                     }
[16:19:13.482]                     else if (inherits(cond, "warning")) {
[16:19:13.482]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.482]                       if (muffled) 
[16:19:13.482]                         invokeRestart("muffleWarning")
[16:19:13.482]                     }
[16:19:13.482]                     else if (inherits(cond, "condition")) {
[16:19:13.482]                       if (!is.null(pattern)) {
[16:19:13.482]                         computeRestarts <- base::computeRestarts
[16:19:13.482]                         grepl <- base::grepl
[16:19:13.482]                         restarts <- computeRestarts(cond)
[16:19:13.482]                         for (restart in restarts) {
[16:19:13.482]                           name <- restart$name
[16:19:13.482]                           if (is.null(name)) 
[16:19:13.482]                             next
[16:19:13.482]                           if (!grepl(pattern, name)) 
[16:19:13.482]                             next
[16:19:13.482]                           invokeRestart(restart)
[16:19:13.482]                           muffled <- TRUE
[16:19:13.482]                           break
[16:19:13.482]                         }
[16:19:13.482]                       }
[16:19:13.482]                     }
[16:19:13.482]                     invisible(muffled)
[16:19:13.482]                   }
[16:19:13.482]                   muffleCondition(cond)
[16:19:13.482]                 })
[16:19:13.482]             }))
[16:19:13.482]             future::FutureResult(value = ...future.value$value, 
[16:19:13.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.482]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.482]                     ...future.globalenv.names))
[16:19:13.482]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.482]         }, condition = base::local({
[16:19:13.482]             c <- base::c
[16:19:13.482]             inherits <- base::inherits
[16:19:13.482]             invokeRestart <- base::invokeRestart
[16:19:13.482]             length <- base::length
[16:19:13.482]             list <- base::list
[16:19:13.482]             seq.int <- base::seq.int
[16:19:13.482]             signalCondition <- base::signalCondition
[16:19:13.482]             sys.calls <- base::sys.calls
[16:19:13.482]             `[[` <- base::`[[`
[16:19:13.482]             `+` <- base::`+`
[16:19:13.482]             `<<-` <- base::`<<-`
[16:19:13.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.482]                   3L)]
[16:19:13.482]             }
[16:19:13.482]             function(cond) {
[16:19:13.482]                 is_error <- inherits(cond, "error")
[16:19:13.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.482]                   NULL)
[16:19:13.482]                 if (is_error) {
[16:19:13.482]                   sessionInformation <- function() {
[16:19:13.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.482]                       search = base::search(), system = base::Sys.info())
[16:19:13.482]                   }
[16:19:13.482]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.482]                     cond$call), session = sessionInformation(), 
[16:19:13.482]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.482]                   signalCondition(cond)
[16:19:13.482]                 }
[16:19:13.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.482]                 "immediateCondition"))) {
[16:19:13.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.482]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.482]                   if (TRUE && !signal) {
[16:19:13.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.482]                     {
[16:19:13.482]                       inherits <- base::inherits
[16:19:13.482]                       invokeRestart <- base::invokeRestart
[16:19:13.482]                       is.null <- base::is.null
[16:19:13.482]                       muffled <- FALSE
[16:19:13.482]                       if (inherits(cond, "message")) {
[16:19:13.482]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.482]                         if (muffled) 
[16:19:13.482]                           invokeRestart("muffleMessage")
[16:19:13.482]                       }
[16:19:13.482]                       else if (inherits(cond, "warning")) {
[16:19:13.482]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.482]                         if (muffled) 
[16:19:13.482]                           invokeRestart("muffleWarning")
[16:19:13.482]                       }
[16:19:13.482]                       else if (inherits(cond, "condition")) {
[16:19:13.482]                         if (!is.null(pattern)) {
[16:19:13.482]                           computeRestarts <- base::computeRestarts
[16:19:13.482]                           grepl <- base::grepl
[16:19:13.482]                           restarts <- computeRestarts(cond)
[16:19:13.482]                           for (restart in restarts) {
[16:19:13.482]                             name <- restart$name
[16:19:13.482]                             if (is.null(name)) 
[16:19:13.482]                               next
[16:19:13.482]                             if (!grepl(pattern, name)) 
[16:19:13.482]                               next
[16:19:13.482]                             invokeRestart(restart)
[16:19:13.482]                             muffled <- TRUE
[16:19:13.482]                             break
[16:19:13.482]                           }
[16:19:13.482]                         }
[16:19:13.482]                       }
[16:19:13.482]                       invisible(muffled)
[16:19:13.482]                     }
[16:19:13.482]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.482]                   }
[16:19:13.482]                 }
[16:19:13.482]                 else {
[16:19:13.482]                   if (TRUE) {
[16:19:13.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.482]                     {
[16:19:13.482]                       inherits <- base::inherits
[16:19:13.482]                       invokeRestart <- base::invokeRestart
[16:19:13.482]                       is.null <- base::is.null
[16:19:13.482]                       muffled <- FALSE
[16:19:13.482]                       if (inherits(cond, "message")) {
[16:19:13.482]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.482]                         if (muffled) 
[16:19:13.482]                           invokeRestart("muffleMessage")
[16:19:13.482]                       }
[16:19:13.482]                       else if (inherits(cond, "warning")) {
[16:19:13.482]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.482]                         if (muffled) 
[16:19:13.482]                           invokeRestart("muffleWarning")
[16:19:13.482]                       }
[16:19:13.482]                       else if (inherits(cond, "condition")) {
[16:19:13.482]                         if (!is.null(pattern)) {
[16:19:13.482]                           computeRestarts <- base::computeRestarts
[16:19:13.482]                           grepl <- base::grepl
[16:19:13.482]                           restarts <- computeRestarts(cond)
[16:19:13.482]                           for (restart in restarts) {
[16:19:13.482]                             name <- restart$name
[16:19:13.482]                             if (is.null(name)) 
[16:19:13.482]                               next
[16:19:13.482]                             if (!grepl(pattern, name)) 
[16:19:13.482]                               next
[16:19:13.482]                             invokeRestart(restart)
[16:19:13.482]                             muffled <- TRUE
[16:19:13.482]                             break
[16:19:13.482]                           }
[16:19:13.482]                         }
[16:19:13.482]                       }
[16:19:13.482]                       invisible(muffled)
[16:19:13.482]                     }
[16:19:13.482]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.482]                   }
[16:19:13.482]                 }
[16:19:13.482]             }
[16:19:13.482]         }))
[16:19:13.482]     }, error = function(ex) {
[16:19:13.482]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.482]                 ...future.rng), started = ...future.startTime, 
[16:19:13.482]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.482]             version = "1.8"), class = "FutureResult")
[16:19:13.482]     }, finally = {
[16:19:13.482]         if (!identical(...future.workdir, getwd())) 
[16:19:13.482]             setwd(...future.workdir)
[16:19:13.482]         {
[16:19:13.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.482]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.482]             }
[16:19:13.482]             base::options(...future.oldOptions)
[16:19:13.482]             if (.Platform$OS.type == "windows") {
[16:19:13.482]                 old_names <- names(...future.oldEnvVars)
[16:19:13.482]                 envs <- base::Sys.getenv()
[16:19:13.482]                 names <- names(envs)
[16:19:13.482]                 common <- intersect(names, old_names)
[16:19:13.482]                 added <- setdiff(names, old_names)
[16:19:13.482]                 removed <- setdiff(old_names, names)
[16:19:13.482]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.482]                   envs[common]]
[16:19:13.482]                 NAMES <- toupper(changed)
[16:19:13.482]                 args <- list()
[16:19:13.482]                 for (kk in seq_along(NAMES)) {
[16:19:13.482]                   name <- changed[[kk]]
[16:19:13.482]                   NAME <- NAMES[[kk]]
[16:19:13.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.482]                     next
[16:19:13.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.482]                 }
[16:19:13.482]                 NAMES <- toupper(added)
[16:19:13.482]                 for (kk in seq_along(NAMES)) {
[16:19:13.482]                   name <- added[[kk]]
[16:19:13.482]                   NAME <- NAMES[[kk]]
[16:19:13.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.482]                     next
[16:19:13.482]                   args[[name]] <- ""
[16:19:13.482]                 }
[16:19:13.482]                 NAMES <- toupper(removed)
[16:19:13.482]                 for (kk in seq_along(NAMES)) {
[16:19:13.482]                   name <- removed[[kk]]
[16:19:13.482]                   NAME <- NAMES[[kk]]
[16:19:13.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.482]                     next
[16:19:13.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.482]                 }
[16:19:13.482]                 if (length(args) > 0) 
[16:19:13.482]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.482]             }
[16:19:13.482]             else {
[16:19:13.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.482]             }
[16:19:13.482]             {
[16:19:13.482]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.482]                   0L) {
[16:19:13.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.482]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.482]                   base::options(opts)
[16:19:13.482]                 }
[16:19:13.482]                 {
[16:19:13.482]                   {
[16:19:13.482]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.482]                     NULL
[16:19:13.482]                   }
[16:19:13.482]                   options(future.plan = NULL)
[16:19:13.482]                   if (is.na(NA_character_)) 
[16:19:13.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.482]                     .init = FALSE)
[16:19:13.482]                 }
[16:19:13.482]             }
[16:19:13.482]         }
[16:19:13.482]     })
[16:19:13.482]     if (TRUE) {
[16:19:13.482]         base::sink(type = "output", split = FALSE)
[16:19:13.482]         if (TRUE) {
[16:19:13.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.482]         }
[16:19:13.482]         else {
[16:19:13.482]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.482]         }
[16:19:13.482]         base::close(...future.stdout)
[16:19:13.482]         ...future.stdout <- NULL
[16:19:13.482]     }
[16:19:13.482]     ...future.result$conditions <- ...future.conditions
[16:19:13.482]     ...future.result$finished <- base::Sys.time()
[16:19:13.482]     ...future.result
[16:19:13.482] }
[16:19:13.485] assign_globals() ...
[16:19:13.485] List of 11
[16:19:13.485]  $ ...future.FUN            :function (x, ...)  
[16:19:13.485]  $ x_FUN                    :function (x)  
[16:19:13.485]  $ times                    : int 0
[16:19:13.485]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.485]  $ stop_if_not              :function (...)  
[16:19:13.485]  $ dim                      : NULL
[16:19:13.485]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.485]  $ future.call.arguments    : list()
[16:19:13.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.485]  $ ...future.elements_ii    :List of 5
[16:19:13.485]   ..$ : int 6
[16:19:13.485]   ..$ : int 7
[16:19:13.485]   ..$ : int 8
[16:19:13.485]   ..$ : int 9
[16:19:13.485]   ..$ : int 10
[16:19:13.485]  $ ...future.seeds_ii       : NULL
[16:19:13.485]  $ ...future.globals.maxSize: NULL
[16:19:13.485]  - attr(*, "where")=List of 11
[16:19:13.485]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.485]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.485]  - attr(*, "resolved")= logi FALSE
[16:19:13.485]  - attr(*, "total_size")= num 95472
[16:19:13.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.485]  - attr(*, "already-done")= logi TRUE
[16:19:13.502] - copied ‘...future.FUN’ to environment
[16:19:13.502] - reassign environment for ‘x_FUN’
[16:19:13.503] - copied ‘x_FUN’ to environment
[16:19:13.503] - copied ‘times’ to environment
[16:19:13.503] - copied ‘stopf’ to environment
[16:19:13.503] - copied ‘stop_if_not’ to environment
[16:19:13.503] - copied ‘dim’ to environment
[16:19:13.503] - copied ‘valid_types’ to environment
[16:19:13.503] - copied ‘future.call.arguments’ to environment
[16:19:13.503] - copied ‘...future.elements_ii’ to environment
[16:19:13.503] - copied ‘...future.seeds_ii’ to environment
[16:19:13.503] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.504] assign_globals() ... done
[16:19:13.504] requestCore(): workers = 2
[16:19:13.506] MulticoreFuture started
[16:19:13.506] - Launch lazy future ... done
[16:19:13.507] run() for ‘MulticoreFuture’ ... done
[16:19:13.507] Created future:
[16:19:13.508] plan(): Setting new future strategy stack:
[16:19:13.508] List of future strategies:
[16:19:13.508] 1. sequential:
[16:19:13.508]    - args: function (..., envir = parent.frame())
[16:19:13.508]    - tweaked: FALSE
[16:19:13.508]    - call: NULL
[16:19:13.509] plan(): nbrOfWorkers() = 1
[16:19:13.511] plan(): Setting new future strategy stack:
[16:19:13.511] List of future strategies:
[16:19:13.511] 1. multicore:
[16:19:13.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.511]    - tweaked: FALSE
[16:19:13.511]    - call: plan(strategy)
[16:19:13.517] plan(): nbrOfWorkers() = 2
[16:19:13.507] MulticoreFuture:
[16:19:13.507] Label: ‘future_vapply-2’
[16:19:13.507] Expression:
[16:19:13.507] {
[16:19:13.507]     do.call(function(...) {
[16:19:13.507]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.507]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.507]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.507]             on.exit(options(oopts), add = TRUE)
[16:19:13.507]         }
[16:19:13.507]         {
[16:19:13.507]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.507]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.507]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.507]             })
[16:19:13.507]         }
[16:19:13.507]     }, args = future.call.arguments)
[16:19:13.507] }
[16:19:13.507] Lazy evaluation: FALSE
[16:19:13.507] Asynchronous evaluation: TRUE
[16:19:13.507] Local evaluation: TRUE
[16:19:13.507] Environment: R_GlobalEnv
[16:19:13.507] Capture standard output: TRUE
[16:19:13.507] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.507] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.507] Packages: 1 packages (‘future.apply’)
[16:19:13.507] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.507] Resolved: TRUE
[16:19:13.507] Value: <not collected>
[16:19:13.507] Conditions captured: <none>
[16:19:13.507] Early signaling: FALSE
[16:19:13.507] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.507] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.518] Chunk #2 of 2 ... DONE
[16:19:13.518] Launching 2 futures (chunks) ... DONE
[16:19:13.518] Resolving 2 futures (chunks) ...
[16:19:13.518] resolve() on list ...
[16:19:13.519]  recursive: 0
[16:19:13.519]  length: 2
[16:19:13.519] 
[16:19:13.519] Future #1
[16:19:13.519] result() for MulticoreFuture ...
[16:19:13.520] result() for MulticoreFuture ...
[16:19:13.521] result() for MulticoreFuture ... done
[16:19:13.521] result() for MulticoreFuture ... done
[16:19:13.521] result() for MulticoreFuture ...
[16:19:13.521] result() for MulticoreFuture ... done
[16:19:13.521] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:13.522] - nx: 2
[16:19:13.522] - relay: TRUE
[16:19:13.522] - stdout: TRUE
[16:19:13.522] - signal: TRUE
[16:19:13.522] - resignal: FALSE
[16:19:13.523] - force: TRUE
[16:19:13.523] - relayed: [n=2] FALSE, FALSE
[16:19:13.523] - queued futures: [n=2] FALSE, FALSE
[16:19:13.523]  - until=1
[16:19:13.523]  - relaying element #1
[16:19:13.524] result() for MulticoreFuture ...
[16:19:13.524] result() for MulticoreFuture ... done
[16:19:13.524] result() for MulticoreFuture ...
[16:19:13.524] result() for MulticoreFuture ... done
[16:19:13.525] result() for MulticoreFuture ...
[16:19:13.525] result() for MulticoreFuture ... done
[16:19:13.525] result() for MulticoreFuture ...
[16:19:13.525] result() for MulticoreFuture ... done
[16:19:13.525] - relayed: [n=2] TRUE, FALSE
[16:19:13.526] - queued futures: [n=2] TRUE, FALSE
[16:19:13.526] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:13.526]  length: 1 (resolved future 1)
[16:19:13.526] Future #2
[16:19:13.526] result() for MulticoreFuture ...
[16:19:13.527] result() for MulticoreFuture ...
[16:19:13.527] result() for MulticoreFuture ... done
[16:19:13.527] result() for MulticoreFuture ... done
[16:19:13.528] result() for MulticoreFuture ...
[16:19:13.528] result() for MulticoreFuture ... done
[16:19:13.528] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:13.528] - nx: 2
[16:19:13.528] - relay: TRUE
[16:19:13.528] - stdout: TRUE
[16:19:13.528] - signal: TRUE
[16:19:13.529] - resignal: FALSE
[16:19:13.529] - force: TRUE
[16:19:13.529] - relayed: [n=2] TRUE, FALSE
[16:19:13.529] - queued futures: [n=2] TRUE, FALSE
[16:19:13.529]  - until=2
[16:19:13.529]  - relaying element #2
[16:19:13.529] result() for MulticoreFuture ...
[16:19:13.529] result() for MulticoreFuture ... done
[16:19:13.530] result() for MulticoreFuture ...
[16:19:13.530] result() for MulticoreFuture ... done
[16:19:13.530] result() for MulticoreFuture ...
[16:19:13.530] result() for MulticoreFuture ... done
[16:19:13.530] result() for MulticoreFuture ...
[16:19:13.530] result() for MulticoreFuture ... done
[16:19:13.530] - relayed: [n=2] TRUE, TRUE
[16:19:13.530] - queued futures: [n=2] TRUE, TRUE
[16:19:13.530] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:13.531]  length: 0 (resolved future 2)
[16:19:13.531] Relaying remaining futures
[16:19:13.531] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.531] - nx: 2
[16:19:13.531] - relay: TRUE
[16:19:13.531] - stdout: TRUE
[16:19:13.531] - signal: TRUE
[16:19:13.531] - resignal: FALSE
[16:19:13.531] - force: TRUE
[16:19:13.531] - relayed: [n=2] TRUE, TRUE
[16:19:13.532] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:13.532] - relayed: [n=2] TRUE, TRUE
[16:19:13.532] - queued futures: [n=2] TRUE, TRUE
[16:19:13.532] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.532] resolve() on list ... DONE
[16:19:13.532] result() for MulticoreFuture ...
[16:19:13.532] result() for MulticoreFuture ... done
[16:19:13.532] result() for MulticoreFuture ...
[16:19:13.533] result() for MulticoreFuture ... done
[16:19:13.533] result() for MulticoreFuture ...
[16:19:13.533] result() for MulticoreFuture ... done
[16:19:13.533] result() for MulticoreFuture ...
[16:19:13.533] result() for MulticoreFuture ... done
[16:19:13.533]  - Number of value chunks collected: 2
[16:19:13.533] Resolving 2 futures (chunks) ... DONE
[16:19:13.533] Reducing values from 2 chunks ...
[16:19:13.533]  - Number of values collected after concatenation: 10
[16:19:13.534]  - Number of values expected: 10
[16:19:13.534] Reducing values from 2 chunks ... DONE
[16:19:13.534] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:19:13.535] future_lapply() ...
[16:19:13.544] Number of chunks: 2
[16:19:13.544] getGlobalsAndPackagesXApply() ...
[16:19:13.544]  - future.globals: TRUE
[16:19:13.545] getGlobalsAndPackages() ...
[16:19:13.545] Searching for globals...
[16:19:13.549] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:19:13.549] Searching for globals ... DONE
[16:19:13.549] Resolving globals: FALSE
[16:19:13.550] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:19:13.551] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.551] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.551] - packages: [1] ‘future.apply’
[16:19:13.551] getGlobalsAndPackages() ... DONE
[16:19:13.551]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.551]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.551] Finding globals ... DONE
[16:19:13.552]  - use_args: TRUE
[16:19:13.552]  - Getting '...' globals ...
[16:19:13.552] resolve() on list ...
[16:19:13.552]  recursive: 0
[16:19:13.552]  length: 1
[16:19:13.552]  elements: ‘...’
[16:19:13.552]  length: 0 (resolved future 1)
[16:19:13.553] resolve() on list ... DONE
[16:19:13.553]    - '...' content: [n=0] 
[16:19:13.553] List of 1
[16:19:13.553]  $ ...: list()
[16:19:13.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.553]  - attr(*, "where")=List of 1
[16:19:13.553]   ..$ ...:<environment: 0x56199f39ebc0> 
[16:19:13.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.553]  - attr(*, "resolved")= logi TRUE
[16:19:13.553]  - attr(*, "total_size")= num NA
[16:19:13.555]  - Getting '...' globals ... DONE
[16:19:13.555] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.556] List of 8
[16:19:13.556]  $ ...future.FUN:function (x, ...)  
[16:19:13.556]  $ x_FUN        :function (x)  
[16:19:13.556]  $ times        : int 0
[16:19:13.556]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.556]  $ stop_if_not  :function (...)  
[16:19:13.556]  $ dim          : NULL
[16:19:13.556]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:13.556]  $ ...          : list()
[16:19:13.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.556]  - attr(*, "where")=List of 8
[16:19:13.556]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.556]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.556]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.556]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.556]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.556]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.556]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.556]   ..$ ...          :<environment: 0x56199f39ebc0> 
[16:19:13.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.556]  - attr(*, "resolved")= logi FALSE
[16:19:13.556]  - attr(*, "total_size")= num 95400
[16:19:13.561] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.561] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.563] Number of futures (= number of chunks): 2
[16:19:13.563] Launching 2 futures (chunks) ...
[16:19:13.563] Chunk #1 of 2 ...
[16:19:13.563]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.564] getGlobalsAndPackages() ...
[16:19:13.564] Searching for globals...
[16:19:13.564] 
[16:19:13.564] Searching for globals ... DONE
[16:19:13.564] - globals: [0] <none>
[16:19:13.564] getGlobalsAndPackages() ... DONE
[16:19:13.564]    + additional globals found: [n=0] 
[16:19:13.564]    + additional namespaces needed: [n=0] 
[16:19:13.565]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.565]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.565]  - seeds: <none>
[16:19:13.565]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.565] getGlobalsAndPackages() ...
[16:19:13.565] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.565] Resolving globals: FALSE
[16:19:13.565] Tweak future expression to call with '...' arguments ...
[16:19:13.566] {
[16:19:13.566]     do.call(function(...) {
[16:19:13.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.566]             on.exit(options(oopts), add = TRUE)
[16:19:13.566]         }
[16:19:13.566]         {
[16:19:13.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.566]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.566]             })
[16:19:13.566]         }
[16:19:13.566]     }, args = future.call.arguments)
[16:19:13.566] }
[16:19:13.566] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.566] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.566] - packages: [1] ‘future.apply’
[16:19:13.567] getGlobalsAndPackages() ... DONE
[16:19:13.567] run() for ‘Future’ ...
[16:19:13.567] - state: ‘created’
[16:19:13.567] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.571] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.571] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.571]   - Field: ‘label’
[16:19:13.571]   - Field: ‘local’
[16:19:13.571]   - Field: ‘owner’
[16:19:13.571]   - Field: ‘envir’
[16:19:13.572]   - Field: ‘workers’
[16:19:13.572]   - Field: ‘packages’
[16:19:13.572]   - Field: ‘gc’
[16:19:13.572]   - Field: ‘job’
[16:19:13.572]   - Field: ‘conditions’
[16:19:13.572]   - Field: ‘expr’
[16:19:13.572]   - Field: ‘uuid’
[16:19:13.572]   - Field: ‘seed’
[16:19:13.572]   - Field: ‘version’
[16:19:13.572]   - Field: ‘result’
[16:19:13.573]   - Field: ‘asynchronous’
[16:19:13.573]   - Field: ‘calls’
[16:19:13.573]   - Field: ‘globals’
[16:19:13.573]   - Field: ‘stdout’
[16:19:13.573]   - Field: ‘earlySignal’
[16:19:13.573]   - Field: ‘lazy’
[16:19:13.573]   - Field: ‘state’
[16:19:13.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.573] - Launch lazy future ...
[16:19:13.574] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.574] Packages needed by future strategies (n = 0): <none>
[16:19:13.574] {
[16:19:13.574]     {
[16:19:13.574]         {
[16:19:13.574]             ...future.startTime <- base::Sys.time()
[16:19:13.574]             {
[16:19:13.574]                 {
[16:19:13.574]                   {
[16:19:13.574]                     {
[16:19:13.574]                       {
[16:19:13.574]                         base::local({
[16:19:13.574]                           has_future <- base::requireNamespace("future", 
[16:19:13.574]                             quietly = TRUE)
[16:19:13.574]                           if (has_future) {
[16:19:13.574]                             ns <- base::getNamespace("future")
[16:19:13.574]                             version <- ns[[".package"]][["version"]]
[16:19:13.574]                             if (is.null(version)) 
[16:19:13.574]                               version <- utils::packageVersion("future")
[16:19:13.574]                           }
[16:19:13.574]                           else {
[16:19:13.574]                             version <- NULL
[16:19:13.574]                           }
[16:19:13.574]                           if (!has_future || version < "1.8.0") {
[16:19:13.574]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.574]                               "", base::R.version$version.string), 
[16:19:13.574]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.574]                                 base::R.version$platform, 8 * 
[16:19:13.574]                                   base::.Machine$sizeof.pointer), 
[16:19:13.574]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.574]                                 "release", "version")], collapse = " "), 
[16:19:13.574]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.574]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.574]                               info)
[16:19:13.574]                             info <- base::paste(info, collapse = "; ")
[16:19:13.574]                             if (!has_future) {
[16:19:13.574]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.574]                                 info)
[16:19:13.574]                             }
[16:19:13.574]                             else {
[16:19:13.574]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.574]                                 info, version)
[16:19:13.574]                             }
[16:19:13.574]                             base::stop(msg)
[16:19:13.574]                           }
[16:19:13.574]                         })
[16:19:13.574]                       }
[16:19:13.574]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.574]                       base::options(mc.cores = 1L)
[16:19:13.574]                     }
[16:19:13.574]                     base::local({
[16:19:13.574]                       for (pkg in "future.apply") {
[16:19:13.574]                         base::loadNamespace(pkg)
[16:19:13.574]                         base::library(pkg, character.only = TRUE)
[16:19:13.574]                       }
[16:19:13.574]                     })
[16:19:13.574]                   }
[16:19:13.574]                   ...future.strategy.old <- future::plan("list")
[16:19:13.574]                   options(future.plan = NULL)
[16:19:13.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.574]                 }
[16:19:13.574]                 ...future.workdir <- getwd()
[16:19:13.574]             }
[16:19:13.574]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.574]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.574]         }
[16:19:13.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.574]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.574]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.574]             base::names(...future.oldOptions))
[16:19:13.574]     }
[16:19:13.574]     if (FALSE) {
[16:19:13.574]     }
[16:19:13.574]     else {
[16:19:13.574]         if (TRUE) {
[16:19:13.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.574]                 open = "w")
[16:19:13.574]         }
[16:19:13.574]         else {
[16:19:13.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.574]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.574]         }
[16:19:13.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.574]             base::sink(type = "output", split = FALSE)
[16:19:13.574]             base::close(...future.stdout)
[16:19:13.574]         }, add = TRUE)
[16:19:13.574]     }
[16:19:13.574]     ...future.frame <- base::sys.nframe()
[16:19:13.574]     ...future.conditions <- base::list()
[16:19:13.574]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.574]     if (FALSE) {
[16:19:13.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.574]     }
[16:19:13.574]     ...future.result <- base::tryCatch({
[16:19:13.574]         base::withCallingHandlers({
[16:19:13.574]             ...future.value <- base::withVisible(base::local({
[16:19:13.574]                 withCallingHandlers({
[16:19:13.574]                   {
[16:19:13.574]                     do.call(function(...) {
[16:19:13.574]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.574]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.574]                         ...future.globals.maxSize)) {
[16:19:13.574]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.574]                         on.exit(options(oopts), add = TRUE)
[16:19:13.574]                       }
[16:19:13.574]                       {
[16:19:13.574]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.574]                           FUN = function(jj) {
[16:19:13.574]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.574]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.574]                           })
[16:19:13.574]                       }
[16:19:13.574]                     }, args = future.call.arguments)
[16:19:13.574]                   }
[16:19:13.574]                 }, immediateCondition = function(cond) {
[16:19:13.574]                   save_rds <- function (object, pathname, ...) 
[16:19:13.574]                   {
[16:19:13.574]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.574]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.574]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.574]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.574]                         fi_tmp[["mtime"]])
[16:19:13.574]                     }
[16:19:13.574]                     tryCatch({
[16:19:13.574]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.574]                     }, error = function(ex) {
[16:19:13.574]                       msg <- conditionMessage(ex)
[16:19:13.574]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.574]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.574]                         fi_tmp[["mtime"]], msg)
[16:19:13.574]                       ex$message <- msg
[16:19:13.574]                       stop(ex)
[16:19:13.574]                     })
[16:19:13.574]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.574]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.574]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.574]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.574]                       fi <- file.info(pathname)
[16:19:13.574]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.574]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.574]                         fi[["size"]], fi[["mtime"]])
[16:19:13.574]                       stop(msg)
[16:19:13.574]                     }
[16:19:13.574]                     invisible(pathname)
[16:19:13.574]                   }
[16:19:13.574]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.574]                     rootPath = tempdir()) 
[16:19:13.574]                   {
[16:19:13.574]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.574]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.574]                       tmpdir = path, fileext = ".rds")
[16:19:13.574]                     save_rds(obj, file)
[16:19:13.574]                   }
[16:19:13.574]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.574]                   {
[16:19:13.574]                     inherits <- base::inherits
[16:19:13.574]                     invokeRestart <- base::invokeRestart
[16:19:13.574]                     is.null <- base::is.null
[16:19:13.574]                     muffled <- FALSE
[16:19:13.574]                     if (inherits(cond, "message")) {
[16:19:13.574]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.574]                       if (muffled) 
[16:19:13.574]                         invokeRestart("muffleMessage")
[16:19:13.574]                     }
[16:19:13.574]                     else if (inherits(cond, "warning")) {
[16:19:13.574]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.574]                       if (muffled) 
[16:19:13.574]                         invokeRestart("muffleWarning")
[16:19:13.574]                     }
[16:19:13.574]                     else if (inherits(cond, "condition")) {
[16:19:13.574]                       if (!is.null(pattern)) {
[16:19:13.574]                         computeRestarts <- base::computeRestarts
[16:19:13.574]                         grepl <- base::grepl
[16:19:13.574]                         restarts <- computeRestarts(cond)
[16:19:13.574]                         for (restart in restarts) {
[16:19:13.574]                           name <- restart$name
[16:19:13.574]                           if (is.null(name)) 
[16:19:13.574]                             next
[16:19:13.574]                           if (!grepl(pattern, name)) 
[16:19:13.574]                             next
[16:19:13.574]                           invokeRestart(restart)
[16:19:13.574]                           muffled <- TRUE
[16:19:13.574]                           break
[16:19:13.574]                         }
[16:19:13.574]                       }
[16:19:13.574]                     }
[16:19:13.574]                     invisible(muffled)
[16:19:13.574]                   }
[16:19:13.574]                   muffleCondition(cond)
[16:19:13.574]                 })
[16:19:13.574]             }))
[16:19:13.574]             future::FutureResult(value = ...future.value$value, 
[16:19:13.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.574]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.574]                     ...future.globalenv.names))
[16:19:13.574]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.574]         }, condition = base::local({
[16:19:13.574]             c <- base::c
[16:19:13.574]             inherits <- base::inherits
[16:19:13.574]             invokeRestart <- base::invokeRestart
[16:19:13.574]             length <- base::length
[16:19:13.574]             list <- base::list
[16:19:13.574]             seq.int <- base::seq.int
[16:19:13.574]             signalCondition <- base::signalCondition
[16:19:13.574]             sys.calls <- base::sys.calls
[16:19:13.574]             `[[` <- base::`[[`
[16:19:13.574]             `+` <- base::`+`
[16:19:13.574]             `<<-` <- base::`<<-`
[16:19:13.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.574]                   3L)]
[16:19:13.574]             }
[16:19:13.574]             function(cond) {
[16:19:13.574]                 is_error <- inherits(cond, "error")
[16:19:13.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.574]                   NULL)
[16:19:13.574]                 if (is_error) {
[16:19:13.574]                   sessionInformation <- function() {
[16:19:13.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.574]                       search = base::search(), system = base::Sys.info())
[16:19:13.574]                   }
[16:19:13.574]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.574]                     cond$call), session = sessionInformation(), 
[16:19:13.574]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.574]                   signalCondition(cond)
[16:19:13.574]                 }
[16:19:13.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.574]                 "immediateCondition"))) {
[16:19:13.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.574]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.574]                   if (TRUE && !signal) {
[16:19:13.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.574]                     {
[16:19:13.574]                       inherits <- base::inherits
[16:19:13.574]                       invokeRestart <- base::invokeRestart
[16:19:13.574]                       is.null <- base::is.null
[16:19:13.574]                       muffled <- FALSE
[16:19:13.574]                       if (inherits(cond, "message")) {
[16:19:13.574]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.574]                         if (muffled) 
[16:19:13.574]                           invokeRestart("muffleMessage")
[16:19:13.574]                       }
[16:19:13.574]                       else if (inherits(cond, "warning")) {
[16:19:13.574]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.574]                         if (muffled) 
[16:19:13.574]                           invokeRestart("muffleWarning")
[16:19:13.574]                       }
[16:19:13.574]                       else if (inherits(cond, "condition")) {
[16:19:13.574]                         if (!is.null(pattern)) {
[16:19:13.574]                           computeRestarts <- base::computeRestarts
[16:19:13.574]                           grepl <- base::grepl
[16:19:13.574]                           restarts <- computeRestarts(cond)
[16:19:13.574]                           for (restart in restarts) {
[16:19:13.574]                             name <- restart$name
[16:19:13.574]                             if (is.null(name)) 
[16:19:13.574]                               next
[16:19:13.574]                             if (!grepl(pattern, name)) 
[16:19:13.574]                               next
[16:19:13.574]                             invokeRestart(restart)
[16:19:13.574]                             muffled <- TRUE
[16:19:13.574]                             break
[16:19:13.574]                           }
[16:19:13.574]                         }
[16:19:13.574]                       }
[16:19:13.574]                       invisible(muffled)
[16:19:13.574]                     }
[16:19:13.574]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.574]                   }
[16:19:13.574]                 }
[16:19:13.574]                 else {
[16:19:13.574]                   if (TRUE) {
[16:19:13.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.574]                     {
[16:19:13.574]                       inherits <- base::inherits
[16:19:13.574]                       invokeRestart <- base::invokeRestart
[16:19:13.574]                       is.null <- base::is.null
[16:19:13.574]                       muffled <- FALSE
[16:19:13.574]                       if (inherits(cond, "message")) {
[16:19:13.574]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.574]                         if (muffled) 
[16:19:13.574]                           invokeRestart("muffleMessage")
[16:19:13.574]                       }
[16:19:13.574]                       else if (inherits(cond, "warning")) {
[16:19:13.574]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.574]                         if (muffled) 
[16:19:13.574]                           invokeRestart("muffleWarning")
[16:19:13.574]                       }
[16:19:13.574]                       else if (inherits(cond, "condition")) {
[16:19:13.574]                         if (!is.null(pattern)) {
[16:19:13.574]                           computeRestarts <- base::computeRestarts
[16:19:13.574]                           grepl <- base::grepl
[16:19:13.574]                           restarts <- computeRestarts(cond)
[16:19:13.574]                           for (restart in restarts) {
[16:19:13.574]                             name <- restart$name
[16:19:13.574]                             if (is.null(name)) 
[16:19:13.574]                               next
[16:19:13.574]                             if (!grepl(pattern, name)) 
[16:19:13.574]                               next
[16:19:13.574]                             invokeRestart(restart)
[16:19:13.574]                             muffled <- TRUE
[16:19:13.574]                             break
[16:19:13.574]                           }
[16:19:13.574]                         }
[16:19:13.574]                       }
[16:19:13.574]                       invisible(muffled)
[16:19:13.574]                     }
[16:19:13.574]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.574]                   }
[16:19:13.574]                 }
[16:19:13.574]             }
[16:19:13.574]         }))
[16:19:13.574]     }, error = function(ex) {
[16:19:13.574]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.574]                 ...future.rng), started = ...future.startTime, 
[16:19:13.574]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.574]             version = "1.8"), class = "FutureResult")
[16:19:13.574]     }, finally = {
[16:19:13.574]         if (!identical(...future.workdir, getwd())) 
[16:19:13.574]             setwd(...future.workdir)
[16:19:13.574]         {
[16:19:13.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.574]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.574]             }
[16:19:13.574]             base::options(...future.oldOptions)
[16:19:13.574]             if (.Platform$OS.type == "windows") {
[16:19:13.574]                 old_names <- names(...future.oldEnvVars)
[16:19:13.574]                 envs <- base::Sys.getenv()
[16:19:13.574]                 names <- names(envs)
[16:19:13.574]                 common <- intersect(names, old_names)
[16:19:13.574]                 added <- setdiff(names, old_names)
[16:19:13.574]                 removed <- setdiff(old_names, names)
[16:19:13.574]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.574]                   envs[common]]
[16:19:13.574]                 NAMES <- toupper(changed)
[16:19:13.574]                 args <- list()
[16:19:13.574]                 for (kk in seq_along(NAMES)) {
[16:19:13.574]                   name <- changed[[kk]]
[16:19:13.574]                   NAME <- NAMES[[kk]]
[16:19:13.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.574]                     next
[16:19:13.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.574]                 }
[16:19:13.574]                 NAMES <- toupper(added)
[16:19:13.574]                 for (kk in seq_along(NAMES)) {
[16:19:13.574]                   name <- added[[kk]]
[16:19:13.574]                   NAME <- NAMES[[kk]]
[16:19:13.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.574]                     next
[16:19:13.574]                   args[[name]] <- ""
[16:19:13.574]                 }
[16:19:13.574]                 NAMES <- toupper(removed)
[16:19:13.574]                 for (kk in seq_along(NAMES)) {
[16:19:13.574]                   name <- removed[[kk]]
[16:19:13.574]                   NAME <- NAMES[[kk]]
[16:19:13.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.574]                     next
[16:19:13.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.574]                 }
[16:19:13.574]                 if (length(args) > 0) 
[16:19:13.574]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.574]             }
[16:19:13.574]             else {
[16:19:13.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.574]             }
[16:19:13.574]             {
[16:19:13.574]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.574]                   0L) {
[16:19:13.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.574]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.574]                   base::options(opts)
[16:19:13.574]                 }
[16:19:13.574]                 {
[16:19:13.574]                   {
[16:19:13.574]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.574]                     NULL
[16:19:13.574]                   }
[16:19:13.574]                   options(future.plan = NULL)
[16:19:13.574]                   if (is.na(NA_character_)) 
[16:19:13.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.574]                     .init = FALSE)
[16:19:13.574]                 }
[16:19:13.574]             }
[16:19:13.574]         }
[16:19:13.574]     })
[16:19:13.574]     if (TRUE) {
[16:19:13.574]         base::sink(type = "output", split = FALSE)
[16:19:13.574]         if (TRUE) {
[16:19:13.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.574]         }
[16:19:13.574]         else {
[16:19:13.574]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.574]         }
[16:19:13.574]         base::close(...future.stdout)
[16:19:13.574]         ...future.stdout <- NULL
[16:19:13.574]     }
[16:19:13.574]     ...future.result$conditions <- ...future.conditions
[16:19:13.574]     ...future.result$finished <- base::Sys.time()
[16:19:13.574]     ...future.result
[16:19:13.574] }
[16:19:13.577] assign_globals() ...
[16:19:13.577] List of 11
[16:19:13.577]  $ ...future.FUN            :function (x, ...)  
[16:19:13.577]  $ x_FUN                    :function (x)  
[16:19:13.577]  $ times                    : int 0
[16:19:13.577]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.577]  $ stop_if_not              :function (...)  
[16:19:13.577]  $ dim                      : NULL
[16:19:13.577]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:13.577]  $ future.call.arguments    : list()
[16:19:13.577]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.577]  $ ...future.elements_ii    :List of 5
[16:19:13.577]   ..$ : int 1
[16:19:13.577]   ..$ : int 2
[16:19:13.577]   ..$ : int 3
[16:19:13.577]   ..$ : int 4
[16:19:13.577]   ..$ : int 5
[16:19:13.577]  $ ...future.seeds_ii       : NULL
[16:19:13.577]  $ ...future.globals.maxSize: NULL
[16:19:13.577]  - attr(*, "where")=List of 11
[16:19:13.577]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.577]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.577]  - attr(*, "resolved")= logi FALSE
[16:19:13.577]  - attr(*, "total_size")= num 95400
[16:19:13.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.577]  - attr(*, "already-done")= logi TRUE
[16:19:13.585] - copied ‘...future.FUN’ to environment
[16:19:13.585] - reassign environment for ‘x_FUN’
[16:19:13.585] - copied ‘x_FUN’ to environment
[16:19:13.585] - copied ‘times’ to environment
[16:19:13.585] - copied ‘stopf’ to environment
[16:19:13.586] - copied ‘stop_if_not’ to environment
[16:19:13.586] - copied ‘dim’ to environment
[16:19:13.586] - copied ‘valid_types’ to environment
[16:19:13.586] - copied ‘future.call.arguments’ to environment
[16:19:13.586] - copied ‘...future.elements_ii’ to environment
[16:19:13.588] - copied ‘...future.seeds_ii’ to environment
[16:19:13.588] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.588] assign_globals() ... done
[16:19:13.588] requestCore(): workers = 2
[16:19:13.590] MulticoreFuture started
[16:19:13.591] - Launch lazy future ... done
[16:19:13.592] run() for ‘MulticoreFuture’ ... done
[16:19:13.592] Created future:
[16:19:13.593] plan(): Setting new future strategy stack:
[16:19:13.593] List of future strategies:
[16:19:13.593] 1. sequential:
[16:19:13.593]    - args: function (..., envir = parent.frame())
[16:19:13.593]    - tweaked: FALSE
[16:19:13.593]    - call: NULL
[16:19:13.594] plan(): nbrOfWorkers() = 1
[16:19:13.597] plan(): Setting new future strategy stack:
[16:19:13.597] List of future strategies:
[16:19:13.597] 1. multicore:
[16:19:13.597]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.597]    - tweaked: FALSE
[16:19:13.597]    - call: plan(strategy)
[16:19:13.604] plan(): nbrOfWorkers() = 2
[16:19:13.593] MulticoreFuture:
[16:19:13.593] Label: ‘future_vapply-1’
[16:19:13.593] Expression:
[16:19:13.593] {
[16:19:13.593]     do.call(function(...) {
[16:19:13.593]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.593]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.593]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.593]             on.exit(options(oopts), add = TRUE)
[16:19:13.593]         }
[16:19:13.593]         {
[16:19:13.593]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.593]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.593]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.593]             })
[16:19:13.593]         }
[16:19:13.593]     }, args = future.call.arguments)
[16:19:13.593] }
[16:19:13.593] Lazy evaluation: FALSE
[16:19:13.593] Asynchronous evaluation: TRUE
[16:19:13.593] Local evaluation: TRUE
[16:19:13.593] Environment: R_GlobalEnv
[16:19:13.593] Capture standard output: TRUE
[16:19:13.593] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.593] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.593] Packages: 1 packages (‘future.apply’)
[16:19:13.593] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.593] Resolved: TRUE
[16:19:13.593] Value: <not collected>
[16:19:13.593] Conditions captured: <none>
[16:19:13.593] Early signaling: FALSE
[16:19:13.593] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.593] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.605] Chunk #1 of 2 ... DONE
[16:19:13.606] Chunk #2 of 2 ...
[16:19:13.606]  - Finding globals in 'X' for chunk #2 ...
[16:19:13.606] getGlobalsAndPackages() ...
[16:19:13.606] Searching for globals...
[16:19:13.607] 
[16:19:13.607] Searching for globals ... DONE
[16:19:13.607] - globals: [0] <none>
[16:19:13.608] getGlobalsAndPackages() ... DONE
[16:19:13.608]    + additional globals found: [n=0] 
[16:19:13.608]    + additional namespaces needed: [n=0] 
[16:19:13.608]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:13.608]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.609]  - seeds: <none>
[16:19:13.609]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.609] getGlobalsAndPackages() ...
[16:19:13.609] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.609] Resolving globals: FALSE
[16:19:13.610] Tweak future expression to call with '...' arguments ...
[16:19:13.610] {
[16:19:13.610]     do.call(function(...) {
[16:19:13.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.610]             on.exit(options(oopts), add = TRUE)
[16:19:13.610]         }
[16:19:13.610]         {
[16:19:13.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.610]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.610]             })
[16:19:13.610]         }
[16:19:13.610]     }, args = future.call.arguments)
[16:19:13.610] }
[16:19:13.610] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.611] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.611] - packages: [1] ‘future.apply’
[16:19:13.612] getGlobalsAndPackages() ... DONE
[16:19:13.612] run() for ‘Future’ ...
[16:19:13.612] - state: ‘created’
[16:19:13.613] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.617] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.618]   - Field: ‘label’
[16:19:13.618]   - Field: ‘local’
[16:19:13.618]   - Field: ‘owner’
[16:19:13.618]   - Field: ‘envir’
[16:19:13.618]   - Field: ‘workers’
[16:19:13.619]   - Field: ‘packages’
[16:19:13.619]   - Field: ‘gc’
[16:19:13.619]   - Field: ‘job’
[16:19:13.619]   - Field: ‘conditions’
[16:19:13.619]   - Field: ‘expr’
[16:19:13.619]   - Field: ‘uuid’
[16:19:13.619]   - Field: ‘seed’
[16:19:13.620]   - Field: ‘version’
[16:19:13.620]   - Field: ‘result’
[16:19:13.620]   - Field: ‘asynchronous’
[16:19:13.620]   - Field: ‘calls’
[16:19:13.620]   - Field: ‘globals’
[16:19:13.620]   - Field: ‘stdout’
[16:19:13.620]   - Field: ‘earlySignal’
[16:19:13.620]   - Field: ‘lazy’
[16:19:13.621]   - Field: ‘state’
[16:19:13.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.621] - Launch lazy future ...
[16:19:13.621] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.621] Packages needed by future strategies (n = 0): <none>
[16:19:13.622] {
[16:19:13.622]     {
[16:19:13.622]         {
[16:19:13.622]             ...future.startTime <- base::Sys.time()
[16:19:13.622]             {
[16:19:13.622]                 {
[16:19:13.622]                   {
[16:19:13.622]                     {
[16:19:13.622]                       {
[16:19:13.622]                         base::local({
[16:19:13.622]                           has_future <- base::requireNamespace("future", 
[16:19:13.622]                             quietly = TRUE)
[16:19:13.622]                           if (has_future) {
[16:19:13.622]                             ns <- base::getNamespace("future")
[16:19:13.622]                             version <- ns[[".package"]][["version"]]
[16:19:13.622]                             if (is.null(version)) 
[16:19:13.622]                               version <- utils::packageVersion("future")
[16:19:13.622]                           }
[16:19:13.622]                           else {
[16:19:13.622]                             version <- NULL
[16:19:13.622]                           }
[16:19:13.622]                           if (!has_future || version < "1.8.0") {
[16:19:13.622]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.622]                               "", base::R.version$version.string), 
[16:19:13.622]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.622]                                 base::R.version$platform, 8 * 
[16:19:13.622]                                   base::.Machine$sizeof.pointer), 
[16:19:13.622]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.622]                                 "release", "version")], collapse = " "), 
[16:19:13.622]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.622]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.622]                               info)
[16:19:13.622]                             info <- base::paste(info, collapse = "; ")
[16:19:13.622]                             if (!has_future) {
[16:19:13.622]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.622]                                 info)
[16:19:13.622]                             }
[16:19:13.622]                             else {
[16:19:13.622]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.622]                                 info, version)
[16:19:13.622]                             }
[16:19:13.622]                             base::stop(msg)
[16:19:13.622]                           }
[16:19:13.622]                         })
[16:19:13.622]                       }
[16:19:13.622]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.622]                       base::options(mc.cores = 1L)
[16:19:13.622]                     }
[16:19:13.622]                     base::local({
[16:19:13.622]                       for (pkg in "future.apply") {
[16:19:13.622]                         base::loadNamespace(pkg)
[16:19:13.622]                         base::library(pkg, character.only = TRUE)
[16:19:13.622]                       }
[16:19:13.622]                     })
[16:19:13.622]                   }
[16:19:13.622]                   ...future.strategy.old <- future::plan("list")
[16:19:13.622]                   options(future.plan = NULL)
[16:19:13.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.622]                 }
[16:19:13.622]                 ...future.workdir <- getwd()
[16:19:13.622]             }
[16:19:13.622]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.622]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.622]         }
[16:19:13.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.622]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.622]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.622]             base::names(...future.oldOptions))
[16:19:13.622]     }
[16:19:13.622]     if (FALSE) {
[16:19:13.622]     }
[16:19:13.622]     else {
[16:19:13.622]         if (TRUE) {
[16:19:13.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.622]                 open = "w")
[16:19:13.622]         }
[16:19:13.622]         else {
[16:19:13.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.622]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.622]         }
[16:19:13.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.622]             base::sink(type = "output", split = FALSE)
[16:19:13.622]             base::close(...future.stdout)
[16:19:13.622]         }, add = TRUE)
[16:19:13.622]     }
[16:19:13.622]     ...future.frame <- base::sys.nframe()
[16:19:13.622]     ...future.conditions <- base::list()
[16:19:13.622]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.622]     if (FALSE) {
[16:19:13.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.622]     }
[16:19:13.622]     ...future.result <- base::tryCatch({
[16:19:13.622]         base::withCallingHandlers({
[16:19:13.622]             ...future.value <- base::withVisible(base::local({
[16:19:13.622]                 withCallingHandlers({
[16:19:13.622]                   {
[16:19:13.622]                     do.call(function(...) {
[16:19:13.622]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.622]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.622]                         ...future.globals.maxSize)) {
[16:19:13.622]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.622]                         on.exit(options(oopts), add = TRUE)
[16:19:13.622]                       }
[16:19:13.622]                       {
[16:19:13.622]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.622]                           FUN = function(jj) {
[16:19:13.622]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.622]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.622]                           })
[16:19:13.622]                       }
[16:19:13.622]                     }, args = future.call.arguments)
[16:19:13.622]                   }
[16:19:13.622]                 }, immediateCondition = function(cond) {
[16:19:13.622]                   save_rds <- function (object, pathname, ...) 
[16:19:13.622]                   {
[16:19:13.622]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.622]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.622]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.622]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.622]                         fi_tmp[["mtime"]])
[16:19:13.622]                     }
[16:19:13.622]                     tryCatch({
[16:19:13.622]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.622]                     }, error = function(ex) {
[16:19:13.622]                       msg <- conditionMessage(ex)
[16:19:13.622]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.622]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.622]                         fi_tmp[["mtime"]], msg)
[16:19:13.622]                       ex$message <- msg
[16:19:13.622]                       stop(ex)
[16:19:13.622]                     })
[16:19:13.622]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.622]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.622]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.622]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.622]                       fi <- file.info(pathname)
[16:19:13.622]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.622]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.622]                         fi[["size"]], fi[["mtime"]])
[16:19:13.622]                       stop(msg)
[16:19:13.622]                     }
[16:19:13.622]                     invisible(pathname)
[16:19:13.622]                   }
[16:19:13.622]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.622]                     rootPath = tempdir()) 
[16:19:13.622]                   {
[16:19:13.622]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.622]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.622]                       tmpdir = path, fileext = ".rds")
[16:19:13.622]                     save_rds(obj, file)
[16:19:13.622]                   }
[16:19:13.622]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.622]                   {
[16:19:13.622]                     inherits <- base::inherits
[16:19:13.622]                     invokeRestart <- base::invokeRestart
[16:19:13.622]                     is.null <- base::is.null
[16:19:13.622]                     muffled <- FALSE
[16:19:13.622]                     if (inherits(cond, "message")) {
[16:19:13.622]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.622]                       if (muffled) 
[16:19:13.622]                         invokeRestart("muffleMessage")
[16:19:13.622]                     }
[16:19:13.622]                     else if (inherits(cond, "warning")) {
[16:19:13.622]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.622]                       if (muffled) 
[16:19:13.622]                         invokeRestart("muffleWarning")
[16:19:13.622]                     }
[16:19:13.622]                     else if (inherits(cond, "condition")) {
[16:19:13.622]                       if (!is.null(pattern)) {
[16:19:13.622]                         computeRestarts <- base::computeRestarts
[16:19:13.622]                         grepl <- base::grepl
[16:19:13.622]                         restarts <- computeRestarts(cond)
[16:19:13.622]                         for (restart in restarts) {
[16:19:13.622]                           name <- restart$name
[16:19:13.622]                           if (is.null(name)) 
[16:19:13.622]                             next
[16:19:13.622]                           if (!grepl(pattern, name)) 
[16:19:13.622]                             next
[16:19:13.622]                           invokeRestart(restart)
[16:19:13.622]                           muffled <- TRUE
[16:19:13.622]                           break
[16:19:13.622]                         }
[16:19:13.622]                       }
[16:19:13.622]                     }
[16:19:13.622]                     invisible(muffled)
[16:19:13.622]                   }
[16:19:13.622]                   muffleCondition(cond)
[16:19:13.622]                 })
[16:19:13.622]             }))
[16:19:13.622]             future::FutureResult(value = ...future.value$value, 
[16:19:13.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.622]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.622]                     ...future.globalenv.names))
[16:19:13.622]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.622]         }, condition = base::local({
[16:19:13.622]             c <- base::c
[16:19:13.622]             inherits <- base::inherits
[16:19:13.622]             invokeRestart <- base::invokeRestart
[16:19:13.622]             length <- base::length
[16:19:13.622]             list <- base::list
[16:19:13.622]             seq.int <- base::seq.int
[16:19:13.622]             signalCondition <- base::signalCondition
[16:19:13.622]             sys.calls <- base::sys.calls
[16:19:13.622]             `[[` <- base::`[[`
[16:19:13.622]             `+` <- base::`+`
[16:19:13.622]             `<<-` <- base::`<<-`
[16:19:13.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.622]                   3L)]
[16:19:13.622]             }
[16:19:13.622]             function(cond) {
[16:19:13.622]                 is_error <- inherits(cond, "error")
[16:19:13.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.622]                   NULL)
[16:19:13.622]                 if (is_error) {
[16:19:13.622]                   sessionInformation <- function() {
[16:19:13.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.622]                       search = base::search(), system = base::Sys.info())
[16:19:13.622]                   }
[16:19:13.622]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.622]                     cond$call), session = sessionInformation(), 
[16:19:13.622]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.622]                   signalCondition(cond)
[16:19:13.622]                 }
[16:19:13.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.622]                 "immediateCondition"))) {
[16:19:13.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.622]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.622]                   if (TRUE && !signal) {
[16:19:13.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.622]                     {
[16:19:13.622]                       inherits <- base::inherits
[16:19:13.622]                       invokeRestart <- base::invokeRestart
[16:19:13.622]                       is.null <- base::is.null
[16:19:13.622]                       muffled <- FALSE
[16:19:13.622]                       if (inherits(cond, "message")) {
[16:19:13.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.622]                         if (muffled) 
[16:19:13.622]                           invokeRestart("muffleMessage")
[16:19:13.622]                       }
[16:19:13.622]                       else if (inherits(cond, "warning")) {
[16:19:13.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.622]                         if (muffled) 
[16:19:13.622]                           invokeRestart("muffleWarning")
[16:19:13.622]                       }
[16:19:13.622]                       else if (inherits(cond, "condition")) {
[16:19:13.622]                         if (!is.null(pattern)) {
[16:19:13.622]                           computeRestarts <- base::computeRestarts
[16:19:13.622]                           grepl <- base::grepl
[16:19:13.622]                           restarts <- computeRestarts(cond)
[16:19:13.622]                           for (restart in restarts) {
[16:19:13.622]                             name <- restart$name
[16:19:13.622]                             if (is.null(name)) 
[16:19:13.622]                               next
[16:19:13.622]                             if (!grepl(pattern, name)) 
[16:19:13.622]                               next
[16:19:13.622]                             invokeRestart(restart)
[16:19:13.622]                             muffled <- TRUE
[16:19:13.622]                             break
[16:19:13.622]                           }
[16:19:13.622]                         }
[16:19:13.622]                       }
[16:19:13.622]                       invisible(muffled)
[16:19:13.622]                     }
[16:19:13.622]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.622]                   }
[16:19:13.622]                 }
[16:19:13.622]                 else {
[16:19:13.622]                   if (TRUE) {
[16:19:13.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.622]                     {
[16:19:13.622]                       inherits <- base::inherits
[16:19:13.622]                       invokeRestart <- base::invokeRestart
[16:19:13.622]                       is.null <- base::is.null
[16:19:13.622]                       muffled <- FALSE
[16:19:13.622]                       if (inherits(cond, "message")) {
[16:19:13.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.622]                         if (muffled) 
[16:19:13.622]                           invokeRestart("muffleMessage")
[16:19:13.622]                       }
[16:19:13.622]                       else if (inherits(cond, "warning")) {
[16:19:13.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.622]                         if (muffled) 
[16:19:13.622]                           invokeRestart("muffleWarning")
[16:19:13.622]                       }
[16:19:13.622]                       else if (inherits(cond, "condition")) {
[16:19:13.622]                         if (!is.null(pattern)) {
[16:19:13.622]                           computeRestarts <- base::computeRestarts
[16:19:13.622]                           grepl <- base::grepl
[16:19:13.622]                           restarts <- computeRestarts(cond)
[16:19:13.622]                           for (restart in restarts) {
[16:19:13.622]                             name <- restart$name
[16:19:13.622]                             if (is.null(name)) 
[16:19:13.622]                               next
[16:19:13.622]                             if (!grepl(pattern, name)) 
[16:19:13.622]                               next
[16:19:13.622]                             invokeRestart(restart)
[16:19:13.622]                             muffled <- TRUE
[16:19:13.622]                             break
[16:19:13.622]                           }
[16:19:13.622]                         }
[16:19:13.622]                       }
[16:19:13.622]                       invisible(muffled)
[16:19:13.622]                     }
[16:19:13.622]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.622]                   }
[16:19:13.622]                 }
[16:19:13.622]             }
[16:19:13.622]         }))
[16:19:13.622]     }, error = function(ex) {
[16:19:13.622]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.622]                 ...future.rng), started = ...future.startTime, 
[16:19:13.622]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.622]             version = "1.8"), class = "FutureResult")
[16:19:13.622]     }, finally = {
[16:19:13.622]         if (!identical(...future.workdir, getwd())) 
[16:19:13.622]             setwd(...future.workdir)
[16:19:13.622]         {
[16:19:13.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.622]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.622]             }
[16:19:13.622]             base::options(...future.oldOptions)
[16:19:13.622]             if (.Platform$OS.type == "windows") {
[16:19:13.622]                 old_names <- names(...future.oldEnvVars)
[16:19:13.622]                 envs <- base::Sys.getenv()
[16:19:13.622]                 names <- names(envs)
[16:19:13.622]                 common <- intersect(names, old_names)
[16:19:13.622]                 added <- setdiff(names, old_names)
[16:19:13.622]                 removed <- setdiff(old_names, names)
[16:19:13.622]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.622]                   envs[common]]
[16:19:13.622]                 NAMES <- toupper(changed)
[16:19:13.622]                 args <- list()
[16:19:13.622]                 for (kk in seq_along(NAMES)) {
[16:19:13.622]                   name <- changed[[kk]]
[16:19:13.622]                   NAME <- NAMES[[kk]]
[16:19:13.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.622]                     next
[16:19:13.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.622]                 }
[16:19:13.622]                 NAMES <- toupper(added)
[16:19:13.622]                 for (kk in seq_along(NAMES)) {
[16:19:13.622]                   name <- added[[kk]]
[16:19:13.622]                   NAME <- NAMES[[kk]]
[16:19:13.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.622]                     next
[16:19:13.622]                   args[[name]] <- ""
[16:19:13.622]                 }
[16:19:13.622]                 NAMES <- toupper(removed)
[16:19:13.622]                 for (kk in seq_along(NAMES)) {
[16:19:13.622]                   name <- removed[[kk]]
[16:19:13.622]                   NAME <- NAMES[[kk]]
[16:19:13.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.622]                     next
[16:19:13.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.622]                 }
[16:19:13.622]                 if (length(args) > 0) 
[16:19:13.622]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.622]             }
[16:19:13.622]             else {
[16:19:13.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.622]             }
[16:19:13.622]             {
[16:19:13.622]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.622]                   0L) {
[16:19:13.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.622]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.622]                   base::options(opts)
[16:19:13.622]                 }
[16:19:13.622]                 {
[16:19:13.622]                   {
[16:19:13.622]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.622]                     NULL
[16:19:13.622]                   }
[16:19:13.622]                   options(future.plan = NULL)
[16:19:13.622]                   if (is.na(NA_character_)) 
[16:19:13.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.622]                     .init = FALSE)
[16:19:13.622]                 }
[16:19:13.622]             }
[16:19:13.622]         }
[16:19:13.622]     })
[16:19:13.622]     if (TRUE) {
[16:19:13.622]         base::sink(type = "output", split = FALSE)
[16:19:13.622]         if (TRUE) {
[16:19:13.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.622]         }
[16:19:13.622]         else {
[16:19:13.622]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.622]         }
[16:19:13.622]         base::close(...future.stdout)
[16:19:13.622]         ...future.stdout <- NULL
[16:19:13.622]     }
[16:19:13.622]     ...future.result$conditions <- ...future.conditions
[16:19:13.622]     ...future.result$finished <- base::Sys.time()
[16:19:13.622]     ...future.result
[16:19:13.622] }
[16:19:13.625] assign_globals() ...
[16:19:13.626] List of 11
[16:19:13.626]  $ ...future.FUN            :function (x, ...)  
[16:19:13.626]  $ x_FUN                    :function (x)  
[16:19:13.626]  $ times                    : int 0
[16:19:13.626]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.626]  $ stop_if_not              :function (...)  
[16:19:13.626]  $ dim                      : NULL
[16:19:13.626]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:13.626]  $ future.call.arguments    : list()
[16:19:13.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.626]  $ ...future.elements_ii    :List of 5
[16:19:13.626]   ..$ : int 6
[16:19:13.626]   ..$ : int 7
[16:19:13.626]   ..$ : int 8
[16:19:13.626]   ..$ : int 9
[16:19:13.626]   ..$ : int 10
[16:19:13.626]  $ ...future.seeds_ii       : NULL
[16:19:13.626]  $ ...future.globals.maxSize: NULL
[16:19:13.626]  - attr(*, "where")=List of 11
[16:19:13.626]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.626]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.626]  - attr(*, "resolved")= logi FALSE
[16:19:13.626]  - attr(*, "total_size")= num 95400
[16:19:13.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.626]  - attr(*, "already-done")= logi TRUE
[16:19:13.638] - copied ‘...future.FUN’ to environment
[16:19:13.639] - reassign environment for ‘x_FUN’
[16:19:13.639] - copied ‘x_FUN’ to environment
[16:19:13.639] - copied ‘times’ to environment
[16:19:13.639] - copied ‘stopf’ to environment
[16:19:13.639] - copied ‘stop_if_not’ to environment
[16:19:13.639] - copied ‘dim’ to environment
[16:19:13.639] - copied ‘valid_types’ to environment
[16:19:13.639] - copied ‘future.call.arguments’ to environment
[16:19:13.640] - copied ‘...future.elements_ii’ to environment
[16:19:13.640] - copied ‘...future.seeds_ii’ to environment
[16:19:13.640] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.640] assign_globals() ... done
[16:19:13.640] requestCore(): workers = 2
[16:19:13.643] MulticoreFuture started
[16:19:13.643] - Launch lazy future ... done
[16:19:13.644] run() for ‘MulticoreFuture’ ... done
[16:19:13.644] Created future:
[16:19:13.644] plan(): Setting new future strategy stack:
[16:19:13.645] List of future strategies:
[16:19:13.645] 1. sequential:
[16:19:13.645]    - args: function (..., envir = parent.frame())
[16:19:13.645]    - tweaked: FALSE
[16:19:13.645]    - call: NULL
[16:19:13.646] plan(): nbrOfWorkers() = 1
[16:19:13.649] plan(): Setting new future strategy stack:
[16:19:13.649] List of future strategies:
[16:19:13.649] 1. multicore:
[16:19:13.649]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.649]    - tweaked: FALSE
[16:19:13.649]    - call: plan(strategy)
[16:19:13.655] plan(): nbrOfWorkers() = 2
[16:19:13.645] MulticoreFuture:
[16:19:13.645] Label: ‘future_vapply-2’
[16:19:13.645] Expression:
[16:19:13.645] {
[16:19:13.645]     do.call(function(...) {
[16:19:13.645]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.645]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.645]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.645]             on.exit(options(oopts), add = TRUE)
[16:19:13.645]         }
[16:19:13.645]         {
[16:19:13.645]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.645]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.645]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.645]             })
[16:19:13.645]         }
[16:19:13.645]     }, args = future.call.arguments)
[16:19:13.645] }
[16:19:13.645] Lazy evaluation: FALSE
[16:19:13.645] Asynchronous evaluation: TRUE
[16:19:13.645] Local evaluation: TRUE
[16:19:13.645] Environment: R_GlobalEnv
[16:19:13.645] Capture standard output: TRUE
[16:19:13.645] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.645] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.645] Packages: 1 packages (‘future.apply’)
[16:19:13.645] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.645] Resolved: TRUE
[16:19:13.645] Value: <not collected>
[16:19:13.645] Conditions captured: <none>
[16:19:13.645] Early signaling: FALSE
[16:19:13.645] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.645] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.656] Chunk #2 of 2 ... DONE
[16:19:13.656] Launching 2 futures (chunks) ... DONE
[16:19:13.657] Resolving 2 futures (chunks) ...
[16:19:13.657] resolve() on list ...
[16:19:13.657]  recursive: 0
[16:19:13.657]  length: 2
[16:19:13.657] 
[16:19:13.658] Future #1
[16:19:13.658] result() for MulticoreFuture ...
[16:19:13.659] result() for MulticoreFuture ...
[16:19:13.659] result() for MulticoreFuture ... done
[16:19:13.659] result() for MulticoreFuture ... done
[16:19:13.659] result() for MulticoreFuture ...
[16:19:13.659] result() for MulticoreFuture ... done
[16:19:13.660] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:13.660] - nx: 2
[16:19:13.660] - relay: TRUE
[16:19:13.660] - stdout: TRUE
[16:19:13.660] - signal: TRUE
[16:19:13.661] - resignal: FALSE
[16:19:13.661] - force: TRUE
[16:19:13.661] - relayed: [n=2] FALSE, FALSE
[16:19:13.661] - queued futures: [n=2] FALSE, FALSE
[16:19:13.661]  - until=1
[16:19:13.661]  - relaying element #1
[16:19:13.662] result() for MulticoreFuture ...
[16:19:13.662] result() for MulticoreFuture ... done
[16:19:13.662] result() for MulticoreFuture ...
[16:19:13.662] result() for MulticoreFuture ... done
[16:19:13.662] result() for MulticoreFuture ...
[16:19:13.663] result() for MulticoreFuture ... done
[16:19:13.663] result() for MulticoreFuture ...
[16:19:13.663] result() for MulticoreFuture ... done
[16:19:13.663] - relayed: [n=2] TRUE, FALSE
[16:19:13.663] - queued futures: [n=2] TRUE, FALSE
[16:19:13.663] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:13.663]  length: 1 (resolved future 1)
[16:19:13.664] Future #2
[16:19:13.664] result() for MulticoreFuture ...
[16:19:13.665] result() for MulticoreFuture ...
[16:19:13.665] result() for MulticoreFuture ... done
[16:19:13.665] result() for MulticoreFuture ... done
[16:19:13.665] result() for MulticoreFuture ...
[16:19:13.665] result() for MulticoreFuture ... done
[16:19:13.665] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:13.665] - nx: 2
[16:19:13.666] - relay: TRUE
[16:19:13.666] - stdout: TRUE
[16:19:13.666] - signal: TRUE
[16:19:13.666] - resignal: FALSE
[16:19:13.666] - force: TRUE
[16:19:13.666] - relayed: [n=2] TRUE, FALSE
[16:19:13.666] - queued futures: [n=2] TRUE, FALSE
[16:19:13.666]  - until=2
[16:19:13.666]  - relaying element #2
[16:19:13.667] result() for MulticoreFuture ...
[16:19:13.667] result() for MulticoreFuture ... done
[16:19:13.667] result() for MulticoreFuture ...
[16:19:13.667] result() for MulticoreFuture ... done
[16:19:13.667] result() for MulticoreFuture ...
[16:19:13.667] result() for MulticoreFuture ... done
[16:19:13.667] result() for MulticoreFuture ...
[16:19:13.667] result() for MulticoreFuture ... done
[16:19:13.667] - relayed: [n=2] TRUE, TRUE
[16:19:13.668] - queued futures: [n=2] TRUE, TRUE
[16:19:13.668] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:13.668]  length: 0 (resolved future 2)
[16:19:13.668] Relaying remaining futures
[16:19:13.668] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.668] - nx: 2
[16:19:13.668] - relay: TRUE
[16:19:13.668] - stdout: TRUE
[16:19:13.668] - signal: TRUE
[16:19:13.669] - resignal: FALSE
[16:19:13.669] - force: TRUE
[16:19:13.669] - relayed: [n=2] TRUE, TRUE
[16:19:13.669] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:13.669] - relayed: [n=2] TRUE, TRUE
[16:19:13.669] - queued futures: [n=2] TRUE, TRUE
[16:19:13.669] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.669] resolve() on list ... DONE
[16:19:13.669] result() for MulticoreFuture ...
[16:19:13.670] result() for MulticoreFuture ... done
[16:19:13.670] result() for MulticoreFuture ...
[16:19:13.670] result() for MulticoreFuture ... done
[16:19:13.670] result() for MulticoreFuture ...
[16:19:13.670] result() for MulticoreFuture ... done
[16:19:13.670] result() for MulticoreFuture ...
[16:19:13.670] result() for MulticoreFuture ... done
[16:19:13.670]  - Number of value chunks collected: 2
[16:19:13.671] Resolving 2 futures (chunks) ... DONE
[16:19:13.671] Reducing values from 2 chunks ...
[16:19:13.671]  - Number of values collected after concatenation: 10
[16:19:13.671]  - Number of values expected: 10
[16:19:13.671] Reducing values from 2 chunks ... DONE
[16:19:13.671] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:19:13.672] future_lapply() ...
[16:19:13.678] Number of chunks: 2
[16:19:13.678] getGlobalsAndPackagesXApply() ...
[16:19:13.678]  - future.globals: TRUE
[16:19:13.678] getGlobalsAndPackages() ...
[16:19:13.678] Searching for globals...
[16:19:13.685] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:13.685] Searching for globals ... DONE
[16:19:13.685] Resolving globals: FALSE
[16:19:13.686] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:19:13.686] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.687] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.687] - packages: [1] ‘future.apply’
[16:19:13.687] getGlobalsAndPackages() ... DONE
[16:19:13.687]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.687]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.687] Finding globals ... DONE
[16:19:13.687]  - use_args: TRUE
[16:19:13.687]  - Getting '...' globals ...
[16:19:13.688] resolve() on list ...
[16:19:13.688]  recursive: 0
[16:19:13.688]  length: 1
[16:19:13.688]  elements: ‘...’
[16:19:13.688]  length: 0 (resolved future 1)
[16:19:13.688] resolve() on list ... DONE
[16:19:13.688]    - '...' content: [n=0] 
[16:19:13.689] List of 1
[16:19:13.689]  $ ...: list()
[16:19:13.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.689]  - attr(*, "where")=List of 1
[16:19:13.689]   ..$ ...:<environment: 0x56199f14d678> 
[16:19:13.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.689]  - attr(*, "resolved")= logi TRUE
[16:19:13.689]  - attr(*, "total_size")= num NA
[16:19:13.691]  - Getting '...' globals ... DONE
[16:19:13.691] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.691] List of 8
[16:19:13.691]  $ ...future.FUN:function (x, ...)  
[16:19:13.691]  $ x_FUN        :function (x)  
[16:19:13.691]  $ times        : int 1
[16:19:13.691]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.691]  $ stop_if_not  :function (...)  
[16:19:13.691]  $ dim          : NULL
[16:19:13.691]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:13.691]  $ ...          : list()
[16:19:13.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.691]  - attr(*, "where")=List of 8
[16:19:13.691]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.691]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.691]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.691]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.691]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.691]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.691]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.691]   ..$ ...          :<environment: 0x56199f14d678> 
[16:19:13.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.691]  - attr(*, "resolved")= logi FALSE
[16:19:13.691]  - attr(*, "total_size")= num 94336
[16:19:13.697] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.697] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.697] Number of futures (= number of chunks): 2
[16:19:13.697] Launching 2 futures (chunks) ...
[16:19:13.697] Chunk #1 of 2 ...
[16:19:13.697]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.698] getGlobalsAndPackages() ...
[16:19:13.698] Searching for globals...
[16:19:13.698] 
[16:19:13.698] Searching for globals ... DONE
[16:19:13.698] - globals: [0] <none>
[16:19:13.698] getGlobalsAndPackages() ... DONE
[16:19:13.698]    + additional globals found: [n=0] 
[16:19:13.698]    + additional namespaces needed: [n=0] 
[16:19:13.698]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.699]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.699]  - seeds: <none>
[16:19:13.699]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.699] getGlobalsAndPackages() ...
[16:19:13.699] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.699] Resolving globals: FALSE
[16:19:13.699] Tweak future expression to call with '...' arguments ...
[16:19:13.699] {
[16:19:13.699]     do.call(function(...) {
[16:19:13.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.699]             on.exit(options(oopts), add = TRUE)
[16:19:13.699]         }
[16:19:13.699]         {
[16:19:13.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.699]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.699]             })
[16:19:13.699]         }
[16:19:13.699]     }, args = future.call.arguments)
[16:19:13.699] }
[16:19:13.700] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.700] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.700] - packages: [1] ‘future.apply’
[16:19:13.700] getGlobalsAndPackages() ... DONE
[16:19:13.701] run() for ‘Future’ ...
[16:19:13.703] - state: ‘created’
[16:19:13.703] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.707] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.707]   - Field: ‘label’
[16:19:13.707]   - Field: ‘local’
[16:19:13.708]   - Field: ‘owner’
[16:19:13.708]   - Field: ‘envir’
[16:19:13.708]   - Field: ‘workers’
[16:19:13.708]   - Field: ‘packages’
[16:19:13.708]   - Field: ‘gc’
[16:19:13.708]   - Field: ‘job’
[16:19:13.708]   - Field: ‘conditions’
[16:19:13.708]   - Field: ‘expr’
[16:19:13.708]   - Field: ‘uuid’
[16:19:13.709]   - Field: ‘seed’
[16:19:13.709]   - Field: ‘version’
[16:19:13.709]   - Field: ‘result’
[16:19:13.709]   - Field: ‘asynchronous’
[16:19:13.709]   - Field: ‘calls’
[16:19:13.709]   - Field: ‘globals’
[16:19:13.709]   - Field: ‘stdout’
[16:19:13.709]   - Field: ‘earlySignal’
[16:19:13.709]   - Field: ‘lazy’
[16:19:13.710]   - Field: ‘state’
[16:19:13.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.710] - Launch lazy future ...
[16:19:13.710] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.710] Packages needed by future strategies (n = 0): <none>
[16:19:13.711] {
[16:19:13.711]     {
[16:19:13.711]         {
[16:19:13.711]             ...future.startTime <- base::Sys.time()
[16:19:13.711]             {
[16:19:13.711]                 {
[16:19:13.711]                   {
[16:19:13.711]                     {
[16:19:13.711]                       {
[16:19:13.711]                         base::local({
[16:19:13.711]                           has_future <- base::requireNamespace("future", 
[16:19:13.711]                             quietly = TRUE)
[16:19:13.711]                           if (has_future) {
[16:19:13.711]                             ns <- base::getNamespace("future")
[16:19:13.711]                             version <- ns[[".package"]][["version"]]
[16:19:13.711]                             if (is.null(version)) 
[16:19:13.711]                               version <- utils::packageVersion("future")
[16:19:13.711]                           }
[16:19:13.711]                           else {
[16:19:13.711]                             version <- NULL
[16:19:13.711]                           }
[16:19:13.711]                           if (!has_future || version < "1.8.0") {
[16:19:13.711]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.711]                               "", base::R.version$version.string), 
[16:19:13.711]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.711]                                 base::R.version$platform, 8 * 
[16:19:13.711]                                   base::.Machine$sizeof.pointer), 
[16:19:13.711]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.711]                                 "release", "version")], collapse = " "), 
[16:19:13.711]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.711]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.711]                               info)
[16:19:13.711]                             info <- base::paste(info, collapse = "; ")
[16:19:13.711]                             if (!has_future) {
[16:19:13.711]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.711]                                 info)
[16:19:13.711]                             }
[16:19:13.711]                             else {
[16:19:13.711]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.711]                                 info, version)
[16:19:13.711]                             }
[16:19:13.711]                             base::stop(msg)
[16:19:13.711]                           }
[16:19:13.711]                         })
[16:19:13.711]                       }
[16:19:13.711]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.711]                       base::options(mc.cores = 1L)
[16:19:13.711]                     }
[16:19:13.711]                     base::local({
[16:19:13.711]                       for (pkg in "future.apply") {
[16:19:13.711]                         base::loadNamespace(pkg)
[16:19:13.711]                         base::library(pkg, character.only = TRUE)
[16:19:13.711]                       }
[16:19:13.711]                     })
[16:19:13.711]                   }
[16:19:13.711]                   ...future.strategy.old <- future::plan("list")
[16:19:13.711]                   options(future.plan = NULL)
[16:19:13.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.711]                 }
[16:19:13.711]                 ...future.workdir <- getwd()
[16:19:13.711]             }
[16:19:13.711]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.711]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.711]         }
[16:19:13.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.711]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.711]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.711]             base::names(...future.oldOptions))
[16:19:13.711]     }
[16:19:13.711]     if (FALSE) {
[16:19:13.711]     }
[16:19:13.711]     else {
[16:19:13.711]         if (TRUE) {
[16:19:13.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.711]                 open = "w")
[16:19:13.711]         }
[16:19:13.711]         else {
[16:19:13.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.711]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.711]         }
[16:19:13.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.711]             base::sink(type = "output", split = FALSE)
[16:19:13.711]             base::close(...future.stdout)
[16:19:13.711]         }, add = TRUE)
[16:19:13.711]     }
[16:19:13.711]     ...future.frame <- base::sys.nframe()
[16:19:13.711]     ...future.conditions <- base::list()
[16:19:13.711]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.711]     if (FALSE) {
[16:19:13.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.711]     }
[16:19:13.711]     ...future.result <- base::tryCatch({
[16:19:13.711]         base::withCallingHandlers({
[16:19:13.711]             ...future.value <- base::withVisible(base::local({
[16:19:13.711]                 withCallingHandlers({
[16:19:13.711]                   {
[16:19:13.711]                     do.call(function(...) {
[16:19:13.711]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.711]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.711]                         ...future.globals.maxSize)) {
[16:19:13.711]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.711]                         on.exit(options(oopts), add = TRUE)
[16:19:13.711]                       }
[16:19:13.711]                       {
[16:19:13.711]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.711]                           FUN = function(jj) {
[16:19:13.711]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.711]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.711]                           })
[16:19:13.711]                       }
[16:19:13.711]                     }, args = future.call.arguments)
[16:19:13.711]                   }
[16:19:13.711]                 }, immediateCondition = function(cond) {
[16:19:13.711]                   save_rds <- function (object, pathname, ...) 
[16:19:13.711]                   {
[16:19:13.711]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.711]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.711]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.711]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.711]                         fi_tmp[["mtime"]])
[16:19:13.711]                     }
[16:19:13.711]                     tryCatch({
[16:19:13.711]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.711]                     }, error = function(ex) {
[16:19:13.711]                       msg <- conditionMessage(ex)
[16:19:13.711]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.711]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.711]                         fi_tmp[["mtime"]], msg)
[16:19:13.711]                       ex$message <- msg
[16:19:13.711]                       stop(ex)
[16:19:13.711]                     })
[16:19:13.711]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.711]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.711]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.711]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.711]                       fi <- file.info(pathname)
[16:19:13.711]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.711]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.711]                         fi[["size"]], fi[["mtime"]])
[16:19:13.711]                       stop(msg)
[16:19:13.711]                     }
[16:19:13.711]                     invisible(pathname)
[16:19:13.711]                   }
[16:19:13.711]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.711]                     rootPath = tempdir()) 
[16:19:13.711]                   {
[16:19:13.711]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.711]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.711]                       tmpdir = path, fileext = ".rds")
[16:19:13.711]                     save_rds(obj, file)
[16:19:13.711]                   }
[16:19:13.711]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.711]                   {
[16:19:13.711]                     inherits <- base::inherits
[16:19:13.711]                     invokeRestart <- base::invokeRestart
[16:19:13.711]                     is.null <- base::is.null
[16:19:13.711]                     muffled <- FALSE
[16:19:13.711]                     if (inherits(cond, "message")) {
[16:19:13.711]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.711]                       if (muffled) 
[16:19:13.711]                         invokeRestart("muffleMessage")
[16:19:13.711]                     }
[16:19:13.711]                     else if (inherits(cond, "warning")) {
[16:19:13.711]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.711]                       if (muffled) 
[16:19:13.711]                         invokeRestart("muffleWarning")
[16:19:13.711]                     }
[16:19:13.711]                     else if (inherits(cond, "condition")) {
[16:19:13.711]                       if (!is.null(pattern)) {
[16:19:13.711]                         computeRestarts <- base::computeRestarts
[16:19:13.711]                         grepl <- base::grepl
[16:19:13.711]                         restarts <- computeRestarts(cond)
[16:19:13.711]                         for (restart in restarts) {
[16:19:13.711]                           name <- restart$name
[16:19:13.711]                           if (is.null(name)) 
[16:19:13.711]                             next
[16:19:13.711]                           if (!grepl(pattern, name)) 
[16:19:13.711]                             next
[16:19:13.711]                           invokeRestart(restart)
[16:19:13.711]                           muffled <- TRUE
[16:19:13.711]                           break
[16:19:13.711]                         }
[16:19:13.711]                       }
[16:19:13.711]                     }
[16:19:13.711]                     invisible(muffled)
[16:19:13.711]                   }
[16:19:13.711]                   muffleCondition(cond)
[16:19:13.711]                 })
[16:19:13.711]             }))
[16:19:13.711]             future::FutureResult(value = ...future.value$value, 
[16:19:13.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.711]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.711]                     ...future.globalenv.names))
[16:19:13.711]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.711]         }, condition = base::local({
[16:19:13.711]             c <- base::c
[16:19:13.711]             inherits <- base::inherits
[16:19:13.711]             invokeRestart <- base::invokeRestart
[16:19:13.711]             length <- base::length
[16:19:13.711]             list <- base::list
[16:19:13.711]             seq.int <- base::seq.int
[16:19:13.711]             signalCondition <- base::signalCondition
[16:19:13.711]             sys.calls <- base::sys.calls
[16:19:13.711]             `[[` <- base::`[[`
[16:19:13.711]             `+` <- base::`+`
[16:19:13.711]             `<<-` <- base::`<<-`
[16:19:13.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.711]                   3L)]
[16:19:13.711]             }
[16:19:13.711]             function(cond) {
[16:19:13.711]                 is_error <- inherits(cond, "error")
[16:19:13.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.711]                   NULL)
[16:19:13.711]                 if (is_error) {
[16:19:13.711]                   sessionInformation <- function() {
[16:19:13.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.711]                       search = base::search(), system = base::Sys.info())
[16:19:13.711]                   }
[16:19:13.711]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.711]                     cond$call), session = sessionInformation(), 
[16:19:13.711]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.711]                   signalCondition(cond)
[16:19:13.711]                 }
[16:19:13.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.711]                 "immediateCondition"))) {
[16:19:13.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.711]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.711]                   if (TRUE && !signal) {
[16:19:13.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.711]                     {
[16:19:13.711]                       inherits <- base::inherits
[16:19:13.711]                       invokeRestart <- base::invokeRestart
[16:19:13.711]                       is.null <- base::is.null
[16:19:13.711]                       muffled <- FALSE
[16:19:13.711]                       if (inherits(cond, "message")) {
[16:19:13.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.711]                         if (muffled) 
[16:19:13.711]                           invokeRestart("muffleMessage")
[16:19:13.711]                       }
[16:19:13.711]                       else if (inherits(cond, "warning")) {
[16:19:13.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.711]                         if (muffled) 
[16:19:13.711]                           invokeRestart("muffleWarning")
[16:19:13.711]                       }
[16:19:13.711]                       else if (inherits(cond, "condition")) {
[16:19:13.711]                         if (!is.null(pattern)) {
[16:19:13.711]                           computeRestarts <- base::computeRestarts
[16:19:13.711]                           grepl <- base::grepl
[16:19:13.711]                           restarts <- computeRestarts(cond)
[16:19:13.711]                           for (restart in restarts) {
[16:19:13.711]                             name <- restart$name
[16:19:13.711]                             if (is.null(name)) 
[16:19:13.711]                               next
[16:19:13.711]                             if (!grepl(pattern, name)) 
[16:19:13.711]                               next
[16:19:13.711]                             invokeRestart(restart)
[16:19:13.711]                             muffled <- TRUE
[16:19:13.711]                             break
[16:19:13.711]                           }
[16:19:13.711]                         }
[16:19:13.711]                       }
[16:19:13.711]                       invisible(muffled)
[16:19:13.711]                     }
[16:19:13.711]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.711]                   }
[16:19:13.711]                 }
[16:19:13.711]                 else {
[16:19:13.711]                   if (TRUE) {
[16:19:13.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.711]                     {
[16:19:13.711]                       inherits <- base::inherits
[16:19:13.711]                       invokeRestart <- base::invokeRestart
[16:19:13.711]                       is.null <- base::is.null
[16:19:13.711]                       muffled <- FALSE
[16:19:13.711]                       if (inherits(cond, "message")) {
[16:19:13.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.711]                         if (muffled) 
[16:19:13.711]                           invokeRestart("muffleMessage")
[16:19:13.711]                       }
[16:19:13.711]                       else if (inherits(cond, "warning")) {
[16:19:13.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.711]                         if (muffled) 
[16:19:13.711]                           invokeRestart("muffleWarning")
[16:19:13.711]                       }
[16:19:13.711]                       else if (inherits(cond, "condition")) {
[16:19:13.711]                         if (!is.null(pattern)) {
[16:19:13.711]                           computeRestarts <- base::computeRestarts
[16:19:13.711]                           grepl <- base::grepl
[16:19:13.711]                           restarts <- computeRestarts(cond)
[16:19:13.711]                           for (restart in restarts) {
[16:19:13.711]                             name <- restart$name
[16:19:13.711]                             if (is.null(name)) 
[16:19:13.711]                               next
[16:19:13.711]                             if (!grepl(pattern, name)) 
[16:19:13.711]                               next
[16:19:13.711]                             invokeRestart(restart)
[16:19:13.711]                             muffled <- TRUE
[16:19:13.711]                             break
[16:19:13.711]                           }
[16:19:13.711]                         }
[16:19:13.711]                       }
[16:19:13.711]                       invisible(muffled)
[16:19:13.711]                     }
[16:19:13.711]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.711]                   }
[16:19:13.711]                 }
[16:19:13.711]             }
[16:19:13.711]         }))
[16:19:13.711]     }, error = function(ex) {
[16:19:13.711]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.711]                 ...future.rng), started = ...future.startTime, 
[16:19:13.711]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.711]             version = "1.8"), class = "FutureResult")
[16:19:13.711]     }, finally = {
[16:19:13.711]         if (!identical(...future.workdir, getwd())) 
[16:19:13.711]             setwd(...future.workdir)
[16:19:13.711]         {
[16:19:13.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.711]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.711]             }
[16:19:13.711]             base::options(...future.oldOptions)
[16:19:13.711]             if (.Platform$OS.type == "windows") {
[16:19:13.711]                 old_names <- names(...future.oldEnvVars)
[16:19:13.711]                 envs <- base::Sys.getenv()
[16:19:13.711]                 names <- names(envs)
[16:19:13.711]                 common <- intersect(names, old_names)
[16:19:13.711]                 added <- setdiff(names, old_names)
[16:19:13.711]                 removed <- setdiff(old_names, names)
[16:19:13.711]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.711]                   envs[common]]
[16:19:13.711]                 NAMES <- toupper(changed)
[16:19:13.711]                 args <- list()
[16:19:13.711]                 for (kk in seq_along(NAMES)) {
[16:19:13.711]                   name <- changed[[kk]]
[16:19:13.711]                   NAME <- NAMES[[kk]]
[16:19:13.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.711]                     next
[16:19:13.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.711]                 }
[16:19:13.711]                 NAMES <- toupper(added)
[16:19:13.711]                 for (kk in seq_along(NAMES)) {
[16:19:13.711]                   name <- added[[kk]]
[16:19:13.711]                   NAME <- NAMES[[kk]]
[16:19:13.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.711]                     next
[16:19:13.711]                   args[[name]] <- ""
[16:19:13.711]                 }
[16:19:13.711]                 NAMES <- toupper(removed)
[16:19:13.711]                 for (kk in seq_along(NAMES)) {
[16:19:13.711]                   name <- removed[[kk]]
[16:19:13.711]                   NAME <- NAMES[[kk]]
[16:19:13.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.711]                     next
[16:19:13.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.711]                 }
[16:19:13.711]                 if (length(args) > 0) 
[16:19:13.711]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.711]             }
[16:19:13.711]             else {
[16:19:13.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.711]             }
[16:19:13.711]             {
[16:19:13.711]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.711]                   0L) {
[16:19:13.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.711]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.711]                   base::options(opts)
[16:19:13.711]                 }
[16:19:13.711]                 {
[16:19:13.711]                   {
[16:19:13.711]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.711]                     NULL
[16:19:13.711]                   }
[16:19:13.711]                   options(future.plan = NULL)
[16:19:13.711]                   if (is.na(NA_character_)) 
[16:19:13.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.711]                     .init = FALSE)
[16:19:13.711]                 }
[16:19:13.711]             }
[16:19:13.711]         }
[16:19:13.711]     })
[16:19:13.711]     if (TRUE) {
[16:19:13.711]         base::sink(type = "output", split = FALSE)
[16:19:13.711]         if (TRUE) {
[16:19:13.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.711]         }
[16:19:13.711]         else {
[16:19:13.711]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.711]         }
[16:19:13.711]         base::close(...future.stdout)
[16:19:13.711]         ...future.stdout <- NULL
[16:19:13.711]     }
[16:19:13.711]     ...future.result$conditions <- ...future.conditions
[16:19:13.711]     ...future.result$finished <- base::Sys.time()
[16:19:13.711]     ...future.result
[16:19:13.711] }
[16:19:13.713] assign_globals() ...
[16:19:13.713] List of 11
[16:19:13.713]  $ ...future.FUN            :function (x, ...)  
[16:19:13.713]  $ x_FUN                    :function (x)  
[16:19:13.713]  $ times                    : int 1
[16:19:13.713]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.713]  $ stop_if_not              :function (...)  
[16:19:13.713]  $ dim                      : NULL
[16:19:13.713]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.713]  $ future.call.arguments    : list()
[16:19:13.713]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.713]  $ ...future.elements_ii    :List of 5
[16:19:13.713]   ..$ : int 1
[16:19:13.713]   ..$ : int 2
[16:19:13.713]   ..$ : int 3
[16:19:13.713]   ..$ : int 4
[16:19:13.713]   ..$ : int 5
[16:19:13.713]  $ ...future.seeds_ii       : NULL
[16:19:13.713]  $ ...future.globals.maxSize: NULL
[16:19:13.713]  - attr(*, "where")=List of 11
[16:19:13.713]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.713]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.713]  - attr(*, "resolved")= logi FALSE
[16:19:13.713]  - attr(*, "total_size")= num 94336
[16:19:13.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.713]  - attr(*, "already-done")= logi TRUE
[16:19:13.722] - copied ‘...future.FUN’ to environment
[16:19:13.722] - copied ‘x_FUN’ to environment
[16:19:13.722] - copied ‘times’ to environment
[16:19:13.722] - copied ‘stopf’ to environment
[16:19:13.722] - copied ‘stop_if_not’ to environment
[16:19:13.722] - copied ‘dim’ to environment
[16:19:13.722] - copied ‘valid_types’ to environment
[16:19:13.722] - copied ‘future.call.arguments’ to environment
[16:19:13.723] - copied ‘...future.elements_ii’ to environment
[16:19:13.723] - copied ‘...future.seeds_ii’ to environment
[16:19:13.723] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.723] assign_globals() ... done
[16:19:13.723] requestCore(): workers = 2
[16:19:13.725] MulticoreFuture started
[16:19:13.726] - Launch lazy future ... done
[16:19:13.726] run() for ‘MulticoreFuture’ ... done
[16:19:13.726] Created future:
[16:19:13.727] plan(): Setting new future strategy stack:
[16:19:13.727] List of future strategies:
[16:19:13.727] 1. sequential:
[16:19:13.727]    - args: function (..., envir = parent.frame())
[16:19:13.727]    - tweaked: FALSE
[16:19:13.727]    - call: NULL
[16:19:13.728] plan(): nbrOfWorkers() = 1
[16:19:13.730] plan(): Setting new future strategy stack:
[16:19:13.730] List of future strategies:
[16:19:13.730] 1. multicore:
[16:19:13.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.730]    - tweaked: FALSE
[16:19:13.730]    - call: plan(strategy)
[16:19:13.726] MulticoreFuture:
[16:19:13.726] Label: ‘future_vapply-1’
[16:19:13.726] Expression:
[16:19:13.726] {
[16:19:13.726]     do.call(function(...) {
[16:19:13.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.726]             on.exit(options(oopts), add = TRUE)
[16:19:13.726]         }
[16:19:13.726]         {
[16:19:13.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.726]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.726]             })
[16:19:13.726]         }
[16:19:13.726]     }, args = future.call.arguments)
[16:19:13.726] }
[16:19:13.726] Lazy evaluation: FALSE
[16:19:13.726] Asynchronous evaluation: TRUE
[16:19:13.726] Local evaluation: TRUE
[16:19:13.726] Environment: R_GlobalEnv
[16:19:13.726] Capture standard output: TRUE
[16:19:13.726] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.726] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.726] Packages: 1 packages (‘future.apply’)
[16:19:13.726] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.726] Resolved: FALSE
[16:19:13.726] Value: <not collected>
[16:19:13.726] Conditions captured: <none>
[16:19:13.726] Early signaling: FALSE
[16:19:13.726] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.726] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.739] Chunk #1 of 2 ... DONE
[16:19:13.740] Chunk #2 of 2 ...
[16:19:13.740]  - Finding globals in 'X' for chunk #2 ...
[16:19:13.740] getGlobalsAndPackages() ...
[16:19:13.740] Searching for globals...
[16:19:13.741] 
[16:19:13.741] plan(): nbrOfWorkers() = 2
[16:19:13.741] Searching for globals ... DONE
[16:19:13.741] - globals: [0] <none>
[16:19:13.744] getGlobalsAndPackages() ... DONE
[16:19:13.744]    + additional globals found: [n=0] 
[16:19:13.745]    + additional namespaces needed: [n=0] 
[16:19:13.745]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:13.745]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.745]  - seeds: <none>
[16:19:13.746]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.746] getGlobalsAndPackages() ...
[16:19:13.746] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.747] Resolving globals: FALSE
[16:19:13.747] Tweak future expression to call with '...' arguments ...
[16:19:13.748] {
[16:19:13.748]     do.call(function(...) {
[16:19:13.748]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.748]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.748]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.748]             on.exit(options(oopts), add = TRUE)
[16:19:13.748]         }
[16:19:13.748]         {
[16:19:13.748]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.748]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.748]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.748]             })
[16:19:13.748]         }
[16:19:13.748]     }, args = future.call.arguments)
[16:19:13.748] }
[16:19:13.748] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.750] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.750] - packages: [1] ‘future.apply’
[16:19:13.750] getGlobalsAndPackages() ... DONE
[16:19:13.751] run() for ‘Future’ ...
[16:19:13.751] - state: ‘created’
[16:19:13.752] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.757] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.757]   - Field: ‘label’
[16:19:13.758]   - Field: ‘local’
[16:19:13.758]   - Field: ‘owner’
[16:19:13.758]   - Field: ‘envir’
[16:19:13.758]   - Field: ‘workers’
[16:19:13.758]   - Field: ‘packages’
[16:19:13.758]   - Field: ‘gc’
[16:19:13.758]   - Field: ‘job’
[16:19:13.759]   - Field: ‘conditions’
[16:19:13.759]   - Field: ‘expr’
[16:19:13.759]   - Field: ‘uuid’
[16:19:13.759]   - Field: ‘seed’
[16:19:13.759]   - Field: ‘version’
[16:19:13.759]   - Field: ‘result’
[16:19:13.760]   - Field: ‘asynchronous’
[16:19:13.760]   - Field: ‘calls’
[16:19:13.760]   - Field: ‘globals’
[16:19:13.760]   - Field: ‘stdout’
[16:19:13.760]   - Field: ‘earlySignal’
[16:19:13.761]   - Field: ‘lazy’
[16:19:13.761]   - Field: ‘state’
[16:19:13.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.761] - Launch lazy future ...
[16:19:13.761] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.762] Packages needed by future strategies (n = 0): <none>
[16:19:13.762] {
[16:19:13.762]     {
[16:19:13.762]         {
[16:19:13.762]             ...future.startTime <- base::Sys.time()
[16:19:13.762]             {
[16:19:13.762]                 {
[16:19:13.762]                   {
[16:19:13.762]                     {
[16:19:13.762]                       {
[16:19:13.762]                         base::local({
[16:19:13.762]                           has_future <- base::requireNamespace("future", 
[16:19:13.762]                             quietly = TRUE)
[16:19:13.762]                           if (has_future) {
[16:19:13.762]                             ns <- base::getNamespace("future")
[16:19:13.762]                             version <- ns[[".package"]][["version"]]
[16:19:13.762]                             if (is.null(version)) 
[16:19:13.762]                               version <- utils::packageVersion("future")
[16:19:13.762]                           }
[16:19:13.762]                           else {
[16:19:13.762]                             version <- NULL
[16:19:13.762]                           }
[16:19:13.762]                           if (!has_future || version < "1.8.0") {
[16:19:13.762]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.762]                               "", base::R.version$version.string), 
[16:19:13.762]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.762]                                 base::R.version$platform, 8 * 
[16:19:13.762]                                   base::.Machine$sizeof.pointer), 
[16:19:13.762]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.762]                                 "release", "version")], collapse = " "), 
[16:19:13.762]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.762]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.762]                               info)
[16:19:13.762]                             info <- base::paste(info, collapse = "; ")
[16:19:13.762]                             if (!has_future) {
[16:19:13.762]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.762]                                 info)
[16:19:13.762]                             }
[16:19:13.762]                             else {
[16:19:13.762]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.762]                                 info, version)
[16:19:13.762]                             }
[16:19:13.762]                             base::stop(msg)
[16:19:13.762]                           }
[16:19:13.762]                         })
[16:19:13.762]                       }
[16:19:13.762]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.762]                       base::options(mc.cores = 1L)
[16:19:13.762]                     }
[16:19:13.762]                     base::local({
[16:19:13.762]                       for (pkg in "future.apply") {
[16:19:13.762]                         base::loadNamespace(pkg)
[16:19:13.762]                         base::library(pkg, character.only = TRUE)
[16:19:13.762]                       }
[16:19:13.762]                     })
[16:19:13.762]                   }
[16:19:13.762]                   ...future.strategy.old <- future::plan("list")
[16:19:13.762]                   options(future.plan = NULL)
[16:19:13.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.762]                 }
[16:19:13.762]                 ...future.workdir <- getwd()
[16:19:13.762]             }
[16:19:13.762]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.762]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.762]         }
[16:19:13.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.762]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.762]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.762]             base::names(...future.oldOptions))
[16:19:13.762]     }
[16:19:13.762]     if (FALSE) {
[16:19:13.762]     }
[16:19:13.762]     else {
[16:19:13.762]         if (TRUE) {
[16:19:13.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.762]                 open = "w")
[16:19:13.762]         }
[16:19:13.762]         else {
[16:19:13.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.762]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.762]         }
[16:19:13.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.762]             base::sink(type = "output", split = FALSE)
[16:19:13.762]             base::close(...future.stdout)
[16:19:13.762]         }, add = TRUE)
[16:19:13.762]     }
[16:19:13.762]     ...future.frame <- base::sys.nframe()
[16:19:13.762]     ...future.conditions <- base::list()
[16:19:13.762]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.762]     if (FALSE) {
[16:19:13.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.762]     }
[16:19:13.762]     ...future.result <- base::tryCatch({
[16:19:13.762]         base::withCallingHandlers({
[16:19:13.762]             ...future.value <- base::withVisible(base::local({
[16:19:13.762]                 withCallingHandlers({
[16:19:13.762]                   {
[16:19:13.762]                     do.call(function(...) {
[16:19:13.762]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.762]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.762]                         ...future.globals.maxSize)) {
[16:19:13.762]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.762]                         on.exit(options(oopts), add = TRUE)
[16:19:13.762]                       }
[16:19:13.762]                       {
[16:19:13.762]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.762]                           FUN = function(jj) {
[16:19:13.762]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.762]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.762]                           })
[16:19:13.762]                       }
[16:19:13.762]                     }, args = future.call.arguments)
[16:19:13.762]                   }
[16:19:13.762]                 }, immediateCondition = function(cond) {
[16:19:13.762]                   save_rds <- function (object, pathname, ...) 
[16:19:13.762]                   {
[16:19:13.762]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.762]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.762]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.762]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.762]                         fi_tmp[["mtime"]])
[16:19:13.762]                     }
[16:19:13.762]                     tryCatch({
[16:19:13.762]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.762]                     }, error = function(ex) {
[16:19:13.762]                       msg <- conditionMessage(ex)
[16:19:13.762]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.762]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.762]                         fi_tmp[["mtime"]], msg)
[16:19:13.762]                       ex$message <- msg
[16:19:13.762]                       stop(ex)
[16:19:13.762]                     })
[16:19:13.762]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.762]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.762]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.762]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.762]                       fi <- file.info(pathname)
[16:19:13.762]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.762]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.762]                         fi[["size"]], fi[["mtime"]])
[16:19:13.762]                       stop(msg)
[16:19:13.762]                     }
[16:19:13.762]                     invisible(pathname)
[16:19:13.762]                   }
[16:19:13.762]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.762]                     rootPath = tempdir()) 
[16:19:13.762]                   {
[16:19:13.762]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.762]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.762]                       tmpdir = path, fileext = ".rds")
[16:19:13.762]                     save_rds(obj, file)
[16:19:13.762]                   }
[16:19:13.762]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.762]                   {
[16:19:13.762]                     inherits <- base::inherits
[16:19:13.762]                     invokeRestart <- base::invokeRestart
[16:19:13.762]                     is.null <- base::is.null
[16:19:13.762]                     muffled <- FALSE
[16:19:13.762]                     if (inherits(cond, "message")) {
[16:19:13.762]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.762]                       if (muffled) 
[16:19:13.762]                         invokeRestart("muffleMessage")
[16:19:13.762]                     }
[16:19:13.762]                     else if (inherits(cond, "warning")) {
[16:19:13.762]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.762]                       if (muffled) 
[16:19:13.762]                         invokeRestart("muffleWarning")
[16:19:13.762]                     }
[16:19:13.762]                     else if (inherits(cond, "condition")) {
[16:19:13.762]                       if (!is.null(pattern)) {
[16:19:13.762]                         computeRestarts <- base::computeRestarts
[16:19:13.762]                         grepl <- base::grepl
[16:19:13.762]                         restarts <- computeRestarts(cond)
[16:19:13.762]                         for (restart in restarts) {
[16:19:13.762]                           name <- restart$name
[16:19:13.762]                           if (is.null(name)) 
[16:19:13.762]                             next
[16:19:13.762]                           if (!grepl(pattern, name)) 
[16:19:13.762]                             next
[16:19:13.762]                           invokeRestart(restart)
[16:19:13.762]                           muffled <- TRUE
[16:19:13.762]                           break
[16:19:13.762]                         }
[16:19:13.762]                       }
[16:19:13.762]                     }
[16:19:13.762]                     invisible(muffled)
[16:19:13.762]                   }
[16:19:13.762]                   muffleCondition(cond)
[16:19:13.762]                 })
[16:19:13.762]             }))
[16:19:13.762]             future::FutureResult(value = ...future.value$value, 
[16:19:13.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.762]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.762]                     ...future.globalenv.names))
[16:19:13.762]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.762]         }, condition = base::local({
[16:19:13.762]             c <- base::c
[16:19:13.762]             inherits <- base::inherits
[16:19:13.762]             invokeRestart <- base::invokeRestart
[16:19:13.762]             length <- base::length
[16:19:13.762]             list <- base::list
[16:19:13.762]             seq.int <- base::seq.int
[16:19:13.762]             signalCondition <- base::signalCondition
[16:19:13.762]             sys.calls <- base::sys.calls
[16:19:13.762]             `[[` <- base::`[[`
[16:19:13.762]             `+` <- base::`+`
[16:19:13.762]             `<<-` <- base::`<<-`
[16:19:13.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.762]                   3L)]
[16:19:13.762]             }
[16:19:13.762]             function(cond) {
[16:19:13.762]                 is_error <- inherits(cond, "error")
[16:19:13.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.762]                   NULL)
[16:19:13.762]                 if (is_error) {
[16:19:13.762]                   sessionInformation <- function() {
[16:19:13.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.762]                       search = base::search(), system = base::Sys.info())
[16:19:13.762]                   }
[16:19:13.762]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.762]                     cond$call), session = sessionInformation(), 
[16:19:13.762]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.762]                   signalCondition(cond)
[16:19:13.762]                 }
[16:19:13.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.762]                 "immediateCondition"))) {
[16:19:13.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.762]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.762]                   if (TRUE && !signal) {
[16:19:13.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.762]                     {
[16:19:13.762]                       inherits <- base::inherits
[16:19:13.762]                       invokeRestart <- base::invokeRestart
[16:19:13.762]                       is.null <- base::is.null
[16:19:13.762]                       muffled <- FALSE
[16:19:13.762]                       if (inherits(cond, "message")) {
[16:19:13.762]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.762]                         if (muffled) 
[16:19:13.762]                           invokeRestart("muffleMessage")
[16:19:13.762]                       }
[16:19:13.762]                       else if (inherits(cond, "warning")) {
[16:19:13.762]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.762]                         if (muffled) 
[16:19:13.762]                           invokeRestart("muffleWarning")
[16:19:13.762]                       }
[16:19:13.762]                       else if (inherits(cond, "condition")) {
[16:19:13.762]                         if (!is.null(pattern)) {
[16:19:13.762]                           computeRestarts <- base::computeRestarts
[16:19:13.762]                           grepl <- base::grepl
[16:19:13.762]                           restarts <- computeRestarts(cond)
[16:19:13.762]                           for (restart in restarts) {
[16:19:13.762]                             name <- restart$name
[16:19:13.762]                             if (is.null(name)) 
[16:19:13.762]                               next
[16:19:13.762]                             if (!grepl(pattern, name)) 
[16:19:13.762]                               next
[16:19:13.762]                             invokeRestart(restart)
[16:19:13.762]                             muffled <- TRUE
[16:19:13.762]                             break
[16:19:13.762]                           }
[16:19:13.762]                         }
[16:19:13.762]                       }
[16:19:13.762]                       invisible(muffled)
[16:19:13.762]                     }
[16:19:13.762]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.762]                   }
[16:19:13.762]                 }
[16:19:13.762]                 else {
[16:19:13.762]                   if (TRUE) {
[16:19:13.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.762]                     {
[16:19:13.762]                       inherits <- base::inherits
[16:19:13.762]                       invokeRestart <- base::invokeRestart
[16:19:13.762]                       is.null <- base::is.null
[16:19:13.762]                       muffled <- FALSE
[16:19:13.762]                       if (inherits(cond, "message")) {
[16:19:13.762]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.762]                         if (muffled) 
[16:19:13.762]                           invokeRestart("muffleMessage")
[16:19:13.762]                       }
[16:19:13.762]                       else if (inherits(cond, "warning")) {
[16:19:13.762]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.762]                         if (muffled) 
[16:19:13.762]                           invokeRestart("muffleWarning")
[16:19:13.762]                       }
[16:19:13.762]                       else if (inherits(cond, "condition")) {
[16:19:13.762]                         if (!is.null(pattern)) {
[16:19:13.762]                           computeRestarts <- base::computeRestarts
[16:19:13.762]                           grepl <- base::grepl
[16:19:13.762]                           restarts <- computeRestarts(cond)
[16:19:13.762]                           for (restart in restarts) {
[16:19:13.762]                             name <- restart$name
[16:19:13.762]                             if (is.null(name)) 
[16:19:13.762]                               next
[16:19:13.762]                             if (!grepl(pattern, name)) 
[16:19:13.762]                               next
[16:19:13.762]                             invokeRestart(restart)
[16:19:13.762]                             muffled <- TRUE
[16:19:13.762]                             break
[16:19:13.762]                           }
[16:19:13.762]                         }
[16:19:13.762]                       }
[16:19:13.762]                       invisible(muffled)
[16:19:13.762]                     }
[16:19:13.762]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.762]                   }
[16:19:13.762]                 }
[16:19:13.762]             }
[16:19:13.762]         }))
[16:19:13.762]     }, error = function(ex) {
[16:19:13.762]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.762]                 ...future.rng), started = ...future.startTime, 
[16:19:13.762]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.762]             version = "1.8"), class = "FutureResult")
[16:19:13.762]     }, finally = {
[16:19:13.762]         if (!identical(...future.workdir, getwd())) 
[16:19:13.762]             setwd(...future.workdir)
[16:19:13.762]         {
[16:19:13.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.762]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.762]             }
[16:19:13.762]             base::options(...future.oldOptions)
[16:19:13.762]             if (.Platform$OS.type == "windows") {
[16:19:13.762]                 old_names <- names(...future.oldEnvVars)
[16:19:13.762]                 envs <- base::Sys.getenv()
[16:19:13.762]                 names <- names(envs)
[16:19:13.762]                 common <- intersect(names, old_names)
[16:19:13.762]                 added <- setdiff(names, old_names)
[16:19:13.762]                 removed <- setdiff(old_names, names)
[16:19:13.762]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.762]                   envs[common]]
[16:19:13.762]                 NAMES <- toupper(changed)
[16:19:13.762]                 args <- list()
[16:19:13.762]                 for (kk in seq_along(NAMES)) {
[16:19:13.762]                   name <- changed[[kk]]
[16:19:13.762]                   NAME <- NAMES[[kk]]
[16:19:13.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.762]                     next
[16:19:13.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.762]                 }
[16:19:13.762]                 NAMES <- toupper(added)
[16:19:13.762]                 for (kk in seq_along(NAMES)) {
[16:19:13.762]                   name <- added[[kk]]
[16:19:13.762]                   NAME <- NAMES[[kk]]
[16:19:13.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.762]                     next
[16:19:13.762]                   args[[name]] <- ""
[16:19:13.762]                 }
[16:19:13.762]                 NAMES <- toupper(removed)
[16:19:13.762]                 for (kk in seq_along(NAMES)) {
[16:19:13.762]                   name <- removed[[kk]]
[16:19:13.762]                   NAME <- NAMES[[kk]]
[16:19:13.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.762]                     next
[16:19:13.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.762]                 }
[16:19:13.762]                 if (length(args) > 0) 
[16:19:13.762]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.762]             }
[16:19:13.762]             else {
[16:19:13.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.762]             }
[16:19:13.762]             {
[16:19:13.762]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.762]                   0L) {
[16:19:13.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.762]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.762]                   base::options(opts)
[16:19:13.762]                 }
[16:19:13.762]                 {
[16:19:13.762]                   {
[16:19:13.762]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.762]                     NULL
[16:19:13.762]                   }
[16:19:13.762]                   options(future.plan = NULL)
[16:19:13.762]                   if (is.na(NA_character_)) 
[16:19:13.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.762]                     .init = FALSE)
[16:19:13.762]                 }
[16:19:13.762]             }
[16:19:13.762]         }
[16:19:13.762]     })
[16:19:13.762]     if (TRUE) {
[16:19:13.762]         base::sink(type = "output", split = FALSE)
[16:19:13.762]         if (TRUE) {
[16:19:13.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.762]         }
[16:19:13.762]         else {
[16:19:13.762]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.762]         }
[16:19:13.762]         base::close(...future.stdout)
[16:19:13.762]         ...future.stdout <- NULL
[16:19:13.762]     }
[16:19:13.762]     ...future.result$conditions <- ...future.conditions
[16:19:13.762]     ...future.result$finished <- base::Sys.time()
[16:19:13.762]     ...future.result
[16:19:13.762] }
[16:19:13.765] assign_globals() ...
[16:19:13.765] List of 11
[16:19:13.765]  $ ...future.FUN            :function (x, ...)  
[16:19:13.765]  $ x_FUN                    :function (x)  
[16:19:13.765]  $ times                    : int 1
[16:19:13.765]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.765]  $ stop_if_not              :function (...)  
[16:19:13.765]  $ dim                      : NULL
[16:19:13.765]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.765]  $ future.call.arguments    : list()
[16:19:13.765]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.765]  $ ...future.elements_ii    :List of 5
[16:19:13.765]   ..$ : int 6
[16:19:13.765]   ..$ : int 7
[16:19:13.765]   ..$ : int 8
[16:19:13.765]   ..$ : int 9
[16:19:13.765]   ..$ : int 10
[16:19:13.765]  $ ...future.seeds_ii       : NULL
[16:19:13.765]  $ ...future.globals.maxSize: NULL
[16:19:13.765]  - attr(*, "where")=List of 11
[16:19:13.765]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.765]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.765]  - attr(*, "resolved")= logi FALSE
[16:19:13.765]  - attr(*, "total_size")= num 94336
[16:19:13.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.765]  - attr(*, "already-done")= logi TRUE
[16:19:13.776] - copied ‘...future.FUN’ to environment
[16:19:13.776] - copied ‘x_FUN’ to environment
[16:19:13.776] - copied ‘times’ to environment
[16:19:13.776] - copied ‘stopf’ to environment
[16:19:13.776] - copied ‘stop_if_not’ to environment
[16:19:13.776] - copied ‘dim’ to environment
[16:19:13.777] - copied ‘valid_types’ to environment
[16:19:13.777] - copied ‘future.call.arguments’ to environment
[16:19:13.777] - copied ‘...future.elements_ii’ to environment
[16:19:13.777] - copied ‘...future.seeds_ii’ to environment
[16:19:13.777] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.777] assign_globals() ... done
[16:19:13.777] requestCore(): workers = 2
[16:19:13.781] MulticoreFuture started
[16:19:13.782] - Launch lazy future ... done
[16:19:13.783] run() for ‘MulticoreFuture’ ... done
[16:19:13.783] Created future:
[16:19:13.784] plan(): Setting new future strategy stack:
[16:19:13.784] List of future strategies:
[16:19:13.784] 1. sequential:
[16:19:13.784]    - args: function (..., envir = parent.frame())
[16:19:13.784]    - tweaked: FALSE
[16:19:13.784]    - call: NULL
[16:19:13.785] plan(): nbrOfWorkers() = 1
[16:19:13.788] plan(): Setting new future strategy stack:
[16:19:13.788] List of future strategies:
[16:19:13.788] 1. multicore:
[16:19:13.788]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.788]    - tweaked: FALSE
[16:19:13.788]    - call: plan(strategy)
[16:19:13.795] plan(): nbrOfWorkers() = 2
[16:19:13.784] MulticoreFuture:
[16:19:13.784] Label: ‘future_vapply-2’
[16:19:13.784] Expression:
[16:19:13.784] {
[16:19:13.784]     do.call(function(...) {
[16:19:13.784]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.784]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.784]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.784]             on.exit(options(oopts), add = TRUE)
[16:19:13.784]         }
[16:19:13.784]         {
[16:19:13.784]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.784]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.784]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.784]             })
[16:19:13.784]         }
[16:19:13.784]     }, args = future.call.arguments)
[16:19:13.784] }
[16:19:13.784] Lazy evaluation: FALSE
[16:19:13.784] Asynchronous evaluation: TRUE
[16:19:13.784] Local evaluation: TRUE
[16:19:13.784] Environment: R_GlobalEnv
[16:19:13.784] Capture standard output: TRUE
[16:19:13.784] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.784] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.784] Packages: 1 packages (‘future.apply’)
[16:19:13.784] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.784] Resolved: TRUE
[16:19:13.784] Value: <not collected>
[16:19:13.784] Conditions captured: <none>
[16:19:13.784] Early signaling: FALSE
[16:19:13.784] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.784] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.796] Chunk #2 of 2 ... DONE
[16:19:13.796] Launching 2 futures (chunks) ... DONE
[16:19:13.797] Resolving 2 futures (chunks) ...
[16:19:13.797] resolve() on list ...
[16:19:13.797]  recursive: 0
[16:19:13.797]  length: 2
[16:19:13.797] 
[16:19:13.798] Future #1
[16:19:13.798] result() for MulticoreFuture ...
[16:19:13.799] result() for MulticoreFuture ...
[16:19:13.799] result() for MulticoreFuture ... done
[16:19:13.800] result() for MulticoreFuture ... done
[16:19:13.800] result() for MulticoreFuture ...
[16:19:13.800] result() for MulticoreFuture ... done
[16:19:13.801] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:13.801] - nx: 2
[16:19:13.801] - relay: TRUE
[16:19:13.801] - stdout: TRUE
[16:19:13.802] - signal: TRUE
[16:19:13.802] - resignal: FALSE
[16:19:13.802] - force: TRUE
[16:19:13.802] - relayed: [n=2] FALSE, FALSE
[16:19:13.802] - queued futures: [n=2] FALSE, FALSE
[16:19:13.803]  - until=1
[16:19:13.803]  - relaying element #1
[16:19:13.803] result() for MulticoreFuture ...
[16:19:13.803] result() for MulticoreFuture ... done
[16:19:13.803] result() for MulticoreFuture ...
[16:19:13.803] result() for MulticoreFuture ... done
[16:19:13.804] result() for MulticoreFuture ...
[16:19:13.804] result() for MulticoreFuture ... done
[16:19:13.804] result() for MulticoreFuture ...
[16:19:13.804] result() for MulticoreFuture ... done
[16:19:13.805] - relayed: [n=2] TRUE, FALSE
[16:19:13.805] - queued futures: [n=2] TRUE, FALSE
[16:19:13.805] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:13.805]  length: 1 (resolved future 1)
[16:19:13.806] Future #2
[16:19:13.806] result() for MulticoreFuture ...
[16:19:13.807] result() for MulticoreFuture ...
[16:19:13.807] result() for MulticoreFuture ... done
[16:19:13.807] result() for MulticoreFuture ... done
[16:19:13.807] result() for MulticoreFuture ...
[16:19:13.807] result() for MulticoreFuture ... done
[16:19:13.807] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:13.808] - nx: 2
[16:19:13.808] - relay: TRUE
[16:19:13.808] - stdout: TRUE
[16:19:13.808] - signal: TRUE
[16:19:13.808] - resignal: FALSE
[16:19:13.808] - force: TRUE
[16:19:13.808] - relayed: [n=2] TRUE, FALSE
[16:19:13.808] - queued futures: [n=2] TRUE, FALSE
[16:19:13.808]  - until=2
[16:19:13.809]  - relaying element #2
[16:19:13.809] result() for MulticoreFuture ...
[16:19:13.809] result() for MulticoreFuture ... done
[16:19:13.809] result() for MulticoreFuture ...
[16:19:13.809] result() for MulticoreFuture ... done
[16:19:13.809] result() for MulticoreFuture ...
[16:19:13.809] result() for MulticoreFuture ... done
[16:19:13.809] result() for MulticoreFuture ...
[16:19:13.810] result() for MulticoreFuture ... done
[16:19:13.810] - relayed: [n=2] TRUE, TRUE
[16:19:13.810] - queued futures: [n=2] TRUE, TRUE
[16:19:13.810] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:13.810]  length: 0 (resolved future 2)
[16:19:13.810] Relaying remaining futures
[16:19:13.810] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.810] - nx: 2
[16:19:13.810] - relay: TRUE
[16:19:13.810] - stdout: TRUE
[16:19:13.811] - signal: TRUE
[16:19:13.811] - resignal: FALSE
[16:19:13.811] - force: TRUE
[16:19:13.811] - relayed: [n=2] TRUE, TRUE
[16:19:13.811] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:13.811] - relayed: [n=2] TRUE, TRUE
[16:19:13.811] - queued futures: [n=2] TRUE, TRUE
[16:19:13.811] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.811] resolve() on list ... DONE
[16:19:13.812] result() for MulticoreFuture ...
[16:19:13.812] result() for MulticoreFuture ... done
[16:19:13.812] result() for MulticoreFuture ...
[16:19:13.812] result() for MulticoreFuture ... done
[16:19:13.812] result() for MulticoreFuture ...
[16:19:13.812] result() for MulticoreFuture ... done
[16:19:13.812] result() for MulticoreFuture ...
[16:19:13.812] result() for MulticoreFuture ... done
[16:19:13.812]  - Number of value chunks collected: 2
[16:19:13.813] Resolving 2 futures (chunks) ... DONE
[16:19:13.813] Reducing values from 2 chunks ...
[16:19:13.813]  - Number of values collected after concatenation: 10
[16:19:13.813]  - Number of values expected: 10
[16:19:13.813] Reducing values from 2 chunks ... DONE
[16:19:13.813] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:19:13.814] future_lapply() ...
[16:19:13.820] Number of chunks: 2
[16:19:13.820] getGlobalsAndPackagesXApply() ...
[16:19:13.820]  - future.globals: TRUE
[16:19:13.820] getGlobalsAndPackages() ...
[16:19:13.820] Searching for globals...
[16:19:13.826] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:19:13.827] Searching for globals ... DONE
[16:19:13.827] Resolving globals: FALSE
[16:19:13.828] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:19:13.828] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.828] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.829] - packages: [1] ‘future.apply’
[16:19:13.829] getGlobalsAndPackages() ... DONE
[16:19:13.829]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.829]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.829] Finding globals ... DONE
[16:19:13.829]  - use_args: TRUE
[16:19:13.829]  - Getting '...' globals ...
[16:19:13.830] resolve() on list ...
[16:19:13.830]  recursive: 0
[16:19:13.830]  length: 1
[16:19:13.830]  elements: ‘...’
[16:19:13.830]  length: 0 (resolved future 1)
[16:19:13.830] resolve() on list ... DONE
[16:19:13.830]    - '...' content: [n=0] 
[16:19:13.830] List of 1
[16:19:13.830]  $ ...: list()
[16:19:13.830]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.830]  - attr(*, "where")=List of 1
[16:19:13.830]   ..$ ...:<environment: 0x56199ef04e18> 
[16:19:13.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.830]  - attr(*, "resolved")= logi TRUE
[16:19:13.830]  - attr(*, "total_size")= num NA
[16:19:13.833]  - Getting '...' globals ... DONE
[16:19:13.833] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.833] List of 8
[16:19:13.833]  $ ...future.FUN:function (x, ...)  
[16:19:13.833]  $ x_FUN        :function (x)  
[16:19:13.833]  $ times        : int 2
[16:19:13.833]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.833]  $ stop_if_not  :function (...)  
[16:19:13.833]  $ dim          : NULL
[16:19:13.833]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:13.833]  $ ...          : list()
[16:19:13.833]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.833]  - attr(*, "where")=List of 8
[16:19:13.833]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.833]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.833]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.833]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.833]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.833]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.833]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.833]   ..$ ...          :<environment: 0x56199ef04e18> 
[16:19:13.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.833]  - attr(*, "resolved")= logi FALSE
[16:19:13.833]  - attr(*, "total_size")= num 96456
[16:19:13.838] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.839] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.839] Number of futures (= number of chunks): 2
[16:19:13.839] Launching 2 futures (chunks) ...
[16:19:13.839] Chunk #1 of 2 ...
[16:19:13.839]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.839] getGlobalsAndPackages() ...
[16:19:13.839] Searching for globals...
[16:19:13.840] 
[16:19:13.840] Searching for globals ... DONE
[16:19:13.840] - globals: [0] <none>
[16:19:13.840] getGlobalsAndPackages() ... DONE
[16:19:13.840]    + additional globals found: [n=0] 
[16:19:13.840]    + additional namespaces needed: [n=0] 
[16:19:13.840]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.840]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.840]  - seeds: <none>
[16:19:13.841]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.841] getGlobalsAndPackages() ...
[16:19:13.841] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.841] Resolving globals: FALSE
[16:19:13.841] Tweak future expression to call with '...' arguments ...
[16:19:13.841] {
[16:19:13.841]     do.call(function(...) {
[16:19:13.841]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.841]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.841]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.841]             on.exit(options(oopts), add = TRUE)
[16:19:13.841]         }
[16:19:13.841]         {
[16:19:13.841]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.841]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.841]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.841]             })
[16:19:13.841]         }
[16:19:13.841]     }, args = future.call.arguments)
[16:19:13.841] }
[16:19:13.841] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.842] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.842] - packages: [1] ‘future.apply’
[16:19:13.842] getGlobalsAndPackages() ... DONE
[16:19:13.842] run() for ‘Future’ ...
[16:19:13.842] - state: ‘created’
[16:19:13.843] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.848] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.848]   - Field: ‘label’
[16:19:13.848]   - Field: ‘local’
[16:19:13.848]   - Field: ‘owner’
[16:19:13.848]   - Field: ‘envir’
[16:19:13.849]   - Field: ‘workers’
[16:19:13.849]   - Field: ‘packages’
[16:19:13.849]   - Field: ‘gc’
[16:19:13.849]   - Field: ‘job’
[16:19:13.849]   - Field: ‘conditions’
[16:19:13.849]   - Field: ‘expr’
[16:19:13.849]   - Field: ‘uuid’
[16:19:13.849]   - Field: ‘seed’
[16:19:13.849]   - Field: ‘version’
[16:19:13.849]   - Field: ‘result’
[16:19:13.850]   - Field: ‘asynchronous’
[16:19:13.850]   - Field: ‘calls’
[16:19:13.850]   - Field: ‘globals’
[16:19:13.850]   - Field: ‘stdout’
[16:19:13.850]   - Field: ‘earlySignal’
[16:19:13.850]   - Field: ‘lazy’
[16:19:13.850]   - Field: ‘state’
[16:19:13.850] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.850] - Launch lazy future ...
[16:19:13.851] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.851] Packages needed by future strategies (n = 0): <none>
[16:19:13.851] {
[16:19:13.851]     {
[16:19:13.851]         {
[16:19:13.851]             ...future.startTime <- base::Sys.time()
[16:19:13.851]             {
[16:19:13.851]                 {
[16:19:13.851]                   {
[16:19:13.851]                     {
[16:19:13.851]                       {
[16:19:13.851]                         base::local({
[16:19:13.851]                           has_future <- base::requireNamespace("future", 
[16:19:13.851]                             quietly = TRUE)
[16:19:13.851]                           if (has_future) {
[16:19:13.851]                             ns <- base::getNamespace("future")
[16:19:13.851]                             version <- ns[[".package"]][["version"]]
[16:19:13.851]                             if (is.null(version)) 
[16:19:13.851]                               version <- utils::packageVersion("future")
[16:19:13.851]                           }
[16:19:13.851]                           else {
[16:19:13.851]                             version <- NULL
[16:19:13.851]                           }
[16:19:13.851]                           if (!has_future || version < "1.8.0") {
[16:19:13.851]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.851]                               "", base::R.version$version.string), 
[16:19:13.851]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.851]                                 base::R.version$platform, 8 * 
[16:19:13.851]                                   base::.Machine$sizeof.pointer), 
[16:19:13.851]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.851]                                 "release", "version")], collapse = " "), 
[16:19:13.851]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.851]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.851]                               info)
[16:19:13.851]                             info <- base::paste(info, collapse = "; ")
[16:19:13.851]                             if (!has_future) {
[16:19:13.851]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.851]                                 info)
[16:19:13.851]                             }
[16:19:13.851]                             else {
[16:19:13.851]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.851]                                 info, version)
[16:19:13.851]                             }
[16:19:13.851]                             base::stop(msg)
[16:19:13.851]                           }
[16:19:13.851]                         })
[16:19:13.851]                       }
[16:19:13.851]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.851]                       base::options(mc.cores = 1L)
[16:19:13.851]                     }
[16:19:13.851]                     base::local({
[16:19:13.851]                       for (pkg in "future.apply") {
[16:19:13.851]                         base::loadNamespace(pkg)
[16:19:13.851]                         base::library(pkg, character.only = TRUE)
[16:19:13.851]                       }
[16:19:13.851]                     })
[16:19:13.851]                   }
[16:19:13.851]                   ...future.strategy.old <- future::plan("list")
[16:19:13.851]                   options(future.plan = NULL)
[16:19:13.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.851]                 }
[16:19:13.851]                 ...future.workdir <- getwd()
[16:19:13.851]             }
[16:19:13.851]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.851]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.851]         }
[16:19:13.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.851]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.851]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.851]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.851]             base::names(...future.oldOptions))
[16:19:13.851]     }
[16:19:13.851]     if (FALSE) {
[16:19:13.851]     }
[16:19:13.851]     else {
[16:19:13.851]         if (TRUE) {
[16:19:13.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.851]                 open = "w")
[16:19:13.851]         }
[16:19:13.851]         else {
[16:19:13.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.851]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.851]         }
[16:19:13.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.851]             base::sink(type = "output", split = FALSE)
[16:19:13.851]             base::close(...future.stdout)
[16:19:13.851]         }, add = TRUE)
[16:19:13.851]     }
[16:19:13.851]     ...future.frame <- base::sys.nframe()
[16:19:13.851]     ...future.conditions <- base::list()
[16:19:13.851]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.851]     if (FALSE) {
[16:19:13.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.851]     }
[16:19:13.851]     ...future.result <- base::tryCatch({
[16:19:13.851]         base::withCallingHandlers({
[16:19:13.851]             ...future.value <- base::withVisible(base::local({
[16:19:13.851]                 withCallingHandlers({
[16:19:13.851]                   {
[16:19:13.851]                     do.call(function(...) {
[16:19:13.851]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.851]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.851]                         ...future.globals.maxSize)) {
[16:19:13.851]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.851]                         on.exit(options(oopts), add = TRUE)
[16:19:13.851]                       }
[16:19:13.851]                       {
[16:19:13.851]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.851]                           FUN = function(jj) {
[16:19:13.851]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.851]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.851]                           })
[16:19:13.851]                       }
[16:19:13.851]                     }, args = future.call.arguments)
[16:19:13.851]                   }
[16:19:13.851]                 }, immediateCondition = function(cond) {
[16:19:13.851]                   save_rds <- function (object, pathname, ...) 
[16:19:13.851]                   {
[16:19:13.851]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.851]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.851]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.851]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.851]                         fi_tmp[["mtime"]])
[16:19:13.851]                     }
[16:19:13.851]                     tryCatch({
[16:19:13.851]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.851]                     }, error = function(ex) {
[16:19:13.851]                       msg <- conditionMessage(ex)
[16:19:13.851]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.851]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.851]                         fi_tmp[["mtime"]], msg)
[16:19:13.851]                       ex$message <- msg
[16:19:13.851]                       stop(ex)
[16:19:13.851]                     })
[16:19:13.851]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.851]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.851]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.851]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.851]                       fi <- file.info(pathname)
[16:19:13.851]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.851]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.851]                         fi[["size"]], fi[["mtime"]])
[16:19:13.851]                       stop(msg)
[16:19:13.851]                     }
[16:19:13.851]                     invisible(pathname)
[16:19:13.851]                   }
[16:19:13.851]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.851]                     rootPath = tempdir()) 
[16:19:13.851]                   {
[16:19:13.851]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.851]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.851]                       tmpdir = path, fileext = ".rds")
[16:19:13.851]                     save_rds(obj, file)
[16:19:13.851]                   }
[16:19:13.851]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.851]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.851]                   {
[16:19:13.851]                     inherits <- base::inherits
[16:19:13.851]                     invokeRestart <- base::invokeRestart
[16:19:13.851]                     is.null <- base::is.null
[16:19:13.851]                     muffled <- FALSE
[16:19:13.851]                     if (inherits(cond, "message")) {
[16:19:13.851]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.851]                       if (muffled) 
[16:19:13.851]                         invokeRestart("muffleMessage")
[16:19:13.851]                     }
[16:19:13.851]                     else if (inherits(cond, "warning")) {
[16:19:13.851]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.851]                       if (muffled) 
[16:19:13.851]                         invokeRestart("muffleWarning")
[16:19:13.851]                     }
[16:19:13.851]                     else if (inherits(cond, "condition")) {
[16:19:13.851]                       if (!is.null(pattern)) {
[16:19:13.851]                         computeRestarts <- base::computeRestarts
[16:19:13.851]                         grepl <- base::grepl
[16:19:13.851]                         restarts <- computeRestarts(cond)
[16:19:13.851]                         for (restart in restarts) {
[16:19:13.851]                           name <- restart$name
[16:19:13.851]                           if (is.null(name)) 
[16:19:13.851]                             next
[16:19:13.851]                           if (!grepl(pattern, name)) 
[16:19:13.851]                             next
[16:19:13.851]                           invokeRestart(restart)
[16:19:13.851]                           muffled <- TRUE
[16:19:13.851]                           break
[16:19:13.851]                         }
[16:19:13.851]                       }
[16:19:13.851]                     }
[16:19:13.851]                     invisible(muffled)
[16:19:13.851]                   }
[16:19:13.851]                   muffleCondition(cond)
[16:19:13.851]                 })
[16:19:13.851]             }))
[16:19:13.851]             future::FutureResult(value = ...future.value$value, 
[16:19:13.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.851]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.851]                     ...future.globalenv.names))
[16:19:13.851]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.851]         }, condition = base::local({
[16:19:13.851]             c <- base::c
[16:19:13.851]             inherits <- base::inherits
[16:19:13.851]             invokeRestart <- base::invokeRestart
[16:19:13.851]             length <- base::length
[16:19:13.851]             list <- base::list
[16:19:13.851]             seq.int <- base::seq.int
[16:19:13.851]             signalCondition <- base::signalCondition
[16:19:13.851]             sys.calls <- base::sys.calls
[16:19:13.851]             `[[` <- base::`[[`
[16:19:13.851]             `+` <- base::`+`
[16:19:13.851]             `<<-` <- base::`<<-`
[16:19:13.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.851]                   3L)]
[16:19:13.851]             }
[16:19:13.851]             function(cond) {
[16:19:13.851]                 is_error <- inherits(cond, "error")
[16:19:13.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.851]                   NULL)
[16:19:13.851]                 if (is_error) {
[16:19:13.851]                   sessionInformation <- function() {
[16:19:13.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.851]                       search = base::search(), system = base::Sys.info())
[16:19:13.851]                   }
[16:19:13.851]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.851]                     cond$call), session = sessionInformation(), 
[16:19:13.851]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.851]                   signalCondition(cond)
[16:19:13.851]                 }
[16:19:13.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.851]                 "immediateCondition"))) {
[16:19:13.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.851]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.851]                   if (TRUE && !signal) {
[16:19:13.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.851]                     {
[16:19:13.851]                       inherits <- base::inherits
[16:19:13.851]                       invokeRestart <- base::invokeRestart
[16:19:13.851]                       is.null <- base::is.null
[16:19:13.851]                       muffled <- FALSE
[16:19:13.851]                       if (inherits(cond, "message")) {
[16:19:13.851]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.851]                         if (muffled) 
[16:19:13.851]                           invokeRestart("muffleMessage")
[16:19:13.851]                       }
[16:19:13.851]                       else if (inherits(cond, "warning")) {
[16:19:13.851]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.851]                         if (muffled) 
[16:19:13.851]                           invokeRestart("muffleWarning")
[16:19:13.851]                       }
[16:19:13.851]                       else if (inherits(cond, "condition")) {
[16:19:13.851]                         if (!is.null(pattern)) {
[16:19:13.851]                           computeRestarts <- base::computeRestarts
[16:19:13.851]                           grepl <- base::grepl
[16:19:13.851]                           restarts <- computeRestarts(cond)
[16:19:13.851]                           for (restart in restarts) {
[16:19:13.851]                             name <- restart$name
[16:19:13.851]                             if (is.null(name)) 
[16:19:13.851]                               next
[16:19:13.851]                             if (!grepl(pattern, name)) 
[16:19:13.851]                               next
[16:19:13.851]                             invokeRestart(restart)
[16:19:13.851]                             muffled <- TRUE
[16:19:13.851]                             break
[16:19:13.851]                           }
[16:19:13.851]                         }
[16:19:13.851]                       }
[16:19:13.851]                       invisible(muffled)
[16:19:13.851]                     }
[16:19:13.851]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.851]                   }
[16:19:13.851]                 }
[16:19:13.851]                 else {
[16:19:13.851]                   if (TRUE) {
[16:19:13.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.851]                     {
[16:19:13.851]                       inherits <- base::inherits
[16:19:13.851]                       invokeRestart <- base::invokeRestart
[16:19:13.851]                       is.null <- base::is.null
[16:19:13.851]                       muffled <- FALSE
[16:19:13.851]                       if (inherits(cond, "message")) {
[16:19:13.851]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.851]                         if (muffled) 
[16:19:13.851]                           invokeRestart("muffleMessage")
[16:19:13.851]                       }
[16:19:13.851]                       else if (inherits(cond, "warning")) {
[16:19:13.851]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.851]                         if (muffled) 
[16:19:13.851]                           invokeRestart("muffleWarning")
[16:19:13.851]                       }
[16:19:13.851]                       else if (inherits(cond, "condition")) {
[16:19:13.851]                         if (!is.null(pattern)) {
[16:19:13.851]                           computeRestarts <- base::computeRestarts
[16:19:13.851]                           grepl <- base::grepl
[16:19:13.851]                           restarts <- computeRestarts(cond)
[16:19:13.851]                           for (restart in restarts) {
[16:19:13.851]                             name <- restart$name
[16:19:13.851]                             if (is.null(name)) 
[16:19:13.851]                               next
[16:19:13.851]                             if (!grepl(pattern, name)) 
[16:19:13.851]                               next
[16:19:13.851]                             invokeRestart(restart)
[16:19:13.851]                             muffled <- TRUE
[16:19:13.851]                             break
[16:19:13.851]                           }
[16:19:13.851]                         }
[16:19:13.851]                       }
[16:19:13.851]                       invisible(muffled)
[16:19:13.851]                     }
[16:19:13.851]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.851]                   }
[16:19:13.851]                 }
[16:19:13.851]             }
[16:19:13.851]         }))
[16:19:13.851]     }, error = function(ex) {
[16:19:13.851]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.851]                 ...future.rng), started = ...future.startTime, 
[16:19:13.851]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.851]             version = "1.8"), class = "FutureResult")
[16:19:13.851]     }, finally = {
[16:19:13.851]         if (!identical(...future.workdir, getwd())) 
[16:19:13.851]             setwd(...future.workdir)
[16:19:13.851]         {
[16:19:13.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.851]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.851]             }
[16:19:13.851]             base::options(...future.oldOptions)
[16:19:13.851]             if (.Platform$OS.type == "windows") {
[16:19:13.851]                 old_names <- names(...future.oldEnvVars)
[16:19:13.851]                 envs <- base::Sys.getenv()
[16:19:13.851]                 names <- names(envs)
[16:19:13.851]                 common <- intersect(names, old_names)
[16:19:13.851]                 added <- setdiff(names, old_names)
[16:19:13.851]                 removed <- setdiff(old_names, names)
[16:19:13.851]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.851]                   envs[common]]
[16:19:13.851]                 NAMES <- toupper(changed)
[16:19:13.851]                 args <- list()
[16:19:13.851]                 for (kk in seq_along(NAMES)) {
[16:19:13.851]                   name <- changed[[kk]]
[16:19:13.851]                   NAME <- NAMES[[kk]]
[16:19:13.851]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.851]                     next
[16:19:13.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.851]                 }
[16:19:13.851]                 NAMES <- toupper(added)
[16:19:13.851]                 for (kk in seq_along(NAMES)) {
[16:19:13.851]                   name <- added[[kk]]
[16:19:13.851]                   NAME <- NAMES[[kk]]
[16:19:13.851]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.851]                     next
[16:19:13.851]                   args[[name]] <- ""
[16:19:13.851]                 }
[16:19:13.851]                 NAMES <- toupper(removed)
[16:19:13.851]                 for (kk in seq_along(NAMES)) {
[16:19:13.851]                   name <- removed[[kk]]
[16:19:13.851]                   NAME <- NAMES[[kk]]
[16:19:13.851]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.851]                     next
[16:19:13.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.851]                 }
[16:19:13.851]                 if (length(args) > 0) 
[16:19:13.851]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.851]             }
[16:19:13.851]             else {
[16:19:13.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.851]             }
[16:19:13.851]             {
[16:19:13.851]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.851]                   0L) {
[16:19:13.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.851]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.851]                   base::options(opts)
[16:19:13.851]                 }
[16:19:13.851]                 {
[16:19:13.851]                   {
[16:19:13.851]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.851]                     NULL
[16:19:13.851]                   }
[16:19:13.851]                   options(future.plan = NULL)
[16:19:13.851]                   if (is.na(NA_character_)) 
[16:19:13.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.851]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.851]                     .init = FALSE)
[16:19:13.851]                 }
[16:19:13.851]             }
[16:19:13.851]         }
[16:19:13.851]     })
[16:19:13.851]     if (TRUE) {
[16:19:13.851]         base::sink(type = "output", split = FALSE)
[16:19:13.851]         if (TRUE) {
[16:19:13.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.851]         }
[16:19:13.851]         else {
[16:19:13.851]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.851]         }
[16:19:13.851]         base::close(...future.stdout)
[16:19:13.851]         ...future.stdout <- NULL
[16:19:13.851]     }
[16:19:13.851]     ...future.result$conditions <- ...future.conditions
[16:19:13.851]     ...future.result$finished <- base::Sys.time()
[16:19:13.851]     ...future.result
[16:19:13.851] }
[16:19:13.854] assign_globals() ...
[16:19:13.854] List of 11
[16:19:13.854]  $ ...future.FUN            :function (x, ...)  
[16:19:13.854]  $ x_FUN                    :function (x)  
[16:19:13.854]  $ times                    : int 2
[16:19:13.854]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.854]  $ stop_if_not              :function (...)  
[16:19:13.854]  $ dim                      : NULL
[16:19:13.854]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.854]  $ future.call.arguments    : list()
[16:19:13.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.854]  $ ...future.elements_ii    :List of 5
[16:19:13.854]   ..$ : int 1
[16:19:13.854]   ..$ : int 2
[16:19:13.854]   ..$ : int 3
[16:19:13.854]   ..$ : int 4
[16:19:13.854]   ..$ : int 5
[16:19:13.854]  $ ...future.seeds_ii       : NULL
[16:19:13.854]  $ ...future.globals.maxSize: NULL
[16:19:13.854]  - attr(*, "where")=List of 11
[16:19:13.854]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.854]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.854]  - attr(*, "resolved")= logi FALSE
[16:19:13.854]  - attr(*, "total_size")= num 96456
[16:19:13.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.854]  - attr(*, "already-done")= logi TRUE
[16:19:13.862] - copied ‘...future.FUN’ to environment
[16:19:13.862] - reassign environment for ‘x_FUN’
[16:19:13.862] - copied ‘x_FUN’ to environment
[16:19:13.862] - copied ‘times’ to environment
[16:19:13.862] - copied ‘stopf’ to environment
[16:19:13.863] - copied ‘stop_if_not’ to environment
[16:19:13.863] - copied ‘dim’ to environment
[16:19:13.863] - copied ‘valid_types’ to environment
[16:19:13.863] - copied ‘future.call.arguments’ to environment
[16:19:13.863] - copied ‘...future.elements_ii’ to environment
[16:19:13.863] - copied ‘...future.seeds_ii’ to environment
[16:19:13.863] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.863] assign_globals() ... done
[16:19:13.863] requestCore(): workers = 2
[16:19:13.866] MulticoreFuture started
[16:19:13.866] - Launch lazy future ... done
[16:19:13.866] run() for ‘MulticoreFuture’ ... done
[16:19:13.867] Created future:
[16:19:13.867] plan(): Setting new future strategy stack:
[16:19:13.867] List of future strategies:
[16:19:13.867] 1. sequential:
[16:19:13.867]    - args: function (..., envir = parent.frame())
[16:19:13.867]    - tweaked: FALSE
[16:19:13.867]    - call: NULL
[16:19:13.868] plan(): nbrOfWorkers() = 1
[16:19:13.870] plan(): Setting new future strategy stack:
[16:19:13.870] List of future strategies:
[16:19:13.870] 1. multicore:
[16:19:13.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.870]    - tweaked: FALSE
[16:19:13.870]    - call: plan(strategy)
[16:19:13.876] plan(): nbrOfWorkers() = 2
[16:19:13.867] MulticoreFuture:
[16:19:13.867] Label: ‘future_vapply-1’
[16:19:13.867] Expression:
[16:19:13.867] {
[16:19:13.867]     do.call(function(...) {
[16:19:13.867]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.867]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.867]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.867]             on.exit(options(oopts), add = TRUE)
[16:19:13.867]         }
[16:19:13.867]         {
[16:19:13.867]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.867]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.867]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.867]             })
[16:19:13.867]         }
[16:19:13.867]     }, args = future.call.arguments)
[16:19:13.867] }
[16:19:13.867] Lazy evaluation: FALSE
[16:19:13.867] Asynchronous evaluation: TRUE
[16:19:13.867] Local evaluation: TRUE
[16:19:13.867] Environment: R_GlobalEnv
[16:19:13.867] Capture standard output: TRUE
[16:19:13.867] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.867] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.867] Packages: 1 packages (‘future.apply’)
[16:19:13.867] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.867] Resolved: FALSE
[16:19:13.867] Value: <not collected>
[16:19:13.867] Conditions captured: <none>
[16:19:13.867] Early signaling: FALSE
[16:19:13.867] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.867] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.880] Chunk #1 of 2 ... DONE
[16:19:13.880] Chunk #2 of 2 ...
[16:19:13.880]  - Finding globals in 'X' for chunk #2 ...
[16:19:13.880] getGlobalsAndPackages() ...
[16:19:13.881] Searching for globals...
[16:19:13.881] 
[16:19:13.881] Searching for globals ... DONE
[16:19:13.881] - globals: [0] <none>
[16:19:13.881] getGlobalsAndPackages() ... DONE
[16:19:13.882]    + additional globals found: [n=0] 
[16:19:13.882]    + additional namespaces needed: [n=0] 
[16:19:13.882]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:13.884]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.884]  - seeds: <none>
[16:19:13.885]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.885] getGlobalsAndPackages() ...
[16:19:13.885] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.886] Resolving globals: FALSE
[16:19:13.886] Tweak future expression to call with '...' arguments ...
[16:19:13.887] {
[16:19:13.887]     do.call(function(...) {
[16:19:13.887]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.887]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.887]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.887]             on.exit(options(oopts), add = TRUE)
[16:19:13.887]         }
[16:19:13.887]         {
[16:19:13.887]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.887]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.887]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.887]             })
[16:19:13.887]         }
[16:19:13.887]     }, args = future.call.arguments)
[16:19:13.887] }
[16:19:13.888] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.889] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.889] - packages: [1] ‘future.apply’
[16:19:13.890] getGlobalsAndPackages() ... DONE
[16:19:13.890] run() for ‘Future’ ...
[16:19:13.891] - state: ‘created’
[16:19:13.891] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.897] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.897] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.897]   - Field: ‘label’
[16:19:13.897]   - Field: ‘local’
[16:19:13.898]   - Field: ‘owner’
[16:19:13.898]   - Field: ‘envir’
[16:19:13.898]   - Field: ‘workers’
[16:19:13.898]   - Field: ‘packages’
[16:19:13.898]   - Field: ‘gc’
[16:19:13.898]   - Field: ‘job’
[16:19:13.898]   - Field: ‘conditions’
[16:19:13.899]   - Field: ‘expr’
[16:19:13.899]   - Field: ‘uuid’
[16:19:13.899]   - Field: ‘seed’
[16:19:13.899]   - Field: ‘version’
[16:19:13.899]   - Field: ‘result’
[16:19:13.899]   - Field: ‘asynchronous’
[16:19:13.899]   - Field: ‘calls’
[16:19:13.900]   - Field: ‘globals’
[16:19:13.900]   - Field: ‘stdout’
[16:19:13.900]   - Field: ‘earlySignal’
[16:19:13.900]   - Field: ‘lazy’
[16:19:13.901]   - Field: ‘state’
[16:19:13.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.901] - Launch lazy future ...
[16:19:13.901] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.902] Packages needed by future strategies (n = 0): <none>
[16:19:13.902] {
[16:19:13.902]     {
[16:19:13.902]         {
[16:19:13.902]             ...future.startTime <- base::Sys.time()
[16:19:13.902]             {
[16:19:13.902]                 {
[16:19:13.902]                   {
[16:19:13.902]                     {
[16:19:13.902]                       {
[16:19:13.902]                         base::local({
[16:19:13.902]                           has_future <- base::requireNamespace("future", 
[16:19:13.902]                             quietly = TRUE)
[16:19:13.902]                           if (has_future) {
[16:19:13.902]                             ns <- base::getNamespace("future")
[16:19:13.902]                             version <- ns[[".package"]][["version"]]
[16:19:13.902]                             if (is.null(version)) 
[16:19:13.902]                               version <- utils::packageVersion("future")
[16:19:13.902]                           }
[16:19:13.902]                           else {
[16:19:13.902]                             version <- NULL
[16:19:13.902]                           }
[16:19:13.902]                           if (!has_future || version < "1.8.0") {
[16:19:13.902]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.902]                               "", base::R.version$version.string), 
[16:19:13.902]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.902]                                 base::R.version$platform, 8 * 
[16:19:13.902]                                   base::.Machine$sizeof.pointer), 
[16:19:13.902]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.902]                                 "release", "version")], collapse = " "), 
[16:19:13.902]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.902]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.902]                               info)
[16:19:13.902]                             info <- base::paste(info, collapse = "; ")
[16:19:13.902]                             if (!has_future) {
[16:19:13.902]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.902]                                 info)
[16:19:13.902]                             }
[16:19:13.902]                             else {
[16:19:13.902]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.902]                                 info, version)
[16:19:13.902]                             }
[16:19:13.902]                             base::stop(msg)
[16:19:13.902]                           }
[16:19:13.902]                         })
[16:19:13.902]                       }
[16:19:13.902]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.902]                       base::options(mc.cores = 1L)
[16:19:13.902]                     }
[16:19:13.902]                     base::local({
[16:19:13.902]                       for (pkg in "future.apply") {
[16:19:13.902]                         base::loadNamespace(pkg)
[16:19:13.902]                         base::library(pkg, character.only = TRUE)
[16:19:13.902]                       }
[16:19:13.902]                     })
[16:19:13.902]                   }
[16:19:13.902]                   ...future.strategy.old <- future::plan("list")
[16:19:13.902]                   options(future.plan = NULL)
[16:19:13.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.902]                 }
[16:19:13.902]                 ...future.workdir <- getwd()
[16:19:13.902]             }
[16:19:13.902]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.902]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.902]         }
[16:19:13.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.902]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.902]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.902]             base::names(...future.oldOptions))
[16:19:13.902]     }
[16:19:13.902]     if (FALSE) {
[16:19:13.902]     }
[16:19:13.902]     else {
[16:19:13.902]         if (TRUE) {
[16:19:13.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.902]                 open = "w")
[16:19:13.902]         }
[16:19:13.902]         else {
[16:19:13.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.902]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.902]         }
[16:19:13.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.902]             base::sink(type = "output", split = FALSE)
[16:19:13.902]             base::close(...future.stdout)
[16:19:13.902]         }, add = TRUE)
[16:19:13.902]     }
[16:19:13.902]     ...future.frame <- base::sys.nframe()
[16:19:13.902]     ...future.conditions <- base::list()
[16:19:13.902]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.902]     if (FALSE) {
[16:19:13.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.902]     }
[16:19:13.902]     ...future.result <- base::tryCatch({
[16:19:13.902]         base::withCallingHandlers({
[16:19:13.902]             ...future.value <- base::withVisible(base::local({
[16:19:13.902]                 withCallingHandlers({
[16:19:13.902]                   {
[16:19:13.902]                     do.call(function(...) {
[16:19:13.902]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.902]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.902]                         ...future.globals.maxSize)) {
[16:19:13.902]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.902]                         on.exit(options(oopts), add = TRUE)
[16:19:13.902]                       }
[16:19:13.902]                       {
[16:19:13.902]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.902]                           FUN = function(jj) {
[16:19:13.902]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.902]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.902]                           })
[16:19:13.902]                       }
[16:19:13.902]                     }, args = future.call.arguments)
[16:19:13.902]                   }
[16:19:13.902]                 }, immediateCondition = function(cond) {
[16:19:13.902]                   save_rds <- function (object, pathname, ...) 
[16:19:13.902]                   {
[16:19:13.902]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.902]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.902]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.902]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.902]                         fi_tmp[["mtime"]])
[16:19:13.902]                     }
[16:19:13.902]                     tryCatch({
[16:19:13.902]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.902]                     }, error = function(ex) {
[16:19:13.902]                       msg <- conditionMessage(ex)
[16:19:13.902]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.902]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.902]                         fi_tmp[["mtime"]], msg)
[16:19:13.902]                       ex$message <- msg
[16:19:13.902]                       stop(ex)
[16:19:13.902]                     })
[16:19:13.902]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.902]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.902]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.902]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.902]                       fi <- file.info(pathname)
[16:19:13.902]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.902]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.902]                         fi[["size"]], fi[["mtime"]])
[16:19:13.902]                       stop(msg)
[16:19:13.902]                     }
[16:19:13.902]                     invisible(pathname)
[16:19:13.902]                   }
[16:19:13.902]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.902]                     rootPath = tempdir()) 
[16:19:13.902]                   {
[16:19:13.902]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.902]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.902]                       tmpdir = path, fileext = ".rds")
[16:19:13.902]                     save_rds(obj, file)
[16:19:13.902]                   }
[16:19:13.902]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.902]                   {
[16:19:13.902]                     inherits <- base::inherits
[16:19:13.902]                     invokeRestart <- base::invokeRestart
[16:19:13.902]                     is.null <- base::is.null
[16:19:13.902]                     muffled <- FALSE
[16:19:13.902]                     if (inherits(cond, "message")) {
[16:19:13.902]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.902]                       if (muffled) 
[16:19:13.902]                         invokeRestart("muffleMessage")
[16:19:13.902]                     }
[16:19:13.902]                     else if (inherits(cond, "warning")) {
[16:19:13.902]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.902]                       if (muffled) 
[16:19:13.902]                         invokeRestart("muffleWarning")
[16:19:13.902]                     }
[16:19:13.902]                     else if (inherits(cond, "condition")) {
[16:19:13.902]                       if (!is.null(pattern)) {
[16:19:13.902]                         computeRestarts <- base::computeRestarts
[16:19:13.902]                         grepl <- base::grepl
[16:19:13.902]                         restarts <- computeRestarts(cond)
[16:19:13.902]                         for (restart in restarts) {
[16:19:13.902]                           name <- restart$name
[16:19:13.902]                           if (is.null(name)) 
[16:19:13.902]                             next
[16:19:13.902]                           if (!grepl(pattern, name)) 
[16:19:13.902]                             next
[16:19:13.902]                           invokeRestart(restart)
[16:19:13.902]                           muffled <- TRUE
[16:19:13.902]                           break
[16:19:13.902]                         }
[16:19:13.902]                       }
[16:19:13.902]                     }
[16:19:13.902]                     invisible(muffled)
[16:19:13.902]                   }
[16:19:13.902]                   muffleCondition(cond)
[16:19:13.902]                 })
[16:19:13.902]             }))
[16:19:13.902]             future::FutureResult(value = ...future.value$value, 
[16:19:13.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.902]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.902]                     ...future.globalenv.names))
[16:19:13.902]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.902]         }, condition = base::local({
[16:19:13.902]             c <- base::c
[16:19:13.902]             inherits <- base::inherits
[16:19:13.902]             invokeRestart <- base::invokeRestart
[16:19:13.902]             length <- base::length
[16:19:13.902]             list <- base::list
[16:19:13.902]             seq.int <- base::seq.int
[16:19:13.902]             signalCondition <- base::signalCondition
[16:19:13.902]             sys.calls <- base::sys.calls
[16:19:13.902]             `[[` <- base::`[[`
[16:19:13.902]             `+` <- base::`+`
[16:19:13.902]             `<<-` <- base::`<<-`
[16:19:13.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.902]                   3L)]
[16:19:13.902]             }
[16:19:13.902]             function(cond) {
[16:19:13.902]                 is_error <- inherits(cond, "error")
[16:19:13.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.902]                   NULL)
[16:19:13.902]                 if (is_error) {
[16:19:13.902]                   sessionInformation <- function() {
[16:19:13.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.902]                       search = base::search(), system = base::Sys.info())
[16:19:13.902]                   }
[16:19:13.902]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.902]                     cond$call), session = sessionInformation(), 
[16:19:13.902]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.902]                   signalCondition(cond)
[16:19:13.902]                 }
[16:19:13.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.902]                 "immediateCondition"))) {
[16:19:13.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.902]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.902]                   if (TRUE && !signal) {
[16:19:13.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.902]                     {
[16:19:13.902]                       inherits <- base::inherits
[16:19:13.902]                       invokeRestart <- base::invokeRestart
[16:19:13.902]                       is.null <- base::is.null
[16:19:13.902]                       muffled <- FALSE
[16:19:13.902]                       if (inherits(cond, "message")) {
[16:19:13.902]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.902]                         if (muffled) 
[16:19:13.902]                           invokeRestart("muffleMessage")
[16:19:13.902]                       }
[16:19:13.902]                       else if (inherits(cond, "warning")) {
[16:19:13.902]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.902]                         if (muffled) 
[16:19:13.902]                           invokeRestart("muffleWarning")
[16:19:13.902]                       }
[16:19:13.902]                       else if (inherits(cond, "condition")) {
[16:19:13.902]                         if (!is.null(pattern)) {
[16:19:13.902]                           computeRestarts <- base::computeRestarts
[16:19:13.902]                           grepl <- base::grepl
[16:19:13.902]                           restarts <- computeRestarts(cond)
[16:19:13.902]                           for (restart in restarts) {
[16:19:13.902]                             name <- restart$name
[16:19:13.902]                             if (is.null(name)) 
[16:19:13.902]                               next
[16:19:13.902]                             if (!grepl(pattern, name)) 
[16:19:13.902]                               next
[16:19:13.902]                             invokeRestart(restart)
[16:19:13.902]                             muffled <- TRUE
[16:19:13.902]                             break
[16:19:13.902]                           }
[16:19:13.902]                         }
[16:19:13.902]                       }
[16:19:13.902]                       invisible(muffled)
[16:19:13.902]                     }
[16:19:13.902]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.902]                   }
[16:19:13.902]                 }
[16:19:13.902]                 else {
[16:19:13.902]                   if (TRUE) {
[16:19:13.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.902]                     {
[16:19:13.902]                       inherits <- base::inherits
[16:19:13.902]                       invokeRestart <- base::invokeRestart
[16:19:13.902]                       is.null <- base::is.null
[16:19:13.902]                       muffled <- FALSE
[16:19:13.902]                       if (inherits(cond, "message")) {
[16:19:13.902]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.902]                         if (muffled) 
[16:19:13.902]                           invokeRestart("muffleMessage")
[16:19:13.902]                       }
[16:19:13.902]                       else if (inherits(cond, "warning")) {
[16:19:13.902]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.902]                         if (muffled) 
[16:19:13.902]                           invokeRestart("muffleWarning")
[16:19:13.902]                       }
[16:19:13.902]                       else if (inherits(cond, "condition")) {
[16:19:13.902]                         if (!is.null(pattern)) {
[16:19:13.902]                           computeRestarts <- base::computeRestarts
[16:19:13.902]                           grepl <- base::grepl
[16:19:13.902]                           restarts <- computeRestarts(cond)
[16:19:13.902]                           for (restart in restarts) {
[16:19:13.902]                             name <- restart$name
[16:19:13.902]                             if (is.null(name)) 
[16:19:13.902]                               next
[16:19:13.902]                             if (!grepl(pattern, name)) 
[16:19:13.902]                               next
[16:19:13.902]                             invokeRestart(restart)
[16:19:13.902]                             muffled <- TRUE
[16:19:13.902]                             break
[16:19:13.902]                           }
[16:19:13.902]                         }
[16:19:13.902]                       }
[16:19:13.902]                       invisible(muffled)
[16:19:13.902]                     }
[16:19:13.902]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.902]                   }
[16:19:13.902]                 }
[16:19:13.902]             }
[16:19:13.902]         }))
[16:19:13.902]     }, error = function(ex) {
[16:19:13.902]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.902]                 ...future.rng), started = ...future.startTime, 
[16:19:13.902]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.902]             version = "1.8"), class = "FutureResult")
[16:19:13.902]     }, finally = {
[16:19:13.902]         if (!identical(...future.workdir, getwd())) 
[16:19:13.902]             setwd(...future.workdir)
[16:19:13.902]         {
[16:19:13.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.902]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.902]             }
[16:19:13.902]             base::options(...future.oldOptions)
[16:19:13.902]             if (.Platform$OS.type == "windows") {
[16:19:13.902]                 old_names <- names(...future.oldEnvVars)
[16:19:13.902]                 envs <- base::Sys.getenv()
[16:19:13.902]                 names <- names(envs)
[16:19:13.902]                 common <- intersect(names, old_names)
[16:19:13.902]                 added <- setdiff(names, old_names)
[16:19:13.902]                 removed <- setdiff(old_names, names)
[16:19:13.902]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.902]                   envs[common]]
[16:19:13.902]                 NAMES <- toupper(changed)
[16:19:13.902]                 args <- list()
[16:19:13.902]                 for (kk in seq_along(NAMES)) {
[16:19:13.902]                   name <- changed[[kk]]
[16:19:13.902]                   NAME <- NAMES[[kk]]
[16:19:13.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.902]                     next
[16:19:13.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.902]                 }
[16:19:13.902]                 NAMES <- toupper(added)
[16:19:13.902]                 for (kk in seq_along(NAMES)) {
[16:19:13.902]                   name <- added[[kk]]
[16:19:13.902]                   NAME <- NAMES[[kk]]
[16:19:13.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.902]                     next
[16:19:13.902]                   args[[name]] <- ""
[16:19:13.902]                 }
[16:19:13.902]                 NAMES <- toupper(removed)
[16:19:13.902]                 for (kk in seq_along(NAMES)) {
[16:19:13.902]                   name <- removed[[kk]]
[16:19:13.902]                   NAME <- NAMES[[kk]]
[16:19:13.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.902]                     next
[16:19:13.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.902]                 }
[16:19:13.902]                 if (length(args) > 0) 
[16:19:13.902]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.902]             }
[16:19:13.902]             else {
[16:19:13.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.902]             }
[16:19:13.902]             {
[16:19:13.902]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.902]                   0L) {
[16:19:13.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.902]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.902]                   base::options(opts)
[16:19:13.902]                 }
[16:19:13.902]                 {
[16:19:13.902]                   {
[16:19:13.902]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.902]                     NULL
[16:19:13.902]                   }
[16:19:13.902]                   options(future.plan = NULL)
[16:19:13.902]                   if (is.na(NA_character_)) 
[16:19:13.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.902]                     .init = FALSE)
[16:19:13.902]                 }
[16:19:13.902]             }
[16:19:13.902]         }
[16:19:13.902]     })
[16:19:13.902]     if (TRUE) {
[16:19:13.902]         base::sink(type = "output", split = FALSE)
[16:19:13.902]         if (TRUE) {
[16:19:13.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.902]         }
[16:19:13.902]         else {
[16:19:13.902]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.902]         }
[16:19:13.902]         base::close(...future.stdout)
[16:19:13.902]         ...future.stdout <- NULL
[16:19:13.902]     }
[16:19:13.902]     ...future.result$conditions <- ...future.conditions
[16:19:13.902]     ...future.result$finished <- base::Sys.time()
[16:19:13.902]     ...future.result
[16:19:13.902] }
[16:19:13.905] assign_globals() ...
[16:19:13.905] List of 11
[16:19:13.905]  $ ...future.FUN            :function (x, ...)  
[16:19:13.905]  $ x_FUN                    :function (x)  
[16:19:13.905]  $ times                    : int 2
[16:19:13.905]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.905]  $ stop_if_not              :function (...)  
[16:19:13.905]  $ dim                      : NULL
[16:19:13.905]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:13.905]  $ future.call.arguments    : list()
[16:19:13.905]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.905]  $ ...future.elements_ii    :List of 5
[16:19:13.905]   ..$ : int 6
[16:19:13.905]   ..$ : int 7
[16:19:13.905]   ..$ : int 8
[16:19:13.905]   ..$ : int 9
[16:19:13.905]   ..$ : int 10
[16:19:13.905]  $ ...future.seeds_ii       : NULL
[16:19:13.905]  $ ...future.globals.maxSize: NULL
[16:19:13.905]  - attr(*, "where")=List of 11
[16:19:13.905]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.905]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.905]  - attr(*, "resolved")= logi FALSE
[16:19:13.905]  - attr(*, "total_size")= num 96456
[16:19:13.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.905]  - attr(*, "already-done")= logi TRUE
[16:19:13.916] - copied ‘...future.FUN’ to environment
[16:19:13.916] - reassign environment for ‘x_FUN’
[16:19:13.916] - copied ‘x_FUN’ to environment
[16:19:13.916] - copied ‘times’ to environment
[16:19:13.916] - copied ‘stopf’ to environment
[16:19:13.917] - copied ‘stop_if_not’ to environment
[16:19:13.917] - copied ‘dim’ to environment
[16:19:13.917] - copied ‘valid_types’ to environment
[16:19:13.917] - copied ‘future.call.arguments’ to environment
[16:19:13.917] - copied ‘...future.elements_ii’ to environment
[16:19:13.917] - copied ‘...future.seeds_ii’ to environment
[16:19:13.917] - copied ‘...future.globals.maxSize’ to environment
[16:19:13.917] assign_globals() ... done
[16:19:13.917] requestCore(): workers = 2
[16:19:13.922] MulticoreFuture started
[16:19:13.922] - Launch lazy future ... done
[16:19:13.923] run() for ‘MulticoreFuture’ ... done
[16:19:13.923] Created future:
[16:19:13.924] plan(): Setting new future strategy stack:
[16:19:13.924] List of future strategies:
[16:19:13.924] 1. sequential:
[16:19:13.924]    - args: function (..., envir = parent.frame())
[16:19:13.924]    - tweaked: FALSE
[16:19:13.924]    - call: NULL
[16:19:13.925] plan(): nbrOfWorkers() = 1
[16:19:13.928] plan(): Setting new future strategy stack:
[16:19:13.928] List of future strategies:
[16:19:13.928] 1. multicore:
[16:19:13.928]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:13.928]    - tweaked: FALSE
[16:19:13.928]    - call: plan(strategy)
[16:19:13.935] plan(): nbrOfWorkers() = 2
[16:19:13.924] MulticoreFuture:
[16:19:13.924] Label: ‘future_vapply-2’
[16:19:13.924] Expression:
[16:19:13.924] {
[16:19:13.924]     do.call(function(...) {
[16:19:13.924]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.924]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.924]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.924]             on.exit(options(oopts), add = TRUE)
[16:19:13.924]         }
[16:19:13.924]         {
[16:19:13.924]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.924]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.924]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.924]             })
[16:19:13.924]         }
[16:19:13.924]     }, args = future.call.arguments)
[16:19:13.924] }
[16:19:13.924] Lazy evaluation: FALSE
[16:19:13.924] Asynchronous evaluation: TRUE
[16:19:13.924] Local evaluation: TRUE
[16:19:13.924] Environment: R_GlobalEnv
[16:19:13.924] Capture standard output: TRUE
[16:19:13.924] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:13.924] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:13.924] Packages: 1 packages (‘future.apply’)
[16:19:13.924] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:13.924] Resolved: TRUE
[16:19:13.924] Value: <not collected>
[16:19:13.924] Conditions captured: <none>
[16:19:13.924] Early signaling: FALSE
[16:19:13.924] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:13.924] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.936] Chunk #2 of 2 ... DONE
[16:19:13.937] Launching 2 futures (chunks) ... DONE
[16:19:13.937] Resolving 2 futures (chunks) ...
[16:19:13.937] resolve() on list ...
[16:19:13.937]  recursive: 0
[16:19:13.938]  length: 2
[16:19:13.938] 
[16:19:13.938] Future #1
[16:19:13.938] result() for MulticoreFuture ...
[16:19:13.939] result() for MulticoreFuture ...
[16:19:13.940] result() for MulticoreFuture ... done
[16:19:13.940] result() for MulticoreFuture ... done
[16:19:13.940] result() for MulticoreFuture ...
[16:19:13.941] result() for MulticoreFuture ... done
[16:19:13.941] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:13.941] - nx: 2
[16:19:13.942] - relay: TRUE
[16:19:13.942] - stdout: TRUE
[16:19:13.942] - signal: TRUE
[16:19:13.942] - resignal: FALSE
[16:19:13.942] - force: TRUE
[16:19:13.942] - relayed: [n=2] FALSE, FALSE
[16:19:13.943] - queued futures: [n=2] FALSE, FALSE
[16:19:13.943]  - until=1
[16:19:13.943]  - relaying element #1
[16:19:13.943] result() for MulticoreFuture ...
[16:19:13.943] result() for MulticoreFuture ... done
[16:19:13.944] result() for MulticoreFuture ...
[16:19:13.944] result() for MulticoreFuture ... done
[16:19:13.944] result() for MulticoreFuture ...
[16:19:13.944] result() for MulticoreFuture ... done
[16:19:13.945] result() for MulticoreFuture ...
[16:19:13.945] result() for MulticoreFuture ... done
[16:19:13.945] - relayed: [n=2] TRUE, FALSE
[16:19:13.945] - queued futures: [n=2] TRUE, FALSE
[16:19:13.945] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:13.946]  length: 1 (resolved future 1)
[16:19:13.946] Future #2
[16:19:13.946] result() for MulticoreFuture ...
[16:19:13.947] result() for MulticoreFuture ...
[16:19:13.947] result() for MulticoreFuture ... done
[16:19:13.947] result() for MulticoreFuture ... done
[16:19:13.947] result() for MulticoreFuture ...
[16:19:13.947] result() for MulticoreFuture ... done
[16:19:13.948] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:13.948] - nx: 2
[16:19:13.948] - relay: TRUE
[16:19:13.948] - stdout: TRUE
[16:19:13.948] - signal: TRUE
[16:19:13.948] - resignal: FALSE
[16:19:13.948] - force: TRUE
[16:19:13.948] - relayed: [n=2] TRUE, FALSE
[16:19:13.949] - queued futures: [n=2] TRUE, FALSE
[16:19:13.949]  - until=2
[16:19:13.949]  - relaying element #2
[16:19:13.949] result() for MulticoreFuture ...
[16:19:13.949] result() for MulticoreFuture ... done
[16:19:13.949] result() for MulticoreFuture ...
[16:19:13.949] result() for MulticoreFuture ... done
[16:19:13.949] result() for MulticoreFuture ...
[16:19:13.950] result() for MulticoreFuture ... done
[16:19:13.950] result() for MulticoreFuture ...
[16:19:13.950] result() for MulticoreFuture ... done
[16:19:13.950] - relayed: [n=2] TRUE, TRUE
[16:19:13.950] - queued futures: [n=2] TRUE, TRUE
[16:19:13.950] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:13.950]  length: 0 (resolved future 2)
[16:19:13.950] Relaying remaining futures
[16:19:13.951] signalConditionsASAP(NULL, pos=0) ...
[16:19:13.951] - nx: 2
[16:19:13.951] - relay: TRUE
[16:19:13.951] - stdout: TRUE
[16:19:13.951] - signal: TRUE
[16:19:13.951] - resignal: FALSE
[16:19:13.951] - force: TRUE
[16:19:13.951] - relayed: [n=2] TRUE, TRUE
[16:19:13.951] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:13.951] - relayed: [n=2] TRUE, TRUE
[16:19:13.952] - queued futures: [n=2] TRUE, TRUE
[16:19:13.952] signalConditionsASAP(NULL, pos=0) ... done
[16:19:13.952] resolve() on list ... DONE
[16:19:13.952] result() for MulticoreFuture ...
[16:19:13.952] result() for MulticoreFuture ... done
[16:19:13.952] result() for MulticoreFuture ...
[16:19:13.952] result() for MulticoreFuture ... done
[16:19:13.952] result() for MulticoreFuture ...
[16:19:13.952] result() for MulticoreFuture ... done
[16:19:13.953] result() for MulticoreFuture ...
[16:19:13.953] result() for MulticoreFuture ... done
[16:19:13.953]  - Number of value chunks collected: 2
[16:19:13.953] Resolving 2 futures (chunks) ... DONE
[16:19:13.953] Reducing values from 2 chunks ...
[16:19:13.953]  - Number of values collected after concatenation: 10
[16:19:13.953]  - Number of values expected: 10
[16:19:13.953] Reducing values from 2 chunks ... DONE
[16:19:13.953] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:19:13.955] future_lapply() ...
[16:19:13.961] Number of chunks: 2
[16:19:13.961] getGlobalsAndPackagesXApply() ...
[16:19:13.961]  - future.globals: TRUE
[16:19:13.961] getGlobalsAndPackages() ...
[16:19:13.961] Searching for globals...
[16:19:13.967] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:19:13.967] Searching for globals ... DONE
[16:19:13.968] Resolving globals: FALSE
[16:19:13.969] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:19:13.969] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:13.969] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.969] - packages: [1] ‘future.apply’
[16:19:13.969] getGlobalsAndPackages() ... DONE
[16:19:13.970]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:13.970]  - needed namespaces: [n=1] ‘future.apply’
[16:19:13.970] Finding globals ... DONE
[16:19:13.970]  - use_args: TRUE
[16:19:13.970]  - Getting '...' globals ...
[16:19:13.970] resolve() on list ...
[16:19:13.970]  recursive: 0
[16:19:13.970]  length: 1
[16:19:13.971]  elements: ‘...’
[16:19:13.971]  length: 0 (resolved future 1)
[16:19:13.971] resolve() on list ... DONE
[16:19:13.971]    - '...' content: [n=0] 
[16:19:13.971] List of 1
[16:19:13.971]  $ ...: list()
[16:19:13.971]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.971]  - attr(*, "where")=List of 1
[16:19:13.971]   ..$ ...:<environment: 0x56199ef6d1a0> 
[16:19:13.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.971]  - attr(*, "resolved")= logi TRUE
[16:19:13.971]  - attr(*, "total_size")= num NA
[16:19:13.974]  - Getting '...' globals ... DONE
[16:19:13.974] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:13.974] List of 8
[16:19:13.974]  $ ...future.FUN:function (x, ...)  
[16:19:13.974]  $ x_FUN        :function (x)  
[16:19:13.974]  $ times        : int 4
[16:19:13.974]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.974]  $ stop_if_not  :function (...)  
[16:19:13.974]  $ dim          : int [1:2] 2 2
[16:19:13.974]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:13.974]  $ ...          : list()
[16:19:13.974]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.974]  - attr(*, "where")=List of 8
[16:19:13.974]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:13.974]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:13.974]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:13.974]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:13.974]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:13.974]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:13.974]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:13.974]   ..$ ...          :<environment: 0x56199ef6d1a0> 
[16:19:13.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.974]  - attr(*, "resolved")= logi FALSE
[16:19:13.974]  - attr(*, "total_size")= num 97232
[16:19:13.979] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:13.979] getGlobalsAndPackagesXApply() ... DONE
[16:19:13.980] Number of futures (= number of chunks): 2
[16:19:13.980] Launching 2 futures (chunks) ...
[16:19:13.980] Chunk #1 of 2 ...
[16:19:13.980]  - Finding globals in 'X' for chunk #1 ...
[16:19:13.980] getGlobalsAndPackages() ...
[16:19:13.980] Searching for globals...
[16:19:13.980] 
[16:19:13.981] Searching for globals ... DONE
[16:19:13.981] - globals: [0] <none>
[16:19:13.981] getGlobalsAndPackages() ... DONE
[16:19:13.981]    + additional globals found: [n=0] 
[16:19:13.981]    + additional namespaces needed: [n=0] 
[16:19:13.981]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:13.981]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:13.981]  - seeds: <none>
[16:19:13.981]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.981] getGlobalsAndPackages() ...
[16:19:13.982] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.982] Resolving globals: FALSE
[16:19:13.982] Tweak future expression to call with '...' arguments ...
[16:19:13.982] {
[16:19:13.982]     do.call(function(...) {
[16:19:13.982]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.982]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:13.982]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.982]             on.exit(options(oopts), add = TRUE)
[16:19:13.982]         }
[16:19:13.982]         {
[16:19:13.982]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:13.982]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.982]                 ...future.FUN(...future.X_jj, ...)
[16:19:13.982]             })
[16:19:13.982]         }
[16:19:13.982]     }, args = future.call.arguments)
[16:19:13.982] }
[16:19:13.982] Tweak future expression to call with '...' arguments ... DONE
[16:19:13.983] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:13.983] - packages: [1] ‘future.apply’
[16:19:13.983] getGlobalsAndPackages() ... DONE
[16:19:13.985] run() for ‘Future’ ...
[16:19:13.985] - state: ‘created’
[16:19:13.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:13.989] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:13.989] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:13.989]   - Field: ‘label’
[16:19:13.990]   - Field: ‘local’
[16:19:13.990]   - Field: ‘owner’
[16:19:13.990]   - Field: ‘envir’
[16:19:13.990]   - Field: ‘workers’
[16:19:13.990]   - Field: ‘packages’
[16:19:13.990]   - Field: ‘gc’
[16:19:13.990]   - Field: ‘job’
[16:19:13.990]   - Field: ‘conditions’
[16:19:13.990]   - Field: ‘expr’
[16:19:13.991]   - Field: ‘uuid’
[16:19:13.991]   - Field: ‘seed’
[16:19:13.991]   - Field: ‘version’
[16:19:13.991]   - Field: ‘result’
[16:19:13.991]   - Field: ‘asynchronous’
[16:19:13.991]   - Field: ‘calls’
[16:19:13.991]   - Field: ‘globals’
[16:19:13.991]   - Field: ‘stdout’
[16:19:13.991]   - Field: ‘earlySignal’
[16:19:13.991]   - Field: ‘lazy’
[16:19:13.992]   - Field: ‘state’
[16:19:13.992] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:13.992] - Launch lazy future ...
[16:19:13.992] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:13.992] Packages needed by future strategies (n = 0): <none>
[16:19:13.993] {
[16:19:13.993]     {
[16:19:13.993]         {
[16:19:13.993]             ...future.startTime <- base::Sys.time()
[16:19:13.993]             {
[16:19:13.993]                 {
[16:19:13.993]                   {
[16:19:13.993]                     {
[16:19:13.993]                       {
[16:19:13.993]                         base::local({
[16:19:13.993]                           has_future <- base::requireNamespace("future", 
[16:19:13.993]                             quietly = TRUE)
[16:19:13.993]                           if (has_future) {
[16:19:13.993]                             ns <- base::getNamespace("future")
[16:19:13.993]                             version <- ns[[".package"]][["version"]]
[16:19:13.993]                             if (is.null(version)) 
[16:19:13.993]                               version <- utils::packageVersion("future")
[16:19:13.993]                           }
[16:19:13.993]                           else {
[16:19:13.993]                             version <- NULL
[16:19:13.993]                           }
[16:19:13.993]                           if (!has_future || version < "1.8.0") {
[16:19:13.993]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:13.993]                               "", base::R.version$version.string), 
[16:19:13.993]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:13.993]                                 base::R.version$platform, 8 * 
[16:19:13.993]                                   base::.Machine$sizeof.pointer), 
[16:19:13.993]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:13.993]                                 "release", "version")], collapse = " "), 
[16:19:13.993]                               hostname = base::Sys.info()[["nodename"]])
[16:19:13.993]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:13.993]                               info)
[16:19:13.993]                             info <- base::paste(info, collapse = "; ")
[16:19:13.993]                             if (!has_future) {
[16:19:13.993]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:13.993]                                 info)
[16:19:13.993]                             }
[16:19:13.993]                             else {
[16:19:13.993]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:13.993]                                 info, version)
[16:19:13.993]                             }
[16:19:13.993]                             base::stop(msg)
[16:19:13.993]                           }
[16:19:13.993]                         })
[16:19:13.993]                       }
[16:19:13.993]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:13.993]                       base::options(mc.cores = 1L)
[16:19:13.993]                     }
[16:19:13.993]                     base::local({
[16:19:13.993]                       for (pkg in "future.apply") {
[16:19:13.993]                         base::loadNamespace(pkg)
[16:19:13.993]                         base::library(pkg, character.only = TRUE)
[16:19:13.993]                       }
[16:19:13.993]                     })
[16:19:13.993]                   }
[16:19:13.993]                   ...future.strategy.old <- future::plan("list")
[16:19:13.993]                   options(future.plan = NULL)
[16:19:13.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:13.993]                 }
[16:19:13.993]                 ...future.workdir <- getwd()
[16:19:13.993]             }
[16:19:13.993]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:13.993]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:13.993]         }
[16:19:13.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:13.993]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:13.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:13.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:13.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:13.993]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:13.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:13.993]             base::names(...future.oldOptions))
[16:19:13.993]     }
[16:19:13.993]     if (FALSE) {
[16:19:13.993]     }
[16:19:13.993]     else {
[16:19:13.993]         if (TRUE) {
[16:19:13.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:13.993]                 open = "w")
[16:19:13.993]         }
[16:19:13.993]         else {
[16:19:13.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:13.993]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:13.993]         }
[16:19:13.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:13.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:13.993]             base::sink(type = "output", split = FALSE)
[16:19:13.993]             base::close(...future.stdout)
[16:19:13.993]         }, add = TRUE)
[16:19:13.993]     }
[16:19:13.993]     ...future.frame <- base::sys.nframe()
[16:19:13.993]     ...future.conditions <- base::list()
[16:19:13.993]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:13.993]     if (FALSE) {
[16:19:13.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:13.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:13.993]     }
[16:19:13.993]     ...future.result <- base::tryCatch({
[16:19:13.993]         base::withCallingHandlers({
[16:19:13.993]             ...future.value <- base::withVisible(base::local({
[16:19:13.993]                 withCallingHandlers({
[16:19:13.993]                   {
[16:19:13.993]                     do.call(function(...) {
[16:19:13.993]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:13.993]                       if (!identical(...future.globals.maxSize.org, 
[16:19:13.993]                         ...future.globals.maxSize)) {
[16:19:13.993]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:13.993]                         on.exit(options(oopts), add = TRUE)
[16:19:13.993]                       }
[16:19:13.993]                       {
[16:19:13.993]                         lapply(seq_along(...future.elements_ii), 
[16:19:13.993]                           FUN = function(jj) {
[16:19:13.993]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:13.993]                             ...future.FUN(...future.X_jj, ...)
[16:19:13.993]                           })
[16:19:13.993]                       }
[16:19:13.993]                     }, args = future.call.arguments)
[16:19:13.993]                   }
[16:19:13.993]                 }, immediateCondition = function(cond) {
[16:19:13.993]                   save_rds <- function (object, pathname, ...) 
[16:19:13.993]                   {
[16:19:13.993]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:13.993]                     if (file_test("-f", pathname_tmp)) {
[16:19:13.993]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.993]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:13.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.993]                         fi_tmp[["mtime"]])
[16:19:13.993]                     }
[16:19:13.993]                     tryCatch({
[16:19:13.993]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:13.993]                     }, error = function(ex) {
[16:19:13.993]                       msg <- conditionMessage(ex)
[16:19:13.993]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.993]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:13.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.993]                         fi_tmp[["mtime"]], msg)
[16:19:13.993]                       ex$message <- msg
[16:19:13.993]                       stop(ex)
[16:19:13.993]                     })
[16:19:13.993]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:13.993]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:13.993]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:13.993]                       fi_tmp <- file.info(pathname_tmp)
[16:19:13.993]                       fi <- file.info(pathname)
[16:19:13.993]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:13.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:13.993]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:13.993]                         fi[["size"]], fi[["mtime"]])
[16:19:13.993]                       stop(msg)
[16:19:13.993]                     }
[16:19:13.993]                     invisible(pathname)
[16:19:13.993]                   }
[16:19:13.993]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:13.993]                     rootPath = tempdir()) 
[16:19:13.993]                   {
[16:19:13.993]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:13.993]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:13.993]                       tmpdir = path, fileext = ".rds")
[16:19:13.993]                     save_rds(obj, file)
[16:19:13.993]                   }
[16:19:13.993]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:13.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.993]                   {
[16:19:13.993]                     inherits <- base::inherits
[16:19:13.993]                     invokeRestart <- base::invokeRestart
[16:19:13.993]                     is.null <- base::is.null
[16:19:13.993]                     muffled <- FALSE
[16:19:13.993]                     if (inherits(cond, "message")) {
[16:19:13.993]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:13.993]                       if (muffled) 
[16:19:13.993]                         invokeRestart("muffleMessage")
[16:19:13.993]                     }
[16:19:13.993]                     else if (inherits(cond, "warning")) {
[16:19:13.993]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:13.993]                       if (muffled) 
[16:19:13.993]                         invokeRestart("muffleWarning")
[16:19:13.993]                     }
[16:19:13.993]                     else if (inherits(cond, "condition")) {
[16:19:13.993]                       if (!is.null(pattern)) {
[16:19:13.993]                         computeRestarts <- base::computeRestarts
[16:19:13.993]                         grepl <- base::grepl
[16:19:13.993]                         restarts <- computeRestarts(cond)
[16:19:13.993]                         for (restart in restarts) {
[16:19:13.993]                           name <- restart$name
[16:19:13.993]                           if (is.null(name)) 
[16:19:13.993]                             next
[16:19:13.993]                           if (!grepl(pattern, name)) 
[16:19:13.993]                             next
[16:19:13.993]                           invokeRestart(restart)
[16:19:13.993]                           muffled <- TRUE
[16:19:13.993]                           break
[16:19:13.993]                         }
[16:19:13.993]                       }
[16:19:13.993]                     }
[16:19:13.993]                     invisible(muffled)
[16:19:13.993]                   }
[16:19:13.993]                   muffleCondition(cond)
[16:19:13.993]                 })
[16:19:13.993]             }))
[16:19:13.993]             future::FutureResult(value = ...future.value$value, 
[16:19:13.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.993]                   ...future.rng), globalenv = if (FALSE) 
[16:19:13.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:13.993]                     ...future.globalenv.names))
[16:19:13.993]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:13.993]         }, condition = base::local({
[16:19:13.993]             c <- base::c
[16:19:13.993]             inherits <- base::inherits
[16:19:13.993]             invokeRestart <- base::invokeRestart
[16:19:13.993]             length <- base::length
[16:19:13.993]             list <- base::list
[16:19:13.993]             seq.int <- base::seq.int
[16:19:13.993]             signalCondition <- base::signalCondition
[16:19:13.993]             sys.calls <- base::sys.calls
[16:19:13.993]             `[[` <- base::`[[`
[16:19:13.993]             `+` <- base::`+`
[16:19:13.993]             `<<-` <- base::`<<-`
[16:19:13.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:13.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:13.993]                   3L)]
[16:19:13.993]             }
[16:19:13.993]             function(cond) {
[16:19:13.993]                 is_error <- inherits(cond, "error")
[16:19:13.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:13.993]                   NULL)
[16:19:13.993]                 if (is_error) {
[16:19:13.993]                   sessionInformation <- function() {
[16:19:13.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:13.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:13.993]                       search = base::search(), system = base::Sys.info())
[16:19:13.993]                   }
[16:19:13.993]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:13.993]                     cond$call), session = sessionInformation(), 
[16:19:13.993]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:13.993]                   signalCondition(cond)
[16:19:13.993]                 }
[16:19:13.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:13.993]                 "immediateCondition"))) {
[16:19:13.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:13.993]                   ...future.conditions[[length(...future.conditions) + 
[16:19:13.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:13.993]                   if (TRUE && !signal) {
[16:19:13.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.993]                     {
[16:19:13.993]                       inherits <- base::inherits
[16:19:13.993]                       invokeRestart <- base::invokeRestart
[16:19:13.993]                       is.null <- base::is.null
[16:19:13.993]                       muffled <- FALSE
[16:19:13.993]                       if (inherits(cond, "message")) {
[16:19:13.993]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.993]                         if (muffled) 
[16:19:13.993]                           invokeRestart("muffleMessage")
[16:19:13.993]                       }
[16:19:13.993]                       else if (inherits(cond, "warning")) {
[16:19:13.993]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.993]                         if (muffled) 
[16:19:13.993]                           invokeRestart("muffleWarning")
[16:19:13.993]                       }
[16:19:13.993]                       else if (inherits(cond, "condition")) {
[16:19:13.993]                         if (!is.null(pattern)) {
[16:19:13.993]                           computeRestarts <- base::computeRestarts
[16:19:13.993]                           grepl <- base::grepl
[16:19:13.993]                           restarts <- computeRestarts(cond)
[16:19:13.993]                           for (restart in restarts) {
[16:19:13.993]                             name <- restart$name
[16:19:13.993]                             if (is.null(name)) 
[16:19:13.993]                               next
[16:19:13.993]                             if (!grepl(pattern, name)) 
[16:19:13.993]                               next
[16:19:13.993]                             invokeRestart(restart)
[16:19:13.993]                             muffled <- TRUE
[16:19:13.993]                             break
[16:19:13.993]                           }
[16:19:13.993]                         }
[16:19:13.993]                       }
[16:19:13.993]                       invisible(muffled)
[16:19:13.993]                     }
[16:19:13.993]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.993]                   }
[16:19:13.993]                 }
[16:19:13.993]                 else {
[16:19:13.993]                   if (TRUE) {
[16:19:13.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:13.993]                     {
[16:19:13.993]                       inherits <- base::inherits
[16:19:13.993]                       invokeRestart <- base::invokeRestart
[16:19:13.993]                       is.null <- base::is.null
[16:19:13.993]                       muffled <- FALSE
[16:19:13.993]                       if (inherits(cond, "message")) {
[16:19:13.993]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:13.993]                         if (muffled) 
[16:19:13.993]                           invokeRestart("muffleMessage")
[16:19:13.993]                       }
[16:19:13.993]                       else if (inherits(cond, "warning")) {
[16:19:13.993]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:13.993]                         if (muffled) 
[16:19:13.993]                           invokeRestart("muffleWarning")
[16:19:13.993]                       }
[16:19:13.993]                       else if (inherits(cond, "condition")) {
[16:19:13.993]                         if (!is.null(pattern)) {
[16:19:13.993]                           computeRestarts <- base::computeRestarts
[16:19:13.993]                           grepl <- base::grepl
[16:19:13.993]                           restarts <- computeRestarts(cond)
[16:19:13.993]                           for (restart in restarts) {
[16:19:13.993]                             name <- restart$name
[16:19:13.993]                             if (is.null(name)) 
[16:19:13.993]                               next
[16:19:13.993]                             if (!grepl(pattern, name)) 
[16:19:13.993]                               next
[16:19:13.993]                             invokeRestart(restart)
[16:19:13.993]                             muffled <- TRUE
[16:19:13.993]                             break
[16:19:13.993]                           }
[16:19:13.993]                         }
[16:19:13.993]                       }
[16:19:13.993]                       invisible(muffled)
[16:19:13.993]                     }
[16:19:13.993]                     muffleCondition(cond, pattern = "^muffle")
[16:19:13.993]                   }
[16:19:13.993]                 }
[16:19:13.993]             }
[16:19:13.993]         }))
[16:19:13.993]     }, error = function(ex) {
[16:19:13.993]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:13.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:13.993]                 ...future.rng), started = ...future.startTime, 
[16:19:13.993]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:13.993]             version = "1.8"), class = "FutureResult")
[16:19:13.993]     }, finally = {
[16:19:13.993]         if (!identical(...future.workdir, getwd())) 
[16:19:13.993]             setwd(...future.workdir)
[16:19:13.993]         {
[16:19:13.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:13.993]                 ...future.oldOptions$nwarnings <- NULL
[16:19:13.993]             }
[16:19:13.993]             base::options(...future.oldOptions)
[16:19:13.993]             if (.Platform$OS.type == "windows") {
[16:19:13.993]                 old_names <- names(...future.oldEnvVars)
[16:19:13.993]                 envs <- base::Sys.getenv()
[16:19:13.993]                 names <- names(envs)
[16:19:13.993]                 common <- intersect(names, old_names)
[16:19:13.993]                 added <- setdiff(names, old_names)
[16:19:13.993]                 removed <- setdiff(old_names, names)
[16:19:13.993]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:13.993]                   envs[common]]
[16:19:13.993]                 NAMES <- toupper(changed)
[16:19:13.993]                 args <- list()
[16:19:13.993]                 for (kk in seq_along(NAMES)) {
[16:19:13.993]                   name <- changed[[kk]]
[16:19:13.993]                   NAME <- NAMES[[kk]]
[16:19:13.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.993]                     next
[16:19:13.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.993]                 }
[16:19:13.993]                 NAMES <- toupper(added)
[16:19:13.993]                 for (kk in seq_along(NAMES)) {
[16:19:13.993]                   name <- added[[kk]]
[16:19:13.993]                   NAME <- NAMES[[kk]]
[16:19:13.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.993]                     next
[16:19:13.993]                   args[[name]] <- ""
[16:19:13.993]                 }
[16:19:13.993]                 NAMES <- toupper(removed)
[16:19:13.993]                 for (kk in seq_along(NAMES)) {
[16:19:13.993]                   name <- removed[[kk]]
[16:19:13.993]                   NAME <- NAMES[[kk]]
[16:19:13.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:13.993]                     next
[16:19:13.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:13.993]                 }
[16:19:13.993]                 if (length(args) > 0) 
[16:19:13.993]                   base::do.call(base::Sys.setenv, args = args)
[16:19:13.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:13.993]             }
[16:19:13.993]             else {
[16:19:13.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:13.993]             }
[16:19:13.993]             {
[16:19:13.993]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:13.993]                   0L) {
[16:19:13.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:13.993]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:13.993]                   base::options(opts)
[16:19:13.993]                 }
[16:19:13.993]                 {
[16:19:13.993]                   {
[16:19:13.993]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:13.993]                     NULL
[16:19:13.993]                   }
[16:19:13.993]                   options(future.plan = NULL)
[16:19:13.993]                   if (is.na(NA_character_)) 
[16:19:13.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:13.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:13.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:13.993]                     .init = FALSE)
[16:19:13.993]                 }
[16:19:13.993]             }
[16:19:13.993]         }
[16:19:13.993]     })
[16:19:13.993]     if (TRUE) {
[16:19:13.993]         base::sink(type = "output", split = FALSE)
[16:19:13.993]         if (TRUE) {
[16:19:13.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:13.993]         }
[16:19:13.993]         else {
[16:19:13.993]             ...future.result["stdout"] <- base::list(NULL)
[16:19:13.993]         }
[16:19:13.993]         base::close(...future.stdout)
[16:19:13.993]         ...future.stdout <- NULL
[16:19:13.993]     }
[16:19:13.993]     ...future.result$conditions <- ...future.conditions
[16:19:13.993]     ...future.result$finished <- base::Sys.time()
[16:19:13.993]     ...future.result
[16:19:13.993] }
[16:19:13.995] assign_globals() ...
[16:19:13.995] List of 11
[16:19:13.995]  $ ...future.FUN            :function (x, ...)  
[16:19:13.995]  $ x_FUN                    :function (x)  
[16:19:13.995]  $ times                    : int 4
[16:19:13.995]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:13.995]  $ stop_if_not              :function (...)  
[16:19:13.995]  $ dim                      : int [1:2] 2 2
[16:19:13.995]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:13.995]  $ future.call.arguments    : list()
[16:19:13.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:13.995]  $ ...future.elements_ii    :List of 5
[16:19:13.995]   ..$ : int 1
[16:19:13.995]   ..$ : int 2
[16:19:13.995]   ..$ : int 3
[16:19:13.995]   ..$ : int 4
[16:19:13.995]   ..$ : int 5
[16:19:13.995]  $ ...future.seeds_ii       : NULL
[16:19:13.995]  $ ...future.globals.maxSize: NULL
[16:19:13.995]  - attr(*, "where")=List of 11
[16:19:13.995]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:13.995]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:13.995]  - attr(*, "resolved")= logi FALSE
[16:19:13.995]  - attr(*, "total_size")= num 97232
[16:19:13.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:13.995]  - attr(*, "already-done")= logi TRUE
[16:19:14.004] - copied ‘...future.FUN’ to environment
[16:19:14.004] - reassign environment for ‘x_FUN’
[16:19:14.004] - copied ‘x_FUN’ to environment
[16:19:14.004] - copied ‘times’ to environment
[16:19:14.004] - copied ‘stopf’ to environment
[16:19:14.004] - copied ‘stop_if_not’ to environment
[16:19:14.004] - copied ‘dim’ to environment
[16:19:14.005] - copied ‘valid_types’ to environment
[16:19:14.005] - copied ‘future.call.arguments’ to environment
[16:19:14.005] - copied ‘...future.elements_ii’ to environment
[16:19:14.005] - copied ‘...future.seeds_ii’ to environment
[16:19:14.005] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.005] assign_globals() ... done
[16:19:14.005] requestCore(): workers = 2
[16:19:14.007] MulticoreFuture started
[16:19:14.008] - Launch lazy future ... done
[16:19:14.008] run() for ‘MulticoreFuture’ ... done
[16:19:14.008] Created future:
[16:19:14.009] plan(): Setting new future strategy stack:
[16:19:14.009] List of future strategies:
[16:19:14.009] 1. sequential:
[16:19:14.009]    - args: function (..., envir = parent.frame())
[16:19:14.009]    - tweaked: FALSE
[16:19:14.009]    - call: NULL
[16:19:14.010] plan(): nbrOfWorkers() = 1
[16:19:14.021] plan(): Setting new future strategy stack:
[16:19:14.022] List of future strategies:
[16:19:14.022] 1. multicore:
[16:19:14.022]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.022]    - tweaked: FALSE
[16:19:14.022]    - call: plan(strategy)
[16:19:14.026] plan(): nbrOfWorkers() = 2
[16:19:14.008] MulticoreFuture:
[16:19:14.008] Label: ‘future_vapply-1’
[16:19:14.008] Expression:
[16:19:14.008] {
[16:19:14.008]     do.call(function(...) {
[16:19:14.008]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.008]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.008]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.008]             on.exit(options(oopts), add = TRUE)
[16:19:14.008]         }
[16:19:14.008]         {
[16:19:14.008]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.008]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.008]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.008]             })
[16:19:14.008]         }
[16:19:14.008]     }, args = future.call.arguments)
[16:19:14.008] }
[16:19:14.008] Lazy evaluation: FALSE
[16:19:14.008] Asynchronous evaluation: TRUE
[16:19:14.008] Local evaluation: TRUE
[16:19:14.008] Environment: R_GlobalEnv
[16:19:14.008] Capture standard output: TRUE
[16:19:14.008] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.008] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.008] Packages: 1 packages (‘future.apply’)
[16:19:14.008] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.008] Resolved: TRUE
[16:19:14.008] Value: <not collected>
[16:19:14.008] Conditions captured: <none>
[16:19:14.008] Early signaling: FALSE
[16:19:14.008] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.008] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.027] Chunk #1 of 2 ... DONE
[16:19:14.027] Chunk #2 of 2 ...
[16:19:14.028]  - Finding globals in 'X' for chunk #2 ...
[16:19:14.028] getGlobalsAndPackages() ...
[16:19:14.028] Searching for globals...
[16:19:14.029] 
[16:19:14.029] Searching for globals ... DONE
[16:19:14.029] - globals: [0] <none>
[16:19:14.029] getGlobalsAndPackages() ... DONE
[16:19:14.029]    + additional globals found: [n=0] 
[16:19:14.029]    + additional namespaces needed: [n=0] 
[16:19:14.029]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:14.030]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.030]  - seeds: <none>
[16:19:14.030]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.030] getGlobalsAndPackages() ...
[16:19:14.031] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.031] Resolving globals: FALSE
[16:19:14.031] Tweak future expression to call with '...' arguments ...
[16:19:14.031] {
[16:19:14.031]     do.call(function(...) {
[16:19:14.031]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.031]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.031]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.031]             on.exit(options(oopts), add = TRUE)
[16:19:14.031]         }
[16:19:14.031]         {
[16:19:14.031]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.031]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.031]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.031]             })
[16:19:14.031]         }
[16:19:14.031]     }, args = future.call.arguments)
[16:19:14.031] }
[16:19:14.032] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.033] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.033] - packages: [1] ‘future.apply’
[16:19:14.033] getGlobalsAndPackages() ... DONE
[16:19:14.034] run() for ‘Future’ ...
[16:19:14.034] - state: ‘created’
[16:19:14.035] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.040] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.040]   - Field: ‘label’
[16:19:14.040]   - Field: ‘local’
[16:19:14.040]   - Field: ‘owner’
[16:19:14.041]   - Field: ‘envir’
[16:19:14.041]   - Field: ‘workers’
[16:19:14.041]   - Field: ‘packages’
[16:19:14.041]   - Field: ‘gc’
[16:19:14.041]   - Field: ‘job’
[16:19:14.041]   - Field: ‘conditions’
[16:19:14.041]   - Field: ‘expr’
[16:19:14.041]   - Field: ‘uuid’
[16:19:14.042]   - Field: ‘seed’
[16:19:14.042]   - Field: ‘version’
[16:19:14.042]   - Field: ‘result’
[16:19:14.042]   - Field: ‘asynchronous’
[16:19:14.042]   - Field: ‘calls’
[16:19:14.043]   - Field: ‘globals’
[16:19:14.043]   - Field: ‘stdout’
[16:19:14.043]   - Field: ‘earlySignal’
[16:19:14.043]   - Field: ‘lazy’
[16:19:14.043]   - Field: ‘state’
[16:19:14.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.043] - Launch lazy future ...
[16:19:14.044] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:14.044] Packages needed by future strategies (n = 0): <none>
[16:19:14.045] {
[16:19:14.045]     {
[16:19:14.045]         {
[16:19:14.045]             ...future.startTime <- base::Sys.time()
[16:19:14.045]             {
[16:19:14.045]                 {
[16:19:14.045]                   {
[16:19:14.045]                     {
[16:19:14.045]                       {
[16:19:14.045]                         base::local({
[16:19:14.045]                           has_future <- base::requireNamespace("future", 
[16:19:14.045]                             quietly = TRUE)
[16:19:14.045]                           if (has_future) {
[16:19:14.045]                             ns <- base::getNamespace("future")
[16:19:14.045]                             version <- ns[[".package"]][["version"]]
[16:19:14.045]                             if (is.null(version)) 
[16:19:14.045]                               version <- utils::packageVersion("future")
[16:19:14.045]                           }
[16:19:14.045]                           else {
[16:19:14.045]                             version <- NULL
[16:19:14.045]                           }
[16:19:14.045]                           if (!has_future || version < "1.8.0") {
[16:19:14.045]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.045]                               "", base::R.version$version.string), 
[16:19:14.045]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.045]                                 base::R.version$platform, 8 * 
[16:19:14.045]                                   base::.Machine$sizeof.pointer), 
[16:19:14.045]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.045]                                 "release", "version")], collapse = " "), 
[16:19:14.045]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.045]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.045]                               info)
[16:19:14.045]                             info <- base::paste(info, collapse = "; ")
[16:19:14.045]                             if (!has_future) {
[16:19:14.045]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.045]                                 info)
[16:19:14.045]                             }
[16:19:14.045]                             else {
[16:19:14.045]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.045]                                 info, version)
[16:19:14.045]                             }
[16:19:14.045]                             base::stop(msg)
[16:19:14.045]                           }
[16:19:14.045]                         })
[16:19:14.045]                       }
[16:19:14.045]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.045]                       base::options(mc.cores = 1L)
[16:19:14.045]                     }
[16:19:14.045]                     base::local({
[16:19:14.045]                       for (pkg in "future.apply") {
[16:19:14.045]                         base::loadNamespace(pkg)
[16:19:14.045]                         base::library(pkg, character.only = TRUE)
[16:19:14.045]                       }
[16:19:14.045]                     })
[16:19:14.045]                   }
[16:19:14.045]                   ...future.strategy.old <- future::plan("list")
[16:19:14.045]                   options(future.plan = NULL)
[16:19:14.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.045]                 }
[16:19:14.045]                 ...future.workdir <- getwd()
[16:19:14.045]             }
[16:19:14.045]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.045]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.045]         }
[16:19:14.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.045]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.045]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.045]             base::names(...future.oldOptions))
[16:19:14.045]     }
[16:19:14.045]     if (FALSE) {
[16:19:14.045]     }
[16:19:14.045]     else {
[16:19:14.045]         if (TRUE) {
[16:19:14.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.045]                 open = "w")
[16:19:14.045]         }
[16:19:14.045]         else {
[16:19:14.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.045]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.045]         }
[16:19:14.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.045]             base::sink(type = "output", split = FALSE)
[16:19:14.045]             base::close(...future.stdout)
[16:19:14.045]         }, add = TRUE)
[16:19:14.045]     }
[16:19:14.045]     ...future.frame <- base::sys.nframe()
[16:19:14.045]     ...future.conditions <- base::list()
[16:19:14.045]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.045]     if (FALSE) {
[16:19:14.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.045]     }
[16:19:14.045]     ...future.result <- base::tryCatch({
[16:19:14.045]         base::withCallingHandlers({
[16:19:14.045]             ...future.value <- base::withVisible(base::local({
[16:19:14.045]                 withCallingHandlers({
[16:19:14.045]                   {
[16:19:14.045]                     do.call(function(...) {
[16:19:14.045]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.045]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.045]                         ...future.globals.maxSize)) {
[16:19:14.045]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.045]                         on.exit(options(oopts), add = TRUE)
[16:19:14.045]                       }
[16:19:14.045]                       {
[16:19:14.045]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.045]                           FUN = function(jj) {
[16:19:14.045]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.045]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.045]                           })
[16:19:14.045]                       }
[16:19:14.045]                     }, args = future.call.arguments)
[16:19:14.045]                   }
[16:19:14.045]                 }, immediateCondition = function(cond) {
[16:19:14.045]                   save_rds <- function (object, pathname, ...) 
[16:19:14.045]                   {
[16:19:14.045]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.045]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.045]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.045]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.045]                         fi_tmp[["mtime"]])
[16:19:14.045]                     }
[16:19:14.045]                     tryCatch({
[16:19:14.045]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.045]                     }, error = function(ex) {
[16:19:14.045]                       msg <- conditionMessage(ex)
[16:19:14.045]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.045]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.045]                         fi_tmp[["mtime"]], msg)
[16:19:14.045]                       ex$message <- msg
[16:19:14.045]                       stop(ex)
[16:19:14.045]                     })
[16:19:14.045]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.045]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.045]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.045]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.045]                       fi <- file.info(pathname)
[16:19:14.045]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.045]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.045]                         fi[["size"]], fi[["mtime"]])
[16:19:14.045]                       stop(msg)
[16:19:14.045]                     }
[16:19:14.045]                     invisible(pathname)
[16:19:14.045]                   }
[16:19:14.045]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.045]                     rootPath = tempdir()) 
[16:19:14.045]                   {
[16:19:14.045]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.045]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.045]                       tmpdir = path, fileext = ".rds")
[16:19:14.045]                     save_rds(obj, file)
[16:19:14.045]                   }
[16:19:14.045]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.045]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.045]                   {
[16:19:14.045]                     inherits <- base::inherits
[16:19:14.045]                     invokeRestart <- base::invokeRestart
[16:19:14.045]                     is.null <- base::is.null
[16:19:14.045]                     muffled <- FALSE
[16:19:14.045]                     if (inherits(cond, "message")) {
[16:19:14.045]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.045]                       if (muffled) 
[16:19:14.045]                         invokeRestart("muffleMessage")
[16:19:14.045]                     }
[16:19:14.045]                     else if (inherits(cond, "warning")) {
[16:19:14.045]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.045]                       if (muffled) 
[16:19:14.045]                         invokeRestart("muffleWarning")
[16:19:14.045]                     }
[16:19:14.045]                     else if (inherits(cond, "condition")) {
[16:19:14.045]                       if (!is.null(pattern)) {
[16:19:14.045]                         computeRestarts <- base::computeRestarts
[16:19:14.045]                         grepl <- base::grepl
[16:19:14.045]                         restarts <- computeRestarts(cond)
[16:19:14.045]                         for (restart in restarts) {
[16:19:14.045]                           name <- restart$name
[16:19:14.045]                           if (is.null(name)) 
[16:19:14.045]                             next
[16:19:14.045]                           if (!grepl(pattern, name)) 
[16:19:14.045]                             next
[16:19:14.045]                           invokeRestart(restart)
[16:19:14.045]                           muffled <- TRUE
[16:19:14.045]                           break
[16:19:14.045]                         }
[16:19:14.045]                       }
[16:19:14.045]                     }
[16:19:14.045]                     invisible(muffled)
[16:19:14.045]                   }
[16:19:14.045]                   muffleCondition(cond)
[16:19:14.045]                 })
[16:19:14.045]             }))
[16:19:14.045]             future::FutureResult(value = ...future.value$value, 
[16:19:14.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.045]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.045]                     ...future.globalenv.names))
[16:19:14.045]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.045]         }, condition = base::local({
[16:19:14.045]             c <- base::c
[16:19:14.045]             inherits <- base::inherits
[16:19:14.045]             invokeRestart <- base::invokeRestart
[16:19:14.045]             length <- base::length
[16:19:14.045]             list <- base::list
[16:19:14.045]             seq.int <- base::seq.int
[16:19:14.045]             signalCondition <- base::signalCondition
[16:19:14.045]             sys.calls <- base::sys.calls
[16:19:14.045]             `[[` <- base::`[[`
[16:19:14.045]             `+` <- base::`+`
[16:19:14.045]             `<<-` <- base::`<<-`
[16:19:14.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.045]                   3L)]
[16:19:14.045]             }
[16:19:14.045]             function(cond) {
[16:19:14.045]                 is_error <- inherits(cond, "error")
[16:19:14.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.045]                   NULL)
[16:19:14.045]                 if (is_error) {
[16:19:14.045]                   sessionInformation <- function() {
[16:19:14.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.045]                       search = base::search(), system = base::Sys.info())
[16:19:14.045]                   }
[16:19:14.045]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.045]                     cond$call), session = sessionInformation(), 
[16:19:14.045]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.045]                   signalCondition(cond)
[16:19:14.045]                 }
[16:19:14.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.045]                 "immediateCondition"))) {
[16:19:14.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.045]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.045]                   if (TRUE && !signal) {
[16:19:14.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.045]                     {
[16:19:14.045]                       inherits <- base::inherits
[16:19:14.045]                       invokeRestart <- base::invokeRestart
[16:19:14.045]                       is.null <- base::is.null
[16:19:14.045]                       muffled <- FALSE
[16:19:14.045]                       if (inherits(cond, "message")) {
[16:19:14.045]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.045]                         if (muffled) 
[16:19:14.045]                           invokeRestart("muffleMessage")
[16:19:14.045]                       }
[16:19:14.045]                       else if (inherits(cond, "warning")) {
[16:19:14.045]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.045]                         if (muffled) 
[16:19:14.045]                           invokeRestart("muffleWarning")
[16:19:14.045]                       }
[16:19:14.045]                       else if (inherits(cond, "condition")) {
[16:19:14.045]                         if (!is.null(pattern)) {
[16:19:14.045]                           computeRestarts <- base::computeRestarts
[16:19:14.045]                           grepl <- base::grepl
[16:19:14.045]                           restarts <- computeRestarts(cond)
[16:19:14.045]                           for (restart in restarts) {
[16:19:14.045]                             name <- restart$name
[16:19:14.045]                             if (is.null(name)) 
[16:19:14.045]                               next
[16:19:14.045]                             if (!grepl(pattern, name)) 
[16:19:14.045]                               next
[16:19:14.045]                             invokeRestart(restart)
[16:19:14.045]                             muffled <- TRUE
[16:19:14.045]                             break
[16:19:14.045]                           }
[16:19:14.045]                         }
[16:19:14.045]                       }
[16:19:14.045]                       invisible(muffled)
[16:19:14.045]                     }
[16:19:14.045]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.045]                   }
[16:19:14.045]                 }
[16:19:14.045]                 else {
[16:19:14.045]                   if (TRUE) {
[16:19:14.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.045]                     {
[16:19:14.045]                       inherits <- base::inherits
[16:19:14.045]                       invokeRestart <- base::invokeRestart
[16:19:14.045]                       is.null <- base::is.null
[16:19:14.045]                       muffled <- FALSE
[16:19:14.045]                       if (inherits(cond, "message")) {
[16:19:14.045]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.045]                         if (muffled) 
[16:19:14.045]                           invokeRestart("muffleMessage")
[16:19:14.045]                       }
[16:19:14.045]                       else if (inherits(cond, "warning")) {
[16:19:14.045]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.045]                         if (muffled) 
[16:19:14.045]                           invokeRestart("muffleWarning")
[16:19:14.045]                       }
[16:19:14.045]                       else if (inherits(cond, "condition")) {
[16:19:14.045]                         if (!is.null(pattern)) {
[16:19:14.045]                           computeRestarts <- base::computeRestarts
[16:19:14.045]                           grepl <- base::grepl
[16:19:14.045]                           restarts <- computeRestarts(cond)
[16:19:14.045]                           for (restart in restarts) {
[16:19:14.045]                             name <- restart$name
[16:19:14.045]                             if (is.null(name)) 
[16:19:14.045]                               next
[16:19:14.045]                             if (!grepl(pattern, name)) 
[16:19:14.045]                               next
[16:19:14.045]                             invokeRestart(restart)
[16:19:14.045]                             muffled <- TRUE
[16:19:14.045]                             break
[16:19:14.045]                           }
[16:19:14.045]                         }
[16:19:14.045]                       }
[16:19:14.045]                       invisible(muffled)
[16:19:14.045]                     }
[16:19:14.045]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.045]                   }
[16:19:14.045]                 }
[16:19:14.045]             }
[16:19:14.045]         }))
[16:19:14.045]     }, error = function(ex) {
[16:19:14.045]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.045]                 ...future.rng), started = ...future.startTime, 
[16:19:14.045]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.045]             version = "1.8"), class = "FutureResult")
[16:19:14.045]     }, finally = {
[16:19:14.045]         if (!identical(...future.workdir, getwd())) 
[16:19:14.045]             setwd(...future.workdir)
[16:19:14.045]         {
[16:19:14.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.045]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.045]             }
[16:19:14.045]             base::options(...future.oldOptions)
[16:19:14.045]             if (.Platform$OS.type == "windows") {
[16:19:14.045]                 old_names <- names(...future.oldEnvVars)
[16:19:14.045]                 envs <- base::Sys.getenv()
[16:19:14.045]                 names <- names(envs)
[16:19:14.045]                 common <- intersect(names, old_names)
[16:19:14.045]                 added <- setdiff(names, old_names)
[16:19:14.045]                 removed <- setdiff(old_names, names)
[16:19:14.045]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.045]                   envs[common]]
[16:19:14.045]                 NAMES <- toupper(changed)
[16:19:14.045]                 args <- list()
[16:19:14.045]                 for (kk in seq_along(NAMES)) {
[16:19:14.045]                   name <- changed[[kk]]
[16:19:14.045]                   NAME <- NAMES[[kk]]
[16:19:14.045]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.045]                     next
[16:19:14.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.045]                 }
[16:19:14.045]                 NAMES <- toupper(added)
[16:19:14.045]                 for (kk in seq_along(NAMES)) {
[16:19:14.045]                   name <- added[[kk]]
[16:19:14.045]                   NAME <- NAMES[[kk]]
[16:19:14.045]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.045]                     next
[16:19:14.045]                   args[[name]] <- ""
[16:19:14.045]                 }
[16:19:14.045]                 NAMES <- toupper(removed)
[16:19:14.045]                 for (kk in seq_along(NAMES)) {
[16:19:14.045]                   name <- removed[[kk]]
[16:19:14.045]                   NAME <- NAMES[[kk]]
[16:19:14.045]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.045]                     next
[16:19:14.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.045]                 }
[16:19:14.045]                 if (length(args) > 0) 
[16:19:14.045]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.045]             }
[16:19:14.045]             else {
[16:19:14.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.045]             }
[16:19:14.045]             {
[16:19:14.045]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.045]                   0L) {
[16:19:14.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.045]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.045]                   base::options(opts)
[16:19:14.045]                 }
[16:19:14.045]                 {
[16:19:14.045]                   {
[16:19:14.045]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.045]                     NULL
[16:19:14.045]                   }
[16:19:14.045]                   options(future.plan = NULL)
[16:19:14.045]                   if (is.na(NA_character_)) 
[16:19:14.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.045]                     .init = FALSE)
[16:19:14.045]                 }
[16:19:14.045]             }
[16:19:14.045]         }
[16:19:14.045]     })
[16:19:14.045]     if (TRUE) {
[16:19:14.045]         base::sink(type = "output", split = FALSE)
[16:19:14.045]         if (TRUE) {
[16:19:14.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.045]         }
[16:19:14.045]         else {
[16:19:14.045]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.045]         }
[16:19:14.045]         base::close(...future.stdout)
[16:19:14.045]         ...future.stdout <- NULL
[16:19:14.045]     }
[16:19:14.045]     ...future.result$conditions <- ...future.conditions
[16:19:14.045]     ...future.result$finished <- base::Sys.time()
[16:19:14.045]     ...future.result
[16:19:14.045] }
[16:19:14.047] assign_globals() ...
[16:19:14.047] List of 11
[16:19:14.047]  $ ...future.FUN            :function (x, ...)  
[16:19:14.047]  $ x_FUN                    :function (x)  
[16:19:14.047]  $ times                    : int 4
[16:19:14.047]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.047]  $ stop_if_not              :function (...)  
[16:19:14.047]  $ dim                      : int [1:2] 2 2
[16:19:14.047]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:14.047]  $ future.call.arguments    : list()
[16:19:14.047]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.047]  $ ...future.elements_ii    :List of 5
[16:19:14.047]   ..$ : int 6
[16:19:14.047]   ..$ : int 7
[16:19:14.047]   ..$ : int 8
[16:19:14.047]   ..$ : int 9
[16:19:14.047]   ..$ : int 10
[16:19:14.047]  $ ...future.seeds_ii       : NULL
[16:19:14.047]  $ ...future.globals.maxSize: NULL
[16:19:14.047]  - attr(*, "where")=List of 11
[16:19:14.047]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.047]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.047]  - attr(*, "resolved")= logi FALSE
[16:19:14.047]  - attr(*, "total_size")= num 97232
[16:19:14.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.047]  - attr(*, "already-done")= logi TRUE
[16:19:14.058] - copied ‘...future.FUN’ to environment
[16:19:14.058] - reassign environment for ‘x_FUN’
[16:19:14.058] - copied ‘x_FUN’ to environment
[16:19:14.058] - copied ‘times’ to environment
[16:19:14.058] - copied ‘stopf’ to environment
[16:19:14.058] - copied ‘stop_if_not’ to environment
[16:19:14.058] - copied ‘dim’ to environment
[16:19:14.059] - copied ‘valid_types’ to environment
[16:19:14.059] - copied ‘future.call.arguments’ to environment
[16:19:14.061] - copied ‘...future.elements_ii’ to environment
[16:19:14.061] - copied ‘...future.seeds_ii’ to environment
[16:19:14.061] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.061] assign_globals() ... done
[16:19:14.062] requestCore(): workers = 2
[16:19:14.064] MulticoreFuture started
[16:19:14.065] - Launch lazy future ... done
[16:19:14.066] run() for ‘MulticoreFuture’ ... done
[16:19:14.066] Created future:
[16:19:14.066] plan(): Setting new future strategy stack:
[16:19:14.067] List of future strategies:
[16:19:14.067] 1. sequential:
[16:19:14.067]    - args: function (..., envir = parent.frame())
[16:19:14.067]    - tweaked: FALSE
[16:19:14.067]    - call: NULL
[16:19:14.068] plan(): nbrOfWorkers() = 1
[16:19:14.071] plan(): Setting new future strategy stack:
[16:19:14.072] List of future strategies:
[16:19:14.072] 1. multicore:
[16:19:14.072]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.072]    - tweaked: FALSE
[16:19:14.072]    - call: plan(strategy)
[16:19:14.078] plan(): nbrOfWorkers() = 2
[16:19:14.067] MulticoreFuture:
[16:19:14.067] Label: ‘future_vapply-2’
[16:19:14.067] Expression:
[16:19:14.067] {
[16:19:14.067]     do.call(function(...) {
[16:19:14.067]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.067]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.067]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.067]             on.exit(options(oopts), add = TRUE)
[16:19:14.067]         }
[16:19:14.067]         {
[16:19:14.067]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.067]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.067]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.067]             })
[16:19:14.067]         }
[16:19:14.067]     }, args = future.call.arguments)
[16:19:14.067] }
[16:19:14.067] Lazy evaluation: FALSE
[16:19:14.067] Asynchronous evaluation: TRUE
[16:19:14.067] Local evaluation: TRUE
[16:19:14.067] Environment: R_GlobalEnv
[16:19:14.067] Capture standard output: TRUE
[16:19:14.067] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.067] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.067] Packages: 1 packages (‘future.apply’)
[16:19:14.067] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.067] Resolved: TRUE
[16:19:14.067] Value: <not collected>
[16:19:14.067] Conditions captured: <none>
[16:19:14.067] Early signaling: FALSE
[16:19:14.067] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.067] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.079] Chunk #2 of 2 ... DONE
[16:19:14.079] Launching 2 futures (chunks) ... DONE
[16:19:14.080] Resolving 2 futures (chunks) ...
[16:19:14.080] resolve() on list ...
[16:19:14.080]  recursive: 0
[16:19:14.080]  length: 2
[16:19:14.081] 
[16:19:14.081] Future #1
[16:19:14.081] result() for MulticoreFuture ...
[16:19:14.082] result() for MulticoreFuture ...
[16:19:14.083] result() for MulticoreFuture ... done
[16:19:14.083] result() for MulticoreFuture ... done
[16:19:14.083] result() for MulticoreFuture ...
[16:19:14.083] result() for MulticoreFuture ... done
[16:19:14.084] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:14.084] - nx: 2
[16:19:14.084] - relay: TRUE
[16:19:14.085] - stdout: TRUE
[16:19:14.085] - signal: TRUE
[16:19:14.085] - resignal: FALSE
[16:19:14.085] - force: TRUE
[16:19:14.086] - relayed: [n=2] FALSE, FALSE
[16:19:14.086] - queued futures: [n=2] FALSE, FALSE
[16:19:14.086]  - until=1
[16:19:14.087]  - relaying element #1
[16:19:14.087] result() for MulticoreFuture ...
[16:19:14.087] result() for MulticoreFuture ... done
[16:19:14.087] result() for MulticoreFuture ...
[16:19:14.088] result() for MulticoreFuture ... done
[16:19:14.088] result() for MulticoreFuture ...
[16:19:14.088] result() for MulticoreFuture ... done
[16:19:14.088] result() for MulticoreFuture ...
[16:19:14.088] result() for MulticoreFuture ... done
[16:19:14.088] - relayed: [n=2] TRUE, FALSE
[16:19:14.088] - queued futures: [n=2] TRUE, FALSE
[16:19:14.089] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:14.089]  length: 1 (resolved future 1)
[16:19:14.089] Future #2
[16:19:14.090] result() for MulticoreFuture ...
[16:19:14.090] result() for MulticoreFuture ...
[16:19:14.091] result() for MulticoreFuture ... done
[16:19:14.091] result() for MulticoreFuture ... done
[16:19:14.091] result() for MulticoreFuture ...
[16:19:14.091] result() for MulticoreFuture ... done
[16:19:14.091] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:14.091] - nx: 2
[16:19:14.091] - relay: TRUE
[16:19:14.092] - stdout: TRUE
[16:19:14.092] - signal: TRUE
[16:19:14.092] - resignal: FALSE
[16:19:14.092] - force: TRUE
[16:19:14.092] - relayed: [n=2] TRUE, FALSE
[16:19:14.092] - queued futures: [n=2] TRUE, FALSE
[16:19:14.092]  - until=2
[16:19:14.092]  - relaying element #2
[16:19:14.093] result() for MulticoreFuture ...
[16:19:14.093] result() for MulticoreFuture ... done
[16:19:14.093] result() for MulticoreFuture ...
[16:19:14.093] result() for MulticoreFuture ... done
[16:19:14.093] result() for MulticoreFuture ...
[16:19:14.093] result() for MulticoreFuture ... done
[16:19:14.093] result() for MulticoreFuture ...
[16:19:14.093] result() for MulticoreFuture ... done
[16:19:14.094] - relayed: [n=2] TRUE, TRUE
[16:19:14.094] - queued futures: [n=2] TRUE, TRUE
[16:19:14.094] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:14.094]  length: 0 (resolved future 2)
[16:19:14.094] Relaying remaining futures
[16:19:14.094] signalConditionsASAP(NULL, pos=0) ...
[16:19:14.094] - nx: 2
[16:19:14.094] - relay: TRUE
[16:19:14.094] - stdout: TRUE
[16:19:14.094] - signal: TRUE
[16:19:14.095] - resignal: FALSE
[16:19:14.095] - force: TRUE
[16:19:14.095] - relayed: [n=2] TRUE, TRUE
[16:19:14.095] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:14.095] - relayed: [n=2] TRUE, TRUE
[16:19:14.095] - queued futures: [n=2] TRUE, TRUE
[16:19:14.095] signalConditionsASAP(NULL, pos=0) ... done
[16:19:14.095] resolve() on list ... DONE
[16:19:14.095] result() for MulticoreFuture ...
[16:19:14.096] result() for MulticoreFuture ... done
[16:19:14.096] result() for MulticoreFuture ...
[16:19:14.096] result() for MulticoreFuture ... done
[16:19:14.096] result() for MulticoreFuture ...
[16:19:14.096] result() for MulticoreFuture ... done
[16:19:14.096] result() for MulticoreFuture ...
[16:19:14.096] result() for MulticoreFuture ... done
[16:19:14.096]  - Number of value chunks collected: 2
[16:19:14.096] Resolving 2 futures (chunks) ... DONE
[16:19:14.097] Reducing values from 2 chunks ...
[16:19:14.097]  - Number of values collected after concatenation: 10
[16:19:14.097]  - Number of values expected: 10
[16:19:14.097] Reducing values from 2 chunks ... DONE
[16:19:14.097] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:19:14.098] future_lapply() ...
[16:19:14.104] Number of chunks: 2
[16:19:14.105] getGlobalsAndPackagesXApply() ...
[16:19:14.105]  - future.globals: TRUE
[16:19:14.105] getGlobalsAndPackages() ...
[16:19:14.105] Searching for globals...
[16:19:14.111] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:19:14.111] Searching for globals ... DONE
[16:19:14.111] Resolving globals: FALSE
[16:19:14.112] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:19:14.113] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:14.113] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.113] - packages: [1] ‘future.apply’
[16:19:14.113] getGlobalsAndPackages() ... DONE
[16:19:14.113]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.114]  - needed namespaces: [n=1] ‘future.apply’
[16:19:14.114] Finding globals ... DONE
[16:19:14.114]  - use_args: TRUE
[16:19:14.114]  - Getting '...' globals ...
[16:19:14.114] resolve() on list ...
[16:19:14.114]  recursive: 0
[16:19:14.114]  length: 1
[16:19:14.115]  elements: ‘...’
[16:19:14.115]  length: 0 (resolved future 1)
[16:19:14.115] resolve() on list ... DONE
[16:19:14.115]    - '...' content: [n=0] 
[16:19:14.115] List of 1
[16:19:14.115]  $ ...: list()
[16:19:14.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.115]  - attr(*, "where")=List of 1
[16:19:14.115]   ..$ ...:<environment: 0x56199ee9c5d0> 
[16:19:14.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.115]  - attr(*, "resolved")= logi TRUE
[16:19:14.115]  - attr(*, "total_size")= num NA
[16:19:14.118]  - Getting '...' globals ... DONE
[16:19:14.118] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:14.118] List of 8
[16:19:14.118]  $ ...future.FUN:function (x, ...)  
[16:19:14.118]  $ x_FUN        :function (x)  
[16:19:14.118]  $ times        : int 4
[16:19:14.118]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.118]  $ stop_if_not  :function (...)  
[16:19:14.118]  $ dim          : int [1:2] 2 2
[16:19:14.118]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:14.118]  $ ...          : list()
[16:19:14.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.118]  - attr(*, "where")=List of 8
[16:19:14.118]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:14.118]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:14.118]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:14.118]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:14.118]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:14.118]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:14.118]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:14.118]   ..$ ...          :<environment: 0x56199ee9c5d0> 
[16:19:14.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.118]  - attr(*, "resolved")= logi FALSE
[16:19:14.118]  - attr(*, "total_size")= num 97304
[16:19:14.123] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:14.124] getGlobalsAndPackagesXApply() ... DONE
[16:19:14.124] Number of futures (= number of chunks): 2
[16:19:14.124] Launching 2 futures (chunks) ...
[16:19:14.124] Chunk #1 of 2 ...
[16:19:14.124]  - Finding globals in 'X' for chunk #1 ...
[16:19:14.124] getGlobalsAndPackages() ...
[16:19:14.124] Searching for globals...
[16:19:14.125] 
[16:19:14.125] Searching for globals ... DONE
[16:19:14.125] - globals: [0] <none>
[16:19:14.125] getGlobalsAndPackages() ... DONE
[16:19:14.125]    + additional globals found: [n=0] 
[16:19:14.125]    + additional namespaces needed: [n=0] 
[16:19:14.125]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:14.125]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.125]  - seeds: <none>
[16:19:14.125]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.126] getGlobalsAndPackages() ...
[16:19:14.126] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.126] Resolving globals: FALSE
[16:19:14.126] Tweak future expression to call with '...' arguments ...
[16:19:14.126] {
[16:19:14.126]     do.call(function(...) {
[16:19:14.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.126]             on.exit(options(oopts), add = TRUE)
[16:19:14.126]         }
[16:19:14.126]         {
[16:19:14.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.126]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.126]             })
[16:19:14.126]         }
[16:19:14.126]     }, args = future.call.arguments)
[16:19:14.126] }
[16:19:14.126] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.127] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.127] - packages: [1] ‘future.apply’
[16:19:14.127] getGlobalsAndPackages() ... DONE
[16:19:14.127] run() for ‘Future’ ...
[16:19:14.127] - state: ‘created’
[16:19:14.128] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.131] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.131]   - Field: ‘label’
[16:19:14.132]   - Field: ‘local’
[16:19:14.133]   - Field: ‘owner’
[16:19:14.134]   - Field: ‘envir’
[16:19:14.134]   - Field: ‘workers’
[16:19:14.134]   - Field: ‘packages’
[16:19:14.134]   - Field: ‘gc’
[16:19:14.134]   - Field: ‘job’
[16:19:14.134]   - Field: ‘conditions’
[16:19:14.134]   - Field: ‘expr’
[16:19:14.134]   - Field: ‘uuid’
[16:19:14.134]   - Field: ‘seed’
[16:19:14.135]   - Field: ‘version’
[16:19:14.135]   - Field: ‘result’
[16:19:14.135]   - Field: ‘asynchronous’
[16:19:14.135]   - Field: ‘calls’
[16:19:14.135]   - Field: ‘globals’
[16:19:14.135]   - Field: ‘stdout’
[16:19:14.135]   - Field: ‘earlySignal’
[16:19:14.135]   - Field: ‘lazy’
[16:19:14.135]   - Field: ‘state’
[16:19:14.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.136] - Launch lazy future ...
[16:19:14.136] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:14.136] Packages needed by future strategies (n = 0): <none>
[16:19:14.137] {
[16:19:14.137]     {
[16:19:14.137]         {
[16:19:14.137]             ...future.startTime <- base::Sys.time()
[16:19:14.137]             {
[16:19:14.137]                 {
[16:19:14.137]                   {
[16:19:14.137]                     {
[16:19:14.137]                       {
[16:19:14.137]                         base::local({
[16:19:14.137]                           has_future <- base::requireNamespace("future", 
[16:19:14.137]                             quietly = TRUE)
[16:19:14.137]                           if (has_future) {
[16:19:14.137]                             ns <- base::getNamespace("future")
[16:19:14.137]                             version <- ns[[".package"]][["version"]]
[16:19:14.137]                             if (is.null(version)) 
[16:19:14.137]                               version <- utils::packageVersion("future")
[16:19:14.137]                           }
[16:19:14.137]                           else {
[16:19:14.137]                             version <- NULL
[16:19:14.137]                           }
[16:19:14.137]                           if (!has_future || version < "1.8.0") {
[16:19:14.137]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.137]                               "", base::R.version$version.string), 
[16:19:14.137]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.137]                                 base::R.version$platform, 8 * 
[16:19:14.137]                                   base::.Machine$sizeof.pointer), 
[16:19:14.137]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.137]                                 "release", "version")], collapse = " "), 
[16:19:14.137]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.137]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.137]                               info)
[16:19:14.137]                             info <- base::paste(info, collapse = "; ")
[16:19:14.137]                             if (!has_future) {
[16:19:14.137]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.137]                                 info)
[16:19:14.137]                             }
[16:19:14.137]                             else {
[16:19:14.137]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.137]                                 info, version)
[16:19:14.137]                             }
[16:19:14.137]                             base::stop(msg)
[16:19:14.137]                           }
[16:19:14.137]                         })
[16:19:14.137]                       }
[16:19:14.137]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.137]                       base::options(mc.cores = 1L)
[16:19:14.137]                     }
[16:19:14.137]                     base::local({
[16:19:14.137]                       for (pkg in "future.apply") {
[16:19:14.137]                         base::loadNamespace(pkg)
[16:19:14.137]                         base::library(pkg, character.only = TRUE)
[16:19:14.137]                       }
[16:19:14.137]                     })
[16:19:14.137]                   }
[16:19:14.137]                   ...future.strategy.old <- future::plan("list")
[16:19:14.137]                   options(future.plan = NULL)
[16:19:14.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.137]                 }
[16:19:14.137]                 ...future.workdir <- getwd()
[16:19:14.137]             }
[16:19:14.137]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.137]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.137]         }
[16:19:14.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.137]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.137]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.137]             base::names(...future.oldOptions))
[16:19:14.137]     }
[16:19:14.137]     if (FALSE) {
[16:19:14.137]     }
[16:19:14.137]     else {
[16:19:14.137]         if (TRUE) {
[16:19:14.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.137]                 open = "w")
[16:19:14.137]         }
[16:19:14.137]         else {
[16:19:14.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.137]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.137]         }
[16:19:14.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.137]             base::sink(type = "output", split = FALSE)
[16:19:14.137]             base::close(...future.stdout)
[16:19:14.137]         }, add = TRUE)
[16:19:14.137]     }
[16:19:14.137]     ...future.frame <- base::sys.nframe()
[16:19:14.137]     ...future.conditions <- base::list()
[16:19:14.137]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.137]     if (FALSE) {
[16:19:14.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.137]     }
[16:19:14.137]     ...future.result <- base::tryCatch({
[16:19:14.137]         base::withCallingHandlers({
[16:19:14.137]             ...future.value <- base::withVisible(base::local({
[16:19:14.137]                 withCallingHandlers({
[16:19:14.137]                   {
[16:19:14.137]                     do.call(function(...) {
[16:19:14.137]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.137]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.137]                         ...future.globals.maxSize)) {
[16:19:14.137]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.137]                         on.exit(options(oopts), add = TRUE)
[16:19:14.137]                       }
[16:19:14.137]                       {
[16:19:14.137]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.137]                           FUN = function(jj) {
[16:19:14.137]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.137]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.137]                           })
[16:19:14.137]                       }
[16:19:14.137]                     }, args = future.call.arguments)
[16:19:14.137]                   }
[16:19:14.137]                 }, immediateCondition = function(cond) {
[16:19:14.137]                   save_rds <- function (object, pathname, ...) 
[16:19:14.137]                   {
[16:19:14.137]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.137]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.137]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.137]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.137]                         fi_tmp[["mtime"]])
[16:19:14.137]                     }
[16:19:14.137]                     tryCatch({
[16:19:14.137]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.137]                     }, error = function(ex) {
[16:19:14.137]                       msg <- conditionMessage(ex)
[16:19:14.137]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.137]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.137]                         fi_tmp[["mtime"]], msg)
[16:19:14.137]                       ex$message <- msg
[16:19:14.137]                       stop(ex)
[16:19:14.137]                     })
[16:19:14.137]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.137]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.137]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.137]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.137]                       fi <- file.info(pathname)
[16:19:14.137]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.137]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.137]                         fi[["size"]], fi[["mtime"]])
[16:19:14.137]                       stop(msg)
[16:19:14.137]                     }
[16:19:14.137]                     invisible(pathname)
[16:19:14.137]                   }
[16:19:14.137]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.137]                     rootPath = tempdir()) 
[16:19:14.137]                   {
[16:19:14.137]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.137]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.137]                       tmpdir = path, fileext = ".rds")
[16:19:14.137]                     save_rds(obj, file)
[16:19:14.137]                   }
[16:19:14.137]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.137]                   {
[16:19:14.137]                     inherits <- base::inherits
[16:19:14.137]                     invokeRestart <- base::invokeRestart
[16:19:14.137]                     is.null <- base::is.null
[16:19:14.137]                     muffled <- FALSE
[16:19:14.137]                     if (inherits(cond, "message")) {
[16:19:14.137]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.137]                       if (muffled) 
[16:19:14.137]                         invokeRestart("muffleMessage")
[16:19:14.137]                     }
[16:19:14.137]                     else if (inherits(cond, "warning")) {
[16:19:14.137]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.137]                       if (muffled) 
[16:19:14.137]                         invokeRestart("muffleWarning")
[16:19:14.137]                     }
[16:19:14.137]                     else if (inherits(cond, "condition")) {
[16:19:14.137]                       if (!is.null(pattern)) {
[16:19:14.137]                         computeRestarts <- base::computeRestarts
[16:19:14.137]                         grepl <- base::grepl
[16:19:14.137]                         restarts <- computeRestarts(cond)
[16:19:14.137]                         for (restart in restarts) {
[16:19:14.137]                           name <- restart$name
[16:19:14.137]                           if (is.null(name)) 
[16:19:14.137]                             next
[16:19:14.137]                           if (!grepl(pattern, name)) 
[16:19:14.137]                             next
[16:19:14.137]                           invokeRestart(restart)
[16:19:14.137]                           muffled <- TRUE
[16:19:14.137]                           break
[16:19:14.137]                         }
[16:19:14.137]                       }
[16:19:14.137]                     }
[16:19:14.137]                     invisible(muffled)
[16:19:14.137]                   }
[16:19:14.137]                   muffleCondition(cond)
[16:19:14.137]                 })
[16:19:14.137]             }))
[16:19:14.137]             future::FutureResult(value = ...future.value$value, 
[16:19:14.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.137]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.137]                     ...future.globalenv.names))
[16:19:14.137]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.137]         }, condition = base::local({
[16:19:14.137]             c <- base::c
[16:19:14.137]             inherits <- base::inherits
[16:19:14.137]             invokeRestart <- base::invokeRestart
[16:19:14.137]             length <- base::length
[16:19:14.137]             list <- base::list
[16:19:14.137]             seq.int <- base::seq.int
[16:19:14.137]             signalCondition <- base::signalCondition
[16:19:14.137]             sys.calls <- base::sys.calls
[16:19:14.137]             `[[` <- base::`[[`
[16:19:14.137]             `+` <- base::`+`
[16:19:14.137]             `<<-` <- base::`<<-`
[16:19:14.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.137]                   3L)]
[16:19:14.137]             }
[16:19:14.137]             function(cond) {
[16:19:14.137]                 is_error <- inherits(cond, "error")
[16:19:14.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.137]                   NULL)
[16:19:14.137]                 if (is_error) {
[16:19:14.137]                   sessionInformation <- function() {
[16:19:14.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.137]                       search = base::search(), system = base::Sys.info())
[16:19:14.137]                   }
[16:19:14.137]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.137]                     cond$call), session = sessionInformation(), 
[16:19:14.137]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.137]                   signalCondition(cond)
[16:19:14.137]                 }
[16:19:14.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.137]                 "immediateCondition"))) {
[16:19:14.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.137]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.137]                   if (TRUE && !signal) {
[16:19:14.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.137]                     {
[16:19:14.137]                       inherits <- base::inherits
[16:19:14.137]                       invokeRestart <- base::invokeRestart
[16:19:14.137]                       is.null <- base::is.null
[16:19:14.137]                       muffled <- FALSE
[16:19:14.137]                       if (inherits(cond, "message")) {
[16:19:14.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.137]                         if (muffled) 
[16:19:14.137]                           invokeRestart("muffleMessage")
[16:19:14.137]                       }
[16:19:14.137]                       else if (inherits(cond, "warning")) {
[16:19:14.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.137]                         if (muffled) 
[16:19:14.137]                           invokeRestart("muffleWarning")
[16:19:14.137]                       }
[16:19:14.137]                       else if (inherits(cond, "condition")) {
[16:19:14.137]                         if (!is.null(pattern)) {
[16:19:14.137]                           computeRestarts <- base::computeRestarts
[16:19:14.137]                           grepl <- base::grepl
[16:19:14.137]                           restarts <- computeRestarts(cond)
[16:19:14.137]                           for (restart in restarts) {
[16:19:14.137]                             name <- restart$name
[16:19:14.137]                             if (is.null(name)) 
[16:19:14.137]                               next
[16:19:14.137]                             if (!grepl(pattern, name)) 
[16:19:14.137]                               next
[16:19:14.137]                             invokeRestart(restart)
[16:19:14.137]                             muffled <- TRUE
[16:19:14.137]                             break
[16:19:14.137]                           }
[16:19:14.137]                         }
[16:19:14.137]                       }
[16:19:14.137]                       invisible(muffled)
[16:19:14.137]                     }
[16:19:14.137]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.137]                   }
[16:19:14.137]                 }
[16:19:14.137]                 else {
[16:19:14.137]                   if (TRUE) {
[16:19:14.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.137]                     {
[16:19:14.137]                       inherits <- base::inherits
[16:19:14.137]                       invokeRestart <- base::invokeRestart
[16:19:14.137]                       is.null <- base::is.null
[16:19:14.137]                       muffled <- FALSE
[16:19:14.137]                       if (inherits(cond, "message")) {
[16:19:14.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.137]                         if (muffled) 
[16:19:14.137]                           invokeRestart("muffleMessage")
[16:19:14.137]                       }
[16:19:14.137]                       else if (inherits(cond, "warning")) {
[16:19:14.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.137]                         if (muffled) 
[16:19:14.137]                           invokeRestart("muffleWarning")
[16:19:14.137]                       }
[16:19:14.137]                       else if (inherits(cond, "condition")) {
[16:19:14.137]                         if (!is.null(pattern)) {
[16:19:14.137]                           computeRestarts <- base::computeRestarts
[16:19:14.137]                           grepl <- base::grepl
[16:19:14.137]                           restarts <- computeRestarts(cond)
[16:19:14.137]                           for (restart in restarts) {
[16:19:14.137]                             name <- restart$name
[16:19:14.137]                             if (is.null(name)) 
[16:19:14.137]                               next
[16:19:14.137]                             if (!grepl(pattern, name)) 
[16:19:14.137]                               next
[16:19:14.137]                             invokeRestart(restart)
[16:19:14.137]                             muffled <- TRUE
[16:19:14.137]                             break
[16:19:14.137]                           }
[16:19:14.137]                         }
[16:19:14.137]                       }
[16:19:14.137]                       invisible(muffled)
[16:19:14.137]                     }
[16:19:14.137]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.137]                   }
[16:19:14.137]                 }
[16:19:14.137]             }
[16:19:14.137]         }))
[16:19:14.137]     }, error = function(ex) {
[16:19:14.137]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.137]                 ...future.rng), started = ...future.startTime, 
[16:19:14.137]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.137]             version = "1.8"), class = "FutureResult")
[16:19:14.137]     }, finally = {
[16:19:14.137]         if (!identical(...future.workdir, getwd())) 
[16:19:14.137]             setwd(...future.workdir)
[16:19:14.137]         {
[16:19:14.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.137]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.137]             }
[16:19:14.137]             base::options(...future.oldOptions)
[16:19:14.137]             if (.Platform$OS.type == "windows") {
[16:19:14.137]                 old_names <- names(...future.oldEnvVars)
[16:19:14.137]                 envs <- base::Sys.getenv()
[16:19:14.137]                 names <- names(envs)
[16:19:14.137]                 common <- intersect(names, old_names)
[16:19:14.137]                 added <- setdiff(names, old_names)
[16:19:14.137]                 removed <- setdiff(old_names, names)
[16:19:14.137]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.137]                   envs[common]]
[16:19:14.137]                 NAMES <- toupper(changed)
[16:19:14.137]                 args <- list()
[16:19:14.137]                 for (kk in seq_along(NAMES)) {
[16:19:14.137]                   name <- changed[[kk]]
[16:19:14.137]                   NAME <- NAMES[[kk]]
[16:19:14.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.137]                     next
[16:19:14.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.137]                 }
[16:19:14.137]                 NAMES <- toupper(added)
[16:19:14.137]                 for (kk in seq_along(NAMES)) {
[16:19:14.137]                   name <- added[[kk]]
[16:19:14.137]                   NAME <- NAMES[[kk]]
[16:19:14.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.137]                     next
[16:19:14.137]                   args[[name]] <- ""
[16:19:14.137]                 }
[16:19:14.137]                 NAMES <- toupper(removed)
[16:19:14.137]                 for (kk in seq_along(NAMES)) {
[16:19:14.137]                   name <- removed[[kk]]
[16:19:14.137]                   NAME <- NAMES[[kk]]
[16:19:14.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.137]                     next
[16:19:14.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.137]                 }
[16:19:14.137]                 if (length(args) > 0) 
[16:19:14.137]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.137]             }
[16:19:14.137]             else {
[16:19:14.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.137]             }
[16:19:14.137]             {
[16:19:14.137]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.137]                   0L) {
[16:19:14.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.137]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.137]                   base::options(opts)
[16:19:14.137]                 }
[16:19:14.137]                 {
[16:19:14.137]                   {
[16:19:14.137]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.137]                     NULL
[16:19:14.137]                   }
[16:19:14.137]                   options(future.plan = NULL)
[16:19:14.137]                   if (is.na(NA_character_)) 
[16:19:14.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.137]                     .init = FALSE)
[16:19:14.137]                 }
[16:19:14.137]             }
[16:19:14.137]         }
[16:19:14.137]     })
[16:19:14.137]     if (TRUE) {
[16:19:14.137]         base::sink(type = "output", split = FALSE)
[16:19:14.137]         if (TRUE) {
[16:19:14.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.137]         }
[16:19:14.137]         else {
[16:19:14.137]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.137]         }
[16:19:14.137]         base::close(...future.stdout)
[16:19:14.137]         ...future.stdout <- NULL
[16:19:14.137]     }
[16:19:14.137]     ...future.result$conditions <- ...future.conditions
[16:19:14.137]     ...future.result$finished <- base::Sys.time()
[16:19:14.137]     ...future.result
[16:19:14.137] }
[16:19:14.139] assign_globals() ...
[16:19:14.140] List of 11
[16:19:14.140]  $ ...future.FUN            :function (x, ...)  
[16:19:14.140]  $ x_FUN                    :function (x)  
[16:19:14.140]  $ times                    : int 4
[16:19:14.140]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.140]  $ stop_if_not              :function (...)  
[16:19:14.140]  $ dim                      : int [1:2] 2 2
[16:19:14.140]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.140]  $ future.call.arguments    : list()
[16:19:14.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.140]  $ ...future.elements_ii    :List of 5
[16:19:14.140]   ..$ : int 1
[16:19:14.140]   ..$ : int 2
[16:19:14.140]   ..$ : int 3
[16:19:14.140]   ..$ : int 4
[16:19:14.140]   ..$ : int 5
[16:19:14.140]  $ ...future.seeds_ii       : NULL
[16:19:14.140]  $ ...future.globals.maxSize: NULL
[16:19:14.140]  - attr(*, "where")=List of 11
[16:19:14.140]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.140]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.140]  - attr(*, "resolved")= logi FALSE
[16:19:14.140]  - attr(*, "total_size")= num 97304
[16:19:14.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.140]  - attr(*, "already-done")= logi TRUE
[16:19:14.149] - copied ‘...future.FUN’ to environment
[16:19:14.149] - reassign environment for ‘x_FUN’
[16:19:14.149] - copied ‘x_FUN’ to environment
[16:19:14.149] - copied ‘times’ to environment
[16:19:14.149] - copied ‘stopf’ to environment
[16:19:14.149] - copied ‘stop_if_not’ to environment
[16:19:14.149] - copied ‘dim’ to environment
[16:19:14.149] - copied ‘valid_types’ to environment
[16:19:14.149] - copied ‘future.call.arguments’ to environment
[16:19:14.149] - copied ‘...future.elements_ii’ to environment
[16:19:14.149] - copied ‘...future.seeds_ii’ to environment
[16:19:14.150] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.150] assign_globals() ... done
[16:19:14.150] requestCore(): workers = 2
[16:19:14.152] MulticoreFuture started
[16:19:14.152] - Launch lazy future ... done
[16:19:14.153] run() for ‘MulticoreFuture’ ... done
[16:19:14.153] Created future:
[16:19:14.154] plan(): Setting new future strategy stack:
[16:19:14.154] List of future strategies:
[16:19:14.154] 1. sequential:
[16:19:14.154]    - args: function (..., envir = parent.frame())
[16:19:14.154]    - tweaked: FALSE
[16:19:14.154]    - call: NULL
[16:19:14.155] plan(): nbrOfWorkers() = 1
[16:19:14.157] plan(): Setting new future strategy stack:
[16:19:14.157] List of future strategies:
[16:19:14.157] 1. multicore:
[16:19:14.157]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.157]    - tweaked: FALSE
[16:19:14.157]    - call: plan(strategy)
[16:19:14.162] plan(): nbrOfWorkers() = 2
[16:19:14.153] MulticoreFuture:
[16:19:14.153] Label: ‘future_vapply-1’
[16:19:14.153] Expression:
[16:19:14.153] {
[16:19:14.153]     do.call(function(...) {
[16:19:14.153]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.153]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.153]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.153]             on.exit(options(oopts), add = TRUE)
[16:19:14.153]         }
[16:19:14.153]         {
[16:19:14.153]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.153]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.153]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.153]             })
[16:19:14.153]         }
[16:19:14.153]     }, args = future.call.arguments)
[16:19:14.153] }
[16:19:14.153] Lazy evaluation: FALSE
[16:19:14.153] Asynchronous evaluation: TRUE
[16:19:14.153] Local evaluation: TRUE
[16:19:14.153] Environment: R_GlobalEnv
[16:19:14.153] Capture standard output: TRUE
[16:19:14.153] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.153] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.153] Packages: 1 packages (‘future.apply’)
[16:19:14.153] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.153] Resolved: TRUE
[16:19:14.153] Value: <not collected>
[16:19:14.153] Conditions captured: <none>
[16:19:14.153] Early signaling: FALSE
[16:19:14.153] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.153] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.163] Chunk #1 of 2 ... DONE
[16:19:14.164] Chunk #2 of 2 ...
[16:19:14.164]  - Finding globals in 'X' for chunk #2 ...
[16:19:14.164] getGlobalsAndPackages() ...
[16:19:14.164] Searching for globals...
[16:19:14.165] 
[16:19:14.165] Searching for globals ... DONE
[16:19:14.165] - globals: [0] <none>
[16:19:14.165] getGlobalsAndPackages() ... DONE
[16:19:14.165]    + additional globals found: [n=0] 
[16:19:14.165]    + additional namespaces needed: [n=0] 
[16:19:14.165]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:14.165]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.166]  - seeds: <none>
[16:19:14.166]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.166] getGlobalsAndPackages() ...
[16:19:14.166] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.166] Resolving globals: FALSE
[16:19:14.166] Tweak future expression to call with '...' arguments ...
[16:19:14.167] {
[16:19:14.167]     do.call(function(...) {
[16:19:14.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.167]             on.exit(options(oopts), add = TRUE)
[16:19:14.167]         }
[16:19:14.167]         {
[16:19:14.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.167]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.167]             })
[16:19:14.167]         }
[16:19:14.167]     }, args = future.call.arguments)
[16:19:14.167] }
[16:19:14.167] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.168] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.168] - packages: [1] ‘future.apply’
[16:19:14.172] getGlobalsAndPackages() ... DONE
[16:19:14.173] run() for ‘Future’ ...
[16:19:14.173] - state: ‘created’
[16:19:14.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.180] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.180]   - Field: ‘label’
[16:19:14.181]   - Field: ‘local’
[16:19:14.181]   - Field: ‘owner’
[16:19:14.181]   - Field: ‘envir’
[16:19:14.181]   - Field: ‘workers’
[16:19:14.182]   - Field: ‘packages’
[16:19:14.182]   - Field: ‘gc’
[16:19:14.182]   - Field: ‘job’
[16:19:14.182]   - Field: ‘conditions’
[16:19:14.183]   - Field: ‘expr’
[16:19:14.183]   - Field: ‘uuid’
[16:19:14.183]   - Field: ‘seed’
[16:19:14.183]   - Field: ‘version’
[16:19:14.183]   - Field: ‘result’
[16:19:14.184]   - Field: ‘asynchronous’
[16:19:14.184]   - Field: ‘calls’
[16:19:14.184]   - Field: ‘globals’
[16:19:14.184]   - Field: ‘stdout’
[16:19:14.184]   - Field: ‘earlySignal’
[16:19:14.185]   - Field: ‘lazy’
[16:19:14.185]   - Field: ‘state’
[16:19:14.185] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.185] - Launch lazy future ...
[16:19:14.186] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:14.186] Packages needed by future strategies (n = 0): <none>
[16:19:14.187] {
[16:19:14.187]     {
[16:19:14.187]         {
[16:19:14.187]             ...future.startTime <- base::Sys.time()
[16:19:14.187]             {
[16:19:14.187]                 {
[16:19:14.187]                   {
[16:19:14.187]                     {
[16:19:14.187]                       {
[16:19:14.187]                         base::local({
[16:19:14.187]                           has_future <- base::requireNamespace("future", 
[16:19:14.187]                             quietly = TRUE)
[16:19:14.187]                           if (has_future) {
[16:19:14.187]                             ns <- base::getNamespace("future")
[16:19:14.187]                             version <- ns[[".package"]][["version"]]
[16:19:14.187]                             if (is.null(version)) 
[16:19:14.187]                               version <- utils::packageVersion("future")
[16:19:14.187]                           }
[16:19:14.187]                           else {
[16:19:14.187]                             version <- NULL
[16:19:14.187]                           }
[16:19:14.187]                           if (!has_future || version < "1.8.0") {
[16:19:14.187]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.187]                               "", base::R.version$version.string), 
[16:19:14.187]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.187]                                 base::R.version$platform, 8 * 
[16:19:14.187]                                   base::.Machine$sizeof.pointer), 
[16:19:14.187]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.187]                                 "release", "version")], collapse = " "), 
[16:19:14.187]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.187]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.187]                               info)
[16:19:14.187]                             info <- base::paste(info, collapse = "; ")
[16:19:14.187]                             if (!has_future) {
[16:19:14.187]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.187]                                 info)
[16:19:14.187]                             }
[16:19:14.187]                             else {
[16:19:14.187]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.187]                                 info, version)
[16:19:14.187]                             }
[16:19:14.187]                             base::stop(msg)
[16:19:14.187]                           }
[16:19:14.187]                         })
[16:19:14.187]                       }
[16:19:14.187]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.187]                       base::options(mc.cores = 1L)
[16:19:14.187]                     }
[16:19:14.187]                     base::local({
[16:19:14.187]                       for (pkg in "future.apply") {
[16:19:14.187]                         base::loadNamespace(pkg)
[16:19:14.187]                         base::library(pkg, character.only = TRUE)
[16:19:14.187]                       }
[16:19:14.187]                     })
[16:19:14.187]                   }
[16:19:14.187]                   ...future.strategy.old <- future::plan("list")
[16:19:14.187]                   options(future.plan = NULL)
[16:19:14.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.187]                 }
[16:19:14.187]                 ...future.workdir <- getwd()
[16:19:14.187]             }
[16:19:14.187]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.187]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.187]         }
[16:19:14.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.187]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.187]             base::names(...future.oldOptions))
[16:19:14.187]     }
[16:19:14.187]     if (FALSE) {
[16:19:14.187]     }
[16:19:14.187]     else {
[16:19:14.187]         if (TRUE) {
[16:19:14.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.187]                 open = "w")
[16:19:14.187]         }
[16:19:14.187]         else {
[16:19:14.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.187]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.187]         }
[16:19:14.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.187]             base::sink(type = "output", split = FALSE)
[16:19:14.187]             base::close(...future.stdout)
[16:19:14.187]         }, add = TRUE)
[16:19:14.187]     }
[16:19:14.187]     ...future.frame <- base::sys.nframe()
[16:19:14.187]     ...future.conditions <- base::list()
[16:19:14.187]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.187]     if (FALSE) {
[16:19:14.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.187]     }
[16:19:14.187]     ...future.result <- base::tryCatch({
[16:19:14.187]         base::withCallingHandlers({
[16:19:14.187]             ...future.value <- base::withVisible(base::local({
[16:19:14.187]                 withCallingHandlers({
[16:19:14.187]                   {
[16:19:14.187]                     do.call(function(...) {
[16:19:14.187]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.187]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.187]                         ...future.globals.maxSize)) {
[16:19:14.187]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.187]                         on.exit(options(oopts), add = TRUE)
[16:19:14.187]                       }
[16:19:14.187]                       {
[16:19:14.187]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.187]                           FUN = function(jj) {
[16:19:14.187]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.187]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.187]                           })
[16:19:14.187]                       }
[16:19:14.187]                     }, args = future.call.arguments)
[16:19:14.187]                   }
[16:19:14.187]                 }, immediateCondition = function(cond) {
[16:19:14.187]                   save_rds <- function (object, pathname, ...) 
[16:19:14.187]                   {
[16:19:14.187]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.187]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.187]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.187]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.187]                         fi_tmp[["mtime"]])
[16:19:14.187]                     }
[16:19:14.187]                     tryCatch({
[16:19:14.187]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.187]                     }, error = function(ex) {
[16:19:14.187]                       msg <- conditionMessage(ex)
[16:19:14.187]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.187]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.187]                         fi_tmp[["mtime"]], msg)
[16:19:14.187]                       ex$message <- msg
[16:19:14.187]                       stop(ex)
[16:19:14.187]                     })
[16:19:14.187]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.187]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.187]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.187]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.187]                       fi <- file.info(pathname)
[16:19:14.187]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.187]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.187]                         fi[["size"]], fi[["mtime"]])
[16:19:14.187]                       stop(msg)
[16:19:14.187]                     }
[16:19:14.187]                     invisible(pathname)
[16:19:14.187]                   }
[16:19:14.187]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.187]                     rootPath = tempdir()) 
[16:19:14.187]                   {
[16:19:14.187]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.187]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.187]                       tmpdir = path, fileext = ".rds")
[16:19:14.187]                     save_rds(obj, file)
[16:19:14.187]                   }
[16:19:14.187]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.187]                   {
[16:19:14.187]                     inherits <- base::inherits
[16:19:14.187]                     invokeRestart <- base::invokeRestart
[16:19:14.187]                     is.null <- base::is.null
[16:19:14.187]                     muffled <- FALSE
[16:19:14.187]                     if (inherits(cond, "message")) {
[16:19:14.187]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.187]                       if (muffled) 
[16:19:14.187]                         invokeRestart("muffleMessage")
[16:19:14.187]                     }
[16:19:14.187]                     else if (inherits(cond, "warning")) {
[16:19:14.187]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.187]                       if (muffled) 
[16:19:14.187]                         invokeRestart("muffleWarning")
[16:19:14.187]                     }
[16:19:14.187]                     else if (inherits(cond, "condition")) {
[16:19:14.187]                       if (!is.null(pattern)) {
[16:19:14.187]                         computeRestarts <- base::computeRestarts
[16:19:14.187]                         grepl <- base::grepl
[16:19:14.187]                         restarts <- computeRestarts(cond)
[16:19:14.187]                         for (restart in restarts) {
[16:19:14.187]                           name <- restart$name
[16:19:14.187]                           if (is.null(name)) 
[16:19:14.187]                             next
[16:19:14.187]                           if (!grepl(pattern, name)) 
[16:19:14.187]                             next
[16:19:14.187]                           invokeRestart(restart)
[16:19:14.187]                           muffled <- TRUE
[16:19:14.187]                           break
[16:19:14.187]                         }
[16:19:14.187]                       }
[16:19:14.187]                     }
[16:19:14.187]                     invisible(muffled)
[16:19:14.187]                   }
[16:19:14.187]                   muffleCondition(cond)
[16:19:14.187]                 })
[16:19:14.187]             }))
[16:19:14.187]             future::FutureResult(value = ...future.value$value, 
[16:19:14.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.187]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.187]                     ...future.globalenv.names))
[16:19:14.187]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.187]         }, condition = base::local({
[16:19:14.187]             c <- base::c
[16:19:14.187]             inherits <- base::inherits
[16:19:14.187]             invokeRestart <- base::invokeRestart
[16:19:14.187]             length <- base::length
[16:19:14.187]             list <- base::list
[16:19:14.187]             seq.int <- base::seq.int
[16:19:14.187]             signalCondition <- base::signalCondition
[16:19:14.187]             sys.calls <- base::sys.calls
[16:19:14.187]             `[[` <- base::`[[`
[16:19:14.187]             `+` <- base::`+`
[16:19:14.187]             `<<-` <- base::`<<-`
[16:19:14.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.187]                   3L)]
[16:19:14.187]             }
[16:19:14.187]             function(cond) {
[16:19:14.187]                 is_error <- inherits(cond, "error")
[16:19:14.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.187]                   NULL)
[16:19:14.187]                 if (is_error) {
[16:19:14.187]                   sessionInformation <- function() {
[16:19:14.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.187]                       search = base::search(), system = base::Sys.info())
[16:19:14.187]                   }
[16:19:14.187]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.187]                     cond$call), session = sessionInformation(), 
[16:19:14.187]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.187]                   signalCondition(cond)
[16:19:14.187]                 }
[16:19:14.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.187]                 "immediateCondition"))) {
[16:19:14.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.187]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.187]                   if (TRUE && !signal) {
[16:19:14.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.187]                     {
[16:19:14.187]                       inherits <- base::inherits
[16:19:14.187]                       invokeRestart <- base::invokeRestart
[16:19:14.187]                       is.null <- base::is.null
[16:19:14.187]                       muffled <- FALSE
[16:19:14.187]                       if (inherits(cond, "message")) {
[16:19:14.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.187]                         if (muffled) 
[16:19:14.187]                           invokeRestart("muffleMessage")
[16:19:14.187]                       }
[16:19:14.187]                       else if (inherits(cond, "warning")) {
[16:19:14.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.187]                         if (muffled) 
[16:19:14.187]                           invokeRestart("muffleWarning")
[16:19:14.187]                       }
[16:19:14.187]                       else if (inherits(cond, "condition")) {
[16:19:14.187]                         if (!is.null(pattern)) {
[16:19:14.187]                           computeRestarts <- base::computeRestarts
[16:19:14.187]                           grepl <- base::grepl
[16:19:14.187]                           restarts <- computeRestarts(cond)
[16:19:14.187]                           for (restart in restarts) {
[16:19:14.187]                             name <- restart$name
[16:19:14.187]                             if (is.null(name)) 
[16:19:14.187]                               next
[16:19:14.187]                             if (!grepl(pattern, name)) 
[16:19:14.187]                               next
[16:19:14.187]                             invokeRestart(restart)
[16:19:14.187]                             muffled <- TRUE
[16:19:14.187]                             break
[16:19:14.187]                           }
[16:19:14.187]                         }
[16:19:14.187]                       }
[16:19:14.187]                       invisible(muffled)
[16:19:14.187]                     }
[16:19:14.187]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.187]                   }
[16:19:14.187]                 }
[16:19:14.187]                 else {
[16:19:14.187]                   if (TRUE) {
[16:19:14.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.187]                     {
[16:19:14.187]                       inherits <- base::inherits
[16:19:14.187]                       invokeRestart <- base::invokeRestart
[16:19:14.187]                       is.null <- base::is.null
[16:19:14.187]                       muffled <- FALSE
[16:19:14.187]                       if (inherits(cond, "message")) {
[16:19:14.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.187]                         if (muffled) 
[16:19:14.187]                           invokeRestart("muffleMessage")
[16:19:14.187]                       }
[16:19:14.187]                       else if (inherits(cond, "warning")) {
[16:19:14.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.187]                         if (muffled) 
[16:19:14.187]                           invokeRestart("muffleWarning")
[16:19:14.187]                       }
[16:19:14.187]                       else if (inherits(cond, "condition")) {
[16:19:14.187]                         if (!is.null(pattern)) {
[16:19:14.187]                           computeRestarts <- base::computeRestarts
[16:19:14.187]                           grepl <- base::grepl
[16:19:14.187]                           restarts <- computeRestarts(cond)
[16:19:14.187]                           for (restart in restarts) {
[16:19:14.187]                             name <- restart$name
[16:19:14.187]                             if (is.null(name)) 
[16:19:14.187]                               next
[16:19:14.187]                             if (!grepl(pattern, name)) 
[16:19:14.187]                               next
[16:19:14.187]                             invokeRestart(restart)
[16:19:14.187]                             muffled <- TRUE
[16:19:14.187]                             break
[16:19:14.187]                           }
[16:19:14.187]                         }
[16:19:14.187]                       }
[16:19:14.187]                       invisible(muffled)
[16:19:14.187]                     }
[16:19:14.187]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.187]                   }
[16:19:14.187]                 }
[16:19:14.187]             }
[16:19:14.187]         }))
[16:19:14.187]     }, error = function(ex) {
[16:19:14.187]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.187]                 ...future.rng), started = ...future.startTime, 
[16:19:14.187]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.187]             version = "1.8"), class = "FutureResult")
[16:19:14.187]     }, finally = {
[16:19:14.187]         if (!identical(...future.workdir, getwd())) 
[16:19:14.187]             setwd(...future.workdir)
[16:19:14.187]         {
[16:19:14.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.187]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.187]             }
[16:19:14.187]             base::options(...future.oldOptions)
[16:19:14.187]             if (.Platform$OS.type == "windows") {
[16:19:14.187]                 old_names <- names(...future.oldEnvVars)
[16:19:14.187]                 envs <- base::Sys.getenv()
[16:19:14.187]                 names <- names(envs)
[16:19:14.187]                 common <- intersect(names, old_names)
[16:19:14.187]                 added <- setdiff(names, old_names)
[16:19:14.187]                 removed <- setdiff(old_names, names)
[16:19:14.187]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.187]                   envs[common]]
[16:19:14.187]                 NAMES <- toupper(changed)
[16:19:14.187]                 args <- list()
[16:19:14.187]                 for (kk in seq_along(NAMES)) {
[16:19:14.187]                   name <- changed[[kk]]
[16:19:14.187]                   NAME <- NAMES[[kk]]
[16:19:14.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.187]                     next
[16:19:14.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.187]                 }
[16:19:14.187]                 NAMES <- toupper(added)
[16:19:14.187]                 for (kk in seq_along(NAMES)) {
[16:19:14.187]                   name <- added[[kk]]
[16:19:14.187]                   NAME <- NAMES[[kk]]
[16:19:14.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.187]                     next
[16:19:14.187]                   args[[name]] <- ""
[16:19:14.187]                 }
[16:19:14.187]                 NAMES <- toupper(removed)
[16:19:14.187]                 for (kk in seq_along(NAMES)) {
[16:19:14.187]                   name <- removed[[kk]]
[16:19:14.187]                   NAME <- NAMES[[kk]]
[16:19:14.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.187]                     next
[16:19:14.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.187]                 }
[16:19:14.187]                 if (length(args) > 0) 
[16:19:14.187]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.187]             }
[16:19:14.187]             else {
[16:19:14.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.187]             }
[16:19:14.187]             {
[16:19:14.187]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.187]                   0L) {
[16:19:14.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.187]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.187]                   base::options(opts)
[16:19:14.187]                 }
[16:19:14.187]                 {
[16:19:14.187]                   {
[16:19:14.187]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.187]                     NULL
[16:19:14.187]                   }
[16:19:14.187]                   options(future.plan = NULL)
[16:19:14.187]                   if (is.na(NA_character_)) 
[16:19:14.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.187]                     .init = FALSE)
[16:19:14.187]                 }
[16:19:14.187]             }
[16:19:14.187]         }
[16:19:14.187]     })
[16:19:14.187]     if (TRUE) {
[16:19:14.187]         base::sink(type = "output", split = FALSE)
[16:19:14.187]         if (TRUE) {
[16:19:14.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.187]         }
[16:19:14.187]         else {
[16:19:14.187]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.187]         }
[16:19:14.187]         base::close(...future.stdout)
[16:19:14.187]         ...future.stdout <- NULL
[16:19:14.187]     }
[16:19:14.187]     ...future.result$conditions <- ...future.conditions
[16:19:14.187]     ...future.result$finished <- base::Sys.time()
[16:19:14.187]     ...future.result
[16:19:14.187] }
[16:19:14.190] assign_globals() ...
[16:19:14.190] List of 11
[16:19:14.190]  $ ...future.FUN            :function (x, ...)  
[16:19:14.190]  $ x_FUN                    :function (x)  
[16:19:14.190]  $ times                    : int 4
[16:19:14.190]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.190]  $ stop_if_not              :function (...)  
[16:19:14.190]  $ dim                      : int [1:2] 2 2
[16:19:14.190]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.190]  $ future.call.arguments    : list()
[16:19:14.190]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.190]  $ ...future.elements_ii    :List of 5
[16:19:14.190]   ..$ : int 6
[16:19:14.190]   ..$ : int 7
[16:19:14.190]   ..$ : int 8
[16:19:14.190]   ..$ : int 9
[16:19:14.190]   ..$ : int 10
[16:19:14.190]  $ ...future.seeds_ii       : NULL
[16:19:14.190]  $ ...future.globals.maxSize: NULL
[16:19:14.190]  - attr(*, "where")=List of 11
[16:19:14.190]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.190]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.190]  - attr(*, "resolved")= logi FALSE
[16:19:14.190]  - attr(*, "total_size")= num 97304
[16:19:14.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.190]  - attr(*, "already-done")= logi TRUE
[16:19:14.202] - copied ‘...future.FUN’ to environment
[16:19:14.202] - reassign environment for ‘x_FUN’
[16:19:14.202] - copied ‘x_FUN’ to environment
[16:19:14.202] - copied ‘times’ to environment
[16:19:14.202] - copied ‘stopf’ to environment
[16:19:14.202] - copied ‘stop_if_not’ to environment
[16:19:14.202] - copied ‘dim’ to environment
[16:19:14.202] - copied ‘valid_types’ to environment
[16:19:14.202] - copied ‘future.call.arguments’ to environment
[16:19:14.202] - copied ‘...future.elements_ii’ to environment
[16:19:14.203] - copied ‘...future.seeds_ii’ to environment
[16:19:14.203] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.203] assign_globals() ... done
[16:19:14.203] requestCore(): workers = 2
[16:19:14.205] MulticoreFuture started
[16:19:14.206] - Launch lazy future ... done
[16:19:14.206] run() for ‘MulticoreFuture’ ... done
[16:19:14.206] Created future:
[16:19:14.207] plan(): Setting new future strategy stack:
[16:19:14.207] List of future strategies:
[16:19:14.207] 1. sequential:
[16:19:14.207]    - args: function (..., envir = parent.frame())
[16:19:14.207]    - tweaked: FALSE
[16:19:14.207]    - call: NULL
[16:19:14.208] plan(): nbrOfWorkers() = 1
[16:19:14.210] plan(): Setting new future strategy stack:
[16:19:14.210] List of future strategies:
[16:19:14.210] 1. multicore:
[16:19:14.210]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.210]    - tweaked: FALSE
[16:19:14.210]    - call: plan(strategy)
[16:19:14.206] MulticoreFuture:
[16:19:14.206] Label: ‘future_vapply-2’
[16:19:14.206] Expression:
[16:19:14.206] {
[16:19:14.206]     do.call(function(...) {
[16:19:14.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.206]             on.exit(options(oopts), add = TRUE)
[16:19:14.206]         }
[16:19:14.206]         {
[16:19:14.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.206]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.206]             })
[16:19:14.206]         }
[16:19:14.206]     }, args = future.call.arguments)
[16:19:14.206] }
[16:19:14.206] Lazy evaluation: FALSE
[16:19:14.206] Asynchronous evaluation: TRUE
[16:19:14.206] Local evaluation: TRUE
[16:19:14.206] Environment: R_GlobalEnv
[16:19:14.206] Capture standard output: TRUE
[16:19:14.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.206] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.206] Packages: 1 packages (‘future.apply’)
[16:19:14.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.206] Resolved: FALSE
[16:19:14.206] Value: <not collected>
[16:19:14.206] Conditions captured: <none>
[16:19:14.206] Early signaling: FALSE
[16:19:14.206] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.206] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.219] Chunk #2 of 2 ... DONE
[16:19:14.220] Launching 2 futures (chunks) ... DONE
[16:19:14.220] Resolving 2 futures (chunks) ...
[16:19:14.220] resolve() on list ...
[16:19:14.220]  recursive: 0
[16:19:14.220]  length: 2
[16:19:14.221] 
[16:19:14.221] plan(): nbrOfWorkers() = 2
[16:19:14.223] Future #1
[16:19:14.224] result() for MulticoreFuture ...
[16:19:14.225] result() for MulticoreFuture ...
[16:19:14.225] result() for MulticoreFuture ... done
[16:19:14.225] result() for MulticoreFuture ... done
[16:19:14.226] result() for MulticoreFuture ...
[16:19:14.226] result() for MulticoreFuture ... done
[16:19:14.226] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:14.227] - nx: 2
[16:19:14.227] - relay: TRUE
[16:19:14.227] - stdout: TRUE
[16:19:14.228] - signal: TRUE
[16:19:14.228] - resignal: FALSE
[16:19:14.228] - force: TRUE
[16:19:14.228] - relayed: [n=2] FALSE, FALSE
[16:19:14.229] - queued futures: [n=2] FALSE, FALSE
[16:19:14.229]  - until=1
[16:19:14.229]  - relaying element #1
[16:19:14.229] result() for MulticoreFuture ...
[16:19:14.230] result() for MulticoreFuture ... done
[16:19:14.230] result() for MulticoreFuture ...
[16:19:14.230] result() for MulticoreFuture ... done
[16:19:14.230] result() for MulticoreFuture ...
[16:19:14.231] result() for MulticoreFuture ... done
[16:19:14.231] result() for MulticoreFuture ...
[16:19:14.231] result() for MulticoreFuture ... done
[16:19:14.231] - relayed: [n=2] TRUE, FALSE
[16:19:14.232] - queued futures: [n=2] TRUE, FALSE
[16:19:14.232] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:14.232]  length: 1 (resolved future 1)
[16:19:14.232] Future #2
[16:19:14.233] result() for MulticoreFuture ...
[16:19:14.234] result() for MulticoreFuture ...
[16:19:14.234] result() for MulticoreFuture ... done
[16:19:14.234] result() for MulticoreFuture ... done
[16:19:14.234] result() for MulticoreFuture ...
[16:19:14.235] result() for MulticoreFuture ... done
[16:19:14.235] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:14.235] - nx: 2
[16:19:14.235] - relay: TRUE
[16:19:14.235] - stdout: TRUE
[16:19:14.235] - signal: TRUE
[16:19:14.236] - resignal: FALSE
[16:19:14.236] - force: TRUE
[16:19:14.236] - relayed: [n=2] TRUE, FALSE
[16:19:14.236] - queued futures: [n=2] TRUE, FALSE
[16:19:14.236]  - until=2
[16:19:14.236]  - relaying element #2
[16:19:14.236] result() for MulticoreFuture ...
[16:19:14.237] result() for MulticoreFuture ... done
[16:19:14.237] result() for MulticoreFuture ...
[16:19:14.237] result() for MulticoreFuture ... done
[16:19:14.237] result() for MulticoreFuture ...
[16:19:14.237] result() for MulticoreFuture ... done
[16:19:14.237] result() for MulticoreFuture ...
[16:19:14.237] result() for MulticoreFuture ... done
[16:19:14.237] - relayed: [n=2] TRUE, TRUE
[16:19:14.238] - queued futures: [n=2] TRUE, TRUE
[16:19:14.238] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:14.238]  length: 0 (resolved future 2)
[16:19:14.238] Relaying remaining futures
[16:19:14.238] signalConditionsASAP(NULL, pos=0) ...
[16:19:14.238] - nx: 2
[16:19:14.238] - relay: TRUE
[16:19:14.238] - stdout: TRUE
[16:19:14.238] - signal: TRUE
[16:19:14.239] - resignal: FALSE
[16:19:14.239] - force: TRUE
[16:19:14.239] - relayed: [n=2] TRUE, TRUE
[16:19:14.239] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:14.239] - relayed: [n=2] TRUE, TRUE
[16:19:14.239] - queued futures: [n=2] TRUE, TRUE
[16:19:14.239] signalConditionsASAP(NULL, pos=0) ... done
[16:19:14.239] resolve() on list ... DONE
[16:19:14.239] result() for MulticoreFuture ...
[16:19:14.240] result() for MulticoreFuture ... done
[16:19:14.240] result() for MulticoreFuture ...
[16:19:14.240] result() for MulticoreFuture ... done
[16:19:14.240] result() for MulticoreFuture ...
[16:19:14.240] result() for MulticoreFuture ... done
[16:19:14.240] result() for MulticoreFuture ...
[16:19:14.240] result() for MulticoreFuture ... done
[16:19:14.240]  - Number of value chunks collected: 2
[16:19:14.241] Resolving 2 futures (chunks) ... DONE
[16:19:14.241] Reducing values from 2 chunks ...
[16:19:14.241]  - Number of values collected after concatenation: 10
[16:19:14.241]  - Number of values expected: 10
[16:19:14.241] Reducing values from 2 chunks ... DONE
[16:19:14.241] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:19:14.243] future_lapply() ...
[16:19:14.250] Number of chunks: 2
[16:19:14.250] getGlobalsAndPackagesXApply() ...
[16:19:14.250]  - future.globals: TRUE
[16:19:14.250] getGlobalsAndPackages() ...
[16:19:14.250] Searching for globals...
[16:19:14.256] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:19:14.256] Searching for globals ... DONE
[16:19:14.256] Resolving globals: FALSE
[16:19:14.257] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:19:14.258] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:14.258] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.258] - packages: [1] ‘future.apply’
[16:19:14.258] getGlobalsAndPackages() ... DONE
[16:19:14.258]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.259]  - needed namespaces: [n=1] ‘future.apply’
[16:19:14.259] Finding globals ... DONE
[16:19:14.259]  - use_args: TRUE
[16:19:14.259]  - Getting '...' globals ...
[16:19:14.259] resolve() on list ...
[16:19:14.259]  recursive: 0
[16:19:14.260]  length: 1
[16:19:14.260]  elements: ‘...’
[16:19:14.260]  length: 0 (resolved future 1)
[16:19:14.260] resolve() on list ... DONE
[16:19:14.260]    - '...' content: [n=0] 
[16:19:14.260] List of 1
[16:19:14.260]  $ ...: list()
[16:19:14.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.260]  - attr(*, "where")=List of 1
[16:19:14.260]   ..$ ...:<environment: 0x56199da44928> 
[16:19:14.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.260]  - attr(*, "resolved")= logi TRUE
[16:19:14.260]  - attr(*, "total_size")= num NA
[16:19:14.263]  - Getting '...' globals ... DONE
[16:19:14.263] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:14.263] List of 8
[16:19:14.263]  $ ...future.FUN:function (x, ...)  
[16:19:14.263]  $ x_FUN        :function (x)  
[16:19:14.263]  $ times        : int 4
[16:19:14.263]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.263]  $ stop_if_not  :function (...)  
[16:19:14.263]  $ dim          : int [1:2] 2 2
[16:19:14.263]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:14.263]  $ ...          : list()
[16:19:14.263]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.263]  - attr(*, "where")=List of 8
[16:19:14.263]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:14.263]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:14.263]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:14.263]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:14.263]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:14.263]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:14.263]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:14.263]   ..$ ...          :<environment: 0x56199da44928> 
[16:19:14.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.263]  - attr(*, "resolved")= logi FALSE
[16:19:14.263]  - attr(*, "total_size")= num 105552
[16:19:14.269] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:14.269] getGlobalsAndPackagesXApply() ... DONE
[16:19:14.269] Number of futures (= number of chunks): 2
[16:19:14.269] Launching 2 futures (chunks) ...
[16:19:14.269] Chunk #1 of 2 ...
[16:19:14.269]  - Finding globals in 'X' for chunk #1 ...
[16:19:14.269] getGlobalsAndPackages() ...
[16:19:14.269] Searching for globals...
[16:19:14.270] 
[16:19:14.270] Searching for globals ... DONE
[16:19:14.270] - globals: [0] <none>
[16:19:14.270] getGlobalsAndPackages() ... DONE
[16:19:14.270]    + additional globals found: [n=0] 
[16:19:14.270]    + additional namespaces needed: [n=0] 
[16:19:14.270]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:14.270]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.270]  - seeds: <none>
[16:19:14.271]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.271] getGlobalsAndPackages() ...
[16:19:14.271] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.271] Resolving globals: FALSE
[16:19:14.271] Tweak future expression to call with '...' arguments ...
[16:19:14.271] {
[16:19:14.271]     do.call(function(...) {
[16:19:14.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.271]             on.exit(options(oopts), add = TRUE)
[16:19:14.271]         }
[16:19:14.271]         {
[16:19:14.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.271]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.271]             })
[16:19:14.271]         }
[16:19:14.271]     }, args = future.call.arguments)
[16:19:14.271] }
[16:19:14.271] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.272] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.272] - packages: [1] ‘future.apply’
[16:19:14.272] getGlobalsAndPackages() ... DONE
[16:19:14.272] run() for ‘Future’ ...
[16:19:14.273] - state: ‘created’
[16:19:14.273] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.276] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.277]   - Field: ‘label’
[16:19:14.277]   - Field: ‘local’
[16:19:14.277]   - Field: ‘owner’
[16:19:14.277]   - Field: ‘envir’
[16:19:14.277]   - Field: ‘workers’
[16:19:14.277]   - Field: ‘packages’
[16:19:14.279]   - Field: ‘gc’
[16:19:14.279]   - Field: ‘job’
[16:19:14.279]   - Field: ‘conditions’
[16:19:14.279]   - Field: ‘expr’
[16:19:14.279]   - Field: ‘uuid’
[16:19:14.279]   - Field: ‘seed’
[16:19:14.279]   - Field: ‘version’
[16:19:14.279]   - Field: ‘result’
[16:19:14.279]   - Field: ‘asynchronous’
[16:19:14.280]   - Field: ‘calls’
[16:19:14.280]   - Field: ‘globals’
[16:19:14.280]   - Field: ‘stdout’
[16:19:14.280]   - Field: ‘earlySignal’
[16:19:14.280]   - Field: ‘lazy’
[16:19:14.280]   - Field: ‘state’
[16:19:14.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.280] - Launch lazy future ...
[16:19:14.281] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:14.281] Packages needed by future strategies (n = 0): <none>
[16:19:14.281] {
[16:19:14.281]     {
[16:19:14.281]         {
[16:19:14.281]             ...future.startTime <- base::Sys.time()
[16:19:14.281]             {
[16:19:14.281]                 {
[16:19:14.281]                   {
[16:19:14.281]                     {
[16:19:14.281]                       {
[16:19:14.281]                         base::local({
[16:19:14.281]                           has_future <- base::requireNamespace("future", 
[16:19:14.281]                             quietly = TRUE)
[16:19:14.281]                           if (has_future) {
[16:19:14.281]                             ns <- base::getNamespace("future")
[16:19:14.281]                             version <- ns[[".package"]][["version"]]
[16:19:14.281]                             if (is.null(version)) 
[16:19:14.281]                               version <- utils::packageVersion("future")
[16:19:14.281]                           }
[16:19:14.281]                           else {
[16:19:14.281]                             version <- NULL
[16:19:14.281]                           }
[16:19:14.281]                           if (!has_future || version < "1.8.0") {
[16:19:14.281]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.281]                               "", base::R.version$version.string), 
[16:19:14.281]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.281]                                 base::R.version$platform, 8 * 
[16:19:14.281]                                   base::.Machine$sizeof.pointer), 
[16:19:14.281]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.281]                                 "release", "version")], collapse = " "), 
[16:19:14.281]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.281]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.281]                               info)
[16:19:14.281]                             info <- base::paste(info, collapse = "; ")
[16:19:14.281]                             if (!has_future) {
[16:19:14.281]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.281]                                 info)
[16:19:14.281]                             }
[16:19:14.281]                             else {
[16:19:14.281]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.281]                                 info, version)
[16:19:14.281]                             }
[16:19:14.281]                             base::stop(msg)
[16:19:14.281]                           }
[16:19:14.281]                         })
[16:19:14.281]                       }
[16:19:14.281]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.281]                       base::options(mc.cores = 1L)
[16:19:14.281]                     }
[16:19:14.281]                     base::local({
[16:19:14.281]                       for (pkg in "future.apply") {
[16:19:14.281]                         base::loadNamespace(pkg)
[16:19:14.281]                         base::library(pkg, character.only = TRUE)
[16:19:14.281]                       }
[16:19:14.281]                     })
[16:19:14.281]                   }
[16:19:14.281]                   ...future.strategy.old <- future::plan("list")
[16:19:14.281]                   options(future.plan = NULL)
[16:19:14.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.281]                 }
[16:19:14.281]                 ...future.workdir <- getwd()
[16:19:14.281]             }
[16:19:14.281]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.281]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.281]         }
[16:19:14.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.281]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.281]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.281]             base::names(...future.oldOptions))
[16:19:14.281]     }
[16:19:14.281]     if (FALSE) {
[16:19:14.281]     }
[16:19:14.281]     else {
[16:19:14.281]         if (TRUE) {
[16:19:14.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.281]                 open = "w")
[16:19:14.281]         }
[16:19:14.281]         else {
[16:19:14.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.281]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.281]         }
[16:19:14.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.281]             base::sink(type = "output", split = FALSE)
[16:19:14.281]             base::close(...future.stdout)
[16:19:14.281]         }, add = TRUE)
[16:19:14.281]     }
[16:19:14.281]     ...future.frame <- base::sys.nframe()
[16:19:14.281]     ...future.conditions <- base::list()
[16:19:14.281]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.281]     if (FALSE) {
[16:19:14.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.281]     }
[16:19:14.281]     ...future.result <- base::tryCatch({
[16:19:14.281]         base::withCallingHandlers({
[16:19:14.281]             ...future.value <- base::withVisible(base::local({
[16:19:14.281]                 withCallingHandlers({
[16:19:14.281]                   {
[16:19:14.281]                     do.call(function(...) {
[16:19:14.281]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.281]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.281]                         ...future.globals.maxSize)) {
[16:19:14.281]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.281]                         on.exit(options(oopts), add = TRUE)
[16:19:14.281]                       }
[16:19:14.281]                       {
[16:19:14.281]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.281]                           FUN = function(jj) {
[16:19:14.281]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.281]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.281]                           })
[16:19:14.281]                       }
[16:19:14.281]                     }, args = future.call.arguments)
[16:19:14.281]                   }
[16:19:14.281]                 }, immediateCondition = function(cond) {
[16:19:14.281]                   save_rds <- function (object, pathname, ...) 
[16:19:14.281]                   {
[16:19:14.281]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.281]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.281]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.281]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.281]                         fi_tmp[["mtime"]])
[16:19:14.281]                     }
[16:19:14.281]                     tryCatch({
[16:19:14.281]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.281]                     }, error = function(ex) {
[16:19:14.281]                       msg <- conditionMessage(ex)
[16:19:14.281]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.281]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.281]                         fi_tmp[["mtime"]], msg)
[16:19:14.281]                       ex$message <- msg
[16:19:14.281]                       stop(ex)
[16:19:14.281]                     })
[16:19:14.281]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.281]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.281]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.281]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.281]                       fi <- file.info(pathname)
[16:19:14.281]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.281]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.281]                         fi[["size"]], fi[["mtime"]])
[16:19:14.281]                       stop(msg)
[16:19:14.281]                     }
[16:19:14.281]                     invisible(pathname)
[16:19:14.281]                   }
[16:19:14.281]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.281]                     rootPath = tempdir()) 
[16:19:14.281]                   {
[16:19:14.281]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.281]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.281]                       tmpdir = path, fileext = ".rds")
[16:19:14.281]                     save_rds(obj, file)
[16:19:14.281]                   }
[16:19:14.281]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.281]                   {
[16:19:14.281]                     inherits <- base::inherits
[16:19:14.281]                     invokeRestart <- base::invokeRestart
[16:19:14.281]                     is.null <- base::is.null
[16:19:14.281]                     muffled <- FALSE
[16:19:14.281]                     if (inherits(cond, "message")) {
[16:19:14.281]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.281]                       if (muffled) 
[16:19:14.281]                         invokeRestart("muffleMessage")
[16:19:14.281]                     }
[16:19:14.281]                     else if (inherits(cond, "warning")) {
[16:19:14.281]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.281]                       if (muffled) 
[16:19:14.281]                         invokeRestart("muffleWarning")
[16:19:14.281]                     }
[16:19:14.281]                     else if (inherits(cond, "condition")) {
[16:19:14.281]                       if (!is.null(pattern)) {
[16:19:14.281]                         computeRestarts <- base::computeRestarts
[16:19:14.281]                         grepl <- base::grepl
[16:19:14.281]                         restarts <- computeRestarts(cond)
[16:19:14.281]                         for (restart in restarts) {
[16:19:14.281]                           name <- restart$name
[16:19:14.281]                           if (is.null(name)) 
[16:19:14.281]                             next
[16:19:14.281]                           if (!grepl(pattern, name)) 
[16:19:14.281]                             next
[16:19:14.281]                           invokeRestart(restart)
[16:19:14.281]                           muffled <- TRUE
[16:19:14.281]                           break
[16:19:14.281]                         }
[16:19:14.281]                       }
[16:19:14.281]                     }
[16:19:14.281]                     invisible(muffled)
[16:19:14.281]                   }
[16:19:14.281]                   muffleCondition(cond)
[16:19:14.281]                 })
[16:19:14.281]             }))
[16:19:14.281]             future::FutureResult(value = ...future.value$value, 
[16:19:14.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.281]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.281]                     ...future.globalenv.names))
[16:19:14.281]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.281]         }, condition = base::local({
[16:19:14.281]             c <- base::c
[16:19:14.281]             inherits <- base::inherits
[16:19:14.281]             invokeRestart <- base::invokeRestart
[16:19:14.281]             length <- base::length
[16:19:14.281]             list <- base::list
[16:19:14.281]             seq.int <- base::seq.int
[16:19:14.281]             signalCondition <- base::signalCondition
[16:19:14.281]             sys.calls <- base::sys.calls
[16:19:14.281]             `[[` <- base::`[[`
[16:19:14.281]             `+` <- base::`+`
[16:19:14.281]             `<<-` <- base::`<<-`
[16:19:14.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.281]                   3L)]
[16:19:14.281]             }
[16:19:14.281]             function(cond) {
[16:19:14.281]                 is_error <- inherits(cond, "error")
[16:19:14.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.281]                   NULL)
[16:19:14.281]                 if (is_error) {
[16:19:14.281]                   sessionInformation <- function() {
[16:19:14.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.281]                       search = base::search(), system = base::Sys.info())
[16:19:14.281]                   }
[16:19:14.281]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.281]                     cond$call), session = sessionInformation(), 
[16:19:14.281]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.281]                   signalCondition(cond)
[16:19:14.281]                 }
[16:19:14.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.281]                 "immediateCondition"))) {
[16:19:14.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.281]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.281]                   if (TRUE && !signal) {
[16:19:14.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.281]                     {
[16:19:14.281]                       inherits <- base::inherits
[16:19:14.281]                       invokeRestart <- base::invokeRestart
[16:19:14.281]                       is.null <- base::is.null
[16:19:14.281]                       muffled <- FALSE
[16:19:14.281]                       if (inherits(cond, "message")) {
[16:19:14.281]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.281]                         if (muffled) 
[16:19:14.281]                           invokeRestart("muffleMessage")
[16:19:14.281]                       }
[16:19:14.281]                       else if (inherits(cond, "warning")) {
[16:19:14.281]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.281]                         if (muffled) 
[16:19:14.281]                           invokeRestart("muffleWarning")
[16:19:14.281]                       }
[16:19:14.281]                       else if (inherits(cond, "condition")) {
[16:19:14.281]                         if (!is.null(pattern)) {
[16:19:14.281]                           computeRestarts <- base::computeRestarts
[16:19:14.281]                           grepl <- base::grepl
[16:19:14.281]                           restarts <- computeRestarts(cond)
[16:19:14.281]                           for (restart in restarts) {
[16:19:14.281]                             name <- restart$name
[16:19:14.281]                             if (is.null(name)) 
[16:19:14.281]                               next
[16:19:14.281]                             if (!grepl(pattern, name)) 
[16:19:14.281]                               next
[16:19:14.281]                             invokeRestart(restart)
[16:19:14.281]                             muffled <- TRUE
[16:19:14.281]                             break
[16:19:14.281]                           }
[16:19:14.281]                         }
[16:19:14.281]                       }
[16:19:14.281]                       invisible(muffled)
[16:19:14.281]                     }
[16:19:14.281]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.281]                   }
[16:19:14.281]                 }
[16:19:14.281]                 else {
[16:19:14.281]                   if (TRUE) {
[16:19:14.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.281]                     {
[16:19:14.281]                       inherits <- base::inherits
[16:19:14.281]                       invokeRestart <- base::invokeRestart
[16:19:14.281]                       is.null <- base::is.null
[16:19:14.281]                       muffled <- FALSE
[16:19:14.281]                       if (inherits(cond, "message")) {
[16:19:14.281]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.281]                         if (muffled) 
[16:19:14.281]                           invokeRestart("muffleMessage")
[16:19:14.281]                       }
[16:19:14.281]                       else if (inherits(cond, "warning")) {
[16:19:14.281]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.281]                         if (muffled) 
[16:19:14.281]                           invokeRestart("muffleWarning")
[16:19:14.281]                       }
[16:19:14.281]                       else if (inherits(cond, "condition")) {
[16:19:14.281]                         if (!is.null(pattern)) {
[16:19:14.281]                           computeRestarts <- base::computeRestarts
[16:19:14.281]                           grepl <- base::grepl
[16:19:14.281]                           restarts <- computeRestarts(cond)
[16:19:14.281]                           for (restart in restarts) {
[16:19:14.281]                             name <- restart$name
[16:19:14.281]                             if (is.null(name)) 
[16:19:14.281]                               next
[16:19:14.281]                             if (!grepl(pattern, name)) 
[16:19:14.281]                               next
[16:19:14.281]                             invokeRestart(restart)
[16:19:14.281]                             muffled <- TRUE
[16:19:14.281]                             break
[16:19:14.281]                           }
[16:19:14.281]                         }
[16:19:14.281]                       }
[16:19:14.281]                       invisible(muffled)
[16:19:14.281]                     }
[16:19:14.281]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.281]                   }
[16:19:14.281]                 }
[16:19:14.281]             }
[16:19:14.281]         }))
[16:19:14.281]     }, error = function(ex) {
[16:19:14.281]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.281]                 ...future.rng), started = ...future.startTime, 
[16:19:14.281]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.281]             version = "1.8"), class = "FutureResult")
[16:19:14.281]     }, finally = {
[16:19:14.281]         if (!identical(...future.workdir, getwd())) 
[16:19:14.281]             setwd(...future.workdir)
[16:19:14.281]         {
[16:19:14.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.281]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.281]             }
[16:19:14.281]             base::options(...future.oldOptions)
[16:19:14.281]             if (.Platform$OS.type == "windows") {
[16:19:14.281]                 old_names <- names(...future.oldEnvVars)
[16:19:14.281]                 envs <- base::Sys.getenv()
[16:19:14.281]                 names <- names(envs)
[16:19:14.281]                 common <- intersect(names, old_names)
[16:19:14.281]                 added <- setdiff(names, old_names)
[16:19:14.281]                 removed <- setdiff(old_names, names)
[16:19:14.281]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.281]                   envs[common]]
[16:19:14.281]                 NAMES <- toupper(changed)
[16:19:14.281]                 args <- list()
[16:19:14.281]                 for (kk in seq_along(NAMES)) {
[16:19:14.281]                   name <- changed[[kk]]
[16:19:14.281]                   NAME <- NAMES[[kk]]
[16:19:14.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.281]                     next
[16:19:14.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.281]                 }
[16:19:14.281]                 NAMES <- toupper(added)
[16:19:14.281]                 for (kk in seq_along(NAMES)) {
[16:19:14.281]                   name <- added[[kk]]
[16:19:14.281]                   NAME <- NAMES[[kk]]
[16:19:14.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.281]                     next
[16:19:14.281]                   args[[name]] <- ""
[16:19:14.281]                 }
[16:19:14.281]                 NAMES <- toupper(removed)
[16:19:14.281]                 for (kk in seq_along(NAMES)) {
[16:19:14.281]                   name <- removed[[kk]]
[16:19:14.281]                   NAME <- NAMES[[kk]]
[16:19:14.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.281]                     next
[16:19:14.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.281]                 }
[16:19:14.281]                 if (length(args) > 0) 
[16:19:14.281]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.281]             }
[16:19:14.281]             else {
[16:19:14.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.281]             }
[16:19:14.281]             {
[16:19:14.281]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.281]                   0L) {
[16:19:14.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.281]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.281]                   base::options(opts)
[16:19:14.281]                 }
[16:19:14.281]                 {
[16:19:14.281]                   {
[16:19:14.281]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.281]                     NULL
[16:19:14.281]                   }
[16:19:14.281]                   options(future.plan = NULL)
[16:19:14.281]                   if (is.na(NA_character_)) 
[16:19:14.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.281]                     .init = FALSE)
[16:19:14.281]                 }
[16:19:14.281]             }
[16:19:14.281]         }
[16:19:14.281]     })
[16:19:14.281]     if (TRUE) {
[16:19:14.281]         base::sink(type = "output", split = FALSE)
[16:19:14.281]         if (TRUE) {
[16:19:14.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.281]         }
[16:19:14.281]         else {
[16:19:14.281]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.281]         }
[16:19:14.281]         base::close(...future.stdout)
[16:19:14.281]         ...future.stdout <- NULL
[16:19:14.281]     }
[16:19:14.281]     ...future.result$conditions <- ...future.conditions
[16:19:14.281]     ...future.result$finished <- base::Sys.time()
[16:19:14.281]     ...future.result
[16:19:14.281] }
[16:19:14.284] assign_globals() ...
[16:19:14.284] List of 11
[16:19:14.284]  $ ...future.FUN            :function (x, ...)  
[16:19:14.284]  $ x_FUN                    :function (x)  
[16:19:14.284]  $ times                    : int 4
[16:19:14.284]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.284]  $ stop_if_not              :function (...)  
[16:19:14.284]  $ dim                      : int [1:2] 2 2
[16:19:14.284]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.284]  $ future.call.arguments    : list()
[16:19:14.284]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.284]  $ ...future.elements_ii    :List of 5
[16:19:14.284]   ..$ : int 1
[16:19:14.284]   ..$ : int 2
[16:19:14.284]   ..$ : int 3
[16:19:14.284]   ..$ : int 4
[16:19:14.284]   ..$ : int 5
[16:19:14.284]  $ ...future.seeds_ii       : NULL
[16:19:14.284]  $ ...future.globals.maxSize: NULL
[16:19:14.284]  - attr(*, "where")=List of 11
[16:19:14.284]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.284]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.284]  - attr(*, "resolved")= logi FALSE
[16:19:14.284]  - attr(*, "total_size")= num 105552
[16:19:14.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.284]  - attr(*, "already-done")= logi TRUE
[16:19:14.293] - copied ‘...future.FUN’ to environment
[16:19:14.293] - reassign environment for ‘x_FUN’
[16:19:14.293] - copied ‘x_FUN’ to environment
[16:19:14.293] - copied ‘times’ to environment
[16:19:14.293] - copied ‘stopf’ to environment
[16:19:14.293] - copied ‘stop_if_not’ to environment
[16:19:14.293] - copied ‘dim’ to environment
[16:19:14.293] - copied ‘valid_types’ to environment
[16:19:14.293] - copied ‘future.call.arguments’ to environment
[16:19:14.293] - copied ‘...future.elements_ii’ to environment
[16:19:14.294] - copied ‘...future.seeds_ii’ to environment
[16:19:14.294] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.294] assign_globals() ... done
[16:19:14.294] requestCore(): workers = 2
[16:19:14.296] MulticoreFuture started
[16:19:14.296] - Launch lazy future ... done
[16:19:14.297] run() for ‘MulticoreFuture’ ... done
[16:19:14.297] Created future:
[16:19:14.298] plan(): Setting new future strategy stack:
[16:19:14.298] List of future strategies:
[16:19:14.298] 1. sequential:
[16:19:14.298]    - args: function (..., envir = parent.frame())
[16:19:14.298]    - tweaked: FALSE
[16:19:14.298]    - call: NULL
[16:19:14.299] plan(): nbrOfWorkers() = 1
[16:19:14.301] plan(): Setting new future strategy stack:
[16:19:14.301] List of future strategies:
[16:19:14.301] 1. multicore:
[16:19:14.301]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.301]    - tweaked: FALSE
[16:19:14.301]    - call: plan(strategy)
[16:19:14.306] plan(): nbrOfWorkers() = 2
[16:19:14.297] MulticoreFuture:
[16:19:14.297] Label: ‘future_vapply-1’
[16:19:14.297] Expression:
[16:19:14.297] {
[16:19:14.297]     do.call(function(...) {
[16:19:14.297]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.297]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.297]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.297]             on.exit(options(oopts), add = TRUE)
[16:19:14.297]         }
[16:19:14.297]         {
[16:19:14.297]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.297]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.297]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.297]             })
[16:19:14.297]         }
[16:19:14.297]     }, args = future.call.arguments)
[16:19:14.297] }
[16:19:14.297] Lazy evaluation: FALSE
[16:19:14.297] Asynchronous evaluation: TRUE
[16:19:14.297] Local evaluation: TRUE
[16:19:14.297] Environment: R_GlobalEnv
[16:19:14.297] Capture standard output: TRUE
[16:19:14.297] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.297] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.297] Packages: 1 packages (‘future.apply’)
[16:19:14.297] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.297] Resolved: TRUE
[16:19:14.297] Value: <not collected>
[16:19:14.297] Conditions captured: <none>
[16:19:14.297] Early signaling: FALSE
[16:19:14.297] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.297] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.307] Chunk #1 of 2 ... DONE
[16:19:14.307] Chunk #2 of 2 ...
[16:19:14.308]  - Finding globals in 'X' for chunk #2 ...
[16:19:14.308] getGlobalsAndPackages() ...
[16:19:14.308] Searching for globals...
[16:19:14.308] 
[16:19:14.309] Searching for globals ... DONE
[16:19:14.309] - globals: [0] <none>
[16:19:14.309] getGlobalsAndPackages() ... DONE
[16:19:14.309]    + additional globals found: [n=0] 
[16:19:14.309]    + additional namespaces needed: [n=0] 
[16:19:14.309]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:14.309]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.309]  - seeds: <none>
[16:19:14.310]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.310] getGlobalsAndPackages() ...
[16:19:14.310] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.310] Resolving globals: FALSE
[16:19:14.310] Tweak future expression to call with '...' arguments ...
[16:19:14.310] {
[16:19:14.310]     do.call(function(...) {
[16:19:14.310]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.310]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.310]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.310]             on.exit(options(oopts), add = TRUE)
[16:19:14.310]         }
[16:19:14.310]         {
[16:19:14.310]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.310]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.310]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.310]             })
[16:19:14.310]         }
[16:19:14.310]     }, args = future.call.arguments)
[16:19:14.310] }
[16:19:14.311] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.312] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.312] - packages: [1] ‘future.apply’
[16:19:14.315] getGlobalsAndPackages() ... DONE
[16:19:14.316] run() for ‘Future’ ...
[16:19:14.317] - state: ‘created’
[16:19:14.317] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.323] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.324]   - Field: ‘label’
[16:19:14.324]   - Field: ‘local’
[16:19:14.325]   - Field: ‘owner’
[16:19:14.325]   - Field: ‘envir’
[16:19:14.325]   - Field: ‘workers’
[16:19:14.325]   - Field: ‘packages’
[16:19:14.326]   - Field: ‘gc’
[16:19:14.326]   - Field: ‘job’
[16:19:14.326]   - Field: ‘conditions’
[16:19:14.326]   - Field: ‘expr’
[16:19:14.326]   - Field: ‘uuid’
[16:19:14.327]   - Field: ‘seed’
[16:19:14.327]   - Field: ‘version’
[16:19:14.327]   - Field: ‘result’
[16:19:14.327]   - Field: ‘asynchronous’
[16:19:14.327]   - Field: ‘calls’
[16:19:14.328]   - Field: ‘globals’
[16:19:14.328]   - Field: ‘stdout’
[16:19:14.328]   - Field: ‘earlySignal’
[16:19:14.328]   - Field: ‘lazy’
[16:19:14.329]   - Field: ‘state’
[16:19:14.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.329] - Launch lazy future ...
[16:19:14.329] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:14.330] Packages needed by future strategies (n = 0): <none>
[16:19:14.331] {
[16:19:14.331]     {
[16:19:14.331]         {
[16:19:14.331]             ...future.startTime <- base::Sys.time()
[16:19:14.331]             {
[16:19:14.331]                 {
[16:19:14.331]                   {
[16:19:14.331]                     {
[16:19:14.331]                       {
[16:19:14.331]                         base::local({
[16:19:14.331]                           has_future <- base::requireNamespace("future", 
[16:19:14.331]                             quietly = TRUE)
[16:19:14.331]                           if (has_future) {
[16:19:14.331]                             ns <- base::getNamespace("future")
[16:19:14.331]                             version <- ns[[".package"]][["version"]]
[16:19:14.331]                             if (is.null(version)) 
[16:19:14.331]                               version <- utils::packageVersion("future")
[16:19:14.331]                           }
[16:19:14.331]                           else {
[16:19:14.331]                             version <- NULL
[16:19:14.331]                           }
[16:19:14.331]                           if (!has_future || version < "1.8.0") {
[16:19:14.331]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.331]                               "", base::R.version$version.string), 
[16:19:14.331]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.331]                                 base::R.version$platform, 8 * 
[16:19:14.331]                                   base::.Machine$sizeof.pointer), 
[16:19:14.331]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.331]                                 "release", "version")], collapse = " "), 
[16:19:14.331]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.331]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.331]                               info)
[16:19:14.331]                             info <- base::paste(info, collapse = "; ")
[16:19:14.331]                             if (!has_future) {
[16:19:14.331]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.331]                                 info)
[16:19:14.331]                             }
[16:19:14.331]                             else {
[16:19:14.331]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.331]                                 info, version)
[16:19:14.331]                             }
[16:19:14.331]                             base::stop(msg)
[16:19:14.331]                           }
[16:19:14.331]                         })
[16:19:14.331]                       }
[16:19:14.331]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.331]                       base::options(mc.cores = 1L)
[16:19:14.331]                     }
[16:19:14.331]                     base::local({
[16:19:14.331]                       for (pkg in "future.apply") {
[16:19:14.331]                         base::loadNamespace(pkg)
[16:19:14.331]                         base::library(pkg, character.only = TRUE)
[16:19:14.331]                       }
[16:19:14.331]                     })
[16:19:14.331]                   }
[16:19:14.331]                   ...future.strategy.old <- future::plan("list")
[16:19:14.331]                   options(future.plan = NULL)
[16:19:14.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.331]                 }
[16:19:14.331]                 ...future.workdir <- getwd()
[16:19:14.331]             }
[16:19:14.331]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.331]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.331]         }
[16:19:14.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.331]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.331]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.331]             base::names(...future.oldOptions))
[16:19:14.331]     }
[16:19:14.331]     if (FALSE) {
[16:19:14.331]     }
[16:19:14.331]     else {
[16:19:14.331]         if (TRUE) {
[16:19:14.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.331]                 open = "w")
[16:19:14.331]         }
[16:19:14.331]         else {
[16:19:14.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.331]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.331]         }
[16:19:14.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.331]             base::sink(type = "output", split = FALSE)
[16:19:14.331]             base::close(...future.stdout)
[16:19:14.331]         }, add = TRUE)
[16:19:14.331]     }
[16:19:14.331]     ...future.frame <- base::sys.nframe()
[16:19:14.331]     ...future.conditions <- base::list()
[16:19:14.331]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.331]     if (FALSE) {
[16:19:14.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.331]     }
[16:19:14.331]     ...future.result <- base::tryCatch({
[16:19:14.331]         base::withCallingHandlers({
[16:19:14.331]             ...future.value <- base::withVisible(base::local({
[16:19:14.331]                 withCallingHandlers({
[16:19:14.331]                   {
[16:19:14.331]                     do.call(function(...) {
[16:19:14.331]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.331]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.331]                         ...future.globals.maxSize)) {
[16:19:14.331]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.331]                         on.exit(options(oopts), add = TRUE)
[16:19:14.331]                       }
[16:19:14.331]                       {
[16:19:14.331]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.331]                           FUN = function(jj) {
[16:19:14.331]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.331]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.331]                           })
[16:19:14.331]                       }
[16:19:14.331]                     }, args = future.call.arguments)
[16:19:14.331]                   }
[16:19:14.331]                 }, immediateCondition = function(cond) {
[16:19:14.331]                   save_rds <- function (object, pathname, ...) 
[16:19:14.331]                   {
[16:19:14.331]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.331]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.331]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.331]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.331]                         fi_tmp[["mtime"]])
[16:19:14.331]                     }
[16:19:14.331]                     tryCatch({
[16:19:14.331]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.331]                     }, error = function(ex) {
[16:19:14.331]                       msg <- conditionMessage(ex)
[16:19:14.331]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.331]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.331]                         fi_tmp[["mtime"]], msg)
[16:19:14.331]                       ex$message <- msg
[16:19:14.331]                       stop(ex)
[16:19:14.331]                     })
[16:19:14.331]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.331]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.331]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.331]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.331]                       fi <- file.info(pathname)
[16:19:14.331]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.331]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.331]                         fi[["size"]], fi[["mtime"]])
[16:19:14.331]                       stop(msg)
[16:19:14.331]                     }
[16:19:14.331]                     invisible(pathname)
[16:19:14.331]                   }
[16:19:14.331]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.331]                     rootPath = tempdir()) 
[16:19:14.331]                   {
[16:19:14.331]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.331]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.331]                       tmpdir = path, fileext = ".rds")
[16:19:14.331]                     save_rds(obj, file)
[16:19:14.331]                   }
[16:19:14.331]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.331]                   {
[16:19:14.331]                     inherits <- base::inherits
[16:19:14.331]                     invokeRestart <- base::invokeRestart
[16:19:14.331]                     is.null <- base::is.null
[16:19:14.331]                     muffled <- FALSE
[16:19:14.331]                     if (inherits(cond, "message")) {
[16:19:14.331]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.331]                       if (muffled) 
[16:19:14.331]                         invokeRestart("muffleMessage")
[16:19:14.331]                     }
[16:19:14.331]                     else if (inherits(cond, "warning")) {
[16:19:14.331]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.331]                       if (muffled) 
[16:19:14.331]                         invokeRestart("muffleWarning")
[16:19:14.331]                     }
[16:19:14.331]                     else if (inherits(cond, "condition")) {
[16:19:14.331]                       if (!is.null(pattern)) {
[16:19:14.331]                         computeRestarts <- base::computeRestarts
[16:19:14.331]                         grepl <- base::grepl
[16:19:14.331]                         restarts <- computeRestarts(cond)
[16:19:14.331]                         for (restart in restarts) {
[16:19:14.331]                           name <- restart$name
[16:19:14.331]                           if (is.null(name)) 
[16:19:14.331]                             next
[16:19:14.331]                           if (!grepl(pattern, name)) 
[16:19:14.331]                             next
[16:19:14.331]                           invokeRestart(restart)
[16:19:14.331]                           muffled <- TRUE
[16:19:14.331]                           break
[16:19:14.331]                         }
[16:19:14.331]                       }
[16:19:14.331]                     }
[16:19:14.331]                     invisible(muffled)
[16:19:14.331]                   }
[16:19:14.331]                   muffleCondition(cond)
[16:19:14.331]                 })
[16:19:14.331]             }))
[16:19:14.331]             future::FutureResult(value = ...future.value$value, 
[16:19:14.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.331]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.331]                     ...future.globalenv.names))
[16:19:14.331]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.331]         }, condition = base::local({
[16:19:14.331]             c <- base::c
[16:19:14.331]             inherits <- base::inherits
[16:19:14.331]             invokeRestart <- base::invokeRestart
[16:19:14.331]             length <- base::length
[16:19:14.331]             list <- base::list
[16:19:14.331]             seq.int <- base::seq.int
[16:19:14.331]             signalCondition <- base::signalCondition
[16:19:14.331]             sys.calls <- base::sys.calls
[16:19:14.331]             `[[` <- base::`[[`
[16:19:14.331]             `+` <- base::`+`
[16:19:14.331]             `<<-` <- base::`<<-`
[16:19:14.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.331]                   3L)]
[16:19:14.331]             }
[16:19:14.331]             function(cond) {
[16:19:14.331]                 is_error <- inherits(cond, "error")
[16:19:14.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.331]                   NULL)
[16:19:14.331]                 if (is_error) {
[16:19:14.331]                   sessionInformation <- function() {
[16:19:14.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.331]                       search = base::search(), system = base::Sys.info())
[16:19:14.331]                   }
[16:19:14.331]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.331]                     cond$call), session = sessionInformation(), 
[16:19:14.331]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.331]                   signalCondition(cond)
[16:19:14.331]                 }
[16:19:14.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.331]                 "immediateCondition"))) {
[16:19:14.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.331]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.331]                   if (TRUE && !signal) {
[16:19:14.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.331]                     {
[16:19:14.331]                       inherits <- base::inherits
[16:19:14.331]                       invokeRestart <- base::invokeRestart
[16:19:14.331]                       is.null <- base::is.null
[16:19:14.331]                       muffled <- FALSE
[16:19:14.331]                       if (inherits(cond, "message")) {
[16:19:14.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.331]                         if (muffled) 
[16:19:14.331]                           invokeRestart("muffleMessage")
[16:19:14.331]                       }
[16:19:14.331]                       else if (inherits(cond, "warning")) {
[16:19:14.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.331]                         if (muffled) 
[16:19:14.331]                           invokeRestart("muffleWarning")
[16:19:14.331]                       }
[16:19:14.331]                       else if (inherits(cond, "condition")) {
[16:19:14.331]                         if (!is.null(pattern)) {
[16:19:14.331]                           computeRestarts <- base::computeRestarts
[16:19:14.331]                           grepl <- base::grepl
[16:19:14.331]                           restarts <- computeRestarts(cond)
[16:19:14.331]                           for (restart in restarts) {
[16:19:14.331]                             name <- restart$name
[16:19:14.331]                             if (is.null(name)) 
[16:19:14.331]                               next
[16:19:14.331]                             if (!grepl(pattern, name)) 
[16:19:14.331]                               next
[16:19:14.331]                             invokeRestart(restart)
[16:19:14.331]                             muffled <- TRUE
[16:19:14.331]                             break
[16:19:14.331]                           }
[16:19:14.331]                         }
[16:19:14.331]                       }
[16:19:14.331]                       invisible(muffled)
[16:19:14.331]                     }
[16:19:14.331]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.331]                   }
[16:19:14.331]                 }
[16:19:14.331]                 else {
[16:19:14.331]                   if (TRUE) {
[16:19:14.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.331]                     {
[16:19:14.331]                       inherits <- base::inherits
[16:19:14.331]                       invokeRestart <- base::invokeRestart
[16:19:14.331]                       is.null <- base::is.null
[16:19:14.331]                       muffled <- FALSE
[16:19:14.331]                       if (inherits(cond, "message")) {
[16:19:14.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.331]                         if (muffled) 
[16:19:14.331]                           invokeRestart("muffleMessage")
[16:19:14.331]                       }
[16:19:14.331]                       else if (inherits(cond, "warning")) {
[16:19:14.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.331]                         if (muffled) 
[16:19:14.331]                           invokeRestart("muffleWarning")
[16:19:14.331]                       }
[16:19:14.331]                       else if (inherits(cond, "condition")) {
[16:19:14.331]                         if (!is.null(pattern)) {
[16:19:14.331]                           computeRestarts <- base::computeRestarts
[16:19:14.331]                           grepl <- base::grepl
[16:19:14.331]                           restarts <- computeRestarts(cond)
[16:19:14.331]                           for (restart in restarts) {
[16:19:14.331]                             name <- restart$name
[16:19:14.331]                             if (is.null(name)) 
[16:19:14.331]                               next
[16:19:14.331]                             if (!grepl(pattern, name)) 
[16:19:14.331]                               next
[16:19:14.331]                             invokeRestart(restart)
[16:19:14.331]                             muffled <- TRUE
[16:19:14.331]                             break
[16:19:14.331]                           }
[16:19:14.331]                         }
[16:19:14.331]                       }
[16:19:14.331]                       invisible(muffled)
[16:19:14.331]                     }
[16:19:14.331]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.331]                   }
[16:19:14.331]                 }
[16:19:14.331]             }
[16:19:14.331]         }))
[16:19:14.331]     }, error = function(ex) {
[16:19:14.331]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.331]                 ...future.rng), started = ...future.startTime, 
[16:19:14.331]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.331]             version = "1.8"), class = "FutureResult")
[16:19:14.331]     }, finally = {
[16:19:14.331]         if (!identical(...future.workdir, getwd())) 
[16:19:14.331]             setwd(...future.workdir)
[16:19:14.331]         {
[16:19:14.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.331]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.331]             }
[16:19:14.331]             base::options(...future.oldOptions)
[16:19:14.331]             if (.Platform$OS.type == "windows") {
[16:19:14.331]                 old_names <- names(...future.oldEnvVars)
[16:19:14.331]                 envs <- base::Sys.getenv()
[16:19:14.331]                 names <- names(envs)
[16:19:14.331]                 common <- intersect(names, old_names)
[16:19:14.331]                 added <- setdiff(names, old_names)
[16:19:14.331]                 removed <- setdiff(old_names, names)
[16:19:14.331]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.331]                   envs[common]]
[16:19:14.331]                 NAMES <- toupper(changed)
[16:19:14.331]                 args <- list()
[16:19:14.331]                 for (kk in seq_along(NAMES)) {
[16:19:14.331]                   name <- changed[[kk]]
[16:19:14.331]                   NAME <- NAMES[[kk]]
[16:19:14.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.331]                     next
[16:19:14.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.331]                 }
[16:19:14.331]                 NAMES <- toupper(added)
[16:19:14.331]                 for (kk in seq_along(NAMES)) {
[16:19:14.331]                   name <- added[[kk]]
[16:19:14.331]                   NAME <- NAMES[[kk]]
[16:19:14.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.331]                     next
[16:19:14.331]                   args[[name]] <- ""
[16:19:14.331]                 }
[16:19:14.331]                 NAMES <- toupper(removed)
[16:19:14.331]                 for (kk in seq_along(NAMES)) {
[16:19:14.331]                   name <- removed[[kk]]
[16:19:14.331]                   NAME <- NAMES[[kk]]
[16:19:14.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.331]                     next
[16:19:14.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.331]                 }
[16:19:14.331]                 if (length(args) > 0) 
[16:19:14.331]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.331]             }
[16:19:14.331]             else {
[16:19:14.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.331]             }
[16:19:14.331]             {
[16:19:14.331]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.331]                   0L) {
[16:19:14.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.331]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.331]                   base::options(opts)
[16:19:14.331]                 }
[16:19:14.331]                 {
[16:19:14.331]                   {
[16:19:14.331]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.331]                     NULL
[16:19:14.331]                   }
[16:19:14.331]                   options(future.plan = NULL)
[16:19:14.331]                   if (is.na(NA_character_)) 
[16:19:14.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.331]                     .init = FALSE)
[16:19:14.331]                 }
[16:19:14.331]             }
[16:19:14.331]         }
[16:19:14.331]     })
[16:19:14.331]     if (TRUE) {
[16:19:14.331]         base::sink(type = "output", split = FALSE)
[16:19:14.331]         if (TRUE) {
[16:19:14.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.331]         }
[16:19:14.331]         else {
[16:19:14.331]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.331]         }
[16:19:14.331]         base::close(...future.stdout)
[16:19:14.331]         ...future.stdout <- NULL
[16:19:14.331]     }
[16:19:14.331]     ...future.result$conditions <- ...future.conditions
[16:19:14.331]     ...future.result$finished <- base::Sys.time()
[16:19:14.331]     ...future.result
[16:19:14.331] }
[16:19:14.333] assign_globals() ...
[16:19:14.334] List of 11
[16:19:14.334]  $ ...future.FUN            :function (x, ...)  
[16:19:14.334]  $ x_FUN                    :function (x)  
[16:19:14.334]  $ times                    : int 4
[16:19:14.334]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.334]  $ stop_if_not              :function (...)  
[16:19:14.334]  $ dim                      : int [1:2] 2 2
[16:19:14.334]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.334]  $ future.call.arguments    : list()
[16:19:14.334]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.334]  $ ...future.elements_ii    :List of 5
[16:19:14.334]   ..$ : int 6
[16:19:14.334]   ..$ : int 7
[16:19:14.334]   ..$ : int 8
[16:19:14.334]   ..$ : int 9
[16:19:14.334]   ..$ : int 10
[16:19:14.334]  $ ...future.seeds_ii       : NULL
[16:19:14.334]  $ ...future.globals.maxSize: NULL
[16:19:14.334]  - attr(*, "where")=List of 11
[16:19:14.334]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.334]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.334]  - attr(*, "resolved")= logi FALSE
[16:19:14.334]  - attr(*, "total_size")= num 105552
[16:19:14.334]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.334]  - attr(*, "already-done")= logi TRUE
[16:19:14.345] - copied ‘...future.FUN’ to environment
[16:19:14.345] - reassign environment for ‘x_FUN’
[16:19:14.345] - copied ‘x_FUN’ to environment
[16:19:14.345] - copied ‘times’ to environment
[16:19:14.346] - copied ‘stopf’ to environment
[16:19:14.346] - copied ‘stop_if_not’ to environment
[16:19:14.346] - copied ‘dim’ to environment
[16:19:14.346] - copied ‘valid_types’ to environment
[16:19:14.346] - copied ‘future.call.arguments’ to environment
[16:19:14.346] - copied ‘...future.elements_ii’ to environment
[16:19:14.346] - copied ‘...future.seeds_ii’ to environment
[16:19:14.346] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.346] assign_globals() ... done
[16:19:14.346] requestCore(): workers = 2
[16:19:14.349] MulticoreFuture started
[16:19:14.349] - Launch lazy future ... done
[16:19:14.349] run() for ‘MulticoreFuture’ ... done
[16:19:14.350] Created future:
[16:19:14.350] plan(): Setting new future strategy stack:
[16:19:14.351] List of future strategies:
[16:19:14.351] 1. sequential:
[16:19:14.351]    - args: function (..., envir = parent.frame())
[16:19:14.351]    - tweaked: FALSE
[16:19:14.351]    - call: NULL
[16:19:14.351] plan(): nbrOfWorkers() = 1
[16:19:14.353] plan(): Setting new future strategy stack:
[16:19:14.354] List of future strategies:
[16:19:14.354] 1. multicore:
[16:19:14.354]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.354]    - tweaked: FALSE
[16:19:14.354]    - call: plan(strategy)
[16:19:14.350] MulticoreFuture:
[16:19:14.350] Label: ‘future_vapply-2’
[16:19:14.350] Expression:
[16:19:14.350] {
[16:19:14.350]     do.call(function(...) {
[16:19:14.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.350]             on.exit(options(oopts), add = TRUE)
[16:19:14.350]         }
[16:19:14.350]         {
[16:19:14.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.350]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.350]             })
[16:19:14.350]         }
[16:19:14.350]     }, args = future.call.arguments)
[16:19:14.350] }
[16:19:14.350] Lazy evaluation: FALSE
[16:19:14.350] Asynchronous evaluation: TRUE
[16:19:14.350] Local evaluation: TRUE
[16:19:14.350] Environment: R_GlobalEnv
[16:19:14.350] Capture standard output: TRUE
[16:19:14.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.350] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.350] Packages: 1 packages (‘future.apply’)
[16:19:14.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.350] Resolved: FALSE
[16:19:14.350] Value: <not collected>
[16:19:14.350] Conditions captured: <none>
[16:19:14.350] Early signaling: FALSE
[16:19:14.350] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.350] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.363] Chunk #2 of 2 ... DONE
[16:19:14.363] Launching 2 futures (chunks) ... DONE
[16:19:14.363] Resolving 2 futures (chunks) ...
[16:19:14.365] plan(): nbrOfWorkers() = 2
[16:19:14.366] resolve() on list ...
[16:19:14.366]  recursive: 0
[16:19:14.366]  length: 2
[16:19:14.366] 
[16:19:14.367] Future #1
[16:19:14.367] result() for MulticoreFuture ...
[16:19:14.368] result() for MulticoreFuture ...
[16:19:14.369] result() for MulticoreFuture ... done
[16:19:14.369] result() for MulticoreFuture ... done
[16:19:14.369] result() for MulticoreFuture ...
[16:19:14.369] result() for MulticoreFuture ... done
[16:19:14.370] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:14.370] - nx: 2
[16:19:14.370] - relay: TRUE
[16:19:14.370] - stdout: TRUE
[16:19:14.371] - signal: TRUE
[16:19:14.371] - resignal: FALSE
[16:19:14.371] - force: TRUE
[16:19:14.371] - relayed: [n=2] FALSE, FALSE
[16:19:14.372] - queued futures: [n=2] FALSE, FALSE
[16:19:14.372]  - until=1
[16:19:14.372]  - relaying element #1
[16:19:14.372] result() for MulticoreFuture ...
[16:19:14.373] result() for MulticoreFuture ... done
[16:19:14.373] result() for MulticoreFuture ...
[16:19:14.373] result() for MulticoreFuture ... done
[16:19:14.373] result() for MulticoreFuture ...
[16:19:14.373] result() for MulticoreFuture ... done
[16:19:14.374] result() for MulticoreFuture ...
[16:19:14.374] result() for MulticoreFuture ... done
[16:19:14.374] - relayed: [n=2] TRUE, FALSE
[16:19:14.374] - queued futures: [n=2] TRUE, FALSE
[16:19:14.375] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:14.375]  length: 1 (resolved future 1)
[16:19:14.375] Future #2
[16:19:14.376] result() for MulticoreFuture ...
[16:19:14.377] result() for MulticoreFuture ...
[16:19:14.377] result() for MulticoreFuture ... done
[16:19:14.377] result() for MulticoreFuture ... done
[16:19:14.377] result() for MulticoreFuture ...
[16:19:14.377] result() for MulticoreFuture ... done
[16:19:14.378] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:14.378] - nx: 2
[16:19:14.378] - relay: TRUE
[16:19:14.378] - stdout: TRUE
[16:19:14.378] - signal: TRUE
[16:19:14.378] - resignal: FALSE
[16:19:14.378] - force: TRUE
[16:19:14.378] - relayed: [n=2] TRUE, FALSE
[16:19:14.378] - queued futures: [n=2] TRUE, FALSE
[16:19:14.379]  - until=2
[16:19:14.379]  - relaying element #2
[16:19:14.379] result() for MulticoreFuture ...
[16:19:14.379] result() for MulticoreFuture ... done
[16:19:14.379] result() for MulticoreFuture ...
[16:19:14.379] result() for MulticoreFuture ... done
[16:19:14.380] result() for MulticoreFuture ...
[16:19:14.380] result() for MulticoreFuture ... done
[16:19:14.380] result() for MulticoreFuture ...
[16:19:14.380] result() for MulticoreFuture ... done
[16:19:14.380] - relayed: [n=2] TRUE, TRUE
[16:19:14.380] - queued futures: [n=2] TRUE, TRUE
[16:19:14.380] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:14.380]  length: 0 (resolved future 2)
[16:19:14.380] Relaying remaining futures
[16:19:14.381] signalConditionsASAP(NULL, pos=0) ...
[16:19:14.381] - nx: 2
[16:19:14.381] - relay: TRUE
[16:19:14.381] - stdout: TRUE
[16:19:14.381] - signal: TRUE
[16:19:14.381] - resignal: FALSE
[16:19:14.381] - force: TRUE
[16:19:14.381] - relayed: [n=2] TRUE, TRUE
[16:19:14.381] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:14.382] - relayed: [n=2] TRUE, TRUE
[16:19:14.382] - queued futures: [n=2] TRUE, TRUE
[16:19:14.382] signalConditionsASAP(NULL, pos=0) ... done
[16:19:14.382] resolve() on list ... DONE
[16:19:14.382] result() for MulticoreFuture ...
[16:19:14.382] result() for MulticoreFuture ... done
[16:19:14.382] result() for MulticoreFuture ...
[16:19:14.382] result() for MulticoreFuture ... done
[16:19:14.382] result() for MulticoreFuture ...
[16:19:14.383] result() for MulticoreFuture ... done
[16:19:14.383] result() for MulticoreFuture ...
[16:19:14.383] result() for MulticoreFuture ... done
[16:19:14.383]  - Number of value chunks collected: 2
[16:19:14.383] Resolving 2 futures (chunks) ... DONE
[16:19:14.383] Reducing values from 2 chunks ...
[16:19:14.383]  - Number of values collected after concatenation: 10
[16:19:14.383]  - Number of values expected: 10
[16:19:14.383] Reducing values from 2 chunks ... DONE
[16:19:14.383] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:19:14.386] future_lapply() ...
[16:19:14.392] Number of chunks: 2
[16:19:14.392] getGlobalsAndPackagesXApply() ...
[16:19:14.392]  - future.globals: TRUE
[16:19:14.392] getGlobalsAndPackages() ...
[16:19:14.392] Searching for globals...
[16:19:14.398] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:19:14.398] Searching for globals ... DONE
[16:19:14.398] Resolving globals: FALSE
[16:19:14.399] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:19:14.400] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:14.400] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.400] - packages: [2] ‘stats’, ‘future.apply’
[16:19:14.400] getGlobalsAndPackages() ... DONE
[16:19:14.400]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.401]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:19:14.401] Finding globals ... DONE
[16:19:14.401]  - use_args: TRUE
[16:19:14.401]  - Getting '...' globals ...
[16:19:14.401] resolve() on list ...
[16:19:14.401]  recursive: 0
[16:19:14.401]  length: 1
[16:19:14.402]  elements: ‘...’
[16:19:14.402]  length: 0 (resolved future 1)
[16:19:14.402] resolve() on list ... DONE
[16:19:14.402]    - '...' content: [n=0] 
[16:19:14.402] List of 1
[16:19:14.402]  $ ...: list()
[16:19:14.402]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.402]  - attr(*, "where")=List of 1
[16:19:14.402]   ..$ ...:<environment: 0x56199e9df848> 
[16:19:14.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.402]  - attr(*, "resolved")= logi TRUE
[16:19:14.402]  - attr(*, "total_size")= num NA
[16:19:14.405]  - Getting '...' globals ... DONE
[16:19:14.405] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:14.405] List of 8
[16:19:14.405]  $ ...future.FUN:function (x, ...)  
[16:19:14.405]  $ x_FUN        :function (x, ...)  
[16:19:14.405]  $ times        : int 5
[16:19:14.405]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.405]  $ stop_if_not  :function (...)  
[16:19:14.405]  $ dim          : NULL
[16:19:14.405]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:14.405]  $ ...          : list()
[16:19:14.405]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.405]  - attr(*, "where")=List of 8
[16:19:14.405]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:14.405]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:14.405]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:14.405]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:14.405]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:14.405]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:14.405]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:14.405]   ..$ ...          :<environment: 0x56199e9df848> 
[16:19:14.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.405]  - attr(*, "resolved")= logi FALSE
[16:19:14.405]  - attr(*, "total_size")= num 95528
[16:19:14.410] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:19:14.410] getGlobalsAndPackagesXApply() ... DONE
[16:19:14.411] Number of futures (= number of chunks): 2
[16:19:14.411] Launching 2 futures (chunks) ...
[16:19:14.411] Chunk #1 of 2 ...
[16:19:14.411]  - Finding globals in 'X' for chunk #1 ...
[16:19:14.411] getGlobalsAndPackages() ...
[16:19:14.411] Searching for globals...
[16:19:14.411] 
[16:19:14.411] Searching for globals ... DONE
[16:19:14.412] - globals: [0] <none>
[16:19:14.412] getGlobalsAndPackages() ... DONE
[16:19:14.412]    + additional globals found: [n=0] 
[16:19:14.412]    + additional namespaces needed: [n=0] 
[16:19:14.412]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:14.412]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.412]  - seeds: <none>
[16:19:14.412]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.412] getGlobalsAndPackages() ...
[16:19:14.412] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.413] Resolving globals: FALSE
[16:19:14.413] Tweak future expression to call with '...' arguments ...
[16:19:14.413] {
[16:19:14.413]     do.call(function(...) {
[16:19:14.413]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.413]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.413]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.413]             on.exit(options(oopts), add = TRUE)
[16:19:14.413]         }
[16:19:14.413]         {
[16:19:14.413]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.413]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.413]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.413]             })
[16:19:14.413]         }
[16:19:14.413]     }, args = future.call.arguments)
[16:19:14.413] }
[16:19:14.413] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.413] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.414] - packages: [2] ‘stats’, ‘future.apply’
[16:19:14.414] getGlobalsAndPackages() ... DONE
[16:19:14.414] run() for ‘Future’ ...
[16:19:14.414] - state: ‘created’
[16:19:14.414] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.418] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.420]   - Field: ‘label’
[16:19:14.420]   - Field: ‘local’
[16:19:14.420]   - Field: ‘owner’
[16:19:14.420]   - Field: ‘envir’
[16:19:14.420]   - Field: ‘workers’
[16:19:14.420]   - Field: ‘packages’
[16:19:14.421]   - Field: ‘gc’
[16:19:14.421]   - Field: ‘job’
[16:19:14.421]   - Field: ‘conditions’
[16:19:14.421]   - Field: ‘expr’
[16:19:14.421]   - Field: ‘uuid’
[16:19:14.421]   - Field: ‘seed’
[16:19:14.421]   - Field: ‘version’
[16:19:14.421]   - Field: ‘result’
[16:19:14.421]   - Field: ‘asynchronous’
[16:19:14.421]   - Field: ‘calls’
[16:19:14.422]   - Field: ‘globals’
[16:19:14.422]   - Field: ‘stdout’
[16:19:14.422]   - Field: ‘earlySignal’
[16:19:14.422]   - Field: ‘lazy’
[16:19:14.422]   - Field: ‘state’
[16:19:14.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.422] - Launch lazy future ...
[16:19:14.422] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:14.423] Packages needed by future strategies (n = 0): <none>
[16:19:14.423] {
[16:19:14.423]     {
[16:19:14.423]         {
[16:19:14.423]             ...future.startTime <- base::Sys.time()
[16:19:14.423]             {
[16:19:14.423]                 {
[16:19:14.423]                   {
[16:19:14.423]                     {
[16:19:14.423]                       {
[16:19:14.423]                         base::local({
[16:19:14.423]                           has_future <- base::requireNamespace("future", 
[16:19:14.423]                             quietly = TRUE)
[16:19:14.423]                           if (has_future) {
[16:19:14.423]                             ns <- base::getNamespace("future")
[16:19:14.423]                             version <- ns[[".package"]][["version"]]
[16:19:14.423]                             if (is.null(version)) 
[16:19:14.423]                               version <- utils::packageVersion("future")
[16:19:14.423]                           }
[16:19:14.423]                           else {
[16:19:14.423]                             version <- NULL
[16:19:14.423]                           }
[16:19:14.423]                           if (!has_future || version < "1.8.0") {
[16:19:14.423]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.423]                               "", base::R.version$version.string), 
[16:19:14.423]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.423]                                 base::R.version$platform, 8 * 
[16:19:14.423]                                   base::.Machine$sizeof.pointer), 
[16:19:14.423]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.423]                                 "release", "version")], collapse = " "), 
[16:19:14.423]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.423]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.423]                               info)
[16:19:14.423]                             info <- base::paste(info, collapse = "; ")
[16:19:14.423]                             if (!has_future) {
[16:19:14.423]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.423]                                 info)
[16:19:14.423]                             }
[16:19:14.423]                             else {
[16:19:14.423]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.423]                                 info, version)
[16:19:14.423]                             }
[16:19:14.423]                             base::stop(msg)
[16:19:14.423]                           }
[16:19:14.423]                         })
[16:19:14.423]                       }
[16:19:14.423]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.423]                       base::options(mc.cores = 1L)
[16:19:14.423]                     }
[16:19:14.423]                     base::local({
[16:19:14.423]                       for (pkg in c("stats", "future.apply")) {
[16:19:14.423]                         base::loadNamespace(pkg)
[16:19:14.423]                         base::library(pkg, character.only = TRUE)
[16:19:14.423]                       }
[16:19:14.423]                     })
[16:19:14.423]                   }
[16:19:14.423]                   ...future.strategy.old <- future::plan("list")
[16:19:14.423]                   options(future.plan = NULL)
[16:19:14.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.423]                 }
[16:19:14.423]                 ...future.workdir <- getwd()
[16:19:14.423]             }
[16:19:14.423]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.423]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.423]         }
[16:19:14.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.423]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.423]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.423]             base::names(...future.oldOptions))
[16:19:14.423]     }
[16:19:14.423]     if (FALSE) {
[16:19:14.423]     }
[16:19:14.423]     else {
[16:19:14.423]         if (TRUE) {
[16:19:14.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.423]                 open = "w")
[16:19:14.423]         }
[16:19:14.423]         else {
[16:19:14.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.423]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.423]         }
[16:19:14.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.423]             base::sink(type = "output", split = FALSE)
[16:19:14.423]             base::close(...future.stdout)
[16:19:14.423]         }, add = TRUE)
[16:19:14.423]     }
[16:19:14.423]     ...future.frame <- base::sys.nframe()
[16:19:14.423]     ...future.conditions <- base::list()
[16:19:14.423]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.423]     if (FALSE) {
[16:19:14.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.423]     }
[16:19:14.423]     ...future.result <- base::tryCatch({
[16:19:14.423]         base::withCallingHandlers({
[16:19:14.423]             ...future.value <- base::withVisible(base::local({
[16:19:14.423]                 withCallingHandlers({
[16:19:14.423]                   {
[16:19:14.423]                     do.call(function(...) {
[16:19:14.423]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.423]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.423]                         ...future.globals.maxSize)) {
[16:19:14.423]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.423]                         on.exit(options(oopts), add = TRUE)
[16:19:14.423]                       }
[16:19:14.423]                       {
[16:19:14.423]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.423]                           FUN = function(jj) {
[16:19:14.423]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.423]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.423]                           })
[16:19:14.423]                       }
[16:19:14.423]                     }, args = future.call.arguments)
[16:19:14.423]                   }
[16:19:14.423]                 }, immediateCondition = function(cond) {
[16:19:14.423]                   save_rds <- function (object, pathname, ...) 
[16:19:14.423]                   {
[16:19:14.423]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.423]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.423]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.423]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.423]                         fi_tmp[["mtime"]])
[16:19:14.423]                     }
[16:19:14.423]                     tryCatch({
[16:19:14.423]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.423]                     }, error = function(ex) {
[16:19:14.423]                       msg <- conditionMessage(ex)
[16:19:14.423]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.423]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.423]                         fi_tmp[["mtime"]], msg)
[16:19:14.423]                       ex$message <- msg
[16:19:14.423]                       stop(ex)
[16:19:14.423]                     })
[16:19:14.423]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.423]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.423]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.423]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.423]                       fi <- file.info(pathname)
[16:19:14.423]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.423]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.423]                         fi[["size"]], fi[["mtime"]])
[16:19:14.423]                       stop(msg)
[16:19:14.423]                     }
[16:19:14.423]                     invisible(pathname)
[16:19:14.423]                   }
[16:19:14.423]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.423]                     rootPath = tempdir()) 
[16:19:14.423]                   {
[16:19:14.423]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.423]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.423]                       tmpdir = path, fileext = ".rds")
[16:19:14.423]                     save_rds(obj, file)
[16:19:14.423]                   }
[16:19:14.423]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.423]                   {
[16:19:14.423]                     inherits <- base::inherits
[16:19:14.423]                     invokeRestart <- base::invokeRestart
[16:19:14.423]                     is.null <- base::is.null
[16:19:14.423]                     muffled <- FALSE
[16:19:14.423]                     if (inherits(cond, "message")) {
[16:19:14.423]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.423]                       if (muffled) 
[16:19:14.423]                         invokeRestart("muffleMessage")
[16:19:14.423]                     }
[16:19:14.423]                     else if (inherits(cond, "warning")) {
[16:19:14.423]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.423]                       if (muffled) 
[16:19:14.423]                         invokeRestart("muffleWarning")
[16:19:14.423]                     }
[16:19:14.423]                     else if (inherits(cond, "condition")) {
[16:19:14.423]                       if (!is.null(pattern)) {
[16:19:14.423]                         computeRestarts <- base::computeRestarts
[16:19:14.423]                         grepl <- base::grepl
[16:19:14.423]                         restarts <- computeRestarts(cond)
[16:19:14.423]                         for (restart in restarts) {
[16:19:14.423]                           name <- restart$name
[16:19:14.423]                           if (is.null(name)) 
[16:19:14.423]                             next
[16:19:14.423]                           if (!grepl(pattern, name)) 
[16:19:14.423]                             next
[16:19:14.423]                           invokeRestart(restart)
[16:19:14.423]                           muffled <- TRUE
[16:19:14.423]                           break
[16:19:14.423]                         }
[16:19:14.423]                       }
[16:19:14.423]                     }
[16:19:14.423]                     invisible(muffled)
[16:19:14.423]                   }
[16:19:14.423]                   muffleCondition(cond)
[16:19:14.423]                 })
[16:19:14.423]             }))
[16:19:14.423]             future::FutureResult(value = ...future.value$value, 
[16:19:14.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.423]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.423]                     ...future.globalenv.names))
[16:19:14.423]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.423]         }, condition = base::local({
[16:19:14.423]             c <- base::c
[16:19:14.423]             inherits <- base::inherits
[16:19:14.423]             invokeRestart <- base::invokeRestart
[16:19:14.423]             length <- base::length
[16:19:14.423]             list <- base::list
[16:19:14.423]             seq.int <- base::seq.int
[16:19:14.423]             signalCondition <- base::signalCondition
[16:19:14.423]             sys.calls <- base::sys.calls
[16:19:14.423]             `[[` <- base::`[[`
[16:19:14.423]             `+` <- base::`+`
[16:19:14.423]             `<<-` <- base::`<<-`
[16:19:14.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.423]                   3L)]
[16:19:14.423]             }
[16:19:14.423]             function(cond) {
[16:19:14.423]                 is_error <- inherits(cond, "error")
[16:19:14.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.423]                   NULL)
[16:19:14.423]                 if (is_error) {
[16:19:14.423]                   sessionInformation <- function() {
[16:19:14.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.423]                       search = base::search(), system = base::Sys.info())
[16:19:14.423]                   }
[16:19:14.423]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.423]                     cond$call), session = sessionInformation(), 
[16:19:14.423]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.423]                   signalCondition(cond)
[16:19:14.423]                 }
[16:19:14.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.423]                 "immediateCondition"))) {
[16:19:14.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.423]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.423]                   if (TRUE && !signal) {
[16:19:14.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.423]                     {
[16:19:14.423]                       inherits <- base::inherits
[16:19:14.423]                       invokeRestart <- base::invokeRestart
[16:19:14.423]                       is.null <- base::is.null
[16:19:14.423]                       muffled <- FALSE
[16:19:14.423]                       if (inherits(cond, "message")) {
[16:19:14.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.423]                         if (muffled) 
[16:19:14.423]                           invokeRestart("muffleMessage")
[16:19:14.423]                       }
[16:19:14.423]                       else if (inherits(cond, "warning")) {
[16:19:14.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.423]                         if (muffled) 
[16:19:14.423]                           invokeRestart("muffleWarning")
[16:19:14.423]                       }
[16:19:14.423]                       else if (inherits(cond, "condition")) {
[16:19:14.423]                         if (!is.null(pattern)) {
[16:19:14.423]                           computeRestarts <- base::computeRestarts
[16:19:14.423]                           grepl <- base::grepl
[16:19:14.423]                           restarts <- computeRestarts(cond)
[16:19:14.423]                           for (restart in restarts) {
[16:19:14.423]                             name <- restart$name
[16:19:14.423]                             if (is.null(name)) 
[16:19:14.423]                               next
[16:19:14.423]                             if (!grepl(pattern, name)) 
[16:19:14.423]                               next
[16:19:14.423]                             invokeRestart(restart)
[16:19:14.423]                             muffled <- TRUE
[16:19:14.423]                             break
[16:19:14.423]                           }
[16:19:14.423]                         }
[16:19:14.423]                       }
[16:19:14.423]                       invisible(muffled)
[16:19:14.423]                     }
[16:19:14.423]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.423]                   }
[16:19:14.423]                 }
[16:19:14.423]                 else {
[16:19:14.423]                   if (TRUE) {
[16:19:14.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.423]                     {
[16:19:14.423]                       inherits <- base::inherits
[16:19:14.423]                       invokeRestart <- base::invokeRestart
[16:19:14.423]                       is.null <- base::is.null
[16:19:14.423]                       muffled <- FALSE
[16:19:14.423]                       if (inherits(cond, "message")) {
[16:19:14.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.423]                         if (muffled) 
[16:19:14.423]                           invokeRestart("muffleMessage")
[16:19:14.423]                       }
[16:19:14.423]                       else if (inherits(cond, "warning")) {
[16:19:14.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.423]                         if (muffled) 
[16:19:14.423]                           invokeRestart("muffleWarning")
[16:19:14.423]                       }
[16:19:14.423]                       else if (inherits(cond, "condition")) {
[16:19:14.423]                         if (!is.null(pattern)) {
[16:19:14.423]                           computeRestarts <- base::computeRestarts
[16:19:14.423]                           grepl <- base::grepl
[16:19:14.423]                           restarts <- computeRestarts(cond)
[16:19:14.423]                           for (restart in restarts) {
[16:19:14.423]                             name <- restart$name
[16:19:14.423]                             if (is.null(name)) 
[16:19:14.423]                               next
[16:19:14.423]                             if (!grepl(pattern, name)) 
[16:19:14.423]                               next
[16:19:14.423]                             invokeRestart(restart)
[16:19:14.423]                             muffled <- TRUE
[16:19:14.423]                             break
[16:19:14.423]                           }
[16:19:14.423]                         }
[16:19:14.423]                       }
[16:19:14.423]                       invisible(muffled)
[16:19:14.423]                     }
[16:19:14.423]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.423]                   }
[16:19:14.423]                 }
[16:19:14.423]             }
[16:19:14.423]         }))
[16:19:14.423]     }, error = function(ex) {
[16:19:14.423]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.423]                 ...future.rng), started = ...future.startTime, 
[16:19:14.423]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.423]             version = "1.8"), class = "FutureResult")
[16:19:14.423]     }, finally = {
[16:19:14.423]         if (!identical(...future.workdir, getwd())) 
[16:19:14.423]             setwd(...future.workdir)
[16:19:14.423]         {
[16:19:14.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.423]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.423]             }
[16:19:14.423]             base::options(...future.oldOptions)
[16:19:14.423]             if (.Platform$OS.type == "windows") {
[16:19:14.423]                 old_names <- names(...future.oldEnvVars)
[16:19:14.423]                 envs <- base::Sys.getenv()
[16:19:14.423]                 names <- names(envs)
[16:19:14.423]                 common <- intersect(names, old_names)
[16:19:14.423]                 added <- setdiff(names, old_names)
[16:19:14.423]                 removed <- setdiff(old_names, names)
[16:19:14.423]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.423]                   envs[common]]
[16:19:14.423]                 NAMES <- toupper(changed)
[16:19:14.423]                 args <- list()
[16:19:14.423]                 for (kk in seq_along(NAMES)) {
[16:19:14.423]                   name <- changed[[kk]]
[16:19:14.423]                   NAME <- NAMES[[kk]]
[16:19:14.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.423]                     next
[16:19:14.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.423]                 }
[16:19:14.423]                 NAMES <- toupper(added)
[16:19:14.423]                 for (kk in seq_along(NAMES)) {
[16:19:14.423]                   name <- added[[kk]]
[16:19:14.423]                   NAME <- NAMES[[kk]]
[16:19:14.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.423]                     next
[16:19:14.423]                   args[[name]] <- ""
[16:19:14.423]                 }
[16:19:14.423]                 NAMES <- toupper(removed)
[16:19:14.423]                 for (kk in seq_along(NAMES)) {
[16:19:14.423]                   name <- removed[[kk]]
[16:19:14.423]                   NAME <- NAMES[[kk]]
[16:19:14.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.423]                     next
[16:19:14.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.423]                 }
[16:19:14.423]                 if (length(args) > 0) 
[16:19:14.423]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.423]             }
[16:19:14.423]             else {
[16:19:14.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.423]             }
[16:19:14.423]             {
[16:19:14.423]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.423]                   0L) {
[16:19:14.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.423]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.423]                   base::options(opts)
[16:19:14.423]                 }
[16:19:14.423]                 {
[16:19:14.423]                   {
[16:19:14.423]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.423]                     NULL
[16:19:14.423]                   }
[16:19:14.423]                   options(future.plan = NULL)
[16:19:14.423]                   if (is.na(NA_character_)) 
[16:19:14.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.423]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.423]                     .init = FALSE)
[16:19:14.423]                 }
[16:19:14.423]             }
[16:19:14.423]         }
[16:19:14.423]     })
[16:19:14.423]     if (TRUE) {
[16:19:14.423]         base::sink(type = "output", split = FALSE)
[16:19:14.423]         if (TRUE) {
[16:19:14.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.423]         }
[16:19:14.423]         else {
[16:19:14.423]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.423]         }
[16:19:14.423]         base::close(...future.stdout)
[16:19:14.423]         ...future.stdout <- NULL
[16:19:14.423]     }
[16:19:14.423]     ...future.result$conditions <- ...future.conditions
[16:19:14.423]     ...future.result$finished <- base::Sys.time()
[16:19:14.423]     ...future.result
[16:19:14.423] }
[16:19:14.426] assign_globals() ...
[16:19:14.426] List of 11
[16:19:14.426]  $ ...future.FUN            :function (x, ...)  
[16:19:14.426]  $ x_FUN                    :function (x, ...)  
[16:19:14.426]  $ times                    : int 5
[16:19:14.426]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.426]  $ stop_if_not              :function (...)  
[16:19:14.426]  $ dim                      : NULL
[16:19:14.426]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.426]  $ future.call.arguments    : list()
[16:19:14.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.426]  $ ...future.elements_ii    :List of 1
[16:19:14.426]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:19:14.426]  $ ...future.seeds_ii       : NULL
[16:19:14.426]  $ ...future.globals.maxSize: NULL
[16:19:14.426]  - attr(*, "where")=List of 11
[16:19:14.426]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.426]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.426]  - attr(*, "resolved")= logi FALSE
[16:19:14.426]  - attr(*, "total_size")= num 95528
[16:19:14.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.426]  - attr(*, "already-done")= logi TRUE
[16:19:14.433] - copied ‘...future.FUN’ to environment
[16:19:14.433] - copied ‘x_FUN’ to environment
[16:19:14.433] - copied ‘times’ to environment
[16:19:14.433] - copied ‘stopf’ to environment
[16:19:14.433] - copied ‘stop_if_not’ to environment
[16:19:14.433] - copied ‘dim’ to environment
[16:19:14.434] - copied ‘valid_types’ to environment
[16:19:14.434] - copied ‘future.call.arguments’ to environment
[16:19:14.434] - copied ‘...future.elements_ii’ to environment
[16:19:14.434] - copied ‘...future.seeds_ii’ to environment
[16:19:14.434] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.434] assign_globals() ... done
[16:19:14.434] requestCore(): workers = 2
[16:19:14.436] MulticoreFuture started
[16:19:14.437] - Launch lazy future ... done
[16:19:14.437] run() for ‘MulticoreFuture’ ... done
[16:19:14.437] Created future:
[16:19:14.438] plan(): Setting new future strategy stack:
[16:19:14.438] List of future strategies:
[16:19:14.438] 1. sequential:
[16:19:14.438]    - args: function (..., envir = parent.frame())
[16:19:14.438]    - tweaked: FALSE
[16:19:14.438]    - call: NULL
[16:19:14.439] plan(): nbrOfWorkers() = 1
[16:19:14.442] plan(): Setting new future strategy stack:
[16:19:14.442] List of future strategies:
[16:19:14.442] 1. multicore:
[16:19:14.442]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.442]    - tweaked: FALSE
[16:19:14.442]    - call: plan(strategy)
[16:19:14.447] plan(): nbrOfWorkers() = 2
[16:19:14.438] MulticoreFuture:
[16:19:14.438] Label: ‘future_vapply-1’
[16:19:14.438] Expression:
[16:19:14.438] {
[16:19:14.438]     do.call(function(...) {
[16:19:14.438]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.438]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.438]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.438]             on.exit(options(oopts), add = TRUE)
[16:19:14.438]         }
[16:19:14.438]         {
[16:19:14.438]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.438]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.438]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.438]             })
[16:19:14.438]         }
[16:19:14.438]     }, args = future.call.arguments)
[16:19:14.438] }
[16:19:14.438] Lazy evaluation: FALSE
[16:19:14.438] Asynchronous evaluation: TRUE
[16:19:14.438] Local evaluation: TRUE
[16:19:14.438] Environment: R_GlobalEnv
[16:19:14.438] Capture standard output: TRUE
[16:19:14.438] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.438] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.438] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:14.438] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.438] Resolved: TRUE
[16:19:14.438] Value: <not collected>
[16:19:14.438] Conditions captured: <none>
[16:19:14.438] Early signaling: FALSE
[16:19:14.438] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.438] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.448] Chunk #1 of 2 ... DONE
[16:19:14.448] Chunk #2 of 2 ...
[16:19:14.449]  - Finding globals in 'X' for chunk #2 ...
[16:19:14.449] getGlobalsAndPackages() ...
[16:19:14.449] Searching for globals...
[16:19:14.449] 
[16:19:14.450] Searching for globals ... DONE
[16:19:14.450] - globals: [0] <none>
[16:19:14.450] getGlobalsAndPackages() ... DONE
[16:19:14.450]    + additional globals found: [n=0] 
[16:19:14.450]    + additional namespaces needed: [n=0] 
[16:19:14.450]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:14.450]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.450]  - seeds: <none>
[16:19:14.450]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.451] getGlobalsAndPackages() ...
[16:19:14.451] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.451] Resolving globals: FALSE
[16:19:14.451] Tweak future expression to call with '...' arguments ...
[16:19:14.451] {
[16:19:14.451]     do.call(function(...) {
[16:19:14.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.451]             on.exit(options(oopts), add = TRUE)
[16:19:14.451]         }
[16:19:14.451]         {
[16:19:14.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.451]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.451]             })
[16:19:14.451]         }
[16:19:14.451]     }, args = future.call.arguments)
[16:19:14.451] }
[16:19:14.452] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.453] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.453] - packages: [2] ‘stats’, ‘future.apply’
[16:19:14.453] getGlobalsAndPackages() ... DONE
[16:19:14.454] run() for ‘Future’ ...
[16:19:14.457] - state: ‘created’
[16:19:14.457] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.464] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.465] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.465]   - Field: ‘label’
[16:19:14.465]   - Field: ‘local’
[16:19:14.465]   - Field: ‘owner’
[16:19:14.465]   - Field: ‘envir’
[16:19:14.466]   - Field: ‘workers’
[16:19:14.466]   - Field: ‘packages’
[16:19:14.466]   - Field: ‘gc’
[16:19:14.466]   - Field: ‘job’
[16:19:14.467]   - Field: ‘conditions’
[16:19:14.467]   - Field: ‘expr’
[16:19:14.467]   - Field: ‘uuid’
[16:19:14.467]   - Field: ‘seed’
[16:19:14.468]   - Field: ‘version’
[16:19:14.468]   - Field: ‘result’
[16:19:14.468]   - Field: ‘asynchronous’
[16:19:14.468]   - Field: ‘calls’
[16:19:14.468]   - Field: ‘globals’
[16:19:14.469]   - Field: ‘stdout’
[16:19:14.469]   - Field: ‘earlySignal’
[16:19:14.469]   - Field: ‘lazy’
[16:19:14.469]   - Field: ‘state’
[16:19:14.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.470] - Launch lazy future ...
[16:19:14.470] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:14.471] Packages needed by future strategies (n = 0): <none>
[16:19:14.472] {
[16:19:14.472]     {
[16:19:14.472]         {
[16:19:14.472]             ...future.startTime <- base::Sys.time()
[16:19:14.472]             {
[16:19:14.472]                 {
[16:19:14.472]                   {
[16:19:14.472]                     {
[16:19:14.472]                       {
[16:19:14.472]                         base::local({
[16:19:14.472]                           has_future <- base::requireNamespace("future", 
[16:19:14.472]                             quietly = TRUE)
[16:19:14.472]                           if (has_future) {
[16:19:14.472]                             ns <- base::getNamespace("future")
[16:19:14.472]                             version <- ns[[".package"]][["version"]]
[16:19:14.472]                             if (is.null(version)) 
[16:19:14.472]                               version <- utils::packageVersion("future")
[16:19:14.472]                           }
[16:19:14.472]                           else {
[16:19:14.472]                             version <- NULL
[16:19:14.472]                           }
[16:19:14.472]                           if (!has_future || version < "1.8.0") {
[16:19:14.472]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.472]                               "", base::R.version$version.string), 
[16:19:14.472]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.472]                                 base::R.version$platform, 8 * 
[16:19:14.472]                                   base::.Machine$sizeof.pointer), 
[16:19:14.472]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.472]                                 "release", "version")], collapse = " "), 
[16:19:14.472]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.472]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.472]                               info)
[16:19:14.472]                             info <- base::paste(info, collapse = "; ")
[16:19:14.472]                             if (!has_future) {
[16:19:14.472]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.472]                                 info)
[16:19:14.472]                             }
[16:19:14.472]                             else {
[16:19:14.472]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.472]                                 info, version)
[16:19:14.472]                             }
[16:19:14.472]                             base::stop(msg)
[16:19:14.472]                           }
[16:19:14.472]                         })
[16:19:14.472]                       }
[16:19:14.472]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.472]                       base::options(mc.cores = 1L)
[16:19:14.472]                     }
[16:19:14.472]                     base::local({
[16:19:14.472]                       for (pkg in c("stats", "future.apply")) {
[16:19:14.472]                         base::loadNamespace(pkg)
[16:19:14.472]                         base::library(pkg, character.only = TRUE)
[16:19:14.472]                       }
[16:19:14.472]                     })
[16:19:14.472]                   }
[16:19:14.472]                   ...future.strategy.old <- future::plan("list")
[16:19:14.472]                   options(future.plan = NULL)
[16:19:14.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.472]                 }
[16:19:14.472]                 ...future.workdir <- getwd()
[16:19:14.472]             }
[16:19:14.472]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.472]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.472]         }
[16:19:14.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.472]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.472]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.472]             base::names(...future.oldOptions))
[16:19:14.472]     }
[16:19:14.472]     if (FALSE) {
[16:19:14.472]     }
[16:19:14.472]     else {
[16:19:14.472]         if (TRUE) {
[16:19:14.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.472]                 open = "w")
[16:19:14.472]         }
[16:19:14.472]         else {
[16:19:14.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.472]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.472]         }
[16:19:14.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.472]             base::sink(type = "output", split = FALSE)
[16:19:14.472]             base::close(...future.stdout)
[16:19:14.472]         }, add = TRUE)
[16:19:14.472]     }
[16:19:14.472]     ...future.frame <- base::sys.nframe()
[16:19:14.472]     ...future.conditions <- base::list()
[16:19:14.472]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.472]     if (FALSE) {
[16:19:14.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.472]     }
[16:19:14.472]     ...future.result <- base::tryCatch({
[16:19:14.472]         base::withCallingHandlers({
[16:19:14.472]             ...future.value <- base::withVisible(base::local({
[16:19:14.472]                 withCallingHandlers({
[16:19:14.472]                   {
[16:19:14.472]                     do.call(function(...) {
[16:19:14.472]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.472]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.472]                         ...future.globals.maxSize)) {
[16:19:14.472]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.472]                         on.exit(options(oopts), add = TRUE)
[16:19:14.472]                       }
[16:19:14.472]                       {
[16:19:14.472]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.472]                           FUN = function(jj) {
[16:19:14.472]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.472]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.472]                           })
[16:19:14.472]                       }
[16:19:14.472]                     }, args = future.call.arguments)
[16:19:14.472]                   }
[16:19:14.472]                 }, immediateCondition = function(cond) {
[16:19:14.472]                   save_rds <- function (object, pathname, ...) 
[16:19:14.472]                   {
[16:19:14.472]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.472]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.472]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.472]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.472]                         fi_tmp[["mtime"]])
[16:19:14.472]                     }
[16:19:14.472]                     tryCatch({
[16:19:14.472]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.472]                     }, error = function(ex) {
[16:19:14.472]                       msg <- conditionMessage(ex)
[16:19:14.472]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.472]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.472]                         fi_tmp[["mtime"]], msg)
[16:19:14.472]                       ex$message <- msg
[16:19:14.472]                       stop(ex)
[16:19:14.472]                     })
[16:19:14.472]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.472]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.472]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.472]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.472]                       fi <- file.info(pathname)
[16:19:14.472]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.472]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.472]                         fi[["size"]], fi[["mtime"]])
[16:19:14.472]                       stop(msg)
[16:19:14.472]                     }
[16:19:14.472]                     invisible(pathname)
[16:19:14.472]                   }
[16:19:14.472]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.472]                     rootPath = tempdir()) 
[16:19:14.472]                   {
[16:19:14.472]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.472]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.472]                       tmpdir = path, fileext = ".rds")
[16:19:14.472]                     save_rds(obj, file)
[16:19:14.472]                   }
[16:19:14.472]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.472]                   {
[16:19:14.472]                     inherits <- base::inherits
[16:19:14.472]                     invokeRestart <- base::invokeRestart
[16:19:14.472]                     is.null <- base::is.null
[16:19:14.472]                     muffled <- FALSE
[16:19:14.472]                     if (inherits(cond, "message")) {
[16:19:14.472]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.472]                       if (muffled) 
[16:19:14.472]                         invokeRestart("muffleMessage")
[16:19:14.472]                     }
[16:19:14.472]                     else if (inherits(cond, "warning")) {
[16:19:14.472]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.472]                       if (muffled) 
[16:19:14.472]                         invokeRestart("muffleWarning")
[16:19:14.472]                     }
[16:19:14.472]                     else if (inherits(cond, "condition")) {
[16:19:14.472]                       if (!is.null(pattern)) {
[16:19:14.472]                         computeRestarts <- base::computeRestarts
[16:19:14.472]                         grepl <- base::grepl
[16:19:14.472]                         restarts <- computeRestarts(cond)
[16:19:14.472]                         for (restart in restarts) {
[16:19:14.472]                           name <- restart$name
[16:19:14.472]                           if (is.null(name)) 
[16:19:14.472]                             next
[16:19:14.472]                           if (!grepl(pattern, name)) 
[16:19:14.472]                             next
[16:19:14.472]                           invokeRestart(restart)
[16:19:14.472]                           muffled <- TRUE
[16:19:14.472]                           break
[16:19:14.472]                         }
[16:19:14.472]                       }
[16:19:14.472]                     }
[16:19:14.472]                     invisible(muffled)
[16:19:14.472]                   }
[16:19:14.472]                   muffleCondition(cond)
[16:19:14.472]                 })
[16:19:14.472]             }))
[16:19:14.472]             future::FutureResult(value = ...future.value$value, 
[16:19:14.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.472]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.472]                     ...future.globalenv.names))
[16:19:14.472]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.472]         }, condition = base::local({
[16:19:14.472]             c <- base::c
[16:19:14.472]             inherits <- base::inherits
[16:19:14.472]             invokeRestart <- base::invokeRestart
[16:19:14.472]             length <- base::length
[16:19:14.472]             list <- base::list
[16:19:14.472]             seq.int <- base::seq.int
[16:19:14.472]             signalCondition <- base::signalCondition
[16:19:14.472]             sys.calls <- base::sys.calls
[16:19:14.472]             `[[` <- base::`[[`
[16:19:14.472]             `+` <- base::`+`
[16:19:14.472]             `<<-` <- base::`<<-`
[16:19:14.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.472]                   3L)]
[16:19:14.472]             }
[16:19:14.472]             function(cond) {
[16:19:14.472]                 is_error <- inherits(cond, "error")
[16:19:14.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.472]                   NULL)
[16:19:14.472]                 if (is_error) {
[16:19:14.472]                   sessionInformation <- function() {
[16:19:14.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.472]                       search = base::search(), system = base::Sys.info())
[16:19:14.472]                   }
[16:19:14.472]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.472]                     cond$call), session = sessionInformation(), 
[16:19:14.472]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.472]                   signalCondition(cond)
[16:19:14.472]                 }
[16:19:14.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.472]                 "immediateCondition"))) {
[16:19:14.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.472]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.472]                   if (TRUE && !signal) {
[16:19:14.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.472]                     {
[16:19:14.472]                       inherits <- base::inherits
[16:19:14.472]                       invokeRestart <- base::invokeRestart
[16:19:14.472]                       is.null <- base::is.null
[16:19:14.472]                       muffled <- FALSE
[16:19:14.472]                       if (inherits(cond, "message")) {
[16:19:14.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.472]                         if (muffled) 
[16:19:14.472]                           invokeRestart("muffleMessage")
[16:19:14.472]                       }
[16:19:14.472]                       else if (inherits(cond, "warning")) {
[16:19:14.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.472]                         if (muffled) 
[16:19:14.472]                           invokeRestart("muffleWarning")
[16:19:14.472]                       }
[16:19:14.472]                       else if (inherits(cond, "condition")) {
[16:19:14.472]                         if (!is.null(pattern)) {
[16:19:14.472]                           computeRestarts <- base::computeRestarts
[16:19:14.472]                           grepl <- base::grepl
[16:19:14.472]                           restarts <- computeRestarts(cond)
[16:19:14.472]                           for (restart in restarts) {
[16:19:14.472]                             name <- restart$name
[16:19:14.472]                             if (is.null(name)) 
[16:19:14.472]                               next
[16:19:14.472]                             if (!grepl(pattern, name)) 
[16:19:14.472]                               next
[16:19:14.472]                             invokeRestart(restart)
[16:19:14.472]                             muffled <- TRUE
[16:19:14.472]                             break
[16:19:14.472]                           }
[16:19:14.472]                         }
[16:19:14.472]                       }
[16:19:14.472]                       invisible(muffled)
[16:19:14.472]                     }
[16:19:14.472]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.472]                   }
[16:19:14.472]                 }
[16:19:14.472]                 else {
[16:19:14.472]                   if (TRUE) {
[16:19:14.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.472]                     {
[16:19:14.472]                       inherits <- base::inherits
[16:19:14.472]                       invokeRestart <- base::invokeRestart
[16:19:14.472]                       is.null <- base::is.null
[16:19:14.472]                       muffled <- FALSE
[16:19:14.472]                       if (inherits(cond, "message")) {
[16:19:14.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.472]                         if (muffled) 
[16:19:14.472]                           invokeRestart("muffleMessage")
[16:19:14.472]                       }
[16:19:14.472]                       else if (inherits(cond, "warning")) {
[16:19:14.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.472]                         if (muffled) 
[16:19:14.472]                           invokeRestart("muffleWarning")
[16:19:14.472]                       }
[16:19:14.472]                       else if (inherits(cond, "condition")) {
[16:19:14.472]                         if (!is.null(pattern)) {
[16:19:14.472]                           computeRestarts <- base::computeRestarts
[16:19:14.472]                           grepl <- base::grepl
[16:19:14.472]                           restarts <- computeRestarts(cond)
[16:19:14.472]                           for (restart in restarts) {
[16:19:14.472]                             name <- restart$name
[16:19:14.472]                             if (is.null(name)) 
[16:19:14.472]                               next
[16:19:14.472]                             if (!grepl(pattern, name)) 
[16:19:14.472]                               next
[16:19:14.472]                             invokeRestart(restart)
[16:19:14.472]                             muffled <- TRUE
[16:19:14.472]                             break
[16:19:14.472]                           }
[16:19:14.472]                         }
[16:19:14.472]                       }
[16:19:14.472]                       invisible(muffled)
[16:19:14.472]                     }
[16:19:14.472]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.472]                   }
[16:19:14.472]                 }
[16:19:14.472]             }
[16:19:14.472]         }))
[16:19:14.472]     }, error = function(ex) {
[16:19:14.472]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.472]                 ...future.rng), started = ...future.startTime, 
[16:19:14.472]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.472]             version = "1.8"), class = "FutureResult")
[16:19:14.472]     }, finally = {
[16:19:14.472]         if (!identical(...future.workdir, getwd())) 
[16:19:14.472]             setwd(...future.workdir)
[16:19:14.472]         {
[16:19:14.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.472]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.472]             }
[16:19:14.472]             base::options(...future.oldOptions)
[16:19:14.472]             if (.Platform$OS.type == "windows") {
[16:19:14.472]                 old_names <- names(...future.oldEnvVars)
[16:19:14.472]                 envs <- base::Sys.getenv()
[16:19:14.472]                 names <- names(envs)
[16:19:14.472]                 common <- intersect(names, old_names)
[16:19:14.472]                 added <- setdiff(names, old_names)
[16:19:14.472]                 removed <- setdiff(old_names, names)
[16:19:14.472]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.472]                   envs[common]]
[16:19:14.472]                 NAMES <- toupper(changed)
[16:19:14.472]                 args <- list()
[16:19:14.472]                 for (kk in seq_along(NAMES)) {
[16:19:14.472]                   name <- changed[[kk]]
[16:19:14.472]                   NAME <- NAMES[[kk]]
[16:19:14.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.472]                     next
[16:19:14.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.472]                 }
[16:19:14.472]                 NAMES <- toupper(added)
[16:19:14.472]                 for (kk in seq_along(NAMES)) {
[16:19:14.472]                   name <- added[[kk]]
[16:19:14.472]                   NAME <- NAMES[[kk]]
[16:19:14.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.472]                     next
[16:19:14.472]                   args[[name]] <- ""
[16:19:14.472]                 }
[16:19:14.472]                 NAMES <- toupper(removed)
[16:19:14.472]                 for (kk in seq_along(NAMES)) {
[16:19:14.472]                   name <- removed[[kk]]
[16:19:14.472]                   NAME <- NAMES[[kk]]
[16:19:14.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.472]                     next
[16:19:14.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.472]                 }
[16:19:14.472]                 if (length(args) > 0) 
[16:19:14.472]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.472]             }
[16:19:14.472]             else {
[16:19:14.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.472]             }
[16:19:14.472]             {
[16:19:14.472]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.472]                   0L) {
[16:19:14.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.472]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.472]                   base::options(opts)
[16:19:14.472]                 }
[16:19:14.472]                 {
[16:19:14.472]                   {
[16:19:14.472]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.472]                     NULL
[16:19:14.472]                   }
[16:19:14.472]                   options(future.plan = NULL)
[16:19:14.472]                   if (is.na(NA_character_)) 
[16:19:14.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.472]                     .init = FALSE)
[16:19:14.472]                 }
[16:19:14.472]             }
[16:19:14.472]         }
[16:19:14.472]     })
[16:19:14.472]     if (TRUE) {
[16:19:14.472]         base::sink(type = "output", split = FALSE)
[16:19:14.472]         if (TRUE) {
[16:19:14.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.472]         }
[16:19:14.472]         else {
[16:19:14.472]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.472]         }
[16:19:14.472]         base::close(...future.stdout)
[16:19:14.472]         ...future.stdout <- NULL
[16:19:14.472]     }
[16:19:14.472]     ...future.result$conditions <- ...future.conditions
[16:19:14.472]     ...future.result$finished <- base::Sys.time()
[16:19:14.472]     ...future.result
[16:19:14.472] }
[16:19:14.475] assign_globals() ...
[16:19:14.475] List of 11
[16:19:14.475]  $ ...future.FUN            :function (x, ...)  
[16:19:14.475]  $ x_FUN                    :function (x, ...)  
[16:19:14.475]  $ times                    : int 5
[16:19:14.475]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.475]  $ stop_if_not              :function (...)  
[16:19:14.475]  $ dim                      : NULL
[16:19:14.475]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.475]  $ future.call.arguments    : list()
[16:19:14.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.475]  $ ...future.elements_ii    :List of 2
[16:19:14.475]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:19:14.475]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:19:14.475]  $ ...future.seeds_ii       : NULL
[16:19:14.475]  $ ...future.globals.maxSize: NULL
[16:19:14.475]  - attr(*, "where")=List of 11
[16:19:14.475]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.475]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.475]  - attr(*, "resolved")= logi FALSE
[16:19:14.475]  - attr(*, "total_size")= num 95528
[16:19:14.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.475]  - attr(*, "already-done")= logi TRUE
[16:19:14.485] - copied ‘...future.FUN’ to environment
[16:19:14.485] - copied ‘x_FUN’ to environment
[16:19:14.486] - copied ‘times’ to environment
[16:19:14.486] - copied ‘stopf’ to environment
[16:19:14.486] - copied ‘stop_if_not’ to environment
[16:19:14.486] - copied ‘dim’ to environment
[16:19:14.486] - copied ‘valid_types’ to environment
[16:19:14.486] - copied ‘future.call.arguments’ to environment
[16:19:14.486] - copied ‘...future.elements_ii’ to environment
[16:19:14.486] - copied ‘...future.seeds_ii’ to environment
[16:19:14.486] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.486] assign_globals() ... done
[16:19:14.487] requestCore(): workers = 2
[16:19:14.489] MulticoreFuture started
[16:19:14.489] - Launch lazy future ... done
[16:19:14.489] run() for ‘MulticoreFuture’ ... done
[16:19:14.490] Created future:
[16:19:14.491] plan(): Setting new future strategy stack:
[16:19:14.491] List of future strategies:
[16:19:14.491] 1. sequential:
[16:19:14.491]    - args: function (..., envir = parent.frame())
[16:19:14.491]    - tweaked: FALSE
[16:19:14.491]    - call: NULL
[16:19:14.491] plan(): nbrOfWorkers() = 1
[16:19:14.494] plan(): Setting new future strategy stack:
[16:19:14.494] List of future strategies:
[16:19:14.494] 1. multicore:
[16:19:14.494]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.494]    - tweaked: FALSE
[16:19:14.494]    - call: plan(strategy)
[16:19:14.490] MulticoreFuture:
[16:19:14.490] Label: ‘future_vapply-2’
[16:19:14.490] Expression:
[16:19:14.490] {
[16:19:14.490]     do.call(function(...) {
[16:19:14.490]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.490]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.490]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.490]             on.exit(options(oopts), add = TRUE)
[16:19:14.490]         }
[16:19:14.490]         {
[16:19:14.490]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.490]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.490]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.490]             })
[16:19:14.490]         }
[16:19:14.490]     }, args = future.call.arguments)
[16:19:14.490] }
[16:19:14.490] Lazy evaluation: FALSE
[16:19:14.490] Asynchronous evaluation: TRUE
[16:19:14.490] Local evaluation: TRUE
[16:19:14.490] Environment: R_GlobalEnv
[16:19:14.490] Capture standard output: TRUE
[16:19:14.490] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.490] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.490] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:14.490] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.490] Resolved: FALSE
[16:19:14.490] Value: <not collected>
[16:19:14.490] Conditions captured: <none>
[16:19:14.490] Early signaling: FALSE
[16:19:14.490] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.490] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.503] Chunk #2 of 2 ... DONE
[16:19:14.503] Launching 2 futures (chunks) ... DONE
[16:19:14.503] Resolving 2 futures (chunks) ...
[16:19:14.504] resolve() on list ...
[16:19:14.504]  recursive: 0
[16:19:14.504]  length: 2
[16:19:14.504] 
[16:19:14.505] Future #1
[16:19:14.505] result() for MulticoreFuture ...
[16:19:14.505] plan(): nbrOfWorkers() = 2
[16:19:14.506] result() for MulticoreFuture ...
[16:19:14.506] result() for MulticoreFuture ... done
[16:19:14.509] result() for MulticoreFuture ... done
[16:19:14.509] result() for MulticoreFuture ...
[16:19:14.509] result() for MulticoreFuture ... done
[16:19:14.510] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:14.510] - nx: 2
[16:19:14.510] - relay: TRUE
[16:19:14.510] - stdout: TRUE
[16:19:14.511] - signal: TRUE
[16:19:14.511] - resignal: FALSE
[16:19:14.511] - force: TRUE
[16:19:14.512] - relayed: [n=2] FALSE, FALSE
[16:19:14.512] - queued futures: [n=2] FALSE, FALSE
[16:19:14.512]  - until=1
[16:19:14.513]  - relaying element #1
[16:19:14.513] result() for MulticoreFuture ...
[16:19:14.513] result() for MulticoreFuture ... done
[16:19:14.513] result() for MulticoreFuture ...
[16:19:14.514] result() for MulticoreFuture ... done
[16:19:14.514] result() for MulticoreFuture ...
[16:19:14.514] result() for MulticoreFuture ... done
[16:19:14.514] result() for MulticoreFuture ...
[16:19:14.515] result() for MulticoreFuture ... done
[16:19:14.515] - relayed: [n=2] TRUE, FALSE
[16:19:14.515] - queued futures: [n=2] TRUE, FALSE
[16:19:14.515] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:14.515]  length: 1 (resolved future 1)
[16:19:14.516] Future #2
[16:19:14.516] result() for MulticoreFuture ...
[16:19:14.517] result() for MulticoreFuture ...
[16:19:14.517] result() for MulticoreFuture ... done
[16:19:14.518] result() for MulticoreFuture ... done
[16:19:14.518] result() for MulticoreFuture ...
[16:19:14.518] result() for MulticoreFuture ... done
[16:19:14.519] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:14.519] - nx: 2
[16:19:14.519] - relay: TRUE
[16:19:14.519] - stdout: TRUE
[16:19:14.519] - signal: TRUE
[16:19:14.520] - resignal: FALSE
[16:19:14.520] - force: TRUE
[16:19:14.520] - relayed: [n=2] TRUE, FALSE
[16:19:14.520] - queued futures: [n=2] TRUE, FALSE
[16:19:14.520]  - until=2
[16:19:14.521]  - relaying element #2
[16:19:14.521] result() for MulticoreFuture ...
[16:19:14.521] result() for MulticoreFuture ... done
[16:19:14.521] result() for MulticoreFuture ...
[16:19:14.521] result() for MulticoreFuture ... done
[16:19:14.521] result() for MulticoreFuture ...
[16:19:14.521] result() for MulticoreFuture ... done
[16:19:14.522] result() for MulticoreFuture ...
[16:19:14.522] result() for MulticoreFuture ... done
[16:19:14.522] - relayed: [n=2] TRUE, TRUE
[16:19:14.522] - queued futures: [n=2] TRUE, TRUE
[16:19:14.522] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:14.522]  length: 0 (resolved future 2)
[16:19:14.522] Relaying remaining futures
[16:19:14.522] signalConditionsASAP(NULL, pos=0) ...
[16:19:14.522] - nx: 2
[16:19:14.523] - relay: TRUE
[16:19:14.523] - stdout: TRUE
[16:19:14.523] - signal: TRUE
[16:19:14.523] - resignal: FALSE
[16:19:14.523] - force: TRUE
[16:19:14.523] - relayed: [n=2] TRUE, TRUE
[16:19:14.523] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:14.523] - relayed: [n=2] TRUE, TRUE
[16:19:14.523] - queued futures: [n=2] TRUE, TRUE
[16:19:14.524] signalConditionsASAP(NULL, pos=0) ... done
[16:19:14.524] resolve() on list ... DONE
[16:19:14.524] result() for MulticoreFuture ...
[16:19:14.524] result() for MulticoreFuture ... done
[16:19:14.524] result() for MulticoreFuture ...
[16:19:14.524] result() for MulticoreFuture ... done
[16:19:14.524] result() for MulticoreFuture ...
[16:19:14.524] result() for MulticoreFuture ... done
[16:19:14.525] result() for MulticoreFuture ...
[16:19:14.525] result() for MulticoreFuture ... done
[16:19:14.525]  - Number of value chunks collected: 2
[16:19:14.525] Resolving 2 futures (chunks) ... DONE
[16:19:14.525] Reducing values from 2 chunks ...
[16:19:14.525]  - Number of values collected after concatenation: 3
[16:19:14.525]  - Number of values expected: 3
[16:19:14.525] Reducing values from 2 chunks ... DONE
[16:19:14.525] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:19:14.528] future_lapply() ...
[16:19:14.536] Number of chunks: 2
[16:19:14.536] getGlobalsAndPackagesXApply() ...
[16:19:14.536]  - future.globals: TRUE
[16:19:14.536] getGlobalsAndPackages() ...
[16:19:14.536] Searching for globals...
[16:19:14.544] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:19:14.544] Searching for globals ... DONE
[16:19:14.544] Resolving globals: FALSE
[16:19:14.545] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:19:14.545] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:19:14.545] - globals: [1] ‘FUN’
[16:19:14.545] - packages: [1] ‘stats’
[16:19:14.545] getGlobalsAndPackages() ... DONE
[16:19:14.545]  - globals found/used: [n=1] ‘FUN’
[16:19:14.546]  - needed namespaces: [n=1] ‘stats’
[16:19:14.546] Finding globals ... DONE
[16:19:14.546]  - use_args: TRUE
[16:19:14.546]  - Getting '...' globals ...
[16:19:14.546] resolve() on list ...
[16:19:14.546]  recursive: 0
[16:19:14.546]  length: 1
[16:19:14.546]  elements: ‘...’
[16:19:14.547]  length: 0 (resolved future 1)
[16:19:14.547] resolve() on list ... DONE
[16:19:14.547]    - '...' content: [n=0] 
[16:19:14.547] List of 1
[16:19:14.547]  $ ...: list()
[16:19:14.547]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.547]  - attr(*, "where")=List of 1
[16:19:14.547]   ..$ ...:<environment: 0x56199d024c50> 
[16:19:14.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.547]  - attr(*, "resolved")= logi TRUE
[16:19:14.547]  - attr(*, "total_size")= num NA
[16:19:14.550]  - Getting '...' globals ... DONE
[16:19:14.550] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:14.550] List of 2
[16:19:14.550]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:19:14.550]  $ ...          : list()
[16:19:14.550]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.550]  - attr(*, "where")=List of 2
[16:19:14.550]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:14.550]   ..$ ...          :<environment: 0x56199d024c50> 
[16:19:14.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.550]  - attr(*, "resolved")= logi FALSE
[16:19:14.550]  - attr(*, "total_size")= num 46960
[16:19:14.553] Packages to be attached in all futures: [n=1] ‘stats’
[16:19:14.553] getGlobalsAndPackagesXApply() ... DONE
[16:19:14.553] Number of futures (= number of chunks): 2
[16:19:14.553] Launching 2 futures (chunks) ...
[16:19:14.553] Chunk #1 of 2 ...
[16:19:14.553]  - Finding globals in 'X' for chunk #1 ...
[16:19:14.553] getGlobalsAndPackages() ...
[16:19:14.553] Searching for globals...
[16:19:14.554] 
[16:19:14.554] Searching for globals ... DONE
[16:19:14.554] - globals: [0] <none>
[16:19:14.554] getGlobalsAndPackages() ... DONE
[16:19:14.554]    + additional globals found: [n=0] 
[16:19:14.554]    + additional namespaces needed: [n=0] 
[16:19:14.554]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:14.554]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.554]  - seeds: <none>
[16:19:14.554]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.555] getGlobalsAndPackages() ...
[16:19:14.555] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.555] Resolving globals: FALSE
[16:19:14.555] Tweak future expression to call with '...' arguments ...
[16:19:14.555] {
[16:19:14.555]     do.call(function(...) {
[16:19:14.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.555]             on.exit(options(oopts), add = TRUE)
[16:19:14.555]         }
[16:19:14.555]         {
[16:19:14.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.555]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.555]             })
[16:19:14.555]         }
[16:19:14.555]     }, args = future.call.arguments)
[16:19:14.555] }
[16:19:14.555] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.556] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.556] - packages: [1] ‘stats’
[16:19:14.556] getGlobalsAndPackages() ... DONE
[16:19:14.556] run() for ‘Future’ ...
[16:19:14.556] - state: ‘created’
[16:19:14.557] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.562] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.563]   - Field: ‘label’
[16:19:14.563]   - Field: ‘local’
[16:19:14.563]   - Field: ‘owner’
[16:19:14.563]   - Field: ‘envir’
[16:19:14.563]   - Field: ‘workers’
[16:19:14.563]   - Field: ‘packages’
[16:19:14.563]   - Field: ‘gc’
[16:19:14.564]   - Field: ‘job’
[16:19:14.564]   - Field: ‘conditions’
[16:19:14.564]   - Field: ‘expr’
[16:19:14.564]   - Field: ‘uuid’
[16:19:14.564]   - Field: ‘seed’
[16:19:14.564]   - Field: ‘version’
[16:19:14.564]   - Field: ‘result’
[16:19:14.564]   - Field: ‘asynchronous’
[16:19:14.565]   - Field: ‘calls’
[16:19:14.565]   - Field: ‘globals’
[16:19:14.565]   - Field: ‘stdout’
[16:19:14.565]   - Field: ‘earlySignal’
[16:19:14.565]   - Field: ‘lazy’
[16:19:14.565]   - Field: ‘state’
[16:19:14.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.565] - Launch lazy future ...
[16:19:14.566] Packages needed by the future expression (n = 1): ‘stats’
[16:19:14.566] Packages needed by future strategies (n = 0): <none>
[16:19:14.566] {
[16:19:14.566]     {
[16:19:14.566]         {
[16:19:14.566]             ...future.startTime <- base::Sys.time()
[16:19:14.566]             {
[16:19:14.566]                 {
[16:19:14.566]                   {
[16:19:14.566]                     {
[16:19:14.566]                       {
[16:19:14.566]                         base::local({
[16:19:14.566]                           has_future <- base::requireNamespace("future", 
[16:19:14.566]                             quietly = TRUE)
[16:19:14.566]                           if (has_future) {
[16:19:14.566]                             ns <- base::getNamespace("future")
[16:19:14.566]                             version <- ns[[".package"]][["version"]]
[16:19:14.566]                             if (is.null(version)) 
[16:19:14.566]                               version <- utils::packageVersion("future")
[16:19:14.566]                           }
[16:19:14.566]                           else {
[16:19:14.566]                             version <- NULL
[16:19:14.566]                           }
[16:19:14.566]                           if (!has_future || version < "1.8.0") {
[16:19:14.566]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.566]                               "", base::R.version$version.string), 
[16:19:14.566]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.566]                                 base::R.version$platform, 8 * 
[16:19:14.566]                                   base::.Machine$sizeof.pointer), 
[16:19:14.566]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.566]                                 "release", "version")], collapse = " "), 
[16:19:14.566]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.566]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.566]                               info)
[16:19:14.566]                             info <- base::paste(info, collapse = "; ")
[16:19:14.566]                             if (!has_future) {
[16:19:14.566]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.566]                                 info)
[16:19:14.566]                             }
[16:19:14.566]                             else {
[16:19:14.566]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.566]                                 info, version)
[16:19:14.566]                             }
[16:19:14.566]                             base::stop(msg)
[16:19:14.566]                           }
[16:19:14.566]                         })
[16:19:14.566]                       }
[16:19:14.566]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.566]                       base::options(mc.cores = 1L)
[16:19:14.566]                     }
[16:19:14.566]                     base::local({
[16:19:14.566]                       for (pkg in "stats") {
[16:19:14.566]                         base::loadNamespace(pkg)
[16:19:14.566]                         base::library(pkg, character.only = TRUE)
[16:19:14.566]                       }
[16:19:14.566]                     })
[16:19:14.566]                   }
[16:19:14.566]                   ...future.strategy.old <- future::plan("list")
[16:19:14.566]                   options(future.plan = NULL)
[16:19:14.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.566]                 }
[16:19:14.566]                 ...future.workdir <- getwd()
[16:19:14.566]             }
[16:19:14.566]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.566]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.566]         }
[16:19:14.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.566]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.566]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.566]             base::names(...future.oldOptions))
[16:19:14.566]     }
[16:19:14.566]     if (FALSE) {
[16:19:14.566]     }
[16:19:14.566]     else {
[16:19:14.566]         if (TRUE) {
[16:19:14.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.566]                 open = "w")
[16:19:14.566]         }
[16:19:14.566]         else {
[16:19:14.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.566]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.566]         }
[16:19:14.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.566]             base::sink(type = "output", split = FALSE)
[16:19:14.566]             base::close(...future.stdout)
[16:19:14.566]         }, add = TRUE)
[16:19:14.566]     }
[16:19:14.566]     ...future.frame <- base::sys.nframe()
[16:19:14.566]     ...future.conditions <- base::list()
[16:19:14.566]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.566]     if (FALSE) {
[16:19:14.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.566]     }
[16:19:14.566]     ...future.result <- base::tryCatch({
[16:19:14.566]         base::withCallingHandlers({
[16:19:14.566]             ...future.value <- base::withVisible(base::local({
[16:19:14.566]                 withCallingHandlers({
[16:19:14.566]                   {
[16:19:14.566]                     do.call(function(...) {
[16:19:14.566]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.566]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.566]                         ...future.globals.maxSize)) {
[16:19:14.566]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.566]                         on.exit(options(oopts), add = TRUE)
[16:19:14.566]                       }
[16:19:14.566]                       {
[16:19:14.566]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.566]                           FUN = function(jj) {
[16:19:14.566]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.566]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.566]                           })
[16:19:14.566]                       }
[16:19:14.566]                     }, args = future.call.arguments)
[16:19:14.566]                   }
[16:19:14.566]                 }, immediateCondition = function(cond) {
[16:19:14.566]                   save_rds <- function (object, pathname, ...) 
[16:19:14.566]                   {
[16:19:14.566]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.566]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.566]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.566]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.566]                         fi_tmp[["mtime"]])
[16:19:14.566]                     }
[16:19:14.566]                     tryCatch({
[16:19:14.566]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.566]                     }, error = function(ex) {
[16:19:14.566]                       msg <- conditionMessage(ex)
[16:19:14.566]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.566]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.566]                         fi_tmp[["mtime"]], msg)
[16:19:14.566]                       ex$message <- msg
[16:19:14.566]                       stop(ex)
[16:19:14.566]                     })
[16:19:14.566]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.566]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.566]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.566]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.566]                       fi <- file.info(pathname)
[16:19:14.566]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.566]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.566]                         fi[["size"]], fi[["mtime"]])
[16:19:14.566]                       stop(msg)
[16:19:14.566]                     }
[16:19:14.566]                     invisible(pathname)
[16:19:14.566]                   }
[16:19:14.566]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.566]                     rootPath = tempdir()) 
[16:19:14.566]                   {
[16:19:14.566]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.566]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.566]                       tmpdir = path, fileext = ".rds")
[16:19:14.566]                     save_rds(obj, file)
[16:19:14.566]                   }
[16:19:14.566]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.566]                   {
[16:19:14.566]                     inherits <- base::inherits
[16:19:14.566]                     invokeRestart <- base::invokeRestart
[16:19:14.566]                     is.null <- base::is.null
[16:19:14.566]                     muffled <- FALSE
[16:19:14.566]                     if (inherits(cond, "message")) {
[16:19:14.566]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.566]                       if (muffled) 
[16:19:14.566]                         invokeRestart("muffleMessage")
[16:19:14.566]                     }
[16:19:14.566]                     else if (inherits(cond, "warning")) {
[16:19:14.566]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.566]                       if (muffled) 
[16:19:14.566]                         invokeRestart("muffleWarning")
[16:19:14.566]                     }
[16:19:14.566]                     else if (inherits(cond, "condition")) {
[16:19:14.566]                       if (!is.null(pattern)) {
[16:19:14.566]                         computeRestarts <- base::computeRestarts
[16:19:14.566]                         grepl <- base::grepl
[16:19:14.566]                         restarts <- computeRestarts(cond)
[16:19:14.566]                         for (restart in restarts) {
[16:19:14.566]                           name <- restart$name
[16:19:14.566]                           if (is.null(name)) 
[16:19:14.566]                             next
[16:19:14.566]                           if (!grepl(pattern, name)) 
[16:19:14.566]                             next
[16:19:14.566]                           invokeRestart(restart)
[16:19:14.566]                           muffled <- TRUE
[16:19:14.566]                           break
[16:19:14.566]                         }
[16:19:14.566]                       }
[16:19:14.566]                     }
[16:19:14.566]                     invisible(muffled)
[16:19:14.566]                   }
[16:19:14.566]                   muffleCondition(cond)
[16:19:14.566]                 })
[16:19:14.566]             }))
[16:19:14.566]             future::FutureResult(value = ...future.value$value, 
[16:19:14.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.566]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.566]                     ...future.globalenv.names))
[16:19:14.566]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.566]         }, condition = base::local({
[16:19:14.566]             c <- base::c
[16:19:14.566]             inherits <- base::inherits
[16:19:14.566]             invokeRestart <- base::invokeRestart
[16:19:14.566]             length <- base::length
[16:19:14.566]             list <- base::list
[16:19:14.566]             seq.int <- base::seq.int
[16:19:14.566]             signalCondition <- base::signalCondition
[16:19:14.566]             sys.calls <- base::sys.calls
[16:19:14.566]             `[[` <- base::`[[`
[16:19:14.566]             `+` <- base::`+`
[16:19:14.566]             `<<-` <- base::`<<-`
[16:19:14.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.566]                   3L)]
[16:19:14.566]             }
[16:19:14.566]             function(cond) {
[16:19:14.566]                 is_error <- inherits(cond, "error")
[16:19:14.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.566]                   NULL)
[16:19:14.566]                 if (is_error) {
[16:19:14.566]                   sessionInformation <- function() {
[16:19:14.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.566]                       search = base::search(), system = base::Sys.info())
[16:19:14.566]                   }
[16:19:14.566]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.566]                     cond$call), session = sessionInformation(), 
[16:19:14.566]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.566]                   signalCondition(cond)
[16:19:14.566]                 }
[16:19:14.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.566]                 "immediateCondition"))) {
[16:19:14.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.566]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.566]                   if (TRUE && !signal) {
[16:19:14.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.566]                     {
[16:19:14.566]                       inherits <- base::inherits
[16:19:14.566]                       invokeRestart <- base::invokeRestart
[16:19:14.566]                       is.null <- base::is.null
[16:19:14.566]                       muffled <- FALSE
[16:19:14.566]                       if (inherits(cond, "message")) {
[16:19:14.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.566]                         if (muffled) 
[16:19:14.566]                           invokeRestart("muffleMessage")
[16:19:14.566]                       }
[16:19:14.566]                       else if (inherits(cond, "warning")) {
[16:19:14.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.566]                         if (muffled) 
[16:19:14.566]                           invokeRestart("muffleWarning")
[16:19:14.566]                       }
[16:19:14.566]                       else if (inherits(cond, "condition")) {
[16:19:14.566]                         if (!is.null(pattern)) {
[16:19:14.566]                           computeRestarts <- base::computeRestarts
[16:19:14.566]                           grepl <- base::grepl
[16:19:14.566]                           restarts <- computeRestarts(cond)
[16:19:14.566]                           for (restart in restarts) {
[16:19:14.566]                             name <- restart$name
[16:19:14.566]                             if (is.null(name)) 
[16:19:14.566]                               next
[16:19:14.566]                             if (!grepl(pattern, name)) 
[16:19:14.566]                               next
[16:19:14.566]                             invokeRestart(restart)
[16:19:14.566]                             muffled <- TRUE
[16:19:14.566]                             break
[16:19:14.566]                           }
[16:19:14.566]                         }
[16:19:14.566]                       }
[16:19:14.566]                       invisible(muffled)
[16:19:14.566]                     }
[16:19:14.566]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.566]                   }
[16:19:14.566]                 }
[16:19:14.566]                 else {
[16:19:14.566]                   if (TRUE) {
[16:19:14.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.566]                     {
[16:19:14.566]                       inherits <- base::inherits
[16:19:14.566]                       invokeRestart <- base::invokeRestart
[16:19:14.566]                       is.null <- base::is.null
[16:19:14.566]                       muffled <- FALSE
[16:19:14.566]                       if (inherits(cond, "message")) {
[16:19:14.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.566]                         if (muffled) 
[16:19:14.566]                           invokeRestart("muffleMessage")
[16:19:14.566]                       }
[16:19:14.566]                       else if (inherits(cond, "warning")) {
[16:19:14.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.566]                         if (muffled) 
[16:19:14.566]                           invokeRestart("muffleWarning")
[16:19:14.566]                       }
[16:19:14.566]                       else if (inherits(cond, "condition")) {
[16:19:14.566]                         if (!is.null(pattern)) {
[16:19:14.566]                           computeRestarts <- base::computeRestarts
[16:19:14.566]                           grepl <- base::grepl
[16:19:14.566]                           restarts <- computeRestarts(cond)
[16:19:14.566]                           for (restart in restarts) {
[16:19:14.566]                             name <- restart$name
[16:19:14.566]                             if (is.null(name)) 
[16:19:14.566]                               next
[16:19:14.566]                             if (!grepl(pattern, name)) 
[16:19:14.566]                               next
[16:19:14.566]                             invokeRestart(restart)
[16:19:14.566]                             muffled <- TRUE
[16:19:14.566]                             break
[16:19:14.566]                           }
[16:19:14.566]                         }
[16:19:14.566]                       }
[16:19:14.566]                       invisible(muffled)
[16:19:14.566]                     }
[16:19:14.566]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.566]                   }
[16:19:14.566]                 }
[16:19:14.566]             }
[16:19:14.566]         }))
[16:19:14.566]     }, error = function(ex) {
[16:19:14.566]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.566]                 ...future.rng), started = ...future.startTime, 
[16:19:14.566]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.566]             version = "1.8"), class = "FutureResult")
[16:19:14.566]     }, finally = {
[16:19:14.566]         if (!identical(...future.workdir, getwd())) 
[16:19:14.566]             setwd(...future.workdir)
[16:19:14.566]         {
[16:19:14.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.566]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.566]             }
[16:19:14.566]             base::options(...future.oldOptions)
[16:19:14.566]             if (.Platform$OS.type == "windows") {
[16:19:14.566]                 old_names <- names(...future.oldEnvVars)
[16:19:14.566]                 envs <- base::Sys.getenv()
[16:19:14.566]                 names <- names(envs)
[16:19:14.566]                 common <- intersect(names, old_names)
[16:19:14.566]                 added <- setdiff(names, old_names)
[16:19:14.566]                 removed <- setdiff(old_names, names)
[16:19:14.566]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.566]                   envs[common]]
[16:19:14.566]                 NAMES <- toupper(changed)
[16:19:14.566]                 args <- list()
[16:19:14.566]                 for (kk in seq_along(NAMES)) {
[16:19:14.566]                   name <- changed[[kk]]
[16:19:14.566]                   NAME <- NAMES[[kk]]
[16:19:14.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.566]                     next
[16:19:14.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.566]                 }
[16:19:14.566]                 NAMES <- toupper(added)
[16:19:14.566]                 for (kk in seq_along(NAMES)) {
[16:19:14.566]                   name <- added[[kk]]
[16:19:14.566]                   NAME <- NAMES[[kk]]
[16:19:14.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.566]                     next
[16:19:14.566]                   args[[name]] <- ""
[16:19:14.566]                 }
[16:19:14.566]                 NAMES <- toupper(removed)
[16:19:14.566]                 for (kk in seq_along(NAMES)) {
[16:19:14.566]                   name <- removed[[kk]]
[16:19:14.566]                   NAME <- NAMES[[kk]]
[16:19:14.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.566]                     next
[16:19:14.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.566]                 }
[16:19:14.566]                 if (length(args) > 0) 
[16:19:14.566]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.566]             }
[16:19:14.566]             else {
[16:19:14.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.566]             }
[16:19:14.566]             {
[16:19:14.566]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.566]                   0L) {
[16:19:14.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.566]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.566]                   base::options(opts)
[16:19:14.566]                 }
[16:19:14.566]                 {
[16:19:14.566]                   {
[16:19:14.566]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.566]                     NULL
[16:19:14.566]                   }
[16:19:14.566]                   options(future.plan = NULL)
[16:19:14.566]                   if (is.na(NA_character_)) 
[16:19:14.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.566]                     .init = FALSE)
[16:19:14.566]                 }
[16:19:14.566]             }
[16:19:14.566]         }
[16:19:14.566]     })
[16:19:14.566]     if (TRUE) {
[16:19:14.566]         base::sink(type = "output", split = FALSE)
[16:19:14.566]         if (TRUE) {
[16:19:14.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.566]         }
[16:19:14.566]         else {
[16:19:14.566]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.566]         }
[16:19:14.566]         base::close(...future.stdout)
[16:19:14.566]         ...future.stdout <- NULL
[16:19:14.566]     }
[16:19:14.566]     ...future.result$conditions <- ...future.conditions
[16:19:14.566]     ...future.result$finished <- base::Sys.time()
[16:19:14.566]     ...future.result
[16:19:14.566] }
[16:19:14.569] assign_globals() ...
[16:19:14.569] List of 5
[16:19:14.569]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:19:14.569]  $ future.call.arguments    : list()
[16:19:14.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.569]  $ ...future.elements_ii    :List of 4
[16:19:14.569]   ..$ : int [1:3] 1 2 3
[16:19:14.569]   ..$ : int [1:4] 1 2 3 4
[16:19:14.569]   ..$ : int [1:5] 1 2 3 4 5
[16:19:14.569]   ..$ : int [1:6] 1 2 3 4 5 6
[16:19:14.569]  $ ...future.seeds_ii       : NULL
[16:19:14.569]  $ ...future.globals.maxSize: NULL
[16:19:14.569]  - attr(*, "where")=List of 5
[16:19:14.569]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.569]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.569]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.569]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.569]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.569]  - attr(*, "resolved")= logi FALSE
[16:19:14.569]  - attr(*, "total_size")= num 46960
[16:19:14.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.569]  - attr(*, "already-done")= logi TRUE
[16:19:14.575] - copied ‘...future.FUN’ to environment
[16:19:14.575] - copied ‘future.call.arguments’ to environment
[16:19:14.575] - copied ‘...future.elements_ii’ to environment
[16:19:14.575] - copied ‘...future.seeds_ii’ to environment
[16:19:14.575] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.575] assign_globals() ... done
[16:19:14.575] requestCore(): workers = 2
[16:19:14.578] MulticoreFuture started
[16:19:14.578] - Launch lazy future ... done
[16:19:14.578] run() for ‘MulticoreFuture’ ... done
[16:19:14.579] Created future:
[16:19:14.579] plan(): Setting new future strategy stack:
[16:19:14.579] List of future strategies:
[16:19:14.579] 1. sequential:
[16:19:14.579]    - args: function (..., envir = parent.frame())
[16:19:14.579]    - tweaked: FALSE
[16:19:14.579]    - call: NULL
[16:19:14.580] plan(): nbrOfWorkers() = 1
[16:19:14.582] plan(): Setting new future strategy stack:
[16:19:14.582] List of future strategies:
[16:19:14.582] 1. multicore:
[16:19:14.582]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.582]    - tweaked: FALSE
[16:19:14.582]    - call: plan(strategy)
[16:19:14.588] plan(): nbrOfWorkers() = 2
[16:19:14.579] MulticoreFuture:
[16:19:14.579] Label: ‘future_sapply-1’
[16:19:14.579] Expression:
[16:19:14.579] {
[16:19:14.579]     do.call(function(...) {
[16:19:14.579]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.579]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.579]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.579]             on.exit(options(oopts), add = TRUE)
[16:19:14.579]         }
[16:19:14.579]         {
[16:19:14.579]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.579]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.579]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.579]             })
[16:19:14.579]         }
[16:19:14.579]     }, args = future.call.arguments)
[16:19:14.579] }
[16:19:14.579] Lazy evaluation: FALSE
[16:19:14.579] Asynchronous evaluation: TRUE
[16:19:14.579] Local evaluation: TRUE
[16:19:14.579] Environment: R_GlobalEnv
[16:19:14.579] Capture standard output: TRUE
[16:19:14.579] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.579] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:14.579] Packages: 1 packages (‘stats’)
[16:19:14.579] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.579] Resolved: TRUE
[16:19:14.579] Value: <not collected>
[16:19:14.579] Conditions captured: <none>
[16:19:14.579] Early signaling: FALSE
[16:19:14.579] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.579] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.589] Chunk #1 of 2 ... DONE
[16:19:14.589] Chunk #2 of 2 ...
[16:19:14.590]  - Finding globals in 'X' for chunk #2 ...
[16:19:14.590] getGlobalsAndPackages() ...
[16:19:14.590] Searching for globals...
[16:19:14.590] 
[16:19:14.591] Searching for globals ... DONE
[16:19:14.591] - globals: [0] <none>
[16:19:14.591] getGlobalsAndPackages() ... DONE
[16:19:14.591]    + additional globals found: [n=0] 
[16:19:14.591]    + additional namespaces needed: [n=0] 
[16:19:14.591]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:14.591]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.591]  - seeds: <none>
[16:19:14.592]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.592] getGlobalsAndPackages() ...
[16:19:14.592] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.592] Resolving globals: FALSE
[16:19:14.592] Tweak future expression to call with '...' arguments ...
[16:19:14.592] {
[16:19:14.592]     do.call(function(...) {
[16:19:14.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.592]             on.exit(options(oopts), add = TRUE)
[16:19:14.592]         }
[16:19:14.592]         {
[16:19:14.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.592]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.592]             })
[16:19:14.592]         }
[16:19:14.592]     }, args = future.call.arguments)
[16:19:14.592] }
[16:19:14.593] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.594] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.594] - packages: [1] ‘stats’
[16:19:14.594] getGlobalsAndPackages() ... DONE
[16:19:14.594] run() for ‘Future’ ...
[16:19:14.595] - state: ‘created’
[16:19:14.595] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.600]   - Field: ‘label’
[16:19:14.600]   - Field: ‘local’
[16:19:14.600]   - Field: ‘owner’
[16:19:14.600]   - Field: ‘envir’
[16:19:14.600]   - Field: ‘workers’
[16:19:14.600]   - Field: ‘packages’
[16:19:14.601]   - Field: ‘gc’
[16:19:14.604]   - Field: ‘job’
[16:19:14.604]   - Field: ‘conditions’
[16:19:14.605]   - Field: ‘expr’
[16:19:14.605]   - Field: ‘uuid’
[16:19:14.605]   - Field: ‘seed’
[16:19:14.605]   - Field: ‘version’
[16:19:14.606]   - Field: ‘result’
[16:19:14.606]   - Field: ‘asynchronous’
[16:19:14.607]   - Field: ‘calls’
[16:19:14.607]   - Field: ‘globals’
[16:19:14.607]   - Field: ‘stdout’
[16:19:14.607]   - Field: ‘earlySignal’
[16:19:14.608]   - Field: ‘lazy’
[16:19:14.608]   - Field: ‘state’
[16:19:14.608] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.608] - Launch lazy future ...
[16:19:14.609] Packages needed by the future expression (n = 1): ‘stats’
[16:19:14.609] Packages needed by future strategies (n = 0): <none>
[16:19:14.611] {
[16:19:14.611]     {
[16:19:14.611]         {
[16:19:14.611]             ...future.startTime <- base::Sys.time()
[16:19:14.611]             {
[16:19:14.611]                 {
[16:19:14.611]                   {
[16:19:14.611]                     {
[16:19:14.611]                       {
[16:19:14.611]                         base::local({
[16:19:14.611]                           has_future <- base::requireNamespace("future", 
[16:19:14.611]                             quietly = TRUE)
[16:19:14.611]                           if (has_future) {
[16:19:14.611]                             ns <- base::getNamespace("future")
[16:19:14.611]                             version <- ns[[".package"]][["version"]]
[16:19:14.611]                             if (is.null(version)) 
[16:19:14.611]                               version <- utils::packageVersion("future")
[16:19:14.611]                           }
[16:19:14.611]                           else {
[16:19:14.611]                             version <- NULL
[16:19:14.611]                           }
[16:19:14.611]                           if (!has_future || version < "1.8.0") {
[16:19:14.611]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.611]                               "", base::R.version$version.string), 
[16:19:14.611]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.611]                                 base::R.version$platform, 8 * 
[16:19:14.611]                                   base::.Machine$sizeof.pointer), 
[16:19:14.611]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.611]                                 "release", "version")], collapse = " "), 
[16:19:14.611]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.611]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.611]                               info)
[16:19:14.611]                             info <- base::paste(info, collapse = "; ")
[16:19:14.611]                             if (!has_future) {
[16:19:14.611]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.611]                                 info)
[16:19:14.611]                             }
[16:19:14.611]                             else {
[16:19:14.611]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.611]                                 info, version)
[16:19:14.611]                             }
[16:19:14.611]                             base::stop(msg)
[16:19:14.611]                           }
[16:19:14.611]                         })
[16:19:14.611]                       }
[16:19:14.611]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.611]                       base::options(mc.cores = 1L)
[16:19:14.611]                     }
[16:19:14.611]                     base::local({
[16:19:14.611]                       for (pkg in "stats") {
[16:19:14.611]                         base::loadNamespace(pkg)
[16:19:14.611]                         base::library(pkg, character.only = TRUE)
[16:19:14.611]                       }
[16:19:14.611]                     })
[16:19:14.611]                   }
[16:19:14.611]                   ...future.strategy.old <- future::plan("list")
[16:19:14.611]                   options(future.plan = NULL)
[16:19:14.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.611]                 }
[16:19:14.611]                 ...future.workdir <- getwd()
[16:19:14.611]             }
[16:19:14.611]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.611]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.611]         }
[16:19:14.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.611]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.611]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.611]             base::names(...future.oldOptions))
[16:19:14.611]     }
[16:19:14.611]     if (FALSE) {
[16:19:14.611]     }
[16:19:14.611]     else {
[16:19:14.611]         if (TRUE) {
[16:19:14.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.611]                 open = "w")
[16:19:14.611]         }
[16:19:14.611]         else {
[16:19:14.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.611]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.611]         }
[16:19:14.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.611]             base::sink(type = "output", split = FALSE)
[16:19:14.611]             base::close(...future.stdout)
[16:19:14.611]         }, add = TRUE)
[16:19:14.611]     }
[16:19:14.611]     ...future.frame <- base::sys.nframe()
[16:19:14.611]     ...future.conditions <- base::list()
[16:19:14.611]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.611]     if (FALSE) {
[16:19:14.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.611]     }
[16:19:14.611]     ...future.result <- base::tryCatch({
[16:19:14.611]         base::withCallingHandlers({
[16:19:14.611]             ...future.value <- base::withVisible(base::local({
[16:19:14.611]                 withCallingHandlers({
[16:19:14.611]                   {
[16:19:14.611]                     do.call(function(...) {
[16:19:14.611]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.611]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.611]                         ...future.globals.maxSize)) {
[16:19:14.611]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.611]                         on.exit(options(oopts), add = TRUE)
[16:19:14.611]                       }
[16:19:14.611]                       {
[16:19:14.611]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.611]                           FUN = function(jj) {
[16:19:14.611]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.611]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.611]                           })
[16:19:14.611]                       }
[16:19:14.611]                     }, args = future.call.arguments)
[16:19:14.611]                   }
[16:19:14.611]                 }, immediateCondition = function(cond) {
[16:19:14.611]                   save_rds <- function (object, pathname, ...) 
[16:19:14.611]                   {
[16:19:14.611]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.611]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.611]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.611]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.611]                         fi_tmp[["mtime"]])
[16:19:14.611]                     }
[16:19:14.611]                     tryCatch({
[16:19:14.611]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.611]                     }, error = function(ex) {
[16:19:14.611]                       msg <- conditionMessage(ex)
[16:19:14.611]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.611]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.611]                         fi_tmp[["mtime"]], msg)
[16:19:14.611]                       ex$message <- msg
[16:19:14.611]                       stop(ex)
[16:19:14.611]                     })
[16:19:14.611]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.611]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.611]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.611]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.611]                       fi <- file.info(pathname)
[16:19:14.611]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.611]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.611]                         fi[["size"]], fi[["mtime"]])
[16:19:14.611]                       stop(msg)
[16:19:14.611]                     }
[16:19:14.611]                     invisible(pathname)
[16:19:14.611]                   }
[16:19:14.611]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.611]                     rootPath = tempdir()) 
[16:19:14.611]                   {
[16:19:14.611]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.611]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.611]                       tmpdir = path, fileext = ".rds")
[16:19:14.611]                     save_rds(obj, file)
[16:19:14.611]                   }
[16:19:14.611]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.611]                   {
[16:19:14.611]                     inherits <- base::inherits
[16:19:14.611]                     invokeRestart <- base::invokeRestart
[16:19:14.611]                     is.null <- base::is.null
[16:19:14.611]                     muffled <- FALSE
[16:19:14.611]                     if (inherits(cond, "message")) {
[16:19:14.611]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.611]                       if (muffled) 
[16:19:14.611]                         invokeRestart("muffleMessage")
[16:19:14.611]                     }
[16:19:14.611]                     else if (inherits(cond, "warning")) {
[16:19:14.611]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.611]                       if (muffled) 
[16:19:14.611]                         invokeRestart("muffleWarning")
[16:19:14.611]                     }
[16:19:14.611]                     else if (inherits(cond, "condition")) {
[16:19:14.611]                       if (!is.null(pattern)) {
[16:19:14.611]                         computeRestarts <- base::computeRestarts
[16:19:14.611]                         grepl <- base::grepl
[16:19:14.611]                         restarts <- computeRestarts(cond)
[16:19:14.611]                         for (restart in restarts) {
[16:19:14.611]                           name <- restart$name
[16:19:14.611]                           if (is.null(name)) 
[16:19:14.611]                             next
[16:19:14.611]                           if (!grepl(pattern, name)) 
[16:19:14.611]                             next
[16:19:14.611]                           invokeRestart(restart)
[16:19:14.611]                           muffled <- TRUE
[16:19:14.611]                           break
[16:19:14.611]                         }
[16:19:14.611]                       }
[16:19:14.611]                     }
[16:19:14.611]                     invisible(muffled)
[16:19:14.611]                   }
[16:19:14.611]                   muffleCondition(cond)
[16:19:14.611]                 })
[16:19:14.611]             }))
[16:19:14.611]             future::FutureResult(value = ...future.value$value, 
[16:19:14.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.611]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.611]                     ...future.globalenv.names))
[16:19:14.611]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.611]         }, condition = base::local({
[16:19:14.611]             c <- base::c
[16:19:14.611]             inherits <- base::inherits
[16:19:14.611]             invokeRestart <- base::invokeRestart
[16:19:14.611]             length <- base::length
[16:19:14.611]             list <- base::list
[16:19:14.611]             seq.int <- base::seq.int
[16:19:14.611]             signalCondition <- base::signalCondition
[16:19:14.611]             sys.calls <- base::sys.calls
[16:19:14.611]             `[[` <- base::`[[`
[16:19:14.611]             `+` <- base::`+`
[16:19:14.611]             `<<-` <- base::`<<-`
[16:19:14.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.611]                   3L)]
[16:19:14.611]             }
[16:19:14.611]             function(cond) {
[16:19:14.611]                 is_error <- inherits(cond, "error")
[16:19:14.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.611]                   NULL)
[16:19:14.611]                 if (is_error) {
[16:19:14.611]                   sessionInformation <- function() {
[16:19:14.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.611]                       search = base::search(), system = base::Sys.info())
[16:19:14.611]                   }
[16:19:14.611]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.611]                     cond$call), session = sessionInformation(), 
[16:19:14.611]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.611]                   signalCondition(cond)
[16:19:14.611]                 }
[16:19:14.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.611]                 "immediateCondition"))) {
[16:19:14.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.611]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.611]                   if (TRUE && !signal) {
[16:19:14.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.611]                     {
[16:19:14.611]                       inherits <- base::inherits
[16:19:14.611]                       invokeRestart <- base::invokeRestart
[16:19:14.611]                       is.null <- base::is.null
[16:19:14.611]                       muffled <- FALSE
[16:19:14.611]                       if (inherits(cond, "message")) {
[16:19:14.611]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.611]                         if (muffled) 
[16:19:14.611]                           invokeRestart("muffleMessage")
[16:19:14.611]                       }
[16:19:14.611]                       else if (inherits(cond, "warning")) {
[16:19:14.611]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.611]                         if (muffled) 
[16:19:14.611]                           invokeRestart("muffleWarning")
[16:19:14.611]                       }
[16:19:14.611]                       else if (inherits(cond, "condition")) {
[16:19:14.611]                         if (!is.null(pattern)) {
[16:19:14.611]                           computeRestarts <- base::computeRestarts
[16:19:14.611]                           grepl <- base::grepl
[16:19:14.611]                           restarts <- computeRestarts(cond)
[16:19:14.611]                           for (restart in restarts) {
[16:19:14.611]                             name <- restart$name
[16:19:14.611]                             if (is.null(name)) 
[16:19:14.611]                               next
[16:19:14.611]                             if (!grepl(pattern, name)) 
[16:19:14.611]                               next
[16:19:14.611]                             invokeRestart(restart)
[16:19:14.611]                             muffled <- TRUE
[16:19:14.611]                             break
[16:19:14.611]                           }
[16:19:14.611]                         }
[16:19:14.611]                       }
[16:19:14.611]                       invisible(muffled)
[16:19:14.611]                     }
[16:19:14.611]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.611]                   }
[16:19:14.611]                 }
[16:19:14.611]                 else {
[16:19:14.611]                   if (TRUE) {
[16:19:14.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.611]                     {
[16:19:14.611]                       inherits <- base::inherits
[16:19:14.611]                       invokeRestart <- base::invokeRestart
[16:19:14.611]                       is.null <- base::is.null
[16:19:14.611]                       muffled <- FALSE
[16:19:14.611]                       if (inherits(cond, "message")) {
[16:19:14.611]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.611]                         if (muffled) 
[16:19:14.611]                           invokeRestart("muffleMessage")
[16:19:14.611]                       }
[16:19:14.611]                       else if (inherits(cond, "warning")) {
[16:19:14.611]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.611]                         if (muffled) 
[16:19:14.611]                           invokeRestart("muffleWarning")
[16:19:14.611]                       }
[16:19:14.611]                       else if (inherits(cond, "condition")) {
[16:19:14.611]                         if (!is.null(pattern)) {
[16:19:14.611]                           computeRestarts <- base::computeRestarts
[16:19:14.611]                           grepl <- base::grepl
[16:19:14.611]                           restarts <- computeRestarts(cond)
[16:19:14.611]                           for (restart in restarts) {
[16:19:14.611]                             name <- restart$name
[16:19:14.611]                             if (is.null(name)) 
[16:19:14.611]                               next
[16:19:14.611]                             if (!grepl(pattern, name)) 
[16:19:14.611]                               next
[16:19:14.611]                             invokeRestart(restart)
[16:19:14.611]                             muffled <- TRUE
[16:19:14.611]                             break
[16:19:14.611]                           }
[16:19:14.611]                         }
[16:19:14.611]                       }
[16:19:14.611]                       invisible(muffled)
[16:19:14.611]                     }
[16:19:14.611]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.611]                   }
[16:19:14.611]                 }
[16:19:14.611]             }
[16:19:14.611]         }))
[16:19:14.611]     }, error = function(ex) {
[16:19:14.611]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.611]                 ...future.rng), started = ...future.startTime, 
[16:19:14.611]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.611]             version = "1.8"), class = "FutureResult")
[16:19:14.611]     }, finally = {
[16:19:14.611]         if (!identical(...future.workdir, getwd())) 
[16:19:14.611]             setwd(...future.workdir)
[16:19:14.611]         {
[16:19:14.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.611]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.611]             }
[16:19:14.611]             base::options(...future.oldOptions)
[16:19:14.611]             if (.Platform$OS.type == "windows") {
[16:19:14.611]                 old_names <- names(...future.oldEnvVars)
[16:19:14.611]                 envs <- base::Sys.getenv()
[16:19:14.611]                 names <- names(envs)
[16:19:14.611]                 common <- intersect(names, old_names)
[16:19:14.611]                 added <- setdiff(names, old_names)
[16:19:14.611]                 removed <- setdiff(old_names, names)
[16:19:14.611]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.611]                   envs[common]]
[16:19:14.611]                 NAMES <- toupper(changed)
[16:19:14.611]                 args <- list()
[16:19:14.611]                 for (kk in seq_along(NAMES)) {
[16:19:14.611]                   name <- changed[[kk]]
[16:19:14.611]                   NAME <- NAMES[[kk]]
[16:19:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.611]                     next
[16:19:14.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.611]                 }
[16:19:14.611]                 NAMES <- toupper(added)
[16:19:14.611]                 for (kk in seq_along(NAMES)) {
[16:19:14.611]                   name <- added[[kk]]
[16:19:14.611]                   NAME <- NAMES[[kk]]
[16:19:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.611]                     next
[16:19:14.611]                   args[[name]] <- ""
[16:19:14.611]                 }
[16:19:14.611]                 NAMES <- toupper(removed)
[16:19:14.611]                 for (kk in seq_along(NAMES)) {
[16:19:14.611]                   name <- removed[[kk]]
[16:19:14.611]                   NAME <- NAMES[[kk]]
[16:19:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.611]                     next
[16:19:14.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.611]                 }
[16:19:14.611]                 if (length(args) > 0) 
[16:19:14.611]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.611]             }
[16:19:14.611]             else {
[16:19:14.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.611]             }
[16:19:14.611]             {
[16:19:14.611]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.611]                   0L) {
[16:19:14.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.611]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.611]                   base::options(opts)
[16:19:14.611]                 }
[16:19:14.611]                 {
[16:19:14.611]                   {
[16:19:14.611]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.611]                     NULL
[16:19:14.611]                   }
[16:19:14.611]                   options(future.plan = NULL)
[16:19:14.611]                   if (is.na(NA_character_)) 
[16:19:14.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.611]                     .init = FALSE)
[16:19:14.611]                 }
[16:19:14.611]             }
[16:19:14.611]         }
[16:19:14.611]     })
[16:19:14.611]     if (TRUE) {
[16:19:14.611]         base::sink(type = "output", split = FALSE)
[16:19:14.611]         if (TRUE) {
[16:19:14.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.611]         }
[16:19:14.611]         else {
[16:19:14.611]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.611]         }
[16:19:14.611]         base::close(...future.stdout)
[16:19:14.611]         ...future.stdout <- NULL
[16:19:14.611]     }
[16:19:14.611]     ...future.result$conditions <- ...future.conditions
[16:19:14.611]     ...future.result$finished <- base::Sys.time()
[16:19:14.611]     ...future.result
[16:19:14.611] }
[16:19:14.614] assign_globals() ...
[16:19:14.614] List of 5
[16:19:14.614]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:19:14.614]  $ future.call.arguments    : list()
[16:19:14.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.614]  $ ...future.elements_ii    :List of 3
[16:19:14.614]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:19:14.614]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:19:14.614]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:19:14.614]  $ ...future.seeds_ii       : NULL
[16:19:14.614]  $ ...future.globals.maxSize: NULL
[16:19:14.614]  - attr(*, "where")=List of 5
[16:19:14.614]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.614]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.614]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.614]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.614]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.614]  - attr(*, "resolved")= logi FALSE
[16:19:14.614]  - attr(*, "total_size")= num 46960
[16:19:14.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.614]  - attr(*, "already-done")= logi TRUE
[16:19:14.623] - copied ‘...future.FUN’ to environment
[16:19:14.623] - copied ‘future.call.arguments’ to environment
[16:19:14.623] - copied ‘...future.elements_ii’ to environment
[16:19:14.623] - copied ‘...future.seeds_ii’ to environment
[16:19:14.623] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.623] assign_globals() ... done
[16:19:14.624] requestCore(): workers = 2
[16:19:14.626] MulticoreFuture started
[16:19:14.626] - Launch lazy future ... done
[16:19:14.627] run() for ‘MulticoreFuture’ ... done
[16:19:14.627] Created future:
[16:19:14.627] plan(): Setting new future strategy stack:
[16:19:14.628] List of future strategies:
[16:19:14.628] 1. sequential:
[16:19:14.628]    - args: function (..., envir = parent.frame())
[16:19:14.628]    - tweaked: FALSE
[16:19:14.628]    - call: NULL
[16:19:14.628] plan(): nbrOfWorkers() = 1
[16:19:14.631] plan(): Setting new future strategy stack:
[16:19:14.631] List of future strategies:
[16:19:14.631] 1. multicore:
[16:19:14.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.631]    - tweaked: FALSE
[16:19:14.631]    - call: plan(strategy)
[16:19:14.636] plan(): nbrOfWorkers() = 2
[16:19:14.627] MulticoreFuture:
[16:19:14.627] Label: ‘future_sapply-2’
[16:19:14.627] Expression:
[16:19:14.627] {
[16:19:14.627]     do.call(function(...) {
[16:19:14.627]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.627]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.627]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.627]             on.exit(options(oopts), add = TRUE)
[16:19:14.627]         }
[16:19:14.627]         {
[16:19:14.627]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.627]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.627]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.627]             })
[16:19:14.627]         }
[16:19:14.627]     }, args = future.call.arguments)
[16:19:14.627] }
[16:19:14.627] Lazy evaluation: FALSE
[16:19:14.627] Asynchronous evaluation: TRUE
[16:19:14.627] Local evaluation: TRUE
[16:19:14.627] Environment: R_GlobalEnv
[16:19:14.627] Capture standard output: TRUE
[16:19:14.627] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.627] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:14.627] Packages: 1 packages (‘stats’)
[16:19:14.627] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.627] Resolved: TRUE
[16:19:14.627] Value: <not collected>
[16:19:14.627] Conditions captured: <none>
[16:19:14.627] Early signaling: FALSE
[16:19:14.627] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.627] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.637] Chunk #2 of 2 ... DONE
[16:19:14.637] Launching 2 futures (chunks) ... DONE
[16:19:14.638] Resolving 2 futures (chunks) ...
[16:19:14.638] resolve() on list ...
[16:19:14.638]  recursive: 0
[16:19:14.638]  length: 2
[16:19:14.638] 
[16:19:14.639] Future #1
[16:19:14.639] result() for MulticoreFuture ...
[16:19:14.640] result() for MulticoreFuture ...
[16:19:14.640] result() for MulticoreFuture ... done
[16:19:14.640] result() for MulticoreFuture ... done
[16:19:14.640] result() for MulticoreFuture ...
[16:19:14.640] result() for MulticoreFuture ... done
[16:19:14.640] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:14.641] - nx: 2
[16:19:14.641] - relay: TRUE
[16:19:14.641] - stdout: TRUE
[16:19:14.641] - signal: TRUE
[16:19:14.641] - resignal: FALSE
[16:19:14.641] - force: TRUE
[16:19:14.641] - relayed: [n=2] FALSE, FALSE
[16:19:14.641] - queued futures: [n=2] FALSE, FALSE
[16:19:14.642]  - until=1
[16:19:14.642]  - relaying element #1
[16:19:14.642] result() for MulticoreFuture ...
[16:19:14.642] result() for MulticoreFuture ... done
[16:19:14.642] result() for MulticoreFuture ...
[16:19:14.642] result() for MulticoreFuture ... done
[16:19:14.643] result() for MulticoreFuture ...
[16:19:14.643] result() for MulticoreFuture ... done
[16:19:14.643] result() for MulticoreFuture ...
[16:19:14.643] result() for MulticoreFuture ... done
[16:19:14.643] - relayed: [n=2] TRUE, FALSE
[16:19:14.643] - queued futures: [n=2] TRUE, FALSE
[16:19:14.644] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:14.644]  length: 1 (resolved future 1)
[16:19:14.644] Future #2
[16:19:14.644] result() for MulticoreFuture ...
[16:19:14.645] result() for MulticoreFuture ...
[16:19:14.645] result() for MulticoreFuture ... done
[16:19:14.645] result() for MulticoreFuture ... done
[16:19:14.645] result() for MulticoreFuture ...
[16:19:14.645] result() for MulticoreFuture ... done
[16:19:14.646] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:14.646] - nx: 2
[16:19:14.646] - relay: TRUE
[16:19:14.646] - stdout: TRUE
[16:19:14.646] - signal: TRUE
[16:19:14.646] - resignal: FALSE
[16:19:14.646] - force: TRUE
[16:19:14.646] - relayed: [n=2] TRUE, FALSE
[16:19:14.647] - queued futures: [n=2] TRUE, FALSE
[16:19:14.647]  - until=2
[16:19:14.647]  - relaying element #2
[16:19:14.647] result() for MulticoreFuture ...
[16:19:14.647] result() for MulticoreFuture ... done
[16:19:14.647] result() for MulticoreFuture ...
[16:19:14.647] result() for MulticoreFuture ... done
[16:19:14.647] result() for MulticoreFuture ...
[16:19:14.648] result() for MulticoreFuture ... done
[16:19:14.648] result() for MulticoreFuture ...
[16:19:14.648] result() for MulticoreFuture ... done
[16:19:14.648] - relayed: [n=2] TRUE, TRUE
[16:19:14.651] - queued futures: [n=2] TRUE, TRUE
[16:19:14.651] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:14.651]  length: 0 (resolved future 2)
[16:19:14.651] Relaying remaining futures
[16:19:14.652] signalConditionsASAP(NULL, pos=0) ...
[16:19:14.652] - nx: 2
[16:19:14.652] - relay: TRUE
[16:19:14.652] - stdout: TRUE
[16:19:14.652] - signal: TRUE
[16:19:14.652] - resignal: FALSE
[16:19:14.653] - force: TRUE
[16:19:14.653] - relayed: [n=2] TRUE, TRUE
[16:19:14.653] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:14.653] - relayed: [n=2] TRUE, TRUE
[16:19:14.653] - queued futures: [n=2] TRUE, TRUE
[16:19:14.654] signalConditionsASAP(NULL, pos=0) ... done
[16:19:14.654] resolve() on list ... DONE
[16:19:14.654] result() for MulticoreFuture ...
[16:19:14.654] result() for MulticoreFuture ... done
[16:19:14.654] result() for MulticoreFuture ...
[16:19:14.654] result() for MulticoreFuture ... done
[16:19:14.655] result() for MulticoreFuture ...
[16:19:14.655] result() for MulticoreFuture ... done
[16:19:14.655] result() for MulticoreFuture ...
[16:19:14.655] result() for MulticoreFuture ... done
[16:19:14.655]  - Number of value chunks collected: 2
[16:19:14.655] Resolving 2 futures (chunks) ... DONE
[16:19:14.656] Reducing values from 2 chunks ...
[16:19:14.656]  - Number of values collected after concatenation: 7
[16:19:14.656]  - Number of values expected: 7
[16:19:14.656] Reducing values from 2 chunks ... DONE
[16:19:14.656] future_lapply() ... DONE
[16:19:14.657] future_lapply() ...
[16:19:14.663] Number of chunks: 2
[16:19:14.664] getGlobalsAndPackagesXApply() ...
[16:19:14.664]  - future.globals: TRUE
[16:19:14.664] getGlobalsAndPackages() ...
[16:19:14.664] Searching for globals...
[16:19:14.672] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:19:14.672] Searching for globals ... DONE
[16:19:14.672] Resolving globals: FALSE
[16:19:14.673] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:19:14.676] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:19:14.676] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.676] - packages: [2] ‘stats’, ‘future.apply’
[16:19:14.676] getGlobalsAndPackages() ... DONE
[16:19:14.676]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.676]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:19:14.677] Finding globals ... DONE
[16:19:14.677]  - use_args: TRUE
[16:19:14.677]  - Getting '...' globals ...
[16:19:14.677] resolve() on list ...
[16:19:14.677]  recursive: 0
[16:19:14.677]  length: 1
[16:19:14.677]  elements: ‘...’
[16:19:14.678]  length: 0 (resolved future 1)
[16:19:14.678] resolve() on list ... DONE
[16:19:14.678]    - '...' content: [n=0] 
[16:19:14.678] List of 1
[16:19:14.678]  $ ...: list()
[16:19:14.678]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.678]  - attr(*, "where")=List of 1
[16:19:14.678]   ..$ ...:<environment: 0x56199ee661b8> 
[16:19:14.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.678]  - attr(*, "resolved")= logi TRUE
[16:19:14.678]  - attr(*, "total_size")= num NA
[16:19:14.681]  - Getting '...' globals ... DONE
[16:19:14.681] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:14.681] List of 8
[16:19:14.681]  $ ...future.FUN:function (x, ...)  
[16:19:14.681]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:19:14.681]  $ times        : int 5
[16:19:14.681]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.681]  $ stop_if_not  :function (...)  
[16:19:14.681]  $ dim          : NULL
[16:19:14.681]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:14.681]  $ ...          : list()
[16:19:14.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.681]  - attr(*, "where")=List of 8
[16:19:14.681]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:14.681]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:14.681]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:14.681]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:14.681]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:14.681]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:14.681]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:14.681]   ..$ ...          :<environment: 0x56199ee661b8> 
[16:19:14.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.681]  - attr(*, "resolved")= logi FALSE
[16:19:14.681]  - attr(*, "total_size")= num 141240
[16:19:14.687] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:19:14.687] getGlobalsAndPackagesXApply() ... DONE
[16:19:14.687] Number of futures (= number of chunks): 2
[16:19:14.687] Launching 2 futures (chunks) ...
[16:19:14.688] Chunk #1 of 2 ...
[16:19:14.688]  - Finding globals in 'X' for chunk #1 ...
[16:19:14.688] getGlobalsAndPackages() ...
[16:19:14.688] Searching for globals...
[16:19:14.688] 
[16:19:14.688] Searching for globals ... DONE
[16:19:14.688] - globals: [0] <none>
[16:19:14.688] getGlobalsAndPackages() ... DONE
[16:19:14.689]    + additional globals found: [n=0] 
[16:19:14.689]    + additional namespaces needed: [n=0] 
[16:19:14.689]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:14.689]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.689]  - seeds: <none>
[16:19:14.689]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.689] getGlobalsAndPackages() ...
[16:19:14.689] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.689] Resolving globals: FALSE
[16:19:14.689] Tweak future expression to call with '...' arguments ...
[16:19:14.690] {
[16:19:14.690]     do.call(function(...) {
[16:19:14.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.690]             on.exit(options(oopts), add = TRUE)
[16:19:14.690]         }
[16:19:14.690]         {
[16:19:14.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.690]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.690]             })
[16:19:14.690]         }
[16:19:14.690]     }, args = future.call.arguments)
[16:19:14.690] }
[16:19:14.690] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.690] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.691] - packages: [2] ‘stats’, ‘future.apply’
[16:19:14.691] getGlobalsAndPackages() ... DONE
[16:19:14.691] run() for ‘Future’ ...
[16:19:14.691] - state: ‘created’
[16:19:14.691] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.695] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.695] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.695]   - Field: ‘label’
[16:19:14.696]   - Field: ‘local’
[16:19:14.696]   - Field: ‘owner’
[16:19:14.696]   - Field: ‘envir’
[16:19:14.696]   - Field: ‘workers’
[16:19:14.696]   - Field: ‘packages’
[16:19:14.696]   - Field: ‘gc’
[16:19:14.696]   - Field: ‘job’
[16:19:14.696]   - Field: ‘conditions’
[16:19:14.696]   - Field: ‘expr’
[16:19:14.696]   - Field: ‘uuid’
[16:19:14.699]   - Field: ‘seed’
[16:19:14.699]   - Field: ‘version’
[16:19:14.699]   - Field: ‘result’
[16:19:14.699]   - Field: ‘asynchronous’
[16:19:14.699]   - Field: ‘calls’
[16:19:14.699]   - Field: ‘globals’
[16:19:14.699]   - Field: ‘stdout’
[16:19:14.700]   - Field: ‘earlySignal’
[16:19:14.700]   - Field: ‘lazy’
[16:19:14.700]   - Field: ‘state’
[16:19:14.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.700] - Launch lazy future ...
[16:19:14.700] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:14.701] Packages needed by future strategies (n = 0): <none>
[16:19:14.701] {
[16:19:14.701]     {
[16:19:14.701]         {
[16:19:14.701]             ...future.startTime <- base::Sys.time()
[16:19:14.701]             {
[16:19:14.701]                 {
[16:19:14.701]                   {
[16:19:14.701]                     {
[16:19:14.701]                       {
[16:19:14.701]                         base::local({
[16:19:14.701]                           has_future <- base::requireNamespace("future", 
[16:19:14.701]                             quietly = TRUE)
[16:19:14.701]                           if (has_future) {
[16:19:14.701]                             ns <- base::getNamespace("future")
[16:19:14.701]                             version <- ns[[".package"]][["version"]]
[16:19:14.701]                             if (is.null(version)) 
[16:19:14.701]                               version <- utils::packageVersion("future")
[16:19:14.701]                           }
[16:19:14.701]                           else {
[16:19:14.701]                             version <- NULL
[16:19:14.701]                           }
[16:19:14.701]                           if (!has_future || version < "1.8.0") {
[16:19:14.701]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.701]                               "", base::R.version$version.string), 
[16:19:14.701]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.701]                                 base::R.version$platform, 8 * 
[16:19:14.701]                                   base::.Machine$sizeof.pointer), 
[16:19:14.701]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.701]                                 "release", "version")], collapse = " "), 
[16:19:14.701]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.701]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.701]                               info)
[16:19:14.701]                             info <- base::paste(info, collapse = "; ")
[16:19:14.701]                             if (!has_future) {
[16:19:14.701]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.701]                                 info)
[16:19:14.701]                             }
[16:19:14.701]                             else {
[16:19:14.701]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.701]                                 info, version)
[16:19:14.701]                             }
[16:19:14.701]                             base::stop(msg)
[16:19:14.701]                           }
[16:19:14.701]                         })
[16:19:14.701]                       }
[16:19:14.701]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.701]                       base::options(mc.cores = 1L)
[16:19:14.701]                     }
[16:19:14.701]                     base::local({
[16:19:14.701]                       for (pkg in c("stats", "future.apply")) {
[16:19:14.701]                         base::loadNamespace(pkg)
[16:19:14.701]                         base::library(pkg, character.only = TRUE)
[16:19:14.701]                       }
[16:19:14.701]                     })
[16:19:14.701]                   }
[16:19:14.701]                   ...future.strategy.old <- future::plan("list")
[16:19:14.701]                   options(future.plan = NULL)
[16:19:14.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.701]                 }
[16:19:14.701]                 ...future.workdir <- getwd()
[16:19:14.701]             }
[16:19:14.701]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.701]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.701]         }
[16:19:14.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.701]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.701]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.701]             base::names(...future.oldOptions))
[16:19:14.701]     }
[16:19:14.701]     if (FALSE) {
[16:19:14.701]     }
[16:19:14.701]     else {
[16:19:14.701]         if (TRUE) {
[16:19:14.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.701]                 open = "w")
[16:19:14.701]         }
[16:19:14.701]         else {
[16:19:14.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.701]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.701]         }
[16:19:14.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.701]             base::sink(type = "output", split = FALSE)
[16:19:14.701]             base::close(...future.stdout)
[16:19:14.701]         }, add = TRUE)
[16:19:14.701]     }
[16:19:14.701]     ...future.frame <- base::sys.nframe()
[16:19:14.701]     ...future.conditions <- base::list()
[16:19:14.701]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.701]     if (FALSE) {
[16:19:14.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.701]     }
[16:19:14.701]     ...future.result <- base::tryCatch({
[16:19:14.701]         base::withCallingHandlers({
[16:19:14.701]             ...future.value <- base::withVisible(base::local({
[16:19:14.701]                 withCallingHandlers({
[16:19:14.701]                   {
[16:19:14.701]                     do.call(function(...) {
[16:19:14.701]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.701]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.701]                         ...future.globals.maxSize)) {
[16:19:14.701]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.701]                         on.exit(options(oopts), add = TRUE)
[16:19:14.701]                       }
[16:19:14.701]                       {
[16:19:14.701]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.701]                           FUN = function(jj) {
[16:19:14.701]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.701]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.701]                           })
[16:19:14.701]                       }
[16:19:14.701]                     }, args = future.call.arguments)
[16:19:14.701]                   }
[16:19:14.701]                 }, immediateCondition = function(cond) {
[16:19:14.701]                   save_rds <- function (object, pathname, ...) 
[16:19:14.701]                   {
[16:19:14.701]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.701]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.701]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.701]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.701]                         fi_tmp[["mtime"]])
[16:19:14.701]                     }
[16:19:14.701]                     tryCatch({
[16:19:14.701]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.701]                     }, error = function(ex) {
[16:19:14.701]                       msg <- conditionMessage(ex)
[16:19:14.701]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.701]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.701]                         fi_tmp[["mtime"]], msg)
[16:19:14.701]                       ex$message <- msg
[16:19:14.701]                       stop(ex)
[16:19:14.701]                     })
[16:19:14.701]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.701]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.701]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.701]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.701]                       fi <- file.info(pathname)
[16:19:14.701]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.701]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.701]                         fi[["size"]], fi[["mtime"]])
[16:19:14.701]                       stop(msg)
[16:19:14.701]                     }
[16:19:14.701]                     invisible(pathname)
[16:19:14.701]                   }
[16:19:14.701]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.701]                     rootPath = tempdir()) 
[16:19:14.701]                   {
[16:19:14.701]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.701]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.701]                       tmpdir = path, fileext = ".rds")
[16:19:14.701]                     save_rds(obj, file)
[16:19:14.701]                   }
[16:19:14.701]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.701]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.701]                   {
[16:19:14.701]                     inherits <- base::inherits
[16:19:14.701]                     invokeRestart <- base::invokeRestart
[16:19:14.701]                     is.null <- base::is.null
[16:19:14.701]                     muffled <- FALSE
[16:19:14.701]                     if (inherits(cond, "message")) {
[16:19:14.701]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.701]                       if (muffled) 
[16:19:14.701]                         invokeRestart("muffleMessage")
[16:19:14.701]                     }
[16:19:14.701]                     else if (inherits(cond, "warning")) {
[16:19:14.701]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.701]                       if (muffled) 
[16:19:14.701]                         invokeRestart("muffleWarning")
[16:19:14.701]                     }
[16:19:14.701]                     else if (inherits(cond, "condition")) {
[16:19:14.701]                       if (!is.null(pattern)) {
[16:19:14.701]                         computeRestarts <- base::computeRestarts
[16:19:14.701]                         grepl <- base::grepl
[16:19:14.701]                         restarts <- computeRestarts(cond)
[16:19:14.701]                         for (restart in restarts) {
[16:19:14.701]                           name <- restart$name
[16:19:14.701]                           if (is.null(name)) 
[16:19:14.701]                             next
[16:19:14.701]                           if (!grepl(pattern, name)) 
[16:19:14.701]                             next
[16:19:14.701]                           invokeRestart(restart)
[16:19:14.701]                           muffled <- TRUE
[16:19:14.701]                           break
[16:19:14.701]                         }
[16:19:14.701]                       }
[16:19:14.701]                     }
[16:19:14.701]                     invisible(muffled)
[16:19:14.701]                   }
[16:19:14.701]                   muffleCondition(cond)
[16:19:14.701]                 })
[16:19:14.701]             }))
[16:19:14.701]             future::FutureResult(value = ...future.value$value, 
[16:19:14.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.701]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.701]                     ...future.globalenv.names))
[16:19:14.701]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.701]         }, condition = base::local({
[16:19:14.701]             c <- base::c
[16:19:14.701]             inherits <- base::inherits
[16:19:14.701]             invokeRestart <- base::invokeRestart
[16:19:14.701]             length <- base::length
[16:19:14.701]             list <- base::list
[16:19:14.701]             seq.int <- base::seq.int
[16:19:14.701]             signalCondition <- base::signalCondition
[16:19:14.701]             sys.calls <- base::sys.calls
[16:19:14.701]             `[[` <- base::`[[`
[16:19:14.701]             `+` <- base::`+`
[16:19:14.701]             `<<-` <- base::`<<-`
[16:19:14.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.701]                   3L)]
[16:19:14.701]             }
[16:19:14.701]             function(cond) {
[16:19:14.701]                 is_error <- inherits(cond, "error")
[16:19:14.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.701]                   NULL)
[16:19:14.701]                 if (is_error) {
[16:19:14.701]                   sessionInformation <- function() {
[16:19:14.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.701]                       search = base::search(), system = base::Sys.info())
[16:19:14.701]                   }
[16:19:14.701]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.701]                     cond$call), session = sessionInformation(), 
[16:19:14.701]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.701]                   signalCondition(cond)
[16:19:14.701]                 }
[16:19:14.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.701]                 "immediateCondition"))) {
[16:19:14.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.701]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.701]                   if (TRUE && !signal) {
[16:19:14.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.701]                     {
[16:19:14.701]                       inherits <- base::inherits
[16:19:14.701]                       invokeRestart <- base::invokeRestart
[16:19:14.701]                       is.null <- base::is.null
[16:19:14.701]                       muffled <- FALSE
[16:19:14.701]                       if (inherits(cond, "message")) {
[16:19:14.701]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.701]                         if (muffled) 
[16:19:14.701]                           invokeRestart("muffleMessage")
[16:19:14.701]                       }
[16:19:14.701]                       else if (inherits(cond, "warning")) {
[16:19:14.701]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.701]                         if (muffled) 
[16:19:14.701]                           invokeRestart("muffleWarning")
[16:19:14.701]                       }
[16:19:14.701]                       else if (inherits(cond, "condition")) {
[16:19:14.701]                         if (!is.null(pattern)) {
[16:19:14.701]                           computeRestarts <- base::computeRestarts
[16:19:14.701]                           grepl <- base::grepl
[16:19:14.701]                           restarts <- computeRestarts(cond)
[16:19:14.701]                           for (restart in restarts) {
[16:19:14.701]                             name <- restart$name
[16:19:14.701]                             if (is.null(name)) 
[16:19:14.701]                               next
[16:19:14.701]                             if (!grepl(pattern, name)) 
[16:19:14.701]                               next
[16:19:14.701]                             invokeRestart(restart)
[16:19:14.701]                             muffled <- TRUE
[16:19:14.701]                             break
[16:19:14.701]                           }
[16:19:14.701]                         }
[16:19:14.701]                       }
[16:19:14.701]                       invisible(muffled)
[16:19:14.701]                     }
[16:19:14.701]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.701]                   }
[16:19:14.701]                 }
[16:19:14.701]                 else {
[16:19:14.701]                   if (TRUE) {
[16:19:14.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.701]                     {
[16:19:14.701]                       inherits <- base::inherits
[16:19:14.701]                       invokeRestart <- base::invokeRestart
[16:19:14.701]                       is.null <- base::is.null
[16:19:14.701]                       muffled <- FALSE
[16:19:14.701]                       if (inherits(cond, "message")) {
[16:19:14.701]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.701]                         if (muffled) 
[16:19:14.701]                           invokeRestart("muffleMessage")
[16:19:14.701]                       }
[16:19:14.701]                       else if (inherits(cond, "warning")) {
[16:19:14.701]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.701]                         if (muffled) 
[16:19:14.701]                           invokeRestart("muffleWarning")
[16:19:14.701]                       }
[16:19:14.701]                       else if (inherits(cond, "condition")) {
[16:19:14.701]                         if (!is.null(pattern)) {
[16:19:14.701]                           computeRestarts <- base::computeRestarts
[16:19:14.701]                           grepl <- base::grepl
[16:19:14.701]                           restarts <- computeRestarts(cond)
[16:19:14.701]                           for (restart in restarts) {
[16:19:14.701]                             name <- restart$name
[16:19:14.701]                             if (is.null(name)) 
[16:19:14.701]                               next
[16:19:14.701]                             if (!grepl(pattern, name)) 
[16:19:14.701]                               next
[16:19:14.701]                             invokeRestart(restart)
[16:19:14.701]                             muffled <- TRUE
[16:19:14.701]                             break
[16:19:14.701]                           }
[16:19:14.701]                         }
[16:19:14.701]                       }
[16:19:14.701]                       invisible(muffled)
[16:19:14.701]                     }
[16:19:14.701]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.701]                   }
[16:19:14.701]                 }
[16:19:14.701]             }
[16:19:14.701]         }))
[16:19:14.701]     }, error = function(ex) {
[16:19:14.701]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.701]                 ...future.rng), started = ...future.startTime, 
[16:19:14.701]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.701]             version = "1.8"), class = "FutureResult")
[16:19:14.701]     }, finally = {
[16:19:14.701]         if (!identical(...future.workdir, getwd())) 
[16:19:14.701]             setwd(...future.workdir)
[16:19:14.701]         {
[16:19:14.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.701]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.701]             }
[16:19:14.701]             base::options(...future.oldOptions)
[16:19:14.701]             if (.Platform$OS.type == "windows") {
[16:19:14.701]                 old_names <- names(...future.oldEnvVars)
[16:19:14.701]                 envs <- base::Sys.getenv()
[16:19:14.701]                 names <- names(envs)
[16:19:14.701]                 common <- intersect(names, old_names)
[16:19:14.701]                 added <- setdiff(names, old_names)
[16:19:14.701]                 removed <- setdiff(old_names, names)
[16:19:14.701]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.701]                   envs[common]]
[16:19:14.701]                 NAMES <- toupper(changed)
[16:19:14.701]                 args <- list()
[16:19:14.701]                 for (kk in seq_along(NAMES)) {
[16:19:14.701]                   name <- changed[[kk]]
[16:19:14.701]                   NAME <- NAMES[[kk]]
[16:19:14.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.701]                     next
[16:19:14.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.701]                 }
[16:19:14.701]                 NAMES <- toupper(added)
[16:19:14.701]                 for (kk in seq_along(NAMES)) {
[16:19:14.701]                   name <- added[[kk]]
[16:19:14.701]                   NAME <- NAMES[[kk]]
[16:19:14.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.701]                     next
[16:19:14.701]                   args[[name]] <- ""
[16:19:14.701]                 }
[16:19:14.701]                 NAMES <- toupper(removed)
[16:19:14.701]                 for (kk in seq_along(NAMES)) {
[16:19:14.701]                   name <- removed[[kk]]
[16:19:14.701]                   NAME <- NAMES[[kk]]
[16:19:14.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.701]                     next
[16:19:14.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.701]                 }
[16:19:14.701]                 if (length(args) > 0) 
[16:19:14.701]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.701]             }
[16:19:14.701]             else {
[16:19:14.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.701]             }
[16:19:14.701]             {
[16:19:14.701]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.701]                   0L) {
[16:19:14.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.701]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.701]                   base::options(opts)
[16:19:14.701]                 }
[16:19:14.701]                 {
[16:19:14.701]                   {
[16:19:14.701]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.701]                     NULL
[16:19:14.701]                   }
[16:19:14.701]                   options(future.plan = NULL)
[16:19:14.701]                   if (is.na(NA_character_)) 
[16:19:14.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.701]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.701]                     .init = FALSE)
[16:19:14.701]                 }
[16:19:14.701]             }
[16:19:14.701]         }
[16:19:14.701]     })
[16:19:14.701]     if (TRUE) {
[16:19:14.701]         base::sink(type = "output", split = FALSE)
[16:19:14.701]         if (TRUE) {
[16:19:14.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.701]         }
[16:19:14.701]         else {
[16:19:14.701]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.701]         }
[16:19:14.701]         base::close(...future.stdout)
[16:19:14.701]         ...future.stdout <- NULL
[16:19:14.701]     }
[16:19:14.701]     ...future.result$conditions <- ...future.conditions
[16:19:14.701]     ...future.result$finished <- base::Sys.time()
[16:19:14.701]     ...future.result
[16:19:14.701] }
[16:19:14.704] assign_globals() ...
[16:19:14.704] List of 11
[16:19:14.704]  $ ...future.FUN            :function (x, ...)  
[16:19:14.704]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:19:14.704]  $ times                    : int 5
[16:19:14.704]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.704]  $ stop_if_not              :function (...)  
[16:19:14.704]  $ dim                      : NULL
[16:19:14.704]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.704]  $ future.call.arguments    : list()
[16:19:14.704]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.704]  $ ...future.elements_ii    :List of 4
[16:19:14.704]   ..$ : int [1:3] 1 2 3
[16:19:14.704]   ..$ : int [1:4] 1 2 3 4
[16:19:14.704]   ..$ : int [1:5] 1 2 3 4 5
[16:19:14.704]   ..$ : int [1:6] 1 2 3 4 5 6
[16:19:14.704]  $ ...future.seeds_ii       : NULL
[16:19:14.704]  $ ...future.globals.maxSize: NULL
[16:19:14.704]  - attr(*, "where")=List of 11
[16:19:14.704]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.704]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.704]  - attr(*, "resolved")= logi FALSE
[16:19:14.704]  - attr(*, "total_size")= num 141240
[16:19:14.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.704]  - attr(*, "already-done")= logi TRUE
[16:19:14.713] - copied ‘...future.FUN’ to environment
[16:19:14.713] - copied ‘x_FUN’ to environment
[16:19:14.713] - copied ‘times’ to environment
[16:19:14.713] - copied ‘stopf’ to environment
[16:19:14.713] - copied ‘stop_if_not’ to environment
[16:19:14.713] - copied ‘dim’ to environment
[16:19:14.714] - copied ‘valid_types’ to environment
[16:19:14.714] - copied ‘future.call.arguments’ to environment
[16:19:14.714] - copied ‘...future.elements_ii’ to environment
[16:19:14.714] - copied ‘...future.seeds_ii’ to environment
[16:19:14.714] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.714] assign_globals() ... done
[16:19:14.714] requestCore(): workers = 2
[16:19:14.717] MulticoreFuture started
[16:19:14.717] - Launch lazy future ... done
[16:19:14.717] run() for ‘MulticoreFuture’ ... done
[16:19:14.718] Created future:
[16:19:14.718] plan(): Setting new future strategy stack:
[16:19:14.719] List of future strategies:
[16:19:14.719] 1. sequential:
[16:19:14.719]    - args: function (..., envir = parent.frame())
[16:19:14.719]    - tweaked: FALSE
[16:19:14.719]    - call: NULL
[16:19:14.719] plan(): nbrOfWorkers() = 1
[16:19:14.722] plan(): Setting new future strategy stack:
[16:19:14.722] List of future strategies:
[16:19:14.722] 1. multicore:
[16:19:14.722]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.722]    - tweaked: FALSE
[16:19:14.722]    - call: plan(strategy)
[16:19:14.728] plan(): nbrOfWorkers() = 2
[16:19:14.718] MulticoreFuture:
[16:19:14.718] Label: ‘future_vapply-1’
[16:19:14.718] Expression:
[16:19:14.718] {
[16:19:14.718]     do.call(function(...) {
[16:19:14.718]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.718]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.718]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.718]             on.exit(options(oopts), add = TRUE)
[16:19:14.718]         }
[16:19:14.718]         {
[16:19:14.718]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.718]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.718]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.718]             })
[16:19:14.718]         }
[16:19:14.718]     }, args = future.call.arguments)
[16:19:14.718] }
[16:19:14.718] Lazy evaluation: FALSE
[16:19:14.718] Asynchronous evaluation: TRUE
[16:19:14.718] Local evaluation: TRUE
[16:19:14.718] Environment: R_GlobalEnv
[16:19:14.718] Capture standard output: TRUE
[16:19:14.718] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.718] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.718] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:14.718] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.718] Resolved: TRUE
[16:19:14.718] Value: <not collected>
[16:19:14.718] Conditions captured: <none>
[16:19:14.718] Early signaling: FALSE
[16:19:14.718] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.718] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.729] Chunk #1 of 2 ... DONE
[16:19:14.729] Chunk #2 of 2 ...
[16:19:14.729]  - Finding globals in 'X' for chunk #2 ...
[16:19:14.729] getGlobalsAndPackages() ...
[16:19:14.730] Searching for globals...
[16:19:14.730] 
[16:19:14.730] Searching for globals ... DONE
[16:19:14.730] - globals: [0] <none>
[16:19:14.730] getGlobalsAndPackages() ... DONE
[16:19:14.730]    + additional globals found: [n=0] 
[16:19:14.731]    + additional namespaces needed: [n=0] 
[16:19:14.731]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:14.731]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.731]  - seeds: <none>
[16:19:14.731]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.731] getGlobalsAndPackages() ...
[16:19:14.731] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.732] Resolving globals: FALSE
[16:19:14.732] Tweak future expression to call with '...' arguments ...
[16:19:14.732] {
[16:19:14.732]     do.call(function(...) {
[16:19:14.732]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.732]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.732]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.732]             on.exit(options(oopts), add = TRUE)
[16:19:14.732]         }
[16:19:14.732]         {
[16:19:14.732]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.732]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.732]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.732]             })
[16:19:14.732]         }
[16:19:14.732]     }, args = future.call.arguments)
[16:19:14.732] }
[16:19:14.732] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.737] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.738] - packages: [2] ‘stats’, ‘future.apply’
[16:19:14.738] getGlobalsAndPackages() ... DONE
[16:19:14.739] run() for ‘Future’ ...
[16:19:14.739] - state: ‘created’
[16:19:14.740] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.747]   - Field: ‘label’
[16:19:14.747]   - Field: ‘local’
[16:19:14.747]   - Field: ‘owner’
[16:19:14.747]   - Field: ‘envir’
[16:19:14.748]   - Field: ‘workers’
[16:19:14.748]   - Field: ‘packages’
[16:19:14.748]   - Field: ‘gc’
[16:19:14.748]   - Field: ‘job’
[16:19:14.748]   - Field: ‘conditions’
[16:19:14.749]   - Field: ‘expr’
[16:19:14.749]   - Field: ‘uuid’
[16:19:14.749]   - Field: ‘seed’
[16:19:14.749]   - Field: ‘version’
[16:19:14.750]   - Field: ‘result’
[16:19:14.750]   - Field: ‘asynchronous’
[16:19:14.750]   - Field: ‘calls’
[16:19:14.750]   - Field: ‘globals’
[16:19:14.751]   - Field: ‘stdout’
[16:19:14.751]   - Field: ‘earlySignal’
[16:19:14.751]   - Field: ‘lazy’
[16:19:14.751]   - Field: ‘state’
[16:19:14.751] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.751] - Launch lazy future ...
[16:19:14.752] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:14.752] Packages needed by future strategies (n = 0): <none>
[16:19:14.753] {
[16:19:14.753]     {
[16:19:14.753]         {
[16:19:14.753]             ...future.startTime <- base::Sys.time()
[16:19:14.753]             {
[16:19:14.753]                 {
[16:19:14.753]                   {
[16:19:14.753]                     {
[16:19:14.753]                       {
[16:19:14.753]                         base::local({
[16:19:14.753]                           has_future <- base::requireNamespace("future", 
[16:19:14.753]                             quietly = TRUE)
[16:19:14.753]                           if (has_future) {
[16:19:14.753]                             ns <- base::getNamespace("future")
[16:19:14.753]                             version <- ns[[".package"]][["version"]]
[16:19:14.753]                             if (is.null(version)) 
[16:19:14.753]                               version <- utils::packageVersion("future")
[16:19:14.753]                           }
[16:19:14.753]                           else {
[16:19:14.753]                             version <- NULL
[16:19:14.753]                           }
[16:19:14.753]                           if (!has_future || version < "1.8.0") {
[16:19:14.753]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.753]                               "", base::R.version$version.string), 
[16:19:14.753]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.753]                                 base::R.version$platform, 8 * 
[16:19:14.753]                                   base::.Machine$sizeof.pointer), 
[16:19:14.753]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.753]                                 "release", "version")], collapse = " "), 
[16:19:14.753]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.753]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.753]                               info)
[16:19:14.753]                             info <- base::paste(info, collapse = "; ")
[16:19:14.753]                             if (!has_future) {
[16:19:14.753]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.753]                                 info)
[16:19:14.753]                             }
[16:19:14.753]                             else {
[16:19:14.753]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.753]                                 info, version)
[16:19:14.753]                             }
[16:19:14.753]                             base::stop(msg)
[16:19:14.753]                           }
[16:19:14.753]                         })
[16:19:14.753]                       }
[16:19:14.753]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.753]                       base::options(mc.cores = 1L)
[16:19:14.753]                     }
[16:19:14.753]                     base::local({
[16:19:14.753]                       for (pkg in c("stats", "future.apply")) {
[16:19:14.753]                         base::loadNamespace(pkg)
[16:19:14.753]                         base::library(pkg, character.only = TRUE)
[16:19:14.753]                       }
[16:19:14.753]                     })
[16:19:14.753]                   }
[16:19:14.753]                   ...future.strategy.old <- future::plan("list")
[16:19:14.753]                   options(future.plan = NULL)
[16:19:14.753]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.753]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.753]                 }
[16:19:14.753]                 ...future.workdir <- getwd()
[16:19:14.753]             }
[16:19:14.753]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.753]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.753]         }
[16:19:14.753]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.753]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.753]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.753]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.753]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.753]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.753]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.753]             base::names(...future.oldOptions))
[16:19:14.753]     }
[16:19:14.753]     if (FALSE) {
[16:19:14.753]     }
[16:19:14.753]     else {
[16:19:14.753]         if (TRUE) {
[16:19:14.753]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.753]                 open = "w")
[16:19:14.753]         }
[16:19:14.753]         else {
[16:19:14.753]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.753]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.753]         }
[16:19:14.753]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.753]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.753]             base::sink(type = "output", split = FALSE)
[16:19:14.753]             base::close(...future.stdout)
[16:19:14.753]         }, add = TRUE)
[16:19:14.753]     }
[16:19:14.753]     ...future.frame <- base::sys.nframe()
[16:19:14.753]     ...future.conditions <- base::list()
[16:19:14.753]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.753]     if (FALSE) {
[16:19:14.753]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.753]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.753]     }
[16:19:14.753]     ...future.result <- base::tryCatch({
[16:19:14.753]         base::withCallingHandlers({
[16:19:14.753]             ...future.value <- base::withVisible(base::local({
[16:19:14.753]                 withCallingHandlers({
[16:19:14.753]                   {
[16:19:14.753]                     do.call(function(...) {
[16:19:14.753]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.753]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.753]                         ...future.globals.maxSize)) {
[16:19:14.753]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.753]                         on.exit(options(oopts), add = TRUE)
[16:19:14.753]                       }
[16:19:14.753]                       {
[16:19:14.753]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.753]                           FUN = function(jj) {
[16:19:14.753]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.753]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.753]                           })
[16:19:14.753]                       }
[16:19:14.753]                     }, args = future.call.arguments)
[16:19:14.753]                   }
[16:19:14.753]                 }, immediateCondition = function(cond) {
[16:19:14.753]                   save_rds <- function (object, pathname, ...) 
[16:19:14.753]                   {
[16:19:14.753]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.753]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.753]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.753]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.753]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.753]                         fi_tmp[["mtime"]])
[16:19:14.753]                     }
[16:19:14.753]                     tryCatch({
[16:19:14.753]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.753]                     }, error = function(ex) {
[16:19:14.753]                       msg <- conditionMessage(ex)
[16:19:14.753]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.753]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.753]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.753]                         fi_tmp[["mtime"]], msg)
[16:19:14.753]                       ex$message <- msg
[16:19:14.753]                       stop(ex)
[16:19:14.753]                     })
[16:19:14.753]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.753]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.753]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.753]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.753]                       fi <- file.info(pathname)
[16:19:14.753]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.753]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.753]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.753]                         fi[["size"]], fi[["mtime"]])
[16:19:14.753]                       stop(msg)
[16:19:14.753]                     }
[16:19:14.753]                     invisible(pathname)
[16:19:14.753]                   }
[16:19:14.753]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.753]                     rootPath = tempdir()) 
[16:19:14.753]                   {
[16:19:14.753]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.753]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.753]                       tmpdir = path, fileext = ".rds")
[16:19:14.753]                     save_rds(obj, file)
[16:19:14.753]                   }
[16:19:14.753]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.753]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.753]                   {
[16:19:14.753]                     inherits <- base::inherits
[16:19:14.753]                     invokeRestart <- base::invokeRestart
[16:19:14.753]                     is.null <- base::is.null
[16:19:14.753]                     muffled <- FALSE
[16:19:14.753]                     if (inherits(cond, "message")) {
[16:19:14.753]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.753]                       if (muffled) 
[16:19:14.753]                         invokeRestart("muffleMessage")
[16:19:14.753]                     }
[16:19:14.753]                     else if (inherits(cond, "warning")) {
[16:19:14.753]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.753]                       if (muffled) 
[16:19:14.753]                         invokeRestart("muffleWarning")
[16:19:14.753]                     }
[16:19:14.753]                     else if (inherits(cond, "condition")) {
[16:19:14.753]                       if (!is.null(pattern)) {
[16:19:14.753]                         computeRestarts <- base::computeRestarts
[16:19:14.753]                         grepl <- base::grepl
[16:19:14.753]                         restarts <- computeRestarts(cond)
[16:19:14.753]                         for (restart in restarts) {
[16:19:14.753]                           name <- restart$name
[16:19:14.753]                           if (is.null(name)) 
[16:19:14.753]                             next
[16:19:14.753]                           if (!grepl(pattern, name)) 
[16:19:14.753]                             next
[16:19:14.753]                           invokeRestart(restart)
[16:19:14.753]                           muffled <- TRUE
[16:19:14.753]                           break
[16:19:14.753]                         }
[16:19:14.753]                       }
[16:19:14.753]                     }
[16:19:14.753]                     invisible(muffled)
[16:19:14.753]                   }
[16:19:14.753]                   muffleCondition(cond)
[16:19:14.753]                 })
[16:19:14.753]             }))
[16:19:14.753]             future::FutureResult(value = ...future.value$value, 
[16:19:14.753]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.753]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.753]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.753]                     ...future.globalenv.names))
[16:19:14.753]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.753]         }, condition = base::local({
[16:19:14.753]             c <- base::c
[16:19:14.753]             inherits <- base::inherits
[16:19:14.753]             invokeRestart <- base::invokeRestart
[16:19:14.753]             length <- base::length
[16:19:14.753]             list <- base::list
[16:19:14.753]             seq.int <- base::seq.int
[16:19:14.753]             signalCondition <- base::signalCondition
[16:19:14.753]             sys.calls <- base::sys.calls
[16:19:14.753]             `[[` <- base::`[[`
[16:19:14.753]             `+` <- base::`+`
[16:19:14.753]             `<<-` <- base::`<<-`
[16:19:14.753]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.753]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.753]                   3L)]
[16:19:14.753]             }
[16:19:14.753]             function(cond) {
[16:19:14.753]                 is_error <- inherits(cond, "error")
[16:19:14.753]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.753]                   NULL)
[16:19:14.753]                 if (is_error) {
[16:19:14.753]                   sessionInformation <- function() {
[16:19:14.753]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.753]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.753]                       search = base::search(), system = base::Sys.info())
[16:19:14.753]                   }
[16:19:14.753]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.753]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.753]                     cond$call), session = sessionInformation(), 
[16:19:14.753]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.753]                   signalCondition(cond)
[16:19:14.753]                 }
[16:19:14.753]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.753]                 "immediateCondition"))) {
[16:19:14.753]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.753]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.753]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.753]                   if (TRUE && !signal) {
[16:19:14.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.753]                     {
[16:19:14.753]                       inherits <- base::inherits
[16:19:14.753]                       invokeRestart <- base::invokeRestart
[16:19:14.753]                       is.null <- base::is.null
[16:19:14.753]                       muffled <- FALSE
[16:19:14.753]                       if (inherits(cond, "message")) {
[16:19:14.753]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.753]                         if (muffled) 
[16:19:14.753]                           invokeRestart("muffleMessage")
[16:19:14.753]                       }
[16:19:14.753]                       else if (inherits(cond, "warning")) {
[16:19:14.753]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.753]                         if (muffled) 
[16:19:14.753]                           invokeRestart("muffleWarning")
[16:19:14.753]                       }
[16:19:14.753]                       else if (inherits(cond, "condition")) {
[16:19:14.753]                         if (!is.null(pattern)) {
[16:19:14.753]                           computeRestarts <- base::computeRestarts
[16:19:14.753]                           grepl <- base::grepl
[16:19:14.753]                           restarts <- computeRestarts(cond)
[16:19:14.753]                           for (restart in restarts) {
[16:19:14.753]                             name <- restart$name
[16:19:14.753]                             if (is.null(name)) 
[16:19:14.753]                               next
[16:19:14.753]                             if (!grepl(pattern, name)) 
[16:19:14.753]                               next
[16:19:14.753]                             invokeRestart(restart)
[16:19:14.753]                             muffled <- TRUE
[16:19:14.753]                             break
[16:19:14.753]                           }
[16:19:14.753]                         }
[16:19:14.753]                       }
[16:19:14.753]                       invisible(muffled)
[16:19:14.753]                     }
[16:19:14.753]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.753]                   }
[16:19:14.753]                 }
[16:19:14.753]                 else {
[16:19:14.753]                   if (TRUE) {
[16:19:14.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.753]                     {
[16:19:14.753]                       inherits <- base::inherits
[16:19:14.753]                       invokeRestart <- base::invokeRestart
[16:19:14.753]                       is.null <- base::is.null
[16:19:14.753]                       muffled <- FALSE
[16:19:14.753]                       if (inherits(cond, "message")) {
[16:19:14.753]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.753]                         if (muffled) 
[16:19:14.753]                           invokeRestart("muffleMessage")
[16:19:14.753]                       }
[16:19:14.753]                       else if (inherits(cond, "warning")) {
[16:19:14.753]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.753]                         if (muffled) 
[16:19:14.753]                           invokeRestart("muffleWarning")
[16:19:14.753]                       }
[16:19:14.753]                       else if (inherits(cond, "condition")) {
[16:19:14.753]                         if (!is.null(pattern)) {
[16:19:14.753]                           computeRestarts <- base::computeRestarts
[16:19:14.753]                           grepl <- base::grepl
[16:19:14.753]                           restarts <- computeRestarts(cond)
[16:19:14.753]                           for (restart in restarts) {
[16:19:14.753]                             name <- restart$name
[16:19:14.753]                             if (is.null(name)) 
[16:19:14.753]                               next
[16:19:14.753]                             if (!grepl(pattern, name)) 
[16:19:14.753]                               next
[16:19:14.753]                             invokeRestart(restart)
[16:19:14.753]                             muffled <- TRUE
[16:19:14.753]                             break
[16:19:14.753]                           }
[16:19:14.753]                         }
[16:19:14.753]                       }
[16:19:14.753]                       invisible(muffled)
[16:19:14.753]                     }
[16:19:14.753]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.753]                   }
[16:19:14.753]                 }
[16:19:14.753]             }
[16:19:14.753]         }))
[16:19:14.753]     }, error = function(ex) {
[16:19:14.753]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.753]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.753]                 ...future.rng), started = ...future.startTime, 
[16:19:14.753]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.753]             version = "1.8"), class = "FutureResult")
[16:19:14.753]     }, finally = {
[16:19:14.753]         if (!identical(...future.workdir, getwd())) 
[16:19:14.753]             setwd(...future.workdir)
[16:19:14.753]         {
[16:19:14.753]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.753]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.753]             }
[16:19:14.753]             base::options(...future.oldOptions)
[16:19:14.753]             if (.Platform$OS.type == "windows") {
[16:19:14.753]                 old_names <- names(...future.oldEnvVars)
[16:19:14.753]                 envs <- base::Sys.getenv()
[16:19:14.753]                 names <- names(envs)
[16:19:14.753]                 common <- intersect(names, old_names)
[16:19:14.753]                 added <- setdiff(names, old_names)
[16:19:14.753]                 removed <- setdiff(old_names, names)
[16:19:14.753]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.753]                   envs[common]]
[16:19:14.753]                 NAMES <- toupper(changed)
[16:19:14.753]                 args <- list()
[16:19:14.753]                 for (kk in seq_along(NAMES)) {
[16:19:14.753]                   name <- changed[[kk]]
[16:19:14.753]                   NAME <- NAMES[[kk]]
[16:19:14.753]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.753]                     next
[16:19:14.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.753]                 }
[16:19:14.753]                 NAMES <- toupper(added)
[16:19:14.753]                 for (kk in seq_along(NAMES)) {
[16:19:14.753]                   name <- added[[kk]]
[16:19:14.753]                   NAME <- NAMES[[kk]]
[16:19:14.753]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.753]                     next
[16:19:14.753]                   args[[name]] <- ""
[16:19:14.753]                 }
[16:19:14.753]                 NAMES <- toupper(removed)
[16:19:14.753]                 for (kk in seq_along(NAMES)) {
[16:19:14.753]                   name <- removed[[kk]]
[16:19:14.753]                   NAME <- NAMES[[kk]]
[16:19:14.753]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.753]                     next
[16:19:14.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.753]                 }
[16:19:14.753]                 if (length(args) > 0) 
[16:19:14.753]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.753]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.753]             }
[16:19:14.753]             else {
[16:19:14.753]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.753]             }
[16:19:14.753]             {
[16:19:14.753]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.753]                   0L) {
[16:19:14.753]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.753]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.753]                   base::options(opts)
[16:19:14.753]                 }
[16:19:14.753]                 {
[16:19:14.753]                   {
[16:19:14.753]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.753]                     NULL
[16:19:14.753]                   }
[16:19:14.753]                   options(future.plan = NULL)
[16:19:14.753]                   if (is.na(NA_character_)) 
[16:19:14.753]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.753]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.753]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.753]                     .init = FALSE)
[16:19:14.753]                 }
[16:19:14.753]             }
[16:19:14.753]         }
[16:19:14.753]     })
[16:19:14.753]     if (TRUE) {
[16:19:14.753]         base::sink(type = "output", split = FALSE)
[16:19:14.753]         if (TRUE) {
[16:19:14.753]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.753]         }
[16:19:14.753]         else {
[16:19:14.753]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.753]         }
[16:19:14.753]         base::close(...future.stdout)
[16:19:14.753]         ...future.stdout <- NULL
[16:19:14.753]     }
[16:19:14.753]     ...future.result$conditions <- ...future.conditions
[16:19:14.753]     ...future.result$finished <- base::Sys.time()
[16:19:14.753]     ...future.result
[16:19:14.753] }
[16:19:14.756] assign_globals() ...
[16:19:14.756] List of 11
[16:19:14.756]  $ ...future.FUN            :function (x, ...)  
[16:19:14.756]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:19:14.756]  $ times                    : int 5
[16:19:14.756]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.756]  $ stop_if_not              :function (...)  
[16:19:14.756]  $ dim                      : NULL
[16:19:14.756]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.756]  $ future.call.arguments    : list()
[16:19:14.756]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.756]  $ ...future.elements_ii    :List of 3
[16:19:14.756]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:19:14.756]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:19:14.756]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:19:14.756]  $ ...future.seeds_ii       : NULL
[16:19:14.756]  $ ...future.globals.maxSize: NULL
[16:19:14.756]  - attr(*, "where")=List of 11
[16:19:14.756]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.756]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.756]  - attr(*, "resolved")= logi FALSE
[16:19:14.756]  - attr(*, "total_size")= num 141240
[16:19:14.756]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.756]  - attr(*, "already-done")= logi TRUE
[16:19:14.767] - copied ‘...future.FUN’ to environment
[16:19:14.767] - copied ‘x_FUN’ to environment
[16:19:14.767] - copied ‘times’ to environment
[16:19:14.767] - copied ‘stopf’ to environment
[16:19:14.767] - copied ‘stop_if_not’ to environment
[16:19:14.767] - copied ‘dim’ to environment
[16:19:14.767] - copied ‘valid_types’ to environment
[16:19:14.768] - copied ‘future.call.arguments’ to environment
[16:19:14.768] - copied ‘...future.elements_ii’ to environment
[16:19:14.768] - copied ‘...future.seeds_ii’ to environment
[16:19:14.768] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.768] assign_globals() ... done
[16:19:14.768] requestCore(): workers = 2
[16:19:14.771] MulticoreFuture started
[16:19:14.771] - Launch lazy future ... done
[16:19:14.771] run() for ‘MulticoreFuture’ ... done
[16:19:14.771] Created future:
[16:19:14.772] plan(): Setting new future strategy stack:
[16:19:14.773] List of future strategies:
[16:19:14.773] 1. sequential:
[16:19:14.773]    - args: function (..., envir = parent.frame())
[16:19:14.773]    - tweaked: FALSE
[16:19:14.773]    - call: NULL
[16:19:14.773] plan(): nbrOfWorkers() = 1
[16:19:14.783] plan(): Setting new future strategy stack:
[16:19:14.783] List of future strategies:
[16:19:14.783] 1. multicore:
[16:19:14.783]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.783]    - tweaked: FALSE
[16:19:14.783]    - call: plan(strategy)
[16:19:14.789] plan(): nbrOfWorkers() = 2
[16:19:14.772] MulticoreFuture:
[16:19:14.772] Label: ‘future_vapply-2’
[16:19:14.772] Expression:
[16:19:14.772] {
[16:19:14.772]     do.call(function(...) {
[16:19:14.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.772]             on.exit(options(oopts), add = TRUE)
[16:19:14.772]         }
[16:19:14.772]         {
[16:19:14.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.772]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.772]             })
[16:19:14.772]         }
[16:19:14.772]     }, args = future.call.arguments)
[16:19:14.772] }
[16:19:14.772] Lazy evaluation: FALSE
[16:19:14.772] Asynchronous evaluation: TRUE
[16:19:14.772] Local evaluation: TRUE
[16:19:14.772] Environment: R_GlobalEnv
[16:19:14.772] Capture standard output: TRUE
[16:19:14.772] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.772] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.772] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:14.772] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.772] Resolved: TRUE
[16:19:14.772] Value: <not collected>
[16:19:14.772] Conditions captured: <none>
[16:19:14.772] Early signaling: FALSE
[16:19:14.772] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.772] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.790] Chunk #2 of 2 ... DONE
[16:19:14.790] Launching 2 futures (chunks) ... DONE
[16:19:14.790] Resolving 2 futures (chunks) ...
[16:19:14.790] resolve() on list ...
[16:19:14.791]  recursive: 0
[16:19:14.791]  length: 2
[16:19:14.791] 
[16:19:14.791] Future #1
[16:19:14.791] result() for MulticoreFuture ...
[16:19:14.792] result() for MulticoreFuture ...
[16:19:14.793] result() for MulticoreFuture ... done
[16:19:14.793] result() for MulticoreFuture ... done
[16:19:14.793] result() for MulticoreFuture ...
[16:19:14.793] result() for MulticoreFuture ... done
[16:19:14.794] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:14.794] - nx: 2
[16:19:14.794] - relay: TRUE
[16:19:14.794] - stdout: TRUE
[16:19:14.794] - signal: TRUE
[16:19:14.795] - resignal: FALSE
[16:19:14.795] - force: TRUE
[16:19:14.795] - relayed: [n=2] FALSE, FALSE
[16:19:14.795] - queued futures: [n=2] FALSE, FALSE
[16:19:14.795]  - until=1
[16:19:14.796]  - relaying element #1
[16:19:14.796] result() for MulticoreFuture ...
[16:19:14.796] result() for MulticoreFuture ... done
[16:19:14.796] result() for MulticoreFuture ...
[16:19:14.797] result() for MulticoreFuture ... done
[16:19:14.797] result() for MulticoreFuture ...
[16:19:14.797] result() for MulticoreFuture ... done
[16:19:14.797] result() for MulticoreFuture ...
[16:19:14.797] result() for MulticoreFuture ... done
[16:19:14.798] - relayed: [n=2] TRUE, FALSE
[16:19:14.798] - queued futures: [n=2] TRUE, FALSE
[16:19:14.798] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:14.798]  length: 1 (resolved future 1)
[16:19:14.799] Future #2
[16:19:14.799] result() for MulticoreFuture ...
[16:19:14.800] result() for MulticoreFuture ...
[16:19:14.800] result() for MulticoreFuture ... done
[16:19:14.800] result() for MulticoreFuture ... done
[16:19:14.801] result() for MulticoreFuture ...
[16:19:14.801] result() for MulticoreFuture ... done
[16:19:14.801] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:14.801] - nx: 2
[16:19:14.801] - relay: TRUE
[16:19:14.802] - stdout: TRUE
[16:19:14.802] - signal: TRUE
[16:19:14.802] - resignal: FALSE
[16:19:14.802] - force: TRUE
[16:19:14.802] - relayed: [n=2] TRUE, FALSE
[16:19:14.802] - queued futures: [n=2] TRUE, FALSE
[16:19:14.803]  - until=2
[16:19:14.803]  - relaying element #2
[16:19:14.803] result() for MulticoreFuture ...
[16:19:14.803] result() for MulticoreFuture ... done
[16:19:14.803] result() for MulticoreFuture ...
[16:19:14.803] result() for MulticoreFuture ... done
[16:19:14.804] result() for MulticoreFuture ...
[16:19:14.804] result() for MulticoreFuture ... done
[16:19:14.804] result() for MulticoreFuture ...
[16:19:14.804] result() for MulticoreFuture ... done
[16:19:14.804] - relayed: [n=2] TRUE, TRUE
[16:19:14.804] - queued futures: [n=2] TRUE, TRUE
[16:19:14.804] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:14.805]  length: 0 (resolved future 2)
[16:19:14.805] Relaying remaining futures
[16:19:14.805] signalConditionsASAP(NULL, pos=0) ...
[16:19:14.805] - nx: 2
[16:19:14.805] - relay: TRUE
[16:19:14.805] - stdout: TRUE
[16:19:14.805] - signal: TRUE
[16:19:14.805] - resignal: FALSE
[16:19:14.805] - force: TRUE
[16:19:14.805] - relayed: [n=2] TRUE, TRUE
[16:19:14.806] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:14.806] - relayed: [n=2] TRUE, TRUE
[16:19:14.806] - queued futures: [n=2] TRUE, TRUE
[16:19:14.806] signalConditionsASAP(NULL, pos=0) ... done
[16:19:14.806] resolve() on list ... DONE
[16:19:14.806] result() for MulticoreFuture ...
[16:19:14.806] result() for MulticoreFuture ... done
[16:19:14.806] result() for MulticoreFuture ...
[16:19:14.806] result() for MulticoreFuture ... done
[16:19:14.807] result() for MulticoreFuture ...
[16:19:14.807] result() for MulticoreFuture ... done
[16:19:14.807] result() for MulticoreFuture ...
[16:19:14.807] result() for MulticoreFuture ... done
[16:19:14.807]  - Number of value chunks collected: 2
[16:19:14.807] Resolving 2 futures (chunks) ... DONE
[16:19:14.807] Reducing values from 2 chunks ...
[16:19:14.807]  - Number of values collected after concatenation: 7
[16:19:14.807]  - Number of values expected: 7
[16:19:14.808] Reducing values from 2 chunks ... DONE
[16:19:14.808] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:19:14.810] future_lapply() ...
[16:19:14.815] Number of chunks: 2
[16:19:14.815] getGlobalsAndPackagesXApply() ...
[16:19:14.815]  - future.globals: TRUE
[16:19:14.815] getGlobalsAndPackages() ...
[16:19:14.815] Searching for globals...
[16:19:14.816] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:19:14.817] Searching for globals ... DONE
[16:19:14.817] Resolving globals: FALSE
[16:19:14.817] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:19:14.817] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:19:14.818] - globals: [1] ‘FUN’
[16:19:14.818] 
[16:19:14.818] getGlobalsAndPackages() ... DONE
[16:19:14.818]  - globals found/used: [n=1] ‘FUN’
[16:19:14.818]  - needed namespaces: [n=0] 
[16:19:14.818] Finding globals ... DONE
[16:19:14.818]  - use_args: TRUE
[16:19:14.818]  - Getting '...' globals ...
[16:19:14.819] resolve() on list ...
[16:19:14.819]  recursive: 0
[16:19:14.819]  length: 1
[16:19:14.819]  elements: ‘...’
[16:19:14.819]  length: 0 (resolved future 1)
[16:19:14.819] resolve() on list ... DONE
[16:19:14.819]    - '...' content: [n=1] ‘y’
[16:19:14.819] List of 1
[16:19:14.819]  $ ...:List of 1
[16:19:14.819]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:14.819]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.819]  - attr(*, "where")=List of 1
[16:19:14.819]   ..$ ...:<environment: 0x56199d705650> 
[16:19:14.819]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.819]  - attr(*, "resolved")= logi TRUE
[16:19:14.819]  - attr(*, "total_size")= num NA
[16:19:14.825]  - Getting '...' globals ... DONE
[16:19:14.825] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:14.825] List of 2
[16:19:14.825]  $ ...future.FUN:function (x, y)  
[16:19:14.825]  $ ...          :List of 1
[16:19:14.825]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:14.825]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.825]  - attr(*, "where")=List of 2
[16:19:14.825]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:14.825]   ..$ ...          :<environment: 0x56199d705650> 
[16:19:14.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.825]  - attr(*, "resolved")= logi FALSE
[16:19:14.825]  - attr(*, "total_size")= num 4264
[16:19:14.829] Packages to be attached in all futures: [n=0] 
[16:19:14.829] getGlobalsAndPackagesXApply() ... DONE
[16:19:14.829] Number of futures (= number of chunks): 2
[16:19:14.829] Launching 2 futures (chunks) ...
[16:19:14.830] Chunk #1 of 2 ...
[16:19:14.830]  - Finding globals in 'X' for chunk #1 ...
[16:19:14.830] getGlobalsAndPackages() ...
[16:19:14.830] Searching for globals...
[16:19:14.830] 
[16:19:14.830] Searching for globals ... DONE
[16:19:14.830] - globals: [0] <none>
[16:19:14.830] getGlobalsAndPackages() ... DONE
[16:19:14.830]    + additional globals found: [n=0] 
[16:19:14.831]    + additional namespaces needed: [n=0] 
[16:19:14.831]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:14.831]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.831]  - seeds: <none>
[16:19:14.831]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.831] getGlobalsAndPackages() ...
[16:19:14.831] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.831] Resolving globals: FALSE
[16:19:14.831] Tweak future expression to call with '...' arguments ...
[16:19:14.832] {
[16:19:14.832]     do.call(function(...) {
[16:19:14.832]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.832]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.832]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.832]             on.exit(options(oopts), add = TRUE)
[16:19:14.832]         }
[16:19:14.832]         {
[16:19:14.832]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.832]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.832]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.832]             })
[16:19:14.832]         }
[16:19:14.832]     }, args = future.call.arguments)
[16:19:14.832] }
[16:19:14.832] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.832] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.832] 
[16:19:14.832] getGlobalsAndPackages() ... DONE
[16:19:14.833] run() for ‘Future’ ...
[16:19:14.833] - state: ‘created’
[16:19:14.833] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.837] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.837]   - Field: ‘label’
[16:19:14.837]   - Field: ‘local’
[16:19:14.837]   - Field: ‘owner’
[16:19:14.837]   - Field: ‘envir’
[16:19:14.837]   - Field: ‘workers’
[16:19:14.837]   - Field: ‘packages’
[16:19:14.837]   - Field: ‘gc’
[16:19:14.838]   - Field: ‘job’
[16:19:14.838]   - Field: ‘conditions’
[16:19:14.838]   - Field: ‘expr’
[16:19:14.838]   - Field: ‘uuid’
[16:19:14.838]   - Field: ‘seed’
[16:19:14.838]   - Field: ‘version’
[16:19:14.838]   - Field: ‘result’
[16:19:14.838]   - Field: ‘asynchronous’
[16:19:14.838]   - Field: ‘calls’
[16:19:14.838]   - Field: ‘globals’
[16:19:14.838]   - Field: ‘stdout’
[16:19:14.839]   - Field: ‘earlySignal’
[16:19:14.839]   - Field: ‘lazy’
[16:19:14.839]   - Field: ‘state’
[16:19:14.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.839] - Launch lazy future ...
[16:19:14.839] Packages needed by the future expression (n = 0): <none>
[16:19:14.839] Packages needed by future strategies (n = 0): <none>
[16:19:14.840] {
[16:19:14.840]     {
[16:19:14.840]         {
[16:19:14.840]             ...future.startTime <- base::Sys.time()
[16:19:14.840]             {
[16:19:14.840]                 {
[16:19:14.840]                   {
[16:19:14.840]                     {
[16:19:14.840]                       base::local({
[16:19:14.840]                         has_future <- base::requireNamespace("future", 
[16:19:14.840]                           quietly = TRUE)
[16:19:14.840]                         if (has_future) {
[16:19:14.840]                           ns <- base::getNamespace("future")
[16:19:14.840]                           version <- ns[[".package"]][["version"]]
[16:19:14.840]                           if (is.null(version)) 
[16:19:14.840]                             version <- utils::packageVersion("future")
[16:19:14.840]                         }
[16:19:14.840]                         else {
[16:19:14.840]                           version <- NULL
[16:19:14.840]                         }
[16:19:14.840]                         if (!has_future || version < "1.8.0") {
[16:19:14.840]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.840]                             "", base::R.version$version.string), 
[16:19:14.840]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:14.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:14.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.840]                               "release", "version")], collapse = " "), 
[16:19:14.840]                             hostname = base::Sys.info()[["nodename"]])
[16:19:14.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.840]                             info)
[16:19:14.840]                           info <- base::paste(info, collapse = "; ")
[16:19:14.840]                           if (!has_future) {
[16:19:14.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.840]                               info)
[16:19:14.840]                           }
[16:19:14.840]                           else {
[16:19:14.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.840]                               info, version)
[16:19:14.840]                           }
[16:19:14.840]                           base::stop(msg)
[16:19:14.840]                         }
[16:19:14.840]                       })
[16:19:14.840]                     }
[16:19:14.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.840]                     base::options(mc.cores = 1L)
[16:19:14.840]                   }
[16:19:14.840]                   ...future.strategy.old <- future::plan("list")
[16:19:14.840]                   options(future.plan = NULL)
[16:19:14.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.840]                 }
[16:19:14.840]                 ...future.workdir <- getwd()
[16:19:14.840]             }
[16:19:14.840]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.840]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.840]         }
[16:19:14.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.840]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.840]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.840]             base::names(...future.oldOptions))
[16:19:14.840]     }
[16:19:14.840]     if (FALSE) {
[16:19:14.840]     }
[16:19:14.840]     else {
[16:19:14.840]         if (TRUE) {
[16:19:14.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.840]                 open = "w")
[16:19:14.840]         }
[16:19:14.840]         else {
[16:19:14.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.840]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.840]         }
[16:19:14.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.840]             base::sink(type = "output", split = FALSE)
[16:19:14.840]             base::close(...future.stdout)
[16:19:14.840]         }, add = TRUE)
[16:19:14.840]     }
[16:19:14.840]     ...future.frame <- base::sys.nframe()
[16:19:14.840]     ...future.conditions <- base::list()
[16:19:14.840]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.840]     if (FALSE) {
[16:19:14.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.840]     }
[16:19:14.840]     ...future.result <- base::tryCatch({
[16:19:14.840]         base::withCallingHandlers({
[16:19:14.840]             ...future.value <- base::withVisible(base::local({
[16:19:14.840]                 withCallingHandlers({
[16:19:14.840]                   {
[16:19:14.840]                     do.call(function(...) {
[16:19:14.840]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.840]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.840]                         ...future.globals.maxSize)) {
[16:19:14.840]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.840]                         on.exit(options(oopts), add = TRUE)
[16:19:14.840]                       }
[16:19:14.840]                       {
[16:19:14.840]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.840]                           FUN = function(jj) {
[16:19:14.840]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.840]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.840]                           })
[16:19:14.840]                       }
[16:19:14.840]                     }, args = future.call.arguments)
[16:19:14.840]                   }
[16:19:14.840]                 }, immediateCondition = function(cond) {
[16:19:14.840]                   save_rds <- function (object, pathname, ...) 
[16:19:14.840]                   {
[16:19:14.840]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.840]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.840]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.840]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.840]                         fi_tmp[["mtime"]])
[16:19:14.840]                     }
[16:19:14.840]                     tryCatch({
[16:19:14.840]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.840]                     }, error = function(ex) {
[16:19:14.840]                       msg <- conditionMessage(ex)
[16:19:14.840]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.840]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.840]                         fi_tmp[["mtime"]], msg)
[16:19:14.840]                       ex$message <- msg
[16:19:14.840]                       stop(ex)
[16:19:14.840]                     })
[16:19:14.840]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.840]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.840]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.840]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.840]                       fi <- file.info(pathname)
[16:19:14.840]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.840]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.840]                         fi[["size"]], fi[["mtime"]])
[16:19:14.840]                       stop(msg)
[16:19:14.840]                     }
[16:19:14.840]                     invisible(pathname)
[16:19:14.840]                   }
[16:19:14.840]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.840]                     rootPath = tempdir()) 
[16:19:14.840]                   {
[16:19:14.840]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.840]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.840]                       tmpdir = path, fileext = ".rds")
[16:19:14.840]                     save_rds(obj, file)
[16:19:14.840]                   }
[16:19:14.840]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.840]                   {
[16:19:14.840]                     inherits <- base::inherits
[16:19:14.840]                     invokeRestart <- base::invokeRestart
[16:19:14.840]                     is.null <- base::is.null
[16:19:14.840]                     muffled <- FALSE
[16:19:14.840]                     if (inherits(cond, "message")) {
[16:19:14.840]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.840]                       if (muffled) 
[16:19:14.840]                         invokeRestart("muffleMessage")
[16:19:14.840]                     }
[16:19:14.840]                     else if (inherits(cond, "warning")) {
[16:19:14.840]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.840]                       if (muffled) 
[16:19:14.840]                         invokeRestart("muffleWarning")
[16:19:14.840]                     }
[16:19:14.840]                     else if (inherits(cond, "condition")) {
[16:19:14.840]                       if (!is.null(pattern)) {
[16:19:14.840]                         computeRestarts <- base::computeRestarts
[16:19:14.840]                         grepl <- base::grepl
[16:19:14.840]                         restarts <- computeRestarts(cond)
[16:19:14.840]                         for (restart in restarts) {
[16:19:14.840]                           name <- restart$name
[16:19:14.840]                           if (is.null(name)) 
[16:19:14.840]                             next
[16:19:14.840]                           if (!grepl(pattern, name)) 
[16:19:14.840]                             next
[16:19:14.840]                           invokeRestart(restart)
[16:19:14.840]                           muffled <- TRUE
[16:19:14.840]                           break
[16:19:14.840]                         }
[16:19:14.840]                       }
[16:19:14.840]                     }
[16:19:14.840]                     invisible(muffled)
[16:19:14.840]                   }
[16:19:14.840]                   muffleCondition(cond)
[16:19:14.840]                 })
[16:19:14.840]             }))
[16:19:14.840]             future::FutureResult(value = ...future.value$value, 
[16:19:14.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.840]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.840]                     ...future.globalenv.names))
[16:19:14.840]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.840]         }, condition = base::local({
[16:19:14.840]             c <- base::c
[16:19:14.840]             inherits <- base::inherits
[16:19:14.840]             invokeRestart <- base::invokeRestart
[16:19:14.840]             length <- base::length
[16:19:14.840]             list <- base::list
[16:19:14.840]             seq.int <- base::seq.int
[16:19:14.840]             signalCondition <- base::signalCondition
[16:19:14.840]             sys.calls <- base::sys.calls
[16:19:14.840]             `[[` <- base::`[[`
[16:19:14.840]             `+` <- base::`+`
[16:19:14.840]             `<<-` <- base::`<<-`
[16:19:14.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.840]                   3L)]
[16:19:14.840]             }
[16:19:14.840]             function(cond) {
[16:19:14.840]                 is_error <- inherits(cond, "error")
[16:19:14.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.840]                   NULL)
[16:19:14.840]                 if (is_error) {
[16:19:14.840]                   sessionInformation <- function() {
[16:19:14.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.840]                       search = base::search(), system = base::Sys.info())
[16:19:14.840]                   }
[16:19:14.840]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.840]                     cond$call), session = sessionInformation(), 
[16:19:14.840]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.840]                   signalCondition(cond)
[16:19:14.840]                 }
[16:19:14.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.840]                 "immediateCondition"))) {
[16:19:14.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.840]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.840]                   if (TRUE && !signal) {
[16:19:14.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.840]                     {
[16:19:14.840]                       inherits <- base::inherits
[16:19:14.840]                       invokeRestart <- base::invokeRestart
[16:19:14.840]                       is.null <- base::is.null
[16:19:14.840]                       muffled <- FALSE
[16:19:14.840]                       if (inherits(cond, "message")) {
[16:19:14.840]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.840]                         if (muffled) 
[16:19:14.840]                           invokeRestart("muffleMessage")
[16:19:14.840]                       }
[16:19:14.840]                       else if (inherits(cond, "warning")) {
[16:19:14.840]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.840]                         if (muffled) 
[16:19:14.840]                           invokeRestart("muffleWarning")
[16:19:14.840]                       }
[16:19:14.840]                       else if (inherits(cond, "condition")) {
[16:19:14.840]                         if (!is.null(pattern)) {
[16:19:14.840]                           computeRestarts <- base::computeRestarts
[16:19:14.840]                           grepl <- base::grepl
[16:19:14.840]                           restarts <- computeRestarts(cond)
[16:19:14.840]                           for (restart in restarts) {
[16:19:14.840]                             name <- restart$name
[16:19:14.840]                             if (is.null(name)) 
[16:19:14.840]                               next
[16:19:14.840]                             if (!grepl(pattern, name)) 
[16:19:14.840]                               next
[16:19:14.840]                             invokeRestart(restart)
[16:19:14.840]                             muffled <- TRUE
[16:19:14.840]                             break
[16:19:14.840]                           }
[16:19:14.840]                         }
[16:19:14.840]                       }
[16:19:14.840]                       invisible(muffled)
[16:19:14.840]                     }
[16:19:14.840]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.840]                   }
[16:19:14.840]                 }
[16:19:14.840]                 else {
[16:19:14.840]                   if (TRUE) {
[16:19:14.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.840]                     {
[16:19:14.840]                       inherits <- base::inherits
[16:19:14.840]                       invokeRestart <- base::invokeRestart
[16:19:14.840]                       is.null <- base::is.null
[16:19:14.840]                       muffled <- FALSE
[16:19:14.840]                       if (inherits(cond, "message")) {
[16:19:14.840]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.840]                         if (muffled) 
[16:19:14.840]                           invokeRestart("muffleMessage")
[16:19:14.840]                       }
[16:19:14.840]                       else if (inherits(cond, "warning")) {
[16:19:14.840]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.840]                         if (muffled) 
[16:19:14.840]                           invokeRestart("muffleWarning")
[16:19:14.840]                       }
[16:19:14.840]                       else if (inherits(cond, "condition")) {
[16:19:14.840]                         if (!is.null(pattern)) {
[16:19:14.840]                           computeRestarts <- base::computeRestarts
[16:19:14.840]                           grepl <- base::grepl
[16:19:14.840]                           restarts <- computeRestarts(cond)
[16:19:14.840]                           for (restart in restarts) {
[16:19:14.840]                             name <- restart$name
[16:19:14.840]                             if (is.null(name)) 
[16:19:14.840]                               next
[16:19:14.840]                             if (!grepl(pattern, name)) 
[16:19:14.840]                               next
[16:19:14.840]                             invokeRestart(restart)
[16:19:14.840]                             muffled <- TRUE
[16:19:14.840]                             break
[16:19:14.840]                           }
[16:19:14.840]                         }
[16:19:14.840]                       }
[16:19:14.840]                       invisible(muffled)
[16:19:14.840]                     }
[16:19:14.840]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.840]                   }
[16:19:14.840]                 }
[16:19:14.840]             }
[16:19:14.840]         }))
[16:19:14.840]     }, error = function(ex) {
[16:19:14.840]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.840]                 ...future.rng), started = ...future.startTime, 
[16:19:14.840]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.840]             version = "1.8"), class = "FutureResult")
[16:19:14.840]     }, finally = {
[16:19:14.840]         if (!identical(...future.workdir, getwd())) 
[16:19:14.840]             setwd(...future.workdir)
[16:19:14.840]         {
[16:19:14.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.840]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.840]             }
[16:19:14.840]             base::options(...future.oldOptions)
[16:19:14.840]             if (.Platform$OS.type == "windows") {
[16:19:14.840]                 old_names <- names(...future.oldEnvVars)
[16:19:14.840]                 envs <- base::Sys.getenv()
[16:19:14.840]                 names <- names(envs)
[16:19:14.840]                 common <- intersect(names, old_names)
[16:19:14.840]                 added <- setdiff(names, old_names)
[16:19:14.840]                 removed <- setdiff(old_names, names)
[16:19:14.840]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.840]                   envs[common]]
[16:19:14.840]                 NAMES <- toupper(changed)
[16:19:14.840]                 args <- list()
[16:19:14.840]                 for (kk in seq_along(NAMES)) {
[16:19:14.840]                   name <- changed[[kk]]
[16:19:14.840]                   NAME <- NAMES[[kk]]
[16:19:14.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.840]                     next
[16:19:14.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.840]                 }
[16:19:14.840]                 NAMES <- toupper(added)
[16:19:14.840]                 for (kk in seq_along(NAMES)) {
[16:19:14.840]                   name <- added[[kk]]
[16:19:14.840]                   NAME <- NAMES[[kk]]
[16:19:14.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.840]                     next
[16:19:14.840]                   args[[name]] <- ""
[16:19:14.840]                 }
[16:19:14.840]                 NAMES <- toupper(removed)
[16:19:14.840]                 for (kk in seq_along(NAMES)) {
[16:19:14.840]                   name <- removed[[kk]]
[16:19:14.840]                   NAME <- NAMES[[kk]]
[16:19:14.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.840]                     next
[16:19:14.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.840]                 }
[16:19:14.840]                 if (length(args) > 0) 
[16:19:14.840]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.840]             }
[16:19:14.840]             else {
[16:19:14.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.840]             }
[16:19:14.840]             {
[16:19:14.840]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.840]                   0L) {
[16:19:14.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.840]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.840]                   base::options(opts)
[16:19:14.840]                 }
[16:19:14.840]                 {
[16:19:14.840]                   {
[16:19:14.840]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.840]                     NULL
[16:19:14.840]                   }
[16:19:14.840]                   options(future.plan = NULL)
[16:19:14.840]                   if (is.na(NA_character_)) 
[16:19:14.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.840]                     .init = FALSE)
[16:19:14.840]                 }
[16:19:14.840]             }
[16:19:14.840]         }
[16:19:14.840]     })
[16:19:14.840]     if (TRUE) {
[16:19:14.840]         base::sink(type = "output", split = FALSE)
[16:19:14.840]         if (TRUE) {
[16:19:14.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.840]         }
[16:19:14.840]         else {
[16:19:14.840]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.840]         }
[16:19:14.840]         base::close(...future.stdout)
[16:19:14.840]         ...future.stdout <- NULL
[16:19:14.840]     }
[16:19:14.840]     ...future.result$conditions <- ...future.conditions
[16:19:14.840]     ...future.result$finished <- base::Sys.time()
[16:19:14.840]     ...future.result
[16:19:14.840] }
[16:19:14.842] assign_globals() ...
[16:19:14.842] List of 5
[16:19:14.842]  $ ...future.FUN            :function (x, y)  
[16:19:14.842]  $ future.call.arguments    :List of 1
[16:19:14.842]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:14.842]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.842]  $ ...future.elements_ii    :List of 2
[16:19:14.842]   ..$ A: num 50
[16:19:14.842]   ..$ B: num 60
[16:19:14.842]  $ ...future.seeds_ii       : NULL
[16:19:14.842]  $ ...future.globals.maxSize: NULL
[16:19:14.842]  - attr(*, "where")=List of 5
[16:19:14.842]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.842]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.842]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.842]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.842]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.842]  - attr(*, "resolved")= logi FALSE
[16:19:14.842]  - attr(*, "total_size")= num 4264
[16:19:14.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.842]  - attr(*, "already-done")= logi TRUE
[16:19:14.850] - reassign environment for ‘...future.FUN’
[16:19:14.850] - copied ‘...future.FUN’ to environment
[16:19:14.850] - copied ‘future.call.arguments’ to environment
[16:19:14.850] - copied ‘...future.elements_ii’ to environment
[16:19:14.850] - copied ‘...future.seeds_ii’ to environment
[16:19:14.851] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.851] assign_globals() ... done
[16:19:14.851] requestCore(): workers = 2
[16:19:14.853] MulticoreFuture started
[16:19:14.854] - Launch lazy future ... done
[16:19:14.855] plan(): Setting new future strategy stack:
[16:19:14.854] run() for ‘MulticoreFuture’ ... done
[16:19:14.855] Created future:
[16:19:14.855] List of future strategies:
[16:19:14.855] 1. sequential:
[16:19:14.855]    - args: function (..., envir = parent.frame())
[16:19:14.855]    - tweaked: FALSE
[16:19:14.855]    - call: NULL
[16:19:14.856] plan(): nbrOfWorkers() = 1
[16:19:14.859] plan(): Setting new future strategy stack:
[16:19:14.859] List of future strategies:
[16:19:14.859] 1. multicore:
[16:19:14.859]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.859]    - tweaked: FALSE
[16:19:14.859]    - call: plan(strategy)
[16:19:14.867] plan(): nbrOfWorkers() = 2
[16:19:14.855] MulticoreFuture:
[16:19:14.855] Label: ‘future_sapply-1’
[16:19:14.855] Expression:
[16:19:14.855] {
[16:19:14.855]     do.call(function(...) {
[16:19:14.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.855]             on.exit(options(oopts), add = TRUE)
[16:19:14.855]         }
[16:19:14.855]         {
[16:19:14.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.855]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.855]             })
[16:19:14.855]         }
[16:19:14.855]     }, args = future.call.arguments)
[16:19:14.855] }
[16:19:14.855] Lazy evaluation: FALSE
[16:19:14.855] Asynchronous evaluation: TRUE
[16:19:14.855] Local evaluation: TRUE
[16:19:14.855] Environment: R_GlobalEnv
[16:19:14.855] Capture standard output: TRUE
[16:19:14.855] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.855] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:14.855] Packages: <none>
[16:19:14.855] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.855] Resolved: TRUE
[16:19:14.855] Value: <not collected>
[16:19:14.855] Conditions captured: <none>
[16:19:14.855] Early signaling: FALSE
[16:19:14.855] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.855] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.869] Chunk #1 of 2 ... DONE
[16:19:14.869] Chunk #2 of 2 ...
[16:19:14.869]  - Finding globals in 'X' for chunk #2 ...
[16:19:14.869] getGlobalsAndPackages() ...
[16:19:14.869] Searching for globals...
[16:19:14.870] 
[16:19:14.870] Searching for globals ... DONE
[16:19:14.870] - globals: [0] <none>
[16:19:14.871] getGlobalsAndPackages() ... DONE
[16:19:14.871]    + additional globals found: [n=0] 
[16:19:14.871]    + additional namespaces needed: [n=0] 
[16:19:14.871]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:14.871]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.872]  - seeds: <none>
[16:19:14.872]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.872] getGlobalsAndPackages() ...
[16:19:14.872] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.872] Resolving globals: FALSE
[16:19:14.872] Tweak future expression to call with '...' arguments ...
[16:19:14.873] {
[16:19:14.873]     do.call(function(...) {
[16:19:14.873]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.873]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.873]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.873]             on.exit(options(oopts), add = TRUE)
[16:19:14.873]         }
[16:19:14.873]         {
[16:19:14.873]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.873]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.873]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.873]             })
[16:19:14.873]         }
[16:19:14.873]     }, args = future.call.arguments)
[16:19:14.873] }
[16:19:14.873] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.874] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.874] 
[16:19:14.874] getGlobalsAndPackages() ... DONE
[16:19:14.875] run() for ‘Future’ ...
[16:19:14.875] - state: ‘created’
[16:19:14.875] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.880] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.880] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.880]   - Field: ‘label’
[16:19:14.880]   - Field: ‘local’
[16:19:14.881]   - Field: ‘owner’
[16:19:14.881]   - Field: ‘envir’
[16:19:14.881]   - Field: ‘workers’
[16:19:14.881]   - Field: ‘packages’
[16:19:14.881]   - Field: ‘gc’
[16:19:14.881]   - Field: ‘job’
[16:19:14.881]   - Field: ‘conditions’
[16:19:14.882]   - Field: ‘expr’
[16:19:14.882]   - Field: ‘uuid’
[16:19:14.882]   - Field: ‘seed’
[16:19:14.882]   - Field: ‘version’
[16:19:14.882]   - Field: ‘result’
[16:19:14.882]   - Field: ‘asynchronous’
[16:19:14.882]   - Field: ‘calls’
[16:19:14.882]   - Field: ‘globals’
[16:19:14.883]   - Field: ‘stdout’
[16:19:14.883]   - Field: ‘earlySignal’
[16:19:14.883]   - Field: ‘lazy’
[16:19:14.883]   - Field: ‘state’
[16:19:14.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.883] - Launch lazy future ...
[16:19:14.884] Packages needed by the future expression (n = 0): <none>
[16:19:14.884] Packages needed by future strategies (n = 0): <none>
[16:19:14.884] {
[16:19:14.884]     {
[16:19:14.884]         {
[16:19:14.884]             ...future.startTime <- base::Sys.time()
[16:19:14.884]             {
[16:19:14.884]                 {
[16:19:14.884]                   {
[16:19:14.884]                     {
[16:19:14.884]                       base::local({
[16:19:14.884]                         has_future <- base::requireNamespace("future", 
[16:19:14.884]                           quietly = TRUE)
[16:19:14.884]                         if (has_future) {
[16:19:14.884]                           ns <- base::getNamespace("future")
[16:19:14.884]                           version <- ns[[".package"]][["version"]]
[16:19:14.884]                           if (is.null(version)) 
[16:19:14.884]                             version <- utils::packageVersion("future")
[16:19:14.884]                         }
[16:19:14.884]                         else {
[16:19:14.884]                           version <- NULL
[16:19:14.884]                         }
[16:19:14.884]                         if (!has_future || version < "1.8.0") {
[16:19:14.884]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.884]                             "", base::R.version$version.string), 
[16:19:14.884]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:14.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:14.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.884]                               "release", "version")], collapse = " "), 
[16:19:14.884]                             hostname = base::Sys.info()[["nodename"]])
[16:19:14.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.884]                             info)
[16:19:14.884]                           info <- base::paste(info, collapse = "; ")
[16:19:14.884]                           if (!has_future) {
[16:19:14.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.884]                               info)
[16:19:14.884]                           }
[16:19:14.884]                           else {
[16:19:14.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.884]                               info, version)
[16:19:14.884]                           }
[16:19:14.884]                           base::stop(msg)
[16:19:14.884]                         }
[16:19:14.884]                       })
[16:19:14.884]                     }
[16:19:14.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.884]                     base::options(mc.cores = 1L)
[16:19:14.884]                   }
[16:19:14.884]                   ...future.strategy.old <- future::plan("list")
[16:19:14.884]                   options(future.plan = NULL)
[16:19:14.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.884]                 }
[16:19:14.884]                 ...future.workdir <- getwd()
[16:19:14.884]             }
[16:19:14.884]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.884]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.884]         }
[16:19:14.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.884]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.884]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.884]             base::names(...future.oldOptions))
[16:19:14.884]     }
[16:19:14.884]     if (FALSE) {
[16:19:14.884]     }
[16:19:14.884]     else {
[16:19:14.884]         if (TRUE) {
[16:19:14.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.884]                 open = "w")
[16:19:14.884]         }
[16:19:14.884]         else {
[16:19:14.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.884]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.884]         }
[16:19:14.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.884]             base::sink(type = "output", split = FALSE)
[16:19:14.884]             base::close(...future.stdout)
[16:19:14.884]         }, add = TRUE)
[16:19:14.884]     }
[16:19:14.884]     ...future.frame <- base::sys.nframe()
[16:19:14.884]     ...future.conditions <- base::list()
[16:19:14.884]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.884]     if (FALSE) {
[16:19:14.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.884]     }
[16:19:14.884]     ...future.result <- base::tryCatch({
[16:19:14.884]         base::withCallingHandlers({
[16:19:14.884]             ...future.value <- base::withVisible(base::local({
[16:19:14.884]                 withCallingHandlers({
[16:19:14.884]                   {
[16:19:14.884]                     do.call(function(...) {
[16:19:14.884]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.884]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.884]                         ...future.globals.maxSize)) {
[16:19:14.884]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.884]                         on.exit(options(oopts), add = TRUE)
[16:19:14.884]                       }
[16:19:14.884]                       {
[16:19:14.884]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.884]                           FUN = function(jj) {
[16:19:14.884]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.884]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.884]                           })
[16:19:14.884]                       }
[16:19:14.884]                     }, args = future.call.arguments)
[16:19:14.884]                   }
[16:19:14.884]                 }, immediateCondition = function(cond) {
[16:19:14.884]                   save_rds <- function (object, pathname, ...) 
[16:19:14.884]                   {
[16:19:14.884]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.884]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.884]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.884]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.884]                         fi_tmp[["mtime"]])
[16:19:14.884]                     }
[16:19:14.884]                     tryCatch({
[16:19:14.884]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.884]                     }, error = function(ex) {
[16:19:14.884]                       msg <- conditionMessage(ex)
[16:19:14.884]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.884]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.884]                         fi_tmp[["mtime"]], msg)
[16:19:14.884]                       ex$message <- msg
[16:19:14.884]                       stop(ex)
[16:19:14.884]                     })
[16:19:14.884]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.884]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.884]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.884]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.884]                       fi <- file.info(pathname)
[16:19:14.884]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.884]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.884]                         fi[["size"]], fi[["mtime"]])
[16:19:14.884]                       stop(msg)
[16:19:14.884]                     }
[16:19:14.884]                     invisible(pathname)
[16:19:14.884]                   }
[16:19:14.884]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.884]                     rootPath = tempdir()) 
[16:19:14.884]                   {
[16:19:14.884]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.884]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.884]                       tmpdir = path, fileext = ".rds")
[16:19:14.884]                     save_rds(obj, file)
[16:19:14.884]                   }
[16:19:14.884]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.884]                   {
[16:19:14.884]                     inherits <- base::inherits
[16:19:14.884]                     invokeRestart <- base::invokeRestart
[16:19:14.884]                     is.null <- base::is.null
[16:19:14.884]                     muffled <- FALSE
[16:19:14.884]                     if (inherits(cond, "message")) {
[16:19:14.884]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.884]                       if (muffled) 
[16:19:14.884]                         invokeRestart("muffleMessage")
[16:19:14.884]                     }
[16:19:14.884]                     else if (inherits(cond, "warning")) {
[16:19:14.884]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.884]                       if (muffled) 
[16:19:14.884]                         invokeRestart("muffleWarning")
[16:19:14.884]                     }
[16:19:14.884]                     else if (inherits(cond, "condition")) {
[16:19:14.884]                       if (!is.null(pattern)) {
[16:19:14.884]                         computeRestarts <- base::computeRestarts
[16:19:14.884]                         grepl <- base::grepl
[16:19:14.884]                         restarts <- computeRestarts(cond)
[16:19:14.884]                         for (restart in restarts) {
[16:19:14.884]                           name <- restart$name
[16:19:14.884]                           if (is.null(name)) 
[16:19:14.884]                             next
[16:19:14.884]                           if (!grepl(pattern, name)) 
[16:19:14.884]                             next
[16:19:14.884]                           invokeRestart(restart)
[16:19:14.884]                           muffled <- TRUE
[16:19:14.884]                           break
[16:19:14.884]                         }
[16:19:14.884]                       }
[16:19:14.884]                     }
[16:19:14.884]                     invisible(muffled)
[16:19:14.884]                   }
[16:19:14.884]                   muffleCondition(cond)
[16:19:14.884]                 })
[16:19:14.884]             }))
[16:19:14.884]             future::FutureResult(value = ...future.value$value, 
[16:19:14.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.884]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.884]                     ...future.globalenv.names))
[16:19:14.884]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.884]         }, condition = base::local({
[16:19:14.884]             c <- base::c
[16:19:14.884]             inherits <- base::inherits
[16:19:14.884]             invokeRestart <- base::invokeRestart
[16:19:14.884]             length <- base::length
[16:19:14.884]             list <- base::list
[16:19:14.884]             seq.int <- base::seq.int
[16:19:14.884]             signalCondition <- base::signalCondition
[16:19:14.884]             sys.calls <- base::sys.calls
[16:19:14.884]             `[[` <- base::`[[`
[16:19:14.884]             `+` <- base::`+`
[16:19:14.884]             `<<-` <- base::`<<-`
[16:19:14.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.884]                   3L)]
[16:19:14.884]             }
[16:19:14.884]             function(cond) {
[16:19:14.884]                 is_error <- inherits(cond, "error")
[16:19:14.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.884]                   NULL)
[16:19:14.884]                 if (is_error) {
[16:19:14.884]                   sessionInformation <- function() {
[16:19:14.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.884]                       search = base::search(), system = base::Sys.info())
[16:19:14.884]                   }
[16:19:14.884]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.884]                     cond$call), session = sessionInformation(), 
[16:19:14.884]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.884]                   signalCondition(cond)
[16:19:14.884]                 }
[16:19:14.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.884]                 "immediateCondition"))) {
[16:19:14.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.884]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.884]                   if (TRUE && !signal) {
[16:19:14.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.884]                     {
[16:19:14.884]                       inherits <- base::inherits
[16:19:14.884]                       invokeRestart <- base::invokeRestart
[16:19:14.884]                       is.null <- base::is.null
[16:19:14.884]                       muffled <- FALSE
[16:19:14.884]                       if (inherits(cond, "message")) {
[16:19:14.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.884]                         if (muffled) 
[16:19:14.884]                           invokeRestart("muffleMessage")
[16:19:14.884]                       }
[16:19:14.884]                       else if (inherits(cond, "warning")) {
[16:19:14.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.884]                         if (muffled) 
[16:19:14.884]                           invokeRestart("muffleWarning")
[16:19:14.884]                       }
[16:19:14.884]                       else if (inherits(cond, "condition")) {
[16:19:14.884]                         if (!is.null(pattern)) {
[16:19:14.884]                           computeRestarts <- base::computeRestarts
[16:19:14.884]                           grepl <- base::grepl
[16:19:14.884]                           restarts <- computeRestarts(cond)
[16:19:14.884]                           for (restart in restarts) {
[16:19:14.884]                             name <- restart$name
[16:19:14.884]                             if (is.null(name)) 
[16:19:14.884]                               next
[16:19:14.884]                             if (!grepl(pattern, name)) 
[16:19:14.884]                               next
[16:19:14.884]                             invokeRestart(restart)
[16:19:14.884]                             muffled <- TRUE
[16:19:14.884]                             break
[16:19:14.884]                           }
[16:19:14.884]                         }
[16:19:14.884]                       }
[16:19:14.884]                       invisible(muffled)
[16:19:14.884]                     }
[16:19:14.884]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.884]                   }
[16:19:14.884]                 }
[16:19:14.884]                 else {
[16:19:14.884]                   if (TRUE) {
[16:19:14.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.884]                     {
[16:19:14.884]                       inherits <- base::inherits
[16:19:14.884]                       invokeRestart <- base::invokeRestart
[16:19:14.884]                       is.null <- base::is.null
[16:19:14.884]                       muffled <- FALSE
[16:19:14.884]                       if (inherits(cond, "message")) {
[16:19:14.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.884]                         if (muffled) 
[16:19:14.884]                           invokeRestart("muffleMessage")
[16:19:14.884]                       }
[16:19:14.884]                       else if (inherits(cond, "warning")) {
[16:19:14.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.884]                         if (muffled) 
[16:19:14.884]                           invokeRestart("muffleWarning")
[16:19:14.884]                       }
[16:19:14.884]                       else if (inherits(cond, "condition")) {
[16:19:14.884]                         if (!is.null(pattern)) {
[16:19:14.884]                           computeRestarts <- base::computeRestarts
[16:19:14.884]                           grepl <- base::grepl
[16:19:14.884]                           restarts <- computeRestarts(cond)
[16:19:14.884]                           for (restart in restarts) {
[16:19:14.884]                             name <- restart$name
[16:19:14.884]                             if (is.null(name)) 
[16:19:14.884]                               next
[16:19:14.884]                             if (!grepl(pattern, name)) 
[16:19:14.884]                               next
[16:19:14.884]                             invokeRestart(restart)
[16:19:14.884]                             muffled <- TRUE
[16:19:14.884]                             break
[16:19:14.884]                           }
[16:19:14.884]                         }
[16:19:14.884]                       }
[16:19:14.884]                       invisible(muffled)
[16:19:14.884]                     }
[16:19:14.884]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.884]                   }
[16:19:14.884]                 }
[16:19:14.884]             }
[16:19:14.884]         }))
[16:19:14.884]     }, error = function(ex) {
[16:19:14.884]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.884]                 ...future.rng), started = ...future.startTime, 
[16:19:14.884]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.884]             version = "1.8"), class = "FutureResult")
[16:19:14.884]     }, finally = {
[16:19:14.884]         if (!identical(...future.workdir, getwd())) 
[16:19:14.884]             setwd(...future.workdir)
[16:19:14.884]         {
[16:19:14.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.884]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.884]             }
[16:19:14.884]             base::options(...future.oldOptions)
[16:19:14.884]             if (.Platform$OS.type == "windows") {
[16:19:14.884]                 old_names <- names(...future.oldEnvVars)
[16:19:14.884]                 envs <- base::Sys.getenv()
[16:19:14.884]                 names <- names(envs)
[16:19:14.884]                 common <- intersect(names, old_names)
[16:19:14.884]                 added <- setdiff(names, old_names)
[16:19:14.884]                 removed <- setdiff(old_names, names)
[16:19:14.884]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.884]                   envs[common]]
[16:19:14.884]                 NAMES <- toupper(changed)
[16:19:14.884]                 args <- list()
[16:19:14.884]                 for (kk in seq_along(NAMES)) {
[16:19:14.884]                   name <- changed[[kk]]
[16:19:14.884]                   NAME <- NAMES[[kk]]
[16:19:14.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.884]                     next
[16:19:14.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.884]                 }
[16:19:14.884]                 NAMES <- toupper(added)
[16:19:14.884]                 for (kk in seq_along(NAMES)) {
[16:19:14.884]                   name <- added[[kk]]
[16:19:14.884]                   NAME <- NAMES[[kk]]
[16:19:14.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.884]                     next
[16:19:14.884]                   args[[name]] <- ""
[16:19:14.884]                 }
[16:19:14.884]                 NAMES <- toupper(removed)
[16:19:14.884]                 for (kk in seq_along(NAMES)) {
[16:19:14.884]                   name <- removed[[kk]]
[16:19:14.884]                   NAME <- NAMES[[kk]]
[16:19:14.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.884]                     next
[16:19:14.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.884]                 }
[16:19:14.884]                 if (length(args) > 0) 
[16:19:14.884]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.884]             }
[16:19:14.884]             else {
[16:19:14.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.884]             }
[16:19:14.884]             {
[16:19:14.884]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.884]                   0L) {
[16:19:14.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.884]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.884]                   base::options(opts)
[16:19:14.884]                 }
[16:19:14.884]                 {
[16:19:14.884]                   {
[16:19:14.884]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.884]                     NULL
[16:19:14.884]                   }
[16:19:14.884]                   options(future.plan = NULL)
[16:19:14.884]                   if (is.na(NA_character_)) 
[16:19:14.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.884]                     .init = FALSE)
[16:19:14.884]                 }
[16:19:14.884]             }
[16:19:14.884]         }
[16:19:14.884]     })
[16:19:14.884]     if (TRUE) {
[16:19:14.884]         base::sink(type = "output", split = FALSE)
[16:19:14.884]         if (TRUE) {
[16:19:14.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.884]         }
[16:19:14.884]         else {
[16:19:14.884]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.884]         }
[16:19:14.884]         base::close(...future.stdout)
[16:19:14.884]         ...future.stdout <- NULL
[16:19:14.884]     }
[16:19:14.884]     ...future.result$conditions <- ...future.conditions
[16:19:14.884]     ...future.result$finished <- base::Sys.time()
[16:19:14.884]     ...future.result
[16:19:14.884] }
[16:19:14.888] assign_globals() ...
[16:19:14.888] List of 5
[16:19:14.888]  $ ...future.FUN            :function (x, y)  
[16:19:14.888]  $ future.call.arguments    :List of 1
[16:19:14.888]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:14.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.888]  $ ...future.elements_ii    :List of 2
[16:19:14.888]   ..$ C: num 70
[16:19:14.888]   ..$ D: num 80
[16:19:14.888]  $ ...future.seeds_ii       : NULL
[16:19:14.888]  $ ...future.globals.maxSize: NULL
[16:19:14.888]  - attr(*, "where")=List of 5
[16:19:14.888]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.888]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.888]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.888]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.888]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.888]  - attr(*, "resolved")= logi FALSE
[16:19:14.888]  - attr(*, "total_size")= num 4264
[16:19:14.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.888]  - attr(*, "already-done")= logi TRUE
[16:19:14.898] - reassign environment for ‘...future.FUN’
[16:19:14.898] - copied ‘...future.FUN’ to environment
[16:19:14.898] - copied ‘future.call.arguments’ to environment
[16:19:14.898] - copied ‘...future.elements_ii’ to environment
[16:19:14.899] - copied ‘...future.seeds_ii’ to environment
[16:19:14.899] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.899] assign_globals() ... done
[16:19:14.899] requestCore(): workers = 2
[16:19:14.902] MulticoreFuture started
[16:19:14.902] - Launch lazy future ... done
[16:19:14.903] plan(): Setting new future strategy stack:
[16:19:14.903] run() for ‘MulticoreFuture’ ... done
[16:19:14.904] Created future:
[16:19:14.903] List of future strategies:
[16:19:14.903] 1. sequential:
[16:19:14.903]    - args: function (..., envir = parent.frame())
[16:19:14.903]    - tweaked: FALSE
[16:19:14.903]    - call: NULL
[16:19:14.905] plan(): nbrOfWorkers() = 1
[16:19:14.908] plan(): Setting new future strategy stack:
[16:19:14.908] List of future strategies:
[16:19:14.908] 1. multicore:
[16:19:14.908]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:14.908]    - tweaked: FALSE
[16:19:14.908]    - call: plan(strategy)
[16:19:14.915] plan(): nbrOfWorkers() = 2
[16:19:14.904] MulticoreFuture:
[16:19:14.904] Label: ‘future_sapply-2’
[16:19:14.904] Expression:
[16:19:14.904] {
[16:19:14.904]     do.call(function(...) {
[16:19:14.904]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.904]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.904]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.904]             on.exit(options(oopts), add = TRUE)
[16:19:14.904]         }
[16:19:14.904]         {
[16:19:14.904]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.904]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.904]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.904]             })
[16:19:14.904]         }
[16:19:14.904]     }, args = future.call.arguments)
[16:19:14.904] }
[16:19:14.904] Lazy evaluation: FALSE
[16:19:14.904] Asynchronous evaluation: TRUE
[16:19:14.904] Local evaluation: TRUE
[16:19:14.904] Environment: R_GlobalEnv
[16:19:14.904] Capture standard output: TRUE
[16:19:14.904] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.904] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:14.904] Packages: <none>
[16:19:14.904] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.904] Resolved: TRUE
[16:19:14.904] Value: <not collected>
[16:19:14.904] Conditions captured: <none>
[16:19:14.904] Early signaling: FALSE
[16:19:14.904] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.904] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.917] Chunk #2 of 2 ... DONE
[16:19:14.917] Launching 2 futures (chunks) ... DONE
[16:19:14.917] Resolving 2 futures (chunks) ...
[16:19:14.918] resolve() on list ...
[16:19:14.918]  recursive: 0
[16:19:14.918]  length: 2
[16:19:14.918] 
[16:19:14.919] Future #1
[16:19:14.919] result() for MulticoreFuture ...
[16:19:14.920] result() for MulticoreFuture ...
[16:19:14.920] result() for MulticoreFuture ... done
[16:19:14.920] result() for MulticoreFuture ... done
[16:19:14.921] result() for MulticoreFuture ...
[16:19:14.921] result() for MulticoreFuture ... done
[16:19:14.921] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:14.921] - nx: 2
[16:19:14.922] - relay: TRUE
[16:19:14.922] - stdout: TRUE
[16:19:14.922] - signal: TRUE
[16:19:14.922] - resignal: FALSE
[16:19:14.922] - force: TRUE
[16:19:14.923] - relayed: [n=2] FALSE, FALSE
[16:19:14.923] - queued futures: [n=2] FALSE, FALSE
[16:19:14.923]  - until=1
[16:19:14.923]  - relaying element #1
[16:19:14.923] result() for MulticoreFuture ...
[16:19:14.924] result() for MulticoreFuture ... done
[16:19:14.924] result() for MulticoreFuture ...
[16:19:14.924] result() for MulticoreFuture ... done
[16:19:14.924] result() for MulticoreFuture ...
[16:19:14.925] result() for MulticoreFuture ... done
[16:19:14.925] result() for MulticoreFuture ...
[16:19:14.925] result() for MulticoreFuture ... done
[16:19:14.925] - relayed: [n=2] TRUE, FALSE
[16:19:14.925] - queued futures: [n=2] TRUE, FALSE
[16:19:14.925] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:14.925]  length: 1 (resolved future 1)
[16:19:14.926] Future #2
[16:19:14.926] result() for MulticoreFuture ...
[16:19:14.927] result() for MulticoreFuture ...
[16:19:14.927] result() for MulticoreFuture ... done
[16:19:14.927] result() for MulticoreFuture ... done
[16:19:14.927] result() for MulticoreFuture ...
[16:19:14.928] result() for MulticoreFuture ... done
[16:19:14.928] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:14.928] - nx: 2
[16:19:14.928] - relay: TRUE
[16:19:14.928] - stdout: TRUE
[16:19:14.928] - signal: TRUE
[16:19:14.928] - resignal: FALSE
[16:19:14.929] - force: TRUE
[16:19:14.929] - relayed: [n=2] TRUE, FALSE
[16:19:14.929] - queued futures: [n=2] TRUE, FALSE
[16:19:14.929]  - until=2
[16:19:14.929]  - relaying element #2
[16:19:14.929] result() for MulticoreFuture ...
[16:19:14.929] result() for MulticoreFuture ... done
[16:19:14.929] result() for MulticoreFuture ...
[16:19:14.929] result() for MulticoreFuture ... done
[16:19:14.930] result() for MulticoreFuture ...
[16:19:14.930] result() for MulticoreFuture ... done
[16:19:14.930] result() for MulticoreFuture ...
[16:19:14.930] result() for MulticoreFuture ... done
[16:19:14.930] - relayed: [n=2] TRUE, TRUE
[16:19:14.930] - queued futures: [n=2] TRUE, TRUE
[16:19:14.930] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:14.930]  length: 0 (resolved future 2)
[16:19:14.931] Relaying remaining futures
[16:19:14.931] signalConditionsASAP(NULL, pos=0) ...
[16:19:14.931] - nx: 2
[16:19:14.931] - relay: TRUE
[16:19:14.931] - stdout: TRUE
[16:19:14.931] - signal: TRUE
[16:19:14.931] - resignal: FALSE
[16:19:14.931] - force: TRUE
[16:19:14.931] - relayed: [n=2] TRUE, TRUE
[16:19:14.931] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:14.932] - relayed: [n=2] TRUE, TRUE
[16:19:14.932] - queued futures: [n=2] TRUE, TRUE
[16:19:14.932] signalConditionsASAP(NULL, pos=0) ... done
[16:19:14.932] resolve() on list ... DONE
[16:19:14.932] result() for MulticoreFuture ...
[16:19:14.932] result() for MulticoreFuture ... done
[16:19:14.932] result() for MulticoreFuture ...
[16:19:14.932] result() for MulticoreFuture ... done
[16:19:14.932] result() for MulticoreFuture ...
[16:19:14.933] result() for MulticoreFuture ... done
[16:19:14.933] result() for MulticoreFuture ...
[16:19:14.933] result() for MulticoreFuture ... done
[16:19:14.933]  - Number of value chunks collected: 2
[16:19:14.933] Resolving 2 futures (chunks) ... DONE
[16:19:14.933] Reducing values from 2 chunks ...
[16:19:14.933]  - Number of values collected after concatenation: 4
[16:19:14.933]  - Number of values expected: 4
[16:19:14.933] Reducing values from 2 chunks ... DONE
[16:19:14.934] future_lapply() ... DONE
[16:19:14.934] future_lapply() ...
[16:19:14.940] Number of chunks: 2
[16:19:14.941] getGlobalsAndPackagesXApply() ...
[16:19:14.941]  - future.globals: TRUE
[16:19:14.941] getGlobalsAndPackages() ...
[16:19:14.941] Searching for globals...
[16:19:14.948] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:19:14.948] Searching for globals ... DONE
[16:19:14.948] Resolving globals: FALSE
[16:19:14.949] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:19:14.950] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:14.950] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.950] - packages: [1] ‘future.apply’
[16:19:14.950] getGlobalsAndPackages() ... DONE
[16:19:14.950]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:14.950]  - needed namespaces: [n=1] ‘future.apply’
[16:19:14.951] Finding globals ... DONE
[16:19:14.951]  - use_args: TRUE
[16:19:14.951]  - Getting '...' globals ...
[16:19:14.951] resolve() on list ...
[16:19:14.951]  recursive: 0
[16:19:14.951]  length: 1
[16:19:14.951]  elements: ‘...’
[16:19:14.952]  length: 0 (resolved future 1)
[16:19:14.952] resolve() on list ... DONE
[16:19:14.952]    - '...' content: [n=1] ‘y’
[16:19:14.952] List of 1
[16:19:14.952]  $ ...:List of 1
[16:19:14.952]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:14.952]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.952]  - attr(*, "where")=List of 1
[16:19:14.952]   ..$ ...:<environment: 0x56199ee422d8> 
[16:19:14.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.952]  - attr(*, "resolved")= logi TRUE
[16:19:14.952]  - attr(*, "total_size")= num NA
[16:19:14.955]  - Getting '...' globals ... DONE
[16:19:14.955] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:14.955] List of 8
[16:19:14.955]  $ ...future.FUN:function (x, ...)  
[16:19:14.955]  $ x_FUN        :function (x, y)  
[16:19:14.955]  $ times        : int 15
[16:19:14.955]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.955]  $ stop_if_not  :function (...)  
[16:19:14.955]  $ dim          : int [1:2] 3 5
[16:19:14.955]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:14.955]  $ ...          :List of 1
[16:19:14.955]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:14.955]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.955]  - attr(*, "where")=List of 8
[16:19:14.955]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:14.955]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:14.955]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:14.955]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:14.955]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:14.955]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:14.955]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:14.955]   ..$ ...          :<environment: 0x56199ee422d8> 
[16:19:14.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.955]  - attr(*, "resolved")= logi FALSE
[16:19:14.955]  - attr(*, "total_size")= num 98600
[16:19:14.961] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:14.961] getGlobalsAndPackagesXApply() ... DONE
[16:19:14.962] Number of futures (= number of chunks): 2
[16:19:14.962] Launching 2 futures (chunks) ...
[16:19:14.962] Chunk #1 of 2 ...
[16:19:14.962]  - Finding globals in 'X' for chunk #1 ...
[16:19:14.962] getGlobalsAndPackages() ...
[16:19:14.962] Searching for globals...
[16:19:14.963] 
[16:19:14.965] Searching for globals ... DONE
[16:19:14.965] - globals: [0] <none>
[16:19:14.965] getGlobalsAndPackages() ... DONE
[16:19:14.965]    + additional globals found: [n=0] 
[16:19:14.965]    + additional namespaces needed: [n=0] 
[16:19:14.965]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:14.965]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:14.965]  - seeds: <none>
[16:19:14.965]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.966] getGlobalsAndPackages() ...
[16:19:14.966] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.966] Resolving globals: FALSE
[16:19:14.966] Tweak future expression to call with '...' arguments ...
[16:19:14.966] {
[16:19:14.966]     do.call(function(...) {
[16:19:14.966]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.966]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.966]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.966]             on.exit(options(oopts), add = TRUE)
[16:19:14.966]         }
[16:19:14.966]         {
[16:19:14.966]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.966]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.966]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.966]             })
[16:19:14.966]         }
[16:19:14.966]     }, args = future.call.arguments)
[16:19:14.966] }
[16:19:14.966] Tweak future expression to call with '...' arguments ... DONE
[16:19:14.967] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:14.967] - packages: [1] ‘future.apply’
[16:19:14.967] getGlobalsAndPackages() ... DONE
[16:19:14.967] run() for ‘Future’ ...
[16:19:14.968] - state: ‘created’
[16:19:14.968] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:14.972] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:14.972] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:14.972]   - Field: ‘label’
[16:19:14.972]   - Field: ‘local’
[16:19:14.972]   - Field: ‘owner’
[16:19:14.972]   - Field: ‘envir’
[16:19:14.972]   - Field: ‘workers’
[16:19:14.973]   - Field: ‘packages’
[16:19:14.973]   - Field: ‘gc’
[16:19:14.973]   - Field: ‘job’
[16:19:14.973]   - Field: ‘conditions’
[16:19:14.973]   - Field: ‘expr’
[16:19:14.973]   - Field: ‘uuid’
[16:19:14.973]   - Field: ‘seed’
[16:19:14.973]   - Field: ‘version’
[16:19:14.973]   - Field: ‘result’
[16:19:14.973]   - Field: ‘asynchronous’
[16:19:14.974]   - Field: ‘calls’
[16:19:14.974]   - Field: ‘globals’
[16:19:14.974]   - Field: ‘stdout’
[16:19:14.974]   - Field: ‘earlySignal’
[16:19:14.974]   - Field: ‘lazy’
[16:19:14.974]   - Field: ‘state’
[16:19:14.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:14.974] - Launch lazy future ...
[16:19:14.975] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:14.975] Packages needed by future strategies (n = 0): <none>
[16:19:14.975] {
[16:19:14.975]     {
[16:19:14.975]         {
[16:19:14.975]             ...future.startTime <- base::Sys.time()
[16:19:14.975]             {
[16:19:14.975]                 {
[16:19:14.975]                   {
[16:19:14.975]                     {
[16:19:14.975]                       {
[16:19:14.975]                         base::local({
[16:19:14.975]                           has_future <- base::requireNamespace("future", 
[16:19:14.975]                             quietly = TRUE)
[16:19:14.975]                           if (has_future) {
[16:19:14.975]                             ns <- base::getNamespace("future")
[16:19:14.975]                             version <- ns[[".package"]][["version"]]
[16:19:14.975]                             if (is.null(version)) 
[16:19:14.975]                               version <- utils::packageVersion("future")
[16:19:14.975]                           }
[16:19:14.975]                           else {
[16:19:14.975]                             version <- NULL
[16:19:14.975]                           }
[16:19:14.975]                           if (!has_future || version < "1.8.0") {
[16:19:14.975]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:14.975]                               "", base::R.version$version.string), 
[16:19:14.975]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:14.975]                                 base::R.version$platform, 8 * 
[16:19:14.975]                                   base::.Machine$sizeof.pointer), 
[16:19:14.975]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:14.975]                                 "release", "version")], collapse = " "), 
[16:19:14.975]                               hostname = base::Sys.info()[["nodename"]])
[16:19:14.975]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:14.975]                               info)
[16:19:14.975]                             info <- base::paste(info, collapse = "; ")
[16:19:14.975]                             if (!has_future) {
[16:19:14.975]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:14.975]                                 info)
[16:19:14.975]                             }
[16:19:14.975]                             else {
[16:19:14.975]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:14.975]                                 info, version)
[16:19:14.975]                             }
[16:19:14.975]                             base::stop(msg)
[16:19:14.975]                           }
[16:19:14.975]                         })
[16:19:14.975]                       }
[16:19:14.975]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:14.975]                       base::options(mc.cores = 1L)
[16:19:14.975]                     }
[16:19:14.975]                     base::local({
[16:19:14.975]                       for (pkg in "future.apply") {
[16:19:14.975]                         base::loadNamespace(pkg)
[16:19:14.975]                         base::library(pkg, character.only = TRUE)
[16:19:14.975]                       }
[16:19:14.975]                     })
[16:19:14.975]                   }
[16:19:14.975]                   ...future.strategy.old <- future::plan("list")
[16:19:14.975]                   options(future.plan = NULL)
[16:19:14.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:14.975]                 }
[16:19:14.975]                 ...future.workdir <- getwd()
[16:19:14.975]             }
[16:19:14.975]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:14.975]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:14.975]         }
[16:19:14.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:14.975]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:14.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:14.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:14.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:14.975]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:14.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:14.975]             base::names(...future.oldOptions))
[16:19:14.975]     }
[16:19:14.975]     if (FALSE) {
[16:19:14.975]     }
[16:19:14.975]     else {
[16:19:14.975]         if (TRUE) {
[16:19:14.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:14.975]                 open = "w")
[16:19:14.975]         }
[16:19:14.975]         else {
[16:19:14.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:14.975]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:14.975]         }
[16:19:14.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:14.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:14.975]             base::sink(type = "output", split = FALSE)
[16:19:14.975]             base::close(...future.stdout)
[16:19:14.975]         }, add = TRUE)
[16:19:14.975]     }
[16:19:14.975]     ...future.frame <- base::sys.nframe()
[16:19:14.975]     ...future.conditions <- base::list()
[16:19:14.975]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:14.975]     if (FALSE) {
[16:19:14.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:14.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:14.975]     }
[16:19:14.975]     ...future.result <- base::tryCatch({
[16:19:14.975]         base::withCallingHandlers({
[16:19:14.975]             ...future.value <- base::withVisible(base::local({
[16:19:14.975]                 withCallingHandlers({
[16:19:14.975]                   {
[16:19:14.975]                     do.call(function(...) {
[16:19:14.975]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.975]                       if (!identical(...future.globals.maxSize.org, 
[16:19:14.975]                         ...future.globals.maxSize)) {
[16:19:14.975]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.975]                         on.exit(options(oopts), add = TRUE)
[16:19:14.975]                       }
[16:19:14.975]                       {
[16:19:14.975]                         lapply(seq_along(...future.elements_ii), 
[16:19:14.975]                           FUN = function(jj) {
[16:19:14.975]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.975]                             ...future.FUN(...future.X_jj, ...)
[16:19:14.975]                           })
[16:19:14.975]                       }
[16:19:14.975]                     }, args = future.call.arguments)
[16:19:14.975]                   }
[16:19:14.975]                 }, immediateCondition = function(cond) {
[16:19:14.975]                   save_rds <- function (object, pathname, ...) 
[16:19:14.975]                   {
[16:19:14.975]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:14.975]                     if (file_test("-f", pathname_tmp)) {
[16:19:14.975]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.975]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:14.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.975]                         fi_tmp[["mtime"]])
[16:19:14.975]                     }
[16:19:14.975]                     tryCatch({
[16:19:14.975]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:14.975]                     }, error = function(ex) {
[16:19:14.975]                       msg <- conditionMessage(ex)
[16:19:14.975]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.975]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:14.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.975]                         fi_tmp[["mtime"]], msg)
[16:19:14.975]                       ex$message <- msg
[16:19:14.975]                       stop(ex)
[16:19:14.975]                     })
[16:19:14.975]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:14.975]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:14.975]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:14.975]                       fi_tmp <- file.info(pathname_tmp)
[16:19:14.975]                       fi <- file.info(pathname)
[16:19:14.975]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:14.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:14.975]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:14.975]                         fi[["size"]], fi[["mtime"]])
[16:19:14.975]                       stop(msg)
[16:19:14.975]                     }
[16:19:14.975]                     invisible(pathname)
[16:19:14.975]                   }
[16:19:14.975]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:14.975]                     rootPath = tempdir()) 
[16:19:14.975]                   {
[16:19:14.975]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:14.975]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:14.975]                       tmpdir = path, fileext = ".rds")
[16:19:14.975]                     save_rds(obj, file)
[16:19:14.975]                   }
[16:19:14.975]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:14.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.975]                   {
[16:19:14.975]                     inherits <- base::inherits
[16:19:14.975]                     invokeRestart <- base::invokeRestart
[16:19:14.975]                     is.null <- base::is.null
[16:19:14.975]                     muffled <- FALSE
[16:19:14.975]                     if (inherits(cond, "message")) {
[16:19:14.975]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:14.975]                       if (muffled) 
[16:19:14.975]                         invokeRestart("muffleMessage")
[16:19:14.975]                     }
[16:19:14.975]                     else if (inherits(cond, "warning")) {
[16:19:14.975]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:14.975]                       if (muffled) 
[16:19:14.975]                         invokeRestart("muffleWarning")
[16:19:14.975]                     }
[16:19:14.975]                     else if (inherits(cond, "condition")) {
[16:19:14.975]                       if (!is.null(pattern)) {
[16:19:14.975]                         computeRestarts <- base::computeRestarts
[16:19:14.975]                         grepl <- base::grepl
[16:19:14.975]                         restarts <- computeRestarts(cond)
[16:19:14.975]                         for (restart in restarts) {
[16:19:14.975]                           name <- restart$name
[16:19:14.975]                           if (is.null(name)) 
[16:19:14.975]                             next
[16:19:14.975]                           if (!grepl(pattern, name)) 
[16:19:14.975]                             next
[16:19:14.975]                           invokeRestart(restart)
[16:19:14.975]                           muffled <- TRUE
[16:19:14.975]                           break
[16:19:14.975]                         }
[16:19:14.975]                       }
[16:19:14.975]                     }
[16:19:14.975]                     invisible(muffled)
[16:19:14.975]                   }
[16:19:14.975]                   muffleCondition(cond)
[16:19:14.975]                 })
[16:19:14.975]             }))
[16:19:14.975]             future::FutureResult(value = ...future.value$value, 
[16:19:14.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.975]                   ...future.rng), globalenv = if (FALSE) 
[16:19:14.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:14.975]                     ...future.globalenv.names))
[16:19:14.975]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:14.975]         }, condition = base::local({
[16:19:14.975]             c <- base::c
[16:19:14.975]             inherits <- base::inherits
[16:19:14.975]             invokeRestart <- base::invokeRestart
[16:19:14.975]             length <- base::length
[16:19:14.975]             list <- base::list
[16:19:14.975]             seq.int <- base::seq.int
[16:19:14.975]             signalCondition <- base::signalCondition
[16:19:14.975]             sys.calls <- base::sys.calls
[16:19:14.975]             `[[` <- base::`[[`
[16:19:14.975]             `+` <- base::`+`
[16:19:14.975]             `<<-` <- base::`<<-`
[16:19:14.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:14.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:14.975]                   3L)]
[16:19:14.975]             }
[16:19:14.975]             function(cond) {
[16:19:14.975]                 is_error <- inherits(cond, "error")
[16:19:14.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:14.975]                   NULL)
[16:19:14.975]                 if (is_error) {
[16:19:14.975]                   sessionInformation <- function() {
[16:19:14.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:14.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:14.975]                       search = base::search(), system = base::Sys.info())
[16:19:14.975]                   }
[16:19:14.975]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:14.975]                     cond$call), session = sessionInformation(), 
[16:19:14.975]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:14.975]                   signalCondition(cond)
[16:19:14.975]                 }
[16:19:14.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:14.975]                 "immediateCondition"))) {
[16:19:14.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:14.975]                   ...future.conditions[[length(...future.conditions) + 
[16:19:14.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:14.975]                   if (TRUE && !signal) {
[16:19:14.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.975]                     {
[16:19:14.975]                       inherits <- base::inherits
[16:19:14.975]                       invokeRestart <- base::invokeRestart
[16:19:14.975]                       is.null <- base::is.null
[16:19:14.975]                       muffled <- FALSE
[16:19:14.975]                       if (inherits(cond, "message")) {
[16:19:14.975]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.975]                         if (muffled) 
[16:19:14.975]                           invokeRestart("muffleMessage")
[16:19:14.975]                       }
[16:19:14.975]                       else if (inherits(cond, "warning")) {
[16:19:14.975]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.975]                         if (muffled) 
[16:19:14.975]                           invokeRestart("muffleWarning")
[16:19:14.975]                       }
[16:19:14.975]                       else if (inherits(cond, "condition")) {
[16:19:14.975]                         if (!is.null(pattern)) {
[16:19:14.975]                           computeRestarts <- base::computeRestarts
[16:19:14.975]                           grepl <- base::grepl
[16:19:14.975]                           restarts <- computeRestarts(cond)
[16:19:14.975]                           for (restart in restarts) {
[16:19:14.975]                             name <- restart$name
[16:19:14.975]                             if (is.null(name)) 
[16:19:14.975]                               next
[16:19:14.975]                             if (!grepl(pattern, name)) 
[16:19:14.975]                               next
[16:19:14.975]                             invokeRestart(restart)
[16:19:14.975]                             muffled <- TRUE
[16:19:14.975]                             break
[16:19:14.975]                           }
[16:19:14.975]                         }
[16:19:14.975]                       }
[16:19:14.975]                       invisible(muffled)
[16:19:14.975]                     }
[16:19:14.975]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.975]                   }
[16:19:14.975]                 }
[16:19:14.975]                 else {
[16:19:14.975]                   if (TRUE) {
[16:19:14.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:14.975]                     {
[16:19:14.975]                       inherits <- base::inherits
[16:19:14.975]                       invokeRestart <- base::invokeRestart
[16:19:14.975]                       is.null <- base::is.null
[16:19:14.975]                       muffled <- FALSE
[16:19:14.975]                       if (inherits(cond, "message")) {
[16:19:14.975]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:14.975]                         if (muffled) 
[16:19:14.975]                           invokeRestart("muffleMessage")
[16:19:14.975]                       }
[16:19:14.975]                       else if (inherits(cond, "warning")) {
[16:19:14.975]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:14.975]                         if (muffled) 
[16:19:14.975]                           invokeRestart("muffleWarning")
[16:19:14.975]                       }
[16:19:14.975]                       else if (inherits(cond, "condition")) {
[16:19:14.975]                         if (!is.null(pattern)) {
[16:19:14.975]                           computeRestarts <- base::computeRestarts
[16:19:14.975]                           grepl <- base::grepl
[16:19:14.975]                           restarts <- computeRestarts(cond)
[16:19:14.975]                           for (restart in restarts) {
[16:19:14.975]                             name <- restart$name
[16:19:14.975]                             if (is.null(name)) 
[16:19:14.975]                               next
[16:19:14.975]                             if (!grepl(pattern, name)) 
[16:19:14.975]                               next
[16:19:14.975]                             invokeRestart(restart)
[16:19:14.975]                             muffled <- TRUE
[16:19:14.975]                             break
[16:19:14.975]                           }
[16:19:14.975]                         }
[16:19:14.975]                       }
[16:19:14.975]                       invisible(muffled)
[16:19:14.975]                     }
[16:19:14.975]                     muffleCondition(cond, pattern = "^muffle")
[16:19:14.975]                   }
[16:19:14.975]                 }
[16:19:14.975]             }
[16:19:14.975]         }))
[16:19:14.975]     }, error = function(ex) {
[16:19:14.975]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:14.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:14.975]                 ...future.rng), started = ...future.startTime, 
[16:19:14.975]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:14.975]             version = "1.8"), class = "FutureResult")
[16:19:14.975]     }, finally = {
[16:19:14.975]         if (!identical(...future.workdir, getwd())) 
[16:19:14.975]             setwd(...future.workdir)
[16:19:14.975]         {
[16:19:14.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:14.975]                 ...future.oldOptions$nwarnings <- NULL
[16:19:14.975]             }
[16:19:14.975]             base::options(...future.oldOptions)
[16:19:14.975]             if (.Platform$OS.type == "windows") {
[16:19:14.975]                 old_names <- names(...future.oldEnvVars)
[16:19:14.975]                 envs <- base::Sys.getenv()
[16:19:14.975]                 names <- names(envs)
[16:19:14.975]                 common <- intersect(names, old_names)
[16:19:14.975]                 added <- setdiff(names, old_names)
[16:19:14.975]                 removed <- setdiff(old_names, names)
[16:19:14.975]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:14.975]                   envs[common]]
[16:19:14.975]                 NAMES <- toupper(changed)
[16:19:14.975]                 args <- list()
[16:19:14.975]                 for (kk in seq_along(NAMES)) {
[16:19:14.975]                   name <- changed[[kk]]
[16:19:14.975]                   NAME <- NAMES[[kk]]
[16:19:14.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.975]                     next
[16:19:14.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.975]                 }
[16:19:14.975]                 NAMES <- toupper(added)
[16:19:14.975]                 for (kk in seq_along(NAMES)) {
[16:19:14.975]                   name <- added[[kk]]
[16:19:14.975]                   NAME <- NAMES[[kk]]
[16:19:14.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.975]                     next
[16:19:14.975]                   args[[name]] <- ""
[16:19:14.975]                 }
[16:19:14.975]                 NAMES <- toupper(removed)
[16:19:14.975]                 for (kk in seq_along(NAMES)) {
[16:19:14.975]                   name <- removed[[kk]]
[16:19:14.975]                   NAME <- NAMES[[kk]]
[16:19:14.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:14.975]                     next
[16:19:14.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:14.975]                 }
[16:19:14.975]                 if (length(args) > 0) 
[16:19:14.975]                   base::do.call(base::Sys.setenv, args = args)
[16:19:14.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:14.975]             }
[16:19:14.975]             else {
[16:19:14.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:14.975]             }
[16:19:14.975]             {
[16:19:14.975]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:14.975]                   0L) {
[16:19:14.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:14.975]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:14.975]                   base::options(opts)
[16:19:14.975]                 }
[16:19:14.975]                 {
[16:19:14.975]                   {
[16:19:14.975]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:14.975]                     NULL
[16:19:14.975]                   }
[16:19:14.975]                   options(future.plan = NULL)
[16:19:14.975]                   if (is.na(NA_character_)) 
[16:19:14.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:14.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:14.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:14.975]                     .init = FALSE)
[16:19:14.975]                 }
[16:19:14.975]             }
[16:19:14.975]         }
[16:19:14.975]     })
[16:19:14.975]     if (TRUE) {
[16:19:14.975]         base::sink(type = "output", split = FALSE)
[16:19:14.975]         if (TRUE) {
[16:19:14.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:14.975]         }
[16:19:14.975]         else {
[16:19:14.975]             ...future.result["stdout"] <- base::list(NULL)
[16:19:14.975]         }
[16:19:14.975]         base::close(...future.stdout)
[16:19:14.975]         ...future.stdout <- NULL
[16:19:14.975]     }
[16:19:14.975]     ...future.result$conditions <- ...future.conditions
[16:19:14.975]     ...future.result$finished <- base::Sys.time()
[16:19:14.975]     ...future.result
[16:19:14.975] }
[16:19:14.978] assign_globals() ...
[16:19:14.978] List of 11
[16:19:14.978]  $ ...future.FUN            :function (x, ...)  
[16:19:14.978]  $ x_FUN                    :function (x, y)  
[16:19:14.978]  $ times                    : int 15
[16:19:14.978]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:14.978]  $ stop_if_not              :function (...)  
[16:19:14.978]  $ dim                      : int [1:2] 3 5
[16:19:14.978]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:14.978]  $ future.call.arguments    :List of 1
[16:19:14.978]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:14.978]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:14.978]  $ ...future.elements_ii    :List of 2
[16:19:14.978]   ..$ A: num 50
[16:19:14.978]   ..$ B: num 60
[16:19:14.978]  $ ...future.seeds_ii       : NULL
[16:19:14.978]  $ ...future.globals.maxSize: NULL
[16:19:14.978]  - attr(*, "where")=List of 11
[16:19:14.978]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:14.978]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:14.978]  - attr(*, "resolved")= logi FALSE
[16:19:14.978]  - attr(*, "total_size")= num 98600
[16:19:14.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:14.978]  - attr(*, "already-done")= logi TRUE
[16:19:14.986] - copied ‘...future.FUN’ to environment
[16:19:14.986] - reassign environment for ‘x_FUN’
[16:19:14.987] - copied ‘x_FUN’ to environment
[16:19:14.987] - copied ‘times’ to environment
[16:19:14.987] - copied ‘stopf’ to environment
[16:19:14.987] - copied ‘stop_if_not’ to environment
[16:19:14.987] - copied ‘dim’ to environment
[16:19:14.987] - copied ‘valid_types’ to environment
[16:19:14.989] - copied ‘future.call.arguments’ to environment
[16:19:14.989] - copied ‘...future.elements_ii’ to environment
[16:19:14.989] - copied ‘...future.seeds_ii’ to environment
[16:19:14.990] - copied ‘...future.globals.maxSize’ to environment
[16:19:14.990] assign_globals() ... done
[16:19:14.990] requestCore(): workers = 2
[16:19:14.992] MulticoreFuture started
[16:19:14.993] - Launch lazy future ... done
[16:19:14.994] run() for ‘MulticoreFuture’ ... done
[16:19:14.994] Created future:
[16:19:14.995] plan(): Setting new future strategy stack:
[16:19:14.995] List of future strategies:
[16:19:14.995] 1. sequential:
[16:19:14.995]    - args: function (..., envir = parent.frame())
[16:19:14.995]    - tweaked: FALSE
[16:19:14.995]    - call: NULL
[16:19:14.996] plan(): nbrOfWorkers() = 1
[16:19:14.999] plan(): Setting new future strategy stack:
[16:19:15.000] List of future strategies:
[16:19:15.000] 1. multicore:
[16:19:15.000]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:15.000]    - tweaked: FALSE
[16:19:15.000]    - call: plan(strategy)
[16:19:15.006] plan(): nbrOfWorkers() = 2
[16:19:14.995] MulticoreFuture:
[16:19:14.995] Label: ‘future_vapply-1’
[16:19:14.995] Expression:
[16:19:14.995] {
[16:19:14.995]     do.call(function(...) {
[16:19:14.995]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:14.995]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:14.995]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:14.995]             on.exit(options(oopts), add = TRUE)
[16:19:14.995]         }
[16:19:14.995]         {
[16:19:14.995]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:14.995]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:14.995]                 ...future.FUN(...future.X_jj, ...)
[16:19:14.995]             })
[16:19:14.995]         }
[16:19:14.995]     }, args = future.call.arguments)
[16:19:14.995] }
[16:19:14.995] Lazy evaluation: FALSE
[16:19:14.995] Asynchronous evaluation: TRUE
[16:19:14.995] Local evaluation: TRUE
[16:19:14.995] Environment: R_GlobalEnv
[16:19:14.995] Capture standard output: TRUE
[16:19:14.995] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:14.995] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:14.995] Packages: 1 packages (‘future.apply’)
[16:19:14.995] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:14.995] Resolved: TRUE
[16:19:14.995] Value: <not collected>
[16:19:14.995] Conditions captured: <none>
[16:19:14.995] Early signaling: FALSE
[16:19:14.995] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:14.995] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.008] Chunk #1 of 2 ... DONE
[16:19:15.008] Chunk #2 of 2 ...
[16:19:15.008]  - Finding globals in 'X' for chunk #2 ...
[16:19:15.009] getGlobalsAndPackages() ...
[16:19:15.009] Searching for globals...
[16:19:15.009] 
[16:19:15.010] Searching for globals ... DONE
[16:19:15.010] - globals: [0] <none>
[16:19:15.010] getGlobalsAndPackages() ... DONE
[16:19:15.010]    + additional globals found: [n=0] 
[16:19:15.010]    + additional namespaces needed: [n=0] 
[16:19:15.010]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:15.011]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:15.011]  - seeds: <none>
[16:19:15.011]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.011] getGlobalsAndPackages() ...
[16:19:15.012] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.012] Resolving globals: FALSE
[16:19:15.012] Tweak future expression to call with '...' arguments ...
[16:19:15.013] {
[16:19:15.013]     do.call(function(...) {
[16:19:15.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.013]             on.exit(options(oopts), add = TRUE)
[16:19:15.013]         }
[16:19:15.013]         {
[16:19:15.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.013]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.013]             })
[16:19:15.013]         }
[16:19:15.013]     }, args = future.call.arguments)
[16:19:15.013] }
[16:19:15.013] Tweak future expression to call with '...' arguments ... DONE
[16:19:15.014] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.015] - packages: [1] ‘future.apply’
[16:19:15.015] getGlobalsAndPackages() ... DONE
[16:19:15.016] run() for ‘Future’ ...
[16:19:15.016] - state: ‘created’
[16:19:15.016] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:15.022] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:15.022]   - Field: ‘label’
[16:19:15.022]   - Field: ‘local’
[16:19:15.022]   - Field: ‘owner’
[16:19:15.023]   - Field: ‘envir’
[16:19:15.023]   - Field: ‘workers’
[16:19:15.023]   - Field: ‘packages’
[16:19:15.023]   - Field: ‘gc’
[16:19:15.023]   - Field: ‘job’
[16:19:15.023]   - Field: ‘conditions’
[16:19:15.023]   - Field: ‘expr’
[16:19:15.024]   - Field: ‘uuid’
[16:19:15.024]   - Field: ‘seed’
[16:19:15.024]   - Field: ‘version’
[16:19:15.024]   - Field: ‘result’
[16:19:15.024]   - Field: ‘asynchronous’
[16:19:15.024]   - Field: ‘calls’
[16:19:15.024]   - Field: ‘globals’
[16:19:15.025]   - Field: ‘stdout’
[16:19:15.025]   - Field: ‘earlySignal’
[16:19:15.025]   - Field: ‘lazy’
[16:19:15.025]   - Field: ‘state’
[16:19:15.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:15.025] - Launch lazy future ...
[16:19:15.026] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:15.026] Packages needed by future strategies (n = 0): <none>
[16:19:15.027] {
[16:19:15.027]     {
[16:19:15.027]         {
[16:19:15.027]             ...future.startTime <- base::Sys.time()
[16:19:15.027]             {
[16:19:15.027]                 {
[16:19:15.027]                   {
[16:19:15.027]                     {
[16:19:15.027]                       {
[16:19:15.027]                         base::local({
[16:19:15.027]                           has_future <- base::requireNamespace("future", 
[16:19:15.027]                             quietly = TRUE)
[16:19:15.027]                           if (has_future) {
[16:19:15.027]                             ns <- base::getNamespace("future")
[16:19:15.027]                             version <- ns[[".package"]][["version"]]
[16:19:15.027]                             if (is.null(version)) 
[16:19:15.027]                               version <- utils::packageVersion("future")
[16:19:15.027]                           }
[16:19:15.027]                           else {
[16:19:15.027]                             version <- NULL
[16:19:15.027]                           }
[16:19:15.027]                           if (!has_future || version < "1.8.0") {
[16:19:15.027]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:15.027]                               "", base::R.version$version.string), 
[16:19:15.027]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:15.027]                                 base::R.version$platform, 8 * 
[16:19:15.027]                                   base::.Machine$sizeof.pointer), 
[16:19:15.027]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:15.027]                                 "release", "version")], collapse = " "), 
[16:19:15.027]                               hostname = base::Sys.info()[["nodename"]])
[16:19:15.027]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:15.027]                               info)
[16:19:15.027]                             info <- base::paste(info, collapse = "; ")
[16:19:15.027]                             if (!has_future) {
[16:19:15.027]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:15.027]                                 info)
[16:19:15.027]                             }
[16:19:15.027]                             else {
[16:19:15.027]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:15.027]                                 info, version)
[16:19:15.027]                             }
[16:19:15.027]                             base::stop(msg)
[16:19:15.027]                           }
[16:19:15.027]                         })
[16:19:15.027]                       }
[16:19:15.027]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:15.027]                       base::options(mc.cores = 1L)
[16:19:15.027]                     }
[16:19:15.027]                     base::local({
[16:19:15.027]                       for (pkg in "future.apply") {
[16:19:15.027]                         base::loadNamespace(pkg)
[16:19:15.027]                         base::library(pkg, character.only = TRUE)
[16:19:15.027]                       }
[16:19:15.027]                     })
[16:19:15.027]                   }
[16:19:15.027]                   ...future.strategy.old <- future::plan("list")
[16:19:15.027]                   options(future.plan = NULL)
[16:19:15.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:15.027]                 }
[16:19:15.027]                 ...future.workdir <- getwd()
[16:19:15.027]             }
[16:19:15.027]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:15.027]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:15.027]         }
[16:19:15.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:15.027]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:15.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:15.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:15.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:15.027]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:15.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:15.027]             base::names(...future.oldOptions))
[16:19:15.027]     }
[16:19:15.027]     if (FALSE) {
[16:19:15.027]     }
[16:19:15.027]     else {
[16:19:15.027]         if (TRUE) {
[16:19:15.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:15.027]                 open = "w")
[16:19:15.027]         }
[16:19:15.027]         else {
[16:19:15.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:15.027]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:15.027]         }
[16:19:15.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:15.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:15.027]             base::sink(type = "output", split = FALSE)
[16:19:15.027]             base::close(...future.stdout)
[16:19:15.027]         }, add = TRUE)
[16:19:15.027]     }
[16:19:15.027]     ...future.frame <- base::sys.nframe()
[16:19:15.027]     ...future.conditions <- base::list()
[16:19:15.027]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:15.027]     if (FALSE) {
[16:19:15.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:15.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:15.027]     }
[16:19:15.027]     ...future.result <- base::tryCatch({
[16:19:15.027]         base::withCallingHandlers({
[16:19:15.027]             ...future.value <- base::withVisible(base::local({
[16:19:15.027]                 withCallingHandlers({
[16:19:15.027]                   {
[16:19:15.027]                     do.call(function(...) {
[16:19:15.027]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.027]                       if (!identical(...future.globals.maxSize.org, 
[16:19:15.027]                         ...future.globals.maxSize)) {
[16:19:15.027]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.027]                         on.exit(options(oopts), add = TRUE)
[16:19:15.027]                       }
[16:19:15.027]                       {
[16:19:15.027]                         lapply(seq_along(...future.elements_ii), 
[16:19:15.027]                           FUN = function(jj) {
[16:19:15.027]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.027]                             ...future.FUN(...future.X_jj, ...)
[16:19:15.027]                           })
[16:19:15.027]                       }
[16:19:15.027]                     }, args = future.call.arguments)
[16:19:15.027]                   }
[16:19:15.027]                 }, immediateCondition = function(cond) {
[16:19:15.027]                   save_rds <- function (object, pathname, ...) 
[16:19:15.027]                   {
[16:19:15.027]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:15.027]                     if (file_test("-f", pathname_tmp)) {
[16:19:15.027]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.027]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:15.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.027]                         fi_tmp[["mtime"]])
[16:19:15.027]                     }
[16:19:15.027]                     tryCatch({
[16:19:15.027]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:15.027]                     }, error = function(ex) {
[16:19:15.027]                       msg <- conditionMessage(ex)
[16:19:15.027]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.027]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:15.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.027]                         fi_tmp[["mtime"]], msg)
[16:19:15.027]                       ex$message <- msg
[16:19:15.027]                       stop(ex)
[16:19:15.027]                     })
[16:19:15.027]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:15.027]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:15.027]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:15.027]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.027]                       fi <- file.info(pathname)
[16:19:15.027]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:15.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.027]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:15.027]                         fi[["size"]], fi[["mtime"]])
[16:19:15.027]                       stop(msg)
[16:19:15.027]                     }
[16:19:15.027]                     invisible(pathname)
[16:19:15.027]                   }
[16:19:15.027]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:15.027]                     rootPath = tempdir()) 
[16:19:15.027]                   {
[16:19:15.027]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:15.027]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:15.027]                       tmpdir = path, fileext = ".rds")
[16:19:15.027]                     save_rds(obj, file)
[16:19:15.027]                   }
[16:19:15.027]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:15.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.027]                   {
[16:19:15.027]                     inherits <- base::inherits
[16:19:15.027]                     invokeRestart <- base::invokeRestart
[16:19:15.027]                     is.null <- base::is.null
[16:19:15.027]                     muffled <- FALSE
[16:19:15.027]                     if (inherits(cond, "message")) {
[16:19:15.027]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:15.027]                       if (muffled) 
[16:19:15.027]                         invokeRestart("muffleMessage")
[16:19:15.027]                     }
[16:19:15.027]                     else if (inherits(cond, "warning")) {
[16:19:15.027]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:15.027]                       if (muffled) 
[16:19:15.027]                         invokeRestart("muffleWarning")
[16:19:15.027]                     }
[16:19:15.027]                     else if (inherits(cond, "condition")) {
[16:19:15.027]                       if (!is.null(pattern)) {
[16:19:15.027]                         computeRestarts <- base::computeRestarts
[16:19:15.027]                         grepl <- base::grepl
[16:19:15.027]                         restarts <- computeRestarts(cond)
[16:19:15.027]                         for (restart in restarts) {
[16:19:15.027]                           name <- restart$name
[16:19:15.027]                           if (is.null(name)) 
[16:19:15.027]                             next
[16:19:15.027]                           if (!grepl(pattern, name)) 
[16:19:15.027]                             next
[16:19:15.027]                           invokeRestart(restart)
[16:19:15.027]                           muffled <- TRUE
[16:19:15.027]                           break
[16:19:15.027]                         }
[16:19:15.027]                       }
[16:19:15.027]                     }
[16:19:15.027]                     invisible(muffled)
[16:19:15.027]                   }
[16:19:15.027]                   muffleCondition(cond)
[16:19:15.027]                 })
[16:19:15.027]             }))
[16:19:15.027]             future::FutureResult(value = ...future.value$value, 
[16:19:15.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.027]                   ...future.rng), globalenv = if (FALSE) 
[16:19:15.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:15.027]                     ...future.globalenv.names))
[16:19:15.027]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:15.027]         }, condition = base::local({
[16:19:15.027]             c <- base::c
[16:19:15.027]             inherits <- base::inherits
[16:19:15.027]             invokeRestart <- base::invokeRestart
[16:19:15.027]             length <- base::length
[16:19:15.027]             list <- base::list
[16:19:15.027]             seq.int <- base::seq.int
[16:19:15.027]             signalCondition <- base::signalCondition
[16:19:15.027]             sys.calls <- base::sys.calls
[16:19:15.027]             `[[` <- base::`[[`
[16:19:15.027]             `+` <- base::`+`
[16:19:15.027]             `<<-` <- base::`<<-`
[16:19:15.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:15.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:15.027]                   3L)]
[16:19:15.027]             }
[16:19:15.027]             function(cond) {
[16:19:15.027]                 is_error <- inherits(cond, "error")
[16:19:15.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:15.027]                   NULL)
[16:19:15.027]                 if (is_error) {
[16:19:15.027]                   sessionInformation <- function() {
[16:19:15.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:15.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:15.027]                       search = base::search(), system = base::Sys.info())
[16:19:15.027]                   }
[16:19:15.027]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:15.027]                     cond$call), session = sessionInformation(), 
[16:19:15.027]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:15.027]                   signalCondition(cond)
[16:19:15.027]                 }
[16:19:15.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:15.027]                 "immediateCondition"))) {
[16:19:15.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:15.027]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:15.027]                   if (TRUE && !signal) {
[16:19:15.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.027]                     {
[16:19:15.027]                       inherits <- base::inherits
[16:19:15.027]                       invokeRestart <- base::invokeRestart
[16:19:15.027]                       is.null <- base::is.null
[16:19:15.027]                       muffled <- FALSE
[16:19:15.027]                       if (inherits(cond, "message")) {
[16:19:15.027]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.027]                         if (muffled) 
[16:19:15.027]                           invokeRestart("muffleMessage")
[16:19:15.027]                       }
[16:19:15.027]                       else if (inherits(cond, "warning")) {
[16:19:15.027]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.027]                         if (muffled) 
[16:19:15.027]                           invokeRestart("muffleWarning")
[16:19:15.027]                       }
[16:19:15.027]                       else if (inherits(cond, "condition")) {
[16:19:15.027]                         if (!is.null(pattern)) {
[16:19:15.027]                           computeRestarts <- base::computeRestarts
[16:19:15.027]                           grepl <- base::grepl
[16:19:15.027]                           restarts <- computeRestarts(cond)
[16:19:15.027]                           for (restart in restarts) {
[16:19:15.027]                             name <- restart$name
[16:19:15.027]                             if (is.null(name)) 
[16:19:15.027]                               next
[16:19:15.027]                             if (!grepl(pattern, name)) 
[16:19:15.027]                               next
[16:19:15.027]                             invokeRestart(restart)
[16:19:15.027]                             muffled <- TRUE
[16:19:15.027]                             break
[16:19:15.027]                           }
[16:19:15.027]                         }
[16:19:15.027]                       }
[16:19:15.027]                       invisible(muffled)
[16:19:15.027]                     }
[16:19:15.027]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.027]                   }
[16:19:15.027]                 }
[16:19:15.027]                 else {
[16:19:15.027]                   if (TRUE) {
[16:19:15.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.027]                     {
[16:19:15.027]                       inherits <- base::inherits
[16:19:15.027]                       invokeRestart <- base::invokeRestart
[16:19:15.027]                       is.null <- base::is.null
[16:19:15.027]                       muffled <- FALSE
[16:19:15.027]                       if (inherits(cond, "message")) {
[16:19:15.027]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.027]                         if (muffled) 
[16:19:15.027]                           invokeRestart("muffleMessage")
[16:19:15.027]                       }
[16:19:15.027]                       else if (inherits(cond, "warning")) {
[16:19:15.027]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.027]                         if (muffled) 
[16:19:15.027]                           invokeRestart("muffleWarning")
[16:19:15.027]                       }
[16:19:15.027]                       else if (inherits(cond, "condition")) {
[16:19:15.027]                         if (!is.null(pattern)) {
[16:19:15.027]                           computeRestarts <- base::computeRestarts
[16:19:15.027]                           grepl <- base::grepl
[16:19:15.027]                           restarts <- computeRestarts(cond)
[16:19:15.027]                           for (restart in restarts) {
[16:19:15.027]                             name <- restart$name
[16:19:15.027]                             if (is.null(name)) 
[16:19:15.027]                               next
[16:19:15.027]                             if (!grepl(pattern, name)) 
[16:19:15.027]                               next
[16:19:15.027]                             invokeRestart(restart)
[16:19:15.027]                             muffled <- TRUE
[16:19:15.027]                             break
[16:19:15.027]                           }
[16:19:15.027]                         }
[16:19:15.027]                       }
[16:19:15.027]                       invisible(muffled)
[16:19:15.027]                     }
[16:19:15.027]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.027]                   }
[16:19:15.027]                 }
[16:19:15.027]             }
[16:19:15.027]         }))
[16:19:15.027]     }, error = function(ex) {
[16:19:15.027]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:15.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.027]                 ...future.rng), started = ...future.startTime, 
[16:19:15.027]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:15.027]             version = "1.8"), class = "FutureResult")
[16:19:15.027]     }, finally = {
[16:19:15.027]         if (!identical(...future.workdir, getwd())) 
[16:19:15.027]             setwd(...future.workdir)
[16:19:15.027]         {
[16:19:15.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:15.027]                 ...future.oldOptions$nwarnings <- NULL
[16:19:15.027]             }
[16:19:15.027]             base::options(...future.oldOptions)
[16:19:15.027]             if (.Platform$OS.type == "windows") {
[16:19:15.027]                 old_names <- names(...future.oldEnvVars)
[16:19:15.027]                 envs <- base::Sys.getenv()
[16:19:15.027]                 names <- names(envs)
[16:19:15.027]                 common <- intersect(names, old_names)
[16:19:15.027]                 added <- setdiff(names, old_names)
[16:19:15.027]                 removed <- setdiff(old_names, names)
[16:19:15.027]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:15.027]                   envs[common]]
[16:19:15.027]                 NAMES <- toupper(changed)
[16:19:15.027]                 args <- list()
[16:19:15.027]                 for (kk in seq_along(NAMES)) {
[16:19:15.027]                   name <- changed[[kk]]
[16:19:15.027]                   NAME <- NAMES[[kk]]
[16:19:15.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.027]                     next
[16:19:15.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.027]                 }
[16:19:15.027]                 NAMES <- toupper(added)
[16:19:15.027]                 for (kk in seq_along(NAMES)) {
[16:19:15.027]                   name <- added[[kk]]
[16:19:15.027]                   NAME <- NAMES[[kk]]
[16:19:15.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.027]                     next
[16:19:15.027]                   args[[name]] <- ""
[16:19:15.027]                 }
[16:19:15.027]                 NAMES <- toupper(removed)
[16:19:15.027]                 for (kk in seq_along(NAMES)) {
[16:19:15.027]                   name <- removed[[kk]]
[16:19:15.027]                   NAME <- NAMES[[kk]]
[16:19:15.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.027]                     next
[16:19:15.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.027]                 }
[16:19:15.027]                 if (length(args) > 0) 
[16:19:15.027]                   base::do.call(base::Sys.setenv, args = args)
[16:19:15.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:15.027]             }
[16:19:15.027]             else {
[16:19:15.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:15.027]             }
[16:19:15.027]             {
[16:19:15.027]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:15.027]                   0L) {
[16:19:15.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:15.027]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:15.027]                   base::options(opts)
[16:19:15.027]                 }
[16:19:15.027]                 {
[16:19:15.027]                   {
[16:19:15.027]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:15.027]                     NULL
[16:19:15.027]                   }
[16:19:15.027]                   options(future.plan = NULL)
[16:19:15.027]                   if (is.na(NA_character_)) 
[16:19:15.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:15.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:15.027]                     .init = FALSE)
[16:19:15.027]                 }
[16:19:15.027]             }
[16:19:15.027]         }
[16:19:15.027]     })
[16:19:15.027]     if (TRUE) {
[16:19:15.027]         base::sink(type = "output", split = FALSE)
[16:19:15.027]         if (TRUE) {
[16:19:15.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:15.027]         }
[16:19:15.027]         else {
[16:19:15.027]             ...future.result["stdout"] <- base::list(NULL)
[16:19:15.027]         }
[16:19:15.027]         base::close(...future.stdout)
[16:19:15.027]         ...future.stdout <- NULL
[16:19:15.027]     }
[16:19:15.027]     ...future.result$conditions <- ...future.conditions
[16:19:15.027]     ...future.result$finished <- base::Sys.time()
[16:19:15.027]     ...future.result
[16:19:15.027] }
[16:19:15.030] assign_globals() ...
[16:19:15.030] List of 11
[16:19:15.030]  $ ...future.FUN            :function (x, ...)  
[16:19:15.030]  $ x_FUN                    :function (x, y)  
[16:19:15.030]  $ times                    : int 15
[16:19:15.030]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.030]  $ stop_if_not              :function (...)  
[16:19:15.030]  $ dim                      : int [1:2] 3 5
[16:19:15.030]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:15.030]  $ future.call.arguments    :List of 1
[16:19:15.030]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:15.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.030]  $ ...future.elements_ii    :List of 2
[16:19:15.030]   ..$ C: num 70
[16:19:15.030]   ..$ D: num 80
[16:19:15.030]  $ ...future.seeds_ii       : NULL
[16:19:15.030]  $ ...future.globals.maxSize: NULL
[16:19:15.030]  - attr(*, "where")=List of 11
[16:19:15.030]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:15.030]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:15.030]  - attr(*, "resolved")= logi FALSE
[16:19:15.030]  - attr(*, "total_size")= num 98600
[16:19:15.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.030]  - attr(*, "already-done")= logi TRUE
[16:19:15.044] - copied ‘...future.FUN’ to environment
[16:19:15.044] - reassign environment for ‘x_FUN’
[16:19:15.044] - copied ‘x_FUN’ to environment
[16:19:15.044] - copied ‘times’ to environment
[16:19:15.044] - copied ‘stopf’ to environment
[16:19:15.044] - copied ‘stop_if_not’ to environment
[16:19:15.045] - copied ‘dim’ to environment
[16:19:15.045] - copied ‘valid_types’ to environment
[16:19:15.045] - copied ‘future.call.arguments’ to environment
[16:19:15.045] - copied ‘...future.elements_ii’ to environment
[16:19:15.045] - copied ‘...future.seeds_ii’ to environment
[16:19:15.045] - copied ‘...future.globals.maxSize’ to environment
[16:19:15.045] assign_globals() ... done
[16:19:15.046] requestCore(): workers = 2
[16:19:15.048] MulticoreFuture started
[16:19:15.049] - Launch lazy future ... done
[16:19:15.050] run() for ‘MulticoreFuture’ ... done
[16:19:15.050] Created future:
[16:19:15.050] plan(): Setting new future strategy stack:
[16:19:15.051] List of future strategies:
[16:19:15.051] 1. sequential:
[16:19:15.051]    - args: function (..., envir = parent.frame())
[16:19:15.051]    - tweaked: FALSE
[16:19:15.051]    - call: NULL
[16:19:15.052] plan(): nbrOfWorkers() = 1
[16:19:15.055] plan(): Setting new future strategy stack:
[16:19:15.055] List of future strategies:
[16:19:15.055] 1. multicore:
[16:19:15.055]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:15.055]    - tweaked: FALSE
[16:19:15.055]    - call: plan(strategy)
[16:19:15.061] plan(): nbrOfWorkers() = 2
[16:19:15.051] MulticoreFuture:
[16:19:15.051] Label: ‘future_vapply-2’
[16:19:15.051] Expression:
[16:19:15.051] {
[16:19:15.051]     do.call(function(...) {
[16:19:15.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.051]             on.exit(options(oopts), add = TRUE)
[16:19:15.051]         }
[16:19:15.051]         {
[16:19:15.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.051]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.051]             })
[16:19:15.051]         }
[16:19:15.051]     }, args = future.call.arguments)
[16:19:15.051] }
[16:19:15.051] Lazy evaluation: FALSE
[16:19:15.051] Asynchronous evaluation: TRUE
[16:19:15.051] Local evaluation: TRUE
[16:19:15.051] Environment: R_GlobalEnv
[16:19:15.051] Capture standard output: TRUE
[16:19:15.051] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:15.051] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:15.051] Packages: 1 packages (‘future.apply’)
[16:19:15.051] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:15.051] Resolved: TRUE
[16:19:15.051] Value: <not collected>
[16:19:15.051] Conditions captured: <none>
[16:19:15.051] Early signaling: FALSE
[16:19:15.051] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:15.051] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.063] Chunk #2 of 2 ... DONE
[16:19:15.063] Launching 2 futures (chunks) ... DONE
[16:19:15.063] Resolving 2 futures (chunks) ...
[16:19:15.064] resolve() on list ...
[16:19:15.064]  recursive: 0
[16:19:15.064]  length: 2
[16:19:15.064] 
[16:19:15.064] Future #1
[16:19:15.065] result() for MulticoreFuture ...
[16:19:15.065] result() for MulticoreFuture ...
[16:19:15.066] result() for MulticoreFuture ... done
[16:19:15.066] result() for MulticoreFuture ... done
[16:19:15.066] result() for MulticoreFuture ...
[16:19:15.066] result() for MulticoreFuture ... done
[16:19:15.066] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:15.066] - nx: 2
[16:19:15.067] - relay: TRUE
[16:19:15.067] - stdout: TRUE
[16:19:15.067] - signal: TRUE
[16:19:15.067] - resignal: FALSE
[16:19:15.068] - force: TRUE
[16:19:15.068] - relayed: [n=2] FALSE, FALSE
[16:19:15.068] - queued futures: [n=2] FALSE, FALSE
[16:19:15.068]  - until=1
[16:19:15.068]  - relaying element #1
[16:19:15.068] result() for MulticoreFuture ...
[16:19:15.069] result() for MulticoreFuture ... done
[16:19:15.069] result() for MulticoreFuture ...
[16:19:15.069] result() for MulticoreFuture ... done
[16:19:15.069] result() for MulticoreFuture ...
[16:19:15.070] result() for MulticoreFuture ... done
[16:19:15.070] result() for MulticoreFuture ...
[16:19:15.070] result() for MulticoreFuture ... done
[16:19:15.070] - relayed: [n=2] TRUE, FALSE
[16:19:15.070] - queued futures: [n=2] TRUE, FALSE
[16:19:15.070] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:15.071]  length: 1 (resolved future 1)
[16:19:15.071] Future #2
[16:19:15.071] result() for MulticoreFuture ...
[16:19:15.072] result() for MulticoreFuture ...
[16:19:15.072] result() for MulticoreFuture ... done
[16:19:15.072] result() for MulticoreFuture ... done
[16:19:15.072] result() for MulticoreFuture ...
[16:19:15.072] result() for MulticoreFuture ... done
[16:19:15.073] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:15.073] - nx: 2
[16:19:15.073] - relay: TRUE
[16:19:15.073] - stdout: TRUE
[16:19:15.073] - signal: TRUE
[16:19:15.073] - resignal: FALSE
[16:19:15.073] - force: TRUE
[16:19:15.073] - relayed: [n=2] TRUE, FALSE
[16:19:15.074] - queued futures: [n=2] TRUE, FALSE
[16:19:15.074]  - until=2
[16:19:15.074]  - relaying element #2
[16:19:15.074] result() for MulticoreFuture ...
[16:19:15.074] result() for MulticoreFuture ... done
[16:19:15.074] result() for MulticoreFuture ...
[16:19:15.074] result() for MulticoreFuture ... done
[16:19:15.074] result() for MulticoreFuture ...
[16:19:15.075] result() for MulticoreFuture ... done
[16:19:15.075] result() for MulticoreFuture ...
[16:19:15.075] result() for MulticoreFuture ... done
[16:19:15.075] - relayed: [n=2] TRUE, TRUE
[16:19:15.075] - queued futures: [n=2] TRUE, TRUE
[16:19:15.075] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:15.075]  length: 0 (resolved future 2)
[16:19:15.075] Relaying remaining futures
[16:19:15.075] signalConditionsASAP(NULL, pos=0) ...
[16:19:15.076] - nx: 2
[16:19:15.076] - relay: TRUE
[16:19:15.076] - stdout: TRUE
[16:19:15.076] - signal: TRUE
[16:19:15.076] - resignal: FALSE
[16:19:15.076] - force: TRUE
[16:19:15.076] - relayed: [n=2] TRUE, TRUE
[16:19:15.076] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:15.077] - relayed: [n=2] TRUE, TRUE
[16:19:15.077] - queued futures: [n=2] TRUE, TRUE
[16:19:15.077] signalConditionsASAP(NULL, pos=0) ... done
[16:19:15.077] resolve() on list ... DONE
[16:19:15.077] result() for MulticoreFuture ...
[16:19:15.077] result() for MulticoreFuture ... done
[16:19:15.077] result() for MulticoreFuture ...
[16:19:15.077] result() for MulticoreFuture ... done
[16:19:15.077] result() for MulticoreFuture ...
[16:19:15.078] result() for MulticoreFuture ... done
[16:19:15.078] result() for MulticoreFuture ...
[16:19:15.078] result() for MulticoreFuture ... done
[16:19:15.078]  - Number of value chunks collected: 2
[16:19:15.078] Resolving 2 futures (chunks) ... DONE
[16:19:15.078] Reducing values from 2 chunks ...
[16:19:15.078]  - Number of values collected after concatenation: 4
[16:19:15.078]  - Number of values expected: 4
[16:19:15.078] Reducing values from 2 chunks ... DONE
[16:19:15.079] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:19:15.081] future_lapply() ...
[16:19:15.091] Number of chunks: 2
[16:19:15.092] getGlobalsAndPackagesXApply() ...
[16:19:15.092]  - future.globals: TRUE
[16:19:15.092] getGlobalsAndPackages() ...
[16:19:15.092] Searching for globals...
[16:19:15.096] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:15.097] Searching for globals ... DONE
[16:19:15.097] Resolving globals: FALSE
[16:19:15.098] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:19:15.098] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:15.098] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:15.098] - packages: [1] ‘future.apply’
[16:19:15.099] getGlobalsAndPackages() ... DONE
[16:19:15.099]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:15.099]  - needed namespaces: [n=1] ‘future.apply’
[16:19:15.099] Finding globals ... DONE
[16:19:15.099]  - use_args: TRUE
[16:19:15.099]  - Getting '...' globals ...
[16:19:15.099] resolve() on list ...
[16:19:15.099]  recursive: 0
[16:19:15.100]  length: 1
[16:19:15.100]  elements: ‘...’
[16:19:15.100]  length: 0 (resolved future 1)
[16:19:15.100] resolve() on list ... DONE
[16:19:15.100]    - '...' content: [n=0] 
[16:19:15.100] List of 1
[16:19:15.100]  $ ...: list()
[16:19:15.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.100]  - attr(*, "where")=List of 1
[16:19:15.100]   ..$ ...:<environment: 0x56199f217760> 
[16:19:15.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.100]  - attr(*, "resolved")= logi TRUE
[16:19:15.100]  - attr(*, "total_size")= num NA
[16:19:15.103]  - Getting '...' globals ... DONE
[16:19:15.103] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:15.103] List of 8
[16:19:15.103]  $ ...future.FUN:function (x, ...)  
[16:19:15.103]  $ x_FUN        :function (x)  
[16:19:15.103]  $ times        : int 1
[16:19:15.103]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.103]  $ stop_if_not  :function (...)  
[16:19:15.103]  $ dim          : NULL
[16:19:15.103]  $ valid_types  : chr "logical"
[16:19:15.103]  $ ...          : list()
[16:19:15.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.103]  - attr(*, "where")=List of 8
[16:19:15.103]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:15.103]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:15.103]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:15.103]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:15.103]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:15.103]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:15.103]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:15.103]   ..$ ...          :<environment: 0x56199f217760> 
[16:19:15.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.103]  - attr(*, "resolved")= logi FALSE
[16:19:15.103]  - attr(*, "total_size")= num 94200
[16:19:15.112] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:15.112] getGlobalsAndPackagesXApply() ... DONE
[16:19:15.112] Number of futures (= number of chunks): 2
[16:19:15.112] Launching 2 futures (chunks) ...
[16:19:15.112] Chunk #1 of 2 ...
[16:19:15.112]  - Finding globals in 'X' for chunk #1 ...
[16:19:15.113] getGlobalsAndPackages() ...
[16:19:15.113] Searching for globals...
[16:19:15.113] 
[16:19:15.113] Searching for globals ... DONE
[16:19:15.113] - globals: [0] <none>
[16:19:15.113] getGlobalsAndPackages() ... DONE
[16:19:15.113]    + additional globals found: [n=0] 
[16:19:15.114]    + additional namespaces needed: [n=0] 
[16:19:15.114]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:15.114]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:15.114]  - seeds: <none>
[16:19:15.114]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.114] getGlobalsAndPackages() ...
[16:19:15.114] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.114] Resolving globals: FALSE
[16:19:15.115] Tweak future expression to call with '...' arguments ...
[16:19:15.115] {
[16:19:15.115]     do.call(function(...) {
[16:19:15.115]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.115]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.115]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.115]             on.exit(options(oopts), add = TRUE)
[16:19:15.115]         }
[16:19:15.115]         {
[16:19:15.115]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.115]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.115]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.115]             })
[16:19:15.115]         }
[16:19:15.115]     }, args = future.call.arguments)
[16:19:15.115] }
[16:19:15.115] Tweak future expression to call with '...' arguments ... DONE
[16:19:15.116] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.116] - packages: [1] ‘future.apply’
[16:19:15.116] getGlobalsAndPackages() ... DONE
[16:19:15.116] run() for ‘Future’ ...
[16:19:15.116] - state: ‘created’
[16:19:15.117] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:15.121] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:15.121]   - Field: ‘label’
[16:19:15.121]   - Field: ‘local’
[16:19:15.121]   - Field: ‘owner’
[16:19:15.122]   - Field: ‘envir’
[16:19:15.122]   - Field: ‘workers’
[16:19:15.122]   - Field: ‘packages’
[16:19:15.122]   - Field: ‘gc’
[16:19:15.122]   - Field: ‘job’
[16:19:15.122]   - Field: ‘conditions’
[16:19:15.122]   - Field: ‘expr’
[16:19:15.122]   - Field: ‘uuid’
[16:19:15.122]   - Field: ‘seed’
[16:19:15.123]   - Field: ‘version’
[16:19:15.123]   - Field: ‘result’
[16:19:15.123]   - Field: ‘asynchronous’
[16:19:15.123]   - Field: ‘calls’
[16:19:15.123]   - Field: ‘globals’
[16:19:15.123]   - Field: ‘stdout’
[16:19:15.123]   - Field: ‘earlySignal’
[16:19:15.123]   - Field: ‘lazy’
[16:19:15.123]   - Field: ‘state’
[16:19:15.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:15.124] - Launch lazy future ...
[16:19:15.124] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:15.124] Packages needed by future strategies (n = 0): <none>
[16:19:15.125] {
[16:19:15.125]     {
[16:19:15.125]         {
[16:19:15.125]             ...future.startTime <- base::Sys.time()
[16:19:15.125]             {
[16:19:15.125]                 {
[16:19:15.125]                   {
[16:19:15.125]                     {
[16:19:15.125]                       {
[16:19:15.125]                         base::local({
[16:19:15.125]                           has_future <- base::requireNamespace("future", 
[16:19:15.125]                             quietly = TRUE)
[16:19:15.125]                           if (has_future) {
[16:19:15.125]                             ns <- base::getNamespace("future")
[16:19:15.125]                             version <- ns[[".package"]][["version"]]
[16:19:15.125]                             if (is.null(version)) 
[16:19:15.125]                               version <- utils::packageVersion("future")
[16:19:15.125]                           }
[16:19:15.125]                           else {
[16:19:15.125]                             version <- NULL
[16:19:15.125]                           }
[16:19:15.125]                           if (!has_future || version < "1.8.0") {
[16:19:15.125]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:15.125]                               "", base::R.version$version.string), 
[16:19:15.125]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:15.125]                                 base::R.version$platform, 8 * 
[16:19:15.125]                                   base::.Machine$sizeof.pointer), 
[16:19:15.125]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:15.125]                                 "release", "version")], collapse = " "), 
[16:19:15.125]                               hostname = base::Sys.info()[["nodename"]])
[16:19:15.125]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:15.125]                               info)
[16:19:15.125]                             info <- base::paste(info, collapse = "; ")
[16:19:15.125]                             if (!has_future) {
[16:19:15.125]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:15.125]                                 info)
[16:19:15.125]                             }
[16:19:15.125]                             else {
[16:19:15.125]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:15.125]                                 info, version)
[16:19:15.125]                             }
[16:19:15.125]                             base::stop(msg)
[16:19:15.125]                           }
[16:19:15.125]                         })
[16:19:15.125]                       }
[16:19:15.125]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:15.125]                       base::options(mc.cores = 1L)
[16:19:15.125]                     }
[16:19:15.125]                     base::local({
[16:19:15.125]                       for (pkg in "future.apply") {
[16:19:15.125]                         base::loadNamespace(pkg)
[16:19:15.125]                         base::library(pkg, character.only = TRUE)
[16:19:15.125]                       }
[16:19:15.125]                     })
[16:19:15.125]                   }
[16:19:15.125]                   ...future.strategy.old <- future::plan("list")
[16:19:15.125]                   options(future.plan = NULL)
[16:19:15.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:15.125]                 }
[16:19:15.125]                 ...future.workdir <- getwd()
[16:19:15.125]             }
[16:19:15.125]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:15.125]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:15.125]         }
[16:19:15.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:15.125]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:15.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:15.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:15.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:15.125]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:15.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:15.125]             base::names(...future.oldOptions))
[16:19:15.125]     }
[16:19:15.125]     if (FALSE) {
[16:19:15.125]     }
[16:19:15.125]     else {
[16:19:15.125]         if (TRUE) {
[16:19:15.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:15.125]                 open = "w")
[16:19:15.125]         }
[16:19:15.125]         else {
[16:19:15.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:15.125]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:15.125]         }
[16:19:15.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:15.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:15.125]             base::sink(type = "output", split = FALSE)
[16:19:15.125]             base::close(...future.stdout)
[16:19:15.125]         }, add = TRUE)
[16:19:15.125]     }
[16:19:15.125]     ...future.frame <- base::sys.nframe()
[16:19:15.125]     ...future.conditions <- base::list()
[16:19:15.125]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:15.125]     if (FALSE) {
[16:19:15.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:15.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:15.125]     }
[16:19:15.125]     ...future.result <- base::tryCatch({
[16:19:15.125]         base::withCallingHandlers({
[16:19:15.125]             ...future.value <- base::withVisible(base::local({
[16:19:15.125]                 withCallingHandlers({
[16:19:15.125]                   {
[16:19:15.125]                     do.call(function(...) {
[16:19:15.125]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.125]                       if (!identical(...future.globals.maxSize.org, 
[16:19:15.125]                         ...future.globals.maxSize)) {
[16:19:15.125]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.125]                         on.exit(options(oopts), add = TRUE)
[16:19:15.125]                       }
[16:19:15.125]                       {
[16:19:15.125]                         lapply(seq_along(...future.elements_ii), 
[16:19:15.125]                           FUN = function(jj) {
[16:19:15.125]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.125]                             ...future.FUN(...future.X_jj, ...)
[16:19:15.125]                           })
[16:19:15.125]                       }
[16:19:15.125]                     }, args = future.call.arguments)
[16:19:15.125]                   }
[16:19:15.125]                 }, immediateCondition = function(cond) {
[16:19:15.125]                   save_rds <- function (object, pathname, ...) 
[16:19:15.125]                   {
[16:19:15.125]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:15.125]                     if (file_test("-f", pathname_tmp)) {
[16:19:15.125]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.125]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:15.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.125]                         fi_tmp[["mtime"]])
[16:19:15.125]                     }
[16:19:15.125]                     tryCatch({
[16:19:15.125]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:15.125]                     }, error = function(ex) {
[16:19:15.125]                       msg <- conditionMessage(ex)
[16:19:15.125]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.125]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:15.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.125]                         fi_tmp[["mtime"]], msg)
[16:19:15.125]                       ex$message <- msg
[16:19:15.125]                       stop(ex)
[16:19:15.125]                     })
[16:19:15.125]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:15.125]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:15.125]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:15.125]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.125]                       fi <- file.info(pathname)
[16:19:15.125]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:15.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.125]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:15.125]                         fi[["size"]], fi[["mtime"]])
[16:19:15.125]                       stop(msg)
[16:19:15.125]                     }
[16:19:15.125]                     invisible(pathname)
[16:19:15.125]                   }
[16:19:15.125]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:15.125]                     rootPath = tempdir()) 
[16:19:15.125]                   {
[16:19:15.125]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:15.125]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:15.125]                       tmpdir = path, fileext = ".rds")
[16:19:15.125]                     save_rds(obj, file)
[16:19:15.125]                   }
[16:19:15.125]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:15.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.125]                   {
[16:19:15.125]                     inherits <- base::inherits
[16:19:15.125]                     invokeRestart <- base::invokeRestart
[16:19:15.125]                     is.null <- base::is.null
[16:19:15.125]                     muffled <- FALSE
[16:19:15.125]                     if (inherits(cond, "message")) {
[16:19:15.125]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:15.125]                       if (muffled) 
[16:19:15.125]                         invokeRestart("muffleMessage")
[16:19:15.125]                     }
[16:19:15.125]                     else if (inherits(cond, "warning")) {
[16:19:15.125]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:15.125]                       if (muffled) 
[16:19:15.125]                         invokeRestart("muffleWarning")
[16:19:15.125]                     }
[16:19:15.125]                     else if (inherits(cond, "condition")) {
[16:19:15.125]                       if (!is.null(pattern)) {
[16:19:15.125]                         computeRestarts <- base::computeRestarts
[16:19:15.125]                         grepl <- base::grepl
[16:19:15.125]                         restarts <- computeRestarts(cond)
[16:19:15.125]                         for (restart in restarts) {
[16:19:15.125]                           name <- restart$name
[16:19:15.125]                           if (is.null(name)) 
[16:19:15.125]                             next
[16:19:15.125]                           if (!grepl(pattern, name)) 
[16:19:15.125]                             next
[16:19:15.125]                           invokeRestart(restart)
[16:19:15.125]                           muffled <- TRUE
[16:19:15.125]                           break
[16:19:15.125]                         }
[16:19:15.125]                       }
[16:19:15.125]                     }
[16:19:15.125]                     invisible(muffled)
[16:19:15.125]                   }
[16:19:15.125]                   muffleCondition(cond)
[16:19:15.125]                 })
[16:19:15.125]             }))
[16:19:15.125]             future::FutureResult(value = ...future.value$value, 
[16:19:15.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.125]                   ...future.rng), globalenv = if (FALSE) 
[16:19:15.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:15.125]                     ...future.globalenv.names))
[16:19:15.125]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:15.125]         }, condition = base::local({
[16:19:15.125]             c <- base::c
[16:19:15.125]             inherits <- base::inherits
[16:19:15.125]             invokeRestart <- base::invokeRestart
[16:19:15.125]             length <- base::length
[16:19:15.125]             list <- base::list
[16:19:15.125]             seq.int <- base::seq.int
[16:19:15.125]             signalCondition <- base::signalCondition
[16:19:15.125]             sys.calls <- base::sys.calls
[16:19:15.125]             `[[` <- base::`[[`
[16:19:15.125]             `+` <- base::`+`
[16:19:15.125]             `<<-` <- base::`<<-`
[16:19:15.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:15.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:15.125]                   3L)]
[16:19:15.125]             }
[16:19:15.125]             function(cond) {
[16:19:15.125]                 is_error <- inherits(cond, "error")
[16:19:15.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:15.125]                   NULL)
[16:19:15.125]                 if (is_error) {
[16:19:15.125]                   sessionInformation <- function() {
[16:19:15.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:15.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:15.125]                       search = base::search(), system = base::Sys.info())
[16:19:15.125]                   }
[16:19:15.125]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:15.125]                     cond$call), session = sessionInformation(), 
[16:19:15.125]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:15.125]                   signalCondition(cond)
[16:19:15.125]                 }
[16:19:15.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:15.125]                 "immediateCondition"))) {
[16:19:15.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:15.125]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:15.125]                   if (TRUE && !signal) {
[16:19:15.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.125]                     {
[16:19:15.125]                       inherits <- base::inherits
[16:19:15.125]                       invokeRestart <- base::invokeRestart
[16:19:15.125]                       is.null <- base::is.null
[16:19:15.125]                       muffled <- FALSE
[16:19:15.125]                       if (inherits(cond, "message")) {
[16:19:15.125]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.125]                         if (muffled) 
[16:19:15.125]                           invokeRestart("muffleMessage")
[16:19:15.125]                       }
[16:19:15.125]                       else if (inherits(cond, "warning")) {
[16:19:15.125]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.125]                         if (muffled) 
[16:19:15.125]                           invokeRestart("muffleWarning")
[16:19:15.125]                       }
[16:19:15.125]                       else if (inherits(cond, "condition")) {
[16:19:15.125]                         if (!is.null(pattern)) {
[16:19:15.125]                           computeRestarts <- base::computeRestarts
[16:19:15.125]                           grepl <- base::grepl
[16:19:15.125]                           restarts <- computeRestarts(cond)
[16:19:15.125]                           for (restart in restarts) {
[16:19:15.125]                             name <- restart$name
[16:19:15.125]                             if (is.null(name)) 
[16:19:15.125]                               next
[16:19:15.125]                             if (!grepl(pattern, name)) 
[16:19:15.125]                               next
[16:19:15.125]                             invokeRestart(restart)
[16:19:15.125]                             muffled <- TRUE
[16:19:15.125]                             break
[16:19:15.125]                           }
[16:19:15.125]                         }
[16:19:15.125]                       }
[16:19:15.125]                       invisible(muffled)
[16:19:15.125]                     }
[16:19:15.125]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.125]                   }
[16:19:15.125]                 }
[16:19:15.125]                 else {
[16:19:15.125]                   if (TRUE) {
[16:19:15.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.125]                     {
[16:19:15.125]                       inherits <- base::inherits
[16:19:15.125]                       invokeRestart <- base::invokeRestart
[16:19:15.125]                       is.null <- base::is.null
[16:19:15.125]                       muffled <- FALSE
[16:19:15.125]                       if (inherits(cond, "message")) {
[16:19:15.125]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.125]                         if (muffled) 
[16:19:15.125]                           invokeRestart("muffleMessage")
[16:19:15.125]                       }
[16:19:15.125]                       else if (inherits(cond, "warning")) {
[16:19:15.125]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.125]                         if (muffled) 
[16:19:15.125]                           invokeRestart("muffleWarning")
[16:19:15.125]                       }
[16:19:15.125]                       else if (inherits(cond, "condition")) {
[16:19:15.125]                         if (!is.null(pattern)) {
[16:19:15.125]                           computeRestarts <- base::computeRestarts
[16:19:15.125]                           grepl <- base::grepl
[16:19:15.125]                           restarts <- computeRestarts(cond)
[16:19:15.125]                           for (restart in restarts) {
[16:19:15.125]                             name <- restart$name
[16:19:15.125]                             if (is.null(name)) 
[16:19:15.125]                               next
[16:19:15.125]                             if (!grepl(pattern, name)) 
[16:19:15.125]                               next
[16:19:15.125]                             invokeRestart(restart)
[16:19:15.125]                             muffled <- TRUE
[16:19:15.125]                             break
[16:19:15.125]                           }
[16:19:15.125]                         }
[16:19:15.125]                       }
[16:19:15.125]                       invisible(muffled)
[16:19:15.125]                     }
[16:19:15.125]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.125]                   }
[16:19:15.125]                 }
[16:19:15.125]             }
[16:19:15.125]         }))
[16:19:15.125]     }, error = function(ex) {
[16:19:15.125]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:15.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.125]                 ...future.rng), started = ...future.startTime, 
[16:19:15.125]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:15.125]             version = "1.8"), class = "FutureResult")
[16:19:15.125]     }, finally = {
[16:19:15.125]         if (!identical(...future.workdir, getwd())) 
[16:19:15.125]             setwd(...future.workdir)
[16:19:15.125]         {
[16:19:15.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:15.125]                 ...future.oldOptions$nwarnings <- NULL
[16:19:15.125]             }
[16:19:15.125]             base::options(...future.oldOptions)
[16:19:15.125]             if (.Platform$OS.type == "windows") {
[16:19:15.125]                 old_names <- names(...future.oldEnvVars)
[16:19:15.125]                 envs <- base::Sys.getenv()
[16:19:15.125]                 names <- names(envs)
[16:19:15.125]                 common <- intersect(names, old_names)
[16:19:15.125]                 added <- setdiff(names, old_names)
[16:19:15.125]                 removed <- setdiff(old_names, names)
[16:19:15.125]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:15.125]                   envs[common]]
[16:19:15.125]                 NAMES <- toupper(changed)
[16:19:15.125]                 args <- list()
[16:19:15.125]                 for (kk in seq_along(NAMES)) {
[16:19:15.125]                   name <- changed[[kk]]
[16:19:15.125]                   NAME <- NAMES[[kk]]
[16:19:15.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.125]                     next
[16:19:15.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.125]                 }
[16:19:15.125]                 NAMES <- toupper(added)
[16:19:15.125]                 for (kk in seq_along(NAMES)) {
[16:19:15.125]                   name <- added[[kk]]
[16:19:15.125]                   NAME <- NAMES[[kk]]
[16:19:15.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.125]                     next
[16:19:15.125]                   args[[name]] <- ""
[16:19:15.125]                 }
[16:19:15.125]                 NAMES <- toupper(removed)
[16:19:15.125]                 for (kk in seq_along(NAMES)) {
[16:19:15.125]                   name <- removed[[kk]]
[16:19:15.125]                   NAME <- NAMES[[kk]]
[16:19:15.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.125]                     next
[16:19:15.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.125]                 }
[16:19:15.125]                 if (length(args) > 0) 
[16:19:15.125]                   base::do.call(base::Sys.setenv, args = args)
[16:19:15.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:15.125]             }
[16:19:15.125]             else {
[16:19:15.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:15.125]             }
[16:19:15.125]             {
[16:19:15.125]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:15.125]                   0L) {
[16:19:15.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:15.125]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:15.125]                   base::options(opts)
[16:19:15.125]                 }
[16:19:15.125]                 {
[16:19:15.125]                   {
[16:19:15.125]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:15.125]                     NULL
[16:19:15.125]                   }
[16:19:15.125]                   options(future.plan = NULL)
[16:19:15.125]                   if (is.na(NA_character_)) 
[16:19:15.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:15.125]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:15.125]                     .init = FALSE)
[16:19:15.125]                 }
[16:19:15.125]             }
[16:19:15.125]         }
[16:19:15.125]     })
[16:19:15.125]     if (TRUE) {
[16:19:15.125]         base::sink(type = "output", split = FALSE)
[16:19:15.125]         if (TRUE) {
[16:19:15.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:15.125]         }
[16:19:15.125]         else {
[16:19:15.125]             ...future.result["stdout"] <- base::list(NULL)
[16:19:15.125]         }
[16:19:15.125]         base::close(...future.stdout)
[16:19:15.125]         ...future.stdout <- NULL
[16:19:15.125]     }
[16:19:15.125]     ...future.result$conditions <- ...future.conditions
[16:19:15.125]     ...future.result$finished <- base::Sys.time()
[16:19:15.125]     ...future.result
[16:19:15.125] }
[16:19:15.127] assign_globals() ...
[16:19:15.127] List of 11
[16:19:15.127]  $ ...future.FUN            :function (x, ...)  
[16:19:15.127]  $ x_FUN                    :function (x)  
[16:19:15.127]  $ times                    : int 1
[16:19:15.127]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.127]  $ stop_if_not              :function (...)  
[16:19:15.127]  $ dim                      : NULL
[16:19:15.127]  $ valid_types              : chr "logical"
[16:19:15.127]  $ future.call.arguments    : list()
[16:19:15.127]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.127]  $ ...future.elements_ii    :List of 6
[16:19:15.127]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[16:19:15.127]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[16:19:15.127]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[16:19:15.127]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[16:19:15.127]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[16:19:15.127]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[16:19:15.127]  $ ...future.seeds_ii       : NULL
[16:19:15.127]  $ ...future.globals.maxSize: NULL
[16:19:15.127]  - attr(*, "where")=List of 11
[16:19:15.127]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:15.127]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:15.127]  - attr(*, "resolved")= logi FALSE
[16:19:15.127]  - attr(*, "total_size")= num 94200
[16:19:15.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.127]  - attr(*, "already-done")= logi TRUE
[16:19:15.140] - copied ‘...future.FUN’ to environment
[16:19:15.141] - copied ‘x_FUN’ to environment
[16:19:15.141] - copied ‘times’ to environment
[16:19:15.141] - copied ‘stopf’ to environment
[16:19:15.141] - copied ‘stop_if_not’ to environment
[16:19:15.141] - copied ‘dim’ to environment
[16:19:15.141] - copied ‘valid_types’ to environment
[16:19:15.141] - copied ‘future.call.arguments’ to environment
[16:19:15.142] - copied ‘...future.elements_ii’ to environment
[16:19:15.142] - copied ‘...future.seeds_ii’ to environment
[16:19:15.142] - copied ‘...future.globals.maxSize’ to environment
[16:19:15.142] assign_globals() ... done
[16:19:15.142] requestCore(): workers = 2
[16:19:15.145] MulticoreFuture started
[16:19:15.145] - Launch lazy future ... done
[16:19:15.146] run() for ‘MulticoreFuture’ ... done
[16:19:15.147] Created future:
[16:19:15.147] plan(): Setting new future strategy stack:
[16:19:15.147] List of future strategies:
[16:19:15.147] 1. sequential:
[16:19:15.147]    - args: function (..., envir = parent.frame())
[16:19:15.147]    - tweaked: FALSE
[16:19:15.147]    - call: NULL
[16:19:15.148] plan(): nbrOfWorkers() = 1
[16:19:15.151] plan(): Setting new future strategy stack:
[16:19:15.151] List of future strategies:
[16:19:15.151] 1. multicore:
[16:19:15.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:15.151]    - tweaked: FALSE
[16:19:15.151]    - call: plan(strategy)
[16:19:15.157] plan(): nbrOfWorkers() = 2
[16:19:15.147] MulticoreFuture:
[16:19:15.147] Label: ‘future_vapply-1’
[16:19:15.147] Expression:
[16:19:15.147] {
[16:19:15.147]     do.call(function(...) {
[16:19:15.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.147]             on.exit(options(oopts), add = TRUE)
[16:19:15.147]         }
[16:19:15.147]         {
[16:19:15.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.147]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.147]             })
[16:19:15.147]         }
[16:19:15.147]     }, args = future.call.arguments)
[16:19:15.147] }
[16:19:15.147] Lazy evaluation: FALSE
[16:19:15.147] Asynchronous evaluation: TRUE
[16:19:15.147] Local evaluation: TRUE
[16:19:15.147] Environment: R_GlobalEnv
[16:19:15.147] Capture standard output: TRUE
[16:19:15.147] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:15.147] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:15.147] Packages: 1 packages (‘future.apply’)
[16:19:15.147] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:15.147] Resolved: TRUE
[16:19:15.147] Value: <not collected>
[16:19:15.147] Conditions captured: <none>
[16:19:15.147] Early signaling: FALSE
[16:19:15.147] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:15.147] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.158] Chunk #1 of 2 ... DONE
[16:19:15.158] Chunk #2 of 2 ...
[16:19:15.159]  - Finding globals in 'X' for chunk #2 ...
[16:19:15.159] getGlobalsAndPackages() ...
[16:19:15.159] Searching for globals...
[16:19:15.160] 
[16:19:15.160] Searching for globals ... DONE
[16:19:15.160] - globals: [0] <none>
[16:19:15.160] getGlobalsAndPackages() ... DONE
[16:19:15.160]    + additional globals found: [n=0] 
[16:19:15.160]    + additional namespaces needed: [n=0] 
[16:19:15.161]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:15.161]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:15.161]  - seeds: <none>
[16:19:15.161]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.161] getGlobalsAndPackages() ...
[16:19:15.161] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.162] Resolving globals: FALSE
[16:19:15.162] Tweak future expression to call with '...' arguments ...
[16:19:15.162] {
[16:19:15.162]     do.call(function(...) {
[16:19:15.162]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.162]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.162]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.162]             on.exit(options(oopts), add = TRUE)
[16:19:15.162]         }
[16:19:15.162]         {
[16:19:15.162]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.162]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.162]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.162]             })
[16:19:15.162]         }
[16:19:15.162]     }, args = future.call.arguments)
[16:19:15.162] }
[16:19:15.163] Tweak future expression to call with '...' arguments ... DONE
[16:19:15.164] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.164] - packages: [1] ‘future.apply’
[16:19:15.164] getGlobalsAndPackages() ... DONE
[16:19:15.165] run() for ‘Future’ ...
[16:19:15.165] - state: ‘created’
[16:19:15.165] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:15.169] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:15.170]   - Field: ‘label’
[16:19:15.170]   - Field: ‘local’
[16:19:15.170]   - Field: ‘owner’
[16:19:15.170]   - Field: ‘envir’
[16:19:15.171]   - Field: ‘workers’
[16:19:15.171]   - Field: ‘packages’
[16:19:15.171]   - Field: ‘gc’
[16:19:15.171]   - Field: ‘job’
[16:19:15.171]   - Field: ‘conditions’
[16:19:15.171]   - Field: ‘expr’
[16:19:15.171]   - Field: ‘uuid’
[16:19:15.172]   - Field: ‘seed’
[16:19:15.172]   - Field: ‘version’
[16:19:15.172]   - Field: ‘result’
[16:19:15.172]   - Field: ‘asynchronous’
[16:19:15.172]   - Field: ‘calls’
[16:19:15.172]   - Field: ‘globals’
[16:19:15.173]   - Field: ‘stdout’
[16:19:15.173]   - Field: ‘earlySignal’
[16:19:15.173]   - Field: ‘lazy’
[16:19:15.173]   - Field: ‘state’
[16:19:15.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:15.173] - Launch lazy future ...
[16:19:15.174] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:15.174] Packages needed by future strategies (n = 0): <none>
[16:19:15.175] {
[16:19:15.175]     {
[16:19:15.175]         {
[16:19:15.175]             ...future.startTime <- base::Sys.time()
[16:19:15.175]             {
[16:19:15.175]                 {
[16:19:15.175]                   {
[16:19:15.175]                     {
[16:19:15.175]                       {
[16:19:15.175]                         base::local({
[16:19:15.175]                           has_future <- base::requireNamespace("future", 
[16:19:15.175]                             quietly = TRUE)
[16:19:15.175]                           if (has_future) {
[16:19:15.175]                             ns <- base::getNamespace("future")
[16:19:15.175]                             version <- ns[[".package"]][["version"]]
[16:19:15.175]                             if (is.null(version)) 
[16:19:15.175]                               version <- utils::packageVersion("future")
[16:19:15.175]                           }
[16:19:15.175]                           else {
[16:19:15.175]                             version <- NULL
[16:19:15.175]                           }
[16:19:15.175]                           if (!has_future || version < "1.8.0") {
[16:19:15.175]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:15.175]                               "", base::R.version$version.string), 
[16:19:15.175]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:15.175]                                 base::R.version$platform, 8 * 
[16:19:15.175]                                   base::.Machine$sizeof.pointer), 
[16:19:15.175]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:15.175]                                 "release", "version")], collapse = " "), 
[16:19:15.175]                               hostname = base::Sys.info()[["nodename"]])
[16:19:15.175]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:15.175]                               info)
[16:19:15.175]                             info <- base::paste(info, collapse = "; ")
[16:19:15.175]                             if (!has_future) {
[16:19:15.175]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:15.175]                                 info)
[16:19:15.175]                             }
[16:19:15.175]                             else {
[16:19:15.175]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:15.175]                                 info, version)
[16:19:15.175]                             }
[16:19:15.175]                             base::stop(msg)
[16:19:15.175]                           }
[16:19:15.175]                         })
[16:19:15.175]                       }
[16:19:15.175]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:15.175]                       base::options(mc.cores = 1L)
[16:19:15.175]                     }
[16:19:15.175]                     base::local({
[16:19:15.175]                       for (pkg in "future.apply") {
[16:19:15.175]                         base::loadNamespace(pkg)
[16:19:15.175]                         base::library(pkg, character.only = TRUE)
[16:19:15.175]                       }
[16:19:15.175]                     })
[16:19:15.175]                   }
[16:19:15.175]                   ...future.strategy.old <- future::plan("list")
[16:19:15.175]                   options(future.plan = NULL)
[16:19:15.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:15.175]                 }
[16:19:15.175]                 ...future.workdir <- getwd()
[16:19:15.175]             }
[16:19:15.175]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:15.175]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:15.175]         }
[16:19:15.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:15.175]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:15.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:15.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:15.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:15.175]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:15.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:15.175]             base::names(...future.oldOptions))
[16:19:15.175]     }
[16:19:15.175]     if (FALSE) {
[16:19:15.175]     }
[16:19:15.175]     else {
[16:19:15.175]         if (TRUE) {
[16:19:15.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:15.175]                 open = "w")
[16:19:15.175]         }
[16:19:15.175]         else {
[16:19:15.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:15.175]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:15.175]         }
[16:19:15.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:15.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:15.175]             base::sink(type = "output", split = FALSE)
[16:19:15.175]             base::close(...future.stdout)
[16:19:15.175]         }, add = TRUE)
[16:19:15.175]     }
[16:19:15.175]     ...future.frame <- base::sys.nframe()
[16:19:15.175]     ...future.conditions <- base::list()
[16:19:15.175]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:15.175]     if (FALSE) {
[16:19:15.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:15.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:15.175]     }
[16:19:15.175]     ...future.result <- base::tryCatch({
[16:19:15.175]         base::withCallingHandlers({
[16:19:15.175]             ...future.value <- base::withVisible(base::local({
[16:19:15.175]                 withCallingHandlers({
[16:19:15.175]                   {
[16:19:15.175]                     do.call(function(...) {
[16:19:15.175]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.175]                       if (!identical(...future.globals.maxSize.org, 
[16:19:15.175]                         ...future.globals.maxSize)) {
[16:19:15.175]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.175]                         on.exit(options(oopts), add = TRUE)
[16:19:15.175]                       }
[16:19:15.175]                       {
[16:19:15.175]                         lapply(seq_along(...future.elements_ii), 
[16:19:15.175]                           FUN = function(jj) {
[16:19:15.175]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.175]                             ...future.FUN(...future.X_jj, ...)
[16:19:15.175]                           })
[16:19:15.175]                       }
[16:19:15.175]                     }, args = future.call.arguments)
[16:19:15.175]                   }
[16:19:15.175]                 }, immediateCondition = function(cond) {
[16:19:15.175]                   save_rds <- function (object, pathname, ...) 
[16:19:15.175]                   {
[16:19:15.175]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:15.175]                     if (file_test("-f", pathname_tmp)) {
[16:19:15.175]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.175]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:15.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.175]                         fi_tmp[["mtime"]])
[16:19:15.175]                     }
[16:19:15.175]                     tryCatch({
[16:19:15.175]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:15.175]                     }, error = function(ex) {
[16:19:15.175]                       msg <- conditionMessage(ex)
[16:19:15.175]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.175]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:15.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.175]                         fi_tmp[["mtime"]], msg)
[16:19:15.175]                       ex$message <- msg
[16:19:15.175]                       stop(ex)
[16:19:15.175]                     })
[16:19:15.175]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:15.175]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:15.175]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:15.175]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.175]                       fi <- file.info(pathname)
[16:19:15.175]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:15.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.175]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:15.175]                         fi[["size"]], fi[["mtime"]])
[16:19:15.175]                       stop(msg)
[16:19:15.175]                     }
[16:19:15.175]                     invisible(pathname)
[16:19:15.175]                   }
[16:19:15.175]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:15.175]                     rootPath = tempdir()) 
[16:19:15.175]                   {
[16:19:15.175]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:15.175]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:15.175]                       tmpdir = path, fileext = ".rds")
[16:19:15.175]                     save_rds(obj, file)
[16:19:15.175]                   }
[16:19:15.175]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:15.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.175]                   {
[16:19:15.175]                     inherits <- base::inherits
[16:19:15.175]                     invokeRestart <- base::invokeRestart
[16:19:15.175]                     is.null <- base::is.null
[16:19:15.175]                     muffled <- FALSE
[16:19:15.175]                     if (inherits(cond, "message")) {
[16:19:15.175]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:15.175]                       if (muffled) 
[16:19:15.175]                         invokeRestart("muffleMessage")
[16:19:15.175]                     }
[16:19:15.175]                     else if (inherits(cond, "warning")) {
[16:19:15.175]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:15.175]                       if (muffled) 
[16:19:15.175]                         invokeRestart("muffleWarning")
[16:19:15.175]                     }
[16:19:15.175]                     else if (inherits(cond, "condition")) {
[16:19:15.175]                       if (!is.null(pattern)) {
[16:19:15.175]                         computeRestarts <- base::computeRestarts
[16:19:15.175]                         grepl <- base::grepl
[16:19:15.175]                         restarts <- computeRestarts(cond)
[16:19:15.175]                         for (restart in restarts) {
[16:19:15.175]                           name <- restart$name
[16:19:15.175]                           if (is.null(name)) 
[16:19:15.175]                             next
[16:19:15.175]                           if (!grepl(pattern, name)) 
[16:19:15.175]                             next
[16:19:15.175]                           invokeRestart(restart)
[16:19:15.175]                           muffled <- TRUE
[16:19:15.175]                           break
[16:19:15.175]                         }
[16:19:15.175]                       }
[16:19:15.175]                     }
[16:19:15.175]                     invisible(muffled)
[16:19:15.175]                   }
[16:19:15.175]                   muffleCondition(cond)
[16:19:15.175]                 })
[16:19:15.175]             }))
[16:19:15.175]             future::FutureResult(value = ...future.value$value, 
[16:19:15.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.175]                   ...future.rng), globalenv = if (FALSE) 
[16:19:15.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:15.175]                     ...future.globalenv.names))
[16:19:15.175]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:15.175]         }, condition = base::local({
[16:19:15.175]             c <- base::c
[16:19:15.175]             inherits <- base::inherits
[16:19:15.175]             invokeRestart <- base::invokeRestart
[16:19:15.175]             length <- base::length
[16:19:15.175]             list <- base::list
[16:19:15.175]             seq.int <- base::seq.int
[16:19:15.175]             signalCondition <- base::signalCondition
[16:19:15.175]             sys.calls <- base::sys.calls
[16:19:15.175]             `[[` <- base::`[[`
[16:19:15.175]             `+` <- base::`+`
[16:19:15.175]             `<<-` <- base::`<<-`
[16:19:15.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:15.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:15.175]                   3L)]
[16:19:15.175]             }
[16:19:15.175]             function(cond) {
[16:19:15.175]                 is_error <- inherits(cond, "error")
[16:19:15.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:15.175]                   NULL)
[16:19:15.175]                 if (is_error) {
[16:19:15.175]                   sessionInformation <- function() {
[16:19:15.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:15.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:15.175]                       search = base::search(), system = base::Sys.info())
[16:19:15.175]                   }
[16:19:15.175]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:15.175]                     cond$call), session = sessionInformation(), 
[16:19:15.175]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:15.175]                   signalCondition(cond)
[16:19:15.175]                 }
[16:19:15.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:15.175]                 "immediateCondition"))) {
[16:19:15.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:15.175]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:15.175]                   if (TRUE && !signal) {
[16:19:15.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.175]                     {
[16:19:15.175]                       inherits <- base::inherits
[16:19:15.175]                       invokeRestart <- base::invokeRestart
[16:19:15.175]                       is.null <- base::is.null
[16:19:15.175]                       muffled <- FALSE
[16:19:15.175]                       if (inherits(cond, "message")) {
[16:19:15.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.175]                         if (muffled) 
[16:19:15.175]                           invokeRestart("muffleMessage")
[16:19:15.175]                       }
[16:19:15.175]                       else if (inherits(cond, "warning")) {
[16:19:15.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.175]                         if (muffled) 
[16:19:15.175]                           invokeRestart("muffleWarning")
[16:19:15.175]                       }
[16:19:15.175]                       else if (inherits(cond, "condition")) {
[16:19:15.175]                         if (!is.null(pattern)) {
[16:19:15.175]                           computeRestarts <- base::computeRestarts
[16:19:15.175]                           grepl <- base::grepl
[16:19:15.175]                           restarts <- computeRestarts(cond)
[16:19:15.175]                           for (restart in restarts) {
[16:19:15.175]                             name <- restart$name
[16:19:15.175]                             if (is.null(name)) 
[16:19:15.175]                               next
[16:19:15.175]                             if (!grepl(pattern, name)) 
[16:19:15.175]                               next
[16:19:15.175]                             invokeRestart(restart)
[16:19:15.175]                             muffled <- TRUE
[16:19:15.175]                             break
[16:19:15.175]                           }
[16:19:15.175]                         }
[16:19:15.175]                       }
[16:19:15.175]                       invisible(muffled)
[16:19:15.175]                     }
[16:19:15.175]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.175]                   }
[16:19:15.175]                 }
[16:19:15.175]                 else {
[16:19:15.175]                   if (TRUE) {
[16:19:15.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.175]                     {
[16:19:15.175]                       inherits <- base::inherits
[16:19:15.175]                       invokeRestart <- base::invokeRestart
[16:19:15.175]                       is.null <- base::is.null
[16:19:15.175]                       muffled <- FALSE
[16:19:15.175]                       if (inherits(cond, "message")) {
[16:19:15.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.175]                         if (muffled) 
[16:19:15.175]                           invokeRestart("muffleMessage")
[16:19:15.175]                       }
[16:19:15.175]                       else if (inherits(cond, "warning")) {
[16:19:15.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.175]                         if (muffled) 
[16:19:15.175]                           invokeRestart("muffleWarning")
[16:19:15.175]                       }
[16:19:15.175]                       else if (inherits(cond, "condition")) {
[16:19:15.175]                         if (!is.null(pattern)) {
[16:19:15.175]                           computeRestarts <- base::computeRestarts
[16:19:15.175]                           grepl <- base::grepl
[16:19:15.175]                           restarts <- computeRestarts(cond)
[16:19:15.175]                           for (restart in restarts) {
[16:19:15.175]                             name <- restart$name
[16:19:15.175]                             if (is.null(name)) 
[16:19:15.175]                               next
[16:19:15.175]                             if (!grepl(pattern, name)) 
[16:19:15.175]                               next
[16:19:15.175]                             invokeRestart(restart)
[16:19:15.175]                             muffled <- TRUE
[16:19:15.175]                             break
[16:19:15.175]                           }
[16:19:15.175]                         }
[16:19:15.175]                       }
[16:19:15.175]                       invisible(muffled)
[16:19:15.175]                     }
[16:19:15.175]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.175]                   }
[16:19:15.175]                 }
[16:19:15.175]             }
[16:19:15.175]         }))
[16:19:15.175]     }, error = function(ex) {
[16:19:15.175]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:15.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.175]                 ...future.rng), started = ...future.startTime, 
[16:19:15.175]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:15.175]             version = "1.8"), class = "FutureResult")
[16:19:15.175]     }, finally = {
[16:19:15.175]         if (!identical(...future.workdir, getwd())) 
[16:19:15.175]             setwd(...future.workdir)
[16:19:15.175]         {
[16:19:15.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:15.175]                 ...future.oldOptions$nwarnings <- NULL
[16:19:15.175]             }
[16:19:15.175]             base::options(...future.oldOptions)
[16:19:15.175]             if (.Platform$OS.type == "windows") {
[16:19:15.175]                 old_names <- names(...future.oldEnvVars)
[16:19:15.175]                 envs <- base::Sys.getenv()
[16:19:15.175]                 names <- names(envs)
[16:19:15.175]                 common <- intersect(names, old_names)
[16:19:15.175]                 added <- setdiff(names, old_names)
[16:19:15.175]                 removed <- setdiff(old_names, names)
[16:19:15.175]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:15.175]                   envs[common]]
[16:19:15.175]                 NAMES <- toupper(changed)
[16:19:15.175]                 args <- list()
[16:19:15.175]                 for (kk in seq_along(NAMES)) {
[16:19:15.175]                   name <- changed[[kk]]
[16:19:15.175]                   NAME <- NAMES[[kk]]
[16:19:15.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.175]                     next
[16:19:15.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.175]                 }
[16:19:15.175]                 NAMES <- toupper(added)
[16:19:15.175]                 for (kk in seq_along(NAMES)) {
[16:19:15.175]                   name <- added[[kk]]
[16:19:15.175]                   NAME <- NAMES[[kk]]
[16:19:15.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.175]                     next
[16:19:15.175]                   args[[name]] <- ""
[16:19:15.175]                 }
[16:19:15.175]                 NAMES <- toupper(removed)
[16:19:15.175]                 for (kk in seq_along(NAMES)) {
[16:19:15.175]                   name <- removed[[kk]]
[16:19:15.175]                   NAME <- NAMES[[kk]]
[16:19:15.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.175]                     next
[16:19:15.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.175]                 }
[16:19:15.175]                 if (length(args) > 0) 
[16:19:15.175]                   base::do.call(base::Sys.setenv, args = args)
[16:19:15.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:15.175]             }
[16:19:15.175]             else {
[16:19:15.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:15.175]             }
[16:19:15.175]             {
[16:19:15.175]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:15.175]                   0L) {
[16:19:15.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:15.175]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:15.175]                   base::options(opts)
[16:19:15.175]                 }
[16:19:15.175]                 {
[16:19:15.175]                   {
[16:19:15.175]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:15.175]                     NULL
[16:19:15.175]                   }
[16:19:15.175]                   options(future.plan = NULL)
[16:19:15.175]                   if (is.na(NA_character_)) 
[16:19:15.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:15.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:15.175]                     .init = FALSE)
[16:19:15.175]                 }
[16:19:15.175]             }
[16:19:15.175]         }
[16:19:15.175]     })
[16:19:15.175]     if (TRUE) {
[16:19:15.175]         base::sink(type = "output", split = FALSE)
[16:19:15.175]         if (TRUE) {
[16:19:15.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:15.175]         }
[16:19:15.175]         else {
[16:19:15.175]             ...future.result["stdout"] <- base::list(NULL)
[16:19:15.175]         }
[16:19:15.175]         base::close(...future.stdout)
[16:19:15.175]         ...future.stdout <- NULL
[16:19:15.175]     }
[16:19:15.175]     ...future.result$conditions <- ...future.conditions
[16:19:15.175]     ...future.result$finished <- base::Sys.time()
[16:19:15.175]     ...future.result
[16:19:15.175] }
[16:19:15.178] assign_globals() ...
[16:19:15.178] List of 11
[16:19:15.178]  $ ...future.FUN            :function (x, ...)  
[16:19:15.178]  $ x_FUN                    :function (x)  
[16:19:15.178]  $ times                    : int 1
[16:19:15.178]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.178]  $ stop_if_not              :function (...)  
[16:19:15.178]  $ dim                      : NULL
[16:19:15.178]  $ valid_types              : chr "logical"
[16:19:15.178]  $ future.call.arguments    : list()
[16:19:15.178]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.178]  $ ...future.elements_ii    :List of 5
[16:19:15.178]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[16:19:15.178]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[16:19:15.178]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[16:19:15.178]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[16:19:15.178]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[16:19:15.178]  $ ...future.seeds_ii       : NULL
[16:19:15.178]  $ ...future.globals.maxSize: NULL
[16:19:15.178]  - attr(*, "where")=List of 11
[16:19:15.178]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:15.178]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:15.178]  - attr(*, "resolved")= logi FALSE
[16:19:15.178]  - attr(*, "total_size")= num 94200
[16:19:15.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.178]  - attr(*, "already-done")= logi TRUE
[16:19:15.195] - copied ‘...future.FUN’ to environment
[16:19:15.195] - copied ‘x_FUN’ to environment
[16:19:15.195] - copied ‘times’ to environment
[16:19:15.196] - copied ‘stopf’ to environment
[16:19:15.196] - copied ‘stop_if_not’ to environment
[16:19:15.196] - copied ‘dim’ to environment
[16:19:15.196] - copied ‘valid_types’ to environment
[16:19:15.196] - copied ‘future.call.arguments’ to environment
[16:19:15.196] - copied ‘...future.elements_ii’ to environment
[16:19:15.196] - copied ‘...future.seeds_ii’ to environment
[16:19:15.196] - copied ‘...future.globals.maxSize’ to environment
[16:19:15.196] assign_globals() ... done
[16:19:15.197] requestCore(): workers = 2
[16:19:15.199] MulticoreFuture started
[16:19:15.199] - Launch lazy future ... done
[16:19:15.200] run() for ‘MulticoreFuture’ ... done
[16:19:15.200] Created future:
[16:19:15.201] plan(): Setting new future strategy stack:
[16:19:15.201] List of future strategies:
[16:19:15.201] 1. sequential:
[16:19:15.201]    - args: function (..., envir = parent.frame())
[16:19:15.201]    - tweaked: FALSE
[16:19:15.201]    - call: NULL
[16:19:15.202] plan(): nbrOfWorkers() = 1
[16:19:15.204] plan(): Setting new future strategy stack:
[16:19:15.204] List of future strategies:
[16:19:15.204] 1. multicore:
[16:19:15.204]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:15.204]    - tweaked: FALSE
[16:19:15.204]    - call: plan(strategy)
[16:19:15.210] plan(): nbrOfWorkers() = 2
[16:19:15.200] MulticoreFuture:
[16:19:15.200] Label: ‘future_vapply-2’
[16:19:15.200] Expression:
[16:19:15.200] {
[16:19:15.200]     do.call(function(...) {
[16:19:15.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.200]             on.exit(options(oopts), add = TRUE)
[16:19:15.200]         }
[16:19:15.200]         {
[16:19:15.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.200]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.200]             })
[16:19:15.200]         }
[16:19:15.200]     }, args = future.call.arguments)
[16:19:15.200] }
[16:19:15.200] Lazy evaluation: FALSE
[16:19:15.200] Asynchronous evaluation: TRUE
[16:19:15.200] Local evaluation: TRUE
[16:19:15.200] Environment: R_GlobalEnv
[16:19:15.200] Capture standard output: TRUE
[16:19:15.200] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:15.200] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:15.200] Packages: 1 packages (‘future.apply’)
[16:19:15.200] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:15.200] Resolved: TRUE
[16:19:15.200] Value: <not collected>
[16:19:15.200] Conditions captured: <none>
[16:19:15.200] Early signaling: FALSE
[16:19:15.200] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:15.200] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.211] Chunk #2 of 2 ... DONE
[16:19:15.211] Launching 2 futures (chunks) ... DONE
[16:19:15.211] Resolving 2 futures (chunks) ...
[16:19:15.211] resolve() on list ...
[16:19:15.212]  recursive: 0
[16:19:15.212]  length: 2
[16:19:15.212] 
[16:19:15.212] Future #1
[16:19:15.212] result() for MulticoreFuture ...
[16:19:15.213] result() for MulticoreFuture ...
[16:19:15.213] result() for MulticoreFuture ... done
[16:19:15.214] result() for MulticoreFuture ... done
[16:19:15.214] result() for MulticoreFuture ...
[16:19:15.214] result() for MulticoreFuture ... done
[16:19:15.214] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:15.214] - nx: 2
[16:19:15.214] - relay: TRUE
[16:19:15.215] - stdout: TRUE
[16:19:15.215] - signal: TRUE
[16:19:15.215] - resignal: FALSE
[16:19:15.215] - force: TRUE
[16:19:15.215] - relayed: [n=2] FALSE, FALSE
[16:19:15.215] - queued futures: [n=2] FALSE, FALSE
[16:19:15.215]  - until=1
[16:19:15.216]  - relaying element #1
[16:19:15.216] result() for MulticoreFuture ...
[16:19:15.216] result() for MulticoreFuture ... done
[16:19:15.216] result() for MulticoreFuture ...
[16:19:15.216] result() for MulticoreFuture ... done
[16:19:15.216] result() for MulticoreFuture ...
[16:19:15.217] result() for MulticoreFuture ... done
[16:19:15.217] result() for MulticoreFuture ...
[16:19:15.217] result() for MulticoreFuture ... done
[16:19:15.217] - relayed: [n=2] TRUE, FALSE
[16:19:15.217] - queued futures: [n=2] TRUE, FALSE
[16:19:15.217] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:15.218]  length: 1 (resolved future 1)
[16:19:15.218] Future #2
[16:19:15.218] result() for MulticoreFuture ...
[16:19:15.219] result() for MulticoreFuture ...
[16:19:15.219] result() for MulticoreFuture ... done
[16:19:15.219] result() for MulticoreFuture ... done
[16:19:15.219] result() for MulticoreFuture ...
[16:19:15.219] result() for MulticoreFuture ... done
[16:19:15.220] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:15.220] - nx: 2
[16:19:15.220] - relay: TRUE
[16:19:15.220] - stdout: TRUE
[16:19:15.220] - signal: TRUE
[16:19:15.220] - resignal: FALSE
[16:19:15.220] - force: TRUE
[16:19:15.220] - relayed: [n=2] TRUE, FALSE
[16:19:15.221] - queued futures: [n=2] TRUE, FALSE
[16:19:15.225]  - until=2
[16:19:15.225]  - relaying element #2
[16:19:15.226] result() for MulticoreFuture ...
[16:19:15.226] result() for MulticoreFuture ... done
[16:19:15.226] result() for MulticoreFuture ...
[16:19:15.226] result() for MulticoreFuture ... done
[16:19:15.226] result() for MulticoreFuture ...
[16:19:15.226] result() for MulticoreFuture ... done
[16:19:15.226] result() for MulticoreFuture ...
[16:19:15.226] result() for MulticoreFuture ... done
[16:19:15.226] - relayed: [n=2] TRUE, TRUE
[16:19:15.227] - queued futures: [n=2] TRUE, TRUE
[16:19:15.227] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:15.227]  length: 0 (resolved future 2)
[16:19:15.227] Relaying remaining futures
[16:19:15.227] signalConditionsASAP(NULL, pos=0) ...
[16:19:15.227] - nx: 2
[16:19:15.227] - relay: TRUE
[16:19:15.228] - stdout: TRUE
[16:19:15.228] - signal: TRUE
[16:19:15.228] - resignal: FALSE
[16:19:15.228] - force: TRUE
[16:19:15.228] - relayed: [n=2] TRUE, TRUE
[16:19:15.228] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:15.229] - relayed: [n=2] TRUE, TRUE
[16:19:15.229] - queued futures: [n=2] TRUE, TRUE
[16:19:15.229] signalConditionsASAP(NULL, pos=0) ... done
[16:19:15.229] resolve() on list ... DONE
[16:19:15.229] result() for MulticoreFuture ...
[16:19:15.229] result() for MulticoreFuture ... done
[16:19:15.229] result() for MulticoreFuture ...
[16:19:15.230] result() for MulticoreFuture ... done
[16:19:15.230] result() for MulticoreFuture ...
[16:19:15.230] result() for MulticoreFuture ... done
[16:19:15.230] result() for MulticoreFuture ...
[16:19:15.230] result() for MulticoreFuture ... done
[16:19:15.230]  - Number of value chunks collected: 2
[16:19:15.231] Resolving 2 futures (chunks) ... DONE
[16:19:15.231] Reducing values from 2 chunks ...
[16:19:15.231]  - Number of values collected after concatenation: 11
[16:19:15.231]  - Number of values expected: 11
[16:19:15.231] Reducing values from 2 chunks ... DONE
[16:19:15.231] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:19:15.233] future_lapply() ...
[16:19:15.240] Number of chunks: 2
[16:19:15.240] getGlobalsAndPackagesXApply() ...
[16:19:15.240]  - future.globals: TRUE
[16:19:15.240] getGlobalsAndPackages() ...
[16:19:15.240] Searching for globals...
[16:19:15.244] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:15.244] Searching for globals ... DONE
[16:19:15.244] Resolving globals: FALSE
[16:19:15.245] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:19:15.245] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:15.246] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:15.246] - packages: [1] ‘future.apply’
[16:19:15.246] getGlobalsAndPackages() ... DONE
[16:19:15.246]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:15.246]  - needed namespaces: [n=1] ‘future.apply’
[16:19:15.246] Finding globals ... DONE
[16:19:15.246]  - use_args: TRUE
[16:19:15.246]  - Getting '...' globals ...
[16:19:15.247] resolve() on list ...
[16:19:15.247]  recursive: 0
[16:19:15.247]  length: 1
[16:19:15.247]  elements: ‘...’
[16:19:15.247]  length: 0 (resolved future 1)
[16:19:15.247] resolve() on list ... DONE
[16:19:15.247]    - '...' content: [n=0] 
[16:19:15.247] List of 1
[16:19:15.247]  $ ...: list()
[16:19:15.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.247]  - attr(*, "where")=List of 1
[16:19:15.247]   ..$ ...:<environment: 0x56199f6bdb38> 
[16:19:15.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.247]  - attr(*, "resolved")= logi TRUE
[16:19:15.247]  - attr(*, "total_size")= num NA
[16:19:15.252]  - Getting '...' globals ... DONE
[16:19:15.252] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:15.253] List of 8
[16:19:15.253]  $ ...future.FUN:function (x, ...)  
[16:19:15.253]  $ x_FUN        :function (x)  
[16:19:15.253]  $ times        : int 1
[16:19:15.253]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.253]  $ stop_if_not  :function (...)  
[16:19:15.253]  $ dim          : NULL
[16:19:15.253]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:15.253]  $ ...          : list()
[16:19:15.253]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.253]  - attr(*, "where")=List of 8
[16:19:15.253]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:15.253]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:15.253]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:15.253]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:15.253]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:15.253]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:15.253]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:15.253]   ..$ ...          :<environment: 0x56199f6bdb38> 
[16:19:15.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.253]  - attr(*, "resolved")= logi FALSE
[16:19:15.253]  - attr(*, "total_size")= num 94264
[16:19:15.259] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:15.259] getGlobalsAndPackagesXApply() ... DONE
[16:19:15.260] Number of futures (= number of chunks): 2
[16:19:15.260] Launching 2 futures (chunks) ...
[16:19:15.260] Chunk #1 of 2 ...
[16:19:15.260]  - Finding globals in 'X' for chunk #1 ...
[16:19:15.260] getGlobalsAndPackages() ...
[16:19:15.260] Searching for globals...
[16:19:15.261] 
[16:19:15.261] Searching for globals ... DONE
[16:19:15.261] - globals: [0] <none>
[16:19:15.261] getGlobalsAndPackages() ... DONE
[16:19:15.261]    + additional globals found: [n=0] 
[16:19:15.261]    + additional namespaces needed: [n=0] 
[16:19:15.261]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:15.261]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:15.261]  - seeds: <none>
[16:19:15.261]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.262] getGlobalsAndPackages() ...
[16:19:15.262] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.262] Resolving globals: FALSE
[16:19:15.262] Tweak future expression to call with '...' arguments ...
[16:19:15.262] {
[16:19:15.262]     do.call(function(...) {
[16:19:15.262]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.262]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.262]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.262]             on.exit(options(oopts), add = TRUE)
[16:19:15.262]         }
[16:19:15.262]         {
[16:19:15.262]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.262]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.262]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.262]             })
[16:19:15.262]         }
[16:19:15.262]     }, args = future.call.arguments)
[16:19:15.262] }
[16:19:15.262] Tweak future expression to call with '...' arguments ... DONE
[16:19:15.263] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.263] - packages: [1] ‘future.apply’
[16:19:15.263] getGlobalsAndPackages() ... DONE
[16:19:15.263] run() for ‘Future’ ...
[16:19:15.263] - state: ‘created’
[16:19:15.264] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:15.268] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:15.268]   - Field: ‘label’
[16:19:15.268]   - Field: ‘local’
[16:19:15.268]   - Field: ‘owner’
[16:19:15.268]   - Field: ‘envir’
[16:19:15.268]   - Field: ‘workers’
[16:19:15.268]   - Field: ‘packages’
[16:19:15.269]   - Field: ‘gc’
[16:19:15.269]   - Field: ‘job’
[16:19:15.269]   - Field: ‘conditions’
[16:19:15.269]   - Field: ‘expr’
[16:19:15.269]   - Field: ‘uuid’
[16:19:15.269]   - Field: ‘seed’
[16:19:15.269]   - Field: ‘version’
[16:19:15.269]   - Field: ‘result’
[16:19:15.269]   - Field: ‘asynchronous’
[16:19:15.269]   - Field: ‘calls’
[16:19:15.270]   - Field: ‘globals’
[16:19:15.270]   - Field: ‘stdout’
[16:19:15.270]   - Field: ‘earlySignal’
[16:19:15.270]   - Field: ‘lazy’
[16:19:15.270]   - Field: ‘state’
[16:19:15.270] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:15.270] - Launch lazy future ...
[16:19:15.270] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:15.271] Packages needed by future strategies (n = 0): <none>
[16:19:15.271] {
[16:19:15.271]     {
[16:19:15.271]         {
[16:19:15.271]             ...future.startTime <- base::Sys.time()
[16:19:15.271]             {
[16:19:15.271]                 {
[16:19:15.271]                   {
[16:19:15.271]                     {
[16:19:15.271]                       {
[16:19:15.271]                         base::local({
[16:19:15.271]                           has_future <- base::requireNamespace("future", 
[16:19:15.271]                             quietly = TRUE)
[16:19:15.271]                           if (has_future) {
[16:19:15.271]                             ns <- base::getNamespace("future")
[16:19:15.271]                             version <- ns[[".package"]][["version"]]
[16:19:15.271]                             if (is.null(version)) 
[16:19:15.271]                               version <- utils::packageVersion("future")
[16:19:15.271]                           }
[16:19:15.271]                           else {
[16:19:15.271]                             version <- NULL
[16:19:15.271]                           }
[16:19:15.271]                           if (!has_future || version < "1.8.0") {
[16:19:15.271]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:15.271]                               "", base::R.version$version.string), 
[16:19:15.271]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:15.271]                                 base::R.version$platform, 8 * 
[16:19:15.271]                                   base::.Machine$sizeof.pointer), 
[16:19:15.271]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:15.271]                                 "release", "version")], collapse = " "), 
[16:19:15.271]                               hostname = base::Sys.info()[["nodename"]])
[16:19:15.271]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:15.271]                               info)
[16:19:15.271]                             info <- base::paste(info, collapse = "; ")
[16:19:15.271]                             if (!has_future) {
[16:19:15.271]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:15.271]                                 info)
[16:19:15.271]                             }
[16:19:15.271]                             else {
[16:19:15.271]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:15.271]                                 info, version)
[16:19:15.271]                             }
[16:19:15.271]                             base::stop(msg)
[16:19:15.271]                           }
[16:19:15.271]                         })
[16:19:15.271]                       }
[16:19:15.271]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:15.271]                       base::options(mc.cores = 1L)
[16:19:15.271]                     }
[16:19:15.271]                     base::local({
[16:19:15.271]                       for (pkg in "future.apply") {
[16:19:15.271]                         base::loadNamespace(pkg)
[16:19:15.271]                         base::library(pkg, character.only = TRUE)
[16:19:15.271]                       }
[16:19:15.271]                     })
[16:19:15.271]                   }
[16:19:15.271]                   ...future.strategy.old <- future::plan("list")
[16:19:15.271]                   options(future.plan = NULL)
[16:19:15.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:15.271]                 }
[16:19:15.271]                 ...future.workdir <- getwd()
[16:19:15.271]             }
[16:19:15.271]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:15.271]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:15.271]         }
[16:19:15.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:15.271]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:15.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:15.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:15.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:15.271]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:15.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:15.271]             base::names(...future.oldOptions))
[16:19:15.271]     }
[16:19:15.271]     if (FALSE) {
[16:19:15.271]     }
[16:19:15.271]     else {
[16:19:15.271]         if (TRUE) {
[16:19:15.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:15.271]                 open = "w")
[16:19:15.271]         }
[16:19:15.271]         else {
[16:19:15.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:15.271]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:15.271]         }
[16:19:15.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:15.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:15.271]             base::sink(type = "output", split = FALSE)
[16:19:15.271]             base::close(...future.stdout)
[16:19:15.271]         }, add = TRUE)
[16:19:15.271]     }
[16:19:15.271]     ...future.frame <- base::sys.nframe()
[16:19:15.271]     ...future.conditions <- base::list()
[16:19:15.271]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:15.271]     if (FALSE) {
[16:19:15.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:15.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:15.271]     }
[16:19:15.271]     ...future.result <- base::tryCatch({
[16:19:15.271]         base::withCallingHandlers({
[16:19:15.271]             ...future.value <- base::withVisible(base::local({
[16:19:15.271]                 withCallingHandlers({
[16:19:15.271]                   {
[16:19:15.271]                     do.call(function(...) {
[16:19:15.271]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.271]                       if (!identical(...future.globals.maxSize.org, 
[16:19:15.271]                         ...future.globals.maxSize)) {
[16:19:15.271]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.271]                         on.exit(options(oopts), add = TRUE)
[16:19:15.271]                       }
[16:19:15.271]                       {
[16:19:15.271]                         lapply(seq_along(...future.elements_ii), 
[16:19:15.271]                           FUN = function(jj) {
[16:19:15.271]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.271]                             ...future.FUN(...future.X_jj, ...)
[16:19:15.271]                           })
[16:19:15.271]                       }
[16:19:15.271]                     }, args = future.call.arguments)
[16:19:15.271]                   }
[16:19:15.271]                 }, immediateCondition = function(cond) {
[16:19:15.271]                   save_rds <- function (object, pathname, ...) 
[16:19:15.271]                   {
[16:19:15.271]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:15.271]                     if (file_test("-f", pathname_tmp)) {
[16:19:15.271]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.271]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:15.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.271]                         fi_tmp[["mtime"]])
[16:19:15.271]                     }
[16:19:15.271]                     tryCatch({
[16:19:15.271]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:15.271]                     }, error = function(ex) {
[16:19:15.271]                       msg <- conditionMessage(ex)
[16:19:15.271]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.271]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:15.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.271]                         fi_tmp[["mtime"]], msg)
[16:19:15.271]                       ex$message <- msg
[16:19:15.271]                       stop(ex)
[16:19:15.271]                     })
[16:19:15.271]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:15.271]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:15.271]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:15.271]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.271]                       fi <- file.info(pathname)
[16:19:15.271]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:15.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.271]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:15.271]                         fi[["size"]], fi[["mtime"]])
[16:19:15.271]                       stop(msg)
[16:19:15.271]                     }
[16:19:15.271]                     invisible(pathname)
[16:19:15.271]                   }
[16:19:15.271]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:15.271]                     rootPath = tempdir()) 
[16:19:15.271]                   {
[16:19:15.271]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:15.271]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:15.271]                       tmpdir = path, fileext = ".rds")
[16:19:15.271]                     save_rds(obj, file)
[16:19:15.271]                   }
[16:19:15.271]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:15.271]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.271]                   {
[16:19:15.271]                     inherits <- base::inherits
[16:19:15.271]                     invokeRestart <- base::invokeRestart
[16:19:15.271]                     is.null <- base::is.null
[16:19:15.271]                     muffled <- FALSE
[16:19:15.271]                     if (inherits(cond, "message")) {
[16:19:15.271]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:15.271]                       if (muffled) 
[16:19:15.271]                         invokeRestart("muffleMessage")
[16:19:15.271]                     }
[16:19:15.271]                     else if (inherits(cond, "warning")) {
[16:19:15.271]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:15.271]                       if (muffled) 
[16:19:15.271]                         invokeRestart("muffleWarning")
[16:19:15.271]                     }
[16:19:15.271]                     else if (inherits(cond, "condition")) {
[16:19:15.271]                       if (!is.null(pattern)) {
[16:19:15.271]                         computeRestarts <- base::computeRestarts
[16:19:15.271]                         grepl <- base::grepl
[16:19:15.271]                         restarts <- computeRestarts(cond)
[16:19:15.271]                         for (restart in restarts) {
[16:19:15.271]                           name <- restart$name
[16:19:15.271]                           if (is.null(name)) 
[16:19:15.271]                             next
[16:19:15.271]                           if (!grepl(pattern, name)) 
[16:19:15.271]                             next
[16:19:15.271]                           invokeRestart(restart)
[16:19:15.271]                           muffled <- TRUE
[16:19:15.271]                           break
[16:19:15.271]                         }
[16:19:15.271]                       }
[16:19:15.271]                     }
[16:19:15.271]                     invisible(muffled)
[16:19:15.271]                   }
[16:19:15.271]                   muffleCondition(cond)
[16:19:15.271]                 })
[16:19:15.271]             }))
[16:19:15.271]             future::FutureResult(value = ...future.value$value, 
[16:19:15.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.271]                   ...future.rng), globalenv = if (FALSE) 
[16:19:15.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:15.271]                     ...future.globalenv.names))
[16:19:15.271]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:15.271]         }, condition = base::local({
[16:19:15.271]             c <- base::c
[16:19:15.271]             inherits <- base::inherits
[16:19:15.271]             invokeRestart <- base::invokeRestart
[16:19:15.271]             length <- base::length
[16:19:15.271]             list <- base::list
[16:19:15.271]             seq.int <- base::seq.int
[16:19:15.271]             signalCondition <- base::signalCondition
[16:19:15.271]             sys.calls <- base::sys.calls
[16:19:15.271]             `[[` <- base::`[[`
[16:19:15.271]             `+` <- base::`+`
[16:19:15.271]             `<<-` <- base::`<<-`
[16:19:15.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:15.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:15.271]                   3L)]
[16:19:15.271]             }
[16:19:15.271]             function(cond) {
[16:19:15.271]                 is_error <- inherits(cond, "error")
[16:19:15.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:15.271]                   NULL)
[16:19:15.271]                 if (is_error) {
[16:19:15.271]                   sessionInformation <- function() {
[16:19:15.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:15.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:15.271]                       search = base::search(), system = base::Sys.info())
[16:19:15.271]                   }
[16:19:15.271]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:15.271]                     cond$call), session = sessionInformation(), 
[16:19:15.271]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:15.271]                   signalCondition(cond)
[16:19:15.271]                 }
[16:19:15.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:15.271]                 "immediateCondition"))) {
[16:19:15.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:15.271]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:15.271]                   if (TRUE && !signal) {
[16:19:15.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.271]                     {
[16:19:15.271]                       inherits <- base::inherits
[16:19:15.271]                       invokeRestart <- base::invokeRestart
[16:19:15.271]                       is.null <- base::is.null
[16:19:15.271]                       muffled <- FALSE
[16:19:15.271]                       if (inherits(cond, "message")) {
[16:19:15.271]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.271]                         if (muffled) 
[16:19:15.271]                           invokeRestart("muffleMessage")
[16:19:15.271]                       }
[16:19:15.271]                       else if (inherits(cond, "warning")) {
[16:19:15.271]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.271]                         if (muffled) 
[16:19:15.271]                           invokeRestart("muffleWarning")
[16:19:15.271]                       }
[16:19:15.271]                       else if (inherits(cond, "condition")) {
[16:19:15.271]                         if (!is.null(pattern)) {
[16:19:15.271]                           computeRestarts <- base::computeRestarts
[16:19:15.271]                           grepl <- base::grepl
[16:19:15.271]                           restarts <- computeRestarts(cond)
[16:19:15.271]                           for (restart in restarts) {
[16:19:15.271]                             name <- restart$name
[16:19:15.271]                             if (is.null(name)) 
[16:19:15.271]                               next
[16:19:15.271]                             if (!grepl(pattern, name)) 
[16:19:15.271]                               next
[16:19:15.271]                             invokeRestart(restart)
[16:19:15.271]                             muffled <- TRUE
[16:19:15.271]                             break
[16:19:15.271]                           }
[16:19:15.271]                         }
[16:19:15.271]                       }
[16:19:15.271]                       invisible(muffled)
[16:19:15.271]                     }
[16:19:15.271]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.271]                   }
[16:19:15.271]                 }
[16:19:15.271]                 else {
[16:19:15.271]                   if (TRUE) {
[16:19:15.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.271]                     {
[16:19:15.271]                       inherits <- base::inherits
[16:19:15.271]                       invokeRestart <- base::invokeRestart
[16:19:15.271]                       is.null <- base::is.null
[16:19:15.271]                       muffled <- FALSE
[16:19:15.271]                       if (inherits(cond, "message")) {
[16:19:15.271]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.271]                         if (muffled) 
[16:19:15.271]                           invokeRestart("muffleMessage")
[16:19:15.271]                       }
[16:19:15.271]                       else if (inherits(cond, "warning")) {
[16:19:15.271]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.271]                         if (muffled) 
[16:19:15.271]                           invokeRestart("muffleWarning")
[16:19:15.271]                       }
[16:19:15.271]                       else if (inherits(cond, "condition")) {
[16:19:15.271]                         if (!is.null(pattern)) {
[16:19:15.271]                           computeRestarts <- base::computeRestarts
[16:19:15.271]                           grepl <- base::grepl
[16:19:15.271]                           restarts <- computeRestarts(cond)
[16:19:15.271]                           for (restart in restarts) {
[16:19:15.271]                             name <- restart$name
[16:19:15.271]                             if (is.null(name)) 
[16:19:15.271]                               next
[16:19:15.271]                             if (!grepl(pattern, name)) 
[16:19:15.271]                               next
[16:19:15.271]                             invokeRestart(restart)
[16:19:15.271]                             muffled <- TRUE
[16:19:15.271]                             break
[16:19:15.271]                           }
[16:19:15.271]                         }
[16:19:15.271]                       }
[16:19:15.271]                       invisible(muffled)
[16:19:15.271]                     }
[16:19:15.271]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.271]                   }
[16:19:15.271]                 }
[16:19:15.271]             }
[16:19:15.271]         }))
[16:19:15.271]     }, error = function(ex) {
[16:19:15.271]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:15.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.271]                 ...future.rng), started = ...future.startTime, 
[16:19:15.271]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:15.271]             version = "1.8"), class = "FutureResult")
[16:19:15.271]     }, finally = {
[16:19:15.271]         if (!identical(...future.workdir, getwd())) 
[16:19:15.271]             setwd(...future.workdir)
[16:19:15.271]         {
[16:19:15.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:15.271]                 ...future.oldOptions$nwarnings <- NULL
[16:19:15.271]             }
[16:19:15.271]             base::options(...future.oldOptions)
[16:19:15.271]             if (.Platform$OS.type == "windows") {
[16:19:15.271]                 old_names <- names(...future.oldEnvVars)
[16:19:15.271]                 envs <- base::Sys.getenv()
[16:19:15.271]                 names <- names(envs)
[16:19:15.271]                 common <- intersect(names, old_names)
[16:19:15.271]                 added <- setdiff(names, old_names)
[16:19:15.271]                 removed <- setdiff(old_names, names)
[16:19:15.271]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:15.271]                   envs[common]]
[16:19:15.271]                 NAMES <- toupper(changed)
[16:19:15.271]                 args <- list()
[16:19:15.271]                 for (kk in seq_along(NAMES)) {
[16:19:15.271]                   name <- changed[[kk]]
[16:19:15.271]                   NAME <- NAMES[[kk]]
[16:19:15.271]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.271]                     next
[16:19:15.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.271]                 }
[16:19:15.271]                 NAMES <- toupper(added)
[16:19:15.271]                 for (kk in seq_along(NAMES)) {
[16:19:15.271]                   name <- added[[kk]]
[16:19:15.271]                   NAME <- NAMES[[kk]]
[16:19:15.271]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.271]                     next
[16:19:15.271]                   args[[name]] <- ""
[16:19:15.271]                 }
[16:19:15.271]                 NAMES <- toupper(removed)
[16:19:15.271]                 for (kk in seq_along(NAMES)) {
[16:19:15.271]                   name <- removed[[kk]]
[16:19:15.271]                   NAME <- NAMES[[kk]]
[16:19:15.271]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.271]                     next
[16:19:15.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.271]                 }
[16:19:15.271]                 if (length(args) > 0) 
[16:19:15.271]                   base::do.call(base::Sys.setenv, args = args)
[16:19:15.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:15.271]             }
[16:19:15.271]             else {
[16:19:15.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:15.271]             }
[16:19:15.271]             {
[16:19:15.271]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:15.271]                   0L) {
[16:19:15.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:15.271]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:15.271]                   base::options(opts)
[16:19:15.271]                 }
[16:19:15.271]                 {
[16:19:15.271]                   {
[16:19:15.271]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:15.271]                     NULL
[16:19:15.271]                   }
[16:19:15.271]                   options(future.plan = NULL)
[16:19:15.271]                   if (is.na(NA_character_)) 
[16:19:15.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:15.271]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:15.271]                     .init = FALSE)
[16:19:15.271]                 }
[16:19:15.271]             }
[16:19:15.271]         }
[16:19:15.271]     })
[16:19:15.271]     if (TRUE) {
[16:19:15.271]         base::sink(type = "output", split = FALSE)
[16:19:15.271]         if (TRUE) {
[16:19:15.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:15.271]         }
[16:19:15.271]         else {
[16:19:15.271]             ...future.result["stdout"] <- base::list(NULL)
[16:19:15.271]         }
[16:19:15.271]         base::close(...future.stdout)
[16:19:15.271]         ...future.stdout <- NULL
[16:19:15.271]     }
[16:19:15.271]     ...future.result$conditions <- ...future.conditions
[16:19:15.271]     ...future.result$finished <- base::Sys.time()
[16:19:15.271]     ...future.result
[16:19:15.271] }
[16:19:15.274] assign_globals() ...
[16:19:15.274] List of 11
[16:19:15.274]  $ ...future.FUN            :function (x, ...)  
[16:19:15.274]  $ x_FUN                    :function (x)  
[16:19:15.274]  $ times                    : int 1
[16:19:15.274]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.274]  $ stop_if_not              :function (...)  
[16:19:15.274]  $ dim                      : NULL
[16:19:15.274]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:15.274]  $ future.call.arguments    : list()
[16:19:15.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.274]  $ ...future.elements_ii    :List of 1
[16:19:15.274]   ..$ a: num 1
[16:19:15.274]  $ ...future.seeds_ii       : NULL
[16:19:15.274]  $ ...future.globals.maxSize: NULL
[16:19:15.274]  - attr(*, "where")=List of 11
[16:19:15.274]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:15.274]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:15.274]  - attr(*, "resolved")= logi FALSE
[16:19:15.274]  - attr(*, "total_size")= num 94264
[16:19:15.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.274]  - attr(*, "already-done")= logi TRUE
[16:19:15.286] - copied ‘...future.FUN’ to environment
[16:19:15.286] - copied ‘x_FUN’ to environment
[16:19:15.286] - copied ‘times’ to environment
[16:19:15.286] - copied ‘stopf’ to environment
[16:19:15.287] - copied ‘stop_if_not’ to environment
[16:19:15.287] - copied ‘dim’ to environment
[16:19:15.287] - copied ‘valid_types’ to environment
[16:19:15.287] - copied ‘future.call.arguments’ to environment
[16:19:15.287] - copied ‘...future.elements_ii’ to environment
[16:19:15.287] - copied ‘...future.seeds_ii’ to environment
[16:19:15.287] - copied ‘...future.globals.maxSize’ to environment
[16:19:15.287] assign_globals() ... done
[16:19:15.288] requestCore(): workers = 2
[16:19:15.290] MulticoreFuture started
[16:19:15.291] - Launch lazy future ... done
[16:19:15.291] run() for ‘MulticoreFuture’ ... done
[16:19:15.292] Created future:
[16:19:15.292] plan(): Setting new future strategy stack:
[16:19:15.292] List of future strategies:
[16:19:15.292] 1. sequential:
[16:19:15.292]    - args: function (..., envir = parent.frame())
[16:19:15.292]    - tweaked: FALSE
[16:19:15.292]    - call: NULL
[16:19:15.293] plan(): nbrOfWorkers() = 1
[16:19:15.296] plan(): Setting new future strategy stack:
[16:19:15.296] List of future strategies:
[16:19:15.296] 1. multicore:
[16:19:15.296]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:15.296]    - tweaked: FALSE
[16:19:15.296]    - call: plan(strategy)
[16:19:15.303] plan(): nbrOfWorkers() = 2
[16:19:15.292] MulticoreFuture:
[16:19:15.292] Label: ‘future_vapply-1’
[16:19:15.292] Expression:
[16:19:15.292] {
[16:19:15.292]     do.call(function(...) {
[16:19:15.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.292]             on.exit(options(oopts), add = TRUE)
[16:19:15.292]         }
[16:19:15.292]         {
[16:19:15.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.292]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.292]             })
[16:19:15.292]         }
[16:19:15.292]     }, args = future.call.arguments)
[16:19:15.292] }
[16:19:15.292] Lazy evaluation: FALSE
[16:19:15.292] Asynchronous evaluation: TRUE
[16:19:15.292] Local evaluation: TRUE
[16:19:15.292] Environment: R_GlobalEnv
[16:19:15.292] Capture standard output: TRUE
[16:19:15.292] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:15.292] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:15.292] Packages: 1 packages (‘future.apply’)
[16:19:15.292] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:15.292] Resolved: TRUE
[16:19:15.292] Value: <not collected>
[16:19:15.292] Conditions captured: <none>
[16:19:15.292] Early signaling: FALSE
[16:19:15.292] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:15.292] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.304] Chunk #1 of 2 ... DONE
[16:19:15.304] Chunk #2 of 2 ...
[16:19:15.304]  - Finding globals in 'X' for chunk #2 ...
[16:19:15.305] getGlobalsAndPackages() ...
[16:19:15.305] Searching for globals...
[16:19:15.305] 
[16:19:15.305] Searching for globals ... DONE
[16:19:15.306] - globals: [0] <none>
[16:19:15.306] getGlobalsAndPackages() ... DONE
[16:19:15.306]    + additional globals found: [n=0] 
[16:19:15.306]    + additional namespaces needed: [n=0] 
[16:19:15.306]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:15.306]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:15.307]  - seeds: <none>
[16:19:15.307]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.307] getGlobalsAndPackages() ...
[16:19:15.307] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.307] Resolving globals: FALSE
[16:19:15.308] Tweak future expression to call with '...' arguments ...
[16:19:15.308] {
[16:19:15.308]     do.call(function(...) {
[16:19:15.308]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.308]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.308]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.308]             on.exit(options(oopts), add = TRUE)
[16:19:15.308]         }
[16:19:15.308]         {
[16:19:15.308]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.308]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.308]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.308]             })
[16:19:15.308]         }
[16:19:15.308]     }, args = future.call.arguments)
[16:19:15.308] }
[16:19:15.308] Tweak future expression to call with '...' arguments ... DONE
[16:19:15.309] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.310] - packages: [1] ‘future.apply’
[16:19:15.310] getGlobalsAndPackages() ... DONE
[16:19:15.310] run() for ‘Future’ ...
[16:19:15.311] - state: ‘created’
[16:19:15.311] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:15.316] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.316] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:15.316]   - Field: ‘label’
[16:19:15.317]   - Field: ‘local’
[16:19:15.317]   - Field: ‘owner’
[16:19:15.317]   - Field: ‘envir’
[16:19:15.317]   - Field: ‘workers’
[16:19:15.317]   - Field: ‘packages’
[16:19:15.317]   - Field: ‘gc’
[16:19:15.317]   - Field: ‘job’
[16:19:15.318]   - Field: ‘conditions’
[16:19:15.318]   - Field: ‘expr’
[16:19:15.318]   - Field: ‘uuid’
[16:19:15.318]   - Field: ‘seed’
[16:19:15.318]   - Field: ‘version’
[16:19:15.318]   - Field: ‘result’
[16:19:15.319]   - Field: ‘asynchronous’
[16:19:15.319]   - Field: ‘calls’
[16:19:15.319]   - Field: ‘globals’
[16:19:15.319]   - Field: ‘stdout’
[16:19:15.319]   - Field: ‘earlySignal’
[16:19:15.319]   - Field: ‘lazy’
[16:19:15.319]   - Field: ‘state’
[16:19:15.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:15.320] - Launch lazy future ...
[16:19:15.320] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:15.321] Packages needed by future strategies (n = 0): <none>
[16:19:15.321] {
[16:19:15.321]     {
[16:19:15.321]         {
[16:19:15.321]             ...future.startTime <- base::Sys.time()
[16:19:15.321]             {
[16:19:15.321]                 {
[16:19:15.321]                   {
[16:19:15.321]                     {
[16:19:15.321]                       {
[16:19:15.321]                         base::local({
[16:19:15.321]                           has_future <- base::requireNamespace("future", 
[16:19:15.321]                             quietly = TRUE)
[16:19:15.321]                           if (has_future) {
[16:19:15.321]                             ns <- base::getNamespace("future")
[16:19:15.321]                             version <- ns[[".package"]][["version"]]
[16:19:15.321]                             if (is.null(version)) 
[16:19:15.321]                               version <- utils::packageVersion("future")
[16:19:15.321]                           }
[16:19:15.321]                           else {
[16:19:15.321]                             version <- NULL
[16:19:15.321]                           }
[16:19:15.321]                           if (!has_future || version < "1.8.0") {
[16:19:15.321]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:15.321]                               "", base::R.version$version.string), 
[16:19:15.321]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:15.321]                                 base::R.version$platform, 8 * 
[16:19:15.321]                                   base::.Machine$sizeof.pointer), 
[16:19:15.321]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:15.321]                                 "release", "version")], collapse = " "), 
[16:19:15.321]                               hostname = base::Sys.info()[["nodename"]])
[16:19:15.321]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:15.321]                               info)
[16:19:15.321]                             info <- base::paste(info, collapse = "; ")
[16:19:15.321]                             if (!has_future) {
[16:19:15.321]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:15.321]                                 info)
[16:19:15.321]                             }
[16:19:15.321]                             else {
[16:19:15.321]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:15.321]                                 info, version)
[16:19:15.321]                             }
[16:19:15.321]                             base::stop(msg)
[16:19:15.321]                           }
[16:19:15.321]                         })
[16:19:15.321]                       }
[16:19:15.321]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:15.321]                       base::options(mc.cores = 1L)
[16:19:15.321]                     }
[16:19:15.321]                     base::local({
[16:19:15.321]                       for (pkg in "future.apply") {
[16:19:15.321]                         base::loadNamespace(pkg)
[16:19:15.321]                         base::library(pkg, character.only = TRUE)
[16:19:15.321]                       }
[16:19:15.321]                     })
[16:19:15.321]                   }
[16:19:15.321]                   ...future.strategy.old <- future::plan("list")
[16:19:15.321]                   options(future.plan = NULL)
[16:19:15.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:15.321]                 }
[16:19:15.321]                 ...future.workdir <- getwd()
[16:19:15.321]             }
[16:19:15.321]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:15.321]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:15.321]         }
[16:19:15.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:15.321]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:15.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:15.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:15.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:15.321]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:15.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:15.321]             base::names(...future.oldOptions))
[16:19:15.321]     }
[16:19:15.321]     if (FALSE) {
[16:19:15.321]     }
[16:19:15.321]     else {
[16:19:15.321]         if (TRUE) {
[16:19:15.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:15.321]                 open = "w")
[16:19:15.321]         }
[16:19:15.321]         else {
[16:19:15.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:15.321]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:15.321]         }
[16:19:15.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:15.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:15.321]             base::sink(type = "output", split = FALSE)
[16:19:15.321]             base::close(...future.stdout)
[16:19:15.321]         }, add = TRUE)
[16:19:15.321]     }
[16:19:15.321]     ...future.frame <- base::sys.nframe()
[16:19:15.321]     ...future.conditions <- base::list()
[16:19:15.321]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:15.321]     if (FALSE) {
[16:19:15.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:15.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:15.321]     }
[16:19:15.321]     ...future.result <- base::tryCatch({
[16:19:15.321]         base::withCallingHandlers({
[16:19:15.321]             ...future.value <- base::withVisible(base::local({
[16:19:15.321]                 withCallingHandlers({
[16:19:15.321]                   {
[16:19:15.321]                     do.call(function(...) {
[16:19:15.321]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.321]                       if (!identical(...future.globals.maxSize.org, 
[16:19:15.321]                         ...future.globals.maxSize)) {
[16:19:15.321]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.321]                         on.exit(options(oopts), add = TRUE)
[16:19:15.321]                       }
[16:19:15.321]                       {
[16:19:15.321]                         lapply(seq_along(...future.elements_ii), 
[16:19:15.321]                           FUN = function(jj) {
[16:19:15.321]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.321]                             ...future.FUN(...future.X_jj, ...)
[16:19:15.321]                           })
[16:19:15.321]                       }
[16:19:15.321]                     }, args = future.call.arguments)
[16:19:15.321]                   }
[16:19:15.321]                 }, immediateCondition = function(cond) {
[16:19:15.321]                   save_rds <- function (object, pathname, ...) 
[16:19:15.321]                   {
[16:19:15.321]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:15.321]                     if (file_test("-f", pathname_tmp)) {
[16:19:15.321]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.321]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:15.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.321]                         fi_tmp[["mtime"]])
[16:19:15.321]                     }
[16:19:15.321]                     tryCatch({
[16:19:15.321]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:15.321]                     }, error = function(ex) {
[16:19:15.321]                       msg <- conditionMessage(ex)
[16:19:15.321]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.321]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:15.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.321]                         fi_tmp[["mtime"]], msg)
[16:19:15.321]                       ex$message <- msg
[16:19:15.321]                       stop(ex)
[16:19:15.321]                     })
[16:19:15.321]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:15.321]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:15.321]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:15.321]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.321]                       fi <- file.info(pathname)
[16:19:15.321]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:15.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.321]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:15.321]                         fi[["size"]], fi[["mtime"]])
[16:19:15.321]                       stop(msg)
[16:19:15.321]                     }
[16:19:15.321]                     invisible(pathname)
[16:19:15.321]                   }
[16:19:15.321]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:15.321]                     rootPath = tempdir()) 
[16:19:15.321]                   {
[16:19:15.321]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:15.321]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:15.321]                       tmpdir = path, fileext = ".rds")
[16:19:15.321]                     save_rds(obj, file)
[16:19:15.321]                   }
[16:19:15.321]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:15.321]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.321]                   {
[16:19:15.321]                     inherits <- base::inherits
[16:19:15.321]                     invokeRestart <- base::invokeRestart
[16:19:15.321]                     is.null <- base::is.null
[16:19:15.321]                     muffled <- FALSE
[16:19:15.321]                     if (inherits(cond, "message")) {
[16:19:15.321]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:15.321]                       if (muffled) 
[16:19:15.321]                         invokeRestart("muffleMessage")
[16:19:15.321]                     }
[16:19:15.321]                     else if (inherits(cond, "warning")) {
[16:19:15.321]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:15.321]                       if (muffled) 
[16:19:15.321]                         invokeRestart("muffleWarning")
[16:19:15.321]                     }
[16:19:15.321]                     else if (inherits(cond, "condition")) {
[16:19:15.321]                       if (!is.null(pattern)) {
[16:19:15.321]                         computeRestarts <- base::computeRestarts
[16:19:15.321]                         grepl <- base::grepl
[16:19:15.321]                         restarts <- computeRestarts(cond)
[16:19:15.321]                         for (restart in restarts) {
[16:19:15.321]                           name <- restart$name
[16:19:15.321]                           if (is.null(name)) 
[16:19:15.321]                             next
[16:19:15.321]                           if (!grepl(pattern, name)) 
[16:19:15.321]                             next
[16:19:15.321]                           invokeRestart(restart)
[16:19:15.321]                           muffled <- TRUE
[16:19:15.321]                           break
[16:19:15.321]                         }
[16:19:15.321]                       }
[16:19:15.321]                     }
[16:19:15.321]                     invisible(muffled)
[16:19:15.321]                   }
[16:19:15.321]                   muffleCondition(cond)
[16:19:15.321]                 })
[16:19:15.321]             }))
[16:19:15.321]             future::FutureResult(value = ...future.value$value, 
[16:19:15.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.321]                   ...future.rng), globalenv = if (FALSE) 
[16:19:15.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:15.321]                     ...future.globalenv.names))
[16:19:15.321]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:15.321]         }, condition = base::local({
[16:19:15.321]             c <- base::c
[16:19:15.321]             inherits <- base::inherits
[16:19:15.321]             invokeRestart <- base::invokeRestart
[16:19:15.321]             length <- base::length
[16:19:15.321]             list <- base::list
[16:19:15.321]             seq.int <- base::seq.int
[16:19:15.321]             signalCondition <- base::signalCondition
[16:19:15.321]             sys.calls <- base::sys.calls
[16:19:15.321]             `[[` <- base::`[[`
[16:19:15.321]             `+` <- base::`+`
[16:19:15.321]             `<<-` <- base::`<<-`
[16:19:15.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:15.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:15.321]                   3L)]
[16:19:15.321]             }
[16:19:15.321]             function(cond) {
[16:19:15.321]                 is_error <- inherits(cond, "error")
[16:19:15.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:15.321]                   NULL)
[16:19:15.321]                 if (is_error) {
[16:19:15.321]                   sessionInformation <- function() {
[16:19:15.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:15.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:15.321]                       search = base::search(), system = base::Sys.info())
[16:19:15.321]                   }
[16:19:15.321]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:15.321]                     cond$call), session = sessionInformation(), 
[16:19:15.321]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:15.321]                   signalCondition(cond)
[16:19:15.321]                 }
[16:19:15.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:15.321]                 "immediateCondition"))) {
[16:19:15.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:15.321]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:15.321]                   if (TRUE && !signal) {
[16:19:15.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.321]                     {
[16:19:15.321]                       inherits <- base::inherits
[16:19:15.321]                       invokeRestart <- base::invokeRestart
[16:19:15.321]                       is.null <- base::is.null
[16:19:15.321]                       muffled <- FALSE
[16:19:15.321]                       if (inherits(cond, "message")) {
[16:19:15.321]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.321]                         if (muffled) 
[16:19:15.321]                           invokeRestart("muffleMessage")
[16:19:15.321]                       }
[16:19:15.321]                       else if (inherits(cond, "warning")) {
[16:19:15.321]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.321]                         if (muffled) 
[16:19:15.321]                           invokeRestart("muffleWarning")
[16:19:15.321]                       }
[16:19:15.321]                       else if (inherits(cond, "condition")) {
[16:19:15.321]                         if (!is.null(pattern)) {
[16:19:15.321]                           computeRestarts <- base::computeRestarts
[16:19:15.321]                           grepl <- base::grepl
[16:19:15.321]                           restarts <- computeRestarts(cond)
[16:19:15.321]                           for (restart in restarts) {
[16:19:15.321]                             name <- restart$name
[16:19:15.321]                             if (is.null(name)) 
[16:19:15.321]                               next
[16:19:15.321]                             if (!grepl(pattern, name)) 
[16:19:15.321]                               next
[16:19:15.321]                             invokeRestart(restart)
[16:19:15.321]                             muffled <- TRUE
[16:19:15.321]                             break
[16:19:15.321]                           }
[16:19:15.321]                         }
[16:19:15.321]                       }
[16:19:15.321]                       invisible(muffled)
[16:19:15.321]                     }
[16:19:15.321]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.321]                   }
[16:19:15.321]                 }
[16:19:15.321]                 else {
[16:19:15.321]                   if (TRUE) {
[16:19:15.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.321]                     {
[16:19:15.321]                       inherits <- base::inherits
[16:19:15.321]                       invokeRestart <- base::invokeRestart
[16:19:15.321]                       is.null <- base::is.null
[16:19:15.321]                       muffled <- FALSE
[16:19:15.321]                       if (inherits(cond, "message")) {
[16:19:15.321]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.321]                         if (muffled) 
[16:19:15.321]                           invokeRestart("muffleMessage")
[16:19:15.321]                       }
[16:19:15.321]                       else if (inherits(cond, "warning")) {
[16:19:15.321]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.321]                         if (muffled) 
[16:19:15.321]                           invokeRestart("muffleWarning")
[16:19:15.321]                       }
[16:19:15.321]                       else if (inherits(cond, "condition")) {
[16:19:15.321]                         if (!is.null(pattern)) {
[16:19:15.321]                           computeRestarts <- base::computeRestarts
[16:19:15.321]                           grepl <- base::grepl
[16:19:15.321]                           restarts <- computeRestarts(cond)
[16:19:15.321]                           for (restart in restarts) {
[16:19:15.321]                             name <- restart$name
[16:19:15.321]                             if (is.null(name)) 
[16:19:15.321]                               next
[16:19:15.321]                             if (!grepl(pattern, name)) 
[16:19:15.321]                               next
[16:19:15.321]                             invokeRestart(restart)
[16:19:15.321]                             muffled <- TRUE
[16:19:15.321]                             break
[16:19:15.321]                           }
[16:19:15.321]                         }
[16:19:15.321]                       }
[16:19:15.321]                       invisible(muffled)
[16:19:15.321]                     }
[16:19:15.321]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.321]                   }
[16:19:15.321]                 }
[16:19:15.321]             }
[16:19:15.321]         }))
[16:19:15.321]     }, error = function(ex) {
[16:19:15.321]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:15.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.321]                 ...future.rng), started = ...future.startTime, 
[16:19:15.321]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:15.321]             version = "1.8"), class = "FutureResult")
[16:19:15.321]     }, finally = {
[16:19:15.321]         if (!identical(...future.workdir, getwd())) 
[16:19:15.321]             setwd(...future.workdir)
[16:19:15.321]         {
[16:19:15.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:15.321]                 ...future.oldOptions$nwarnings <- NULL
[16:19:15.321]             }
[16:19:15.321]             base::options(...future.oldOptions)
[16:19:15.321]             if (.Platform$OS.type == "windows") {
[16:19:15.321]                 old_names <- names(...future.oldEnvVars)
[16:19:15.321]                 envs <- base::Sys.getenv()
[16:19:15.321]                 names <- names(envs)
[16:19:15.321]                 common <- intersect(names, old_names)
[16:19:15.321]                 added <- setdiff(names, old_names)
[16:19:15.321]                 removed <- setdiff(old_names, names)
[16:19:15.321]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:15.321]                   envs[common]]
[16:19:15.321]                 NAMES <- toupper(changed)
[16:19:15.321]                 args <- list()
[16:19:15.321]                 for (kk in seq_along(NAMES)) {
[16:19:15.321]                   name <- changed[[kk]]
[16:19:15.321]                   NAME <- NAMES[[kk]]
[16:19:15.321]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.321]                     next
[16:19:15.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.321]                 }
[16:19:15.321]                 NAMES <- toupper(added)
[16:19:15.321]                 for (kk in seq_along(NAMES)) {
[16:19:15.321]                   name <- added[[kk]]
[16:19:15.321]                   NAME <- NAMES[[kk]]
[16:19:15.321]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.321]                     next
[16:19:15.321]                   args[[name]] <- ""
[16:19:15.321]                 }
[16:19:15.321]                 NAMES <- toupper(removed)
[16:19:15.321]                 for (kk in seq_along(NAMES)) {
[16:19:15.321]                   name <- removed[[kk]]
[16:19:15.321]                   NAME <- NAMES[[kk]]
[16:19:15.321]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.321]                     next
[16:19:15.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.321]                 }
[16:19:15.321]                 if (length(args) > 0) 
[16:19:15.321]                   base::do.call(base::Sys.setenv, args = args)
[16:19:15.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:15.321]             }
[16:19:15.321]             else {
[16:19:15.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:15.321]             }
[16:19:15.321]             {
[16:19:15.321]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:15.321]                   0L) {
[16:19:15.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:15.321]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:15.321]                   base::options(opts)
[16:19:15.321]                 }
[16:19:15.321]                 {
[16:19:15.321]                   {
[16:19:15.321]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:15.321]                     NULL
[16:19:15.321]                   }
[16:19:15.321]                   options(future.plan = NULL)
[16:19:15.321]                   if (is.na(NA_character_)) 
[16:19:15.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:15.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:15.321]                     .init = FALSE)
[16:19:15.321]                 }
[16:19:15.321]             }
[16:19:15.321]         }
[16:19:15.321]     })
[16:19:15.321]     if (TRUE) {
[16:19:15.321]         base::sink(type = "output", split = FALSE)
[16:19:15.321]         if (TRUE) {
[16:19:15.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:15.321]         }
[16:19:15.321]         else {
[16:19:15.321]             ...future.result["stdout"] <- base::list(NULL)
[16:19:15.321]         }
[16:19:15.321]         base::close(...future.stdout)
[16:19:15.321]         ...future.stdout <- NULL
[16:19:15.321]     }
[16:19:15.321]     ...future.result$conditions <- ...future.conditions
[16:19:15.321]     ...future.result$finished <- base::Sys.time()
[16:19:15.321]     ...future.result
[16:19:15.321] }
[16:19:15.325] assign_globals() ...
[16:19:15.325] List of 11
[16:19:15.325]  $ ...future.FUN            :function (x, ...)  
[16:19:15.325]  $ x_FUN                    :function (x)  
[16:19:15.325]  $ times                    : int 1
[16:19:15.325]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.325]  $ stop_if_not              :function (...)  
[16:19:15.325]  $ dim                      : NULL
[16:19:15.325]  $ valid_types              : chr [1:2] "logical" "integer"
[16:19:15.325]  $ future.call.arguments    : list()
[16:19:15.325]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.325]  $ ...future.elements_ii    :List of 2
[16:19:15.325]   ..$ b: num 2
[16:19:15.325]   ..$ c: num 3
[16:19:15.325]  $ ...future.seeds_ii       : NULL
[16:19:15.325]  $ ...future.globals.maxSize: NULL
[16:19:15.325]  - attr(*, "where")=List of 11
[16:19:15.325]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:15.325]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:15.325]  - attr(*, "resolved")= logi FALSE
[16:19:15.325]  - attr(*, "total_size")= num 94264
[16:19:15.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.325]  - attr(*, "already-done")= logi TRUE
[16:19:15.343] - copied ‘...future.FUN’ to environment
[16:19:15.344] - copied ‘x_FUN’ to environment
[16:19:15.344] - copied ‘times’ to environment
[16:19:15.344] - copied ‘stopf’ to environment
[16:19:15.344] - copied ‘stop_if_not’ to environment
[16:19:15.344] - copied ‘dim’ to environment
[16:19:15.344] - copied ‘valid_types’ to environment
[16:19:15.344] - copied ‘future.call.arguments’ to environment
[16:19:15.344] - copied ‘...future.elements_ii’ to environment
[16:19:15.344] - copied ‘...future.seeds_ii’ to environment
[16:19:15.345] - copied ‘...future.globals.maxSize’ to environment
[16:19:15.345] assign_globals() ... done
[16:19:15.345] requestCore(): workers = 2
[16:19:15.347] MulticoreFuture started
[16:19:15.348] - Launch lazy future ... done
[16:19:15.348] run() for ‘MulticoreFuture’ ... done
[16:19:15.349] Created future:
[16:19:15.349] plan(): Setting new future strategy stack:
[16:19:15.350] List of future strategies:
[16:19:15.350] 1. sequential:
[16:19:15.350]    - args: function (..., envir = parent.frame())
[16:19:15.350]    - tweaked: FALSE
[16:19:15.350]    - call: NULL
[16:19:15.350] plan(): nbrOfWorkers() = 1
[16:19:15.353] plan(): Setting new future strategy stack:
[16:19:15.353] List of future strategies:
[16:19:15.353] 1. multicore:
[16:19:15.353]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:15.353]    - tweaked: FALSE
[16:19:15.353]    - call: plan(strategy)
[16:19:15.358] plan(): nbrOfWorkers() = 2
[16:19:15.349] MulticoreFuture:
[16:19:15.349] Label: ‘future_vapply-2’
[16:19:15.349] Expression:
[16:19:15.349] {
[16:19:15.349]     do.call(function(...) {
[16:19:15.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.349]             on.exit(options(oopts), add = TRUE)
[16:19:15.349]         }
[16:19:15.349]         {
[16:19:15.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.349]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.349]             })
[16:19:15.349]         }
[16:19:15.349]     }, args = future.call.arguments)
[16:19:15.349] }
[16:19:15.349] Lazy evaluation: FALSE
[16:19:15.349] Asynchronous evaluation: TRUE
[16:19:15.349] Local evaluation: TRUE
[16:19:15.349] Environment: R_GlobalEnv
[16:19:15.349] Capture standard output: TRUE
[16:19:15.349] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:15.349] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:15.349] Packages: 1 packages (‘future.apply’)
[16:19:15.349] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:15.349] Resolved: TRUE
[16:19:15.349] Value: <not collected>
[16:19:15.349] Conditions captured: <none>
[16:19:15.349] Early signaling: FALSE
[16:19:15.349] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:15.349] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.360] Chunk #2 of 2 ... DONE
[16:19:15.360] Launching 2 futures (chunks) ... DONE
[16:19:15.360] Resolving 2 futures (chunks) ...
[16:19:15.360] resolve() on list ...
[16:19:15.360]  recursive: 0
[16:19:15.360]  length: 2
[16:19:15.361] 
[16:19:15.361] Future #1
[16:19:15.361] result() for MulticoreFuture ...
[16:19:15.362] result() for MulticoreFuture ...
[16:19:15.362] result() for MulticoreFuture ... done
[16:19:15.362] result() for MulticoreFuture ... done
[16:19:15.362] result() for MulticoreFuture ...
[16:19:15.363] result() for MulticoreFuture ... done
[16:19:15.363] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:15.363] - nx: 2
[16:19:15.363] - relay: TRUE
[16:19:15.363] - stdout: TRUE
[16:19:15.363] - signal: TRUE
[16:19:15.364] - resignal: FALSE
[16:19:15.364] - force: TRUE
[16:19:15.364] - relayed: [n=2] FALSE, FALSE
[16:19:15.364] - queued futures: [n=2] FALSE, FALSE
[16:19:15.364]  - until=1
[16:19:15.364]  - relaying element #1
[16:19:15.365] result() for MulticoreFuture ...
[16:19:15.365] result() for MulticoreFuture ... done
[16:19:15.365] result() for MulticoreFuture ...
[16:19:15.365] result() for MulticoreFuture ... done
[16:19:15.365] result() for MulticoreFuture ...
[16:19:15.365] result() for MulticoreFuture ... done
[16:19:15.366] result() for MulticoreFuture ...
[16:19:15.366] result() for MulticoreFuture ... done
[16:19:15.366] - relayed: [n=2] TRUE, FALSE
[16:19:15.366] - queued futures: [n=2] TRUE, FALSE
[16:19:15.366] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:15.366]  length: 1 (resolved future 1)
[16:19:15.367] Future #2
[16:19:15.367] result() for MulticoreFuture ...
[16:19:15.368] result() for MulticoreFuture ...
[16:19:15.368] result() for MulticoreFuture ... done
[16:19:15.368] result() for MulticoreFuture ... done
[16:19:15.368] result() for MulticoreFuture ...
[16:19:15.369] result() for MulticoreFuture ... done
[16:19:15.369] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:15.369] - nx: 2
[16:19:15.369] - relay: TRUE
[16:19:15.369] - stdout: TRUE
[16:19:15.369] - signal: TRUE
[16:19:15.369] - resignal: FALSE
[16:19:15.369] - force: TRUE
[16:19:15.370] - relayed: [n=2] TRUE, FALSE
[16:19:15.370] - queued futures: [n=2] TRUE, FALSE
[16:19:15.370]  - until=2
[16:19:15.370]  - relaying element #2
[16:19:15.370] result() for MulticoreFuture ...
[16:19:15.370] result() for MulticoreFuture ... done
[16:19:15.373] result() for MulticoreFuture ...
[16:19:15.373] result() for MulticoreFuture ... done
[16:19:15.374] result() for MulticoreFuture ...
[16:19:15.374] result() for MulticoreFuture ... done
[16:19:15.374] result() for MulticoreFuture ...
[16:19:15.374] result() for MulticoreFuture ... done
[16:19:15.374] - relayed: [n=2] TRUE, TRUE
[16:19:15.374] - queued futures: [n=2] TRUE, TRUE
[16:19:15.375] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:19:15.375]  length: 0 (resolved future 2)
[16:19:15.375] Relaying remaining futures
[16:19:15.375] signalConditionsASAP(NULL, pos=0) ...
[16:19:15.375] - nx: 2
[16:19:15.375] - relay: TRUE
[16:19:15.376] - stdout: TRUE
[16:19:15.376] - signal: TRUE
[16:19:15.376] - resignal: FALSE
[16:19:15.376] - force: TRUE
[16:19:15.376] - relayed: [n=2] TRUE, TRUE
[16:19:15.376] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:15.377] - relayed: [n=2] TRUE, TRUE
[16:19:15.377] - queued futures: [n=2] TRUE, TRUE
[16:19:15.377] signalConditionsASAP(NULL, pos=0) ... done
[16:19:15.377] resolve() on list ... DONE
[16:19:15.377] result() for MulticoreFuture ...
[16:19:15.377] result() for MulticoreFuture ... done
[16:19:15.378] result() for MulticoreFuture ...
[16:19:15.378] result() for MulticoreFuture ... done
[16:19:15.378] result() for MulticoreFuture ...
[16:19:15.378] result() for MulticoreFuture ... done
[16:19:15.378] result() for MulticoreFuture ...
[16:19:15.378] result() for MulticoreFuture ... done
[16:19:15.378]  - Number of value chunks collected: 2
[16:19:15.379] Resolving 2 futures (chunks) ... DONE
[16:19:15.379] Reducing values from 2 chunks ...
[16:19:15.379]  - Number of values collected after concatenation: 3
[16:19:15.379]  - Number of values expected: 3
[16:19:15.379] Reducing values from 2 chunks ... DONE
[16:19:15.379] future_lapply() ... DONE
- exceptions ...
[16:19:15.380] future_lapply() ...
[16:19:15.387] Number of chunks: 2
[16:19:15.387] getGlobalsAndPackagesXApply() ...
[16:19:15.387]  - future.globals: TRUE
[16:19:15.387] getGlobalsAndPackages() ...
[16:19:15.387] Searching for globals...
[16:19:15.391] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:15.391] Searching for globals ... DONE
[16:19:15.391] Resolving globals: FALSE
[16:19:15.392] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:19:15.392] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:15.393] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:15.393] - packages: [1] ‘future.apply’
[16:19:15.393] getGlobalsAndPackages() ... DONE
[16:19:15.393]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:15.393]  - needed namespaces: [n=1] ‘future.apply’
[16:19:15.393] Finding globals ... DONE
[16:19:15.393]  - use_args: TRUE
[16:19:15.393]  - Getting '...' globals ...
[16:19:15.394] resolve() on list ...
[16:19:15.394]  recursive: 0
[16:19:15.394]  length: 1
[16:19:15.394]  elements: ‘...’
[16:19:15.394]  length: 0 (resolved future 1)
[16:19:15.394] resolve() on list ... DONE
[16:19:15.394]    - '...' content: [n=0] 
[16:19:15.394] List of 1
[16:19:15.394]  $ ...: list()
[16:19:15.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.394]  - attr(*, "where")=List of 1
[16:19:15.394]   ..$ ...:<environment: 0x56199f66ffc0> 
[16:19:15.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.394]  - attr(*, "resolved")= logi TRUE
[16:19:15.394]  - attr(*, "total_size")= num NA
[16:19:15.400]  - Getting '...' globals ... DONE
[16:19:15.400] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:15.400] List of 8
[16:19:15.400]  $ ...future.FUN:function (x, ...)  
[16:19:15.400]  $ x_FUN        :function (x)  
[16:19:15.400]  $ times        : int 2
[16:19:15.400]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.400]  $ stop_if_not  :function (...)  
[16:19:15.400]  $ dim          : NULL
[16:19:15.400]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:15.400]  $ ...          : list()
[16:19:15.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.400]  - attr(*, "where")=List of 8
[16:19:15.400]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:15.400]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:15.400]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:15.400]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:15.400]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:15.400]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:15.400]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:15.400]   ..$ ...          :<environment: 0x56199f66ffc0> 
[16:19:15.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.400]  - attr(*, "resolved")= logi FALSE
[16:19:15.400]  - attr(*, "total_size")= num 95128
[16:19:15.407] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:15.407] getGlobalsAndPackagesXApply() ... DONE
[16:19:15.407] Number of futures (= number of chunks): 2
[16:19:15.407] Launching 2 futures (chunks) ...
[16:19:15.408] Chunk #1 of 2 ...
[16:19:15.408]  - Finding globals in 'X' for chunk #1 ...
[16:19:15.408] getGlobalsAndPackages() ...
[16:19:15.408] Searching for globals...
[16:19:15.408] 
[16:19:15.408] Searching for globals ... DONE
[16:19:15.408] - globals: [0] <none>
[16:19:15.408] getGlobalsAndPackages() ... DONE
[16:19:15.409]    + additional globals found: [n=0] 
[16:19:15.409]    + additional namespaces needed: [n=0] 
[16:19:15.409]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:15.409]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:15.409]  - seeds: <none>
[16:19:15.409]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.409] getGlobalsAndPackages() ...
[16:19:15.409] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.409] Resolving globals: FALSE
[16:19:15.409] Tweak future expression to call with '...' arguments ...
[16:19:15.410] {
[16:19:15.410]     do.call(function(...) {
[16:19:15.410]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.410]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.410]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.410]             on.exit(options(oopts), add = TRUE)
[16:19:15.410]         }
[16:19:15.410]         {
[16:19:15.410]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.410]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.410]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.410]             })
[16:19:15.410]         }
[16:19:15.410]     }, args = future.call.arguments)
[16:19:15.410] }
[16:19:15.410] Tweak future expression to call with '...' arguments ... DONE
[16:19:15.410] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.411] - packages: [1] ‘future.apply’
[16:19:15.411] getGlobalsAndPackages() ... DONE
[16:19:15.411] run() for ‘Future’ ...
[16:19:15.411] - state: ‘created’
[16:19:15.411] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:15.415] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.415] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:15.415]   - Field: ‘label’
[16:19:15.415]   - Field: ‘local’
[16:19:15.416]   - Field: ‘owner’
[16:19:15.416]   - Field: ‘envir’
[16:19:15.416]   - Field: ‘workers’
[16:19:15.416]   - Field: ‘packages’
[16:19:15.416]   - Field: ‘gc’
[16:19:15.416]   - Field: ‘job’
[16:19:15.416]   - Field: ‘conditions’
[16:19:15.416]   - Field: ‘expr’
[16:19:15.416]   - Field: ‘uuid’
[16:19:15.416]   - Field: ‘seed’
[16:19:15.417]   - Field: ‘version’
[16:19:15.417]   - Field: ‘result’
[16:19:15.417]   - Field: ‘asynchronous’
[16:19:15.417]   - Field: ‘calls’
[16:19:15.417]   - Field: ‘globals’
[16:19:15.417]   - Field: ‘stdout’
[16:19:15.417]   - Field: ‘earlySignal’
[16:19:15.417]   - Field: ‘lazy’
[16:19:15.417]   - Field: ‘state’
[16:19:15.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:15.418] - Launch lazy future ...
[16:19:15.418] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:15.418] Packages needed by future strategies (n = 0): <none>
[16:19:15.419] {
[16:19:15.419]     {
[16:19:15.419]         {
[16:19:15.419]             ...future.startTime <- base::Sys.time()
[16:19:15.419]             {
[16:19:15.419]                 {
[16:19:15.419]                   {
[16:19:15.419]                     {
[16:19:15.419]                       {
[16:19:15.419]                         base::local({
[16:19:15.419]                           has_future <- base::requireNamespace("future", 
[16:19:15.419]                             quietly = TRUE)
[16:19:15.419]                           if (has_future) {
[16:19:15.419]                             ns <- base::getNamespace("future")
[16:19:15.419]                             version <- ns[[".package"]][["version"]]
[16:19:15.419]                             if (is.null(version)) 
[16:19:15.419]                               version <- utils::packageVersion("future")
[16:19:15.419]                           }
[16:19:15.419]                           else {
[16:19:15.419]                             version <- NULL
[16:19:15.419]                           }
[16:19:15.419]                           if (!has_future || version < "1.8.0") {
[16:19:15.419]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:15.419]                               "", base::R.version$version.string), 
[16:19:15.419]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:15.419]                                 base::R.version$platform, 8 * 
[16:19:15.419]                                   base::.Machine$sizeof.pointer), 
[16:19:15.419]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:15.419]                                 "release", "version")], collapse = " "), 
[16:19:15.419]                               hostname = base::Sys.info()[["nodename"]])
[16:19:15.419]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:15.419]                               info)
[16:19:15.419]                             info <- base::paste(info, collapse = "; ")
[16:19:15.419]                             if (!has_future) {
[16:19:15.419]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:15.419]                                 info)
[16:19:15.419]                             }
[16:19:15.419]                             else {
[16:19:15.419]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:15.419]                                 info, version)
[16:19:15.419]                             }
[16:19:15.419]                             base::stop(msg)
[16:19:15.419]                           }
[16:19:15.419]                         })
[16:19:15.419]                       }
[16:19:15.419]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:15.419]                       base::options(mc.cores = 1L)
[16:19:15.419]                     }
[16:19:15.419]                     base::local({
[16:19:15.419]                       for (pkg in "future.apply") {
[16:19:15.419]                         base::loadNamespace(pkg)
[16:19:15.419]                         base::library(pkg, character.only = TRUE)
[16:19:15.419]                       }
[16:19:15.419]                     })
[16:19:15.419]                   }
[16:19:15.419]                   ...future.strategy.old <- future::plan("list")
[16:19:15.419]                   options(future.plan = NULL)
[16:19:15.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:15.419]                 }
[16:19:15.419]                 ...future.workdir <- getwd()
[16:19:15.419]             }
[16:19:15.419]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:15.419]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:15.419]         }
[16:19:15.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:15.419]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:15.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:15.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:15.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:15.419]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:15.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:15.419]             base::names(...future.oldOptions))
[16:19:15.419]     }
[16:19:15.419]     if (FALSE) {
[16:19:15.419]     }
[16:19:15.419]     else {
[16:19:15.419]         if (TRUE) {
[16:19:15.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:15.419]                 open = "w")
[16:19:15.419]         }
[16:19:15.419]         else {
[16:19:15.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:15.419]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:15.419]         }
[16:19:15.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:15.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:15.419]             base::sink(type = "output", split = FALSE)
[16:19:15.419]             base::close(...future.stdout)
[16:19:15.419]         }, add = TRUE)
[16:19:15.419]     }
[16:19:15.419]     ...future.frame <- base::sys.nframe()
[16:19:15.419]     ...future.conditions <- base::list()
[16:19:15.419]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:15.419]     if (FALSE) {
[16:19:15.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:15.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:15.419]     }
[16:19:15.419]     ...future.result <- base::tryCatch({
[16:19:15.419]         base::withCallingHandlers({
[16:19:15.419]             ...future.value <- base::withVisible(base::local({
[16:19:15.419]                 withCallingHandlers({
[16:19:15.419]                   {
[16:19:15.419]                     do.call(function(...) {
[16:19:15.419]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.419]                       if (!identical(...future.globals.maxSize.org, 
[16:19:15.419]                         ...future.globals.maxSize)) {
[16:19:15.419]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.419]                         on.exit(options(oopts), add = TRUE)
[16:19:15.419]                       }
[16:19:15.419]                       {
[16:19:15.419]                         lapply(seq_along(...future.elements_ii), 
[16:19:15.419]                           FUN = function(jj) {
[16:19:15.419]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.419]                             ...future.FUN(...future.X_jj, ...)
[16:19:15.419]                           })
[16:19:15.419]                       }
[16:19:15.419]                     }, args = future.call.arguments)
[16:19:15.419]                   }
[16:19:15.419]                 }, immediateCondition = function(cond) {
[16:19:15.419]                   save_rds <- function (object, pathname, ...) 
[16:19:15.419]                   {
[16:19:15.419]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:15.419]                     if (file_test("-f", pathname_tmp)) {
[16:19:15.419]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.419]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:15.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.419]                         fi_tmp[["mtime"]])
[16:19:15.419]                     }
[16:19:15.419]                     tryCatch({
[16:19:15.419]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:15.419]                     }, error = function(ex) {
[16:19:15.419]                       msg <- conditionMessage(ex)
[16:19:15.419]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.419]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:15.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.419]                         fi_tmp[["mtime"]], msg)
[16:19:15.419]                       ex$message <- msg
[16:19:15.419]                       stop(ex)
[16:19:15.419]                     })
[16:19:15.419]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:15.419]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:15.419]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:15.419]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.419]                       fi <- file.info(pathname)
[16:19:15.419]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:15.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.419]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:15.419]                         fi[["size"]], fi[["mtime"]])
[16:19:15.419]                       stop(msg)
[16:19:15.419]                     }
[16:19:15.419]                     invisible(pathname)
[16:19:15.419]                   }
[16:19:15.419]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:15.419]                     rootPath = tempdir()) 
[16:19:15.419]                   {
[16:19:15.419]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:15.419]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:15.419]                       tmpdir = path, fileext = ".rds")
[16:19:15.419]                     save_rds(obj, file)
[16:19:15.419]                   }
[16:19:15.419]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:15.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.419]                   {
[16:19:15.419]                     inherits <- base::inherits
[16:19:15.419]                     invokeRestart <- base::invokeRestart
[16:19:15.419]                     is.null <- base::is.null
[16:19:15.419]                     muffled <- FALSE
[16:19:15.419]                     if (inherits(cond, "message")) {
[16:19:15.419]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:15.419]                       if (muffled) 
[16:19:15.419]                         invokeRestart("muffleMessage")
[16:19:15.419]                     }
[16:19:15.419]                     else if (inherits(cond, "warning")) {
[16:19:15.419]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:15.419]                       if (muffled) 
[16:19:15.419]                         invokeRestart("muffleWarning")
[16:19:15.419]                     }
[16:19:15.419]                     else if (inherits(cond, "condition")) {
[16:19:15.419]                       if (!is.null(pattern)) {
[16:19:15.419]                         computeRestarts <- base::computeRestarts
[16:19:15.419]                         grepl <- base::grepl
[16:19:15.419]                         restarts <- computeRestarts(cond)
[16:19:15.419]                         for (restart in restarts) {
[16:19:15.419]                           name <- restart$name
[16:19:15.419]                           if (is.null(name)) 
[16:19:15.419]                             next
[16:19:15.419]                           if (!grepl(pattern, name)) 
[16:19:15.419]                             next
[16:19:15.419]                           invokeRestart(restart)
[16:19:15.419]                           muffled <- TRUE
[16:19:15.419]                           break
[16:19:15.419]                         }
[16:19:15.419]                       }
[16:19:15.419]                     }
[16:19:15.419]                     invisible(muffled)
[16:19:15.419]                   }
[16:19:15.419]                   muffleCondition(cond)
[16:19:15.419]                 })
[16:19:15.419]             }))
[16:19:15.419]             future::FutureResult(value = ...future.value$value, 
[16:19:15.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.419]                   ...future.rng), globalenv = if (FALSE) 
[16:19:15.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:15.419]                     ...future.globalenv.names))
[16:19:15.419]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:15.419]         }, condition = base::local({
[16:19:15.419]             c <- base::c
[16:19:15.419]             inherits <- base::inherits
[16:19:15.419]             invokeRestart <- base::invokeRestart
[16:19:15.419]             length <- base::length
[16:19:15.419]             list <- base::list
[16:19:15.419]             seq.int <- base::seq.int
[16:19:15.419]             signalCondition <- base::signalCondition
[16:19:15.419]             sys.calls <- base::sys.calls
[16:19:15.419]             `[[` <- base::`[[`
[16:19:15.419]             `+` <- base::`+`
[16:19:15.419]             `<<-` <- base::`<<-`
[16:19:15.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:15.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:15.419]                   3L)]
[16:19:15.419]             }
[16:19:15.419]             function(cond) {
[16:19:15.419]                 is_error <- inherits(cond, "error")
[16:19:15.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:15.419]                   NULL)
[16:19:15.419]                 if (is_error) {
[16:19:15.419]                   sessionInformation <- function() {
[16:19:15.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:15.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:15.419]                       search = base::search(), system = base::Sys.info())
[16:19:15.419]                   }
[16:19:15.419]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:15.419]                     cond$call), session = sessionInformation(), 
[16:19:15.419]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:15.419]                   signalCondition(cond)
[16:19:15.419]                 }
[16:19:15.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:15.419]                 "immediateCondition"))) {
[16:19:15.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:15.419]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:15.419]                   if (TRUE && !signal) {
[16:19:15.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.419]                     {
[16:19:15.419]                       inherits <- base::inherits
[16:19:15.419]                       invokeRestart <- base::invokeRestart
[16:19:15.419]                       is.null <- base::is.null
[16:19:15.419]                       muffled <- FALSE
[16:19:15.419]                       if (inherits(cond, "message")) {
[16:19:15.419]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.419]                         if (muffled) 
[16:19:15.419]                           invokeRestart("muffleMessage")
[16:19:15.419]                       }
[16:19:15.419]                       else if (inherits(cond, "warning")) {
[16:19:15.419]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.419]                         if (muffled) 
[16:19:15.419]                           invokeRestart("muffleWarning")
[16:19:15.419]                       }
[16:19:15.419]                       else if (inherits(cond, "condition")) {
[16:19:15.419]                         if (!is.null(pattern)) {
[16:19:15.419]                           computeRestarts <- base::computeRestarts
[16:19:15.419]                           grepl <- base::grepl
[16:19:15.419]                           restarts <- computeRestarts(cond)
[16:19:15.419]                           for (restart in restarts) {
[16:19:15.419]                             name <- restart$name
[16:19:15.419]                             if (is.null(name)) 
[16:19:15.419]                               next
[16:19:15.419]                             if (!grepl(pattern, name)) 
[16:19:15.419]                               next
[16:19:15.419]                             invokeRestart(restart)
[16:19:15.419]                             muffled <- TRUE
[16:19:15.419]                             break
[16:19:15.419]                           }
[16:19:15.419]                         }
[16:19:15.419]                       }
[16:19:15.419]                       invisible(muffled)
[16:19:15.419]                     }
[16:19:15.419]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.419]                   }
[16:19:15.419]                 }
[16:19:15.419]                 else {
[16:19:15.419]                   if (TRUE) {
[16:19:15.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.419]                     {
[16:19:15.419]                       inherits <- base::inherits
[16:19:15.419]                       invokeRestart <- base::invokeRestart
[16:19:15.419]                       is.null <- base::is.null
[16:19:15.419]                       muffled <- FALSE
[16:19:15.419]                       if (inherits(cond, "message")) {
[16:19:15.419]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.419]                         if (muffled) 
[16:19:15.419]                           invokeRestart("muffleMessage")
[16:19:15.419]                       }
[16:19:15.419]                       else if (inherits(cond, "warning")) {
[16:19:15.419]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.419]                         if (muffled) 
[16:19:15.419]                           invokeRestart("muffleWarning")
[16:19:15.419]                       }
[16:19:15.419]                       else if (inherits(cond, "condition")) {
[16:19:15.419]                         if (!is.null(pattern)) {
[16:19:15.419]                           computeRestarts <- base::computeRestarts
[16:19:15.419]                           grepl <- base::grepl
[16:19:15.419]                           restarts <- computeRestarts(cond)
[16:19:15.419]                           for (restart in restarts) {
[16:19:15.419]                             name <- restart$name
[16:19:15.419]                             if (is.null(name)) 
[16:19:15.419]                               next
[16:19:15.419]                             if (!grepl(pattern, name)) 
[16:19:15.419]                               next
[16:19:15.419]                             invokeRestart(restart)
[16:19:15.419]                             muffled <- TRUE
[16:19:15.419]                             break
[16:19:15.419]                           }
[16:19:15.419]                         }
[16:19:15.419]                       }
[16:19:15.419]                       invisible(muffled)
[16:19:15.419]                     }
[16:19:15.419]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.419]                   }
[16:19:15.419]                 }
[16:19:15.419]             }
[16:19:15.419]         }))
[16:19:15.419]     }, error = function(ex) {
[16:19:15.419]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:15.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.419]                 ...future.rng), started = ...future.startTime, 
[16:19:15.419]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:15.419]             version = "1.8"), class = "FutureResult")
[16:19:15.419]     }, finally = {
[16:19:15.419]         if (!identical(...future.workdir, getwd())) 
[16:19:15.419]             setwd(...future.workdir)
[16:19:15.419]         {
[16:19:15.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:15.419]                 ...future.oldOptions$nwarnings <- NULL
[16:19:15.419]             }
[16:19:15.419]             base::options(...future.oldOptions)
[16:19:15.419]             if (.Platform$OS.type == "windows") {
[16:19:15.419]                 old_names <- names(...future.oldEnvVars)
[16:19:15.419]                 envs <- base::Sys.getenv()
[16:19:15.419]                 names <- names(envs)
[16:19:15.419]                 common <- intersect(names, old_names)
[16:19:15.419]                 added <- setdiff(names, old_names)
[16:19:15.419]                 removed <- setdiff(old_names, names)
[16:19:15.419]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:15.419]                   envs[common]]
[16:19:15.419]                 NAMES <- toupper(changed)
[16:19:15.419]                 args <- list()
[16:19:15.419]                 for (kk in seq_along(NAMES)) {
[16:19:15.419]                   name <- changed[[kk]]
[16:19:15.419]                   NAME <- NAMES[[kk]]
[16:19:15.419]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.419]                     next
[16:19:15.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.419]                 }
[16:19:15.419]                 NAMES <- toupper(added)
[16:19:15.419]                 for (kk in seq_along(NAMES)) {
[16:19:15.419]                   name <- added[[kk]]
[16:19:15.419]                   NAME <- NAMES[[kk]]
[16:19:15.419]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.419]                     next
[16:19:15.419]                   args[[name]] <- ""
[16:19:15.419]                 }
[16:19:15.419]                 NAMES <- toupper(removed)
[16:19:15.419]                 for (kk in seq_along(NAMES)) {
[16:19:15.419]                   name <- removed[[kk]]
[16:19:15.419]                   NAME <- NAMES[[kk]]
[16:19:15.419]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.419]                     next
[16:19:15.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.419]                 }
[16:19:15.419]                 if (length(args) > 0) 
[16:19:15.419]                   base::do.call(base::Sys.setenv, args = args)
[16:19:15.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:15.419]             }
[16:19:15.419]             else {
[16:19:15.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:15.419]             }
[16:19:15.419]             {
[16:19:15.419]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:15.419]                   0L) {
[16:19:15.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:15.419]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:15.419]                   base::options(opts)
[16:19:15.419]                 }
[16:19:15.419]                 {
[16:19:15.419]                   {
[16:19:15.419]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:15.419]                     NULL
[16:19:15.419]                   }
[16:19:15.419]                   options(future.plan = NULL)
[16:19:15.419]                   if (is.na(NA_character_)) 
[16:19:15.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:15.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:15.419]                     .init = FALSE)
[16:19:15.419]                 }
[16:19:15.419]             }
[16:19:15.419]         }
[16:19:15.419]     })
[16:19:15.419]     if (TRUE) {
[16:19:15.419]         base::sink(type = "output", split = FALSE)
[16:19:15.419]         if (TRUE) {
[16:19:15.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:15.419]         }
[16:19:15.419]         else {
[16:19:15.419]             ...future.result["stdout"] <- base::list(NULL)
[16:19:15.419]         }
[16:19:15.419]         base::close(...future.stdout)
[16:19:15.419]         ...future.stdout <- NULL
[16:19:15.419]     }
[16:19:15.419]     ...future.result$conditions <- ...future.conditions
[16:19:15.419]     ...future.result$finished <- base::Sys.time()
[16:19:15.419]     ...future.result
[16:19:15.419] }
[16:19:15.421] assign_globals() ...
[16:19:15.421] List of 11
[16:19:15.421]  $ ...future.FUN            :function (x, ...)  
[16:19:15.421]  $ x_FUN                    :function (x)  
[16:19:15.421]  $ times                    : int 2
[16:19:15.421]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.421]  $ stop_if_not              :function (...)  
[16:19:15.421]  $ dim                      : NULL
[16:19:15.421]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:15.421]  $ future.call.arguments    : list()
[16:19:15.421]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.421]  $ ...future.elements_ii    :List of 1
[16:19:15.421]   ..$ : int 1
[16:19:15.421]  $ ...future.seeds_ii       : NULL
[16:19:15.421]  $ ...future.globals.maxSize: NULL
[16:19:15.421]  - attr(*, "where")=List of 11
[16:19:15.421]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:15.421]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:15.421]  - attr(*, "resolved")= logi FALSE
[16:19:15.421]  - attr(*, "total_size")= num 95128
[16:19:15.421]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.421]  - attr(*, "already-done")= logi TRUE
[16:19:15.432] - copied ‘...future.FUN’ to environment
[16:19:15.432] - copied ‘x_FUN’ to environment
[16:19:15.432] - copied ‘times’ to environment
[16:19:15.432] - copied ‘stopf’ to environment
[16:19:15.432] - copied ‘stop_if_not’ to environment
[16:19:15.432] - copied ‘dim’ to environment
[16:19:15.433] - copied ‘valid_types’ to environment
[16:19:15.433] - copied ‘future.call.arguments’ to environment
[16:19:15.433] - copied ‘...future.elements_ii’ to environment
[16:19:15.433] - copied ‘...future.seeds_ii’ to environment
[16:19:15.433] - copied ‘...future.globals.maxSize’ to environment
[16:19:15.433] assign_globals() ... done
[16:19:15.433] requestCore(): workers = 2
[16:19:15.435] MulticoreFuture started
[16:19:15.436] - Launch lazy future ... done
[16:19:15.436] run() for ‘MulticoreFuture’ ... done
[16:19:15.437] Created future:
[16:19:15.437] plan(): Setting new future strategy stack:
[16:19:15.438] List of future strategies:
[16:19:15.438] 1. sequential:
[16:19:15.438]    - args: function (..., envir = parent.frame())
[16:19:15.438]    - tweaked: FALSE
[16:19:15.438]    - call: NULL
[16:19:15.438] plan(): nbrOfWorkers() = 1
[16:19:15.441] plan(): Setting new future strategy stack:
[16:19:15.441] List of future strategies:
[16:19:15.441] 1. multicore:
[16:19:15.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:15.441]    - tweaked: FALSE
[16:19:15.441]    - call: plan(strategy)
[16:19:15.447] plan(): nbrOfWorkers() = 2
[16:19:15.437] MulticoreFuture:
[16:19:15.437] Label: ‘future_vapply-1’
[16:19:15.437] Expression:
[16:19:15.437] {
[16:19:15.437]     do.call(function(...) {
[16:19:15.437]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.437]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.437]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.437]             on.exit(options(oopts), add = TRUE)
[16:19:15.437]         }
[16:19:15.437]         {
[16:19:15.437]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.437]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.437]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.437]             })
[16:19:15.437]         }
[16:19:15.437]     }, args = future.call.arguments)
[16:19:15.437] }
[16:19:15.437] Lazy evaluation: FALSE
[16:19:15.437] Asynchronous evaluation: TRUE
[16:19:15.437] Local evaluation: TRUE
[16:19:15.437] Environment: R_GlobalEnv
[16:19:15.437] Capture standard output: TRUE
[16:19:15.437] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:15.437] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:15.437] Packages: 1 packages (‘future.apply’)
[16:19:15.437] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:15.437] Resolved: FALSE
[16:19:15.437] Value: <not collected>
[16:19:15.437] Conditions captured: <none>
[16:19:15.437] Early signaling: FALSE
[16:19:15.437] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:15.437] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.451] Chunk #1 of 2 ... DONE
[16:19:15.451] Chunk #2 of 2 ...
[16:19:15.451]  - Finding globals in 'X' for chunk #2 ...
[16:19:15.452] getGlobalsAndPackages() ...
[16:19:15.452] Searching for globals...
[16:19:15.453] 
[16:19:15.453] Searching for globals ... DONE
[16:19:15.453] - globals: [0] <none>
[16:19:15.453] getGlobalsAndPackages() ... DONE
[16:19:15.453]    + additional globals found: [n=0] 
[16:19:15.454]    + additional namespaces needed: [n=0] 
[16:19:15.454]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:15.454]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:15.454]  - seeds: <none>
[16:19:15.454]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.455] getGlobalsAndPackages() ...
[16:19:15.455] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.455] Resolving globals: FALSE
[16:19:15.455] Tweak future expression to call with '...' arguments ...
[16:19:15.455] {
[16:19:15.455]     do.call(function(...) {
[16:19:15.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.455]             on.exit(options(oopts), add = TRUE)
[16:19:15.455]         }
[16:19:15.455]         {
[16:19:15.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.455]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.455]             })
[16:19:15.455]         }
[16:19:15.455]     }, args = future.call.arguments)
[16:19:15.455] }
[16:19:15.456] Tweak future expression to call with '...' arguments ... DONE
[16:19:15.457] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:15.457] - packages: [1] ‘future.apply’
[16:19:15.458] getGlobalsAndPackages() ... DONE
[16:19:15.458] run() for ‘Future’ ...
[16:19:15.458] - state: ‘created’
[16:19:15.459] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:15.463] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.463] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:15.464]   - Field: ‘label’
[16:19:15.464]   - Field: ‘local’
[16:19:15.464]   - Field: ‘owner’
[16:19:15.464]   - Field: ‘envir’
[16:19:15.465]   - Field: ‘workers’
[16:19:15.465]   - Field: ‘packages’
[16:19:15.465]   - Field: ‘gc’
[16:19:15.465]   - Field: ‘job’
[16:19:15.465]   - Field: ‘conditions’
[16:19:15.465]   - Field: ‘expr’
[16:19:15.466]   - Field: ‘uuid’
[16:19:15.466]   - Field: ‘seed’
[16:19:15.466]   - Field: ‘version’
[16:19:15.466]   - Field: ‘result’
[16:19:15.466]   - Field: ‘asynchronous’
[16:19:15.466]   - Field: ‘calls’
[16:19:15.466]   - Field: ‘globals’
[16:19:15.467]   - Field: ‘stdout’
[16:19:15.467]   - Field: ‘earlySignal’
[16:19:15.467]   - Field: ‘lazy’
[16:19:15.467]   - Field: ‘state’
[16:19:15.467] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:15.467] - Launch lazy future ...
[16:19:15.468] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:15.468] Packages needed by future strategies (n = 0): <none>
[16:19:15.472] {
[16:19:15.472]     {
[16:19:15.472]         {
[16:19:15.472]             ...future.startTime <- base::Sys.time()
[16:19:15.472]             {
[16:19:15.472]                 {
[16:19:15.472]                   {
[16:19:15.472]                     {
[16:19:15.472]                       {
[16:19:15.472]                         base::local({
[16:19:15.472]                           has_future <- base::requireNamespace("future", 
[16:19:15.472]                             quietly = TRUE)
[16:19:15.472]                           if (has_future) {
[16:19:15.472]                             ns <- base::getNamespace("future")
[16:19:15.472]                             version <- ns[[".package"]][["version"]]
[16:19:15.472]                             if (is.null(version)) 
[16:19:15.472]                               version <- utils::packageVersion("future")
[16:19:15.472]                           }
[16:19:15.472]                           else {
[16:19:15.472]                             version <- NULL
[16:19:15.472]                           }
[16:19:15.472]                           if (!has_future || version < "1.8.0") {
[16:19:15.472]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:15.472]                               "", base::R.version$version.string), 
[16:19:15.472]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:15.472]                                 base::R.version$platform, 8 * 
[16:19:15.472]                                   base::.Machine$sizeof.pointer), 
[16:19:15.472]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:15.472]                                 "release", "version")], collapse = " "), 
[16:19:15.472]                               hostname = base::Sys.info()[["nodename"]])
[16:19:15.472]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:15.472]                               info)
[16:19:15.472]                             info <- base::paste(info, collapse = "; ")
[16:19:15.472]                             if (!has_future) {
[16:19:15.472]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:15.472]                                 info)
[16:19:15.472]                             }
[16:19:15.472]                             else {
[16:19:15.472]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:15.472]                                 info, version)
[16:19:15.472]                             }
[16:19:15.472]                             base::stop(msg)
[16:19:15.472]                           }
[16:19:15.472]                         })
[16:19:15.472]                       }
[16:19:15.472]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:15.472]                       base::options(mc.cores = 1L)
[16:19:15.472]                     }
[16:19:15.472]                     base::local({
[16:19:15.472]                       for (pkg in "future.apply") {
[16:19:15.472]                         base::loadNamespace(pkg)
[16:19:15.472]                         base::library(pkg, character.only = TRUE)
[16:19:15.472]                       }
[16:19:15.472]                     })
[16:19:15.472]                   }
[16:19:15.472]                   ...future.strategy.old <- future::plan("list")
[16:19:15.472]                   options(future.plan = NULL)
[16:19:15.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:15.472]                 }
[16:19:15.472]                 ...future.workdir <- getwd()
[16:19:15.472]             }
[16:19:15.472]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:15.472]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:15.472]         }
[16:19:15.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:15.472]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:15.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:15.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:15.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:15.472]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:15.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:15.472]             base::names(...future.oldOptions))
[16:19:15.472]     }
[16:19:15.472]     if (FALSE) {
[16:19:15.472]     }
[16:19:15.472]     else {
[16:19:15.472]         if (TRUE) {
[16:19:15.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:15.472]                 open = "w")
[16:19:15.472]         }
[16:19:15.472]         else {
[16:19:15.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:15.472]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:15.472]         }
[16:19:15.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:15.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:15.472]             base::sink(type = "output", split = FALSE)
[16:19:15.472]             base::close(...future.stdout)
[16:19:15.472]         }, add = TRUE)
[16:19:15.472]     }
[16:19:15.472]     ...future.frame <- base::sys.nframe()
[16:19:15.472]     ...future.conditions <- base::list()
[16:19:15.472]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:15.472]     if (FALSE) {
[16:19:15.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:15.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:15.472]     }
[16:19:15.472]     ...future.result <- base::tryCatch({
[16:19:15.472]         base::withCallingHandlers({
[16:19:15.472]             ...future.value <- base::withVisible(base::local({
[16:19:15.472]                 withCallingHandlers({
[16:19:15.472]                   {
[16:19:15.472]                     do.call(function(...) {
[16:19:15.472]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.472]                       if (!identical(...future.globals.maxSize.org, 
[16:19:15.472]                         ...future.globals.maxSize)) {
[16:19:15.472]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.472]                         on.exit(options(oopts), add = TRUE)
[16:19:15.472]                       }
[16:19:15.472]                       {
[16:19:15.472]                         lapply(seq_along(...future.elements_ii), 
[16:19:15.472]                           FUN = function(jj) {
[16:19:15.472]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.472]                             ...future.FUN(...future.X_jj, ...)
[16:19:15.472]                           })
[16:19:15.472]                       }
[16:19:15.472]                     }, args = future.call.arguments)
[16:19:15.472]                   }
[16:19:15.472]                 }, immediateCondition = function(cond) {
[16:19:15.472]                   save_rds <- function (object, pathname, ...) 
[16:19:15.472]                   {
[16:19:15.472]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:15.472]                     if (file_test("-f", pathname_tmp)) {
[16:19:15.472]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.472]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:15.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.472]                         fi_tmp[["mtime"]])
[16:19:15.472]                     }
[16:19:15.472]                     tryCatch({
[16:19:15.472]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:15.472]                     }, error = function(ex) {
[16:19:15.472]                       msg <- conditionMessage(ex)
[16:19:15.472]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.472]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:15.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.472]                         fi_tmp[["mtime"]], msg)
[16:19:15.472]                       ex$message <- msg
[16:19:15.472]                       stop(ex)
[16:19:15.472]                     })
[16:19:15.472]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:15.472]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:15.472]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:15.472]                       fi_tmp <- file.info(pathname_tmp)
[16:19:15.472]                       fi <- file.info(pathname)
[16:19:15.472]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:15.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:15.472]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:15.472]                         fi[["size"]], fi[["mtime"]])
[16:19:15.472]                       stop(msg)
[16:19:15.472]                     }
[16:19:15.472]                     invisible(pathname)
[16:19:15.472]                   }
[16:19:15.472]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:15.472]                     rootPath = tempdir()) 
[16:19:15.472]                   {
[16:19:15.472]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:15.472]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:15.472]                       tmpdir = path, fileext = ".rds")
[16:19:15.472]                     save_rds(obj, file)
[16:19:15.472]                   }
[16:19:15.472]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1rxERt/.future/immediateConditions")
[16:19:15.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.472]                   {
[16:19:15.472]                     inherits <- base::inherits
[16:19:15.472]                     invokeRestart <- base::invokeRestart
[16:19:15.472]                     is.null <- base::is.null
[16:19:15.472]                     muffled <- FALSE
[16:19:15.472]                     if (inherits(cond, "message")) {
[16:19:15.472]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:15.472]                       if (muffled) 
[16:19:15.472]                         invokeRestart("muffleMessage")
[16:19:15.472]                     }
[16:19:15.472]                     else if (inherits(cond, "warning")) {
[16:19:15.472]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:15.472]                       if (muffled) 
[16:19:15.472]                         invokeRestart("muffleWarning")
[16:19:15.472]                     }
[16:19:15.472]                     else if (inherits(cond, "condition")) {
[16:19:15.472]                       if (!is.null(pattern)) {
[16:19:15.472]                         computeRestarts <- base::computeRestarts
[16:19:15.472]                         grepl <- base::grepl
[16:19:15.472]                         restarts <- computeRestarts(cond)
[16:19:15.472]                         for (restart in restarts) {
[16:19:15.472]                           name <- restart$name
[16:19:15.472]                           if (is.null(name)) 
[16:19:15.472]                             next
[16:19:15.472]                           if (!grepl(pattern, name)) 
[16:19:15.472]                             next
[16:19:15.472]                           invokeRestart(restart)
[16:19:15.472]                           muffled <- TRUE
[16:19:15.472]                           break
[16:19:15.472]                         }
[16:19:15.472]                       }
[16:19:15.472]                     }
[16:19:15.472]                     invisible(muffled)
[16:19:15.472]                   }
[16:19:15.472]                   muffleCondition(cond)
[16:19:15.472]                 })
[16:19:15.472]             }))
[16:19:15.472]             future::FutureResult(value = ...future.value$value, 
[16:19:15.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.472]                   ...future.rng), globalenv = if (FALSE) 
[16:19:15.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:15.472]                     ...future.globalenv.names))
[16:19:15.472]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:15.472]         }, condition = base::local({
[16:19:15.472]             c <- base::c
[16:19:15.472]             inherits <- base::inherits
[16:19:15.472]             invokeRestart <- base::invokeRestart
[16:19:15.472]             length <- base::length
[16:19:15.472]             list <- base::list
[16:19:15.472]             seq.int <- base::seq.int
[16:19:15.472]             signalCondition <- base::signalCondition
[16:19:15.472]             sys.calls <- base::sys.calls
[16:19:15.472]             `[[` <- base::`[[`
[16:19:15.472]             `+` <- base::`+`
[16:19:15.472]             `<<-` <- base::`<<-`
[16:19:15.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:15.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:15.472]                   3L)]
[16:19:15.472]             }
[16:19:15.472]             function(cond) {
[16:19:15.472]                 is_error <- inherits(cond, "error")
[16:19:15.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:15.472]                   NULL)
[16:19:15.472]                 if (is_error) {
[16:19:15.472]                   sessionInformation <- function() {
[16:19:15.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:15.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:15.472]                       search = base::search(), system = base::Sys.info())
[16:19:15.472]                   }
[16:19:15.472]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:15.472]                     cond$call), session = sessionInformation(), 
[16:19:15.472]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:15.472]                   signalCondition(cond)
[16:19:15.472]                 }
[16:19:15.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:15.472]                 "immediateCondition"))) {
[16:19:15.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:15.472]                   ...future.conditions[[length(...future.conditions) + 
[16:19:15.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:15.472]                   if (TRUE && !signal) {
[16:19:15.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.472]                     {
[16:19:15.472]                       inherits <- base::inherits
[16:19:15.472]                       invokeRestart <- base::invokeRestart
[16:19:15.472]                       is.null <- base::is.null
[16:19:15.472]                       muffled <- FALSE
[16:19:15.472]                       if (inherits(cond, "message")) {
[16:19:15.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.472]                         if (muffled) 
[16:19:15.472]                           invokeRestart("muffleMessage")
[16:19:15.472]                       }
[16:19:15.472]                       else if (inherits(cond, "warning")) {
[16:19:15.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.472]                         if (muffled) 
[16:19:15.472]                           invokeRestart("muffleWarning")
[16:19:15.472]                       }
[16:19:15.472]                       else if (inherits(cond, "condition")) {
[16:19:15.472]                         if (!is.null(pattern)) {
[16:19:15.472]                           computeRestarts <- base::computeRestarts
[16:19:15.472]                           grepl <- base::grepl
[16:19:15.472]                           restarts <- computeRestarts(cond)
[16:19:15.472]                           for (restart in restarts) {
[16:19:15.472]                             name <- restart$name
[16:19:15.472]                             if (is.null(name)) 
[16:19:15.472]                               next
[16:19:15.472]                             if (!grepl(pattern, name)) 
[16:19:15.472]                               next
[16:19:15.472]                             invokeRestart(restart)
[16:19:15.472]                             muffled <- TRUE
[16:19:15.472]                             break
[16:19:15.472]                           }
[16:19:15.472]                         }
[16:19:15.472]                       }
[16:19:15.472]                       invisible(muffled)
[16:19:15.472]                     }
[16:19:15.472]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.472]                   }
[16:19:15.472]                 }
[16:19:15.472]                 else {
[16:19:15.472]                   if (TRUE) {
[16:19:15.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:15.472]                     {
[16:19:15.472]                       inherits <- base::inherits
[16:19:15.472]                       invokeRestart <- base::invokeRestart
[16:19:15.472]                       is.null <- base::is.null
[16:19:15.472]                       muffled <- FALSE
[16:19:15.472]                       if (inherits(cond, "message")) {
[16:19:15.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:15.472]                         if (muffled) 
[16:19:15.472]                           invokeRestart("muffleMessage")
[16:19:15.472]                       }
[16:19:15.472]                       else if (inherits(cond, "warning")) {
[16:19:15.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:15.472]                         if (muffled) 
[16:19:15.472]                           invokeRestart("muffleWarning")
[16:19:15.472]                       }
[16:19:15.472]                       else if (inherits(cond, "condition")) {
[16:19:15.472]                         if (!is.null(pattern)) {
[16:19:15.472]                           computeRestarts <- base::computeRestarts
[16:19:15.472]                           grepl <- base::grepl
[16:19:15.472]                           restarts <- computeRestarts(cond)
[16:19:15.472]                           for (restart in restarts) {
[16:19:15.472]                             name <- restart$name
[16:19:15.472]                             if (is.null(name)) 
[16:19:15.472]                               next
[16:19:15.472]                             if (!grepl(pattern, name)) 
[16:19:15.472]                               next
[16:19:15.472]                             invokeRestart(restart)
[16:19:15.472]                             muffled <- TRUE
[16:19:15.472]                             break
[16:19:15.472]                           }
[16:19:15.472]                         }
[16:19:15.472]                       }
[16:19:15.472]                       invisible(muffled)
[16:19:15.472]                     }
[16:19:15.472]                     muffleCondition(cond, pattern = "^muffle")
[16:19:15.472]                   }
[16:19:15.472]                 }
[16:19:15.472]             }
[16:19:15.472]         }))
[16:19:15.472]     }, error = function(ex) {
[16:19:15.472]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:15.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:15.472]                 ...future.rng), started = ...future.startTime, 
[16:19:15.472]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:15.472]             version = "1.8"), class = "FutureResult")
[16:19:15.472]     }, finally = {
[16:19:15.472]         if (!identical(...future.workdir, getwd())) 
[16:19:15.472]             setwd(...future.workdir)
[16:19:15.472]         {
[16:19:15.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:15.472]                 ...future.oldOptions$nwarnings <- NULL
[16:19:15.472]             }
[16:19:15.472]             base::options(...future.oldOptions)
[16:19:15.472]             if (.Platform$OS.type == "windows") {
[16:19:15.472]                 old_names <- names(...future.oldEnvVars)
[16:19:15.472]                 envs <- base::Sys.getenv()
[16:19:15.472]                 names <- names(envs)
[16:19:15.472]                 common <- intersect(names, old_names)
[16:19:15.472]                 added <- setdiff(names, old_names)
[16:19:15.472]                 removed <- setdiff(old_names, names)
[16:19:15.472]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:15.472]                   envs[common]]
[16:19:15.472]                 NAMES <- toupper(changed)
[16:19:15.472]                 args <- list()
[16:19:15.472]                 for (kk in seq_along(NAMES)) {
[16:19:15.472]                   name <- changed[[kk]]
[16:19:15.472]                   NAME <- NAMES[[kk]]
[16:19:15.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.472]                     next
[16:19:15.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.472]                 }
[16:19:15.472]                 NAMES <- toupper(added)
[16:19:15.472]                 for (kk in seq_along(NAMES)) {
[16:19:15.472]                   name <- added[[kk]]
[16:19:15.472]                   NAME <- NAMES[[kk]]
[16:19:15.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.472]                     next
[16:19:15.472]                   args[[name]] <- ""
[16:19:15.472]                 }
[16:19:15.472]                 NAMES <- toupper(removed)
[16:19:15.472]                 for (kk in seq_along(NAMES)) {
[16:19:15.472]                   name <- removed[[kk]]
[16:19:15.472]                   NAME <- NAMES[[kk]]
[16:19:15.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:15.472]                     next
[16:19:15.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:15.472]                 }
[16:19:15.472]                 if (length(args) > 0) 
[16:19:15.472]                   base::do.call(base::Sys.setenv, args = args)
[16:19:15.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:15.472]             }
[16:19:15.472]             else {
[16:19:15.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:15.472]             }
[16:19:15.472]             {
[16:19:15.472]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:15.472]                   0L) {
[16:19:15.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:15.472]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:15.472]                   base::options(opts)
[16:19:15.472]                 }
[16:19:15.472]                 {
[16:19:15.472]                   {
[16:19:15.472]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:15.472]                     NULL
[16:19:15.472]                   }
[16:19:15.472]                   options(future.plan = NULL)
[16:19:15.472]                   if (is.na(NA_character_)) 
[16:19:15.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:15.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:15.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:15.472]                     .init = FALSE)
[16:19:15.472]                 }
[16:19:15.472]             }
[16:19:15.472]         }
[16:19:15.472]     })
[16:19:15.472]     if (TRUE) {
[16:19:15.472]         base::sink(type = "output", split = FALSE)
[16:19:15.472]         if (TRUE) {
[16:19:15.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:15.472]         }
[16:19:15.472]         else {
[16:19:15.472]             ...future.result["stdout"] <- base::list(NULL)
[16:19:15.472]         }
[16:19:15.472]         base::close(...future.stdout)
[16:19:15.472]         ...future.stdout <- NULL
[16:19:15.472]     }
[16:19:15.472]     ...future.result$conditions <- ...future.conditions
[16:19:15.472]     ...future.result$finished <- base::Sys.time()
[16:19:15.472]     ...future.result
[16:19:15.472] }
[16:19:15.476] assign_globals() ...
[16:19:15.476] List of 11
[16:19:15.476]  $ ...future.FUN            :function (x, ...)  
[16:19:15.476]  $ x_FUN                    :function (x)  
[16:19:15.476]  $ times                    : int 2
[16:19:15.476]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:15.476]  $ stop_if_not              :function (...)  
[16:19:15.476]  $ dim                      : NULL
[16:19:15.476]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:19:15.476]  $ future.call.arguments    : list()
[16:19:15.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:15.476]  $ ...future.elements_ii    :List of 2
[16:19:15.476]   ..$ : int 2
[16:19:15.476]   ..$ : int 3
[16:19:15.476]  $ ...future.seeds_ii       : NULL
[16:19:15.476]  $ ...future.globals.maxSize: NULL
[16:19:15.476]  - attr(*, "where")=List of 11
[16:19:15.476]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ times                    :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:15.476]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:15.476]  - attr(*, "resolved")= logi FALSE
[16:19:15.476]  - attr(*, "total_size")= num 95128
[16:19:15.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:15.476]  - attr(*, "already-done")= logi TRUE
[16:19:15.489] - copied ‘...future.FUN’ to environment
[16:19:15.489] - copied ‘x_FUN’ to environment
[16:19:15.489] - copied ‘times’ to environment
[16:19:15.489] - copied ‘stopf’ to environment
[16:19:15.489] - copied ‘stop_if_not’ to environment
[16:19:15.490] - copied ‘dim’ to environment
[16:19:15.490] - copied ‘valid_types’ to environment
[16:19:15.490] - copied ‘future.call.arguments’ to environment
[16:19:15.490] - copied ‘...future.elements_ii’ to environment
[16:19:15.490] - copied ‘...future.seeds_ii’ to environment
[16:19:15.490] - copied ‘...future.globals.maxSize’ to environment
[16:19:15.490] assign_globals() ... done
[16:19:15.490] requestCore(): workers = 2
[16:19:15.493] MulticoreFuture started
[16:19:15.493] - Launch lazy future ... done
[16:19:15.493] run() for ‘MulticoreFuture’ ... done
[16:19:15.494] Created future:
[16:19:15.494] plan(): Setting new future strategy stack:
[16:19:15.495] List of future strategies:
[16:19:15.495] 1. sequential:
[16:19:15.495]    - args: function (..., envir = parent.frame())
[16:19:15.495]    - tweaked: FALSE
[16:19:15.495]    - call: NULL
[16:19:15.495] plan(): nbrOfWorkers() = 1
[16:19:15.498] plan(): Setting new future strategy stack:
[16:19:15.498] List of future strategies:
[16:19:15.498] 1. multicore:
[16:19:15.498]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:15.498]    - tweaked: FALSE
[16:19:15.498]    - call: plan(strategy)
[16:19:15.504] plan(): nbrOfWorkers() = 2
[16:19:15.494] MulticoreFuture:
[16:19:15.494] Label: ‘future_vapply-2’
[16:19:15.494] Expression:
[16:19:15.494] {
[16:19:15.494]     do.call(function(...) {
[16:19:15.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:15.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:15.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:15.494]             on.exit(options(oopts), add = TRUE)
[16:19:15.494]         }
[16:19:15.494]         {
[16:19:15.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:15.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:15.494]                 ...future.FUN(...future.X_jj, ...)
[16:19:15.494]             })
[16:19:15.494]         }
[16:19:15.494]     }, args = future.call.arguments)
[16:19:15.494] }
[16:19:15.494] Lazy evaluation: FALSE
[16:19:15.494] Asynchronous evaluation: TRUE
[16:19:15.494] Local evaluation: TRUE
[16:19:15.494] Environment: R_GlobalEnv
[16:19:15.494] Capture standard output: TRUE
[16:19:15.494] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:15.494] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:15.494] Packages: 1 packages (‘future.apply’)
[16:19:15.494] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:15.494] Resolved: FALSE
[16:19:15.494] Value: <not collected>
[16:19:15.494] Conditions captured: <none>
[16:19:15.494] Early signaling: FALSE
[16:19:15.494] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:15.494] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:15.507] Chunk #2 of 2 ... DONE
[16:19:15.508] Launching 2 futures (chunks) ... DONE
[16:19:15.508] Resolving 2 futures (chunks) ...
[16:19:15.508] resolve() on list ...
[16:19:15.508]  recursive: 0
[16:19:15.508]  length: 2
[16:19:15.508] 
[16:19:15.509] Future #1
[16:19:15.509] result() for MulticoreFuture ...
[16:19:15.522] result() for MulticoreFuture ...
[16:19:15.523] result() for MulticoreFuture ... done
[16:19:15.523] signalConditions() ...
[16:19:15.523]  - include = ‘immediateCondition’
[16:19:15.523]  - exclude = 
[16:19:15.524]  - resignal = FALSE
[16:19:15.524]  - Number of conditions: 1
[16:19:15.524] signalConditions() ... done
[16:19:15.524] result() for MulticoreFuture ... done
[16:19:15.525] result() for MulticoreFuture ...
[16:19:15.525] result() for MulticoreFuture ... done
[16:19:15.525] signalConditions() ...
[16:19:15.525]  - include = ‘immediateCondition’
[16:19:15.526]  - exclude = 
[16:19:15.526]  - resignal = FALSE
[16:19:15.526]  - Number of conditions: 1
[16:19:15.526] signalConditions() ... done
[16:19:15.527] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:15.527] - nx: 2
[16:19:15.527] - relay: TRUE
[16:19:15.527] - stdout: TRUE
[16:19:15.527] - signal: TRUE
[16:19:15.528] - resignal: FALSE
[16:19:15.528] - force: TRUE
[16:19:15.528] - relayed: [n=2] FALSE, FALSE
[16:19:15.528] - queued futures: [n=2] FALSE, FALSE
[16:19:15.528]  - until=1
[16:19:15.529]  - relaying element #1
[16:19:15.529] result() for MulticoreFuture ...
[16:19:15.529] result() for MulticoreFuture ... done
[16:19:15.529] result() for MulticoreFuture ...
[16:19:15.529] result() for MulticoreFuture ... done
[16:19:15.529] signalConditions() ...
[16:19:15.530]  - include = ‘immediateCondition’
[16:19:15.530]  - exclude = 
[16:19:15.530]  - resignal = FALSE
[16:19:15.530]  - Number of conditions: 1
[16:19:15.530] signalConditions() ... done
[16:19:15.531] result() for MulticoreFuture ...
[16:19:15.531] result() for MulticoreFuture ... done
[16:19:15.531] signalConditions() ...
[16:19:15.531]  - include = ‘immediateCondition’
[16:19:15.531]  - exclude = 
[16:19:15.531]  - resignal = FALSE
[16:19:15.532]  - Number of conditions: 1
[16:19:15.532] signalConditions() ... done
[16:19:15.532] result() for MulticoreFuture ...
[16:19:15.532] result() for MulticoreFuture ... done
[16:19:15.532] signalConditions() ...
[16:19:15.532]  - include = ‘condition’
[16:19:15.533]  - exclude = ‘immediateCondition’
[16:19:15.533]  - resignal = TRUE
[16:19:15.533]  - Number of conditions: 1
[16:19:15.533]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:19:15.533] signalConditions() ... done
[16:19:15.533] - relayed: [n=2] FALSE, FALSE
[16:19:15.534] - queued futures: [n=2] TRUE, FALSE
[16:19:15.534] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:15.534] plan(): Setting new future strategy stack:
[16:19:15.534] List of future strategies:
[16:19:15.534] 1. sequential:
[16:19:15.534]    - args: function (..., envir = parent.frame())
[16:19:15.534]    - tweaked: FALSE
[16:19:15.534]    - call: plan(sequential)
[16:19:15.535] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:19:15.536] plan(): Setting new future strategy stack:
[16:19:15.536] List of future strategies:
[16:19:15.536] 1. multisession:
[16:19:15.536]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:15.536]    - tweaked: FALSE
[16:19:15.536]    - call: plan(strategy)
[16:19:15.536] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:19:15.537] multisession:
[16:19:15.537] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:15.537] - tweaked: FALSE
[16:19:15.537] - call: plan(strategy)
[16:19:15.544] getGlobalsAndPackages() ...
[16:19:15.544] Not searching for globals
[16:19:15.544] - globals: [0] <none>
[16:19:15.544] getGlobalsAndPackages() ... DONE
[16:19:15.545] [local output] makeClusterPSOCK() ...
[16:19:15.631] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:19:15.633] [local output] Base port: 11201
[16:19:15.633] [local output] Getting setup options for 2 cluster nodes ...
[16:19:15.633] [local output]  - Node 1 of 2 ...
[16:19:15.634] [local output] localMachine=TRUE => revtunnel=FALSE

[16:19:15.634] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp1rxERt/worker.rank=1.parallelly.parent=76056.129182cd96198.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp1rxERt/worker.rank=1.parallelly.parent=76056.129182cd96198.pid")'’
[16:19:15.825] - Possible to infer worker's PID: TRUE
[16:19:15.825] [local output] Rscript port: 11201

[16:19:15.826] [local output]  - Node 2 of 2 ...
[16:19:15.826] [local output] localMachine=TRUE => revtunnel=FALSE

[16:19:15.827] [local output] Rscript port: 11201

[16:19:15.827] [local output] Getting setup options for 2 cluster nodes ... done
[16:19:15.827] [local output]  - Parallel setup requested for some PSOCK nodes
[16:19:15.828] [local output] Setting up PSOCK nodes in parallel
[16:19:15.828] List of 36
[16:19:15.828]  $ worker          : chr "localhost"
[16:19:15.828]   ..- attr(*, "localhost")= logi TRUE
[16:19:15.828]  $ master          : chr "localhost"
[16:19:15.828]  $ port            : int 11201
[16:19:15.828]  $ connectTimeout  : num 120
[16:19:15.828]  $ timeout         : num 2592000
[16:19:15.828]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:19:15.828]  $ homogeneous     : logi TRUE
[16:19:15.828]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:19:15.828]  $ rscript_envs    : NULL
[16:19:15.828]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:19:15.828]  $ rscript_startup : NULL
[16:19:15.828]  $ rscript_sh      : chr "sh"
[16:19:15.828]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:19:15.828]  $ methods         : logi TRUE
[16:19:15.828]  $ socketOptions   : chr "no-delay"
[16:19:15.828]  $ useXDR          : logi FALSE
[16:19:15.828]  $ outfile         : chr "/dev/null"
[16:19:15.828]  $ renice          : int NA
[16:19:15.828]  $ rshcmd          : NULL
[16:19:15.828]  $ user            : chr(0) 
[16:19:15.828]  $ revtunnel       : logi FALSE
[16:19:15.828]  $ rshlogfile      : NULL
[16:19:15.828]  $ rshopts         : chr(0) 
[16:19:15.828]  $ rank            : int 1
[16:19:15.828]  $ manual          : logi FALSE
[16:19:15.828]  $ dryrun          : logi FALSE
[16:19:15.828]  $ quiet           : logi FALSE
[16:19:15.828]  $ setup_strategy  : chr "parallel"
[16:19:15.828]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:19:15.828]  $ pidfile         : chr "/tmp/Rtmp1rxERt/worker.rank=1.parallelly.parent=76056.129182cd96198.pid"
[16:19:15.828]  $ rshcmd_label    : NULL
[16:19:15.828]  $ rsh_call        : NULL
[16:19:15.828]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:19:15.828]  $ localMachine    : logi TRUE
[16:19:15.828]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:19:15.828]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:19:15.828]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:19:15.828]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:19:15.828]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:19:15.828]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:19:15.828]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:19:15.828]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:19:15.828]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:19:15.828]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:19:15.828]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:19:15.828]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:19:15.828]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:19:15.828]  $ arguments       :List of 28
[16:19:15.828]   ..$ worker          : chr "localhost"
[16:19:15.828]   ..$ master          : NULL
[16:19:15.828]   ..$ port            : int 11201
[16:19:15.828]   ..$ connectTimeout  : num 120
[16:19:15.828]   ..$ timeout         : num 2592000
[16:19:15.828]   ..$ rscript         : NULL
[16:19:15.828]   ..$ homogeneous     : NULL
[16:19:15.828]   ..$ rscript_args    : NULL
[16:19:15.828]   ..$ rscript_envs    : NULL
[16:19:15.828]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:19:15.828]   ..$ rscript_startup : NULL
[16:19:15.828]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:19:15.828]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:19:15.828]   ..$ methods         : logi TRUE
[16:19:15.828]   ..$ socketOptions   : chr "no-delay"
[16:19:15.828]   ..$ useXDR          : logi FALSE
[16:19:15.828]   ..$ outfile         : chr "/dev/null"
[16:19:15.828]   ..$ renice          : int NA
[16:19:15.828]   ..$ rshcmd          : NULL
[16:19:15.828]   ..$ user            : NULL
[16:19:15.828]   ..$ revtunnel       : logi NA
[16:19:15.828]   ..$ rshlogfile      : NULL
[16:19:15.828]   ..$ rshopts         : NULL
[16:19:15.828]   ..$ rank            : int 1
[16:19:15.828]   ..$ manual          : logi FALSE
[16:19:15.828]   ..$ dryrun          : logi FALSE
[16:19:15.828]   ..$ quiet           : logi FALSE
[16:19:15.828]   ..$ setup_strategy  : chr "parallel"
[16:19:15.828]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:19:15.846] [local output] System call to launch all workers:
[16:19:15.847] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp1rxERt/worker.rank=1.parallelly.parent=76056.129182cd96198.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11201 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:19:15.847] [local output] Starting PSOCK main server
[16:19:15.852] [local output] Workers launched
[16:19:15.853] [local output] Waiting for workers to connect back
[16:19:15.853]  - [local output] 0 workers out of 2 ready
[16:19:16.113]  - [local output] 0 workers out of 2 ready
[16:19:16.114]  - [local output] 1 workers out of 2 ready
[16:19:16.114]  - [local output] 2 workers out of 2 ready
[16:19:16.114] [local output] Launching of workers completed
[16:19:16.114] [local output] Collecting session information from workers
[16:19:16.115] [local output]  - Worker #1 of 2
[16:19:16.116] [local output]  - Worker #2 of 2
[16:19:16.116] [local output] makeClusterPSOCK() ... done
[16:19:16.127] Packages needed by the future expression (n = 0): <none>
[16:19:16.127] Packages needed by future strategies (n = 0): <none>
[16:19:16.128] {
[16:19:16.128]     {
[16:19:16.128]         {
[16:19:16.128]             ...future.startTime <- base::Sys.time()
[16:19:16.128]             {
[16:19:16.128]                 {
[16:19:16.128]                   {
[16:19:16.128]                     {
[16:19:16.128]                       base::local({
[16:19:16.128]                         has_future <- base::requireNamespace("future", 
[16:19:16.128]                           quietly = TRUE)
[16:19:16.128]                         if (has_future) {
[16:19:16.128]                           ns <- base::getNamespace("future")
[16:19:16.128]                           version <- ns[[".package"]][["version"]]
[16:19:16.128]                           if (is.null(version)) 
[16:19:16.128]                             version <- utils::packageVersion("future")
[16:19:16.128]                         }
[16:19:16.128]                         else {
[16:19:16.128]                           version <- NULL
[16:19:16.128]                         }
[16:19:16.128]                         if (!has_future || version < "1.8.0") {
[16:19:16.128]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:16.128]                             "", base::R.version$version.string), 
[16:19:16.128]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:16.128]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:16.128]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:16.128]                               "release", "version")], collapse = " "), 
[16:19:16.128]                             hostname = base::Sys.info()[["nodename"]])
[16:19:16.128]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:16.128]                             info)
[16:19:16.128]                           info <- base::paste(info, collapse = "; ")
[16:19:16.128]                           if (!has_future) {
[16:19:16.128]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:16.128]                               info)
[16:19:16.128]                           }
[16:19:16.128]                           else {
[16:19:16.128]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:16.128]                               info, version)
[16:19:16.128]                           }
[16:19:16.128]                           base::stop(msg)
[16:19:16.128]                         }
[16:19:16.128]                       })
[16:19:16.128]                     }
[16:19:16.128]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:16.128]                     base::options(mc.cores = 1L)
[16:19:16.128]                   }
[16:19:16.128]                   ...future.strategy.old <- future::plan("list")
[16:19:16.128]                   options(future.plan = NULL)
[16:19:16.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:16.128]                 }
[16:19:16.128]                 ...future.workdir <- getwd()
[16:19:16.128]             }
[16:19:16.128]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:16.128]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:16.128]         }
[16:19:16.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:16.128]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:16.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:16.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:16.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:16.128]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:16.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:16.128]             base::names(...future.oldOptions))
[16:19:16.128]     }
[16:19:16.128]     if (FALSE) {
[16:19:16.128]     }
[16:19:16.128]     else {
[16:19:16.128]         if (TRUE) {
[16:19:16.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:16.128]                 open = "w")
[16:19:16.128]         }
[16:19:16.128]         else {
[16:19:16.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:16.128]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:16.128]         }
[16:19:16.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:16.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:16.128]             base::sink(type = "output", split = FALSE)
[16:19:16.128]             base::close(...future.stdout)
[16:19:16.128]         }, add = TRUE)
[16:19:16.128]     }
[16:19:16.128]     ...future.frame <- base::sys.nframe()
[16:19:16.128]     ...future.conditions <- base::list()
[16:19:16.128]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:16.128]     if (FALSE) {
[16:19:16.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:16.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:16.128]     }
[16:19:16.128]     ...future.result <- base::tryCatch({
[16:19:16.128]         base::withCallingHandlers({
[16:19:16.128]             ...future.value <- base::withVisible(base::local({
[16:19:16.128]                 ...future.makeSendCondition <- base::local({
[16:19:16.128]                   sendCondition <- NULL
[16:19:16.128]                   function(frame = 1L) {
[16:19:16.128]                     if (is.function(sendCondition)) 
[16:19:16.128]                       return(sendCondition)
[16:19:16.128]                     ns <- getNamespace("parallel")
[16:19:16.128]                     if (exists("sendData", mode = "function", 
[16:19:16.128]                       envir = ns)) {
[16:19:16.128]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:16.128]                         envir = ns)
[16:19:16.128]                       envir <- sys.frame(frame)
[16:19:16.128]                       master <- NULL
[16:19:16.128]                       while (!identical(envir, .GlobalEnv) && 
[16:19:16.128]                         !identical(envir, emptyenv())) {
[16:19:16.128]                         if (exists("master", mode = "list", envir = envir, 
[16:19:16.128]                           inherits = FALSE)) {
[16:19:16.128]                           master <- get("master", mode = "list", 
[16:19:16.128]                             envir = envir, inherits = FALSE)
[16:19:16.128]                           if (inherits(master, c("SOCKnode", 
[16:19:16.128]                             "SOCK0node"))) {
[16:19:16.128]                             sendCondition <<- function(cond) {
[16:19:16.128]                               data <- list(type = "VALUE", value = cond, 
[16:19:16.128]                                 success = TRUE)
[16:19:16.128]                               parallel_sendData(master, data)
[16:19:16.128]                             }
[16:19:16.128]                             return(sendCondition)
[16:19:16.128]                           }
[16:19:16.128]                         }
[16:19:16.128]                         frame <- frame + 1L
[16:19:16.128]                         envir <- sys.frame(frame)
[16:19:16.128]                       }
[16:19:16.128]                     }
[16:19:16.128]                     sendCondition <<- function(cond) NULL
[16:19:16.128]                   }
[16:19:16.128]                 })
[16:19:16.128]                 withCallingHandlers({
[16:19:16.128]                   NA
[16:19:16.128]                 }, immediateCondition = function(cond) {
[16:19:16.128]                   sendCondition <- ...future.makeSendCondition()
[16:19:16.128]                   sendCondition(cond)
[16:19:16.128]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.128]                   {
[16:19:16.128]                     inherits <- base::inherits
[16:19:16.128]                     invokeRestart <- base::invokeRestart
[16:19:16.128]                     is.null <- base::is.null
[16:19:16.128]                     muffled <- FALSE
[16:19:16.128]                     if (inherits(cond, "message")) {
[16:19:16.128]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:16.128]                       if (muffled) 
[16:19:16.128]                         invokeRestart("muffleMessage")
[16:19:16.128]                     }
[16:19:16.128]                     else if (inherits(cond, "warning")) {
[16:19:16.128]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:16.128]                       if (muffled) 
[16:19:16.128]                         invokeRestart("muffleWarning")
[16:19:16.128]                     }
[16:19:16.128]                     else if (inherits(cond, "condition")) {
[16:19:16.128]                       if (!is.null(pattern)) {
[16:19:16.128]                         computeRestarts <- base::computeRestarts
[16:19:16.128]                         grepl <- base::grepl
[16:19:16.128]                         restarts <- computeRestarts(cond)
[16:19:16.128]                         for (restart in restarts) {
[16:19:16.128]                           name <- restart$name
[16:19:16.128]                           if (is.null(name)) 
[16:19:16.128]                             next
[16:19:16.128]                           if (!grepl(pattern, name)) 
[16:19:16.128]                             next
[16:19:16.128]                           invokeRestart(restart)
[16:19:16.128]                           muffled <- TRUE
[16:19:16.128]                           break
[16:19:16.128]                         }
[16:19:16.128]                       }
[16:19:16.128]                     }
[16:19:16.128]                     invisible(muffled)
[16:19:16.128]                   }
[16:19:16.128]                   muffleCondition(cond)
[16:19:16.128]                 })
[16:19:16.128]             }))
[16:19:16.128]             future::FutureResult(value = ...future.value$value, 
[16:19:16.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.128]                   ...future.rng), globalenv = if (FALSE) 
[16:19:16.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:16.128]                     ...future.globalenv.names))
[16:19:16.128]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:16.128]         }, condition = base::local({
[16:19:16.128]             c <- base::c
[16:19:16.128]             inherits <- base::inherits
[16:19:16.128]             invokeRestart <- base::invokeRestart
[16:19:16.128]             length <- base::length
[16:19:16.128]             list <- base::list
[16:19:16.128]             seq.int <- base::seq.int
[16:19:16.128]             signalCondition <- base::signalCondition
[16:19:16.128]             sys.calls <- base::sys.calls
[16:19:16.128]             `[[` <- base::`[[`
[16:19:16.128]             `+` <- base::`+`
[16:19:16.128]             `<<-` <- base::`<<-`
[16:19:16.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:16.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:16.128]                   3L)]
[16:19:16.128]             }
[16:19:16.128]             function(cond) {
[16:19:16.128]                 is_error <- inherits(cond, "error")
[16:19:16.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:16.128]                   NULL)
[16:19:16.128]                 if (is_error) {
[16:19:16.128]                   sessionInformation <- function() {
[16:19:16.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:16.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:16.128]                       search = base::search(), system = base::Sys.info())
[16:19:16.128]                   }
[16:19:16.128]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:16.128]                     cond$call), session = sessionInformation(), 
[16:19:16.128]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:16.128]                   signalCondition(cond)
[16:19:16.128]                 }
[16:19:16.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:16.128]                 "immediateCondition"))) {
[16:19:16.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:16.128]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:16.128]                   if (TRUE && !signal) {
[16:19:16.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.128]                     {
[16:19:16.128]                       inherits <- base::inherits
[16:19:16.128]                       invokeRestart <- base::invokeRestart
[16:19:16.128]                       is.null <- base::is.null
[16:19:16.128]                       muffled <- FALSE
[16:19:16.128]                       if (inherits(cond, "message")) {
[16:19:16.128]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.128]                         if (muffled) 
[16:19:16.128]                           invokeRestart("muffleMessage")
[16:19:16.128]                       }
[16:19:16.128]                       else if (inherits(cond, "warning")) {
[16:19:16.128]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.128]                         if (muffled) 
[16:19:16.128]                           invokeRestart("muffleWarning")
[16:19:16.128]                       }
[16:19:16.128]                       else if (inherits(cond, "condition")) {
[16:19:16.128]                         if (!is.null(pattern)) {
[16:19:16.128]                           computeRestarts <- base::computeRestarts
[16:19:16.128]                           grepl <- base::grepl
[16:19:16.128]                           restarts <- computeRestarts(cond)
[16:19:16.128]                           for (restart in restarts) {
[16:19:16.128]                             name <- restart$name
[16:19:16.128]                             if (is.null(name)) 
[16:19:16.128]                               next
[16:19:16.128]                             if (!grepl(pattern, name)) 
[16:19:16.128]                               next
[16:19:16.128]                             invokeRestart(restart)
[16:19:16.128]                             muffled <- TRUE
[16:19:16.128]                             break
[16:19:16.128]                           }
[16:19:16.128]                         }
[16:19:16.128]                       }
[16:19:16.128]                       invisible(muffled)
[16:19:16.128]                     }
[16:19:16.128]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.128]                   }
[16:19:16.128]                 }
[16:19:16.128]                 else {
[16:19:16.128]                   if (TRUE) {
[16:19:16.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.128]                     {
[16:19:16.128]                       inherits <- base::inherits
[16:19:16.128]                       invokeRestart <- base::invokeRestart
[16:19:16.128]                       is.null <- base::is.null
[16:19:16.128]                       muffled <- FALSE
[16:19:16.128]                       if (inherits(cond, "message")) {
[16:19:16.128]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.128]                         if (muffled) 
[16:19:16.128]                           invokeRestart("muffleMessage")
[16:19:16.128]                       }
[16:19:16.128]                       else if (inherits(cond, "warning")) {
[16:19:16.128]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.128]                         if (muffled) 
[16:19:16.128]                           invokeRestart("muffleWarning")
[16:19:16.128]                       }
[16:19:16.128]                       else if (inherits(cond, "condition")) {
[16:19:16.128]                         if (!is.null(pattern)) {
[16:19:16.128]                           computeRestarts <- base::computeRestarts
[16:19:16.128]                           grepl <- base::grepl
[16:19:16.128]                           restarts <- computeRestarts(cond)
[16:19:16.128]                           for (restart in restarts) {
[16:19:16.128]                             name <- restart$name
[16:19:16.128]                             if (is.null(name)) 
[16:19:16.128]                               next
[16:19:16.128]                             if (!grepl(pattern, name)) 
[16:19:16.128]                               next
[16:19:16.128]                             invokeRestart(restart)
[16:19:16.128]                             muffled <- TRUE
[16:19:16.128]                             break
[16:19:16.128]                           }
[16:19:16.128]                         }
[16:19:16.128]                       }
[16:19:16.128]                       invisible(muffled)
[16:19:16.128]                     }
[16:19:16.128]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.128]                   }
[16:19:16.128]                 }
[16:19:16.128]             }
[16:19:16.128]         }))
[16:19:16.128]     }, error = function(ex) {
[16:19:16.128]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:16.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.128]                 ...future.rng), started = ...future.startTime, 
[16:19:16.128]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:16.128]             version = "1.8"), class = "FutureResult")
[16:19:16.128]     }, finally = {
[16:19:16.128]         if (!identical(...future.workdir, getwd())) 
[16:19:16.128]             setwd(...future.workdir)
[16:19:16.128]         {
[16:19:16.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:16.128]                 ...future.oldOptions$nwarnings <- NULL
[16:19:16.128]             }
[16:19:16.128]             base::options(...future.oldOptions)
[16:19:16.128]             if (.Platform$OS.type == "windows") {
[16:19:16.128]                 old_names <- names(...future.oldEnvVars)
[16:19:16.128]                 envs <- base::Sys.getenv()
[16:19:16.128]                 names <- names(envs)
[16:19:16.128]                 common <- intersect(names, old_names)
[16:19:16.128]                 added <- setdiff(names, old_names)
[16:19:16.128]                 removed <- setdiff(old_names, names)
[16:19:16.128]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:16.128]                   envs[common]]
[16:19:16.128]                 NAMES <- toupper(changed)
[16:19:16.128]                 args <- list()
[16:19:16.128]                 for (kk in seq_along(NAMES)) {
[16:19:16.128]                   name <- changed[[kk]]
[16:19:16.128]                   NAME <- NAMES[[kk]]
[16:19:16.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.128]                     next
[16:19:16.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.128]                 }
[16:19:16.128]                 NAMES <- toupper(added)
[16:19:16.128]                 for (kk in seq_along(NAMES)) {
[16:19:16.128]                   name <- added[[kk]]
[16:19:16.128]                   NAME <- NAMES[[kk]]
[16:19:16.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.128]                     next
[16:19:16.128]                   args[[name]] <- ""
[16:19:16.128]                 }
[16:19:16.128]                 NAMES <- toupper(removed)
[16:19:16.128]                 for (kk in seq_along(NAMES)) {
[16:19:16.128]                   name <- removed[[kk]]
[16:19:16.128]                   NAME <- NAMES[[kk]]
[16:19:16.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.128]                     next
[16:19:16.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.128]                 }
[16:19:16.128]                 if (length(args) > 0) 
[16:19:16.128]                   base::do.call(base::Sys.setenv, args = args)
[16:19:16.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:16.128]             }
[16:19:16.128]             else {
[16:19:16.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:16.128]             }
[16:19:16.128]             {
[16:19:16.128]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:16.128]                   0L) {
[16:19:16.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:16.128]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:16.128]                   base::options(opts)
[16:19:16.128]                 }
[16:19:16.128]                 {
[16:19:16.128]                   {
[16:19:16.128]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:16.128]                     NULL
[16:19:16.128]                   }
[16:19:16.128]                   options(future.plan = NULL)
[16:19:16.128]                   if (is.na(NA_character_)) 
[16:19:16.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:16.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:16.128]                     .init = FALSE)
[16:19:16.128]                 }
[16:19:16.128]             }
[16:19:16.128]         }
[16:19:16.128]     })
[16:19:16.128]     if (TRUE) {
[16:19:16.128]         base::sink(type = "output", split = FALSE)
[16:19:16.128]         if (TRUE) {
[16:19:16.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:16.128]         }
[16:19:16.128]         else {
[16:19:16.128]             ...future.result["stdout"] <- base::list(NULL)
[16:19:16.128]         }
[16:19:16.128]         base::close(...future.stdout)
[16:19:16.128]         ...future.stdout <- NULL
[16:19:16.128]     }
[16:19:16.128]     ...future.result$conditions <- ...future.conditions
[16:19:16.128]     ...future.result$finished <- base::Sys.time()
[16:19:16.128]     ...future.result
[16:19:16.128] }
[16:19:16.180] MultisessionFuture started
[16:19:16.181] result() for ClusterFuture ...
[16:19:16.182] receiveMessageFromWorker() for ClusterFuture ...
[16:19:16.182] - Validating connection of MultisessionFuture
[16:19:16.214] - received message: FutureResult
[16:19:16.215] - Received FutureResult
[16:19:16.215] - Erased future from FutureRegistry
[16:19:16.215] result() for ClusterFuture ...
[16:19:16.215] - result already collected: FutureResult
[16:19:16.215] result() for ClusterFuture ... done
[16:19:16.215] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:16.215] result() for ClusterFuture ... done
[16:19:16.216] result() for ClusterFuture ...
[16:19:16.216] - result already collected: FutureResult
[16:19:16.216] result() for ClusterFuture ... done
[16:19:16.216] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:19:16.220] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:19:16.223] future_lapply() ...
[16:19:16.229] Number of chunks: 2
[16:19:16.229] getGlobalsAndPackagesXApply() ...
[16:19:16.230]  - future.globals: TRUE
[16:19:16.230] getGlobalsAndPackages() ...
[16:19:16.230] Searching for globals...
[16:19:16.234] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:16.234] Searching for globals ... DONE
[16:19:16.234] Resolving globals: FALSE
[16:19:16.235] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:19:16.235] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:16.236] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:16.236] - packages: [1] ‘future.apply’
[16:19:16.236] getGlobalsAndPackages() ... DONE
[16:19:16.236]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:16.236]  - needed namespaces: [n=1] ‘future.apply’
[16:19:16.236] Finding globals ... DONE
[16:19:16.236]  - use_args: TRUE
[16:19:16.236]  - Getting '...' globals ...
[16:19:16.237] resolve() on list ...
[16:19:16.237]  recursive: 0
[16:19:16.237]  length: 1
[16:19:16.237]  elements: ‘...’
[16:19:16.237]  length: 0 (resolved future 1)
[16:19:16.238] resolve() on list ... DONE
[16:19:16.238]    - '...' content: [n=0] 
[16:19:16.238] List of 1
[16:19:16.238]  $ ...: list()
[16:19:16.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:16.238]  - attr(*, "where")=List of 1
[16:19:16.238]   ..$ ...:<environment: 0x5619a06970e8> 
[16:19:16.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:16.238]  - attr(*, "resolved")= logi TRUE
[16:19:16.238]  - attr(*, "total_size")= num NA
[16:19:16.241]  - Getting '...' globals ... DONE
[16:19:16.241] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:16.241] List of 8
[16:19:16.241]  $ ...future.FUN:function (x, ...)  
[16:19:16.241]  $ x_FUN        :function (x)  
[16:19:16.241]  $ times        : int 1
[16:19:16.241]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:16.241]  $ stop_if_not  :function (...)  
[16:19:16.241]  $ dim          : NULL
[16:19:16.241]  $ valid_types  : chr "character"
[16:19:16.241]  $ ...          : list()
[16:19:16.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:16.241]  - attr(*, "where")=List of 8
[16:19:16.241]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:16.241]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:16.241]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:16.241]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:16.241]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:16.241]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:16.241]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:16.241]   ..$ ...          :<environment: 0x5619a06970e8> 
[16:19:16.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:16.241]  - attr(*, "resolved")= logi FALSE
[16:19:16.241]  - attr(*, "total_size")= num 94208
[16:19:16.248] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:16.248] getGlobalsAndPackagesXApply() ... DONE
[16:19:16.248] Number of futures (= number of chunks): 2
[16:19:16.249] Launching 2 futures (chunks) ...
[16:19:16.249] Chunk #1 of 2 ...
[16:19:16.249]  - Finding globals in 'X' for chunk #1 ...
[16:19:16.249] getGlobalsAndPackages() ...
[16:19:16.249] Searching for globals...
[16:19:16.249] 
[16:19:16.250] Searching for globals ... DONE
[16:19:16.250] - globals: [0] <none>
[16:19:16.250] getGlobalsAndPackages() ... DONE
[16:19:16.250]    + additional globals found: [n=0] 
[16:19:16.250]    + additional namespaces needed: [n=0] 
[16:19:16.250]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:16.250]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:16.250]  - seeds: <none>
[16:19:16.250]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.251] getGlobalsAndPackages() ...
[16:19:16.251] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.251] Resolving globals: FALSE
[16:19:16.251] Tweak future expression to call with '...' arguments ...
[16:19:16.251] {
[16:19:16.251]     do.call(function(...) {
[16:19:16.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:16.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.251]             on.exit(options(oopts), add = TRUE)
[16:19:16.251]         }
[16:19:16.251]         {
[16:19:16.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:16.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.251]                 ...future.FUN(...future.X_jj, ...)
[16:19:16.251]             })
[16:19:16.251]         }
[16:19:16.251]     }, args = future.call.arguments)
[16:19:16.251] }
[16:19:16.251] Tweak future expression to call with '...' arguments ... DONE
[16:19:16.252] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.252] - packages: [1] ‘future.apply’
[16:19:16.252] getGlobalsAndPackages() ... DONE
[16:19:16.253] run() for ‘Future’ ...
[16:19:16.253] - state: ‘created’
[16:19:16.253] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:16.268] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:16.268] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:16.268]   - Field: ‘node’
[16:19:16.268]   - Field: ‘label’
[16:19:16.268]   - Field: ‘local’
[16:19:16.269]   - Field: ‘owner’
[16:19:16.269]   - Field: ‘envir’
[16:19:16.269]   - Field: ‘workers’
[16:19:16.269]   - Field: ‘packages’
[16:19:16.269]   - Field: ‘gc’
[16:19:16.269]   - Field: ‘conditions’
[16:19:16.269]   - Field: ‘persistent’
[16:19:16.269]   - Field: ‘expr’
[16:19:16.269]   - Field: ‘uuid’
[16:19:16.270]   - Field: ‘seed’
[16:19:16.270]   - Field: ‘version’
[16:19:16.270]   - Field: ‘result’
[16:19:16.270]   - Field: ‘asynchronous’
[16:19:16.270]   - Field: ‘calls’
[16:19:16.270]   - Field: ‘globals’
[16:19:16.270]   - Field: ‘stdout’
[16:19:16.270]   - Field: ‘earlySignal’
[16:19:16.270]   - Field: ‘lazy’
[16:19:16.271]   - Field: ‘state’
[16:19:16.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:16.271] - Launch lazy future ...
[16:19:16.271] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:16.271] Packages needed by future strategies (n = 0): <none>
[16:19:16.272] {
[16:19:16.272]     {
[16:19:16.272]         {
[16:19:16.272]             ...future.startTime <- base::Sys.time()
[16:19:16.272]             {
[16:19:16.272]                 {
[16:19:16.272]                   {
[16:19:16.272]                     {
[16:19:16.272]                       {
[16:19:16.272]                         base::local({
[16:19:16.272]                           has_future <- base::requireNamespace("future", 
[16:19:16.272]                             quietly = TRUE)
[16:19:16.272]                           if (has_future) {
[16:19:16.272]                             ns <- base::getNamespace("future")
[16:19:16.272]                             version <- ns[[".package"]][["version"]]
[16:19:16.272]                             if (is.null(version)) 
[16:19:16.272]                               version <- utils::packageVersion("future")
[16:19:16.272]                           }
[16:19:16.272]                           else {
[16:19:16.272]                             version <- NULL
[16:19:16.272]                           }
[16:19:16.272]                           if (!has_future || version < "1.8.0") {
[16:19:16.272]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:16.272]                               "", base::R.version$version.string), 
[16:19:16.272]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:16.272]                                 base::R.version$platform, 8 * 
[16:19:16.272]                                   base::.Machine$sizeof.pointer), 
[16:19:16.272]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:16.272]                                 "release", "version")], collapse = " "), 
[16:19:16.272]                               hostname = base::Sys.info()[["nodename"]])
[16:19:16.272]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:16.272]                               info)
[16:19:16.272]                             info <- base::paste(info, collapse = "; ")
[16:19:16.272]                             if (!has_future) {
[16:19:16.272]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:16.272]                                 info)
[16:19:16.272]                             }
[16:19:16.272]                             else {
[16:19:16.272]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:16.272]                                 info, version)
[16:19:16.272]                             }
[16:19:16.272]                             base::stop(msg)
[16:19:16.272]                           }
[16:19:16.272]                         })
[16:19:16.272]                       }
[16:19:16.272]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:16.272]                       base::options(mc.cores = 1L)
[16:19:16.272]                     }
[16:19:16.272]                     base::local({
[16:19:16.272]                       for (pkg in "future.apply") {
[16:19:16.272]                         base::loadNamespace(pkg)
[16:19:16.272]                         base::library(pkg, character.only = TRUE)
[16:19:16.272]                       }
[16:19:16.272]                     })
[16:19:16.272]                   }
[16:19:16.272]                   ...future.strategy.old <- future::plan("list")
[16:19:16.272]                   options(future.plan = NULL)
[16:19:16.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:16.272]                 }
[16:19:16.272]                 ...future.workdir <- getwd()
[16:19:16.272]             }
[16:19:16.272]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:16.272]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:16.272]         }
[16:19:16.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:16.272]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:16.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:16.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:16.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:16.272]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:16.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:16.272]             base::names(...future.oldOptions))
[16:19:16.272]     }
[16:19:16.272]     if (FALSE) {
[16:19:16.272]     }
[16:19:16.272]     else {
[16:19:16.272]         if (TRUE) {
[16:19:16.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:16.272]                 open = "w")
[16:19:16.272]         }
[16:19:16.272]         else {
[16:19:16.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:16.272]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:16.272]         }
[16:19:16.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:16.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:16.272]             base::sink(type = "output", split = FALSE)
[16:19:16.272]             base::close(...future.stdout)
[16:19:16.272]         }, add = TRUE)
[16:19:16.272]     }
[16:19:16.272]     ...future.frame <- base::sys.nframe()
[16:19:16.272]     ...future.conditions <- base::list()
[16:19:16.272]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:16.272]     if (FALSE) {
[16:19:16.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:16.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:16.272]     }
[16:19:16.272]     ...future.result <- base::tryCatch({
[16:19:16.272]         base::withCallingHandlers({
[16:19:16.272]             ...future.value <- base::withVisible(base::local({
[16:19:16.272]                 ...future.makeSendCondition <- base::local({
[16:19:16.272]                   sendCondition <- NULL
[16:19:16.272]                   function(frame = 1L) {
[16:19:16.272]                     if (is.function(sendCondition)) 
[16:19:16.272]                       return(sendCondition)
[16:19:16.272]                     ns <- getNamespace("parallel")
[16:19:16.272]                     if (exists("sendData", mode = "function", 
[16:19:16.272]                       envir = ns)) {
[16:19:16.272]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:16.272]                         envir = ns)
[16:19:16.272]                       envir <- sys.frame(frame)
[16:19:16.272]                       master <- NULL
[16:19:16.272]                       while (!identical(envir, .GlobalEnv) && 
[16:19:16.272]                         !identical(envir, emptyenv())) {
[16:19:16.272]                         if (exists("master", mode = "list", envir = envir, 
[16:19:16.272]                           inherits = FALSE)) {
[16:19:16.272]                           master <- get("master", mode = "list", 
[16:19:16.272]                             envir = envir, inherits = FALSE)
[16:19:16.272]                           if (inherits(master, c("SOCKnode", 
[16:19:16.272]                             "SOCK0node"))) {
[16:19:16.272]                             sendCondition <<- function(cond) {
[16:19:16.272]                               data <- list(type = "VALUE", value = cond, 
[16:19:16.272]                                 success = TRUE)
[16:19:16.272]                               parallel_sendData(master, data)
[16:19:16.272]                             }
[16:19:16.272]                             return(sendCondition)
[16:19:16.272]                           }
[16:19:16.272]                         }
[16:19:16.272]                         frame <- frame + 1L
[16:19:16.272]                         envir <- sys.frame(frame)
[16:19:16.272]                       }
[16:19:16.272]                     }
[16:19:16.272]                     sendCondition <<- function(cond) NULL
[16:19:16.272]                   }
[16:19:16.272]                 })
[16:19:16.272]                 withCallingHandlers({
[16:19:16.272]                   {
[16:19:16.272]                     do.call(function(...) {
[16:19:16.272]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.272]                       if (!identical(...future.globals.maxSize.org, 
[16:19:16.272]                         ...future.globals.maxSize)) {
[16:19:16.272]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.272]                         on.exit(options(oopts), add = TRUE)
[16:19:16.272]                       }
[16:19:16.272]                       {
[16:19:16.272]                         lapply(seq_along(...future.elements_ii), 
[16:19:16.272]                           FUN = function(jj) {
[16:19:16.272]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.272]                             ...future.FUN(...future.X_jj, ...)
[16:19:16.272]                           })
[16:19:16.272]                       }
[16:19:16.272]                     }, args = future.call.arguments)
[16:19:16.272]                   }
[16:19:16.272]                 }, immediateCondition = function(cond) {
[16:19:16.272]                   sendCondition <- ...future.makeSendCondition()
[16:19:16.272]                   sendCondition(cond)
[16:19:16.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.272]                   {
[16:19:16.272]                     inherits <- base::inherits
[16:19:16.272]                     invokeRestart <- base::invokeRestart
[16:19:16.272]                     is.null <- base::is.null
[16:19:16.272]                     muffled <- FALSE
[16:19:16.272]                     if (inherits(cond, "message")) {
[16:19:16.272]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:16.272]                       if (muffled) 
[16:19:16.272]                         invokeRestart("muffleMessage")
[16:19:16.272]                     }
[16:19:16.272]                     else if (inherits(cond, "warning")) {
[16:19:16.272]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:16.272]                       if (muffled) 
[16:19:16.272]                         invokeRestart("muffleWarning")
[16:19:16.272]                     }
[16:19:16.272]                     else if (inherits(cond, "condition")) {
[16:19:16.272]                       if (!is.null(pattern)) {
[16:19:16.272]                         computeRestarts <- base::computeRestarts
[16:19:16.272]                         grepl <- base::grepl
[16:19:16.272]                         restarts <- computeRestarts(cond)
[16:19:16.272]                         for (restart in restarts) {
[16:19:16.272]                           name <- restart$name
[16:19:16.272]                           if (is.null(name)) 
[16:19:16.272]                             next
[16:19:16.272]                           if (!grepl(pattern, name)) 
[16:19:16.272]                             next
[16:19:16.272]                           invokeRestart(restart)
[16:19:16.272]                           muffled <- TRUE
[16:19:16.272]                           break
[16:19:16.272]                         }
[16:19:16.272]                       }
[16:19:16.272]                     }
[16:19:16.272]                     invisible(muffled)
[16:19:16.272]                   }
[16:19:16.272]                   muffleCondition(cond)
[16:19:16.272]                 })
[16:19:16.272]             }))
[16:19:16.272]             future::FutureResult(value = ...future.value$value, 
[16:19:16.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.272]                   ...future.rng), globalenv = if (FALSE) 
[16:19:16.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:16.272]                     ...future.globalenv.names))
[16:19:16.272]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:16.272]         }, condition = base::local({
[16:19:16.272]             c <- base::c
[16:19:16.272]             inherits <- base::inherits
[16:19:16.272]             invokeRestart <- base::invokeRestart
[16:19:16.272]             length <- base::length
[16:19:16.272]             list <- base::list
[16:19:16.272]             seq.int <- base::seq.int
[16:19:16.272]             signalCondition <- base::signalCondition
[16:19:16.272]             sys.calls <- base::sys.calls
[16:19:16.272]             `[[` <- base::`[[`
[16:19:16.272]             `+` <- base::`+`
[16:19:16.272]             `<<-` <- base::`<<-`
[16:19:16.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:16.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:16.272]                   3L)]
[16:19:16.272]             }
[16:19:16.272]             function(cond) {
[16:19:16.272]                 is_error <- inherits(cond, "error")
[16:19:16.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:16.272]                   NULL)
[16:19:16.272]                 if (is_error) {
[16:19:16.272]                   sessionInformation <- function() {
[16:19:16.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:16.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:16.272]                       search = base::search(), system = base::Sys.info())
[16:19:16.272]                   }
[16:19:16.272]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:16.272]                     cond$call), session = sessionInformation(), 
[16:19:16.272]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:16.272]                   signalCondition(cond)
[16:19:16.272]                 }
[16:19:16.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:16.272]                 "immediateCondition"))) {
[16:19:16.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:16.272]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:16.272]                   if (TRUE && !signal) {
[16:19:16.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.272]                     {
[16:19:16.272]                       inherits <- base::inherits
[16:19:16.272]                       invokeRestart <- base::invokeRestart
[16:19:16.272]                       is.null <- base::is.null
[16:19:16.272]                       muffled <- FALSE
[16:19:16.272]                       if (inherits(cond, "message")) {
[16:19:16.272]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.272]                         if (muffled) 
[16:19:16.272]                           invokeRestart("muffleMessage")
[16:19:16.272]                       }
[16:19:16.272]                       else if (inherits(cond, "warning")) {
[16:19:16.272]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.272]                         if (muffled) 
[16:19:16.272]                           invokeRestart("muffleWarning")
[16:19:16.272]                       }
[16:19:16.272]                       else if (inherits(cond, "condition")) {
[16:19:16.272]                         if (!is.null(pattern)) {
[16:19:16.272]                           computeRestarts <- base::computeRestarts
[16:19:16.272]                           grepl <- base::grepl
[16:19:16.272]                           restarts <- computeRestarts(cond)
[16:19:16.272]                           for (restart in restarts) {
[16:19:16.272]                             name <- restart$name
[16:19:16.272]                             if (is.null(name)) 
[16:19:16.272]                               next
[16:19:16.272]                             if (!grepl(pattern, name)) 
[16:19:16.272]                               next
[16:19:16.272]                             invokeRestart(restart)
[16:19:16.272]                             muffled <- TRUE
[16:19:16.272]                             break
[16:19:16.272]                           }
[16:19:16.272]                         }
[16:19:16.272]                       }
[16:19:16.272]                       invisible(muffled)
[16:19:16.272]                     }
[16:19:16.272]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.272]                   }
[16:19:16.272]                 }
[16:19:16.272]                 else {
[16:19:16.272]                   if (TRUE) {
[16:19:16.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.272]                     {
[16:19:16.272]                       inherits <- base::inherits
[16:19:16.272]                       invokeRestart <- base::invokeRestart
[16:19:16.272]                       is.null <- base::is.null
[16:19:16.272]                       muffled <- FALSE
[16:19:16.272]                       if (inherits(cond, "message")) {
[16:19:16.272]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.272]                         if (muffled) 
[16:19:16.272]                           invokeRestart("muffleMessage")
[16:19:16.272]                       }
[16:19:16.272]                       else if (inherits(cond, "warning")) {
[16:19:16.272]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.272]                         if (muffled) 
[16:19:16.272]                           invokeRestart("muffleWarning")
[16:19:16.272]                       }
[16:19:16.272]                       else if (inherits(cond, "condition")) {
[16:19:16.272]                         if (!is.null(pattern)) {
[16:19:16.272]                           computeRestarts <- base::computeRestarts
[16:19:16.272]                           grepl <- base::grepl
[16:19:16.272]                           restarts <- computeRestarts(cond)
[16:19:16.272]                           for (restart in restarts) {
[16:19:16.272]                             name <- restart$name
[16:19:16.272]                             if (is.null(name)) 
[16:19:16.272]                               next
[16:19:16.272]                             if (!grepl(pattern, name)) 
[16:19:16.272]                               next
[16:19:16.272]                             invokeRestart(restart)
[16:19:16.272]                             muffled <- TRUE
[16:19:16.272]                             break
[16:19:16.272]                           }
[16:19:16.272]                         }
[16:19:16.272]                       }
[16:19:16.272]                       invisible(muffled)
[16:19:16.272]                     }
[16:19:16.272]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.272]                   }
[16:19:16.272]                 }
[16:19:16.272]             }
[16:19:16.272]         }))
[16:19:16.272]     }, error = function(ex) {
[16:19:16.272]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:16.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.272]                 ...future.rng), started = ...future.startTime, 
[16:19:16.272]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:16.272]             version = "1.8"), class = "FutureResult")
[16:19:16.272]     }, finally = {
[16:19:16.272]         if (!identical(...future.workdir, getwd())) 
[16:19:16.272]             setwd(...future.workdir)
[16:19:16.272]         {
[16:19:16.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:16.272]                 ...future.oldOptions$nwarnings <- NULL
[16:19:16.272]             }
[16:19:16.272]             base::options(...future.oldOptions)
[16:19:16.272]             if (.Platform$OS.type == "windows") {
[16:19:16.272]                 old_names <- names(...future.oldEnvVars)
[16:19:16.272]                 envs <- base::Sys.getenv()
[16:19:16.272]                 names <- names(envs)
[16:19:16.272]                 common <- intersect(names, old_names)
[16:19:16.272]                 added <- setdiff(names, old_names)
[16:19:16.272]                 removed <- setdiff(old_names, names)
[16:19:16.272]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:16.272]                   envs[common]]
[16:19:16.272]                 NAMES <- toupper(changed)
[16:19:16.272]                 args <- list()
[16:19:16.272]                 for (kk in seq_along(NAMES)) {
[16:19:16.272]                   name <- changed[[kk]]
[16:19:16.272]                   NAME <- NAMES[[kk]]
[16:19:16.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.272]                     next
[16:19:16.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.272]                 }
[16:19:16.272]                 NAMES <- toupper(added)
[16:19:16.272]                 for (kk in seq_along(NAMES)) {
[16:19:16.272]                   name <- added[[kk]]
[16:19:16.272]                   NAME <- NAMES[[kk]]
[16:19:16.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.272]                     next
[16:19:16.272]                   args[[name]] <- ""
[16:19:16.272]                 }
[16:19:16.272]                 NAMES <- toupper(removed)
[16:19:16.272]                 for (kk in seq_along(NAMES)) {
[16:19:16.272]                   name <- removed[[kk]]
[16:19:16.272]                   NAME <- NAMES[[kk]]
[16:19:16.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.272]                     next
[16:19:16.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.272]                 }
[16:19:16.272]                 if (length(args) > 0) 
[16:19:16.272]                   base::do.call(base::Sys.setenv, args = args)
[16:19:16.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:16.272]             }
[16:19:16.272]             else {
[16:19:16.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:16.272]             }
[16:19:16.272]             {
[16:19:16.272]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:16.272]                   0L) {
[16:19:16.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:16.272]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:16.272]                   base::options(opts)
[16:19:16.272]                 }
[16:19:16.272]                 {
[16:19:16.272]                   {
[16:19:16.272]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:16.272]                     NULL
[16:19:16.272]                   }
[16:19:16.272]                   options(future.plan = NULL)
[16:19:16.272]                   if (is.na(NA_character_)) 
[16:19:16.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:16.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:16.272]                     .init = FALSE)
[16:19:16.272]                 }
[16:19:16.272]             }
[16:19:16.272]         }
[16:19:16.272]     })
[16:19:16.272]     if (TRUE) {
[16:19:16.272]         base::sink(type = "output", split = FALSE)
[16:19:16.272]         if (TRUE) {
[16:19:16.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:16.272]         }
[16:19:16.272]         else {
[16:19:16.272]             ...future.result["stdout"] <- base::list(NULL)
[16:19:16.272]         }
[16:19:16.272]         base::close(...future.stdout)
[16:19:16.272]         ...future.stdout <- NULL
[16:19:16.272]     }
[16:19:16.272]     ...future.result$conditions <- ...future.conditions
[16:19:16.272]     ...future.result$finished <- base::Sys.time()
[16:19:16.272]     ...future.result
[16:19:16.272] }
[16:19:16.275] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[16:19:16.275] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:16.317] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:16.317] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:19:16.317] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:19:16.318] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:16.318] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:16.318] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:16.360] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:16.361] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:16.404] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:16.405] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:16.405] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:16.405] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[16:19:16.406] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[16:19:16.406] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:16.407] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:16.407] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[16:19:16.407] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[16:19:16.407] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:16.408] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:16.408] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:16.408] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:16.409] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[16:19:16.409] MultisessionFuture started
[16:19:16.409] - Launch lazy future ... done
[16:19:16.410] run() for ‘MultisessionFuture’ ... done
[16:19:16.410] Created future:
[16:19:16.410] MultisessionFuture:
[16:19:16.410] Label: ‘future_vapply-1’
[16:19:16.410] Expression:
[16:19:16.410] {
[16:19:16.410]     do.call(function(...) {
[16:19:16.410]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.410]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:16.410]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.410]             on.exit(options(oopts), add = TRUE)
[16:19:16.410]         }
[16:19:16.410]         {
[16:19:16.410]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:16.410]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.410]                 ...future.FUN(...future.X_jj, ...)
[16:19:16.410]             })
[16:19:16.410]         }
[16:19:16.410]     }, args = future.call.arguments)
[16:19:16.410] }
[16:19:16.410] Lazy evaluation: FALSE
[16:19:16.410] Asynchronous evaluation: TRUE
[16:19:16.410] Local evaluation: TRUE
[16:19:16.410] Environment: R_GlobalEnv
[16:19:16.410] Capture standard output: TRUE
[16:19:16.410] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:16.410] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:16.410] Packages: 1 packages (‘future.apply’)
[16:19:16.410] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:16.410] Resolved: FALSE
[16:19:16.410] Value: <not collected>
[16:19:16.410] Conditions captured: <none>
[16:19:16.410] Early signaling: FALSE
[16:19:16.410] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:16.410] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:16.422] Chunk #1 of 2 ... DONE
[16:19:16.423] Chunk #2 of 2 ...
[16:19:16.423]  - Finding globals in 'X' for chunk #2 ...
[16:19:16.423] getGlobalsAndPackages() ...
[16:19:16.423] Searching for globals...
[16:19:16.423] 
[16:19:16.423] Searching for globals ... DONE
[16:19:16.424] - globals: [0] <none>
[16:19:16.424] getGlobalsAndPackages() ... DONE
[16:19:16.424]    + additional globals found: [n=0] 
[16:19:16.424]    + additional namespaces needed: [n=0] 
[16:19:16.424]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:16.424]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:16.424]  - seeds: <none>
[16:19:16.424]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.425] getGlobalsAndPackages() ...
[16:19:16.425] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.425] Resolving globals: FALSE
[16:19:16.425] Tweak future expression to call with '...' arguments ...
[16:19:16.425] {
[16:19:16.425]     do.call(function(...) {
[16:19:16.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:16.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.425]             on.exit(options(oopts), add = TRUE)
[16:19:16.425]         }
[16:19:16.425]         {
[16:19:16.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:16.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.425]                 ...future.FUN(...future.X_jj, ...)
[16:19:16.425]             })
[16:19:16.425]         }
[16:19:16.425]     }, args = future.call.arguments)
[16:19:16.425] }
[16:19:16.425] Tweak future expression to call with '...' arguments ... DONE
[16:19:16.426] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.426] - packages: [1] ‘future.apply’
[16:19:16.426] getGlobalsAndPackages() ... DONE
[16:19:16.427] run() for ‘Future’ ...
[16:19:16.427] - state: ‘created’
[16:19:16.427] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:16.442] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:16.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:16.442]   - Field: ‘node’
[16:19:16.442]   - Field: ‘label’
[16:19:16.443]   - Field: ‘local’
[16:19:16.443]   - Field: ‘owner’
[16:19:16.443]   - Field: ‘envir’
[16:19:16.443]   - Field: ‘workers’
[16:19:16.443]   - Field: ‘packages’
[16:19:16.443]   - Field: ‘gc’
[16:19:16.443]   - Field: ‘conditions’
[16:19:16.443]   - Field: ‘persistent’
[16:19:16.443]   - Field: ‘expr’
[16:19:16.443]   - Field: ‘uuid’
[16:19:16.444]   - Field: ‘seed’
[16:19:16.444]   - Field: ‘version’
[16:19:16.444]   - Field: ‘result’
[16:19:16.444]   - Field: ‘asynchronous’
[16:19:16.444]   - Field: ‘calls’
[16:19:16.444]   - Field: ‘globals’
[16:19:16.444]   - Field: ‘stdout’
[16:19:16.444]   - Field: ‘earlySignal’
[16:19:16.445]   - Field: ‘lazy’
[16:19:16.445]   - Field: ‘state’
[16:19:16.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:16.445] - Launch lazy future ...
[16:19:16.445] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:16.445] Packages needed by future strategies (n = 0): <none>
[16:19:16.446] {
[16:19:16.446]     {
[16:19:16.446]         {
[16:19:16.446]             ...future.startTime <- base::Sys.time()
[16:19:16.446]             {
[16:19:16.446]                 {
[16:19:16.446]                   {
[16:19:16.446]                     {
[16:19:16.446]                       {
[16:19:16.446]                         base::local({
[16:19:16.446]                           has_future <- base::requireNamespace("future", 
[16:19:16.446]                             quietly = TRUE)
[16:19:16.446]                           if (has_future) {
[16:19:16.446]                             ns <- base::getNamespace("future")
[16:19:16.446]                             version <- ns[[".package"]][["version"]]
[16:19:16.446]                             if (is.null(version)) 
[16:19:16.446]                               version <- utils::packageVersion("future")
[16:19:16.446]                           }
[16:19:16.446]                           else {
[16:19:16.446]                             version <- NULL
[16:19:16.446]                           }
[16:19:16.446]                           if (!has_future || version < "1.8.0") {
[16:19:16.446]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:16.446]                               "", base::R.version$version.string), 
[16:19:16.446]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:16.446]                                 base::R.version$platform, 8 * 
[16:19:16.446]                                   base::.Machine$sizeof.pointer), 
[16:19:16.446]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:16.446]                                 "release", "version")], collapse = " "), 
[16:19:16.446]                               hostname = base::Sys.info()[["nodename"]])
[16:19:16.446]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:16.446]                               info)
[16:19:16.446]                             info <- base::paste(info, collapse = "; ")
[16:19:16.446]                             if (!has_future) {
[16:19:16.446]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:16.446]                                 info)
[16:19:16.446]                             }
[16:19:16.446]                             else {
[16:19:16.446]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:16.446]                                 info, version)
[16:19:16.446]                             }
[16:19:16.446]                             base::stop(msg)
[16:19:16.446]                           }
[16:19:16.446]                         })
[16:19:16.446]                       }
[16:19:16.446]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:16.446]                       base::options(mc.cores = 1L)
[16:19:16.446]                     }
[16:19:16.446]                     base::local({
[16:19:16.446]                       for (pkg in "future.apply") {
[16:19:16.446]                         base::loadNamespace(pkg)
[16:19:16.446]                         base::library(pkg, character.only = TRUE)
[16:19:16.446]                       }
[16:19:16.446]                     })
[16:19:16.446]                   }
[16:19:16.446]                   ...future.strategy.old <- future::plan("list")
[16:19:16.446]                   options(future.plan = NULL)
[16:19:16.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:16.446]                 }
[16:19:16.446]                 ...future.workdir <- getwd()
[16:19:16.446]             }
[16:19:16.446]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:16.446]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:16.446]         }
[16:19:16.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:16.446]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:16.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:16.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:16.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:16.446]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:16.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:16.446]             base::names(...future.oldOptions))
[16:19:16.446]     }
[16:19:16.446]     if (FALSE) {
[16:19:16.446]     }
[16:19:16.446]     else {
[16:19:16.446]         if (TRUE) {
[16:19:16.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:16.446]                 open = "w")
[16:19:16.446]         }
[16:19:16.446]         else {
[16:19:16.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:16.446]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:16.446]         }
[16:19:16.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:16.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:16.446]             base::sink(type = "output", split = FALSE)
[16:19:16.446]             base::close(...future.stdout)
[16:19:16.446]         }, add = TRUE)
[16:19:16.446]     }
[16:19:16.446]     ...future.frame <- base::sys.nframe()
[16:19:16.446]     ...future.conditions <- base::list()
[16:19:16.446]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:16.446]     if (FALSE) {
[16:19:16.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:16.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:16.446]     }
[16:19:16.446]     ...future.result <- base::tryCatch({
[16:19:16.446]         base::withCallingHandlers({
[16:19:16.446]             ...future.value <- base::withVisible(base::local({
[16:19:16.446]                 ...future.makeSendCondition <- base::local({
[16:19:16.446]                   sendCondition <- NULL
[16:19:16.446]                   function(frame = 1L) {
[16:19:16.446]                     if (is.function(sendCondition)) 
[16:19:16.446]                       return(sendCondition)
[16:19:16.446]                     ns <- getNamespace("parallel")
[16:19:16.446]                     if (exists("sendData", mode = "function", 
[16:19:16.446]                       envir = ns)) {
[16:19:16.446]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:16.446]                         envir = ns)
[16:19:16.446]                       envir <- sys.frame(frame)
[16:19:16.446]                       master <- NULL
[16:19:16.446]                       while (!identical(envir, .GlobalEnv) && 
[16:19:16.446]                         !identical(envir, emptyenv())) {
[16:19:16.446]                         if (exists("master", mode = "list", envir = envir, 
[16:19:16.446]                           inherits = FALSE)) {
[16:19:16.446]                           master <- get("master", mode = "list", 
[16:19:16.446]                             envir = envir, inherits = FALSE)
[16:19:16.446]                           if (inherits(master, c("SOCKnode", 
[16:19:16.446]                             "SOCK0node"))) {
[16:19:16.446]                             sendCondition <<- function(cond) {
[16:19:16.446]                               data <- list(type = "VALUE", value = cond, 
[16:19:16.446]                                 success = TRUE)
[16:19:16.446]                               parallel_sendData(master, data)
[16:19:16.446]                             }
[16:19:16.446]                             return(sendCondition)
[16:19:16.446]                           }
[16:19:16.446]                         }
[16:19:16.446]                         frame <- frame + 1L
[16:19:16.446]                         envir <- sys.frame(frame)
[16:19:16.446]                       }
[16:19:16.446]                     }
[16:19:16.446]                     sendCondition <<- function(cond) NULL
[16:19:16.446]                   }
[16:19:16.446]                 })
[16:19:16.446]                 withCallingHandlers({
[16:19:16.446]                   {
[16:19:16.446]                     do.call(function(...) {
[16:19:16.446]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.446]                       if (!identical(...future.globals.maxSize.org, 
[16:19:16.446]                         ...future.globals.maxSize)) {
[16:19:16.446]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.446]                         on.exit(options(oopts), add = TRUE)
[16:19:16.446]                       }
[16:19:16.446]                       {
[16:19:16.446]                         lapply(seq_along(...future.elements_ii), 
[16:19:16.446]                           FUN = function(jj) {
[16:19:16.446]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.446]                             ...future.FUN(...future.X_jj, ...)
[16:19:16.446]                           })
[16:19:16.446]                       }
[16:19:16.446]                     }, args = future.call.arguments)
[16:19:16.446]                   }
[16:19:16.446]                 }, immediateCondition = function(cond) {
[16:19:16.446]                   sendCondition <- ...future.makeSendCondition()
[16:19:16.446]                   sendCondition(cond)
[16:19:16.446]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.446]                   {
[16:19:16.446]                     inherits <- base::inherits
[16:19:16.446]                     invokeRestart <- base::invokeRestart
[16:19:16.446]                     is.null <- base::is.null
[16:19:16.446]                     muffled <- FALSE
[16:19:16.446]                     if (inherits(cond, "message")) {
[16:19:16.446]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:16.446]                       if (muffled) 
[16:19:16.446]                         invokeRestart("muffleMessage")
[16:19:16.446]                     }
[16:19:16.446]                     else if (inherits(cond, "warning")) {
[16:19:16.446]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:16.446]                       if (muffled) 
[16:19:16.446]                         invokeRestart("muffleWarning")
[16:19:16.446]                     }
[16:19:16.446]                     else if (inherits(cond, "condition")) {
[16:19:16.446]                       if (!is.null(pattern)) {
[16:19:16.446]                         computeRestarts <- base::computeRestarts
[16:19:16.446]                         grepl <- base::grepl
[16:19:16.446]                         restarts <- computeRestarts(cond)
[16:19:16.446]                         for (restart in restarts) {
[16:19:16.446]                           name <- restart$name
[16:19:16.446]                           if (is.null(name)) 
[16:19:16.446]                             next
[16:19:16.446]                           if (!grepl(pattern, name)) 
[16:19:16.446]                             next
[16:19:16.446]                           invokeRestart(restart)
[16:19:16.446]                           muffled <- TRUE
[16:19:16.446]                           break
[16:19:16.446]                         }
[16:19:16.446]                       }
[16:19:16.446]                     }
[16:19:16.446]                     invisible(muffled)
[16:19:16.446]                   }
[16:19:16.446]                   muffleCondition(cond)
[16:19:16.446]                 })
[16:19:16.446]             }))
[16:19:16.446]             future::FutureResult(value = ...future.value$value, 
[16:19:16.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.446]                   ...future.rng), globalenv = if (FALSE) 
[16:19:16.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:16.446]                     ...future.globalenv.names))
[16:19:16.446]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:16.446]         }, condition = base::local({
[16:19:16.446]             c <- base::c
[16:19:16.446]             inherits <- base::inherits
[16:19:16.446]             invokeRestart <- base::invokeRestart
[16:19:16.446]             length <- base::length
[16:19:16.446]             list <- base::list
[16:19:16.446]             seq.int <- base::seq.int
[16:19:16.446]             signalCondition <- base::signalCondition
[16:19:16.446]             sys.calls <- base::sys.calls
[16:19:16.446]             `[[` <- base::`[[`
[16:19:16.446]             `+` <- base::`+`
[16:19:16.446]             `<<-` <- base::`<<-`
[16:19:16.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:16.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:16.446]                   3L)]
[16:19:16.446]             }
[16:19:16.446]             function(cond) {
[16:19:16.446]                 is_error <- inherits(cond, "error")
[16:19:16.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:16.446]                   NULL)
[16:19:16.446]                 if (is_error) {
[16:19:16.446]                   sessionInformation <- function() {
[16:19:16.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:16.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:16.446]                       search = base::search(), system = base::Sys.info())
[16:19:16.446]                   }
[16:19:16.446]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:16.446]                     cond$call), session = sessionInformation(), 
[16:19:16.446]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:16.446]                   signalCondition(cond)
[16:19:16.446]                 }
[16:19:16.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:16.446]                 "immediateCondition"))) {
[16:19:16.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:16.446]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:16.446]                   if (TRUE && !signal) {
[16:19:16.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.446]                     {
[16:19:16.446]                       inherits <- base::inherits
[16:19:16.446]                       invokeRestart <- base::invokeRestart
[16:19:16.446]                       is.null <- base::is.null
[16:19:16.446]                       muffled <- FALSE
[16:19:16.446]                       if (inherits(cond, "message")) {
[16:19:16.446]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.446]                         if (muffled) 
[16:19:16.446]                           invokeRestart("muffleMessage")
[16:19:16.446]                       }
[16:19:16.446]                       else if (inherits(cond, "warning")) {
[16:19:16.446]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.446]                         if (muffled) 
[16:19:16.446]                           invokeRestart("muffleWarning")
[16:19:16.446]                       }
[16:19:16.446]                       else if (inherits(cond, "condition")) {
[16:19:16.446]                         if (!is.null(pattern)) {
[16:19:16.446]                           computeRestarts <- base::computeRestarts
[16:19:16.446]                           grepl <- base::grepl
[16:19:16.446]                           restarts <- computeRestarts(cond)
[16:19:16.446]                           for (restart in restarts) {
[16:19:16.446]                             name <- restart$name
[16:19:16.446]                             if (is.null(name)) 
[16:19:16.446]                               next
[16:19:16.446]                             if (!grepl(pattern, name)) 
[16:19:16.446]                               next
[16:19:16.446]                             invokeRestart(restart)
[16:19:16.446]                             muffled <- TRUE
[16:19:16.446]                             break
[16:19:16.446]                           }
[16:19:16.446]                         }
[16:19:16.446]                       }
[16:19:16.446]                       invisible(muffled)
[16:19:16.446]                     }
[16:19:16.446]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.446]                   }
[16:19:16.446]                 }
[16:19:16.446]                 else {
[16:19:16.446]                   if (TRUE) {
[16:19:16.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.446]                     {
[16:19:16.446]                       inherits <- base::inherits
[16:19:16.446]                       invokeRestart <- base::invokeRestart
[16:19:16.446]                       is.null <- base::is.null
[16:19:16.446]                       muffled <- FALSE
[16:19:16.446]                       if (inherits(cond, "message")) {
[16:19:16.446]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.446]                         if (muffled) 
[16:19:16.446]                           invokeRestart("muffleMessage")
[16:19:16.446]                       }
[16:19:16.446]                       else if (inherits(cond, "warning")) {
[16:19:16.446]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.446]                         if (muffled) 
[16:19:16.446]                           invokeRestart("muffleWarning")
[16:19:16.446]                       }
[16:19:16.446]                       else if (inherits(cond, "condition")) {
[16:19:16.446]                         if (!is.null(pattern)) {
[16:19:16.446]                           computeRestarts <- base::computeRestarts
[16:19:16.446]                           grepl <- base::grepl
[16:19:16.446]                           restarts <- computeRestarts(cond)
[16:19:16.446]                           for (restart in restarts) {
[16:19:16.446]                             name <- restart$name
[16:19:16.446]                             if (is.null(name)) 
[16:19:16.446]                               next
[16:19:16.446]                             if (!grepl(pattern, name)) 
[16:19:16.446]                               next
[16:19:16.446]                             invokeRestart(restart)
[16:19:16.446]                             muffled <- TRUE
[16:19:16.446]                             break
[16:19:16.446]                           }
[16:19:16.446]                         }
[16:19:16.446]                       }
[16:19:16.446]                       invisible(muffled)
[16:19:16.446]                     }
[16:19:16.446]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.446]                   }
[16:19:16.446]                 }
[16:19:16.446]             }
[16:19:16.446]         }))
[16:19:16.446]     }, error = function(ex) {
[16:19:16.446]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:16.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.446]                 ...future.rng), started = ...future.startTime, 
[16:19:16.446]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:16.446]             version = "1.8"), class = "FutureResult")
[16:19:16.446]     }, finally = {
[16:19:16.446]         if (!identical(...future.workdir, getwd())) 
[16:19:16.446]             setwd(...future.workdir)
[16:19:16.446]         {
[16:19:16.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:16.446]                 ...future.oldOptions$nwarnings <- NULL
[16:19:16.446]             }
[16:19:16.446]             base::options(...future.oldOptions)
[16:19:16.446]             if (.Platform$OS.type == "windows") {
[16:19:16.446]                 old_names <- names(...future.oldEnvVars)
[16:19:16.446]                 envs <- base::Sys.getenv()
[16:19:16.446]                 names <- names(envs)
[16:19:16.446]                 common <- intersect(names, old_names)
[16:19:16.446]                 added <- setdiff(names, old_names)
[16:19:16.446]                 removed <- setdiff(old_names, names)
[16:19:16.446]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:16.446]                   envs[common]]
[16:19:16.446]                 NAMES <- toupper(changed)
[16:19:16.446]                 args <- list()
[16:19:16.446]                 for (kk in seq_along(NAMES)) {
[16:19:16.446]                   name <- changed[[kk]]
[16:19:16.446]                   NAME <- NAMES[[kk]]
[16:19:16.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.446]                     next
[16:19:16.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.446]                 }
[16:19:16.446]                 NAMES <- toupper(added)
[16:19:16.446]                 for (kk in seq_along(NAMES)) {
[16:19:16.446]                   name <- added[[kk]]
[16:19:16.446]                   NAME <- NAMES[[kk]]
[16:19:16.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.446]                     next
[16:19:16.446]                   args[[name]] <- ""
[16:19:16.446]                 }
[16:19:16.446]                 NAMES <- toupper(removed)
[16:19:16.446]                 for (kk in seq_along(NAMES)) {
[16:19:16.446]                   name <- removed[[kk]]
[16:19:16.446]                   NAME <- NAMES[[kk]]
[16:19:16.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.446]                     next
[16:19:16.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.446]                 }
[16:19:16.446]                 if (length(args) > 0) 
[16:19:16.446]                   base::do.call(base::Sys.setenv, args = args)
[16:19:16.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:16.446]             }
[16:19:16.446]             else {
[16:19:16.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:16.446]             }
[16:19:16.446]             {
[16:19:16.446]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:16.446]                   0L) {
[16:19:16.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:16.446]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:16.446]                   base::options(opts)
[16:19:16.446]                 }
[16:19:16.446]                 {
[16:19:16.446]                   {
[16:19:16.446]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:16.446]                     NULL
[16:19:16.446]                   }
[16:19:16.446]                   options(future.plan = NULL)
[16:19:16.446]                   if (is.na(NA_character_)) 
[16:19:16.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:16.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:16.446]                     .init = FALSE)
[16:19:16.446]                 }
[16:19:16.446]             }
[16:19:16.446]         }
[16:19:16.446]     })
[16:19:16.446]     if (TRUE) {
[16:19:16.446]         base::sink(type = "output", split = FALSE)
[16:19:16.446]         if (TRUE) {
[16:19:16.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:16.446]         }
[16:19:16.446]         else {
[16:19:16.446]             ...future.result["stdout"] <- base::list(NULL)
[16:19:16.446]         }
[16:19:16.446]         base::close(...future.stdout)
[16:19:16.446]         ...future.stdout <- NULL
[16:19:16.446]     }
[16:19:16.446]     ...future.result$conditions <- ...future.conditions
[16:19:16.446]     ...future.result$finished <- base::Sys.time()
[16:19:16.446]     ...future.result
[16:19:16.446] }
[16:19:16.499] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[16:19:16.500] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:19:16.504] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:19:16.504] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:19:16.505] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:19:16.505] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:19:16.505] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:19:16.506] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:19:16.548] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:19:16.549] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:19:16.592] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:19:16.593] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:19:16.593] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:19:16.593] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[16:19:16.594] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[16:19:16.594] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:16.594] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:16.595] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[16:19:16.595] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[16:19:16.595] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:16.595] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:16.598] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:16.599] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:16.599] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[16:19:16.599] MultisessionFuture started
[16:19:16.599] - Launch lazy future ... done
[16:19:16.600] run() for ‘MultisessionFuture’ ... done
[16:19:16.600] Created future:
[16:19:16.600] MultisessionFuture:
[16:19:16.600] Label: ‘future_vapply-2’
[16:19:16.600] Expression:
[16:19:16.600] {
[16:19:16.600]     do.call(function(...) {
[16:19:16.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:16.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.600]             on.exit(options(oopts), add = TRUE)
[16:19:16.600]         }
[16:19:16.600]         {
[16:19:16.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:16.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.600]                 ...future.FUN(...future.X_jj, ...)
[16:19:16.600]             })
[16:19:16.600]         }
[16:19:16.600]     }, args = future.call.arguments)
[16:19:16.600] }
[16:19:16.600] Lazy evaluation: FALSE
[16:19:16.600] Asynchronous evaluation: TRUE
[16:19:16.600] Local evaluation: TRUE
[16:19:16.600] Environment: R_GlobalEnv
[16:19:16.600] Capture standard output: TRUE
[16:19:16.600] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:16.600] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:16.600] Packages: 1 packages (‘future.apply’)
[16:19:16.600] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:16.600] Resolved: FALSE
[16:19:16.600] Value: <not collected>
[16:19:16.600] Conditions captured: <none>
[16:19:16.600] Early signaling: FALSE
[16:19:16.600] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:16.600] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:16.612] Chunk #2 of 2 ... DONE
[16:19:16.612] Launching 2 futures (chunks) ... DONE
[16:19:16.612] Resolving 2 futures (chunks) ...
[16:19:16.612] resolve() on list ...
[16:19:16.612]  recursive: 0
[16:19:16.612]  length: 2
[16:19:16.612] 
[16:19:16.613] receiveMessageFromWorker() for ClusterFuture ...
[16:19:16.613] - Validating connection of MultisessionFuture
[16:19:16.613] - received message: FutureResult
[16:19:16.613] - Received FutureResult
[16:19:16.613] - Erased future from FutureRegistry
[16:19:16.613] result() for ClusterFuture ...
[16:19:16.614] - result already collected: FutureResult
[16:19:16.614] result() for ClusterFuture ... done
[16:19:16.614] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:16.614] Future #1
[16:19:16.614] result() for ClusterFuture ...
[16:19:16.614] - result already collected: FutureResult
[16:19:16.614] result() for ClusterFuture ... done
[16:19:16.614] result() for ClusterFuture ...
[16:19:16.614] - result already collected: FutureResult
[16:19:16.614] result() for ClusterFuture ... done
[16:19:16.614] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:16.615] - nx: 2
[16:19:16.615] - relay: TRUE
[16:19:16.615] - stdout: TRUE
[16:19:16.615] - signal: TRUE
[16:19:16.615] - resignal: FALSE
[16:19:16.615] - force: TRUE
[16:19:16.615] - relayed: [n=2] FALSE, FALSE
[16:19:16.615] - queued futures: [n=2] FALSE, FALSE
[16:19:16.615]  - until=1
[16:19:16.615]  - relaying element #1
[16:19:16.615] result() for ClusterFuture ...
[16:19:16.615] - result already collected: FutureResult
[16:19:16.616] result() for ClusterFuture ... done
[16:19:16.616] result() for ClusterFuture ...
[16:19:16.616] - result already collected: FutureResult
[16:19:16.616] result() for ClusterFuture ... done
[16:19:16.616] result() for ClusterFuture ...
[16:19:16.616] - result already collected: FutureResult
[16:19:16.616] result() for ClusterFuture ... done
[16:19:16.616] result() for ClusterFuture ...
[16:19:16.616] - result already collected: FutureResult
[16:19:16.616] result() for ClusterFuture ... done
[16:19:16.616] - relayed: [n=2] TRUE, FALSE
[16:19:16.617] - queued futures: [n=2] TRUE, FALSE
[16:19:16.617] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:16.617]  length: 1 (resolved future 1)
[16:19:16.685] receiveMessageFromWorker() for ClusterFuture ...
[16:19:16.685] - Validating connection of MultisessionFuture
[16:19:16.685] - received message: FutureResult
[16:19:16.685] - Received FutureResult
[16:19:16.685] - Erased future from FutureRegistry
[16:19:16.686] result() for ClusterFuture ...
[16:19:16.686] - result already collected: FutureResult
[16:19:16.686] result() for ClusterFuture ... done
[16:19:16.686] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:16.686] Future #2
[16:19:16.686] result() for ClusterFuture ...
[16:19:16.686] - result already collected: FutureResult
[16:19:16.686] result() for ClusterFuture ... done
[16:19:16.686] result() for ClusterFuture ...
[16:19:16.686] - result already collected: FutureResult
[16:19:16.687] result() for ClusterFuture ... done
[16:19:16.687] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:16.687] - nx: 2
[16:19:16.687] - relay: TRUE
[16:19:16.687] - stdout: TRUE
[16:19:16.687] - signal: TRUE
[16:19:16.687] - resignal: FALSE
[16:19:16.687] - force: TRUE
[16:19:16.687] - relayed: [n=2] TRUE, FALSE
[16:19:16.687] - queued futures: [n=2] TRUE, FALSE
[16:19:16.688]  - until=2
[16:19:16.688]  - relaying element #2
[16:19:16.688] result() for ClusterFuture ...
[16:19:16.688] - result already collected: FutureResult
[16:19:16.688] result() for ClusterFuture ... done
[16:19:16.688] result() for ClusterFuture ...
[16:19:16.688] - result already collected: FutureResult
[16:19:16.688] result() for ClusterFuture ... done
[16:19:16.688] result() for ClusterFuture ...
[16:19:16.688] - result already collected: FutureResult
[16:19:16.689] result() for ClusterFuture ... done
[16:19:16.689] result() for ClusterFuture ...
[16:19:16.689] - result already collected: FutureResult
[16:19:16.689] result() for ClusterFuture ... done
[16:19:16.689] - relayed: [n=2] TRUE, TRUE
[16:19:16.689] - queued futures: [n=2] TRUE, TRUE
[16:19:16.689] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:16.689]  length: 0 (resolved future 2)
[16:19:16.689] Relaying remaining futures
[16:19:16.689] signalConditionsASAP(NULL, pos=0) ...
[16:19:16.690] - nx: 2
[16:19:16.690] - relay: TRUE
[16:19:16.690] - stdout: TRUE
[16:19:16.690] - signal: TRUE
[16:19:16.690] - resignal: FALSE
[16:19:16.690] - force: TRUE
[16:19:16.690] - relayed: [n=2] TRUE, TRUE
[16:19:16.690] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:16.690] - relayed: [n=2] TRUE, TRUE
[16:19:16.690] - queued futures: [n=2] TRUE, TRUE
[16:19:16.690] signalConditionsASAP(NULL, pos=0) ... done
[16:19:16.691] resolve() on list ... DONE
[16:19:16.691] result() for ClusterFuture ...
[16:19:16.691] - result already collected: FutureResult
[16:19:16.691] result() for ClusterFuture ... done
[16:19:16.691] result() for ClusterFuture ...
[16:19:16.691] - result already collected: FutureResult
[16:19:16.691] result() for ClusterFuture ... done
[16:19:16.691] result() for ClusterFuture ...
[16:19:16.691] - result already collected: FutureResult
[16:19:16.691] result() for ClusterFuture ... done
[16:19:16.691] result() for ClusterFuture ...
[16:19:16.692] - result already collected: FutureResult
[16:19:16.692] result() for ClusterFuture ... done
[16:19:16.692]  - Number of value chunks collected: 2
[16:19:16.692] Resolving 2 futures (chunks) ... DONE
[16:19:16.692] Reducing values from 2 chunks ...
[16:19:16.692]  - Number of values collected after concatenation: 2
[16:19:16.692]  - Number of values expected: 2
[16:19:16.692] Reducing values from 2 chunks ... DONE
[16:19:16.692] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:19:16.693] future_lapply() ...
[16:19:16.699] Number of chunks: 2
[16:19:16.699] getGlobalsAndPackagesXApply() ...
[16:19:16.699]  - future.globals: TRUE
[16:19:16.699] getGlobalsAndPackages() ...
[16:19:16.700] Searching for globals...
[16:19:16.703] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:19:16.703] Searching for globals ... DONE
[16:19:16.703] Resolving globals: FALSE
[16:19:16.704] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:19:16.705] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:16.705] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:16.705] - packages: [1] ‘future.apply’
[16:19:16.705] getGlobalsAndPackages() ... DONE
[16:19:16.705]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:16.705]  - needed namespaces: [n=1] ‘future.apply’
[16:19:16.705] Finding globals ... DONE
[16:19:16.706]  - use_args: TRUE
[16:19:16.706]  - Getting '...' globals ...
[16:19:16.706] resolve() on list ...
[16:19:16.706]  recursive: 0
[16:19:16.706]  length: 1
[16:19:16.706]  elements: ‘...’
[16:19:16.706]  length: 0 (resolved future 1)
[16:19:16.706] resolve() on list ... DONE
[16:19:16.707]    - '...' content: [n=0] 
[16:19:16.707] List of 1
[16:19:16.707]  $ ...: list()
[16:19:16.707]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:16.707]  - attr(*, "where")=List of 1
[16:19:16.707]   ..$ ...:<environment: 0x56199e396500> 
[16:19:16.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:16.707]  - attr(*, "resolved")= logi TRUE
[16:19:16.707]  - attr(*, "total_size")= num NA
[16:19:16.709]  - Getting '...' globals ... DONE
[16:19:16.709] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:16.709] List of 8
[16:19:16.709]  $ ...future.FUN:function (x, ...)  
[16:19:16.709]  $ x_FUN        :function (x)  
[16:19:16.709]  $ times        : int 0
[16:19:16.709]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:16.709]  $ stop_if_not  :function (...)  
[16:19:16.709]  $ dim          : NULL
[16:19:16.709]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:16.709]  $ ...          : list()
[16:19:16.709]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:16.709]  - attr(*, "where")=List of 8
[16:19:16.709]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:16.709]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:16.709]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:16.709]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:16.709]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:16.709]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:16.709]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:16.709]   ..$ ...          :<environment: 0x56199e396500> 
[16:19:16.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:16.709]  - attr(*, "resolved")= logi FALSE
[16:19:16.709]  - attr(*, "total_size")= num 95472
[16:19:16.715] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:16.715] getGlobalsAndPackagesXApply() ... DONE
[16:19:16.715] Number of futures (= number of chunks): 2
[16:19:16.715] Launching 2 futures (chunks) ...
[16:19:16.715] Chunk #1 of 2 ...
[16:19:16.715]  - Finding globals in 'X' for chunk #1 ...
[16:19:16.715] getGlobalsAndPackages() ...
[16:19:16.715] Searching for globals...
[16:19:16.716] 
[16:19:16.716] Searching for globals ... DONE
[16:19:16.716] - globals: [0] <none>
[16:19:16.716] getGlobalsAndPackages() ... DONE
[16:19:16.716]    + additional globals found: [n=0] 
[16:19:16.716]    + additional namespaces needed: [n=0] 
[16:19:16.716]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:16.716]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:16.717]  - seeds: <none>
[16:19:16.717]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.717] getGlobalsAndPackages() ...
[16:19:16.717] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.717] Resolving globals: FALSE
[16:19:16.717] Tweak future expression to call with '...' arguments ...
[16:19:16.717] {
[16:19:16.717]     do.call(function(...) {
[16:19:16.717]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.717]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:16.717]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.717]             on.exit(options(oopts), add = TRUE)
[16:19:16.717]         }
[16:19:16.717]         {
[16:19:16.717]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:16.717]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.717]                 ...future.FUN(...future.X_jj, ...)
[16:19:16.717]             })
[16:19:16.717]         }
[16:19:16.717]     }, args = future.call.arguments)
[16:19:16.717] }
[16:19:16.717] Tweak future expression to call with '...' arguments ... DONE
[16:19:16.718] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.718] - packages: [1] ‘future.apply’
[16:19:16.718] getGlobalsAndPackages() ... DONE
[16:19:16.718] run() for ‘Future’ ...
[16:19:16.719] - state: ‘created’
[16:19:16.719] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:16.733] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:16.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:16.733]   - Field: ‘node’
[16:19:16.733]   - Field: ‘label’
[16:19:16.733]   - Field: ‘local’
[16:19:16.733]   - Field: ‘owner’
[16:19:16.734]   - Field: ‘envir’
[16:19:16.734]   - Field: ‘workers’
[16:19:16.734]   - Field: ‘packages’
[16:19:16.734]   - Field: ‘gc’
[16:19:16.734]   - Field: ‘conditions’
[16:19:16.734]   - Field: ‘persistent’
[16:19:16.734]   - Field: ‘expr’
[16:19:16.734]   - Field: ‘uuid’
[16:19:16.734]   - Field: ‘seed’
[16:19:16.734]   - Field: ‘version’
[16:19:16.734]   - Field: ‘result’
[16:19:16.735]   - Field: ‘asynchronous’
[16:19:16.735]   - Field: ‘calls’
[16:19:16.735]   - Field: ‘globals’
[16:19:16.735]   - Field: ‘stdout’
[16:19:16.735]   - Field: ‘earlySignal’
[16:19:16.735]   - Field: ‘lazy’
[16:19:16.735]   - Field: ‘state’
[16:19:16.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:16.735] - Launch lazy future ...
[16:19:16.736] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:16.736] Packages needed by future strategies (n = 0): <none>
[16:19:16.736] {
[16:19:16.736]     {
[16:19:16.736]         {
[16:19:16.736]             ...future.startTime <- base::Sys.time()
[16:19:16.736]             {
[16:19:16.736]                 {
[16:19:16.736]                   {
[16:19:16.736]                     {
[16:19:16.736]                       {
[16:19:16.736]                         base::local({
[16:19:16.736]                           has_future <- base::requireNamespace("future", 
[16:19:16.736]                             quietly = TRUE)
[16:19:16.736]                           if (has_future) {
[16:19:16.736]                             ns <- base::getNamespace("future")
[16:19:16.736]                             version <- ns[[".package"]][["version"]]
[16:19:16.736]                             if (is.null(version)) 
[16:19:16.736]                               version <- utils::packageVersion("future")
[16:19:16.736]                           }
[16:19:16.736]                           else {
[16:19:16.736]                             version <- NULL
[16:19:16.736]                           }
[16:19:16.736]                           if (!has_future || version < "1.8.0") {
[16:19:16.736]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:16.736]                               "", base::R.version$version.string), 
[16:19:16.736]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:16.736]                                 base::R.version$platform, 8 * 
[16:19:16.736]                                   base::.Machine$sizeof.pointer), 
[16:19:16.736]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:16.736]                                 "release", "version")], collapse = " "), 
[16:19:16.736]                               hostname = base::Sys.info()[["nodename"]])
[16:19:16.736]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:16.736]                               info)
[16:19:16.736]                             info <- base::paste(info, collapse = "; ")
[16:19:16.736]                             if (!has_future) {
[16:19:16.736]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:16.736]                                 info)
[16:19:16.736]                             }
[16:19:16.736]                             else {
[16:19:16.736]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:16.736]                                 info, version)
[16:19:16.736]                             }
[16:19:16.736]                             base::stop(msg)
[16:19:16.736]                           }
[16:19:16.736]                         })
[16:19:16.736]                       }
[16:19:16.736]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:16.736]                       base::options(mc.cores = 1L)
[16:19:16.736]                     }
[16:19:16.736]                     base::local({
[16:19:16.736]                       for (pkg in "future.apply") {
[16:19:16.736]                         base::loadNamespace(pkg)
[16:19:16.736]                         base::library(pkg, character.only = TRUE)
[16:19:16.736]                       }
[16:19:16.736]                     })
[16:19:16.736]                   }
[16:19:16.736]                   ...future.strategy.old <- future::plan("list")
[16:19:16.736]                   options(future.plan = NULL)
[16:19:16.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:16.736]                 }
[16:19:16.736]                 ...future.workdir <- getwd()
[16:19:16.736]             }
[16:19:16.736]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:16.736]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:16.736]         }
[16:19:16.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:16.736]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:16.736]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:16.736]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:16.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:16.736]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:16.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:16.736]             base::names(...future.oldOptions))
[16:19:16.736]     }
[16:19:16.736]     if (FALSE) {
[16:19:16.736]     }
[16:19:16.736]     else {
[16:19:16.736]         if (TRUE) {
[16:19:16.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:16.736]                 open = "w")
[16:19:16.736]         }
[16:19:16.736]         else {
[16:19:16.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:16.736]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:16.736]         }
[16:19:16.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:16.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:16.736]             base::sink(type = "output", split = FALSE)
[16:19:16.736]             base::close(...future.stdout)
[16:19:16.736]         }, add = TRUE)
[16:19:16.736]     }
[16:19:16.736]     ...future.frame <- base::sys.nframe()
[16:19:16.736]     ...future.conditions <- base::list()
[16:19:16.736]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:16.736]     if (FALSE) {
[16:19:16.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:16.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:16.736]     }
[16:19:16.736]     ...future.result <- base::tryCatch({
[16:19:16.736]         base::withCallingHandlers({
[16:19:16.736]             ...future.value <- base::withVisible(base::local({
[16:19:16.736]                 ...future.makeSendCondition <- base::local({
[16:19:16.736]                   sendCondition <- NULL
[16:19:16.736]                   function(frame = 1L) {
[16:19:16.736]                     if (is.function(sendCondition)) 
[16:19:16.736]                       return(sendCondition)
[16:19:16.736]                     ns <- getNamespace("parallel")
[16:19:16.736]                     if (exists("sendData", mode = "function", 
[16:19:16.736]                       envir = ns)) {
[16:19:16.736]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:16.736]                         envir = ns)
[16:19:16.736]                       envir <- sys.frame(frame)
[16:19:16.736]                       master <- NULL
[16:19:16.736]                       while (!identical(envir, .GlobalEnv) && 
[16:19:16.736]                         !identical(envir, emptyenv())) {
[16:19:16.736]                         if (exists("master", mode = "list", envir = envir, 
[16:19:16.736]                           inherits = FALSE)) {
[16:19:16.736]                           master <- get("master", mode = "list", 
[16:19:16.736]                             envir = envir, inherits = FALSE)
[16:19:16.736]                           if (inherits(master, c("SOCKnode", 
[16:19:16.736]                             "SOCK0node"))) {
[16:19:16.736]                             sendCondition <<- function(cond) {
[16:19:16.736]                               data <- list(type = "VALUE", value = cond, 
[16:19:16.736]                                 success = TRUE)
[16:19:16.736]                               parallel_sendData(master, data)
[16:19:16.736]                             }
[16:19:16.736]                             return(sendCondition)
[16:19:16.736]                           }
[16:19:16.736]                         }
[16:19:16.736]                         frame <- frame + 1L
[16:19:16.736]                         envir <- sys.frame(frame)
[16:19:16.736]                       }
[16:19:16.736]                     }
[16:19:16.736]                     sendCondition <<- function(cond) NULL
[16:19:16.736]                   }
[16:19:16.736]                 })
[16:19:16.736]                 withCallingHandlers({
[16:19:16.736]                   {
[16:19:16.736]                     do.call(function(...) {
[16:19:16.736]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.736]                       if (!identical(...future.globals.maxSize.org, 
[16:19:16.736]                         ...future.globals.maxSize)) {
[16:19:16.736]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.736]                         on.exit(options(oopts), add = TRUE)
[16:19:16.736]                       }
[16:19:16.736]                       {
[16:19:16.736]                         lapply(seq_along(...future.elements_ii), 
[16:19:16.736]                           FUN = function(jj) {
[16:19:16.736]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.736]                             ...future.FUN(...future.X_jj, ...)
[16:19:16.736]                           })
[16:19:16.736]                       }
[16:19:16.736]                     }, args = future.call.arguments)
[16:19:16.736]                   }
[16:19:16.736]                 }, immediateCondition = function(cond) {
[16:19:16.736]                   sendCondition <- ...future.makeSendCondition()
[16:19:16.736]                   sendCondition(cond)
[16:19:16.736]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.736]                   {
[16:19:16.736]                     inherits <- base::inherits
[16:19:16.736]                     invokeRestart <- base::invokeRestart
[16:19:16.736]                     is.null <- base::is.null
[16:19:16.736]                     muffled <- FALSE
[16:19:16.736]                     if (inherits(cond, "message")) {
[16:19:16.736]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:16.736]                       if (muffled) 
[16:19:16.736]                         invokeRestart("muffleMessage")
[16:19:16.736]                     }
[16:19:16.736]                     else if (inherits(cond, "warning")) {
[16:19:16.736]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:16.736]                       if (muffled) 
[16:19:16.736]                         invokeRestart("muffleWarning")
[16:19:16.736]                     }
[16:19:16.736]                     else if (inherits(cond, "condition")) {
[16:19:16.736]                       if (!is.null(pattern)) {
[16:19:16.736]                         computeRestarts <- base::computeRestarts
[16:19:16.736]                         grepl <- base::grepl
[16:19:16.736]                         restarts <- computeRestarts(cond)
[16:19:16.736]                         for (restart in restarts) {
[16:19:16.736]                           name <- restart$name
[16:19:16.736]                           if (is.null(name)) 
[16:19:16.736]                             next
[16:19:16.736]                           if (!grepl(pattern, name)) 
[16:19:16.736]                             next
[16:19:16.736]                           invokeRestart(restart)
[16:19:16.736]                           muffled <- TRUE
[16:19:16.736]                           break
[16:19:16.736]                         }
[16:19:16.736]                       }
[16:19:16.736]                     }
[16:19:16.736]                     invisible(muffled)
[16:19:16.736]                   }
[16:19:16.736]                   muffleCondition(cond)
[16:19:16.736]                 })
[16:19:16.736]             }))
[16:19:16.736]             future::FutureResult(value = ...future.value$value, 
[16:19:16.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.736]                   ...future.rng), globalenv = if (FALSE) 
[16:19:16.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:16.736]                     ...future.globalenv.names))
[16:19:16.736]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:16.736]         }, condition = base::local({
[16:19:16.736]             c <- base::c
[16:19:16.736]             inherits <- base::inherits
[16:19:16.736]             invokeRestart <- base::invokeRestart
[16:19:16.736]             length <- base::length
[16:19:16.736]             list <- base::list
[16:19:16.736]             seq.int <- base::seq.int
[16:19:16.736]             signalCondition <- base::signalCondition
[16:19:16.736]             sys.calls <- base::sys.calls
[16:19:16.736]             `[[` <- base::`[[`
[16:19:16.736]             `+` <- base::`+`
[16:19:16.736]             `<<-` <- base::`<<-`
[16:19:16.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:16.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:16.736]                   3L)]
[16:19:16.736]             }
[16:19:16.736]             function(cond) {
[16:19:16.736]                 is_error <- inherits(cond, "error")
[16:19:16.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:16.736]                   NULL)
[16:19:16.736]                 if (is_error) {
[16:19:16.736]                   sessionInformation <- function() {
[16:19:16.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:16.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:16.736]                       search = base::search(), system = base::Sys.info())
[16:19:16.736]                   }
[16:19:16.736]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:16.736]                     cond$call), session = sessionInformation(), 
[16:19:16.736]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:16.736]                   signalCondition(cond)
[16:19:16.736]                 }
[16:19:16.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:16.736]                 "immediateCondition"))) {
[16:19:16.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:16.736]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:16.736]                   if (TRUE && !signal) {
[16:19:16.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.736]                     {
[16:19:16.736]                       inherits <- base::inherits
[16:19:16.736]                       invokeRestart <- base::invokeRestart
[16:19:16.736]                       is.null <- base::is.null
[16:19:16.736]                       muffled <- FALSE
[16:19:16.736]                       if (inherits(cond, "message")) {
[16:19:16.736]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.736]                         if (muffled) 
[16:19:16.736]                           invokeRestart("muffleMessage")
[16:19:16.736]                       }
[16:19:16.736]                       else if (inherits(cond, "warning")) {
[16:19:16.736]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.736]                         if (muffled) 
[16:19:16.736]                           invokeRestart("muffleWarning")
[16:19:16.736]                       }
[16:19:16.736]                       else if (inherits(cond, "condition")) {
[16:19:16.736]                         if (!is.null(pattern)) {
[16:19:16.736]                           computeRestarts <- base::computeRestarts
[16:19:16.736]                           grepl <- base::grepl
[16:19:16.736]                           restarts <- computeRestarts(cond)
[16:19:16.736]                           for (restart in restarts) {
[16:19:16.736]                             name <- restart$name
[16:19:16.736]                             if (is.null(name)) 
[16:19:16.736]                               next
[16:19:16.736]                             if (!grepl(pattern, name)) 
[16:19:16.736]                               next
[16:19:16.736]                             invokeRestart(restart)
[16:19:16.736]                             muffled <- TRUE
[16:19:16.736]                             break
[16:19:16.736]                           }
[16:19:16.736]                         }
[16:19:16.736]                       }
[16:19:16.736]                       invisible(muffled)
[16:19:16.736]                     }
[16:19:16.736]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.736]                   }
[16:19:16.736]                 }
[16:19:16.736]                 else {
[16:19:16.736]                   if (TRUE) {
[16:19:16.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.736]                     {
[16:19:16.736]                       inherits <- base::inherits
[16:19:16.736]                       invokeRestart <- base::invokeRestart
[16:19:16.736]                       is.null <- base::is.null
[16:19:16.736]                       muffled <- FALSE
[16:19:16.736]                       if (inherits(cond, "message")) {
[16:19:16.736]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.736]                         if (muffled) 
[16:19:16.736]                           invokeRestart("muffleMessage")
[16:19:16.736]                       }
[16:19:16.736]                       else if (inherits(cond, "warning")) {
[16:19:16.736]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.736]                         if (muffled) 
[16:19:16.736]                           invokeRestart("muffleWarning")
[16:19:16.736]                       }
[16:19:16.736]                       else if (inherits(cond, "condition")) {
[16:19:16.736]                         if (!is.null(pattern)) {
[16:19:16.736]                           computeRestarts <- base::computeRestarts
[16:19:16.736]                           grepl <- base::grepl
[16:19:16.736]                           restarts <- computeRestarts(cond)
[16:19:16.736]                           for (restart in restarts) {
[16:19:16.736]                             name <- restart$name
[16:19:16.736]                             if (is.null(name)) 
[16:19:16.736]                               next
[16:19:16.736]                             if (!grepl(pattern, name)) 
[16:19:16.736]                               next
[16:19:16.736]                             invokeRestart(restart)
[16:19:16.736]                             muffled <- TRUE
[16:19:16.736]                             break
[16:19:16.736]                           }
[16:19:16.736]                         }
[16:19:16.736]                       }
[16:19:16.736]                       invisible(muffled)
[16:19:16.736]                     }
[16:19:16.736]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.736]                   }
[16:19:16.736]                 }
[16:19:16.736]             }
[16:19:16.736]         }))
[16:19:16.736]     }, error = function(ex) {
[16:19:16.736]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:16.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.736]                 ...future.rng), started = ...future.startTime, 
[16:19:16.736]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:16.736]             version = "1.8"), class = "FutureResult")
[16:19:16.736]     }, finally = {
[16:19:16.736]         if (!identical(...future.workdir, getwd())) 
[16:19:16.736]             setwd(...future.workdir)
[16:19:16.736]         {
[16:19:16.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:16.736]                 ...future.oldOptions$nwarnings <- NULL
[16:19:16.736]             }
[16:19:16.736]             base::options(...future.oldOptions)
[16:19:16.736]             if (.Platform$OS.type == "windows") {
[16:19:16.736]                 old_names <- names(...future.oldEnvVars)
[16:19:16.736]                 envs <- base::Sys.getenv()
[16:19:16.736]                 names <- names(envs)
[16:19:16.736]                 common <- intersect(names, old_names)
[16:19:16.736]                 added <- setdiff(names, old_names)
[16:19:16.736]                 removed <- setdiff(old_names, names)
[16:19:16.736]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:16.736]                   envs[common]]
[16:19:16.736]                 NAMES <- toupper(changed)
[16:19:16.736]                 args <- list()
[16:19:16.736]                 for (kk in seq_along(NAMES)) {
[16:19:16.736]                   name <- changed[[kk]]
[16:19:16.736]                   NAME <- NAMES[[kk]]
[16:19:16.736]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.736]                     next
[16:19:16.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.736]                 }
[16:19:16.736]                 NAMES <- toupper(added)
[16:19:16.736]                 for (kk in seq_along(NAMES)) {
[16:19:16.736]                   name <- added[[kk]]
[16:19:16.736]                   NAME <- NAMES[[kk]]
[16:19:16.736]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.736]                     next
[16:19:16.736]                   args[[name]] <- ""
[16:19:16.736]                 }
[16:19:16.736]                 NAMES <- toupper(removed)
[16:19:16.736]                 for (kk in seq_along(NAMES)) {
[16:19:16.736]                   name <- removed[[kk]]
[16:19:16.736]                   NAME <- NAMES[[kk]]
[16:19:16.736]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.736]                     next
[16:19:16.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.736]                 }
[16:19:16.736]                 if (length(args) > 0) 
[16:19:16.736]                   base::do.call(base::Sys.setenv, args = args)
[16:19:16.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:16.736]             }
[16:19:16.736]             else {
[16:19:16.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:16.736]             }
[16:19:16.736]             {
[16:19:16.736]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:16.736]                   0L) {
[16:19:16.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:16.736]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:16.736]                   base::options(opts)
[16:19:16.736]                 }
[16:19:16.736]                 {
[16:19:16.736]                   {
[16:19:16.736]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:16.736]                     NULL
[16:19:16.736]                   }
[16:19:16.736]                   options(future.plan = NULL)
[16:19:16.736]                   if (is.na(NA_character_)) 
[16:19:16.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:16.736]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:16.736]                     .init = FALSE)
[16:19:16.736]                 }
[16:19:16.736]             }
[16:19:16.736]         }
[16:19:16.736]     })
[16:19:16.736]     if (TRUE) {
[16:19:16.736]         base::sink(type = "output", split = FALSE)
[16:19:16.736]         if (TRUE) {
[16:19:16.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:16.736]         }
[16:19:16.736]         else {
[16:19:16.736]             ...future.result["stdout"] <- base::list(NULL)
[16:19:16.736]         }
[16:19:16.736]         base::close(...future.stdout)
[16:19:16.736]         ...future.stdout <- NULL
[16:19:16.736]     }
[16:19:16.736]     ...future.result$conditions <- ...future.conditions
[16:19:16.736]     ...future.result$finished <- base::Sys.time()
[16:19:16.736]     ...future.result
[16:19:16.736] }
[16:19:16.739] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[16:19:16.739] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:16.780] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:16.781] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[16:19:16.781] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[16:19:16.781] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:16.781] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:16.782] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:16.824] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:16.825] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:16.869] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:16.869] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:16.869] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:16.869] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:16.870] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:16.870] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:16.870] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:16.871] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:16.871] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:16.871] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:16.871] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:16.872] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:16.872] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:16.872] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[16:19:16.873] MultisessionFuture started
[16:19:16.873] - Launch lazy future ... done
[16:19:16.873] run() for ‘MultisessionFuture’ ... done
[16:19:16.873] Created future:
[16:19:16.875] receiveMessageFromWorker() for ClusterFuture ...
[16:19:16.875] - Validating connection of MultisessionFuture
[16:19:16.875] - received message: FutureResult
[16:19:16.875] - Received FutureResult
[16:19:16.875] - Erased future from FutureRegistry
[16:19:16.875] result() for ClusterFuture ...
[16:19:16.875] - result already collected: FutureResult
[16:19:16.875] result() for ClusterFuture ... done
[16:19:16.875] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:16.873] MultisessionFuture:
[16:19:16.873] Label: ‘future_vapply-1’
[16:19:16.873] Expression:
[16:19:16.873] {
[16:19:16.873]     do.call(function(...) {
[16:19:16.873]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.873]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:16.873]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.873]             on.exit(options(oopts), add = TRUE)
[16:19:16.873]         }
[16:19:16.873]         {
[16:19:16.873]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:16.873]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.873]                 ...future.FUN(...future.X_jj, ...)
[16:19:16.873]             })
[16:19:16.873]         }
[16:19:16.873]     }, args = future.call.arguments)
[16:19:16.873] }
[16:19:16.873] Lazy evaluation: FALSE
[16:19:16.873] Asynchronous evaluation: TRUE
[16:19:16.873] Local evaluation: TRUE
[16:19:16.873] Environment: R_GlobalEnv
[16:19:16.873] Capture standard output: TRUE
[16:19:16.873] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:16.873] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:16.873] Packages: 1 packages (‘future.apply’)
[16:19:16.873] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:16.873] Resolved: TRUE
[16:19:16.873] Value: <not collected>
[16:19:16.873] Conditions captured: <none>
[16:19:16.873] Early signaling: FALSE
[16:19:16.873] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:16.873] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:16.876] Chunk #1 of 2 ... DONE
[16:19:16.876] Chunk #2 of 2 ...
[16:19:16.876]  - Finding globals in 'X' for chunk #2 ...
[16:19:16.876] getGlobalsAndPackages() ...
[16:19:16.876] Searching for globals...
[16:19:16.876] 
[16:19:16.877] Searching for globals ... DONE
[16:19:16.877] - globals: [0] <none>
[16:19:16.877] getGlobalsAndPackages() ... DONE
[16:19:16.877]    + additional globals found: [n=0] 
[16:19:16.877]    + additional namespaces needed: [n=0] 
[16:19:16.877]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:16.877]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:16.877]  - seeds: <none>
[16:19:16.877]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.877] getGlobalsAndPackages() ...
[16:19:16.878] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.878] Resolving globals: FALSE
[16:19:16.878] Tweak future expression to call with '...' arguments ...
[16:19:16.878] {
[16:19:16.878]     do.call(function(...) {
[16:19:16.878]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.878]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:16.878]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.878]             on.exit(options(oopts), add = TRUE)
[16:19:16.878]         }
[16:19:16.878]         {
[16:19:16.878]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:16.878]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.878]                 ...future.FUN(...future.X_jj, ...)
[16:19:16.878]             })
[16:19:16.878]         }
[16:19:16.878]     }, args = future.call.arguments)
[16:19:16.878] }
[16:19:16.878] Tweak future expression to call with '...' arguments ... DONE
[16:19:16.879] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:16.879] - packages: [1] ‘future.apply’
[16:19:16.879] getGlobalsAndPackages() ... DONE
[16:19:16.879] run() for ‘Future’ ...
[16:19:16.879] - state: ‘created’
[16:19:16.879] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:16.893] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:16.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:16.894]   - Field: ‘node’
[16:19:16.894]   - Field: ‘label’
[16:19:16.894]   - Field: ‘local’
[16:19:16.894]   - Field: ‘owner’
[16:19:16.894]   - Field: ‘envir’
[16:19:16.894]   - Field: ‘workers’
[16:19:16.894]   - Field: ‘packages’
[16:19:16.894]   - Field: ‘gc’
[16:19:16.894]   - Field: ‘conditions’
[16:19:16.895]   - Field: ‘persistent’
[16:19:16.895]   - Field: ‘expr’
[16:19:16.895]   - Field: ‘uuid’
[16:19:16.895]   - Field: ‘seed’
[16:19:16.895]   - Field: ‘version’
[16:19:16.895]   - Field: ‘result’
[16:19:16.895]   - Field: ‘asynchronous’
[16:19:16.895]   - Field: ‘calls’
[16:19:16.895]   - Field: ‘globals’
[16:19:16.895]   - Field: ‘stdout’
[16:19:16.895]   - Field: ‘earlySignal’
[16:19:16.895]   - Field: ‘lazy’
[16:19:16.896]   - Field: ‘state’
[16:19:16.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:16.896] - Launch lazy future ...
[16:19:16.896] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:16.896] Packages needed by future strategies (n = 0): <none>
[16:19:16.897] {
[16:19:16.897]     {
[16:19:16.897]         {
[16:19:16.897]             ...future.startTime <- base::Sys.time()
[16:19:16.897]             {
[16:19:16.897]                 {
[16:19:16.897]                   {
[16:19:16.897]                     {
[16:19:16.897]                       {
[16:19:16.897]                         base::local({
[16:19:16.897]                           has_future <- base::requireNamespace("future", 
[16:19:16.897]                             quietly = TRUE)
[16:19:16.897]                           if (has_future) {
[16:19:16.897]                             ns <- base::getNamespace("future")
[16:19:16.897]                             version <- ns[[".package"]][["version"]]
[16:19:16.897]                             if (is.null(version)) 
[16:19:16.897]                               version <- utils::packageVersion("future")
[16:19:16.897]                           }
[16:19:16.897]                           else {
[16:19:16.897]                             version <- NULL
[16:19:16.897]                           }
[16:19:16.897]                           if (!has_future || version < "1.8.0") {
[16:19:16.897]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:16.897]                               "", base::R.version$version.string), 
[16:19:16.897]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:16.897]                                 base::R.version$platform, 8 * 
[16:19:16.897]                                   base::.Machine$sizeof.pointer), 
[16:19:16.897]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:16.897]                                 "release", "version")], collapse = " "), 
[16:19:16.897]                               hostname = base::Sys.info()[["nodename"]])
[16:19:16.897]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:16.897]                               info)
[16:19:16.897]                             info <- base::paste(info, collapse = "; ")
[16:19:16.897]                             if (!has_future) {
[16:19:16.897]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:16.897]                                 info)
[16:19:16.897]                             }
[16:19:16.897]                             else {
[16:19:16.897]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:16.897]                                 info, version)
[16:19:16.897]                             }
[16:19:16.897]                             base::stop(msg)
[16:19:16.897]                           }
[16:19:16.897]                         })
[16:19:16.897]                       }
[16:19:16.897]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:16.897]                       base::options(mc.cores = 1L)
[16:19:16.897]                     }
[16:19:16.897]                     base::local({
[16:19:16.897]                       for (pkg in "future.apply") {
[16:19:16.897]                         base::loadNamespace(pkg)
[16:19:16.897]                         base::library(pkg, character.only = TRUE)
[16:19:16.897]                       }
[16:19:16.897]                     })
[16:19:16.897]                   }
[16:19:16.897]                   ...future.strategy.old <- future::plan("list")
[16:19:16.897]                   options(future.plan = NULL)
[16:19:16.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:16.897]                 }
[16:19:16.897]                 ...future.workdir <- getwd()
[16:19:16.897]             }
[16:19:16.897]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:16.897]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:16.897]         }
[16:19:16.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:16.897]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:16.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:16.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:16.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:16.897]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:16.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:16.897]             base::names(...future.oldOptions))
[16:19:16.897]     }
[16:19:16.897]     if (FALSE) {
[16:19:16.897]     }
[16:19:16.897]     else {
[16:19:16.897]         if (TRUE) {
[16:19:16.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:16.897]                 open = "w")
[16:19:16.897]         }
[16:19:16.897]         else {
[16:19:16.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:16.897]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:16.897]         }
[16:19:16.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:16.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:16.897]             base::sink(type = "output", split = FALSE)
[16:19:16.897]             base::close(...future.stdout)
[16:19:16.897]         }, add = TRUE)
[16:19:16.897]     }
[16:19:16.897]     ...future.frame <- base::sys.nframe()
[16:19:16.897]     ...future.conditions <- base::list()
[16:19:16.897]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:16.897]     if (FALSE) {
[16:19:16.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:16.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:16.897]     }
[16:19:16.897]     ...future.result <- base::tryCatch({
[16:19:16.897]         base::withCallingHandlers({
[16:19:16.897]             ...future.value <- base::withVisible(base::local({
[16:19:16.897]                 ...future.makeSendCondition <- base::local({
[16:19:16.897]                   sendCondition <- NULL
[16:19:16.897]                   function(frame = 1L) {
[16:19:16.897]                     if (is.function(sendCondition)) 
[16:19:16.897]                       return(sendCondition)
[16:19:16.897]                     ns <- getNamespace("parallel")
[16:19:16.897]                     if (exists("sendData", mode = "function", 
[16:19:16.897]                       envir = ns)) {
[16:19:16.897]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:16.897]                         envir = ns)
[16:19:16.897]                       envir <- sys.frame(frame)
[16:19:16.897]                       master <- NULL
[16:19:16.897]                       while (!identical(envir, .GlobalEnv) && 
[16:19:16.897]                         !identical(envir, emptyenv())) {
[16:19:16.897]                         if (exists("master", mode = "list", envir = envir, 
[16:19:16.897]                           inherits = FALSE)) {
[16:19:16.897]                           master <- get("master", mode = "list", 
[16:19:16.897]                             envir = envir, inherits = FALSE)
[16:19:16.897]                           if (inherits(master, c("SOCKnode", 
[16:19:16.897]                             "SOCK0node"))) {
[16:19:16.897]                             sendCondition <<- function(cond) {
[16:19:16.897]                               data <- list(type = "VALUE", value = cond, 
[16:19:16.897]                                 success = TRUE)
[16:19:16.897]                               parallel_sendData(master, data)
[16:19:16.897]                             }
[16:19:16.897]                             return(sendCondition)
[16:19:16.897]                           }
[16:19:16.897]                         }
[16:19:16.897]                         frame <- frame + 1L
[16:19:16.897]                         envir <- sys.frame(frame)
[16:19:16.897]                       }
[16:19:16.897]                     }
[16:19:16.897]                     sendCondition <<- function(cond) NULL
[16:19:16.897]                   }
[16:19:16.897]                 })
[16:19:16.897]                 withCallingHandlers({
[16:19:16.897]                   {
[16:19:16.897]                     do.call(function(...) {
[16:19:16.897]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:16.897]                       if (!identical(...future.globals.maxSize.org, 
[16:19:16.897]                         ...future.globals.maxSize)) {
[16:19:16.897]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:16.897]                         on.exit(options(oopts), add = TRUE)
[16:19:16.897]                       }
[16:19:16.897]                       {
[16:19:16.897]                         lapply(seq_along(...future.elements_ii), 
[16:19:16.897]                           FUN = function(jj) {
[16:19:16.897]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:16.897]                             ...future.FUN(...future.X_jj, ...)
[16:19:16.897]                           })
[16:19:16.897]                       }
[16:19:16.897]                     }, args = future.call.arguments)
[16:19:16.897]                   }
[16:19:16.897]                 }, immediateCondition = function(cond) {
[16:19:16.897]                   sendCondition <- ...future.makeSendCondition()
[16:19:16.897]                   sendCondition(cond)
[16:19:16.897]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.897]                   {
[16:19:16.897]                     inherits <- base::inherits
[16:19:16.897]                     invokeRestart <- base::invokeRestart
[16:19:16.897]                     is.null <- base::is.null
[16:19:16.897]                     muffled <- FALSE
[16:19:16.897]                     if (inherits(cond, "message")) {
[16:19:16.897]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:16.897]                       if (muffled) 
[16:19:16.897]                         invokeRestart("muffleMessage")
[16:19:16.897]                     }
[16:19:16.897]                     else if (inherits(cond, "warning")) {
[16:19:16.897]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:16.897]                       if (muffled) 
[16:19:16.897]                         invokeRestart("muffleWarning")
[16:19:16.897]                     }
[16:19:16.897]                     else if (inherits(cond, "condition")) {
[16:19:16.897]                       if (!is.null(pattern)) {
[16:19:16.897]                         computeRestarts <- base::computeRestarts
[16:19:16.897]                         grepl <- base::grepl
[16:19:16.897]                         restarts <- computeRestarts(cond)
[16:19:16.897]                         for (restart in restarts) {
[16:19:16.897]                           name <- restart$name
[16:19:16.897]                           if (is.null(name)) 
[16:19:16.897]                             next
[16:19:16.897]                           if (!grepl(pattern, name)) 
[16:19:16.897]                             next
[16:19:16.897]                           invokeRestart(restart)
[16:19:16.897]                           muffled <- TRUE
[16:19:16.897]                           break
[16:19:16.897]                         }
[16:19:16.897]                       }
[16:19:16.897]                     }
[16:19:16.897]                     invisible(muffled)
[16:19:16.897]                   }
[16:19:16.897]                   muffleCondition(cond)
[16:19:16.897]                 })
[16:19:16.897]             }))
[16:19:16.897]             future::FutureResult(value = ...future.value$value, 
[16:19:16.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.897]                   ...future.rng), globalenv = if (FALSE) 
[16:19:16.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:16.897]                     ...future.globalenv.names))
[16:19:16.897]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:16.897]         }, condition = base::local({
[16:19:16.897]             c <- base::c
[16:19:16.897]             inherits <- base::inherits
[16:19:16.897]             invokeRestart <- base::invokeRestart
[16:19:16.897]             length <- base::length
[16:19:16.897]             list <- base::list
[16:19:16.897]             seq.int <- base::seq.int
[16:19:16.897]             signalCondition <- base::signalCondition
[16:19:16.897]             sys.calls <- base::sys.calls
[16:19:16.897]             `[[` <- base::`[[`
[16:19:16.897]             `+` <- base::`+`
[16:19:16.897]             `<<-` <- base::`<<-`
[16:19:16.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:16.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:16.897]                   3L)]
[16:19:16.897]             }
[16:19:16.897]             function(cond) {
[16:19:16.897]                 is_error <- inherits(cond, "error")
[16:19:16.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:16.897]                   NULL)
[16:19:16.897]                 if (is_error) {
[16:19:16.897]                   sessionInformation <- function() {
[16:19:16.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:16.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:16.897]                       search = base::search(), system = base::Sys.info())
[16:19:16.897]                   }
[16:19:16.897]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:16.897]                     cond$call), session = sessionInformation(), 
[16:19:16.897]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:16.897]                   signalCondition(cond)
[16:19:16.897]                 }
[16:19:16.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:16.897]                 "immediateCondition"))) {
[16:19:16.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:16.897]                   ...future.conditions[[length(...future.conditions) + 
[16:19:16.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:16.897]                   if (TRUE && !signal) {
[16:19:16.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.897]                     {
[16:19:16.897]                       inherits <- base::inherits
[16:19:16.897]                       invokeRestart <- base::invokeRestart
[16:19:16.897]                       is.null <- base::is.null
[16:19:16.897]                       muffled <- FALSE
[16:19:16.897]                       if (inherits(cond, "message")) {
[16:19:16.897]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.897]                         if (muffled) 
[16:19:16.897]                           invokeRestart("muffleMessage")
[16:19:16.897]                       }
[16:19:16.897]                       else if (inherits(cond, "warning")) {
[16:19:16.897]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.897]                         if (muffled) 
[16:19:16.897]                           invokeRestart("muffleWarning")
[16:19:16.897]                       }
[16:19:16.897]                       else if (inherits(cond, "condition")) {
[16:19:16.897]                         if (!is.null(pattern)) {
[16:19:16.897]                           computeRestarts <- base::computeRestarts
[16:19:16.897]                           grepl <- base::grepl
[16:19:16.897]                           restarts <- computeRestarts(cond)
[16:19:16.897]                           for (restart in restarts) {
[16:19:16.897]                             name <- restart$name
[16:19:16.897]                             if (is.null(name)) 
[16:19:16.897]                               next
[16:19:16.897]                             if (!grepl(pattern, name)) 
[16:19:16.897]                               next
[16:19:16.897]                             invokeRestart(restart)
[16:19:16.897]                             muffled <- TRUE
[16:19:16.897]                             break
[16:19:16.897]                           }
[16:19:16.897]                         }
[16:19:16.897]                       }
[16:19:16.897]                       invisible(muffled)
[16:19:16.897]                     }
[16:19:16.897]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.897]                   }
[16:19:16.897]                 }
[16:19:16.897]                 else {
[16:19:16.897]                   if (TRUE) {
[16:19:16.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:16.897]                     {
[16:19:16.897]                       inherits <- base::inherits
[16:19:16.897]                       invokeRestart <- base::invokeRestart
[16:19:16.897]                       is.null <- base::is.null
[16:19:16.897]                       muffled <- FALSE
[16:19:16.897]                       if (inherits(cond, "message")) {
[16:19:16.897]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:16.897]                         if (muffled) 
[16:19:16.897]                           invokeRestart("muffleMessage")
[16:19:16.897]                       }
[16:19:16.897]                       else if (inherits(cond, "warning")) {
[16:19:16.897]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:16.897]                         if (muffled) 
[16:19:16.897]                           invokeRestart("muffleWarning")
[16:19:16.897]                       }
[16:19:16.897]                       else if (inherits(cond, "condition")) {
[16:19:16.897]                         if (!is.null(pattern)) {
[16:19:16.897]                           computeRestarts <- base::computeRestarts
[16:19:16.897]                           grepl <- base::grepl
[16:19:16.897]                           restarts <- computeRestarts(cond)
[16:19:16.897]                           for (restart in restarts) {
[16:19:16.897]                             name <- restart$name
[16:19:16.897]                             if (is.null(name)) 
[16:19:16.897]                               next
[16:19:16.897]                             if (!grepl(pattern, name)) 
[16:19:16.897]                               next
[16:19:16.897]                             invokeRestart(restart)
[16:19:16.897]                             muffled <- TRUE
[16:19:16.897]                             break
[16:19:16.897]                           }
[16:19:16.897]                         }
[16:19:16.897]                       }
[16:19:16.897]                       invisible(muffled)
[16:19:16.897]                     }
[16:19:16.897]                     muffleCondition(cond, pattern = "^muffle")
[16:19:16.897]                   }
[16:19:16.897]                 }
[16:19:16.897]             }
[16:19:16.897]         }))
[16:19:16.897]     }, error = function(ex) {
[16:19:16.897]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:16.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:16.897]                 ...future.rng), started = ...future.startTime, 
[16:19:16.897]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:16.897]             version = "1.8"), class = "FutureResult")
[16:19:16.897]     }, finally = {
[16:19:16.897]         if (!identical(...future.workdir, getwd())) 
[16:19:16.897]             setwd(...future.workdir)
[16:19:16.897]         {
[16:19:16.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:16.897]                 ...future.oldOptions$nwarnings <- NULL
[16:19:16.897]             }
[16:19:16.897]             base::options(...future.oldOptions)
[16:19:16.897]             if (.Platform$OS.type == "windows") {
[16:19:16.897]                 old_names <- names(...future.oldEnvVars)
[16:19:16.897]                 envs <- base::Sys.getenv()
[16:19:16.897]                 names <- names(envs)
[16:19:16.897]                 common <- intersect(names, old_names)
[16:19:16.897]                 added <- setdiff(names, old_names)
[16:19:16.897]                 removed <- setdiff(old_names, names)
[16:19:16.897]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:16.897]                   envs[common]]
[16:19:16.897]                 NAMES <- toupper(changed)
[16:19:16.897]                 args <- list()
[16:19:16.897]                 for (kk in seq_along(NAMES)) {
[16:19:16.897]                   name <- changed[[kk]]
[16:19:16.897]                   NAME <- NAMES[[kk]]
[16:19:16.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.897]                     next
[16:19:16.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.897]                 }
[16:19:16.897]                 NAMES <- toupper(added)
[16:19:16.897]                 for (kk in seq_along(NAMES)) {
[16:19:16.897]                   name <- added[[kk]]
[16:19:16.897]                   NAME <- NAMES[[kk]]
[16:19:16.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.897]                     next
[16:19:16.897]                   args[[name]] <- ""
[16:19:16.897]                 }
[16:19:16.897]                 NAMES <- toupper(removed)
[16:19:16.897]                 for (kk in seq_along(NAMES)) {
[16:19:16.897]                   name <- removed[[kk]]
[16:19:16.897]                   NAME <- NAMES[[kk]]
[16:19:16.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:16.897]                     next
[16:19:16.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:16.897]                 }
[16:19:16.897]                 if (length(args) > 0) 
[16:19:16.897]                   base::do.call(base::Sys.setenv, args = args)
[16:19:16.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:16.897]             }
[16:19:16.897]             else {
[16:19:16.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:16.897]             }
[16:19:16.897]             {
[16:19:16.897]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:16.897]                   0L) {
[16:19:16.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:16.897]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:16.897]                   base::options(opts)
[16:19:16.897]                 }
[16:19:16.897]                 {
[16:19:16.897]                   {
[16:19:16.897]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:16.897]                     NULL
[16:19:16.897]                   }
[16:19:16.897]                   options(future.plan = NULL)
[16:19:16.897]                   if (is.na(NA_character_)) 
[16:19:16.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:16.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:16.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:16.897]                     .init = FALSE)
[16:19:16.897]                 }
[16:19:16.897]             }
[16:19:16.897]         }
[16:19:16.897]     })
[16:19:16.897]     if (TRUE) {
[16:19:16.897]         base::sink(type = "output", split = FALSE)
[16:19:16.897]         if (TRUE) {
[16:19:16.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:16.897]         }
[16:19:16.897]         else {
[16:19:16.897]             ...future.result["stdout"] <- base::list(NULL)
[16:19:16.897]         }
[16:19:16.897]         base::close(...future.stdout)
[16:19:16.897]         ...future.stdout <- NULL
[16:19:16.897]     }
[16:19:16.897]     ...future.result$conditions <- ...future.conditions
[16:19:16.897]     ...future.result$finished <- base::Sys.time()
[16:19:16.897]     ...future.result
[16:19:16.897] }
[16:19:16.899] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[16:19:16.900] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:16.941] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:16.941] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[16:19:16.941] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[16:19:16.941] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:16.942] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:16.942] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:16.984] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:16.985] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:17.029] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:17.029] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:17.029] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.029] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:17.030] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:17.030] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:17.030] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.031] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:17.031] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:17.031] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:17.031] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.032] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:17.032] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.032] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[16:19:17.033] MultisessionFuture started
[16:19:17.033] - Launch lazy future ... done
[16:19:17.033] run() for ‘MultisessionFuture’ ... done
[16:19:17.033] Created future:
[16:19:17.033] MultisessionFuture:
[16:19:17.033] Label: ‘future_vapply-2’
[16:19:17.033] Expression:
[16:19:17.033] {
[16:19:17.033]     do.call(function(...) {
[16:19:17.033]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.033]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.033]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.033]             on.exit(options(oopts), add = TRUE)
[16:19:17.033]         }
[16:19:17.033]         {
[16:19:17.033]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.033]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.033]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.033]             })
[16:19:17.033]         }
[16:19:17.033]     }, args = future.call.arguments)
[16:19:17.033] }
[16:19:17.033] Lazy evaluation: FALSE
[16:19:17.033] Asynchronous evaluation: TRUE
[16:19:17.033] Local evaluation: TRUE
[16:19:17.033] Environment: R_GlobalEnv
[16:19:17.033] Capture standard output: TRUE
[16:19:17.033] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:17.033] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:17.033] Packages: 1 packages (‘future.apply’)
[16:19:17.033] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:17.033] Resolved: FALSE
[16:19:17.033] Value: <not collected>
[16:19:17.033] Conditions captured: <none>
[16:19:17.033] Early signaling: FALSE
[16:19:17.033] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:17.033] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.045] Chunk #2 of 2 ... DONE
[16:19:17.045] Launching 2 futures (chunks) ... DONE
[16:19:17.045] Resolving 2 futures (chunks) ...
[16:19:17.045] resolve() on list ...
[16:19:17.045]  recursive: 0
[16:19:17.045]  length: 2
[16:19:17.046] 
[16:19:17.046] Future #1
[16:19:17.046] result() for ClusterFuture ...
[16:19:17.046] - result already collected: FutureResult
[16:19:17.046] result() for ClusterFuture ... done
[16:19:17.046] result() for ClusterFuture ...
[16:19:17.046] - result already collected: FutureResult
[16:19:17.046] result() for ClusterFuture ... done
[16:19:17.046] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:17.046] - nx: 2
[16:19:17.047] - relay: TRUE
[16:19:17.047] - stdout: TRUE
[16:19:17.047] - signal: TRUE
[16:19:17.047] - resignal: FALSE
[16:19:17.047] - force: TRUE
[16:19:17.047] - relayed: [n=2] FALSE, FALSE
[16:19:17.047] - queued futures: [n=2] FALSE, FALSE
[16:19:17.047]  - until=1
[16:19:17.047]  - relaying element #1
[16:19:17.047] result() for ClusterFuture ...
[16:19:17.047] - result already collected: FutureResult
[16:19:17.047] result() for ClusterFuture ... done
[16:19:17.048] result() for ClusterFuture ...
[16:19:17.048] - result already collected: FutureResult
[16:19:17.048] result() for ClusterFuture ... done
[16:19:17.048] result() for ClusterFuture ...
[16:19:17.048] - result already collected: FutureResult
[16:19:17.048] result() for ClusterFuture ... done
[16:19:17.048] result() for ClusterFuture ...
[16:19:17.048] - result already collected: FutureResult
[16:19:17.048] result() for ClusterFuture ... done
[16:19:17.048] - relayed: [n=2] TRUE, FALSE
[16:19:17.048] - queued futures: [n=2] TRUE, FALSE
[16:19:17.049] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:17.049]  length: 1 (resolved future 1)
[16:19:17.078] receiveMessageFromWorker() for ClusterFuture ...
[16:19:17.078] - Validating connection of MultisessionFuture
[16:19:17.078] - received message: FutureResult
[16:19:17.078] - Received FutureResult
[16:19:17.079] - Erased future from FutureRegistry
[16:19:17.079] result() for ClusterFuture ...
[16:19:17.079] - result already collected: FutureResult
[16:19:17.079] result() for ClusterFuture ... done
[16:19:17.079] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:17.079] Future #2
[16:19:17.079] result() for ClusterFuture ...
[16:19:17.079] - result already collected: FutureResult
[16:19:17.079] result() for ClusterFuture ... done
[16:19:17.079] result() for ClusterFuture ...
[16:19:17.080] - result already collected: FutureResult
[16:19:17.080] result() for ClusterFuture ... done
[16:19:17.080] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:17.080] - nx: 2
[16:19:17.080] - relay: TRUE
[16:19:17.080] - stdout: TRUE
[16:19:17.080] - signal: TRUE
[16:19:17.080] - resignal: FALSE
[16:19:17.080] - force: TRUE
[16:19:17.080] - relayed: [n=2] TRUE, FALSE
[16:19:17.080] - queued futures: [n=2] TRUE, FALSE
[16:19:17.081]  - until=2
[16:19:17.081]  - relaying element #2
[16:19:17.081] result() for ClusterFuture ...
[16:19:17.081] - result already collected: FutureResult
[16:19:17.081] result() for ClusterFuture ... done
[16:19:17.081] result() for ClusterFuture ...
[16:19:17.081] - result already collected: FutureResult
[16:19:17.081] result() for ClusterFuture ... done
[16:19:17.081] result() for ClusterFuture ...
[16:19:17.081] - result already collected: FutureResult
[16:19:17.081] result() for ClusterFuture ... done
[16:19:17.082] result() for ClusterFuture ...
[16:19:17.082] - result already collected: FutureResult
[16:19:17.082] result() for ClusterFuture ... done
[16:19:17.082] - relayed: [n=2] TRUE, TRUE
[16:19:17.082] - queued futures: [n=2] TRUE, TRUE
[16:19:17.082] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:17.082]  length: 0 (resolved future 2)
[16:19:17.082] Relaying remaining futures
[16:19:17.082] signalConditionsASAP(NULL, pos=0) ...
[16:19:17.082] - nx: 2
[16:19:17.082] - relay: TRUE
[16:19:17.082] - stdout: TRUE
[16:19:17.083] - signal: TRUE
[16:19:17.083] - resignal: FALSE
[16:19:17.083] - force: TRUE
[16:19:17.083] - relayed: [n=2] TRUE, TRUE
[16:19:17.083] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:17.083] - relayed: [n=2] TRUE, TRUE
[16:19:17.083] - queued futures: [n=2] TRUE, TRUE
[16:19:17.083] signalConditionsASAP(NULL, pos=0) ... done
[16:19:17.083] resolve() on list ... DONE
[16:19:17.083] result() for ClusterFuture ...
[16:19:17.083] - result already collected: FutureResult
[16:19:17.084] result() for ClusterFuture ... done
[16:19:17.084] result() for ClusterFuture ...
[16:19:17.084] - result already collected: FutureResult
[16:19:17.084] result() for ClusterFuture ... done
[16:19:17.084] result() for ClusterFuture ...
[16:19:17.084] - result already collected: FutureResult
[16:19:17.084] result() for ClusterFuture ... done
[16:19:17.084] result() for ClusterFuture ...
[16:19:17.084] - result already collected: FutureResult
[16:19:17.084] result() for ClusterFuture ... done
[16:19:17.084]  - Number of value chunks collected: 2
[16:19:17.085] Resolving 2 futures (chunks) ... DONE
[16:19:17.085] Reducing values from 2 chunks ...
[16:19:17.085]  - Number of values collected after concatenation: 10
[16:19:17.085]  - Number of values expected: 10
[16:19:17.085] Reducing values from 2 chunks ... DONE
[16:19:17.085] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:19:17.086] future_lapply() ...
[16:19:17.097] Number of chunks: 2
[16:19:17.097] getGlobalsAndPackagesXApply() ...
[16:19:17.097]  - future.globals: TRUE
[16:19:17.097] getGlobalsAndPackages() ...
[16:19:17.097] Searching for globals...
[16:19:17.101] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:19:17.101] Searching for globals ... DONE
[16:19:17.101] Resolving globals: FALSE
[16:19:17.102] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:19:17.102] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:17.102] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:17.103] - packages: [1] ‘future.apply’
[16:19:17.103] getGlobalsAndPackages() ... DONE
[16:19:17.103]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:17.103]  - needed namespaces: [n=1] ‘future.apply’
[16:19:17.103] Finding globals ... DONE
[16:19:17.103]  - use_args: TRUE
[16:19:17.103]  - Getting '...' globals ...
[16:19:17.103] resolve() on list ...
[16:19:17.104]  recursive: 0
[16:19:17.104]  length: 1
[16:19:17.104]  elements: ‘...’
[16:19:17.104]  length: 0 (resolved future 1)
[16:19:17.104] resolve() on list ... DONE
[16:19:17.104]    - '...' content: [n=0] 
[16:19:17.104] List of 1
[16:19:17.104]  $ ...: list()
[16:19:17.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:17.104]  - attr(*, "where")=List of 1
[16:19:17.104]   ..$ ...:<environment: 0x5619a1cdc010> 
[16:19:17.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:17.104]  - attr(*, "resolved")= logi TRUE
[16:19:17.104]  - attr(*, "total_size")= num NA
[16:19:17.107]  - Getting '...' globals ... DONE
[16:19:17.107] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:17.107] List of 8
[16:19:17.107]  $ ...future.FUN:function (x, ...)  
[16:19:17.107]  $ x_FUN        :function (x)  
[16:19:17.107]  $ times        : int 0
[16:19:17.107]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:17.107]  $ stop_if_not  :function (...)  
[16:19:17.107]  $ dim          : NULL
[16:19:17.107]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:17.107]  $ ...          : list()
[16:19:17.107]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:17.107]  - attr(*, "where")=List of 8
[16:19:17.107]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:17.107]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:17.107]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:17.107]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:17.107]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:17.107]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:17.107]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:17.107]   ..$ ...          :<environment: 0x5619a1cdc010> 
[16:19:17.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:17.107]  - attr(*, "resolved")= logi FALSE
[16:19:17.107]  - attr(*, "total_size")= num 95400
[16:19:17.113] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:17.113] getGlobalsAndPackagesXApply() ... DONE
[16:19:17.113] Number of futures (= number of chunks): 2
[16:19:17.113] Launching 2 futures (chunks) ...
[16:19:17.113] Chunk #1 of 2 ...
[16:19:17.113]  - Finding globals in 'X' for chunk #1 ...
[16:19:17.113] getGlobalsAndPackages() ...
[16:19:17.113] Searching for globals...
[16:19:17.114] 
[16:19:17.114] Searching for globals ... DONE
[16:19:17.114] - globals: [0] <none>
[16:19:17.114] getGlobalsAndPackages() ... DONE
[16:19:17.114]    + additional globals found: [n=0] 
[16:19:17.114]    + additional namespaces needed: [n=0] 
[16:19:17.114]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:17.114]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:17.114]  - seeds: <none>
[16:19:17.114]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.115] getGlobalsAndPackages() ...
[16:19:17.115] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.115] Resolving globals: FALSE
[16:19:17.115] Tweak future expression to call with '...' arguments ...
[16:19:17.115] {
[16:19:17.115]     do.call(function(...) {
[16:19:17.115]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.115]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.115]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.115]             on.exit(options(oopts), add = TRUE)
[16:19:17.115]         }
[16:19:17.115]         {
[16:19:17.115]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.115]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.115]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.115]             })
[16:19:17.115]         }
[16:19:17.115]     }, args = future.call.arguments)
[16:19:17.115] }
[16:19:17.115] Tweak future expression to call with '...' arguments ... DONE
[16:19:17.116] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.116] - packages: [1] ‘future.apply’
[16:19:17.116] getGlobalsAndPackages() ... DONE
[16:19:17.116] run() for ‘Future’ ...
[16:19:17.116] - state: ‘created’
[16:19:17.116] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:17.130] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:17.130]   - Field: ‘node’
[16:19:17.130]   - Field: ‘label’
[16:19:17.130]   - Field: ‘local’
[16:19:17.131]   - Field: ‘owner’
[16:19:17.131]   - Field: ‘envir’
[16:19:17.131]   - Field: ‘workers’
[16:19:17.131]   - Field: ‘packages’
[16:19:17.131]   - Field: ‘gc’
[16:19:17.131]   - Field: ‘conditions’
[16:19:17.131]   - Field: ‘persistent’
[16:19:17.131]   - Field: ‘expr’
[16:19:17.131]   - Field: ‘uuid’
[16:19:17.131]   - Field: ‘seed’
[16:19:17.131]   - Field: ‘version’
[16:19:17.132]   - Field: ‘result’
[16:19:17.132]   - Field: ‘asynchronous’
[16:19:17.132]   - Field: ‘calls’
[16:19:17.132]   - Field: ‘globals’
[16:19:17.132]   - Field: ‘stdout’
[16:19:17.132]   - Field: ‘earlySignal’
[16:19:17.132]   - Field: ‘lazy’
[16:19:17.132]   - Field: ‘state’
[16:19:17.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:17.132] - Launch lazy future ...
[16:19:17.133] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:17.133] Packages needed by future strategies (n = 0): <none>
[16:19:17.133] {
[16:19:17.133]     {
[16:19:17.133]         {
[16:19:17.133]             ...future.startTime <- base::Sys.time()
[16:19:17.133]             {
[16:19:17.133]                 {
[16:19:17.133]                   {
[16:19:17.133]                     {
[16:19:17.133]                       {
[16:19:17.133]                         base::local({
[16:19:17.133]                           has_future <- base::requireNamespace("future", 
[16:19:17.133]                             quietly = TRUE)
[16:19:17.133]                           if (has_future) {
[16:19:17.133]                             ns <- base::getNamespace("future")
[16:19:17.133]                             version <- ns[[".package"]][["version"]]
[16:19:17.133]                             if (is.null(version)) 
[16:19:17.133]                               version <- utils::packageVersion("future")
[16:19:17.133]                           }
[16:19:17.133]                           else {
[16:19:17.133]                             version <- NULL
[16:19:17.133]                           }
[16:19:17.133]                           if (!has_future || version < "1.8.0") {
[16:19:17.133]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:17.133]                               "", base::R.version$version.string), 
[16:19:17.133]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:17.133]                                 base::R.version$platform, 8 * 
[16:19:17.133]                                   base::.Machine$sizeof.pointer), 
[16:19:17.133]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:17.133]                                 "release", "version")], collapse = " "), 
[16:19:17.133]                               hostname = base::Sys.info()[["nodename"]])
[16:19:17.133]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:17.133]                               info)
[16:19:17.133]                             info <- base::paste(info, collapse = "; ")
[16:19:17.133]                             if (!has_future) {
[16:19:17.133]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:17.133]                                 info)
[16:19:17.133]                             }
[16:19:17.133]                             else {
[16:19:17.133]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:17.133]                                 info, version)
[16:19:17.133]                             }
[16:19:17.133]                             base::stop(msg)
[16:19:17.133]                           }
[16:19:17.133]                         })
[16:19:17.133]                       }
[16:19:17.133]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:17.133]                       base::options(mc.cores = 1L)
[16:19:17.133]                     }
[16:19:17.133]                     base::local({
[16:19:17.133]                       for (pkg in "future.apply") {
[16:19:17.133]                         base::loadNamespace(pkg)
[16:19:17.133]                         base::library(pkg, character.only = TRUE)
[16:19:17.133]                       }
[16:19:17.133]                     })
[16:19:17.133]                   }
[16:19:17.133]                   ...future.strategy.old <- future::plan("list")
[16:19:17.133]                   options(future.plan = NULL)
[16:19:17.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:17.133]                 }
[16:19:17.133]                 ...future.workdir <- getwd()
[16:19:17.133]             }
[16:19:17.133]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:17.133]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:17.133]         }
[16:19:17.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:17.133]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:17.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:17.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:17.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:17.133]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:17.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:17.133]             base::names(...future.oldOptions))
[16:19:17.133]     }
[16:19:17.133]     if (FALSE) {
[16:19:17.133]     }
[16:19:17.133]     else {
[16:19:17.133]         if (TRUE) {
[16:19:17.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:17.133]                 open = "w")
[16:19:17.133]         }
[16:19:17.133]         else {
[16:19:17.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:17.133]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:17.133]         }
[16:19:17.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:17.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:17.133]             base::sink(type = "output", split = FALSE)
[16:19:17.133]             base::close(...future.stdout)
[16:19:17.133]         }, add = TRUE)
[16:19:17.133]     }
[16:19:17.133]     ...future.frame <- base::sys.nframe()
[16:19:17.133]     ...future.conditions <- base::list()
[16:19:17.133]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:17.133]     if (FALSE) {
[16:19:17.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:17.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:17.133]     }
[16:19:17.133]     ...future.result <- base::tryCatch({
[16:19:17.133]         base::withCallingHandlers({
[16:19:17.133]             ...future.value <- base::withVisible(base::local({
[16:19:17.133]                 ...future.makeSendCondition <- base::local({
[16:19:17.133]                   sendCondition <- NULL
[16:19:17.133]                   function(frame = 1L) {
[16:19:17.133]                     if (is.function(sendCondition)) 
[16:19:17.133]                       return(sendCondition)
[16:19:17.133]                     ns <- getNamespace("parallel")
[16:19:17.133]                     if (exists("sendData", mode = "function", 
[16:19:17.133]                       envir = ns)) {
[16:19:17.133]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:17.133]                         envir = ns)
[16:19:17.133]                       envir <- sys.frame(frame)
[16:19:17.133]                       master <- NULL
[16:19:17.133]                       while (!identical(envir, .GlobalEnv) && 
[16:19:17.133]                         !identical(envir, emptyenv())) {
[16:19:17.133]                         if (exists("master", mode = "list", envir = envir, 
[16:19:17.133]                           inherits = FALSE)) {
[16:19:17.133]                           master <- get("master", mode = "list", 
[16:19:17.133]                             envir = envir, inherits = FALSE)
[16:19:17.133]                           if (inherits(master, c("SOCKnode", 
[16:19:17.133]                             "SOCK0node"))) {
[16:19:17.133]                             sendCondition <<- function(cond) {
[16:19:17.133]                               data <- list(type = "VALUE", value = cond, 
[16:19:17.133]                                 success = TRUE)
[16:19:17.133]                               parallel_sendData(master, data)
[16:19:17.133]                             }
[16:19:17.133]                             return(sendCondition)
[16:19:17.133]                           }
[16:19:17.133]                         }
[16:19:17.133]                         frame <- frame + 1L
[16:19:17.133]                         envir <- sys.frame(frame)
[16:19:17.133]                       }
[16:19:17.133]                     }
[16:19:17.133]                     sendCondition <<- function(cond) NULL
[16:19:17.133]                   }
[16:19:17.133]                 })
[16:19:17.133]                 withCallingHandlers({
[16:19:17.133]                   {
[16:19:17.133]                     do.call(function(...) {
[16:19:17.133]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.133]                       if (!identical(...future.globals.maxSize.org, 
[16:19:17.133]                         ...future.globals.maxSize)) {
[16:19:17.133]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.133]                         on.exit(options(oopts), add = TRUE)
[16:19:17.133]                       }
[16:19:17.133]                       {
[16:19:17.133]                         lapply(seq_along(...future.elements_ii), 
[16:19:17.133]                           FUN = function(jj) {
[16:19:17.133]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.133]                             ...future.FUN(...future.X_jj, ...)
[16:19:17.133]                           })
[16:19:17.133]                       }
[16:19:17.133]                     }, args = future.call.arguments)
[16:19:17.133]                   }
[16:19:17.133]                 }, immediateCondition = function(cond) {
[16:19:17.133]                   sendCondition <- ...future.makeSendCondition()
[16:19:17.133]                   sendCondition(cond)
[16:19:17.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.133]                   {
[16:19:17.133]                     inherits <- base::inherits
[16:19:17.133]                     invokeRestart <- base::invokeRestart
[16:19:17.133]                     is.null <- base::is.null
[16:19:17.133]                     muffled <- FALSE
[16:19:17.133]                     if (inherits(cond, "message")) {
[16:19:17.133]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:17.133]                       if (muffled) 
[16:19:17.133]                         invokeRestart("muffleMessage")
[16:19:17.133]                     }
[16:19:17.133]                     else if (inherits(cond, "warning")) {
[16:19:17.133]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:17.133]                       if (muffled) 
[16:19:17.133]                         invokeRestart("muffleWarning")
[16:19:17.133]                     }
[16:19:17.133]                     else if (inherits(cond, "condition")) {
[16:19:17.133]                       if (!is.null(pattern)) {
[16:19:17.133]                         computeRestarts <- base::computeRestarts
[16:19:17.133]                         grepl <- base::grepl
[16:19:17.133]                         restarts <- computeRestarts(cond)
[16:19:17.133]                         for (restart in restarts) {
[16:19:17.133]                           name <- restart$name
[16:19:17.133]                           if (is.null(name)) 
[16:19:17.133]                             next
[16:19:17.133]                           if (!grepl(pattern, name)) 
[16:19:17.133]                             next
[16:19:17.133]                           invokeRestart(restart)
[16:19:17.133]                           muffled <- TRUE
[16:19:17.133]                           break
[16:19:17.133]                         }
[16:19:17.133]                       }
[16:19:17.133]                     }
[16:19:17.133]                     invisible(muffled)
[16:19:17.133]                   }
[16:19:17.133]                   muffleCondition(cond)
[16:19:17.133]                 })
[16:19:17.133]             }))
[16:19:17.133]             future::FutureResult(value = ...future.value$value, 
[16:19:17.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.133]                   ...future.rng), globalenv = if (FALSE) 
[16:19:17.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:17.133]                     ...future.globalenv.names))
[16:19:17.133]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:17.133]         }, condition = base::local({
[16:19:17.133]             c <- base::c
[16:19:17.133]             inherits <- base::inherits
[16:19:17.133]             invokeRestart <- base::invokeRestart
[16:19:17.133]             length <- base::length
[16:19:17.133]             list <- base::list
[16:19:17.133]             seq.int <- base::seq.int
[16:19:17.133]             signalCondition <- base::signalCondition
[16:19:17.133]             sys.calls <- base::sys.calls
[16:19:17.133]             `[[` <- base::`[[`
[16:19:17.133]             `+` <- base::`+`
[16:19:17.133]             `<<-` <- base::`<<-`
[16:19:17.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:17.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:17.133]                   3L)]
[16:19:17.133]             }
[16:19:17.133]             function(cond) {
[16:19:17.133]                 is_error <- inherits(cond, "error")
[16:19:17.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:17.133]                   NULL)
[16:19:17.133]                 if (is_error) {
[16:19:17.133]                   sessionInformation <- function() {
[16:19:17.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:17.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:17.133]                       search = base::search(), system = base::Sys.info())
[16:19:17.133]                   }
[16:19:17.133]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:17.133]                     cond$call), session = sessionInformation(), 
[16:19:17.133]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:17.133]                   signalCondition(cond)
[16:19:17.133]                 }
[16:19:17.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:17.133]                 "immediateCondition"))) {
[16:19:17.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:17.133]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:17.133]                   if (TRUE && !signal) {
[16:19:17.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.133]                     {
[16:19:17.133]                       inherits <- base::inherits
[16:19:17.133]                       invokeRestart <- base::invokeRestart
[16:19:17.133]                       is.null <- base::is.null
[16:19:17.133]                       muffled <- FALSE
[16:19:17.133]                       if (inherits(cond, "message")) {
[16:19:17.133]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.133]                         if (muffled) 
[16:19:17.133]                           invokeRestart("muffleMessage")
[16:19:17.133]                       }
[16:19:17.133]                       else if (inherits(cond, "warning")) {
[16:19:17.133]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.133]                         if (muffled) 
[16:19:17.133]                           invokeRestart("muffleWarning")
[16:19:17.133]                       }
[16:19:17.133]                       else if (inherits(cond, "condition")) {
[16:19:17.133]                         if (!is.null(pattern)) {
[16:19:17.133]                           computeRestarts <- base::computeRestarts
[16:19:17.133]                           grepl <- base::grepl
[16:19:17.133]                           restarts <- computeRestarts(cond)
[16:19:17.133]                           for (restart in restarts) {
[16:19:17.133]                             name <- restart$name
[16:19:17.133]                             if (is.null(name)) 
[16:19:17.133]                               next
[16:19:17.133]                             if (!grepl(pattern, name)) 
[16:19:17.133]                               next
[16:19:17.133]                             invokeRestart(restart)
[16:19:17.133]                             muffled <- TRUE
[16:19:17.133]                             break
[16:19:17.133]                           }
[16:19:17.133]                         }
[16:19:17.133]                       }
[16:19:17.133]                       invisible(muffled)
[16:19:17.133]                     }
[16:19:17.133]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.133]                   }
[16:19:17.133]                 }
[16:19:17.133]                 else {
[16:19:17.133]                   if (TRUE) {
[16:19:17.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.133]                     {
[16:19:17.133]                       inherits <- base::inherits
[16:19:17.133]                       invokeRestart <- base::invokeRestart
[16:19:17.133]                       is.null <- base::is.null
[16:19:17.133]                       muffled <- FALSE
[16:19:17.133]                       if (inherits(cond, "message")) {
[16:19:17.133]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.133]                         if (muffled) 
[16:19:17.133]                           invokeRestart("muffleMessage")
[16:19:17.133]                       }
[16:19:17.133]                       else if (inherits(cond, "warning")) {
[16:19:17.133]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.133]                         if (muffled) 
[16:19:17.133]                           invokeRestart("muffleWarning")
[16:19:17.133]                       }
[16:19:17.133]                       else if (inherits(cond, "condition")) {
[16:19:17.133]                         if (!is.null(pattern)) {
[16:19:17.133]                           computeRestarts <- base::computeRestarts
[16:19:17.133]                           grepl <- base::grepl
[16:19:17.133]                           restarts <- computeRestarts(cond)
[16:19:17.133]                           for (restart in restarts) {
[16:19:17.133]                             name <- restart$name
[16:19:17.133]                             if (is.null(name)) 
[16:19:17.133]                               next
[16:19:17.133]                             if (!grepl(pattern, name)) 
[16:19:17.133]                               next
[16:19:17.133]                             invokeRestart(restart)
[16:19:17.133]                             muffled <- TRUE
[16:19:17.133]                             break
[16:19:17.133]                           }
[16:19:17.133]                         }
[16:19:17.133]                       }
[16:19:17.133]                       invisible(muffled)
[16:19:17.133]                     }
[16:19:17.133]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.133]                   }
[16:19:17.133]                 }
[16:19:17.133]             }
[16:19:17.133]         }))
[16:19:17.133]     }, error = function(ex) {
[16:19:17.133]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:17.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.133]                 ...future.rng), started = ...future.startTime, 
[16:19:17.133]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:17.133]             version = "1.8"), class = "FutureResult")
[16:19:17.133]     }, finally = {
[16:19:17.133]         if (!identical(...future.workdir, getwd())) 
[16:19:17.133]             setwd(...future.workdir)
[16:19:17.133]         {
[16:19:17.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:17.133]                 ...future.oldOptions$nwarnings <- NULL
[16:19:17.133]             }
[16:19:17.133]             base::options(...future.oldOptions)
[16:19:17.133]             if (.Platform$OS.type == "windows") {
[16:19:17.133]                 old_names <- names(...future.oldEnvVars)
[16:19:17.133]                 envs <- base::Sys.getenv()
[16:19:17.133]                 names <- names(envs)
[16:19:17.133]                 common <- intersect(names, old_names)
[16:19:17.133]                 added <- setdiff(names, old_names)
[16:19:17.133]                 removed <- setdiff(old_names, names)
[16:19:17.133]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:17.133]                   envs[common]]
[16:19:17.133]                 NAMES <- toupper(changed)
[16:19:17.133]                 args <- list()
[16:19:17.133]                 for (kk in seq_along(NAMES)) {
[16:19:17.133]                   name <- changed[[kk]]
[16:19:17.133]                   NAME <- NAMES[[kk]]
[16:19:17.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.133]                     next
[16:19:17.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.133]                 }
[16:19:17.133]                 NAMES <- toupper(added)
[16:19:17.133]                 for (kk in seq_along(NAMES)) {
[16:19:17.133]                   name <- added[[kk]]
[16:19:17.133]                   NAME <- NAMES[[kk]]
[16:19:17.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.133]                     next
[16:19:17.133]                   args[[name]] <- ""
[16:19:17.133]                 }
[16:19:17.133]                 NAMES <- toupper(removed)
[16:19:17.133]                 for (kk in seq_along(NAMES)) {
[16:19:17.133]                   name <- removed[[kk]]
[16:19:17.133]                   NAME <- NAMES[[kk]]
[16:19:17.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.133]                     next
[16:19:17.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.133]                 }
[16:19:17.133]                 if (length(args) > 0) 
[16:19:17.133]                   base::do.call(base::Sys.setenv, args = args)
[16:19:17.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:17.133]             }
[16:19:17.133]             else {
[16:19:17.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:17.133]             }
[16:19:17.133]             {
[16:19:17.133]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:17.133]                   0L) {
[16:19:17.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:17.133]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:17.133]                   base::options(opts)
[16:19:17.133]                 }
[16:19:17.133]                 {
[16:19:17.133]                   {
[16:19:17.133]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:17.133]                     NULL
[16:19:17.133]                   }
[16:19:17.133]                   options(future.plan = NULL)
[16:19:17.133]                   if (is.na(NA_character_)) 
[16:19:17.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:17.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:17.133]                     .init = FALSE)
[16:19:17.133]                 }
[16:19:17.133]             }
[16:19:17.133]         }
[16:19:17.133]     })
[16:19:17.133]     if (TRUE) {
[16:19:17.133]         base::sink(type = "output", split = FALSE)
[16:19:17.133]         if (TRUE) {
[16:19:17.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:17.133]         }
[16:19:17.133]         else {
[16:19:17.133]             ...future.result["stdout"] <- base::list(NULL)
[16:19:17.133]         }
[16:19:17.133]         base::close(...future.stdout)
[16:19:17.133]         ...future.stdout <- NULL
[16:19:17.133]     }
[16:19:17.133]     ...future.result$conditions <- ...future.conditions
[16:19:17.133]     ...future.result$finished <- base::Sys.time()
[16:19:17.133]     ...future.result
[16:19:17.133] }
[16:19:17.136] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[16:19:17.136] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:17.180] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:17.181] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[16:19:17.181] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[16:19:17.181] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:17.182] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:17.182] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:17.224] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:17.225] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:17.269] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:17.269] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:17.269] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.269] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:19:17.270] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:19:17.270] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:17.271] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.271] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:17.271] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:17.271] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:17.272] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.272] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:17.272] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.272] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[16:19:17.273] MultisessionFuture started
[16:19:17.273] - Launch lazy future ... done
[16:19:17.273] run() for ‘MultisessionFuture’ ... done
[16:19:17.273] Created future:
[16:19:17.273] MultisessionFuture:
[16:19:17.273] Label: ‘future_vapply-1’
[16:19:17.273] Expression:
[16:19:17.273] {
[16:19:17.273]     do.call(function(...) {
[16:19:17.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.273]             on.exit(options(oopts), add = TRUE)
[16:19:17.273]         }
[16:19:17.273]         {
[16:19:17.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.273]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.273]             })
[16:19:17.273]         }
[16:19:17.273]     }, args = future.call.arguments)
[16:19:17.273] }
[16:19:17.273] Lazy evaluation: FALSE
[16:19:17.273] Asynchronous evaluation: TRUE
[16:19:17.273] Local evaluation: TRUE
[16:19:17.273] Environment: R_GlobalEnv
[16:19:17.273] Capture standard output: TRUE
[16:19:17.273] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:17.273] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:17.273] Packages: 1 packages (‘future.apply’)
[16:19:17.273] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:17.273] Resolved: FALSE
[16:19:17.273] Value: <not collected>
[16:19:17.273] Conditions captured: <none>
[16:19:17.273] Early signaling: FALSE
[16:19:17.273] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:17.273] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.285] Chunk #1 of 2 ... DONE
[16:19:17.285] Chunk #2 of 2 ...
[16:19:17.285]  - Finding globals in 'X' for chunk #2 ...
[16:19:17.285] getGlobalsAndPackages() ...
[16:19:17.285] Searching for globals...
[16:19:17.286] 
[16:19:17.286] Searching for globals ... DONE
[16:19:17.286] - globals: [0] <none>
[16:19:17.286] getGlobalsAndPackages() ... DONE
[16:19:17.286]    + additional globals found: [n=0] 
[16:19:17.286]    + additional namespaces needed: [n=0] 
[16:19:17.286]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:17.286]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:17.286]  - seeds: <none>
[16:19:17.287]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.287] getGlobalsAndPackages() ...
[16:19:17.287] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.287] Resolving globals: FALSE
[16:19:17.287] Tweak future expression to call with '...' arguments ...
[16:19:17.287] {
[16:19:17.287]     do.call(function(...) {
[16:19:17.287]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.287]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.287]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.287]             on.exit(options(oopts), add = TRUE)
[16:19:17.287]         }
[16:19:17.287]         {
[16:19:17.287]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.287]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.287]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.287]             })
[16:19:17.287]         }
[16:19:17.287]     }, args = future.call.arguments)
[16:19:17.287] }
[16:19:17.287] Tweak future expression to call with '...' arguments ... DONE
[16:19:17.288] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.288] - packages: [1] ‘future.apply’
[16:19:17.288] getGlobalsAndPackages() ... DONE
[16:19:17.288] run() for ‘Future’ ...
[16:19:17.289] - state: ‘created’
[16:19:17.289] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:17.303] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:17.303]   - Field: ‘node’
[16:19:17.303]   - Field: ‘label’
[16:19:17.303]   - Field: ‘local’
[16:19:17.303]   - Field: ‘owner’
[16:19:17.303]   - Field: ‘envir’
[16:19:17.303]   - Field: ‘workers’
[16:19:17.304]   - Field: ‘packages’
[16:19:17.304]   - Field: ‘gc’
[16:19:17.304]   - Field: ‘conditions’
[16:19:17.304]   - Field: ‘persistent’
[16:19:17.304]   - Field: ‘expr’
[16:19:17.304]   - Field: ‘uuid’
[16:19:17.304]   - Field: ‘seed’
[16:19:17.304]   - Field: ‘version’
[16:19:17.304]   - Field: ‘result’
[16:19:17.304]   - Field: ‘asynchronous’
[16:19:17.304]   - Field: ‘calls’
[16:19:17.305]   - Field: ‘globals’
[16:19:17.305]   - Field: ‘stdout’
[16:19:17.305]   - Field: ‘earlySignal’
[16:19:17.305]   - Field: ‘lazy’
[16:19:17.305]   - Field: ‘state’
[16:19:17.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:17.305] - Launch lazy future ...
[16:19:17.305] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:17.306] Packages needed by future strategies (n = 0): <none>
[16:19:17.306] {
[16:19:17.306]     {
[16:19:17.306]         {
[16:19:17.306]             ...future.startTime <- base::Sys.time()
[16:19:17.306]             {
[16:19:17.306]                 {
[16:19:17.306]                   {
[16:19:17.306]                     {
[16:19:17.306]                       {
[16:19:17.306]                         base::local({
[16:19:17.306]                           has_future <- base::requireNamespace("future", 
[16:19:17.306]                             quietly = TRUE)
[16:19:17.306]                           if (has_future) {
[16:19:17.306]                             ns <- base::getNamespace("future")
[16:19:17.306]                             version <- ns[[".package"]][["version"]]
[16:19:17.306]                             if (is.null(version)) 
[16:19:17.306]                               version <- utils::packageVersion("future")
[16:19:17.306]                           }
[16:19:17.306]                           else {
[16:19:17.306]                             version <- NULL
[16:19:17.306]                           }
[16:19:17.306]                           if (!has_future || version < "1.8.0") {
[16:19:17.306]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:17.306]                               "", base::R.version$version.string), 
[16:19:17.306]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:17.306]                                 base::R.version$platform, 8 * 
[16:19:17.306]                                   base::.Machine$sizeof.pointer), 
[16:19:17.306]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:17.306]                                 "release", "version")], collapse = " "), 
[16:19:17.306]                               hostname = base::Sys.info()[["nodename"]])
[16:19:17.306]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:17.306]                               info)
[16:19:17.306]                             info <- base::paste(info, collapse = "; ")
[16:19:17.306]                             if (!has_future) {
[16:19:17.306]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:17.306]                                 info)
[16:19:17.306]                             }
[16:19:17.306]                             else {
[16:19:17.306]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:17.306]                                 info, version)
[16:19:17.306]                             }
[16:19:17.306]                             base::stop(msg)
[16:19:17.306]                           }
[16:19:17.306]                         })
[16:19:17.306]                       }
[16:19:17.306]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:17.306]                       base::options(mc.cores = 1L)
[16:19:17.306]                     }
[16:19:17.306]                     base::local({
[16:19:17.306]                       for (pkg in "future.apply") {
[16:19:17.306]                         base::loadNamespace(pkg)
[16:19:17.306]                         base::library(pkg, character.only = TRUE)
[16:19:17.306]                       }
[16:19:17.306]                     })
[16:19:17.306]                   }
[16:19:17.306]                   ...future.strategy.old <- future::plan("list")
[16:19:17.306]                   options(future.plan = NULL)
[16:19:17.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:17.306]                 }
[16:19:17.306]                 ...future.workdir <- getwd()
[16:19:17.306]             }
[16:19:17.306]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:17.306]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:17.306]         }
[16:19:17.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:17.306]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:17.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:17.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:17.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:17.306]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:17.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:17.306]             base::names(...future.oldOptions))
[16:19:17.306]     }
[16:19:17.306]     if (FALSE) {
[16:19:17.306]     }
[16:19:17.306]     else {
[16:19:17.306]         if (TRUE) {
[16:19:17.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:17.306]                 open = "w")
[16:19:17.306]         }
[16:19:17.306]         else {
[16:19:17.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:17.306]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:17.306]         }
[16:19:17.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:17.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:17.306]             base::sink(type = "output", split = FALSE)
[16:19:17.306]             base::close(...future.stdout)
[16:19:17.306]         }, add = TRUE)
[16:19:17.306]     }
[16:19:17.306]     ...future.frame <- base::sys.nframe()
[16:19:17.306]     ...future.conditions <- base::list()
[16:19:17.306]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:17.306]     if (FALSE) {
[16:19:17.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:17.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:17.306]     }
[16:19:17.306]     ...future.result <- base::tryCatch({
[16:19:17.306]         base::withCallingHandlers({
[16:19:17.306]             ...future.value <- base::withVisible(base::local({
[16:19:17.306]                 ...future.makeSendCondition <- base::local({
[16:19:17.306]                   sendCondition <- NULL
[16:19:17.306]                   function(frame = 1L) {
[16:19:17.306]                     if (is.function(sendCondition)) 
[16:19:17.306]                       return(sendCondition)
[16:19:17.306]                     ns <- getNamespace("parallel")
[16:19:17.306]                     if (exists("sendData", mode = "function", 
[16:19:17.306]                       envir = ns)) {
[16:19:17.306]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:17.306]                         envir = ns)
[16:19:17.306]                       envir <- sys.frame(frame)
[16:19:17.306]                       master <- NULL
[16:19:17.306]                       while (!identical(envir, .GlobalEnv) && 
[16:19:17.306]                         !identical(envir, emptyenv())) {
[16:19:17.306]                         if (exists("master", mode = "list", envir = envir, 
[16:19:17.306]                           inherits = FALSE)) {
[16:19:17.306]                           master <- get("master", mode = "list", 
[16:19:17.306]                             envir = envir, inherits = FALSE)
[16:19:17.306]                           if (inherits(master, c("SOCKnode", 
[16:19:17.306]                             "SOCK0node"))) {
[16:19:17.306]                             sendCondition <<- function(cond) {
[16:19:17.306]                               data <- list(type = "VALUE", value = cond, 
[16:19:17.306]                                 success = TRUE)
[16:19:17.306]                               parallel_sendData(master, data)
[16:19:17.306]                             }
[16:19:17.306]                             return(sendCondition)
[16:19:17.306]                           }
[16:19:17.306]                         }
[16:19:17.306]                         frame <- frame + 1L
[16:19:17.306]                         envir <- sys.frame(frame)
[16:19:17.306]                       }
[16:19:17.306]                     }
[16:19:17.306]                     sendCondition <<- function(cond) NULL
[16:19:17.306]                   }
[16:19:17.306]                 })
[16:19:17.306]                 withCallingHandlers({
[16:19:17.306]                   {
[16:19:17.306]                     do.call(function(...) {
[16:19:17.306]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.306]                       if (!identical(...future.globals.maxSize.org, 
[16:19:17.306]                         ...future.globals.maxSize)) {
[16:19:17.306]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.306]                         on.exit(options(oopts), add = TRUE)
[16:19:17.306]                       }
[16:19:17.306]                       {
[16:19:17.306]                         lapply(seq_along(...future.elements_ii), 
[16:19:17.306]                           FUN = function(jj) {
[16:19:17.306]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.306]                             ...future.FUN(...future.X_jj, ...)
[16:19:17.306]                           })
[16:19:17.306]                       }
[16:19:17.306]                     }, args = future.call.arguments)
[16:19:17.306]                   }
[16:19:17.306]                 }, immediateCondition = function(cond) {
[16:19:17.306]                   sendCondition <- ...future.makeSendCondition()
[16:19:17.306]                   sendCondition(cond)
[16:19:17.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.306]                   {
[16:19:17.306]                     inherits <- base::inherits
[16:19:17.306]                     invokeRestart <- base::invokeRestart
[16:19:17.306]                     is.null <- base::is.null
[16:19:17.306]                     muffled <- FALSE
[16:19:17.306]                     if (inherits(cond, "message")) {
[16:19:17.306]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:17.306]                       if (muffled) 
[16:19:17.306]                         invokeRestart("muffleMessage")
[16:19:17.306]                     }
[16:19:17.306]                     else if (inherits(cond, "warning")) {
[16:19:17.306]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:17.306]                       if (muffled) 
[16:19:17.306]                         invokeRestart("muffleWarning")
[16:19:17.306]                     }
[16:19:17.306]                     else if (inherits(cond, "condition")) {
[16:19:17.306]                       if (!is.null(pattern)) {
[16:19:17.306]                         computeRestarts <- base::computeRestarts
[16:19:17.306]                         grepl <- base::grepl
[16:19:17.306]                         restarts <- computeRestarts(cond)
[16:19:17.306]                         for (restart in restarts) {
[16:19:17.306]                           name <- restart$name
[16:19:17.306]                           if (is.null(name)) 
[16:19:17.306]                             next
[16:19:17.306]                           if (!grepl(pattern, name)) 
[16:19:17.306]                             next
[16:19:17.306]                           invokeRestart(restart)
[16:19:17.306]                           muffled <- TRUE
[16:19:17.306]                           break
[16:19:17.306]                         }
[16:19:17.306]                       }
[16:19:17.306]                     }
[16:19:17.306]                     invisible(muffled)
[16:19:17.306]                   }
[16:19:17.306]                   muffleCondition(cond)
[16:19:17.306]                 })
[16:19:17.306]             }))
[16:19:17.306]             future::FutureResult(value = ...future.value$value, 
[16:19:17.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.306]                   ...future.rng), globalenv = if (FALSE) 
[16:19:17.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:17.306]                     ...future.globalenv.names))
[16:19:17.306]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:17.306]         }, condition = base::local({
[16:19:17.306]             c <- base::c
[16:19:17.306]             inherits <- base::inherits
[16:19:17.306]             invokeRestart <- base::invokeRestart
[16:19:17.306]             length <- base::length
[16:19:17.306]             list <- base::list
[16:19:17.306]             seq.int <- base::seq.int
[16:19:17.306]             signalCondition <- base::signalCondition
[16:19:17.306]             sys.calls <- base::sys.calls
[16:19:17.306]             `[[` <- base::`[[`
[16:19:17.306]             `+` <- base::`+`
[16:19:17.306]             `<<-` <- base::`<<-`
[16:19:17.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:17.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:17.306]                   3L)]
[16:19:17.306]             }
[16:19:17.306]             function(cond) {
[16:19:17.306]                 is_error <- inherits(cond, "error")
[16:19:17.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:17.306]                   NULL)
[16:19:17.306]                 if (is_error) {
[16:19:17.306]                   sessionInformation <- function() {
[16:19:17.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:17.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:17.306]                       search = base::search(), system = base::Sys.info())
[16:19:17.306]                   }
[16:19:17.306]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:17.306]                     cond$call), session = sessionInformation(), 
[16:19:17.306]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:17.306]                   signalCondition(cond)
[16:19:17.306]                 }
[16:19:17.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:17.306]                 "immediateCondition"))) {
[16:19:17.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:17.306]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:17.306]                   if (TRUE && !signal) {
[16:19:17.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.306]                     {
[16:19:17.306]                       inherits <- base::inherits
[16:19:17.306]                       invokeRestart <- base::invokeRestart
[16:19:17.306]                       is.null <- base::is.null
[16:19:17.306]                       muffled <- FALSE
[16:19:17.306]                       if (inherits(cond, "message")) {
[16:19:17.306]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.306]                         if (muffled) 
[16:19:17.306]                           invokeRestart("muffleMessage")
[16:19:17.306]                       }
[16:19:17.306]                       else if (inherits(cond, "warning")) {
[16:19:17.306]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.306]                         if (muffled) 
[16:19:17.306]                           invokeRestart("muffleWarning")
[16:19:17.306]                       }
[16:19:17.306]                       else if (inherits(cond, "condition")) {
[16:19:17.306]                         if (!is.null(pattern)) {
[16:19:17.306]                           computeRestarts <- base::computeRestarts
[16:19:17.306]                           grepl <- base::grepl
[16:19:17.306]                           restarts <- computeRestarts(cond)
[16:19:17.306]                           for (restart in restarts) {
[16:19:17.306]                             name <- restart$name
[16:19:17.306]                             if (is.null(name)) 
[16:19:17.306]                               next
[16:19:17.306]                             if (!grepl(pattern, name)) 
[16:19:17.306]                               next
[16:19:17.306]                             invokeRestart(restart)
[16:19:17.306]                             muffled <- TRUE
[16:19:17.306]                             break
[16:19:17.306]                           }
[16:19:17.306]                         }
[16:19:17.306]                       }
[16:19:17.306]                       invisible(muffled)
[16:19:17.306]                     }
[16:19:17.306]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.306]                   }
[16:19:17.306]                 }
[16:19:17.306]                 else {
[16:19:17.306]                   if (TRUE) {
[16:19:17.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.306]                     {
[16:19:17.306]                       inherits <- base::inherits
[16:19:17.306]                       invokeRestart <- base::invokeRestart
[16:19:17.306]                       is.null <- base::is.null
[16:19:17.306]                       muffled <- FALSE
[16:19:17.306]                       if (inherits(cond, "message")) {
[16:19:17.306]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.306]                         if (muffled) 
[16:19:17.306]                           invokeRestart("muffleMessage")
[16:19:17.306]                       }
[16:19:17.306]                       else if (inherits(cond, "warning")) {
[16:19:17.306]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.306]                         if (muffled) 
[16:19:17.306]                           invokeRestart("muffleWarning")
[16:19:17.306]                       }
[16:19:17.306]                       else if (inherits(cond, "condition")) {
[16:19:17.306]                         if (!is.null(pattern)) {
[16:19:17.306]                           computeRestarts <- base::computeRestarts
[16:19:17.306]                           grepl <- base::grepl
[16:19:17.306]                           restarts <- computeRestarts(cond)
[16:19:17.306]                           for (restart in restarts) {
[16:19:17.306]                             name <- restart$name
[16:19:17.306]                             if (is.null(name)) 
[16:19:17.306]                               next
[16:19:17.306]                             if (!grepl(pattern, name)) 
[16:19:17.306]                               next
[16:19:17.306]                             invokeRestart(restart)
[16:19:17.306]                             muffled <- TRUE
[16:19:17.306]                             break
[16:19:17.306]                           }
[16:19:17.306]                         }
[16:19:17.306]                       }
[16:19:17.306]                       invisible(muffled)
[16:19:17.306]                     }
[16:19:17.306]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.306]                   }
[16:19:17.306]                 }
[16:19:17.306]             }
[16:19:17.306]         }))
[16:19:17.306]     }, error = function(ex) {
[16:19:17.306]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:17.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.306]                 ...future.rng), started = ...future.startTime, 
[16:19:17.306]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:17.306]             version = "1.8"), class = "FutureResult")
[16:19:17.306]     }, finally = {
[16:19:17.306]         if (!identical(...future.workdir, getwd())) 
[16:19:17.306]             setwd(...future.workdir)
[16:19:17.306]         {
[16:19:17.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:17.306]                 ...future.oldOptions$nwarnings <- NULL
[16:19:17.306]             }
[16:19:17.306]             base::options(...future.oldOptions)
[16:19:17.306]             if (.Platform$OS.type == "windows") {
[16:19:17.306]                 old_names <- names(...future.oldEnvVars)
[16:19:17.306]                 envs <- base::Sys.getenv()
[16:19:17.306]                 names <- names(envs)
[16:19:17.306]                 common <- intersect(names, old_names)
[16:19:17.306]                 added <- setdiff(names, old_names)
[16:19:17.306]                 removed <- setdiff(old_names, names)
[16:19:17.306]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:17.306]                   envs[common]]
[16:19:17.306]                 NAMES <- toupper(changed)
[16:19:17.306]                 args <- list()
[16:19:17.306]                 for (kk in seq_along(NAMES)) {
[16:19:17.306]                   name <- changed[[kk]]
[16:19:17.306]                   NAME <- NAMES[[kk]]
[16:19:17.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.306]                     next
[16:19:17.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.306]                 }
[16:19:17.306]                 NAMES <- toupper(added)
[16:19:17.306]                 for (kk in seq_along(NAMES)) {
[16:19:17.306]                   name <- added[[kk]]
[16:19:17.306]                   NAME <- NAMES[[kk]]
[16:19:17.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.306]                     next
[16:19:17.306]                   args[[name]] <- ""
[16:19:17.306]                 }
[16:19:17.306]                 NAMES <- toupper(removed)
[16:19:17.306]                 for (kk in seq_along(NAMES)) {
[16:19:17.306]                   name <- removed[[kk]]
[16:19:17.306]                   NAME <- NAMES[[kk]]
[16:19:17.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.306]                     next
[16:19:17.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.306]                 }
[16:19:17.306]                 if (length(args) > 0) 
[16:19:17.306]                   base::do.call(base::Sys.setenv, args = args)
[16:19:17.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:17.306]             }
[16:19:17.306]             else {
[16:19:17.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:17.306]             }
[16:19:17.306]             {
[16:19:17.306]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:17.306]                   0L) {
[16:19:17.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:17.306]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:17.306]                   base::options(opts)
[16:19:17.306]                 }
[16:19:17.306]                 {
[16:19:17.306]                   {
[16:19:17.306]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:17.306]                     NULL
[16:19:17.306]                   }
[16:19:17.306]                   options(future.plan = NULL)
[16:19:17.306]                   if (is.na(NA_character_)) 
[16:19:17.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:17.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:17.306]                     .init = FALSE)
[16:19:17.306]                 }
[16:19:17.306]             }
[16:19:17.306]         }
[16:19:17.306]     })
[16:19:17.306]     if (TRUE) {
[16:19:17.306]         base::sink(type = "output", split = FALSE)
[16:19:17.306]         if (TRUE) {
[16:19:17.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:17.306]         }
[16:19:17.306]         else {
[16:19:17.306]             ...future.result["stdout"] <- base::list(NULL)
[16:19:17.306]         }
[16:19:17.306]         base::close(...future.stdout)
[16:19:17.306]         ...future.stdout <- NULL
[16:19:17.306]     }
[16:19:17.306]     ...future.result$conditions <- ...future.conditions
[16:19:17.306]     ...future.result$finished <- base::Sys.time()
[16:19:17.306]     ...future.result
[16:19:17.306] }
[16:19:17.309] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[16:19:17.309] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:19:17.353] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:19:17.353] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[16:19:17.353] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[16:19:17.353] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:19:17.354] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:19:17.354] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:19:17.396] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:19:17.397] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:19:17.441] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:19:17.441] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:19:17.441] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:19:17.441] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[16:19:17.442] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[16:19:17.442] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:17.442] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:17.443] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:19:17.443] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:19:17.443] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:17.444] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:17.444] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:17.444] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:17.444] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[16:19:17.445] MultisessionFuture started
[16:19:17.445] - Launch lazy future ... done
[16:19:17.445] run() for ‘MultisessionFuture’ ... done
[16:19:17.445] Created future:
[16:19:17.447] receiveMessageFromWorker() for ClusterFuture ...
[16:19:17.447] - Validating connection of MultisessionFuture
[16:19:17.447] - received message: FutureResult
[16:19:17.447] - Received FutureResult
[16:19:17.447] - Erased future from FutureRegistry
[16:19:17.447] result() for ClusterFuture ...
[16:19:17.447] - result already collected: FutureResult
[16:19:17.447] result() for ClusterFuture ... done
[16:19:17.448] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:17.445] MultisessionFuture:
[16:19:17.445] Label: ‘future_vapply-2’
[16:19:17.445] Expression:
[16:19:17.445] {
[16:19:17.445]     do.call(function(...) {
[16:19:17.445]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.445]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.445]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.445]             on.exit(options(oopts), add = TRUE)
[16:19:17.445]         }
[16:19:17.445]         {
[16:19:17.445]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.445]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.445]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.445]             })
[16:19:17.445]         }
[16:19:17.445]     }, args = future.call.arguments)
[16:19:17.445] }
[16:19:17.445] Lazy evaluation: FALSE
[16:19:17.445] Asynchronous evaluation: TRUE
[16:19:17.445] Local evaluation: TRUE
[16:19:17.445] Environment: R_GlobalEnv
[16:19:17.445] Capture standard output: TRUE
[16:19:17.445] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:17.445] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:17.445] Packages: 1 packages (‘future.apply’)
[16:19:17.445] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:17.445] Resolved: TRUE
[16:19:17.445] Value: <not collected>
[16:19:17.445] Conditions captured: <none>
[16:19:17.445] Early signaling: FALSE
[16:19:17.445] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:17.445] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.448] Chunk #2 of 2 ... DONE
[16:19:17.448] Launching 2 futures (chunks) ... DONE
[16:19:17.448] Resolving 2 futures (chunks) ...
[16:19:17.448] resolve() on list ...
[16:19:17.448]  recursive: 0
[16:19:17.448]  length: 2
[16:19:17.448] 
[16:19:17.449] receiveMessageFromWorker() for ClusterFuture ...
[16:19:17.449] - Validating connection of MultisessionFuture
[16:19:17.449] - received message: FutureResult
[16:19:17.449] - Received FutureResult
[16:19:17.449] - Erased future from FutureRegistry
[16:19:17.449] result() for ClusterFuture ...
[16:19:17.450] - result already collected: FutureResult
[16:19:17.450] result() for ClusterFuture ... done
[16:19:17.450] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:17.450] Future #1
[16:19:17.450] result() for ClusterFuture ...
[16:19:17.450] - result already collected: FutureResult
[16:19:17.450] result() for ClusterFuture ... done
[16:19:17.450] result() for ClusterFuture ...
[16:19:17.450] - result already collected: FutureResult
[16:19:17.450] result() for ClusterFuture ... done
[16:19:17.450] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:17.451] - nx: 2
[16:19:17.451] - relay: TRUE
[16:19:17.451] - stdout: TRUE
[16:19:17.451] - signal: TRUE
[16:19:17.451] - resignal: FALSE
[16:19:17.451] - force: TRUE
[16:19:17.451] - relayed: [n=2] FALSE, FALSE
[16:19:17.451] - queued futures: [n=2] FALSE, FALSE
[16:19:17.451]  - until=1
[16:19:17.451]  - relaying element #1
[16:19:17.451] result() for ClusterFuture ...
[16:19:17.451] - result already collected: FutureResult
[16:19:17.452] result() for ClusterFuture ... done
[16:19:17.452] result() for ClusterFuture ...
[16:19:17.452] - result already collected: FutureResult
[16:19:17.452] result() for ClusterFuture ... done
[16:19:17.452] result() for ClusterFuture ...
[16:19:17.452] - result already collected: FutureResult
[16:19:17.452] result() for ClusterFuture ... done
[16:19:17.452] result() for ClusterFuture ...
[16:19:17.452] - result already collected: FutureResult
[16:19:17.452] result() for ClusterFuture ... done
[16:19:17.452] - relayed: [n=2] TRUE, FALSE
[16:19:17.453] - queued futures: [n=2] TRUE, FALSE
[16:19:17.453] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:17.453]  length: 1 (resolved future 1)
[16:19:17.453] Future #2
[16:19:17.453] result() for ClusterFuture ...
[16:19:17.453] - result already collected: FutureResult
[16:19:17.453] result() for ClusterFuture ... done
[16:19:17.453] result() for ClusterFuture ...
[16:19:17.453] - result already collected: FutureResult
[16:19:17.453] result() for ClusterFuture ... done
[16:19:17.454] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:17.454] - nx: 2
[16:19:17.454] - relay: TRUE
[16:19:17.454] - stdout: TRUE
[16:19:17.454] - signal: TRUE
[16:19:17.454] - resignal: FALSE
[16:19:17.454] - force: TRUE
[16:19:17.454] - relayed: [n=2] TRUE, FALSE
[16:19:17.454] - queued futures: [n=2] TRUE, FALSE
[16:19:17.454]  - until=2
[16:19:17.454]  - relaying element #2
[16:19:17.454] result() for ClusterFuture ...
[16:19:17.455] - result already collected: FutureResult
[16:19:17.455] result() for ClusterFuture ... done
[16:19:17.455] result() for ClusterFuture ...
[16:19:17.455] - result already collected: FutureResult
[16:19:17.455] result() for ClusterFuture ... done
[16:19:17.455] result() for ClusterFuture ...
[16:19:17.455] - result already collected: FutureResult
[16:19:17.455] result() for ClusterFuture ... done
[16:19:17.455] result() for ClusterFuture ...
[16:19:17.455] - result already collected: FutureResult
[16:19:17.455] result() for ClusterFuture ... done
[16:19:17.455] - relayed: [n=2] TRUE, TRUE
[16:19:17.456] - queued futures: [n=2] TRUE, TRUE
[16:19:17.456] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:17.456]  length: 0 (resolved future 2)
[16:19:17.456] Relaying remaining futures
[16:19:17.456] signalConditionsASAP(NULL, pos=0) ...
[16:19:17.456] - nx: 2
[16:19:17.456] - relay: TRUE
[16:19:17.456] - stdout: TRUE
[16:19:17.456] - signal: TRUE
[16:19:17.456] - resignal: FALSE
[16:19:17.456] - force: TRUE
[16:19:17.457] - relayed: [n=2] TRUE, TRUE
[16:19:17.457] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:17.457] - relayed: [n=2] TRUE, TRUE
[16:19:17.457] - queued futures: [n=2] TRUE, TRUE
[16:19:17.457] signalConditionsASAP(NULL, pos=0) ... done
[16:19:17.457] resolve() on list ... DONE
[16:19:17.457] result() for ClusterFuture ...
[16:19:17.457] - result already collected: FutureResult
[16:19:17.457] result() for ClusterFuture ... done
[16:19:17.457] result() for ClusterFuture ...
[16:19:17.457] - result already collected: FutureResult
[16:19:17.458] result() for ClusterFuture ... done
[16:19:17.458] result() for ClusterFuture ...
[16:19:17.458] - result already collected: FutureResult
[16:19:17.458] result() for ClusterFuture ... done
[16:19:17.458] result() for ClusterFuture ...
[16:19:17.458] - result already collected: FutureResult
[16:19:17.458] result() for ClusterFuture ... done
[16:19:17.458]  - Number of value chunks collected: 2
[16:19:17.458] Resolving 2 futures (chunks) ... DONE
[16:19:17.458] Reducing values from 2 chunks ...
[16:19:17.458]  - Number of values collected after concatenation: 10
[16:19:17.459]  - Number of values expected: 10
[16:19:17.459] Reducing values from 2 chunks ... DONE
[16:19:17.459] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:19:17.460] future_lapply() ...
[16:19:17.465] Number of chunks: 2
[16:19:17.465] getGlobalsAndPackagesXApply() ...
[16:19:17.465]  - future.globals: TRUE
[16:19:17.465] getGlobalsAndPackages() ...
[16:19:17.466] Searching for globals...
[16:19:17.469] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:17.469] Searching for globals ... DONE
[16:19:17.469] Resolving globals: FALSE
[16:19:17.470] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:19:17.470] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:17.470] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:17.470] - packages: [1] ‘future.apply’
[16:19:17.470] getGlobalsAndPackages() ... DONE
[16:19:17.471]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:17.471]  - needed namespaces: [n=1] ‘future.apply’
[16:19:17.471] Finding globals ... DONE
[16:19:17.471]  - use_args: TRUE
[16:19:17.471]  - Getting '...' globals ...
[16:19:17.471] resolve() on list ...
[16:19:17.471]  recursive: 0
[16:19:17.471]  length: 1
[16:19:17.471]  elements: ‘...’
[16:19:17.472]  length: 0 (resolved future 1)
[16:19:17.472] resolve() on list ... DONE
[16:19:17.472]    - '...' content: [n=0] 
[16:19:17.472] List of 1
[16:19:17.472]  $ ...: list()
[16:19:17.472]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:17.472]  - attr(*, "where")=List of 1
[16:19:17.472]   ..$ ...:<environment: 0x5619a0f2ea38> 
[16:19:17.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:17.472]  - attr(*, "resolved")= logi TRUE
[16:19:17.472]  - attr(*, "total_size")= num NA
[16:19:17.474]  - Getting '...' globals ... DONE
[16:19:17.475] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:17.475] List of 8
[16:19:17.475]  $ ...future.FUN:function (x, ...)  
[16:19:17.475]  $ x_FUN        :function (x)  
[16:19:17.475]  $ times        : int 1
[16:19:17.475]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:17.475]  $ stop_if_not  :function (...)  
[16:19:17.475]  $ dim          : NULL
[16:19:17.475]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:17.475]  $ ...          : list()
[16:19:17.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:17.475]  - attr(*, "where")=List of 8
[16:19:17.475]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:17.475]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:17.475]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:17.475]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:17.475]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:17.475]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:17.475]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:17.475]   ..$ ...          :<environment: 0x5619a0f2ea38> 
[16:19:17.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:17.475]  - attr(*, "resolved")= logi FALSE
[16:19:17.475]  - attr(*, "total_size")= num 94336
[16:19:17.480] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:17.480] getGlobalsAndPackagesXApply() ... DONE
[16:19:17.483] Number of futures (= number of chunks): 2
[16:19:17.483] Launching 2 futures (chunks) ...
[16:19:17.483] Chunk #1 of 2 ...
[16:19:17.483]  - Finding globals in 'X' for chunk #1 ...
[16:19:17.483] getGlobalsAndPackages() ...
[16:19:17.483] Searching for globals...
[16:19:17.484] 
[16:19:17.484] Searching for globals ... DONE
[16:19:17.484] - globals: [0] <none>
[16:19:17.484] getGlobalsAndPackages() ... DONE
[16:19:17.484]    + additional globals found: [n=0] 
[16:19:17.484]    + additional namespaces needed: [n=0] 
[16:19:17.484]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:17.484]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:17.484]  - seeds: <none>
[16:19:17.484]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.485] getGlobalsAndPackages() ...
[16:19:17.485] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.485] Resolving globals: FALSE
[16:19:17.485] Tweak future expression to call with '...' arguments ...
[16:19:17.485] {
[16:19:17.485]     do.call(function(...) {
[16:19:17.485]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.485]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.485]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.485]             on.exit(options(oopts), add = TRUE)
[16:19:17.485]         }
[16:19:17.485]         {
[16:19:17.485]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.485]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.485]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.485]             })
[16:19:17.485]         }
[16:19:17.485]     }, args = future.call.arguments)
[16:19:17.485] }
[16:19:17.485] Tweak future expression to call with '...' arguments ... DONE
[16:19:17.486] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.486] - packages: [1] ‘future.apply’
[16:19:17.486] getGlobalsAndPackages() ... DONE
[16:19:17.486] run() for ‘Future’ ...
[16:19:17.486] - state: ‘created’
[16:19:17.486] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:17.500] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:17.501]   - Field: ‘node’
[16:19:17.501]   - Field: ‘label’
[16:19:17.501]   - Field: ‘local’
[16:19:17.501]   - Field: ‘owner’
[16:19:17.501]   - Field: ‘envir’
[16:19:17.501]   - Field: ‘workers’
[16:19:17.501]   - Field: ‘packages’
[16:19:17.501]   - Field: ‘gc’
[16:19:17.501]   - Field: ‘conditions’
[16:19:17.501]   - Field: ‘persistent’
[16:19:17.502]   - Field: ‘expr’
[16:19:17.502]   - Field: ‘uuid’
[16:19:17.502]   - Field: ‘seed’
[16:19:17.502]   - Field: ‘version’
[16:19:17.502]   - Field: ‘result’
[16:19:17.502]   - Field: ‘asynchronous’
[16:19:17.502]   - Field: ‘calls’
[16:19:17.502]   - Field: ‘globals’
[16:19:17.502]   - Field: ‘stdout’
[16:19:17.502]   - Field: ‘earlySignal’
[16:19:17.502]   - Field: ‘lazy’
[16:19:17.502]   - Field: ‘state’
[16:19:17.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:17.503] - Launch lazy future ...
[16:19:17.503] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:17.503] Packages needed by future strategies (n = 0): <none>
[16:19:17.504] {
[16:19:17.504]     {
[16:19:17.504]         {
[16:19:17.504]             ...future.startTime <- base::Sys.time()
[16:19:17.504]             {
[16:19:17.504]                 {
[16:19:17.504]                   {
[16:19:17.504]                     {
[16:19:17.504]                       {
[16:19:17.504]                         base::local({
[16:19:17.504]                           has_future <- base::requireNamespace("future", 
[16:19:17.504]                             quietly = TRUE)
[16:19:17.504]                           if (has_future) {
[16:19:17.504]                             ns <- base::getNamespace("future")
[16:19:17.504]                             version <- ns[[".package"]][["version"]]
[16:19:17.504]                             if (is.null(version)) 
[16:19:17.504]                               version <- utils::packageVersion("future")
[16:19:17.504]                           }
[16:19:17.504]                           else {
[16:19:17.504]                             version <- NULL
[16:19:17.504]                           }
[16:19:17.504]                           if (!has_future || version < "1.8.0") {
[16:19:17.504]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:17.504]                               "", base::R.version$version.string), 
[16:19:17.504]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:17.504]                                 base::R.version$platform, 8 * 
[16:19:17.504]                                   base::.Machine$sizeof.pointer), 
[16:19:17.504]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:17.504]                                 "release", "version")], collapse = " "), 
[16:19:17.504]                               hostname = base::Sys.info()[["nodename"]])
[16:19:17.504]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:17.504]                               info)
[16:19:17.504]                             info <- base::paste(info, collapse = "; ")
[16:19:17.504]                             if (!has_future) {
[16:19:17.504]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:17.504]                                 info)
[16:19:17.504]                             }
[16:19:17.504]                             else {
[16:19:17.504]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:17.504]                                 info, version)
[16:19:17.504]                             }
[16:19:17.504]                             base::stop(msg)
[16:19:17.504]                           }
[16:19:17.504]                         })
[16:19:17.504]                       }
[16:19:17.504]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:17.504]                       base::options(mc.cores = 1L)
[16:19:17.504]                     }
[16:19:17.504]                     base::local({
[16:19:17.504]                       for (pkg in "future.apply") {
[16:19:17.504]                         base::loadNamespace(pkg)
[16:19:17.504]                         base::library(pkg, character.only = TRUE)
[16:19:17.504]                       }
[16:19:17.504]                     })
[16:19:17.504]                   }
[16:19:17.504]                   ...future.strategy.old <- future::plan("list")
[16:19:17.504]                   options(future.plan = NULL)
[16:19:17.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:17.504]                 }
[16:19:17.504]                 ...future.workdir <- getwd()
[16:19:17.504]             }
[16:19:17.504]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:17.504]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:17.504]         }
[16:19:17.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:17.504]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:17.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:17.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:17.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:17.504]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:17.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:17.504]             base::names(...future.oldOptions))
[16:19:17.504]     }
[16:19:17.504]     if (FALSE) {
[16:19:17.504]     }
[16:19:17.504]     else {
[16:19:17.504]         if (TRUE) {
[16:19:17.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:17.504]                 open = "w")
[16:19:17.504]         }
[16:19:17.504]         else {
[16:19:17.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:17.504]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:17.504]         }
[16:19:17.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:17.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:17.504]             base::sink(type = "output", split = FALSE)
[16:19:17.504]             base::close(...future.stdout)
[16:19:17.504]         }, add = TRUE)
[16:19:17.504]     }
[16:19:17.504]     ...future.frame <- base::sys.nframe()
[16:19:17.504]     ...future.conditions <- base::list()
[16:19:17.504]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:17.504]     if (FALSE) {
[16:19:17.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:17.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:17.504]     }
[16:19:17.504]     ...future.result <- base::tryCatch({
[16:19:17.504]         base::withCallingHandlers({
[16:19:17.504]             ...future.value <- base::withVisible(base::local({
[16:19:17.504]                 ...future.makeSendCondition <- base::local({
[16:19:17.504]                   sendCondition <- NULL
[16:19:17.504]                   function(frame = 1L) {
[16:19:17.504]                     if (is.function(sendCondition)) 
[16:19:17.504]                       return(sendCondition)
[16:19:17.504]                     ns <- getNamespace("parallel")
[16:19:17.504]                     if (exists("sendData", mode = "function", 
[16:19:17.504]                       envir = ns)) {
[16:19:17.504]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:17.504]                         envir = ns)
[16:19:17.504]                       envir <- sys.frame(frame)
[16:19:17.504]                       master <- NULL
[16:19:17.504]                       while (!identical(envir, .GlobalEnv) && 
[16:19:17.504]                         !identical(envir, emptyenv())) {
[16:19:17.504]                         if (exists("master", mode = "list", envir = envir, 
[16:19:17.504]                           inherits = FALSE)) {
[16:19:17.504]                           master <- get("master", mode = "list", 
[16:19:17.504]                             envir = envir, inherits = FALSE)
[16:19:17.504]                           if (inherits(master, c("SOCKnode", 
[16:19:17.504]                             "SOCK0node"))) {
[16:19:17.504]                             sendCondition <<- function(cond) {
[16:19:17.504]                               data <- list(type = "VALUE", value = cond, 
[16:19:17.504]                                 success = TRUE)
[16:19:17.504]                               parallel_sendData(master, data)
[16:19:17.504]                             }
[16:19:17.504]                             return(sendCondition)
[16:19:17.504]                           }
[16:19:17.504]                         }
[16:19:17.504]                         frame <- frame + 1L
[16:19:17.504]                         envir <- sys.frame(frame)
[16:19:17.504]                       }
[16:19:17.504]                     }
[16:19:17.504]                     sendCondition <<- function(cond) NULL
[16:19:17.504]                   }
[16:19:17.504]                 })
[16:19:17.504]                 withCallingHandlers({
[16:19:17.504]                   {
[16:19:17.504]                     do.call(function(...) {
[16:19:17.504]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.504]                       if (!identical(...future.globals.maxSize.org, 
[16:19:17.504]                         ...future.globals.maxSize)) {
[16:19:17.504]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.504]                         on.exit(options(oopts), add = TRUE)
[16:19:17.504]                       }
[16:19:17.504]                       {
[16:19:17.504]                         lapply(seq_along(...future.elements_ii), 
[16:19:17.504]                           FUN = function(jj) {
[16:19:17.504]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.504]                             ...future.FUN(...future.X_jj, ...)
[16:19:17.504]                           })
[16:19:17.504]                       }
[16:19:17.504]                     }, args = future.call.arguments)
[16:19:17.504]                   }
[16:19:17.504]                 }, immediateCondition = function(cond) {
[16:19:17.504]                   sendCondition <- ...future.makeSendCondition()
[16:19:17.504]                   sendCondition(cond)
[16:19:17.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.504]                   {
[16:19:17.504]                     inherits <- base::inherits
[16:19:17.504]                     invokeRestart <- base::invokeRestart
[16:19:17.504]                     is.null <- base::is.null
[16:19:17.504]                     muffled <- FALSE
[16:19:17.504]                     if (inherits(cond, "message")) {
[16:19:17.504]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:17.504]                       if (muffled) 
[16:19:17.504]                         invokeRestart("muffleMessage")
[16:19:17.504]                     }
[16:19:17.504]                     else if (inherits(cond, "warning")) {
[16:19:17.504]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:17.504]                       if (muffled) 
[16:19:17.504]                         invokeRestart("muffleWarning")
[16:19:17.504]                     }
[16:19:17.504]                     else if (inherits(cond, "condition")) {
[16:19:17.504]                       if (!is.null(pattern)) {
[16:19:17.504]                         computeRestarts <- base::computeRestarts
[16:19:17.504]                         grepl <- base::grepl
[16:19:17.504]                         restarts <- computeRestarts(cond)
[16:19:17.504]                         for (restart in restarts) {
[16:19:17.504]                           name <- restart$name
[16:19:17.504]                           if (is.null(name)) 
[16:19:17.504]                             next
[16:19:17.504]                           if (!grepl(pattern, name)) 
[16:19:17.504]                             next
[16:19:17.504]                           invokeRestart(restart)
[16:19:17.504]                           muffled <- TRUE
[16:19:17.504]                           break
[16:19:17.504]                         }
[16:19:17.504]                       }
[16:19:17.504]                     }
[16:19:17.504]                     invisible(muffled)
[16:19:17.504]                   }
[16:19:17.504]                   muffleCondition(cond)
[16:19:17.504]                 })
[16:19:17.504]             }))
[16:19:17.504]             future::FutureResult(value = ...future.value$value, 
[16:19:17.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.504]                   ...future.rng), globalenv = if (FALSE) 
[16:19:17.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:17.504]                     ...future.globalenv.names))
[16:19:17.504]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:17.504]         }, condition = base::local({
[16:19:17.504]             c <- base::c
[16:19:17.504]             inherits <- base::inherits
[16:19:17.504]             invokeRestart <- base::invokeRestart
[16:19:17.504]             length <- base::length
[16:19:17.504]             list <- base::list
[16:19:17.504]             seq.int <- base::seq.int
[16:19:17.504]             signalCondition <- base::signalCondition
[16:19:17.504]             sys.calls <- base::sys.calls
[16:19:17.504]             `[[` <- base::`[[`
[16:19:17.504]             `+` <- base::`+`
[16:19:17.504]             `<<-` <- base::`<<-`
[16:19:17.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:17.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:17.504]                   3L)]
[16:19:17.504]             }
[16:19:17.504]             function(cond) {
[16:19:17.504]                 is_error <- inherits(cond, "error")
[16:19:17.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:17.504]                   NULL)
[16:19:17.504]                 if (is_error) {
[16:19:17.504]                   sessionInformation <- function() {
[16:19:17.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:17.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:17.504]                       search = base::search(), system = base::Sys.info())
[16:19:17.504]                   }
[16:19:17.504]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:17.504]                     cond$call), session = sessionInformation(), 
[16:19:17.504]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:17.504]                   signalCondition(cond)
[16:19:17.504]                 }
[16:19:17.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:17.504]                 "immediateCondition"))) {
[16:19:17.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:17.504]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:17.504]                   if (TRUE && !signal) {
[16:19:17.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.504]                     {
[16:19:17.504]                       inherits <- base::inherits
[16:19:17.504]                       invokeRestart <- base::invokeRestart
[16:19:17.504]                       is.null <- base::is.null
[16:19:17.504]                       muffled <- FALSE
[16:19:17.504]                       if (inherits(cond, "message")) {
[16:19:17.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.504]                         if (muffled) 
[16:19:17.504]                           invokeRestart("muffleMessage")
[16:19:17.504]                       }
[16:19:17.504]                       else if (inherits(cond, "warning")) {
[16:19:17.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.504]                         if (muffled) 
[16:19:17.504]                           invokeRestart("muffleWarning")
[16:19:17.504]                       }
[16:19:17.504]                       else if (inherits(cond, "condition")) {
[16:19:17.504]                         if (!is.null(pattern)) {
[16:19:17.504]                           computeRestarts <- base::computeRestarts
[16:19:17.504]                           grepl <- base::grepl
[16:19:17.504]                           restarts <- computeRestarts(cond)
[16:19:17.504]                           for (restart in restarts) {
[16:19:17.504]                             name <- restart$name
[16:19:17.504]                             if (is.null(name)) 
[16:19:17.504]                               next
[16:19:17.504]                             if (!grepl(pattern, name)) 
[16:19:17.504]                               next
[16:19:17.504]                             invokeRestart(restart)
[16:19:17.504]                             muffled <- TRUE
[16:19:17.504]                             break
[16:19:17.504]                           }
[16:19:17.504]                         }
[16:19:17.504]                       }
[16:19:17.504]                       invisible(muffled)
[16:19:17.504]                     }
[16:19:17.504]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.504]                   }
[16:19:17.504]                 }
[16:19:17.504]                 else {
[16:19:17.504]                   if (TRUE) {
[16:19:17.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.504]                     {
[16:19:17.504]                       inherits <- base::inherits
[16:19:17.504]                       invokeRestart <- base::invokeRestart
[16:19:17.504]                       is.null <- base::is.null
[16:19:17.504]                       muffled <- FALSE
[16:19:17.504]                       if (inherits(cond, "message")) {
[16:19:17.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.504]                         if (muffled) 
[16:19:17.504]                           invokeRestart("muffleMessage")
[16:19:17.504]                       }
[16:19:17.504]                       else if (inherits(cond, "warning")) {
[16:19:17.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.504]                         if (muffled) 
[16:19:17.504]                           invokeRestart("muffleWarning")
[16:19:17.504]                       }
[16:19:17.504]                       else if (inherits(cond, "condition")) {
[16:19:17.504]                         if (!is.null(pattern)) {
[16:19:17.504]                           computeRestarts <- base::computeRestarts
[16:19:17.504]                           grepl <- base::grepl
[16:19:17.504]                           restarts <- computeRestarts(cond)
[16:19:17.504]                           for (restart in restarts) {
[16:19:17.504]                             name <- restart$name
[16:19:17.504]                             if (is.null(name)) 
[16:19:17.504]                               next
[16:19:17.504]                             if (!grepl(pattern, name)) 
[16:19:17.504]                               next
[16:19:17.504]                             invokeRestart(restart)
[16:19:17.504]                             muffled <- TRUE
[16:19:17.504]                             break
[16:19:17.504]                           }
[16:19:17.504]                         }
[16:19:17.504]                       }
[16:19:17.504]                       invisible(muffled)
[16:19:17.504]                     }
[16:19:17.504]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.504]                   }
[16:19:17.504]                 }
[16:19:17.504]             }
[16:19:17.504]         }))
[16:19:17.504]     }, error = function(ex) {
[16:19:17.504]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:17.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.504]                 ...future.rng), started = ...future.startTime, 
[16:19:17.504]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:17.504]             version = "1.8"), class = "FutureResult")
[16:19:17.504]     }, finally = {
[16:19:17.504]         if (!identical(...future.workdir, getwd())) 
[16:19:17.504]             setwd(...future.workdir)
[16:19:17.504]         {
[16:19:17.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:17.504]                 ...future.oldOptions$nwarnings <- NULL
[16:19:17.504]             }
[16:19:17.504]             base::options(...future.oldOptions)
[16:19:17.504]             if (.Platform$OS.type == "windows") {
[16:19:17.504]                 old_names <- names(...future.oldEnvVars)
[16:19:17.504]                 envs <- base::Sys.getenv()
[16:19:17.504]                 names <- names(envs)
[16:19:17.504]                 common <- intersect(names, old_names)
[16:19:17.504]                 added <- setdiff(names, old_names)
[16:19:17.504]                 removed <- setdiff(old_names, names)
[16:19:17.504]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:17.504]                   envs[common]]
[16:19:17.504]                 NAMES <- toupper(changed)
[16:19:17.504]                 args <- list()
[16:19:17.504]                 for (kk in seq_along(NAMES)) {
[16:19:17.504]                   name <- changed[[kk]]
[16:19:17.504]                   NAME <- NAMES[[kk]]
[16:19:17.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.504]                     next
[16:19:17.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.504]                 }
[16:19:17.504]                 NAMES <- toupper(added)
[16:19:17.504]                 for (kk in seq_along(NAMES)) {
[16:19:17.504]                   name <- added[[kk]]
[16:19:17.504]                   NAME <- NAMES[[kk]]
[16:19:17.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.504]                     next
[16:19:17.504]                   args[[name]] <- ""
[16:19:17.504]                 }
[16:19:17.504]                 NAMES <- toupper(removed)
[16:19:17.504]                 for (kk in seq_along(NAMES)) {
[16:19:17.504]                   name <- removed[[kk]]
[16:19:17.504]                   NAME <- NAMES[[kk]]
[16:19:17.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.504]                     next
[16:19:17.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.504]                 }
[16:19:17.504]                 if (length(args) > 0) 
[16:19:17.504]                   base::do.call(base::Sys.setenv, args = args)
[16:19:17.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:17.504]             }
[16:19:17.504]             else {
[16:19:17.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:17.504]             }
[16:19:17.504]             {
[16:19:17.504]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:17.504]                   0L) {
[16:19:17.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:17.504]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:17.504]                   base::options(opts)
[16:19:17.504]                 }
[16:19:17.504]                 {
[16:19:17.504]                   {
[16:19:17.504]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:17.504]                     NULL
[16:19:17.504]                   }
[16:19:17.504]                   options(future.plan = NULL)
[16:19:17.504]                   if (is.na(NA_character_)) 
[16:19:17.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:17.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:17.504]                     .init = FALSE)
[16:19:17.504]                 }
[16:19:17.504]             }
[16:19:17.504]         }
[16:19:17.504]     })
[16:19:17.504]     if (TRUE) {
[16:19:17.504]         base::sink(type = "output", split = FALSE)
[16:19:17.504]         if (TRUE) {
[16:19:17.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:17.504]         }
[16:19:17.504]         else {
[16:19:17.504]             ...future.result["stdout"] <- base::list(NULL)
[16:19:17.504]         }
[16:19:17.504]         base::close(...future.stdout)
[16:19:17.504]         ...future.stdout <- NULL
[16:19:17.504]     }
[16:19:17.504]     ...future.result$conditions <- ...future.conditions
[16:19:17.504]     ...future.result$finished <- base::Sys.time()
[16:19:17.504]     ...future.result
[16:19:17.504] }
[16:19:17.507] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[16:19:17.507] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:17.549] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:17.549] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:19:17.550] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:19:17.550] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:17.550] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:17.550] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:17.592] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:17.593] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:17.636] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:17.637] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:17.637] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.637] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:17.638] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:17.638] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:17.638] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.639] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:17.639] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:17.639] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:17.639] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.640] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:17.640] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.640] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[16:19:17.641] MultisessionFuture started
[16:19:17.641] - Launch lazy future ... done
[16:19:17.641] run() for ‘MultisessionFuture’ ... done
[16:19:17.641] Created future:
[16:19:17.643] receiveMessageFromWorker() for ClusterFuture ...
[16:19:17.643] - Validating connection of MultisessionFuture
[16:19:17.643] - received message: FutureResult
[16:19:17.643] - Received FutureResult
[16:19:17.643] - Erased future from FutureRegistry
[16:19:17.643] result() for ClusterFuture ...
[16:19:17.643] - result already collected: FutureResult
[16:19:17.643] result() for ClusterFuture ... done
[16:19:17.644] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:17.641] MultisessionFuture:
[16:19:17.641] Label: ‘future_vapply-1’
[16:19:17.641] Expression:
[16:19:17.641] {
[16:19:17.641]     do.call(function(...) {
[16:19:17.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.641]             on.exit(options(oopts), add = TRUE)
[16:19:17.641]         }
[16:19:17.641]         {
[16:19:17.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.641]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.641]             })
[16:19:17.641]         }
[16:19:17.641]     }, args = future.call.arguments)
[16:19:17.641] }
[16:19:17.641] Lazy evaluation: FALSE
[16:19:17.641] Asynchronous evaluation: TRUE
[16:19:17.641] Local evaluation: TRUE
[16:19:17.641] Environment: R_GlobalEnv
[16:19:17.641] Capture standard output: TRUE
[16:19:17.641] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:17.641] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:17.641] Packages: 1 packages (‘future.apply’)
[16:19:17.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:17.641] Resolved: TRUE
[16:19:17.641] Value: <not collected>
[16:19:17.641] Conditions captured: <none>
[16:19:17.641] Early signaling: FALSE
[16:19:17.641] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:17.641] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.644] Chunk #1 of 2 ... DONE
[16:19:17.644] Chunk #2 of 2 ...
[16:19:17.644]  - Finding globals in 'X' for chunk #2 ...
[16:19:17.644] getGlobalsAndPackages() ...
[16:19:17.644] Searching for globals...
[16:19:17.645] 
[16:19:17.645] Searching for globals ... DONE
[16:19:17.645] - globals: [0] <none>
[16:19:17.645] getGlobalsAndPackages() ... DONE
[16:19:17.645]    + additional globals found: [n=0] 
[16:19:17.645]    + additional namespaces needed: [n=0] 
[16:19:17.645]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:17.645]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:17.645]  - seeds: <none>
[16:19:17.645]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.646] getGlobalsAndPackages() ...
[16:19:17.646] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.646] Resolving globals: FALSE
[16:19:17.646] Tweak future expression to call with '...' arguments ...
[16:19:17.646] {
[16:19:17.646]     do.call(function(...) {
[16:19:17.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.646]             on.exit(options(oopts), add = TRUE)
[16:19:17.646]         }
[16:19:17.646]         {
[16:19:17.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.646]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.646]             })
[16:19:17.646]         }
[16:19:17.646]     }, args = future.call.arguments)
[16:19:17.646] }
[16:19:17.646] Tweak future expression to call with '...' arguments ... DONE
[16:19:17.647] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.647] - packages: [1] ‘future.apply’
[16:19:17.647] getGlobalsAndPackages() ... DONE
[16:19:17.647] run() for ‘Future’ ...
[16:19:17.647] - state: ‘created’
[16:19:17.648] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:17.662] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:17.662]   - Field: ‘node’
[16:19:17.662]   - Field: ‘label’
[16:19:17.662]   - Field: ‘local’
[16:19:17.662]   - Field: ‘owner’
[16:19:17.662]   - Field: ‘envir’
[16:19:17.662]   - Field: ‘workers’
[16:19:17.663]   - Field: ‘packages’
[16:19:17.663]   - Field: ‘gc’
[16:19:17.663]   - Field: ‘conditions’
[16:19:17.663]   - Field: ‘persistent’
[16:19:17.663]   - Field: ‘expr’
[16:19:17.663]   - Field: ‘uuid’
[16:19:17.663]   - Field: ‘seed’
[16:19:17.663]   - Field: ‘version’
[16:19:17.663]   - Field: ‘result’
[16:19:17.663]   - Field: ‘asynchronous’
[16:19:17.663]   - Field: ‘calls’
[16:19:17.664]   - Field: ‘globals’
[16:19:17.664]   - Field: ‘stdout’
[16:19:17.664]   - Field: ‘earlySignal’
[16:19:17.664]   - Field: ‘lazy’
[16:19:17.664]   - Field: ‘state’
[16:19:17.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:17.664] - Launch lazy future ...
[16:19:17.664] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:17.665] Packages needed by future strategies (n = 0): <none>
[16:19:17.665] {
[16:19:17.665]     {
[16:19:17.665]         {
[16:19:17.665]             ...future.startTime <- base::Sys.time()
[16:19:17.665]             {
[16:19:17.665]                 {
[16:19:17.665]                   {
[16:19:17.665]                     {
[16:19:17.665]                       {
[16:19:17.665]                         base::local({
[16:19:17.665]                           has_future <- base::requireNamespace("future", 
[16:19:17.665]                             quietly = TRUE)
[16:19:17.665]                           if (has_future) {
[16:19:17.665]                             ns <- base::getNamespace("future")
[16:19:17.665]                             version <- ns[[".package"]][["version"]]
[16:19:17.665]                             if (is.null(version)) 
[16:19:17.665]                               version <- utils::packageVersion("future")
[16:19:17.665]                           }
[16:19:17.665]                           else {
[16:19:17.665]                             version <- NULL
[16:19:17.665]                           }
[16:19:17.665]                           if (!has_future || version < "1.8.0") {
[16:19:17.665]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:17.665]                               "", base::R.version$version.string), 
[16:19:17.665]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:17.665]                                 base::R.version$platform, 8 * 
[16:19:17.665]                                   base::.Machine$sizeof.pointer), 
[16:19:17.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:17.665]                                 "release", "version")], collapse = " "), 
[16:19:17.665]                               hostname = base::Sys.info()[["nodename"]])
[16:19:17.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:17.665]                               info)
[16:19:17.665]                             info <- base::paste(info, collapse = "; ")
[16:19:17.665]                             if (!has_future) {
[16:19:17.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:17.665]                                 info)
[16:19:17.665]                             }
[16:19:17.665]                             else {
[16:19:17.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:17.665]                                 info, version)
[16:19:17.665]                             }
[16:19:17.665]                             base::stop(msg)
[16:19:17.665]                           }
[16:19:17.665]                         })
[16:19:17.665]                       }
[16:19:17.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:17.665]                       base::options(mc.cores = 1L)
[16:19:17.665]                     }
[16:19:17.665]                     base::local({
[16:19:17.665]                       for (pkg in "future.apply") {
[16:19:17.665]                         base::loadNamespace(pkg)
[16:19:17.665]                         base::library(pkg, character.only = TRUE)
[16:19:17.665]                       }
[16:19:17.665]                     })
[16:19:17.665]                   }
[16:19:17.665]                   ...future.strategy.old <- future::plan("list")
[16:19:17.665]                   options(future.plan = NULL)
[16:19:17.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:17.665]                 }
[16:19:17.665]                 ...future.workdir <- getwd()
[16:19:17.665]             }
[16:19:17.665]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:17.665]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:17.665]         }
[16:19:17.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:17.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:17.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:17.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:17.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:17.665]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:17.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:17.665]             base::names(...future.oldOptions))
[16:19:17.665]     }
[16:19:17.665]     if (FALSE) {
[16:19:17.665]     }
[16:19:17.665]     else {
[16:19:17.665]         if (TRUE) {
[16:19:17.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:17.665]                 open = "w")
[16:19:17.665]         }
[16:19:17.665]         else {
[16:19:17.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:17.665]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:17.665]         }
[16:19:17.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:17.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:17.665]             base::sink(type = "output", split = FALSE)
[16:19:17.665]             base::close(...future.stdout)
[16:19:17.665]         }, add = TRUE)
[16:19:17.665]     }
[16:19:17.665]     ...future.frame <- base::sys.nframe()
[16:19:17.665]     ...future.conditions <- base::list()
[16:19:17.665]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:17.665]     if (FALSE) {
[16:19:17.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:17.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:17.665]     }
[16:19:17.665]     ...future.result <- base::tryCatch({
[16:19:17.665]         base::withCallingHandlers({
[16:19:17.665]             ...future.value <- base::withVisible(base::local({
[16:19:17.665]                 ...future.makeSendCondition <- base::local({
[16:19:17.665]                   sendCondition <- NULL
[16:19:17.665]                   function(frame = 1L) {
[16:19:17.665]                     if (is.function(sendCondition)) 
[16:19:17.665]                       return(sendCondition)
[16:19:17.665]                     ns <- getNamespace("parallel")
[16:19:17.665]                     if (exists("sendData", mode = "function", 
[16:19:17.665]                       envir = ns)) {
[16:19:17.665]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:17.665]                         envir = ns)
[16:19:17.665]                       envir <- sys.frame(frame)
[16:19:17.665]                       master <- NULL
[16:19:17.665]                       while (!identical(envir, .GlobalEnv) && 
[16:19:17.665]                         !identical(envir, emptyenv())) {
[16:19:17.665]                         if (exists("master", mode = "list", envir = envir, 
[16:19:17.665]                           inherits = FALSE)) {
[16:19:17.665]                           master <- get("master", mode = "list", 
[16:19:17.665]                             envir = envir, inherits = FALSE)
[16:19:17.665]                           if (inherits(master, c("SOCKnode", 
[16:19:17.665]                             "SOCK0node"))) {
[16:19:17.665]                             sendCondition <<- function(cond) {
[16:19:17.665]                               data <- list(type = "VALUE", value = cond, 
[16:19:17.665]                                 success = TRUE)
[16:19:17.665]                               parallel_sendData(master, data)
[16:19:17.665]                             }
[16:19:17.665]                             return(sendCondition)
[16:19:17.665]                           }
[16:19:17.665]                         }
[16:19:17.665]                         frame <- frame + 1L
[16:19:17.665]                         envir <- sys.frame(frame)
[16:19:17.665]                       }
[16:19:17.665]                     }
[16:19:17.665]                     sendCondition <<- function(cond) NULL
[16:19:17.665]                   }
[16:19:17.665]                 })
[16:19:17.665]                 withCallingHandlers({
[16:19:17.665]                   {
[16:19:17.665]                     do.call(function(...) {
[16:19:17.665]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.665]                       if (!identical(...future.globals.maxSize.org, 
[16:19:17.665]                         ...future.globals.maxSize)) {
[16:19:17.665]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.665]                         on.exit(options(oopts), add = TRUE)
[16:19:17.665]                       }
[16:19:17.665]                       {
[16:19:17.665]                         lapply(seq_along(...future.elements_ii), 
[16:19:17.665]                           FUN = function(jj) {
[16:19:17.665]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.665]                             ...future.FUN(...future.X_jj, ...)
[16:19:17.665]                           })
[16:19:17.665]                       }
[16:19:17.665]                     }, args = future.call.arguments)
[16:19:17.665]                   }
[16:19:17.665]                 }, immediateCondition = function(cond) {
[16:19:17.665]                   sendCondition <- ...future.makeSendCondition()
[16:19:17.665]                   sendCondition(cond)
[16:19:17.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.665]                   {
[16:19:17.665]                     inherits <- base::inherits
[16:19:17.665]                     invokeRestart <- base::invokeRestart
[16:19:17.665]                     is.null <- base::is.null
[16:19:17.665]                     muffled <- FALSE
[16:19:17.665]                     if (inherits(cond, "message")) {
[16:19:17.665]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:17.665]                       if (muffled) 
[16:19:17.665]                         invokeRestart("muffleMessage")
[16:19:17.665]                     }
[16:19:17.665]                     else if (inherits(cond, "warning")) {
[16:19:17.665]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:17.665]                       if (muffled) 
[16:19:17.665]                         invokeRestart("muffleWarning")
[16:19:17.665]                     }
[16:19:17.665]                     else if (inherits(cond, "condition")) {
[16:19:17.665]                       if (!is.null(pattern)) {
[16:19:17.665]                         computeRestarts <- base::computeRestarts
[16:19:17.665]                         grepl <- base::grepl
[16:19:17.665]                         restarts <- computeRestarts(cond)
[16:19:17.665]                         for (restart in restarts) {
[16:19:17.665]                           name <- restart$name
[16:19:17.665]                           if (is.null(name)) 
[16:19:17.665]                             next
[16:19:17.665]                           if (!grepl(pattern, name)) 
[16:19:17.665]                             next
[16:19:17.665]                           invokeRestart(restart)
[16:19:17.665]                           muffled <- TRUE
[16:19:17.665]                           break
[16:19:17.665]                         }
[16:19:17.665]                       }
[16:19:17.665]                     }
[16:19:17.665]                     invisible(muffled)
[16:19:17.665]                   }
[16:19:17.665]                   muffleCondition(cond)
[16:19:17.665]                 })
[16:19:17.665]             }))
[16:19:17.665]             future::FutureResult(value = ...future.value$value, 
[16:19:17.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.665]                   ...future.rng), globalenv = if (FALSE) 
[16:19:17.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:17.665]                     ...future.globalenv.names))
[16:19:17.665]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:17.665]         }, condition = base::local({
[16:19:17.665]             c <- base::c
[16:19:17.665]             inherits <- base::inherits
[16:19:17.665]             invokeRestart <- base::invokeRestart
[16:19:17.665]             length <- base::length
[16:19:17.665]             list <- base::list
[16:19:17.665]             seq.int <- base::seq.int
[16:19:17.665]             signalCondition <- base::signalCondition
[16:19:17.665]             sys.calls <- base::sys.calls
[16:19:17.665]             `[[` <- base::`[[`
[16:19:17.665]             `+` <- base::`+`
[16:19:17.665]             `<<-` <- base::`<<-`
[16:19:17.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:17.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:17.665]                   3L)]
[16:19:17.665]             }
[16:19:17.665]             function(cond) {
[16:19:17.665]                 is_error <- inherits(cond, "error")
[16:19:17.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:17.665]                   NULL)
[16:19:17.665]                 if (is_error) {
[16:19:17.665]                   sessionInformation <- function() {
[16:19:17.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:17.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:17.665]                       search = base::search(), system = base::Sys.info())
[16:19:17.665]                   }
[16:19:17.665]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:17.665]                     cond$call), session = sessionInformation(), 
[16:19:17.665]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:17.665]                   signalCondition(cond)
[16:19:17.665]                 }
[16:19:17.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:17.665]                 "immediateCondition"))) {
[16:19:17.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:17.665]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:17.665]                   if (TRUE && !signal) {
[16:19:17.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.665]                     {
[16:19:17.665]                       inherits <- base::inherits
[16:19:17.665]                       invokeRestart <- base::invokeRestart
[16:19:17.665]                       is.null <- base::is.null
[16:19:17.665]                       muffled <- FALSE
[16:19:17.665]                       if (inherits(cond, "message")) {
[16:19:17.665]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.665]                         if (muffled) 
[16:19:17.665]                           invokeRestart("muffleMessage")
[16:19:17.665]                       }
[16:19:17.665]                       else if (inherits(cond, "warning")) {
[16:19:17.665]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.665]                         if (muffled) 
[16:19:17.665]                           invokeRestart("muffleWarning")
[16:19:17.665]                       }
[16:19:17.665]                       else if (inherits(cond, "condition")) {
[16:19:17.665]                         if (!is.null(pattern)) {
[16:19:17.665]                           computeRestarts <- base::computeRestarts
[16:19:17.665]                           grepl <- base::grepl
[16:19:17.665]                           restarts <- computeRestarts(cond)
[16:19:17.665]                           for (restart in restarts) {
[16:19:17.665]                             name <- restart$name
[16:19:17.665]                             if (is.null(name)) 
[16:19:17.665]                               next
[16:19:17.665]                             if (!grepl(pattern, name)) 
[16:19:17.665]                               next
[16:19:17.665]                             invokeRestart(restart)
[16:19:17.665]                             muffled <- TRUE
[16:19:17.665]                             break
[16:19:17.665]                           }
[16:19:17.665]                         }
[16:19:17.665]                       }
[16:19:17.665]                       invisible(muffled)
[16:19:17.665]                     }
[16:19:17.665]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.665]                   }
[16:19:17.665]                 }
[16:19:17.665]                 else {
[16:19:17.665]                   if (TRUE) {
[16:19:17.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.665]                     {
[16:19:17.665]                       inherits <- base::inherits
[16:19:17.665]                       invokeRestart <- base::invokeRestart
[16:19:17.665]                       is.null <- base::is.null
[16:19:17.665]                       muffled <- FALSE
[16:19:17.665]                       if (inherits(cond, "message")) {
[16:19:17.665]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.665]                         if (muffled) 
[16:19:17.665]                           invokeRestart("muffleMessage")
[16:19:17.665]                       }
[16:19:17.665]                       else if (inherits(cond, "warning")) {
[16:19:17.665]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.665]                         if (muffled) 
[16:19:17.665]                           invokeRestart("muffleWarning")
[16:19:17.665]                       }
[16:19:17.665]                       else if (inherits(cond, "condition")) {
[16:19:17.665]                         if (!is.null(pattern)) {
[16:19:17.665]                           computeRestarts <- base::computeRestarts
[16:19:17.665]                           grepl <- base::grepl
[16:19:17.665]                           restarts <- computeRestarts(cond)
[16:19:17.665]                           for (restart in restarts) {
[16:19:17.665]                             name <- restart$name
[16:19:17.665]                             if (is.null(name)) 
[16:19:17.665]                               next
[16:19:17.665]                             if (!grepl(pattern, name)) 
[16:19:17.665]                               next
[16:19:17.665]                             invokeRestart(restart)
[16:19:17.665]                             muffled <- TRUE
[16:19:17.665]                             break
[16:19:17.665]                           }
[16:19:17.665]                         }
[16:19:17.665]                       }
[16:19:17.665]                       invisible(muffled)
[16:19:17.665]                     }
[16:19:17.665]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.665]                   }
[16:19:17.665]                 }
[16:19:17.665]             }
[16:19:17.665]         }))
[16:19:17.665]     }, error = function(ex) {
[16:19:17.665]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:17.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.665]                 ...future.rng), started = ...future.startTime, 
[16:19:17.665]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:17.665]             version = "1.8"), class = "FutureResult")
[16:19:17.665]     }, finally = {
[16:19:17.665]         if (!identical(...future.workdir, getwd())) 
[16:19:17.665]             setwd(...future.workdir)
[16:19:17.665]         {
[16:19:17.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:17.665]                 ...future.oldOptions$nwarnings <- NULL
[16:19:17.665]             }
[16:19:17.665]             base::options(...future.oldOptions)
[16:19:17.665]             if (.Platform$OS.type == "windows") {
[16:19:17.665]                 old_names <- names(...future.oldEnvVars)
[16:19:17.665]                 envs <- base::Sys.getenv()
[16:19:17.665]                 names <- names(envs)
[16:19:17.665]                 common <- intersect(names, old_names)
[16:19:17.665]                 added <- setdiff(names, old_names)
[16:19:17.665]                 removed <- setdiff(old_names, names)
[16:19:17.665]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:17.665]                   envs[common]]
[16:19:17.665]                 NAMES <- toupper(changed)
[16:19:17.665]                 args <- list()
[16:19:17.665]                 for (kk in seq_along(NAMES)) {
[16:19:17.665]                   name <- changed[[kk]]
[16:19:17.665]                   NAME <- NAMES[[kk]]
[16:19:17.665]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.665]                     next
[16:19:17.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.665]                 }
[16:19:17.665]                 NAMES <- toupper(added)
[16:19:17.665]                 for (kk in seq_along(NAMES)) {
[16:19:17.665]                   name <- added[[kk]]
[16:19:17.665]                   NAME <- NAMES[[kk]]
[16:19:17.665]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.665]                     next
[16:19:17.665]                   args[[name]] <- ""
[16:19:17.665]                 }
[16:19:17.665]                 NAMES <- toupper(removed)
[16:19:17.665]                 for (kk in seq_along(NAMES)) {
[16:19:17.665]                   name <- removed[[kk]]
[16:19:17.665]                   NAME <- NAMES[[kk]]
[16:19:17.665]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.665]                     next
[16:19:17.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.665]                 }
[16:19:17.665]                 if (length(args) > 0) 
[16:19:17.665]                   base::do.call(base::Sys.setenv, args = args)
[16:19:17.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:17.665]             }
[16:19:17.665]             else {
[16:19:17.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:17.665]             }
[16:19:17.665]             {
[16:19:17.665]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:17.665]                   0L) {
[16:19:17.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:17.665]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:17.665]                   base::options(opts)
[16:19:17.665]                 }
[16:19:17.665]                 {
[16:19:17.665]                   {
[16:19:17.665]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:17.665]                     NULL
[16:19:17.665]                   }
[16:19:17.665]                   options(future.plan = NULL)
[16:19:17.665]                   if (is.na(NA_character_)) 
[16:19:17.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:17.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:17.665]                     .init = FALSE)
[16:19:17.665]                 }
[16:19:17.665]             }
[16:19:17.665]         }
[16:19:17.665]     })
[16:19:17.665]     if (TRUE) {
[16:19:17.665]         base::sink(type = "output", split = FALSE)
[16:19:17.665]         if (TRUE) {
[16:19:17.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:17.665]         }
[16:19:17.665]         else {
[16:19:17.665]             ...future.result["stdout"] <- base::list(NULL)
[16:19:17.665]         }
[16:19:17.665]         base::close(...future.stdout)
[16:19:17.665]         ...future.stdout <- NULL
[16:19:17.665]     }
[16:19:17.665]     ...future.result$conditions <- ...future.conditions
[16:19:17.665]     ...future.result$finished <- base::Sys.time()
[16:19:17.665]     ...future.result
[16:19:17.665] }
[16:19:17.668] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[16:19:17.668] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:17.709] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:17.709] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:19:17.709] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:19:17.710] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:17.710] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:17.710] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:17.752] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:17.753] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:17.797] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:17.797] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:17.797] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.797] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:17.798] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:17.798] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:17.798] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.799] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:17.799] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:17.799] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:17.799] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.800] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:17.800] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.800] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[16:19:17.801] MultisessionFuture started
[16:19:17.801] - Launch lazy future ... done
[16:19:17.801] run() for ‘MultisessionFuture’ ... done
[16:19:17.801] Created future:
[16:19:17.803] receiveMessageFromWorker() for ClusterFuture ...
[16:19:17.803] - Validating connection of MultisessionFuture
[16:19:17.803] - received message: FutureResult
[16:19:17.803] - Received FutureResult
[16:19:17.803] - Erased future from FutureRegistry
[16:19:17.803] result() for ClusterFuture ...
[16:19:17.803] - result already collected: FutureResult
[16:19:17.803] result() for ClusterFuture ... done
[16:19:17.804] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:17.801] MultisessionFuture:
[16:19:17.801] Label: ‘future_vapply-2’
[16:19:17.801] Expression:
[16:19:17.801] {
[16:19:17.801]     do.call(function(...) {
[16:19:17.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.801]             on.exit(options(oopts), add = TRUE)
[16:19:17.801]         }
[16:19:17.801]         {
[16:19:17.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.801]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.801]             })
[16:19:17.801]         }
[16:19:17.801]     }, args = future.call.arguments)
[16:19:17.801] }
[16:19:17.801] Lazy evaluation: FALSE
[16:19:17.801] Asynchronous evaluation: TRUE
[16:19:17.801] Local evaluation: TRUE
[16:19:17.801] Environment: R_GlobalEnv
[16:19:17.801] Capture standard output: TRUE
[16:19:17.801] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:17.801] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:17.801] Packages: 1 packages (‘future.apply’)
[16:19:17.801] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:17.801] Resolved: TRUE
[16:19:17.801] Value: <not collected>
[16:19:17.801] Conditions captured: <none>
[16:19:17.801] Early signaling: FALSE
[16:19:17.801] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:17.801] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.804] Chunk #2 of 2 ... DONE
[16:19:17.804] Launching 2 futures (chunks) ... DONE
[16:19:17.804] Resolving 2 futures (chunks) ...
[16:19:17.804] resolve() on list ...
[16:19:17.804]  recursive: 0
[16:19:17.804]  length: 2
[16:19:17.804] 
[16:19:17.805] Future #1
[16:19:17.805] result() for ClusterFuture ...
[16:19:17.805] - result already collected: FutureResult
[16:19:17.805] result() for ClusterFuture ... done
[16:19:17.805] result() for ClusterFuture ...
[16:19:17.805] - result already collected: FutureResult
[16:19:17.805] result() for ClusterFuture ... done
[16:19:17.805] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:17.805] - nx: 2
[16:19:17.805] - relay: TRUE
[16:19:17.805] - stdout: TRUE
[16:19:17.806] - signal: TRUE
[16:19:17.806] - resignal: FALSE
[16:19:17.806] - force: TRUE
[16:19:17.806] - relayed: [n=2] FALSE, FALSE
[16:19:17.806] - queued futures: [n=2] FALSE, FALSE
[16:19:17.806]  - until=1
[16:19:17.806]  - relaying element #1
[16:19:17.806] result() for ClusterFuture ...
[16:19:17.806] - result already collected: FutureResult
[16:19:17.806] result() for ClusterFuture ... done
[16:19:17.806] result() for ClusterFuture ...
[16:19:17.806] - result already collected: FutureResult
[16:19:17.807] result() for ClusterFuture ... done
[16:19:17.807] result() for ClusterFuture ...
[16:19:17.807] - result already collected: FutureResult
[16:19:17.807] result() for ClusterFuture ... done
[16:19:17.807] result() for ClusterFuture ...
[16:19:17.807] - result already collected: FutureResult
[16:19:17.807] result() for ClusterFuture ... done
[16:19:17.807] - relayed: [n=2] TRUE, FALSE
[16:19:17.807] - queued futures: [n=2] TRUE, FALSE
[16:19:17.807] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:17.807]  length: 1 (resolved future 1)
[16:19:17.808] Future #2
[16:19:17.808] result() for ClusterFuture ...
[16:19:17.808] - result already collected: FutureResult
[16:19:17.808] result() for ClusterFuture ... done
[16:19:17.808] result() for ClusterFuture ...
[16:19:17.808] - result already collected: FutureResult
[16:19:17.808] result() for ClusterFuture ... done
[16:19:17.808] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:17.808] - nx: 2
[16:19:17.808] - relay: TRUE
[16:19:17.808] - stdout: TRUE
[16:19:17.809] - signal: TRUE
[16:19:17.809] - resignal: FALSE
[16:19:17.809] - force: TRUE
[16:19:17.809] - relayed: [n=2] TRUE, FALSE
[16:19:17.809] - queued futures: [n=2] TRUE, FALSE
[16:19:17.809]  - until=2
[16:19:17.809]  - relaying element #2
[16:19:17.809] result() for ClusterFuture ...
[16:19:17.809] - result already collected: FutureResult
[16:19:17.809] result() for ClusterFuture ... done
[16:19:17.809] result() for ClusterFuture ...
[16:19:17.810] - result already collected: FutureResult
[16:19:17.810] result() for ClusterFuture ... done
[16:19:17.810] result() for ClusterFuture ...
[16:19:17.810] - result already collected: FutureResult
[16:19:17.810] result() for ClusterFuture ... done
[16:19:17.810] result() for ClusterFuture ...
[16:19:17.810] - result already collected: FutureResult
[16:19:17.810] result() for ClusterFuture ... done
[16:19:17.810] - relayed: [n=2] TRUE, TRUE
[16:19:17.810] - queued futures: [n=2] TRUE, TRUE
[16:19:17.810] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:17.811]  length: 0 (resolved future 2)
[16:19:17.811] Relaying remaining futures
[16:19:17.811] signalConditionsASAP(NULL, pos=0) ...
[16:19:17.811] - nx: 2
[16:19:17.811] - relay: TRUE
[16:19:17.811] - stdout: TRUE
[16:19:17.811] - signal: TRUE
[16:19:17.811] - resignal: FALSE
[16:19:17.811] - force: TRUE
[16:19:17.811] - relayed: [n=2] TRUE, TRUE
[16:19:17.811] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:17.811] - relayed: [n=2] TRUE, TRUE
[16:19:17.812] - queued futures: [n=2] TRUE, TRUE
[16:19:17.812] signalConditionsASAP(NULL, pos=0) ... done
[16:19:17.812] resolve() on list ... DONE
[16:19:17.812] result() for ClusterFuture ...
[16:19:17.812] - result already collected: FutureResult
[16:19:17.812] result() for ClusterFuture ... done
[16:19:17.812] result() for ClusterFuture ...
[16:19:17.812] - result already collected: FutureResult
[16:19:17.812] result() for ClusterFuture ... done
[16:19:17.812] result() for ClusterFuture ...
[16:19:17.812] - result already collected: FutureResult
[16:19:17.813] result() for ClusterFuture ... done
[16:19:17.813] result() for ClusterFuture ...
[16:19:17.813] - result already collected: FutureResult
[16:19:17.813] result() for ClusterFuture ... done
[16:19:17.813]  - Number of value chunks collected: 2
[16:19:17.813] Resolving 2 futures (chunks) ... DONE
[16:19:17.813] Reducing values from 2 chunks ...
[16:19:17.813]  - Number of values collected after concatenation: 10
[16:19:17.813]  - Number of values expected: 10
[16:19:17.813] Reducing values from 2 chunks ... DONE
[16:19:17.813] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:19:17.814] future_lapply() ...
[16:19:17.820] Number of chunks: 2
[16:19:17.820] getGlobalsAndPackagesXApply() ...
[16:19:17.820]  - future.globals: TRUE
[16:19:17.820] getGlobalsAndPackages() ...
[16:19:17.820] Searching for globals...
[16:19:17.824] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:19:17.824] Searching for globals ... DONE
[16:19:17.824] Resolving globals: FALSE
[16:19:17.825] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:19:17.825] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:17.825] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:17.826] - packages: [1] ‘future.apply’
[16:19:17.826] getGlobalsAndPackages() ... DONE
[16:19:17.826]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:17.826]  - needed namespaces: [n=1] ‘future.apply’
[16:19:17.826] Finding globals ... DONE
[16:19:17.826]  - use_args: TRUE
[16:19:17.826]  - Getting '...' globals ...
[16:19:17.826] resolve() on list ...
[16:19:17.827]  recursive: 0
[16:19:17.827]  length: 1
[16:19:17.827]  elements: ‘...’
[16:19:17.827]  length: 0 (resolved future 1)
[16:19:17.827] resolve() on list ... DONE
[16:19:17.827]    - '...' content: [n=0] 
[16:19:17.827] List of 1
[16:19:17.827]  $ ...: list()
[16:19:17.827]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:17.827]  - attr(*, "where")=List of 1
[16:19:17.827]   ..$ ...:<environment: 0x5619a04f7280> 
[16:19:17.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:17.827]  - attr(*, "resolved")= logi TRUE
[16:19:17.827]  - attr(*, "total_size")= num NA
[16:19:17.830]  - Getting '...' globals ... DONE
[16:19:17.830] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:17.830] List of 8
[16:19:17.830]  $ ...future.FUN:function (x, ...)  
[16:19:17.830]  $ x_FUN        :function (x)  
[16:19:17.830]  $ times        : int 2
[16:19:17.830]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:17.830]  $ stop_if_not  :function (...)  
[16:19:17.830]  $ dim          : NULL
[16:19:17.830]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:17.830]  $ ...          : list()
[16:19:17.830]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:17.830]  - attr(*, "where")=List of 8
[16:19:17.830]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:17.830]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:17.830]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:17.830]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:17.830]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:17.830]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:17.830]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:17.830]   ..$ ...          :<environment: 0x5619a04f7280> 
[16:19:17.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:17.830]  - attr(*, "resolved")= logi FALSE
[16:19:17.830]  - attr(*, "total_size")= num 96456
[16:19:17.835] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:17.835] getGlobalsAndPackagesXApply() ... DONE
[16:19:17.835] Number of futures (= number of chunks): 2
[16:19:17.836] Launching 2 futures (chunks) ...
[16:19:17.836] Chunk #1 of 2 ...
[16:19:17.836]  - Finding globals in 'X' for chunk #1 ...
[16:19:17.836] getGlobalsAndPackages() ...
[16:19:17.836] Searching for globals...
[16:19:17.836] 
[16:19:17.836] Searching for globals ... DONE
[16:19:17.836] - globals: [0] <none>
[16:19:17.837] getGlobalsAndPackages() ... DONE
[16:19:17.837]    + additional globals found: [n=0] 
[16:19:17.837]    + additional namespaces needed: [n=0] 
[16:19:17.837]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:17.837]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:17.837]  - seeds: <none>
[16:19:17.837]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.837] getGlobalsAndPackages() ...
[16:19:17.837] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.837] Resolving globals: FALSE
[16:19:17.838] Tweak future expression to call with '...' arguments ...
[16:19:17.838] {
[16:19:17.838]     do.call(function(...) {
[16:19:17.838]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.838]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.838]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.838]             on.exit(options(oopts), add = TRUE)
[16:19:17.838]         }
[16:19:17.838]         {
[16:19:17.838]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.838]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.838]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.838]             })
[16:19:17.838]         }
[16:19:17.838]     }, args = future.call.arguments)
[16:19:17.838] }
[16:19:17.838] Tweak future expression to call with '...' arguments ... DONE
[16:19:17.838] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:17.839] - packages: [1] ‘future.apply’
[16:19:17.839] getGlobalsAndPackages() ... DONE
[16:19:17.839] run() for ‘Future’ ...
[16:19:17.839] - state: ‘created’
[16:19:17.839] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:17.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:17.853]   - Field: ‘node’
[16:19:17.853]   - Field: ‘label’
[16:19:17.853]   - Field: ‘local’
[16:19:17.854]   - Field: ‘owner’
[16:19:17.854]   - Field: ‘envir’
[16:19:17.854]   - Field: ‘workers’
[16:19:17.854]   - Field: ‘packages’
[16:19:17.854]   - Field: ‘gc’
[16:19:17.854]   - Field: ‘conditions’
[16:19:17.854]   - Field: ‘persistent’
[16:19:17.854]   - Field: ‘expr’
[16:19:17.854]   - Field: ‘uuid’
[16:19:17.854]   - Field: ‘seed’
[16:19:17.854]   - Field: ‘version’
[16:19:17.855]   - Field: ‘result’
[16:19:17.855]   - Field: ‘asynchronous’
[16:19:17.855]   - Field: ‘calls’
[16:19:17.855]   - Field: ‘globals’
[16:19:17.855]   - Field: ‘stdout’
[16:19:17.855]   - Field: ‘earlySignal’
[16:19:17.855]   - Field: ‘lazy’
[16:19:17.855]   - Field: ‘state’
[16:19:17.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:17.855] - Launch lazy future ...
[16:19:17.856] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:17.856] Packages needed by future strategies (n = 0): <none>
[16:19:17.856] {
[16:19:17.856]     {
[16:19:17.856]         {
[16:19:17.856]             ...future.startTime <- base::Sys.time()
[16:19:17.856]             {
[16:19:17.856]                 {
[16:19:17.856]                   {
[16:19:17.856]                     {
[16:19:17.856]                       {
[16:19:17.856]                         base::local({
[16:19:17.856]                           has_future <- base::requireNamespace("future", 
[16:19:17.856]                             quietly = TRUE)
[16:19:17.856]                           if (has_future) {
[16:19:17.856]                             ns <- base::getNamespace("future")
[16:19:17.856]                             version <- ns[[".package"]][["version"]]
[16:19:17.856]                             if (is.null(version)) 
[16:19:17.856]                               version <- utils::packageVersion("future")
[16:19:17.856]                           }
[16:19:17.856]                           else {
[16:19:17.856]                             version <- NULL
[16:19:17.856]                           }
[16:19:17.856]                           if (!has_future || version < "1.8.0") {
[16:19:17.856]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:17.856]                               "", base::R.version$version.string), 
[16:19:17.856]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:17.856]                                 base::R.version$platform, 8 * 
[16:19:17.856]                                   base::.Machine$sizeof.pointer), 
[16:19:17.856]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:17.856]                                 "release", "version")], collapse = " "), 
[16:19:17.856]                               hostname = base::Sys.info()[["nodename"]])
[16:19:17.856]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:17.856]                               info)
[16:19:17.856]                             info <- base::paste(info, collapse = "; ")
[16:19:17.856]                             if (!has_future) {
[16:19:17.856]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:17.856]                                 info)
[16:19:17.856]                             }
[16:19:17.856]                             else {
[16:19:17.856]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:17.856]                                 info, version)
[16:19:17.856]                             }
[16:19:17.856]                             base::stop(msg)
[16:19:17.856]                           }
[16:19:17.856]                         })
[16:19:17.856]                       }
[16:19:17.856]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:17.856]                       base::options(mc.cores = 1L)
[16:19:17.856]                     }
[16:19:17.856]                     base::local({
[16:19:17.856]                       for (pkg in "future.apply") {
[16:19:17.856]                         base::loadNamespace(pkg)
[16:19:17.856]                         base::library(pkg, character.only = TRUE)
[16:19:17.856]                       }
[16:19:17.856]                     })
[16:19:17.856]                   }
[16:19:17.856]                   ...future.strategy.old <- future::plan("list")
[16:19:17.856]                   options(future.plan = NULL)
[16:19:17.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:17.856]                 }
[16:19:17.856]                 ...future.workdir <- getwd()
[16:19:17.856]             }
[16:19:17.856]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:17.856]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:17.856]         }
[16:19:17.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:17.856]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:17.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:17.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:17.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:17.856]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:17.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:17.856]             base::names(...future.oldOptions))
[16:19:17.856]     }
[16:19:17.856]     if (FALSE) {
[16:19:17.856]     }
[16:19:17.856]     else {
[16:19:17.856]         if (TRUE) {
[16:19:17.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:17.856]                 open = "w")
[16:19:17.856]         }
[16:19:17.856]         else {
[16:19:17.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:17.856]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:17.856]         }
[16:19:17.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:17.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:17.856]             base::sink(type = "output", split = FALSE)
[16:19:17.856]             base::close(...future.stdout)
[16:19:17.856]         }, add = TRUE)
[16:19:17.856]     }
[16:19:17.856]     ...future.frame <- base::sys.nframe()
[16:19:17.856]     ...future.conditions <- base::list()
[16:19:17.856]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:17.856]     if (FALSE) {
[16:19:17.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:17.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:17.856]     }
[16:19:17.856]     ...future.result <- base::tryCatch({
[16:19:17.856]         base::withCallingHandlers({
[16:19:17.856]             ...future.value <- base::withVisible(base::local({
[16:19:17.856]                 ...future.makeSendCondition <- base::local({
[16:19:17.856]                   sendCondition <- NULL
[16:19:17.856]                   function(frame = 1L) {
[16:19:17.856]                     if (is.function(sendCondition)) 
[16:19:17.856]                       return(sendCondition)
[16:19:17.856]                     ns <- getNamespace("parallel")
[16:19:17.856]                     if (exists("sendData", mode = "function", 
[16:19:17.856]                       envir = ns)) {
[16:19:17.856]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:17.856]                         envir = ns)
[16:19:17.856]                       envir <- sys.frame(frame)
[16:19:17.856]                       master <- NULL
[16:19:17.856]                       while (!identical(envir, .GlobalEnv) && 
[16:19:17.856]                         !identical(envir, emptyenv())) {
[16:19:17.856]                         if (exists("master", mode = "list", envir = envir, 
[16:19:17.856]                           inherits = FALSE)) {
[16:19:17.856]                           master <- get("master", mode = "list", 
[16:19:17.856]                             envir = envir, inherits = FALSE)
[16:19:17.856]                           if (inherits(master, c("SOCKnode", 
[16:19:17.856]                             "SOCK0node"))) {
[16:19:17.856]                             sendCondition <<- function(cond) {
[16:19:17.856]                               data <- list(type = "VALUE", value = cond, 
[16:19:17.856]                                 success = TRUE)
[16:19:17.856]                               parallel_sendData(master, data)
[16:19:17.856]                             }
[16:19:17.856]                             return(sendCondition)
[16:19:17.856]                           }
[16:19:17.856]                         }
[16:19:17.856]                         frame <- frame + 1L
[16:19:17.856]                         envir <- sys.frame(frame)
[16:19:17.856]                       }
[16:19:17.856]                     }
[16:19:17.856]                     sendCondition <<- function(cond) NULL
[16:19:17.856]                   }
[16:19:17.856]                 })
[16:19:17.856]                 withCallingHandlers({
[16:19:17.856]                   {
[16:19:17.856]                     do.call(function(...) {
[16:19:17.856]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.856]                       if (!identical(...future.globals.maxSize.org, 
[16:19:17.856]                         ...future.globals.maxSize)) {
[16:19:17.856]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.856]                         on.exit(options(oopts), add = TRUE)
[16:19:17.856]                       }
[16:19:17.856]                       {
[16:19:17.856]                         lapply(seq_along(...future.elements_ii), 
[16:19:17.856]                           FUN = function(jj) {
[16:19:17.856]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.856]                             ...future.FUN(...future.X_jj, ...)
[16:19:17.856]                           })
[16:19:17.856]                       }
[16:19:17.856]                     }, args = future.call.arguments)
[16:19:17.856]                   }
[16:19:17.856]                 }, immediateCondition = function(cond) {
[16:19:17.856]                   sendCondition <- ...future.makeSendCondition()
[16:19:17.856]                   sendCondition(cond)
[16:19:17.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.856]                   {
[16:19:17.856]                     inherits <- base::inherits
[16:19:17.856]                     invokeRestart <- base::invokeRestart
[16:19:17.856]                     is.null <- base::is.null
[16:19:17.856]                     muffled <- FALSE
[16:19:17.856]                     if (inherits(cond, "message")) {
[16:19:17.856]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:17.856]                       if (muffled) 
[16:19:17.856]                         invokeRestart("muffleMessage")
[16:19:17.856]                     }
[16:19:17.856]                     else if (inherits(cond, "warning")) {
[16:19:17.856]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:17.856]                       if (muffled) 
[16:19:17.856]                         invokeRestart("muffleWarning")
[16:19:17.856]                     }
[16:19:17.856]                     else if (inherits(cond, "condition")) {
[16:19:17.856]                       if (!is.null(pattern)) {
[16:19:17.856]                         computeRestarts <- base::computeRestarts
[16:19:17.856]                         grepl <- base::grepl
[16:19:17.856]                         restarts <- computeRestarts(cond)
[16:19:17.856]                         for (restart in restarts) {
[16:19:17.856]                           name <- restart$name
[16:19:17.856]                           if (is.null(name)) 
[16:19:17.856]                             next
[16:19:17.856]                           if (!grepl(pattern, name)) 
[16:19:17.856]                             next
[16:19:17.856]                           invokeRestart(restart)
[16:19:17.856]                           muffled <- TRUE
[16:19:17.856]                           break
[16:19:17.856]                         }
[16:19:17.856]                       }
[16:19:17.856]                     }
[16:19:17.856]                     invisible(muffled)
[16:19:17.856]                   }
[16:19:17.856]                   muffleCondition(cond)
[16:19:17.856]                 })
[16:19:17.856]             }))
[16:19:17.856]             future::FutureResult(value = ...future.value$value, 
[16:19:17.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.856]                   ...future.rng), globalenv = if (FALSE) 
[16:19:17.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:17.856]                     ...future.globalenv.names))
[16:19:17.856]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:17.856]         }, condition = base::local({
[16:19:17.856]             c <- base::c
[16:19:17.856]             inherits <- base::inherits
[16:19:17.856]             invokeRestart <- base::invokeRestart
[16:19:17.856]             length <- base::length
[16:19:17.856]             list <- base::list
[16:19:17.856]             seq.int <- base::seq.int
[16:19:17.856]             signalCondition <- base::signalCondition
[16:19:17.856]             sys.calls <- base::sys.calls
[16:19:17.856]             `[[` <- base::`[[`
[16:19:17.856]             `+` <- base::`+`
[16:19:17.856]             `<<-` <- base::`<<-`
[16:19:17.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:17.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:17.856]                   3L)]
[16:19:17.856]             }
[16:19:17.856]             function(cond) {
[16:19:17.856]                 is_error <- inherits(cond, "error")
[16:19:17.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:17.856]                   NULL)
[16:19:17.856]                 if (is_error) {
[16:19:17.856]                   sessionInformation <- function() {
[16:19:17.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:17.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:17.856]                       search = base::search(), system = base::Sys.info())
[16:19:17.856]                   }
[16:19:17.856]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:17.856]                     cond$call), session = sessionInformation(), 
[16:19:17.856]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:17.856]                   signalCondition(cond)
[16:19:17.856]                 }
[16:19:17.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:17.856]                 "immediateCondition"))) {
[16:19:17.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:17.856]                   ...future.conditions[[length(...future.conditions) + 
[16:19:17.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:17.856]                   if (TRUE && !signal) {
[16:19:17.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.856]                     {
[16:19:17.856]                       inherits <- base::inherits
[16:19:17.856]                       invokeRestart <- base::invokeRestart
[16:19:17.856]                       is.null <- base::is.null
[16:19:17.856]                       muffled <- FALSE
[16:19:17.856]                       if (inherits(cond, "message")) {
[16:19:17.856]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.856]                         if (muffled) 
[16:19:17.856]                           invokeRestart("muffleMessage")
[16:19:17.856]                       }
[16:19:17.856]                       else if (inherits(cond, "warning")) {
[16:19:17.856]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.856]                         if (muffled) 
[16:19:17.856]                           invokeRestart("muffleWarning")
[16:19:17.856]                       }
[16:19:17.856]                       else if (inherits(cond, "condition")) {
[16:19:17.856]                         if (!is.null(pattern)) {
[16:19:17.856]                           computeRestarts <- base::computeRestarts
[16:19:17.856]                           grepl <- base::grepl
[16:19:17.856]                           restarts <- computeRestarts(cond)
[16:19:17.856]                           for (restart in restarts) {
[16:19:17.856]                             name <- restart$name
[16:19:17.856]                             if (is.null(name)) 
[16:19:17.856]                               next
[16:19:17.856]                             if (!grepl(pattern, name)) 
[16:19:17.856]                               next
[16:19:17.856]                             invokeRestart(restart)
[16:19:17.856]                             muffled <- TRUE
[16:19:17.856]                             break
[16:19:17.856]                           }
[16:19:17.856]                         }
[16:19:17.856]                       }
[16:19:17.856]                       invisible(muffled)
[16:19:17.856]                     }
[16:19:17.856]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.856]                   }
[16:19:17.856]                 }
[16:19:17.856]                 else {
[16:19:17.856]                   if (TRUE) {
[16:19:17.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:17.856]                     {
[16:19:17.856]                       inherits <- base::inherits
[16:19:17.856]                       invokeRestart <- base::invokeRestart
[16:19:17.856]                       is.null <- base::is.null
[16:19:17.856]                       muffled <- FALSE
[16:19:17.856]                       if (inherits(cond, "message")) {
[16:19:17.856]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:17.856]                         if (muffled) 
[16:19:17.856]                           invokeRestart("muffleMessage")
[16:19:17.856]                       }
[16:19:17.856]                       else if (inherits(cond, "warning")) {
[16:19:17.856]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:17.856]                         if (muffled) 
[16:19:17.856]                           invokeRestart("muffleWarning")
[16:19:17.856]                       }
[16:19:17.856]                       else if (inherits(cond, "condition")) {
[16:19:17.856]                         if (!is.null(pattern)) {
[16:19:17.856]                           computeRestarts <- base::computeRestarts
[16:19:17.856]                           grepl <- base::grepl
[16:19:17.856]                           restarts <- computeRestarts(cond)
[16:19:17.856]                           for (restart in restarts) {
[16:19:17.856]                             name <- restart$name
[16:19:17.856]                             if (is.null(name)) 
[16:19:17.856]                               next
[16:19:17.856]                             if (!grepl(pattern, name)) 
[16:19:17.856]                               next
[16:19:17.856]                             invokeRestart(restart)
[16:19:17.856]                             muffled <- TRUE
[16:19:17.856]                             break
[16:19:17.856]                           }
[16:19:17.856]                         }
[16:19:17.856]                       }
[16:19:17.856]                       invisible(muffled)
[16:19:17.856]                     }
[16:19:17.856]                     muffleCondition(cond, pattern = "^muffle")
[16:19:17.856]                   }
[16:19:17.856]                 }
[16:19:17.856]             }
[16:19:17.856]         }))
[16:19:17.856]     }, error = function(ex) {
[16:19:17.856]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:17.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:17.856]                 ...future.rng), started = ...future.startTime, 
[16:19:17.856]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:17.856]             version = "1.8"), class = "FutureResult")
[16:19:17.856]     }, finally = {
[16:19:17.856]         if (!identical(...future.workdir, getwd())) 
[16:19:17.856]             setwd(...future.workdir)
[16:19:17.856]         {
[16:19:17.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:17.856]                 ...future.oldOptions$nwarnings <- NULL
[16:19:17.856]             }
[16:19:17.856]             base::options(...future.oldOptions)
[16:19:17.856]             if (.Platform$OS.type == "windows") {
[16:19:17.856]                 old_names <- names(...future.oldEnvVars)
[16:19:17.856]                 envs <- base::Sys.getenv()
[16:19:17.856]                 names <- names(envs)
[16:19:17.856]                 common <- intersect(names, old_names)
[16:19:17.856]                 added <- setdiff(names, old_names)
[16:19:17.856]                 removed <- setdiff(old_names, names)
[16:19:17.856]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:17.856]                   envs[common]]
[16:19:17.856]                 NAMES <- toupper(changed)
[16:19:17.856]                 args <- list()
[16:19:17.856]                 for (kk in seq_along(NAMES)) {
[16:19:17.856]                   name <- changed[[kk]]
[16:19:17.856]                   NAME <- NAMES[[kk]]
[16:19:17.856]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.856]                     next
[16:19:17.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.856]                 }
[16:19:17.856]                 NAMES <- toupper(added)
[16:19:17.856]                 for (kk in seq_along(NAMES)) {
[16:19:17.856]                   name <- added[[kk]]
[16:19:17.856]                   NAME <- NAMES[[kk]]
[16:19:17.856]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.856]                     next
[16:19:17.856]                   args[[name]] <- ""
[16:19:17.856]                 }
[16:19:17.856]                 NAMES <- toupper(removed)
[16:19:17.856]                 for (kk in seq_along(NAMES)) {
[16:19:17.856]                   name <- removed[[kk]]
[16:19:17.856]                   NAME <- NAMES[[kk]]
[16:19:17.856]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:17.856]                     next
[16:19:17.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:17.856]                 }
[16:19:17.856]                 if (length(args) > 0) 
[16:19:17.856]                   base::do.call(base::Sys.setenv, args = args)
[16:19:17.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:17.856]             }
[16:19:17.856]             else {
[16:19:17.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:17.856]             }
[16:19:17.856]             {
[16:19:17.856]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:17.856]                   0L) {
[16:19:17.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:17.856]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:17.856]                   base::options(opts)
[16:19:17.856]                 }
[16:19:17.856]                 {
[16:19:17.856]                   {
[16:19:17.856]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:17.856]                     NULL
[16:19:17.856]                   }
[16:19:17.856]                   options(future.plan = NULL)
[16:19:17.856]                   if (is.na(NA_character_)) 
[16:19:17.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:17.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:17.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:17.856]                     .init = FALSE)
[16:19:17.856]                 }
[16:19:17.856]             }
[16:19:17.856]         }
[16:19:17.856]     })
[16:19:17.856]     if (TRUE) {
[16:19:17.856]         base::sink(type = "output", split = FALSE)
[16:19:17.856]         if (TRUE) {
[16:19:17.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:17.856]         }
[16:19:17.856]         else {
[16:19:17.856]             ...future.result["stdout"] <- base::list(NULL)
[16:19:17.856]         }
[16:19:17.856]         base::close(...future.stdout)
[16:19:17.856]         ...future.stdout <- NULL
[16:19:17.856]     }
[16:19:17.856]     ...future.result$conditions <- ...future.conditions
[16:19:17.856]     ...future.result$finished <- base::Sys.time()
[16:19:17.856]     ...future.result
[16:19:17.856] }
[16:19:17.859] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[16:19:17.859] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:17.901] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:17.901] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[16:19:17.901] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[16:19:17.901] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:17.902] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:17.902] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:17.945] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:17.945] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:17.988] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:17.989] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:17.989] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.989] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:17.990] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:17.990] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:17.990] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.991] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:17.991] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:17.991] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:17.991] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.992] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:17.992] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:17.992] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[16:19:17.993] MultisessionFuture started
[16:19:17.993] - Launch lazy future ... done
[16:19:17.993] run() for ‘MultisessionFuture’ ... done
[16:19:17.993] Created future:
[16:19:17.995] receiveMessageFromWorker() for ClusterFuture ...
[16:19:17.995] - Validating connection of MultisessionFuture
[16:19:17.995] - received message: FutureResult
[16:19:17.995] - Received FutureResult
[16:19:17.995] - Erased future from FutureRegistry
[16:19:17.995] result() for ClusterFuture ...
[16:19:17.996] - result already collected: FutureResult
[16:19:17.996] result() for ClusterFuture ... done
[16:19:17.996] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:17.993] MultisessionFuture:
[16:19:17.993] Label: ‘future_vapply-1’
[16:19:17.993] Expression:
[16:19:17.993] {
[16:19:17.993]     do.call(function(...) {
[16:19:17.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:17.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:17.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:17.993]             on.exit(options(oopts), add = TRUE)
[16:19:17.993]         }
[16:19:17.993]         {
[16:19:17.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:17.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:17.993]                 ...future.FUN(...future.X_jj, ...)
[16:19:17.993]             })
[16:19:17.993]         }
[16:19:17.993]     }, args = future.call.arguments)
[16:19:17.993] }
[16:19:17.993] Lazy evaluation: FALSE
[16:19:17.993] Asynchronous evaluation: TRUE
[16:19:17.993] Local evaluation: TRUE
[16:19:17.993] Environment: R_GlobalEnv
[16:19:17.993] Capture standard output: TRUE
[16:19:17.993] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:17.993] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:17.993] Packages: 1 packages (‘future.apply’)
[16:19:17.993] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:17.993] Resolved: TRUE
[16:19:17.993] Value: <not collected>
[16:19:17.993] Conditions captured: <none>
[16:19:17.993] Early signaling: FALSE
[16:19:17.993] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:17.993] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:17.996] Chunk #1 of 2 ... DONE
[16:19:17.996] Chunk #2 of 2 ...
[16:19:17.996]  - Finding globals in 'X' for chunk #2 ...
[16:19:17.996] getGlobalsAndPackages() ...
[16:19:17.996] Searching for globals...
[16:19:17.997] 
[16:19:17.997] Searching for globals ... DONE
[16:19:17.997] - globals: [0] <none>
[16:19:17.997] getGlobalsAndPackages() ... DONE
[16:19:17.997]    + additional globals found: [n=0] 
[16:19:17.997]    + additional namespaces needed: [n=0] 
[16:19:17.997]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:17.997]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:18.000]  - seeds: <none>
[16:19:18.000]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.000] getGlobalsAndPackages() ...
[16:19:18.000] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.001] Resolving globals: FALSE
[16:19:18.001] Tweak future expression to call with '...' arguments ...
[16:19:18.001] {
[16:19:18.001]     do.call(function(...) {
[16:19:18.001]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.001]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.001]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.001]             on.exit(options(oopts), add = TRUE)
[16:19:18.001]         }
[16:19:18.001]         {
[16:19:18.001]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.001]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.001]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.001]             })
[16:19:18.001]         }
[16:19:18.001]     }, args = future.call.arguments)
[16:19:18.001] }
[16:19:18.001] Tweak future expression to call with '...' arguments ... DONE
[16:19:18.002] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.002] - packages: [1] ‘future.apply’
[16:19:18.002] getGlobalsAndPackages() ... DONE
[16:19:18.002] run() for ‘Future’ ...
[16:19:18.002] - state: ‘created’
[16:19:18.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:18.017] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.017] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:18.017]   - Field: ‘node’
[16:19:18.017]   - Field: ‘label’
[16:19:18.017]   - Field: ‘local’
[16:19:18.017]   - Field: ‘owner’
[16:19:18.017]   - Field: ‘envir’
[16:19:18.018]   - Field: ‘workers’
[16:19:18.018]   - Field: ‘packages’
[16:19:18.018]   - Field: ‘gc’
[16:19:18.018]   - Field: ‘conditions’
[16:19:18.018]   - Field: ‘persistent’
[16:19:18.018]   - Field: ‘expr’
[16:19:18.018]   - Field: ‘uuid’
[16:19:18.018]   - Field: ‘seed’
[16:19:18.018]   - Field: ‘version’
[16:19:18.018]   - Field: ‘result’
[16:19:18.019]   - Field: ‘asynchronous’
[16:19:18.019]   - Field: ‘calls’
[16:19:18.019]   - Field: ‘globals’
[16:19:18.019]   - Field: ‘stdout’
[16:19:18.019]   - Field: ‘earlySignal’
[16:19:18.019]   - Field: ‘lazy’
[16:19:18.019]   - Field: ‘state’
[16:19:18.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:18.019] - Launch lazy future ...
[16:19:18.020] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:18.020] Packages needed by future strategies (n = 0): <none>
[16:19:18.020] {
[16:19:18.020]     {
[16:19:18.020]         {
[16:19:18.020]             ...future.startTime <- base::Sys.time()
[16:19:18.020]             {
[16:19:18.020]                 {
[16:19:18.020]                   {
[16:19:18.020]                     {
[16:19:18.020]                       {
[16:19:18.020]                         base::local({
[16:19:18.020]                           has_future <- base::requireNamespace("future", 
[16:19:18.020]                             quietly = TRUE)
[16:19:18.020]                           if (has_future) {
[16:19:18.020]                             ns <- base::getNamespace("future")
[16:19:18.020]                             version <- ns[[".package"]][["version"]]
[16:19:18.020]                             if (is.null(version)) 
[16:19:18.020]                               version <- utils::packageVersion("future")
[16:19:18.020]                           }
[16:19:18.020]                           else {
[16:19:18.020]                             version <- NULL
[16:19:18.020]                           }
[16:19:18.020]                           if (!has_future || version < "1.8.0") {
[16:19:18.020]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:18.020]                               "", base::R.version$version.string), 
[16:19:18.020]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:18.020]                                 base::R.version$platform, 8 * 
[16:19:18.020]                                   base::.Machine$sizeof.pointer), 
[16:19:18.020]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:18.020]                                 "release", "version")], collapse = " "), 
[16:19:18.020]                               hostname = base::Sys.info()[["nodename"]])
[16:19:18.020]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:18.020]                               info)
[16:19:18.020]                             info <- base::paste(info, collapse = "; ")
[16:19:18.020]                             if (!has_future) {
[16:19:18.020]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:18.020]                                 info)
[16:19:18.020]                             }
[16:19:18.020]                             else {
[16:19:18.020]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:18.020]                                 info, version)
[16:19:18.020]                             }
[16:19:18.020]                             base::stop(msg)
[16:19:18.020]                           }
[16:19:18.020]                         })
[16:19:18.020]                       }
[16:19:18.020]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:18.020]                       base::options(mc.cores = 1L)
[16:19:18.020]                     }
[16:19:18.020]                     base::local({
[16:19:18.020]                       for (pkg in "future.apply") {
[16:19:18.020]                         base::loadNamespace(pkg)
[16:19:18.020]                         base::library(pkg, character.only = TRUE)
[16:19:18.020]                       }
[16:19:18.020]                     })
[16:19:18.020]                   }
[16:19:18.020]                   ...future.strategy.old <- future::plan("list")
[16:19:18.020]                   options(future.plan = NULL)
[16:19:18.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:18.020]                 }
[16:19:18.020]                 ...future.workdir <- getwd()
[16:19:18.020]             }
[16:19:18.020]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:18.020]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:18.020]         }
[16:19:18.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:18.020]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:18.020]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:18.020]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:18.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:18.020]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:18.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:18.020]             base::names(...future.oldOptions))
[16:19:18.020]     }
[16:19:18.020]     if (FALSE) {
[16:19:18.020]     }
[16:19:18.020]     else {
[16:19:18.020]         if (TRUE) {
[16:19:18.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:18.020]                 open = "w")
[16:19:18.020]         }
[16:19:18.020]         else {
[16:19:18.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:18.020]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:18.020]         }
[16:19:18.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:18.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:18.020]             base::sink(type = "output", split = FALSE)
[16:19:18.020]             base::close(...future.stdout)
[16:19:18.020]         }, add = TRUE)
[16:19:18.020]     }
[16:19:18.020]     ...future.frame <- base::sys.nframe()
[16:19:18.020]     ...future.conditions <- base::list()
[16:19:18.020]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:18.020]     if (FALSE) {
[16:19:18.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:18.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:18.020]     }
[16:19:18.020]     ...future.result <- base::tryCatch({
[16:19:18.020]         base::withCallingHandlers({
[16:19:18.020]             ...future.value <- base::withVisible(base::local({
[16:19:18.020]                 ...future.makeSendCondition <- base::local({
[16:19:18.020]                   sendCondition <- NULL
[16:19:18.020]                   function(frame = 1L) {
[16:19:18.020]                     if (is.function(sendCondition)) 
[16:19:18.020]                       return(sendCondition)
[16:19:18.020]                     ns <- getNamespace("parallel")
[16:19:18.020]                     if (exists("sendData", mode = "function", 
[16:19:18.020]                       envir = ns)) {
[16:19:18.020]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:18.020]                         envir = ns)
[16:19:18.020]                       envir <- sys.frame(frame)
[16:19:18.020]                       master <- NULL
[16:19:18.020]                       while (!identical(envir, .GlobalEnv) && 
[16:19:18.020]                         !identical(envir, emptyenv())) {
[16:19:18.020]                         if (exists("master", mode = "list", envir = envir, 
[16:19:18.020]                           inherits = FALSE)) {
[16:19:18.020]                           master <- get("master", mode = "list", 
[16:19:18.020]                             envir = envir, inherits = FALSE)
[16:19:18.020]                           if (inherits(master, c("SOCKnode", 
[16:19:18.020]                             "SOCK0node"))) {
[16:19:18.020]                             sendCondition <<- function(cond) {
[16:19:18.020]                               data <- list(type = "VALUE", value = cond, 
[16:19:18.020]                                 success = TRUE)
[16:19:18.020]                               parallel_sendData(master, data)
[16:19:18.020]                             }
[16:19:18.020]                             return(sendCondition)
[16:19:18.020]                           }
[16:19:18.020]                         }
[16:19:18.020]                         frame <- frame + 1L
[16:19:18.020]                         envir <- sys.frame(frame)
[16:19:18.020]                       }
[16:19:18.020]                     }
[16:19:18.020]                     sendCondition <<- function(cond) NULL
[16:19:18.020]                   }
[16:19:18.020]                 })
[16:19:18.020]                 withCallingHandlers({
[16:19:18.020]                   {
[16:19:18.020]                     do.call(function(...) {
[16:19:18.020]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.020]                       if (!identical(...future.globals.maxSize.org, 
[16:19:18.020]                         ...future.globals.maxSize)) {
[16:19:18.020]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.020]                         on.exit(options(oopts), add = TRUE)
[16:19:18.020]                       }
[16:19:18.020]                       {
[16:19:18.020]                         lapply(seq_along(...future.elements_ii), 
[16:19:18.020]                           FUN = function(jj) {
[16:19:18.020]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.020]                             ...future.FUN(...future.X_jj, ...)
[16:19:18.020]                           })
[16:19:18.020]                       }
[16:19:18.020]                     }, args = future.call.arguments)
[16:19:18.020]                   }
[16:19:18.020]                 }, immediateCondition = function(cond) {
[16:19:18.020]                   sendCondition <- ...future.makeSendCondition()
[16:19:18.020]                   sendCondition(cond)
[16:19:18.020]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.020]                   {
[16:19:18.020]                     inherits <- base::inherits
[16:19:18.020]                     invokeRestart <- base::invokeRestart
[16:19:18.020]                     is.null <- base::is.null
[16:19:18.020]                     muffled <- FALSE
[16:19:18.020]                     if (inherits(cond, "message")) {
[16:19:18.020]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:18.020]                       if (muffled) 
[16:19:18.020]                         invokeRestart("muffleMessage")
[16:19:18.020]                     }
[16:19:18.020]                     else if (inherits(cond, "warning")) {
[16:19:18.020]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:18.020]                       if (muffled) 
[16:19:18.020]                         invokeRestart("muffleWarning")
[16:19:18.020]                     }
[16:19:18.020]                     else if (inherits(cond, "condition")) {
[16:19:18.020]                       if (!is.null(pattern)) {
[16:19:18.020]                         computeRestarts <- base::computeRestarts
[16:19:18.020]                         grepl <- base::grepl
[16:19:18.020]                         restarts <- computeRestarts(cond)
[16:19:18.020]                         for (restart in restarts) {
[16:19:18.020]                           name <- restart$name
[16:19:18.020]                           if (is.null(name)) 
[16:19:18.020]                             next
[16:19:18.020]                           if (!grepl(pattern, name)) 
[16:19:18.020]                             next
[16:19:18.020]                           invokeRestart(restart)
[16:19:18.020]                           muffled <- TRUE
[16:19:18.020]                           break
[16:19:18.020]                         }
[16:19:18.020]                       }
[16:19:18.020]                     }
[16:19:18.020]                     invisible(muffled)
[16:19:18.020]                   }
[16:19:18.020]                   muffleCondition(cond)
[16:19:18.020]                 })
[16:19:18.020]             }))
[16:19:18.020]             future::FutureResult(value = ...future.value$value, 
[16:19:18.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.020]                   ...future.rng), globalenv = if (FALSE) 
[16:19:18.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:18.020]                     ...future.globalenv.names))
[16:19:18.020]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:18.020]         }, condition = base::local({
[16:19:18.020]             c <- base::c
[16:19:18.020]             inherits <- base::inherits
[16:19:18.020]             invokeRestart <- base::invokeRestart
[16:19:18.020]             length <- base::length
[16:19:18.020]             list <- base::list
[16:19:18.020]             seq.int <- base::seq.int
[16:19:18.020]             signalCondition <- base::signalCondition
[16:19:18.020]             sys.calls <- base::sys.calls
[16:19:18.020]             `[[` <- base::`[[`
[16:19:18.020]             `+` <- base::`+`
[16:19:18.020]             `<<-` <- base::`<<-`
[16:19:18.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:18.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:18.020]                   3L)]
[16:19:18.020]             }
[16:19:18.020]             function(cond) {
[16:19:18.020]                 is_error <- inherits(cond, "error")
[16:19:18.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:18.020]                   NULL)
[16:19:18.020]                 if (is_error) {
[16:19:18.020]                   sessionInformation <- function() {
[16:19:18.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:18.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:18.020]                       search = base::search(), system = base::Sys.info())
[16:19:18.020]                   }
[16:19:18.020]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:18.020]                     cond$call), session = sessionInformation(), 
[16:19:18.020]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:18.020]                   signalCondition(cond)
[16:19:18.020]                 }
[16:19:18.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:18.020]                 "immediateCondition"))) {
[16:19:18.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:18.020]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:18.020]                   if (TRUE && !signal) {
[16:19:18.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.020]                     {
[16:19:18.020]                       inherits <- base::inherits
[16:19:18.020]                       invokeRestart <- base::invokeRestart
[16:19:18.020]                       is.null <- base::is.null
[16:19:18.020]                       muffled <- FALSE
[16:19:18.020]                       if (inherits(cond, "message")) {
[16:19:18.020]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.020]                         if (muffled) 
[16:19:18.020]                           invokeRestart("muffleMessage")
[16:19:18.020]                       }
[16:19:18.020]                       else if (inherits(cond, "warning")) {
[16:19:18.020]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.020]                         if (muffled) 
[16:19:18.020]                           invokeRestart("muffleWarning")
[16:19:18.020]                       }
[16:19:18.020]                       else if (inherits(cond, "condition")) {
[16:19:18.020]                         if (!is.null(pattern)) {
[16:19:18.020]                           computeRestarts <- base::computeRestarts
[16:19:18.020]                           grepl <- base::grepl
[16:19:18.020]                           restarts <- computeRestarts(cond)
[16:19:18.020]                           for (restart in restarts) {
[16:19:18.020]                             name <- restart$name
[16:19:18.020]                             if (is.null(name)) 
[16:19:18.020]                               next
[16:19:18.020]                             if (!grepl(pattern, name)) 
[16:19:18.020]                               next
[16:19:18.020]                             invokeRestart(restart)
[16:19:18.020]                             muffled <- TRUE
[16:19:18.020]                             break
[16:19:18.020]                           }
[16:19:18.020]                         }
[16:19:18.020]                       }
[16:19:18.020]                       invisible(muffled)
[16:19:18.020]                     }
[16:19:18.020]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.020]                   }
[16:19:18.020]                 }
[16:19:18.020]                 else {
[16:19:18.020]                   if (TRUE) {
[16:19:18.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.020]                     {
[16:19:18.020]                       inherits <- base::inherits
[16:19:18.020]                       invokeRestart <- base::invokeRestart
[16:19:18.020]                       is.null <- base::is.null
[16:19:18.020]                       muffled <- FALSE
[16:19:18.020]                       if (inherits(cond, "message")) {
[16:19:18.020]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.020]                         if (muffled) 
[16:19:18.020]                           invokeRestart("muffleMessage")
[16:19:18.020]                       }
[16:19:18.020]                       else if (inherits(cond, "warning")) {
[16:19:18.020]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.020]                         if (muffled) 
[16:19:18.020]                           invokeRestart("muffleWarning")
[16:19:18.020]                       }
[16:19:18.020]                       else if (inherits(cond, "condition")) {
[16:19:18.020]                         if (!is.null(pattern)) {
[16:19:18.020]                           computeRestarts <- base::computeRestarts
[16:19:18.020]                           grepl <- base::grepl
[16:19:18.020]                           restarts <- computeRestarts(cond)
[16:19:18.020]                           for (restart in restarts) {
[16:19:18.020]                             name <- restart$name
[16:19:18.020]                             if (is.null(name)) 
[16:19:18.020]                               next
[16:19:18.020]                             if (!grepl(pattern, name)) 
[16:19:18.020]                               next
[16:19:18.020]                             invokeRestart(restart)
[16:19:18.020]                             muffled <- TRUE
[16:19:18.020]                             break
[16:19:18.020]                           }
[16:19:18.020]                         }
[16:19:18.020]                       }
[16:19:18.020]                       invisible(muffled)
[16:19:18.020]                     }
[16:19:18.020]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.020]                   }
[16:19:18.020]                 }
[16:19:18.020]             }
[16:19:18.020]         }))
[16:19:18.020]     }, error = function(ex) {
[16:19:18.020]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:18.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.020]                 ...future.rng), started = ...future.startTime, 
[16:19:18.020]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:18.020]             version = "1.8"), class = "FutureResult")
[16:19:18.020]     }, finally = {
[16:19:18.020]         if (!identical(...future.workdir, getwd())) 
[16:19:18.020]             setwd(...future.workdir)
[16:19:18.020]         {
[16:19:18.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:18.020]                 ...future.oldOptions$nwarnings <- NULL
[16:19:18.020]             }
[16:19:18.020]             base::options(...future.oldOptions)
[16:19:18.020]             if (.Platform$OS.type == "windows") {
[16:19:18.020]                 old_names <- names(...future.oldEnvVars)
[16:19:18.020]                 envs <- base::Sys.getenv()
[16:19:18.020]                 names <- names(envs)
[16:19:18.020]                 common <- intersect(names, old_names)
[16:19:18.020]                 added <- setdiff(names, old_names)
[16:19:18.020]                 removed <- setdiff(old_names, names)
[16:19:18.020]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:18.020]                   envs[common]]
[16:19:18.020]                 NAMES <- toupper(changed)
[16:19:18.020]                 args <- list()
[16:19:18.020]                 for (kk in seq_along(NAMES)) {
[16:19:18.020]                   name <- changed[[kk]]
[16:19:18.020]                   NAME <- NAMES[[kk]]
[16:19:18.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.020]                     next
[16:19:18.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.020]                 }
[16:19:18.020]                 NAMES <- toupper(added)
[16:19:18.020]                 for (kk in seq_along(NAMES)) {
[16:19:18.020]                   name <- added[[kk]]
[16:19:18.020]                   NAME <- NAMES[[kk]]
[16:19:18.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.020]                     next
[16:19:18.020]                   args[[name]] <- ""
[16:19:18.020]                 }
[16:19:18.020]                 NAMES <- toupper(removed)
[16:19:18.020]                 for (kk in seq_along(NAMES)) {
[16:19:18.020]                   name <- removed[[kk]]
[16:19:18.020]                   NAME <- NAMES[[kk]]
[16:19:18.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.020]                     next
[16:19:18.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.020]                 }
[16:19:18.020]                 if (length(args) > 0) 
[16:19:18.020]                   base::do.call(base::Sys.setenv, args = args)
[16:19:18.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:18.020]             }
[16:19:18.020]             else {
[16:19:18.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:18.020]             }
[16:19:18.020]             {
[16:19:18.020]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:18.020]                   0L) {
[16:19:18.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:18.020]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:18.020]                   base::options(opts)
[16:19:18.020]                 }
[16:19:18.020]                 {
[16:19:18.020]                   {
[16:19:18.020]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:18.020]                     NULL
[16:19:18.020]                   }
[16:19:18.020]                   options(future.plan = NULL)
[16:19:18.020]                   if (is.na(NA_character_)) 
[16:19:18.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:18.020]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:18.020]                     .init = FALSE)
[16:19:18.020]                 }
[16:19:18.020]             }
[16:19:18.020]         }
[16:19:18.020]     })
[16:19:18.020]     if (TRUE) {
[16:19:18.020]         base::sink(type = "output", split = FALSE)
[16:19:18.020]         if (TRUE) {
[16:19:18.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:18.020]         }
[16:19:18.020]         else {
[16:19:18.020]             ...future.result["stdout"] <- base::list(NULL)
[16:19:18.020]         }
[16:19:18.020]         base::close(...future.stdout)
[16:19:18.020]         ...future.stdout <- NULL
[16:19:18.020]     }
[16:19:18.020]     ...future.result$conditions <- ...future.conditions
[16:19:18.020]     ...future.result$finished <- base::Sys.time()
[16:19:18.020]     ...future.result
[16:19:18.020] }
[16:19:18.023] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[16:19:18.023] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:18.064] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:18.065] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[16:19:18.065] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[16:19:18.065] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:18.066] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:18.066] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:18.108] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:18.109] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:18.152] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:18.153] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:18.153] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.153] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:18.154] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:18.154] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:18.154] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.155] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:18.155] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:18.155] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:18.155] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.156] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:18.156] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.156] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[16:19:18.157] MultisessionFuture started
[16:19:18.157] - Launch lazy future ... done
[16:19:18.157] run() for ‘MultisessionFuture’ ... done
[16:19:18.157] Created future:
[16:19:18.159] receiveMessageFromWorker() for ClusterFuture ...
[16:19:18.159] - Validating connection of MultisessionFuture
[16:19:18.159] - received message: FutureResult
[16:19:18.159] - Received FutureResult
[16:19:18.159] - Erased future from FutureRegistry
[16:19:18.159] result() for ClusterFuture ...
[16:19:18.159] - result already collected: FutureResult
[16:19:18.159] result() for ClusterFuture ... done
[16:19:18.160] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:18.157] MultisessionFuture:
[16:19:18.157] Label: ‘future_vapply-2’
[16:19:18.157] Expression:
[16:19:18.157] {
[16:19:18.157]     do.call(function(...) {
[16:19:18.157]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.157]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.157]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.157]             on.exit(options(oopts), add = TRUE)
[16:19:18.157]         }
[16:19:18.157]         {
[16:19:18.157]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.157]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.157]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.157]             })
[16:19:18.157]         }
[16:19:18.157]     }, args = future.call.arguments)
[16:19:18.157] }
[16:19:18.157] Lazy evaluation: FALSE
[16:19:18.157] Asynchronous evaluation: TRUE
[16:19:18.157] Local evaluation: TRUE
[16:19:18.157] Environment: R_GlobalEnv
[16:19:18.157] Capture standard output: TRUE
[16:19:18.157] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:18.157] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:18.157] Packages: 1 packages (‘future.apply’)
[16:19:18.157] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:18.157] Resolved: TRUE
[16:19:18.157] Value: <not collected>
[16:19:18.157] Conditions captured: <none>
[16:19:18.157] Early signaling: FALSE
[16:19:18.157] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:18.157] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.160] Chunk #2 of 2 ... DONE
[16:19:18.160] Launching 2 futures (chunks) ... DONE
[16:19:18.160] Resolving 2 futures (chunks) ...
[16:19:18.160] resolve() on list ...
[16:19:18.160]  recursive: 0
[16:19:18.160]  length: 2
[16:19:18.160] 
[16:19:18.161] Future #1
[16:19:18.161] result() for ClusterFuture ...
[16:19:18.161] - result already collected: FutureResult
[16:19:18.161] result() for ClusterFuture ... done
[16:19:18.161] result() for ClusterFuture ...
[16:19:18.161] - result already collected: FutureResult
[16:19:18.161] result() for ClusterFuture ... done
[16:19:18.161] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:18.161] - nx: 2
[16:19:18.161] - relay: TRUE
[16:19:18.161] - stdout: TRUE
[16:19:18.162] - signal: TRUE
[16:19:18.162] - resignal: FALSE
[16:19:18.162] - force: TRUE
[16:19:18.162] - relayed: [n=2] FALSE, FALSE
[16:19:18.162] - queued futures: [n=2] FALSE, FALSE
[16:19:18.162]  - until=1
[16:19:18.162]  - relaying element #1
[16:19:18.162] result() for ClusterFuture ...
[16:19:18.162] - result already collected: FutureResult
[16:19:18.162] result() for ClusterFuture ... done
[16:19:18.162] result() for ClusterFuture ...
[16:19:18.163] - result already collected: FutureResult
[16:19:18.163] result() for ClusterFuture ... done
[16:19:18.163] result() for ClusterFuture ...
[16:19:18.163] - result already collected: FutureResult
[16:19:18.163] result() for ClusterFuture ... done
[16:19:18.163] result() for ClusterFuture ...
[16:19:18.163] - result already collected: FutureResult
[16:19:18.163] result() for ClusterFuture ... done
[16:19:18.163] - relayed: [n=2] TRUE, FALSE
[16:19:18.163] - queued futures: [n=2] TRUE, FALSE
[16:19:18.163] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:18.164]  length: 1 (resolved future 1)
[16:19:18.164] Future #2
[16:19:18.164] result() for ClusterFuture ...
[16:19:18.164] - result already collected: FutureResult
[16:19:18.164] result() for ClusterFuture ... done
[16:19:18.164] result() for ClusterFuture ...
[16:19:18.164] - result already collected: FutureResult
[16:19:18.164] result() for ClusterFuture ... done
[16:19:18.164] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:18.165] - nx: 2
[16:19:18.165] - relay: TRUE
[16:19:18.165] - stdout: TRUE
[16:19:18.165] - signal: TRUE
[16:19:18.165] - resignal: FALSE
[16:19:18.165] - force: TRUE
[16:19:18.165] - relayed: [n=2] TRUE, FALSE
[16:19:18.165] - queued futures: [n=2] TRUE, FALSE
[16:19:18.165]  - until=2
[16:19:18.165]  - relaying element #2
[16:19:18.165] result() for ClusterFuture ...
[16:19:18.165] - result already collected: FutureResult
[16:19:18.166] result() for ClusterFuture ... done
[16:19:18.166] result() for ClusterFuture ...
[16:19:18.166] - result already collected: FutureResult
[16:19:18.166] result() for ClusterFuture ... done
[16:19:18.166] result() for ClusterFuture ...
[16:19:18.166] - result already collected: FutureResult
[16:19:18.166] result() for ClusterFuture ... done
[16:19:18.166] result() for ClusterFuture ...
[16:19:18.166] - result already collected: FutureResult
[16:19:18.166] result() for ClusterFuture ... done
[16:19:18.166] - relayed: [n=2] TRUE, TRUE
[16:19:18.167] - queued futures: [n=2] TRUE, TRUE
[16:19:18.167] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:18.167]  length: 0 (resolved future 2)
[16:19:18.167] Relaying remaining futures
[16:19:18.167] signalConditionsASAP(NULL, pos=0) ...
[16:19:18.167] - nx: 2
[16:19:18.167] - relay: TRUE
[16:19:18.167] - stdout: TRUE
[16:19:18.167] - signal: TRUE
[16:19:18.167] - resignal: FALSE
[16:19:18.167] - force: TRUE
[16:19:18.167] - relayed: [n=2] TRUE, TRUE
[16:19:18.168] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:18.168] - relayed: [n=2] TRUE, TRUE
[16:19:18.168] - queued futures: [n=2] TRUE, TRUE
[16:19:18.168] signalConditionsASAP(NULL, pos=0) ... done
[16:19:18.168] resolve() on list ... DONE
[16:19:18.168] result() for ClusterFuture ...
[16:19:18.168] - result already collected: FutureResult
[16:19:18.168] result() for ClusterFuture ... done
[16:19:18.168] result() for ClusterFuture ...
[16:19:18.168] - result already collected: FutureResult
[16:19:18.169] result() for ClusterFuture ... done
[16:19:18.169] result() for ClusterFuture ...
[16:19:18.169] - result already collected: FutureResult
[16:19:18.169] result() for ClusterFuture ... done
[16:19:18.169] result() for ClusterFuture ...
[16:19:18.169] - result already collected: FutureResult
[16:19:18.169] result() for ClusterFuture ... done
[16:19:18.169]  - Number of value chunks collected: 2
[16:19:18.169] Resolving 2 futures (chunks) ... DONE
[16:19:18.169] Reducing values from 2 chunks ...
[16:19:18.169]  - Number of values collected after concatenation: 10
[16:19:18.170]  - Number of values expected: 10
[16:19:18.170] Reducing values from 2 chunks ... DONE
[16:19:18.170] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:19:18.171] future_lapply() ...
[16:19:18.176] Number of chunks: 2
[16:19:18.177] getGlobalsAndPackagesXApply() ...
[16:19:18.177]  - future.globals: TRUE
[16:19:18.177] getGlobalsAndPackages() ...
[16:19:18.177] Searching for globals...
[16:19:18.180] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:19:18.180] Searching for globals ... DONE
[16:19:18.181] Resolving globals: FALSE
[16:19:18.181] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:19:18.182] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:18.182] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:18.182] - packages: [1] ‘future.apply’
[16:19:18.182] getGlobalsAndPackages() ... DONE
[16:19:18.182]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:18.182]  - needed namespaces: [n=1] ‘future.apply’
[16:19:18.182] Finding globals ... DONE
[16:19:18.183]  - use_args: TRUE
[16:19:18.183]  - Getting '...' globals ...
[16:19:18.183] resolve() on list ...
[16:19:18.183]  recursive: 0
[16:19:18.183]  length: 1
[16:19:18.183]  elements: ‘...’
[16:19:18.183]  length: 0 (resolved future 1)
[16:19:18.183] resolve() on list ... DONE
[16:19:18.183]    - '...' content: [n=0] 
[16:19:18.184] List of 1
[16:19:18.184]  $ ...: list()
[16:19:18.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:18.184]  - attr(*, "where")=List of 1
[16:19:18.184]   ..$ ...:<environment: 0x5619a002dbb8> 
[16:19:18.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:18.184]  - attr(*, "resolved")= logi TRUE
[16:19:18.184]  - attr(*, "total_size")= num NA
[16:19:18.186]  - Getting '...' globals ... DONE
[16:19:18.186] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:18.186] List of 8
[16:19:18.186]  $ ...future.FUN:function (x, ...)  
[16:19:18.186]  $ x_FUN        :function (x)  
[16:19:18.186]  $ times        : int 4
[16:19:18.186]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:18.186]  $ stop_if_not  :function (...)  
[16:19:18.186]  $ dim          : int [1:2] 2 2
[16:19:18.186]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:18.186]  $ ...          : list()
[16:19:18.186]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:18.186]  - attr(*, "where")=List of 8
[16:19:18.186]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:18.186]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:18.186]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:18.186]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:18.186]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:18.186]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:18.186]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:18.186]   ..$ ...          :<environment: 0x5619a002dbb8> 
[16:19:18.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:18.186]  - attr(*, "resolved")= logi FALSE
[16:19:18.186]  - attr(*, "total_size")= num 97232
[16:19:18.192] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:18.192] getGlobalsAndPackagesXApply() ... DONE
[16:19:18.192] Number of futures (= number of chunks): 2
[16:19:18.192] Launching 2 futures (chunks) ...
[16:19:18.192] Chunk #1 of 2 ...
[16:19:18.192]  - Finding globals in 'X' for chunk #1 ...
[16:19:18.192] getGlobalsAndPackages() ...
[16:19:18.193] Searching for globals...
[16:19:18.193] 
[16:19:18.193] Searching for globals ... DONE
[16:19:18.193] - globals: [0] <none>
[16:19:18.193] getGlobalsAndPackages() ... DONE
[16:19:18.193]    + additional globals found: [n=0] 
[16:19:18.193]    + additional namespaces needed: [n=0] 
[16:19:18.193]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:18.193]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:18.194]  - seeds: <none>
[16:19:18.194]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.194] getGlobalsAndPackages() ...
[16:19:18.194] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.194] Resolving globals: FALSE
[16:19:18.194] Tweak future expression to call with '...' arguments ...
[16:19:18.194] {
[16:19:18.194]     do.call(function(...) {
[16:19:18.194]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.194]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.194]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.194]             on.exit(options(oopts), add = TRUE)
[16:19:18.194]         }
[16:19:18.194]         {
[16:19:18.194]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.194]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.194]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.194]             })
[16:19:18.194]         }
[16:19:18.194]     }, args = future.call.arguments)
[16:19:18.194] }
[16:19:18.194] Tweak future expression to call with '...' arguments ... DONE
[16:19:18.195] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.195] - packages: [1] ‘future.apply’
[16:19:18.195] getGlobalsAndPackages() ... DONE
[16:19:18.195] run() for ‘Future’ ...
[16:19:18.196] - state: ‘created’
[16:19:18.196] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:18.210] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:18.210]   - Field: ‘node’
[16:19:18.210]   - Field: ‘label’
[16:19:18.210]   - Field: ‘local’
[16:19:18.210]   - Field: ‘owner’
[16:19:18.210]   - Field: ‘envir’
[16:19:18.210]   - Field: ‘workers’
[16:19:18.210]   - Field: ‘packages’
[16:19:18.211]   - Field: ‘gc’
[16:19:18.211]   - Field: ‘conditions’
[16:19:18.211]   - Field: ‘persistent’
[16:19:18.211]   - Field: ‘expr’
[16:19:18.211]   - Field: ‘uuid’
[16:19:18.211]   - Field: ‘seed’
[16:19:18.211]   - Field: ‘version’
[16:19:18.211]   - Field: ‘result’
[16:19:18.211]   - Field: ‘asynchronous’
[16:19:18.211]   - Field: ‘calls’
[16:19:18.211]   - Field: ‘globals’
[16:19:18.212]   - Field: ‘stdout’
[16:19:18.212]   - Field: ‘earlySignal’
[16:19:18.212]   - Field: ‘lazy’
[16:19:18.212]   - Field: ‘state’
[16:19:18.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:18.212] - Launch lazy future ...
[16:19:18.212] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:18.212] Packages needed by future strategies (n = 0): <none>
[16:19:18.213] {
[16:19:18.213]     {
[16:19:18.213]         {
[16:19:18.213]             ...future.startTime <- base::Sys.time()
[16:19:18.213]             {
[16:19:18.213]                 {
[16:19:18.213]                   {
[16:19:18.213]                     {
[16:19:18.213]                       {
[16:19:18.213]                         base::local({
[16:19:18.213]                           has_future <- base::requireNamespace("future", 
[16:19:18.213]                             quietly = TRUE)
[16:19:18.213]                           if (has_future) {
[16:19:18.213]                             ns <- base::getNamespace("future")
[16:19:18.213]                             version <- ns[[".package"]][["version"]]
[16:19:18.213]                             if (is.null(version)) 
[16:19:18.213]                               version <- utils::packageVersion("future")
[16:19:18.213]                           }
[16:19:18.213]                           else {
[16:19:18.213]                             version <- NULL
[16:19:18.213]                           }
[16:19:18.213]                           if (!has_future || version < "1.8.0") {
[16:19:18.213]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:18.213]                               "", base::R.version$version.string), 
[16:19:18.213]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:18.213]                                 base::R.version$platform, 8 * 
[16:19:18.213]                                   base::.Machine$sizeof.pointer), 
[16:19:18.213]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:18.213]                                 "release", "version")], collapse = " "), 
[16:19:18.213]                               hostname = base::Sys.info()[["nodename"]])
[16:19:18.213]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:18.213]                               info)
[16:19:18.213]                             info <- base::paste(info, collapse = "; ")
[16:19:18.213]                             if (!has_future) {
[16:19:18.213]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:18.213]                                 info)
[16:19:18.213]                             }
[16:19:18.213]                             else {
[16:19:18.213]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:18.213]                                 info, version)
[16:19:18.213]                             }
[16:19:18.213]                             base::stop(msg)
[16:19:18.213]                           }
[16:19:18.213]                         })
[16:19:18.213]                       }
[16:19:18.213]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:18.213]                       base::options(mc.cores = 1L)
[16:19:18.213]                     }
[16:19:18.213]                     base::local({
[16:19:18.213]                       for (pkg in "future.apply") {
[16:19:18.213]                         base::loadNamespace(pkg)
[16:19:18.213]                         base::library(pkg, character.only = TRUE)
[16:19:18.213]                       }
[16:19:18.213]                     })
[16:19:18.213]                   }
[16:19:18.213]                   ...future.strategy.old <- future::plan("list")
[16:19:18.213]                   options(future.plan = NULL)
[16:19:18.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:18.213]                 }
[16:19:18.213]                 ...future.workdir <- getwd()
[16:19:18.213]             }
[16:19:18.213]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:18.213]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:18.213]         }
[16:19:18.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:18.213]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:18.213]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:18.213]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:18.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:18.213]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:18.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:18.213]             base::names(...future.oldOptions))
[16:19:18.213]     }
[16:19:18.213]     if (FALSE) {
[16:19:18.213]     }
[16:19:18.213]     else {
[16:19:18.213]         if (TRUE) {
[16:19:18.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:18.213]                 open = "w")
[16:19:18.213]         }
[16:19:18.213]         else {
[16:19:18.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:18.213]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:18.213]         }
[16:19:18.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:18.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:18.213]             base::sink(type = "output", split = FALSE)
[16:19:18.213]             base::close(...future.stdout)
[16:19:18.213]         }, add = TRUE)
[16:19:18.213]     }
[16:19:18.213]     ...future.frame <- base::sys.nframe()
[16:19:18.213]     ...future.conditions <- base::list()
[16:19:18.213]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:18.213]     if (FALSE) {
[16:19:18.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:18.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:18.213]     }
[16:19:18.213]     ...future.result <- base::tryCatch({
[16:19:18.213]         base::withCallingHandlers({
[16:19:18.213]             ...future.value <- base::withVisible(base::local({
[16:19:18.213]                 ...future.makeSendCondition <- base::local({
[16:19:18.213]                   sendCondition <- NULL
[16:19:18.213]                   function(frame = 1L) {
[16:19:18.213]                     if (is.function(sendCondition)) 
[16:19:18.213]                       return(sendCondition)
[16:19:18.213]                     ns <- getNamespace("parallel")
[16:19:18.213]                     if (exists("sendData", mode = "function", 
[16:19:18.213]                       envir = ns)) {
[16:19:18.213]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:18.213]                         envir = ns)
[16:19:18.213]                       envir <- sys.frame(frame)
[16:19:18.213]                       master <- NULL
[16:19:18.213]                       while (!identical(envir, .GlobalEnv) && 
[16:19:18.213]                         !identical(envir, emptyenv())) {
[16:19:18.213]                         if (exists("master", mode = "list", envir = envir, 
[16:19:18.213]                           inherits = FALSE)) {
[16:19:18.213]                           master <- get("master", mode = "list", 
[16:19:18.213]                             envir = envir, inherits = FALSE)
[16:19:18.213]                           if (inherits(master, c("SOCKnode", 
[16:19:18.213]                             "SOCK0node"))) {
[16:19:18.213]                             sendCondition <<- function(cond) {
[16:19:18.213]                               data <- list(type = "VALUE", value = cond, 
[16:19:18.213]                                 success = TRUE)
[16:19:18.213]                               parallel_sendData(master, data)
[16:19:18.213]                             }
[16:19:18.213]                             return(sendCondition)
[16:19:18.213]                           }
[16:19:18.213]                         }
[16:19:18.213]                         frame <- frame + 1L
[16:19:18.213]                         envir <- sys.frame(frame)
[16:19:18.213]                       }
[16:19:18.213]                     }
[16:19:18.213]                     sendCondition <<- function(cond) NULL
[16:19:18.213]                   }
[16:19:18.213]                 })
[16:19:18.213]                 withCallingHandlers({
[16:19:18.213]                   {
[16:19:18.213]                     do.call(function(...) {
[16:19:18.213]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.213]                       if (!identical(...future.globals.maxSize.org, 
[16:19:18.213]                         ...future.globals.maxSize)) {
[16:19:18.213]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.213]                         on.exit(options(oopts), add = TRUE)
[16:19:18.213]                       }
[16:19:18.213]                       {
[16:19:18.213]                         lapply(seq_along(...future.elements_ii), 
[16:19:18.213]                           FUN = function(jj) {
[16:19:18.213]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.213]                             ...future.FUN(...future.X_jj, ...)
[16:19:18.213]                           })
[16:19:18.213]                       }
[16:19:18.213]                     }, args = future.call.arguments)
[16:19:18.213]                   }
[16:19:18.213]                 }, immediateCondition = function(cond) {
[16:19:18.213]                   sendCondition <- ...future.makeSendCondition()
[16:19:18.213]                   sendCondition(cond)
[16:19:18.213]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.213]                   {
[16:19:18.213]                     inherits <- base::inherits
[16:19:18.213]                     invokeRestart <- base::invokeRestart
[16:19:18.213]                     is.null <- base::is.null
[16:19:18.213]                     muffled <- FALSE
[16:19:18.213]                     if (inherits(cond, "message")) {
[16:19:18.213]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:18.213]                       if (muffled) 
[16:19:18.213]                         invokeRestart("muffleMessage")
[16:19:18.213]                     }
[16:19:18.213]                     else if (inherits(cond, "warning")) {
[16:19:18.213]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:18.213]                       if (muffled) 
[16:19:18.213]                         invokeRestart("muffleWarning")
[16:19:18.213]                     }
[16:19:18.213]                     else if (inherits(cond, "condition")) {
[16:19:18.213]                       if (!is.null(pattern)) {
[16:19:18.213]                         computeRestarts <- base::computeRestarts
[16:19:18.213]                         grepl <- base::grepl
[16:19:18.213]                         restarts <- computeRestarts(cond)
[16:19:18.213]                         for (restart in restarts) {
[16:19:18.213]                           name <- restart$name
[16:19:18.213]                           if (is.null(name)) 
[16:19:18.213]                             next
[16:19:18.213]                           if (!grepl(pattern, name)) 
[16:19:18.213]                             next
[16:19:18.213]                           invokeRestart(restart)
[16:19:18.213]                           muffled <- TRUE
[16:19:18.213]                           break
[16:19:18.213]                         }
[16:19:18.213]                       }
[16:19:18.213]                     }
[16:19:18.213]                     invisible(muffled)
[16:19:18.213]                   }
[16:19:18.213]                   muffleCondition(cond)
[16:19:18.213]                 })
[16:19:18.213]             }))
[16:19:18.213]             future::FutureResult(value = ...future.value$value, 
[16:19:18.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.213]                   ...future.rng), globalenv = if (FALSE) 
[16:19:18.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:18.213]                     ...future.globalenv.names))
[16:19:18.213]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:18.213]         }, condition = base::local({
[16:19:18.213]             c <- base::c
[16:19:18.213]             inherits <- base::inherits
[16:19:18.213]             invokeRestart <- base::invokeRestart
[16:19:18.213]             length <- base::length
[16:19:18.213]             list <- base::list
[16:19:18.213]             seq.int <- base::seq.int
[16:19:18.213]             signalCondition <- base::signalCondition
[16:19:18.213]             sys.calls <- base::sys.calls
[16:19:18.213]             `[[` <- base::`[[`
[16:19:18.213]             `+` <- base::`+`
[16:19:18.213]             `<<-` <- base::`<<-`
[16:19:18.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:18.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:18.213]                   3L)]
[16:19:18.213]             }
[16:19:18.213]             function(cond) {
[16:19:18.213]                 is_error <- inherits(cond, "error")
[16:19:18.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:18.213]                   NULL)
[16:19:18.213]                 if (is_error) {
[16:19:18.213]                   sessionInformation <- function() {
[16:19:18.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:18.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:18.213]                       search = base::search(), system = base::Sys.info())
[16:19:18.213]                   }
[16:19:18.213]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:18.213]                     cond$call), session = sessionInformation(), 
[16:19:18.213]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:18.213]                   signalCondition(cond)
[16:19:18.213]                 }
[16:19:18.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:18.213]                 "immediateCondition"))) {
[16:19:18.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:18.213]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:18.213]                   if (TRUE && !signal) {
[16:19:18.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.213]                     {
[16:19:18.213]                       inherits <- base::inherits
[16:19:18.213]                       invokeRestart <- base::invokeRestart
[16:19:18.213]                       is.null <- base::is.null
[16:19:18.213]                       muffled <- FALSE
[16:19:18.213]                       if (inherits(cond, "message")) {
[16:19:18.213]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.213]                         if (muffled) 
[16:19:18.213]                           invokeRestart("muffleMessage")
[16:19:18.213]                       }
[16:19:18.213]                       else if (inherits(cond, "warning")) {
[16:19:18.213]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.213]                         if (muffled) 
[16:19:18.213]                           invokeRestart("muffleWarning")
[16:19:18.213]                       }
[16:19:18.213]                       else if (inherits(cond, "condition")) {
[16:19:18.213]                         if (!is.null(pattern)) {
[16:19:18.213]                           computeRestarts <- base::computeRestarts
[16:19:18.213]                           grepl <- base::grepl
[16:19:18.213]                           restarts <- computeRestarts(cond)
[16:19:18.213]                           for (restart in restarts) {
[16:19:18.213]                             name <- restart$name
[16:19:18.213]                             if (is.null(name)) 
[16:19:18.213]                               next
[16:19:18.213]                             if (!grepl(pattern, name)) 
[16:19:18.213]                               next
[16:19:18.213]                             invokeRestart(restart)
[16:19:18.213]                             muffled <- TRUE
[16:19:18.213]                             break
[16:19:18.213]                           }
[16:19:18.213]                         }
[16:19:18.213]                       }
[16:19:18.213]                       invisible(muffled)
[16:19:18.213]                     }
[16:19:18.213]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.213]                   }
[16:19:18.213]                 }
[16:19:18.213]                 else {
[16:19:18.213]                   if (TRUE) {
[16:19:18.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.213]                     {
[16:19:18.213]                       inherits <- base::inherits
[16:19:18.213]                       invokeRestart <- base::invokeRestart
[16:19:18.213]                       is.null <- base::is.null
[16:19:18.213]                       muffled <- FALSE
[16:19:18.213]                       if (inherits(cond, "message")) {
[16:19:18.213]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.213]                         if (muffled) 
[16:19:18.213]                           invokeRestart("muffleMessage")
[16:19:18.213]                       }
[16:19:18.213]                       else if (inherits(cond, "warning")) {
[16:19:18.213]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.213]                         if (muffled) 
[16:19:18.213]                           invokeRestart("muffleWarning")
[16:19:18.213]                       }
[16:19:18.213]                       else if (inherits(cond, "condition")) {
[16:19:18.213]                         if (!is.null(pattern)) {
[16:19:18.213]                           computeRestarts <- base::computeRestarts
[16:19:18.213]                           grepl <- base::grepl
[16:19:18.213]                           restarts <- computeRestarts(cond)
[16:19:18.213]                           for (restart in restarts) {
[16:19:18.213]                             name <- restart$name
[16:19:18.213]                             if (is.null(name)) 
[16:19:18.213]                               next
[16:19:18.213]                             if (!grepl(pattern, name)) 
[16:19:18.213]                               next
[16:19:18.213]                             invokeRestart(restart)
[16:19:18.213]                             muffled <- TRUE
[16:19:18.213]                             break
[16:19:18.213]                           }
[16:19:18.213]                         }
[16:19:18.213]                       }
[16:19:18.213]                       invisible(muffled)
[16:19:18.213]                     }
[16:19:18.213]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.213]                   }
[16:19:18.213]                 }
[16:19:18.213]             }
[16:19:18.213]         }))
[16:19:18.213]     }, error = function(ex) {
[16:19:18.213]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:18.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.213]                 ...future.rng), started = ...future.startTime, 
[16:19:18.213]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:18.213]             version = "1.8"), class = "FutureResult")
[16:19:18.213]     }, finally = {
[16:19:18.213]         if (!identical(...future.workdir, getwd())) 
[16:19:18.213]             setwd(...future.workdir)
[16:19:18.213]         {
[16:19:18.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:18.213]                 ...future.oldOptions$nwarnings <- NULL
[16:19:18.213]             }
[16:19:18.213]             base::options(...future.oldOptions)
[16:19:18.213]             if (.Platform$OS.type == "windows") {
[16:19:18.213]                 old_names <- names(...future.oldEnvVars)
[16:19:18.213]                 envs <- base::Sys.getenv()
[16:19:18.213]                 names <- names(envs)
[16:19:18.213]                 common <- intersect(names, old_names)
[16:19:18.213]                 added <- setdiff(names, old_names)
[16:19:18.213]                 removed <- setdiff(old_names, names)
[16:19:18.213]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:18.213]                   envs[common]]
[16:19:18.213]                 NAMES <- toupper(changed)
[16:19:18.213]                 args <- list()
[16:19:18.213]                 for (kk in seq_along(NAMES)) {
[16:19:18.213]                   name <- changed[[kk]]
[16:19:18.213]                   NAME <- NAMES[[kk]]
[16:19:18.213]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.213]                     next
[16:19:18.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.213]                 }
[16:19:18.213]                 NAMES <- toupper(added)
[16:19:18.213]                 for (kk in seq_along(NAMES)) {
[16:19:18.213]                   name <- added[[kk]]
[16:19:18.213]                   NAME <- NAMES[[kk]]
[16:19:18.213]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.213]                     next
[16:19:18.213]                   args[[name]] <- ""
[16:19:18.213]                 }
[16:19:18.213]                 NAMES <- toupper(removed)
[16:19:18.213]                 for (kk in seq_along(NAMES)) {
[16:19:18.213]                   name <- removed[[kk]]
[16:19:18.213]                   NAME <- NAMES[[kk]]
[16:19:18.213]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.213]                     next
[16:19:18.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.213]                 }
[16:19:18.213]                 if (length(args) > 0) 
[16:19:18.213]                   base::do.call(base::Sys.setenv, args = args)
[16:19:18.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:18.213]             }
[16:19:18.213]             else {
[16:19:18.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:18.213]             }
[16:19:18.213]             {
[16:19:18.213]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:18.213]                   0L) {
[16:19:18.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:18.213]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:18.213]                   base::options(opts)
[16:19:18.213]                 }
[16:19:18.213]                 {
[16:19:18.213]                   {
[16:19:18.213]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:18.213]                     NULL
[16:19:18.213]                   }
[16:19:18.213]                   options(future.plan = NULL)
[16:19:18.213]                   if (is.na(NA_character_)) 
[16:19:18.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:18.213]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:18.213]                     .init = FALSE)
[16:19:18.213]                 }
[16:19:18.213]             }
[16:19:18.213]         }
[16:19:18.213]     })
[16:19:18.213]     if (TRUE) {
[16:19:18.213]         base::sink(type = "output", split = FALSE)
[16:19:18.213]         if (TRUE) {
[16:19:18.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:18.213]         }
[16:19:18.213]         else {
[16:19:18.213]             ...future.result["stdout"] <- base::list(NULL)
[16:19:18.213]         }
[16:19:18.213]         base::close(...future.stdout)
[16:19:18.213]         ...future.stdout <- NULL
[16:19:18.213]     }
[16:19:18.213]     ...future.result$conditions <- ...future.conditions
[16:19:18.213]     ...future.result$finished <- base::Sys.time()
[16:19:18.213]     ...future.result
[16:19:18.213] }
[16:19:18.216] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[16:19:18.216] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:18.257] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:18.257] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[16:19:18.257] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[16:19:18.257] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:18.258] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:18.258] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:18.300] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:18.301] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:18.344] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:18.345] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:19:18.345] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:19:18.345] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:19:18.346] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:19:18.346] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:18.346] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.347] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:18.347] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:18.347] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:18.347] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.348] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:18.348] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.348] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[16:19:18.349] MultisessionFuture started
[16:19:18.349] - Launch lazy future ... done
[16:19:18.349] run() for ‘MultisessionFuture’ ... done
[16:19:18.349] Created future:
[16:19:18.349] MultisessionFuture:
[16:19:18.349] Label: ‘future_vapply-1’
[16:19:18.349] Expression:
[16:19:18.349] {
[16:19:18.349]     do.call(function(...) {
[16:19:18.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.349]             on.exit(options(oopts), add = TRUE)
[16:19:18.349]         }
[16:19:18.349]         {
[16:19:18.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.349]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.349]             })
[16:19:18.349]         }
[16:19:18.349]     }, args = future.call.arguments)
[16:19:18.349] }
[16:19:18.349] Lazy evaluation: FALSE
[16:19:18.349] Asynchronous evaluation: TRUE
[16:19:18.349] Local evaluation: TRUE
[16:19:18.349] Environment: R_GlobalEnv
[16:19:18.349] Capture standard output: TRUE
[16:19:18.349] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:18.349] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:18.349] Packages: 1 packages (‘future.apply’)
[16:19:18.349] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:18.349] Resolved: FALSE
[16:19:18.349] Value: <not collected>
[16:19:18.349] Conditions captured: <none>
[16:19:18.349] Early signaling: FALSE
[16:19:18.349] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:18.349] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.361] Chunk #1 of 2 ... DONE
[16:19:18.361] Chunk #2 of 2 ...
[16:19:18.361]  - Finding globals in 'X' for chunk #2 ...
[16:19:18.362] getGlobalsAndPackages() ...
[16:19:18.362] Searching for globals...
[16:19:18.362] 
[16:19:18.362] Searching for globals ... DONE
[16:19:18.362] - globals: [0] <none>
[16:19:18.362] getGlobalsAndPackages() ... DONE
[16:19:18.362]    + additional globals found: [n=0] 
[16:19:18.362]    + additional namespaces needed: [n=0] 
[16:19:18.362]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:18.363]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:18.363]  - seeds: <none>
[16:19:18.363]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.363] getGlobalsAndPackages() ...
[16:19:18.363] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.363] Resolving globals: FALSE
[16:19:18.363] Tweak future expression to call with '...' arguments ...
[16:19:18.363] {
[16:19:18.363]     do.call(function(...) {
[16:19:18.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.363]             on.exit(options(oopts), add = TRUE)
[16:19:18.363]         }
[16:19:18.363]         {
[16:19:18.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.363]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.363]             })
[16:19:18.363]         }
[16:19:18.363]     }, args = future.call.arguments)
[16:19:18.363] }
[16:19:18.364] Tweak future expression to call with '...' arguments ... DONE
[16:19:18.364] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.364] - packages: [1] ‘future.apply’
[16:19:18.364] getGlobalsAndPackages() ... DONE
[16:19:18.365] run() for ‘Future’ ...
[16:19:18.365] - state: ‘created’
[16:19:18.365] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:18.379] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:18.379]   - Field: ‘node’
[16:19:18.379]   - Field: ‘label’
[16:19:18.379]   - Field: ‘local’
[16:19:18.379]   - Field: ‘owner’
[16:19:18.379]   - Field: ‘envir’
[16:19:18.380]   - Field: ‘workers’
[16:19:18.380]   - Field: ‘packages’
[16:19:18.380]   - Field: ‘gc’
[16:19:18.380]   - Field: ‘conditions’
[16:19:18.380]   - Field: ‘persistent’
[16:19:18.380]   - Field: ‘expr’
[16:19:18.380]   - Field: ‘uuid’
[16:19:18.380]   - Field: ‘seed’
[16:19:18.380]   - Field: ‘version’
[16:19:18.380]   - Field: ‘result’
[16:19:18.381]   - Field: ‘asynchronous’
[16:19:18.381]   - Field: ‘calls’
[16:19:18.381]   - Field: ‘globals’
[16:19:18.381]   - Field: ‘stdout’
[16:19:18.381]   - Field: ‘earlySignal’
[16:19:18.381]   - Field: ‘lazy’
[16:19:18.381]   - Field: ‘state’
[16:19:18.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:18.381] - Launch lazy future ...
[16:19:18.382] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:18.382] Packages needed by future strategies (n = 0): <none>
[16:19:18.382] {
[16:19:18.382]     {
[16:19:18.382]         {
[16:19:18.382]             ...future.startTime <- base::Sys.time()
[16:19:18.382]             {
[16:19:18.382]                 {
[16:19:18.382]                   {
[16:19:18.382]                     {
[16:19:18.382]                       {
[16:19:18.382]                         base::local({
[16:19:18.382]                           has_future <- base::requireNamespace("future", 
[16:19:18.382]                             quietly = TRUE)
[16:19:18.382]                           if (has_future) {
[16:19:18.382]                             ns <- base::getNamespace("future")
[16:19:18.382]                             version <- ns[[".package"]][["version"]]
[16:19:18.382]                             if (is.null(version)) 
[16:19:18.382]                               version <- utils::packageVersion("future")
[16:19:18.382]                           }
[16:19:18.382]                           else {
[16:19:18.382]                             version <- NULL
[16:19:18.382]                           }
[16:19:18.382]                           if (!has_future || version < "1.8.0") {
[16:19:18.382]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:18.382]                               "", base::R.version$version.string), 
[16:19:18.382]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:18.382]                                 base::R.version$platform, 8 * 
[16:19:18.382]                                   base::.Machine$sizeof.pointer), 
[16:19:18.382]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:18.382]                                 "release", "version")], collapse = " "), 
[16:19:18.382]                               hostname = base::Sys.info()[["nodename"]])
[16:19:18.382]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:18.382]                               info)
[16:19:18.382]                             info <- base::paste(info, collapse = "; ")
[16:19:18.382]                             if (!has_future) {
[16:19:18.382]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:18.382]                                 info)
[16:19:18.382]                             }
[16:19:18.382]                             else {
[16:19:18.382]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:18.382]                                 info, version)
[16:19:18.382]                             }
[16:19:18.382]                             base::stop(msg)
[16:19:18.382]                           }
[16:19:18.382]                         })
[16:19:18.382]                       }
[16:19:18.382]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:18.382]                       base::options(mc.cores = 1L)
[16:19:18.382]                     }
[16:19:18.382]                     base::local({
[16:19:18.382]                       for (pkg in "future.apply") {
[16:19:18.382]                         base::loadNamespace(pkg)
[16:19:18.382]                         base::library(pkg, character.only = TRUE)
[16:19:18.382]                       }
[16:19:18.382]                     })
[16:19:18.382]                   }
[16:19:18.382]                   ...future.strategy.old <- future::plan("list")
[16:19:18.382]                   options(future.plan = NULL)
[16:19:18.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:18.382]                 }
[16:19:18.382]                 ...future.workdir <- getwd()
[16:19:18.382]             }
[16:19:18.382]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:18.382]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:18.382]         }
[16:19:18.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:18.382]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:18.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:18.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:18.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:18.382]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:18.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:18.382]             base::names(...future.oldOptions))
[16:19:18.382]     }
[16:19:18.382]     if (FALSE) {
[16:19:18.382]     }
[16:19:18.382]     else {
[16:19:18.382]         if (TRUE) {
[16:19:18.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:18.382]                 open = "w")
[16:19:18.382]         }
[16:19:18.382]         else {
[16:19:18.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:18.382]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:18.382]         }
[16:19:18.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:18.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:18.382]             base::sink(type = "output", split = FALSE)
[16:19:18.382]             base::close(...future.stdout)
[16:19:18.382]         }, add = TRUE)
[16:19:18.382]     }
[16:19:18.382]     ...future.frame <- base::sys.nframe()
[16:19:18.382]     ...future.conditions <- base::list()
[16:19:18.382]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:18.382]     if (FALSE) {
[16:19:18.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:18.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:18.382]     }
[16:19:18.382]     ...future.result <- base::tryCatch({
[16:19:18.382]         base::withCallingHandlers({
[16:19:18.382]             ...future.value <- base::withVisible(base::local({
[16:19:18.382]                 ...future.makeSendCondition <- base::local({
[16:19:18.382]                   sendCondition <- NULL
[16:19:18.382]                   function(frame = 1L) {
[16:19:18.382]                     if (is.function(sendCondition)) 
[16:19:18.382]                       return(sendCondition)
[16:19:18.382]                     ns <- getNamespace("parallel")
[16:19:18.382]                     if (exists("sendData", mode = "function", 
[16:19:18.382]                       envir = ns)) {
[16:19:18.382]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:18.382]                         envir = ns)
[16:19:18.382]                       envir <- sys.frame(frame)
[16:19:18.382]                       master <- NULL
[16:19:18.382]                       while (!identical(envir, .GlobalEnv) && 
[16:19:18.382]                         !identical(envir, emptyenv())) {
[16:19:18.382]                         if (exists("master", mode = "list", envir = envir, 
[16:19:18.382]                           inherits = FALSE)) {
[16:19:18.382]                           master <- get("master", mode = "list", 
[16:19:18.382]                             envir = envir, inherits = FALSE)
[16:19:18.382]                           if (inherits(master, c("SOCKnode", 
[16:19:18.382]                             "SOCK0node"))) {
[16:19:18.382]                             sendCondition <<- function(cond) {
[16:19:18.382]                               data <- list(type = "VALUE", value = cond, 
[16:19:18.382]                                 success = TRUE)
[16:19:18.382]                               parallel_sendData(master, data)
[16:19:18.382]                             }
[16:19:18.382]                             return(sendCondition)
[16:19:18.382]                           }
[16:19:18.382]                         }
[16:19:18.382]                         frame <- frame + 1L
[16:19:18.382]                         envir <- sys.frame(frame)
[16:19:18.382]                       }
[16:19:18.382]                     }
[16:19:18.382]                     sendCondition <<- function(cond) NULL
[16:19:18.382]                   }
[16:19:18.382]                 })
[16:19:18.382]                 withCallingHandlers({
[16:19:18.382]                   {
[16:19:18.382]                     do.call(function(...) {
[16:19:18.382]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.382]                       if (!identical(...future.globals.maxSize.org, 
[16:19:18.382]                         ...future.globals.maxSize)) {
[16:19:18.382]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.382]                         on.exit(options(oopts), add = TRUE)
[16:19:18.382]                       }
[16:19:18.382]                       {
[16:19:18.382]                         lapply(seq_along(...future.elements_ii), 
[16:19:18.382]                           FUN = function(jj) {
[16:19:18.382]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.382]                             ...future.FUN(...future.X_jj, ...)
[16:19:18.382]                           })
[16:19:18.382]                       }
[16:19:18.382]                     }, args = future.call.arguments)
[16:19:18.382]                   }
[16:19:18.382]                 }, immediateCondition = function(cond) {
[16:19:18.382]                   sendCondition <- ...future.makeSendCondition()
[16:19:18.382]                   sendCondition(cond)
[16:19:18.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.382]                   {
[16:19:18.382]                     inherits <- base::inherits
[16:19:18.382]                     invokeRestart <- base::invokeRestart
[16:19:18.382]                     is.null <- base::is.null
[16:19:18.382]                     muffled <- FALSE
[16:19:18.382]                     if (inherits(cond, "message")) {
[16:19:18.382]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:18.382]                       if (muffled) 
[16:19:18.382]                         invokeRestart("muffleMessage")
[16:19:18.382]                     }
[16:19:18.382]                     else if (inherits(cond, "warning")) {
[16:19:18.382]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:18.382]                       if (muffled) 
[16:19:18.382]                         invokeRestart("muffleWarning")
[16:19:18.382]                     }
[16:19:18.382]                     else if (inherits(cond, "condition")) {
[16:19:18.382]                       if (!is.null(pattern)) {
[16:19:18.382]                         computeRestarts <- base::computeRestarts
[16:19:18.382]                         grepl <- base::grepl
[16:19:18.382]                         restarts <- computeRestarts(cond)
[16:19:18.382]                         for (restart in restarts) {
[16:19:18.382]                           name <- restart$name
[16:19:18.382]                           if (is.null(name)) 
[16:19:18.382]                             next
[16:19:18.382]                           if (!grepl(pattern, name)) 
[16:19:18.382]                             next
[16:19:18.382]                           invokeRestart(restart)
[16:19:18.382]                           muffled <- TRUE
[16:19:18.382]                           break
[16:19:18.382]                         }
[16:19:18.382]                       }
[16:19:18.382]                     }
[16:19:18.382]                     invisible(muffled)
[16:19:18.382]                   }
[16:19:18.382]                   muffleCondition(cond)
[16:19:18.382]                 })
[16:19:18.382]             }))
[16:19:18.382]             future::FutureResult(value = ...future.value$value, 
[16:19:18.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.382]                   ...future.rng), globalenv = if (FALSE) 
[16:19:18.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:18.382]                     ...future.globalenv.names))
[16:19:18.382]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:18.382]         }, condition = base::local({
[16:19:18.382]             c <- base::c
[16:19:18.382]             inherits <- base::inherits
[16:19:18.382]             invokeRestart <- base::invokeRestart
[16:19:18.382]             length <- base::length
[16:19:18.382]             list <- base::list
[16:19:18.382]             seq.int <- base::seq.int
[16:19:18.382]             signalCondition <- base::signalCondition
[16:19:18.382]             sys.calls <- base::sys.calls
[16:19:18.382]             `[[` <- base::`[[`
[16:19:18.382]             `+` <- base::`+`
[16:19:18.382]             `<<-` <- base::`<<-`
[16:19:18.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:18.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:18.382]                   3L)]
[16:19:18.382]             }
[16:19:18.382]             function(cond) {
[16:19:18.382]                 is_error <- inherits(cond, "error")
[16:19:18.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:18.382]                   NULL)
[16:19:18.382]                 if (is_error) {
[16:19:18.382]                   sessionInformation <- function() {
[16:19:18.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:18.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:18.382]                       search = base::search(), system = base::Sys.info())
[16:19:18.382]                   }
[16:19:18.382]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:18.382]                     cond$call), session = sessionInformation(), 
[16:19:18.382]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:18.382]                   signalCondition(cond)
[16:19:18.382]                 }
[16:19:18.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:18.382]                 "immediateCondition"))) {
[16:19:18.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:18.382]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:18.382]                   if (TRUE && !signal) {
[16:19:18.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.382]                     {
[16:19:18.382]                       inherits <- base::inherits
[16:19:18.382]                       invokeRestart <- base::invokeRestart
[16:19:18.382]                       is.null <- base::is.null
[16:19:18.382]                       muffled <- FALSE
[16:19:18.382]                       if (inherits(cond, "message")) {
[16:19:18.382]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.382]                         if (muffled) 
[16:19:18.382]                           invokeRestart("muffleMessage")
[16:19:18.382]                       }
[16:19:18.382]                       else if (inherits(cond, "warning")) {
[16:19:18.382]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.382]                         if (muffled) 
[16:19:18.382]                           invokeRestart("muffleWarning")
[16:19:18.382]                       }
[16:19:18.382]                       else if (inherits(cond, "condition")) {
[16:19:18.382]                         if (!is.null(pattern)) {
[16:19:18.382]                           computeRestarts <- base::computeRestarts
[16:19:18.382]                           grepl <- base::grepl
[16:19:18.382]                           restarts <- computeRestarts(cond)
[16:19:18.382]                           for (restart in restarts) {
[16:19:18.382]                             name <- restart$name
[16:19:18.382]                             if (is.null(name)) 
[16:19:18.382]                               next
[16:19:18.382]                             if (!grepl(pattern, name)) 
[16:19:18.382]                               next
[16:19:18.382]                             invokeRestart(restart)
[16:19:18.382]                             muffled <- TRUE
[16:19:18.382]                             break
[16:19:18.382]                           }
[16:19:18.382]                         }
[16:19:18.382]                       }
[16:19:18.382]                       invisible(muffled)
[16:19:18.382]                     }
[16:19:18.382]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.382]                   }
[16:19:18.382]                 }
[16:19:18.382]                 else {
[16:19:18.382]                   if (TRUE) {
[16:19:18.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.382]                     {
[16:19:18.382]                       inherits <- base::inherits
[16:19:18.382]                       invokeRestart <- base::invokeRestart
[16:19:18.382]                       is.null <- base::is.null
[16:19:18.382]                       muffled <- FALSE
[16:19:18.382]                       if (inherits(cond, "message")) {
[16:19:18.382]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.382]                         if (muffled) 
[16:19:18.382]                           invokeRestart("muffleMessage")
[16:19:18.382]                       }
[16:19:18.382]                       else if (inherits(cond, "warning")) {
[16:19:18.382]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.382]                         if (muffled) 
[16:19:18.382]                           invokeRestart("muffleWarning")
[16:19:18.382]                       }
[16:19:18.382]                       else if (inherits(cond, "condition")) {
[16:19:18.382]                         if (!is.null(pattern)) {
[16:19:18.382]                           computeRestarts <- base::computeRestarts
[16:19:18.382]                           grepl <- base::grepl
[16:19:18.382]                           restarts <- computeRestarts(cond)
[16:19:18.382]                           for (restart in restarts) {
[16:19:18.382]                             name <- restart$name
[16:19:18.382]                             if (is.null(name)) 
[16:19:18.382]                               next
[16:19:18.382]                             if (!grepl(pattern, name)) 
[16:19:18.382]                               next
[16:19:18.382]                             invokeRestart(restart)
[16:19:18.382]                             muffled <- TRUE
[16:19:18.382]                             break
[16:19:18.382]                           }
[16:19:18.382]                         }
[16:19:18.382]                       }
[16:19:18.382]                       invisible(muffled)
[16:19:18.382]                     }
[16:19:18.382]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.382]                   }
[16:19:18.382]                 }
[16:19:18.382]             }
[16:19:18.382]         }))
[16:19:18.382]     }, error = function(ex) {
[16:19:18.382]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:18.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.382]                 ...future.rng), started = ...future.startTime, 
[16:19:18.382]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:18.382]             version = "1.8"), class = "FutureResult")
[16:19:18.382]     }, finally = {
[16:19:18.382]         if (!identical(...future.workdir, getwd())) 
[16:19:18.382]             setwd(...future.workdir)
[16:19:18.382]         {
[16:19:18.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:18.382]                 ...future.oldOptions$nwarnings <- NULL
[16:19:18.382]             }
[16:19:18.382]             base::options(...future.oldOptions)
[16:19:18.382]             if (.Platform$OS.type == "windows") {
[16:19:18.382]                 old_names <- names(...future.oldEnvVars)
[16:19:18.382]                 envs <- base::Sys.getenv()
[16:19:18.382]                 names <- names(envs)
[16:19:18.382]                 common <- intersect(names, old_names)
[16:19:18.382]                 added <- setdiff(names, old_names)
[16:19:18.382]                 removed <- setdiff(old_names, names)
[16:19:18.382]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:18.382]                   envs[common]]
[16:19:18.382]                 NAMES <- toupper(changed)
[16:19:18.382]                 args <- list()
[16:19:18.382]                 for (kk in seq_along(NAMES)) {
[16:19:18.382]                   name <- changed[[kk]]
[16:19:18.382]                   NAME <- NAMES[[kk]]
[16:19:18.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.382]                     next
[16:19:18.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.382]                 }
[16:19:18.382]                 NAMES <- toupper(added)
[16:19:18.382]                 for (kk in seq_along(NAMES)) {
[16:19:18.382]                   name <- added[[kk]]
[16:19:18.382]                   NAME <- NAMES[[kk]]
[16:19:18.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.382]                     next
[16:19:18.382]                   args[[name]] <- ""
[16:19:18.382]                 }
[16:19:18.382]                 NAMES <- toupper(removed)
[16:19:18.382]                 for (kk in seq_along(NAMES)) {
[16:19:18.382]                   name <- removed[[kk]]
[16:19:18.382]                   NAME <- NAMES[[kk]]
[16:19:18.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.382]                     next
[16:19:18.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.382]                 }
[16:19:18.382]                 if (length(args) > 0) 
[16:19:18.382]                   base::do.call(base::Sys.setenv, args = args)
[16:19:18.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:18.382]             }
[16:19:18.382]             else {
[16:19:18.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:18.382]             }
[16:19:18.382]             {
[16:19:18.382]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:18.382]                   0L) {
[16:19:18.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:18.382]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:18.382]                   base::options(opts)
[16:19:18.382]                 }
[16:19:18.382]                 {
[16:19:18.382]                   {
[16:19:18.382]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:18.382]                     NULL
[16:19:18.382]                   }
[16:19:18.382]                   options(future.plan = NULL)
[16:19:18.382]                   if (is.na(NA_character_)) 
[16:19:18.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:18.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:18.382]                     .init = FALSE)
[16:19:18.382]                 }
[16:19:18.382]             }
[16:19:18.382]         }
[16:19:18.382]     })
[16:19:18.382]     if (TRUE) {
[16:19:18.382]         base::sink(type = "output", split = FALSE)
[16:19:18.382]         if (TRUE) {
[16:19:18.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:18.382]         }
[16:19:18.382]         else {
[16:19:18.382]             ...future.result["stdout"] <- base::list(NULL)
[16:19:18.382]         }
[16:19:18.382]         base::close(...future.stdout)
[16:19:18.382]         ...future.stdout <- NULL
[16:19:18.382]     }
[16:19:18.382]     ...future.result$conditions <- ...future.conditions
[16:19:18.382]     ...future.result$finished <- base::Sys.time()
[16:19:18.382]     ...future.result
[16:19:18.382] }
[16:19:18.385] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[16:19:18.385] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:19:18.429] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:19:18.429] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[16:19:18.429] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[16:19:18.429] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:19:18.430] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:19:18.430] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:19:18.473] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:19:18.473] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:19:18.517] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:19:18.517] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:19:18.517] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:19:18.517] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[16:19:18.518] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[16:19:18.518] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:18.518] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:18.519] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:19:18.519] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:19:18.519] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:18.519] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:18.520] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:18.520] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:18.520] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[16:19:18.521] MultisessionFuture started
[16:19:18.521] - Launch lazy future ... done
[16:19:18.521] run() for ‘MultisessionFuture’ ... done
[16:19:18.521] Created future:
[16:19:18.523] receiveMessageFromWorker() for ClusterFuture ...
[16:19:18.523] - Validating connection of MultisessionFuture
[16:19:18.523] - received message: FutureResult
[16:19:18.523] - Received FutureResult
[16:19:18.523] - Erased future from FutureRegistry
[16:19:18.523] result() for ClusterFuture ...
[16:19:18.523] - result already collected: FutureResult
[16:19:18.523] result() for ClusterFuture ... done
[16:19:18.524] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:18.521] MultisessionFuture:
[16:19:18.521] Label: ‘future_vapply-2’
[16:19:18.521] Expression:
[16:19:18.521] {
[16:19:18.521]     do.call(function(...) {
[16:19:18.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.521]             on.exit(options(oopts), add = TRUE)
[16:19:18.521]         }
[16:19:18.521]         {
[16:19:18.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.521]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.521]             })
[16:19:18.521]         }
[16:19:18.521]     }, args = future.call.arguments)
[16:19:18.521] }
[16:19:18.521] Lazy evaluation: FALSE
[16:19:18.521] Asynchronous evaluation: TRUE
[16:19:18.521] Local evaluation: TRUE
[16:19:18.521] Environment: R_GlobalEnv
[16:19:18.521] Capture standard output: TRUE
[16:19:18.521] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:18.521] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:18.521] Packages: 1 packages (‘future.apply’)
[16:19:18.521] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:18.521] Resolved: TRUE
[16:19:18.521] Value: <not collected>
[16:19:18.521] Conditions captured: <none>
[16:19:18.521] Early signaling: FALSE
[16:19:18.521] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:18.521] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.524] Chunk #2 of 2 ... DONE
[16:19:18.524] Launching 2 futures (chunks) ... DONE
[16:19:18.524] Resolving 2 futures (chunks) ...
[16:19:18.524] resolve() on list ...
[16:19:18.524]  recursive: 0
[16:19:18.524]  length: 2
[16:19:18.524] 
[16:19:18.525] receiveMessageFromWorker() for ClusterFuture ...
[16:19:18.525] - Validating connection of MultisessionFuture
[16:19:18.525] - received message: FutureResult
[16:19:18.525] - Received FutureResult
[16:19:18.525] - Erased future from FutureRegistry
[16:19:18.526] result() for ClusterFuture ...
[16:19:18.526] - result already collected: FutureResult
[16:19:18.526] result() for ClusterFuture ... done
[16:19:18.526] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:18.526] Future #1
[16:19:18.526] result() for ClusterFuture ...
[16:19:18.526] - result already collected: FutureResult
[16:19:18.526] result() for ClusterFuture ... done
[16:19:18.526] result() for ClusterFuture ...
[16:19:18.526] - result already collected: FutureResult
[16:19:18.526] result() for ClusterFuture ... done
[16:19:18.527] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:18.527] - nx: 2
[16:19:18.527] - relay: TRUE
[16:19:18.527] - stdout: TRUE
[16:19:18.527] - signal: TRUE
[16:19:18.527] - resignal: FALSE
[16:19:18.527] - force: TRUE
[16:19:18.527] - relayed: [n=2] FALSE, FALSE
[16:19:18.527] - queued futures: [n=2] FALSE, FALSE
[16:19:18.527]  - until=1
[16:19:18.527]  - relaying element #1
[16:19:18.530] result() for ClusterFuture ...
[16:19:18.530] - result already collected: FutureResult
[16:19:18.530] result() for ClusterFuture ... done
[16:19:18.530] result() for ClusterFuture ...
[16:19:18.531] - result already collected: FutureResult
[16:19:18.531] result() for ClusterFuture ... done
[16:19:18.531] result() for ClusterFuture ...
[16:19:18.531] - result already collected: FutureResult
[16:19:18.531] result() for ClusterFuture ... done
[16:19:18.531] result() for ClusterFuture ...
[16:19:18.531] - result already collected: FutureResult
[16:19:18.531] result() for ClusterFuture ... done
[16:19:18.531] - relayed: [n=2] TRUE, FALSE
[16:19:18.531] - queued futures: [n=2] TRUE, FALSE
[16:19:18.531] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:18.532]  length: 1 (resolved future 1)
[16:19:18.532] Future #2
[16:19:18.532] result() for ClusterFuture ...
[16:19:18.532] - result already collected: FutureResult
[16:19:18.532] result() for ClusterFuture ... done
[16:19:18.532] result() for ClusterFuture ...
[16:19:18.532] - result already collected: FutureResult
[16:19:18.532] result() for ClusterFuture ... done
[16:19:18.532] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:18.532] - nx: 2
[16:19:18.532] - relay: TRUE
[16:19:18.533] - stdout: TRUE
[16:19:18.533] - signal: TRUE
[16:19:18.533] - resignal: FALSE
[16:19:18.533] - force: TRUE
[16:19:18.533] - relayed: [n=2] TRUE, FALSE
[16:19:18.533] - queued futures: [n=2] TRUE, FALSE
[16:19:18.533]  - until=2
[16:19:18.533]  - relaying element #2
[16:19:18.533] result() for ClusterFuture ...
[16:19:18.533] - result already collected: FutureResult
[16:19:18.533] result() for ClusterFuture ... done
[16:19:18.534] result() for ClusterFuture ...
[16:19:18.534] - result already collected: FutureResult
[16:19:18.534] result() for ClusterFuture ... done
[16:19:18.534] result() for ClusterFuture ...
[16:19:18.534] - result already collected: FutureResult
[16:19:18.534] result() for ClusterFuture ... done
[16:19:18.534] result() for ClusterFuture ...
[16:19:18.534] - result already collected: FutureResult
[16:19:18.534] result() for ClusterFuture ... done
[16:19:18.534] - relayed: [n=2] TRUE, TRUE
[16:19:18.534] - queued futures: [n=2] TRUE, TRUE
[16:19:18.534] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:18.535]  length: 0 (resolved future 2)
[16:19:18.535] Relaying remaining futures
[16:19:18.535] signalConditionsASAP(NULL, pos=0) ...
[16:19:18.535] - nx: 2
[16:19:18.535] - relay: TRUE
[16:19:18.535] - stdout: TRUE
[16:19:18.535] - signal: TRUE
[16:19:18.535] - resignal: FALSE
[16:19:18.535] - force: TRUE
[16:19:18.535] - relayed: [n=2] TRUE, TRUE
[16:19:18.535] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:18.536] - relayed: [n=2] TRUE, TRUE
[16:19:18.536] - queued futures: [n=2] TRUE, TRUE
[16:19:18.536] signalConditionsASAP(NULL, pos=0) ... done
[16:19:18.536] resolve() on list ... DONE
[16:19:18.536] result() for ClusterFuture ...
[16:19:18.536] - result already collected: FutureResult
[16:19:18.536] result() for ClusterFuture ... done
[16:19:18.536] result() for ClusterFuture ...
[16:19:18.536] - result already collected: FutureResult
[16:19:18.536] result() for ClusterFuture ... done
[16:19:18.536] result() for ClusterFuture ...
[16:19:18.537] - result already collected: FutureResult
[16:19:18.537] result() for ClusterFuture ... done
[16:19:18.537] result() for ClusterFuture ...
[16:19:18.537] - result already collected: FutureResult
[16:19:18.537] result() for ClusterFuture ... done
[16:19:18.537]  - Number of value chunks collected: 2
[16:19:18.537] Resolving 2 futures (chunks) ... DONE
[16:19:18.537] Reducing values from 2 chunks ...
[16:19:18.537]  - Number of values collected after concatenation: 10
[16:19:18.537]  - Number of values expected: 10
[16:19:18.537] Reducing values from 2 chunks ... DONE
[16:19:18.538] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:19:18.539] future_lapply() ...
[16:19:18.545] Number of chunks: 2
[16:19:18.545] getGlobalsAndPackagesXApply() ...
[16:19:18.545]  - future.globals: TRUE
[16:19:18.545] getGlobalsAndPackages() ...
[16:19:18.545] Searching for globals...
[16:19:18.549] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:19:18.549] Searching for globals ... DONE
[16:19:18.549] Resolving globals: FALSE
[16:19:18.550] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:19:18.550] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:18.551] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:18.551] - packages: [1] ‘future.apply’
[16:19:18.551] getGlobalsAndPackages() ... DONE
[16:19:18.551]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:18.551]  - needed namespaces: [n=1] ‘future.apply’
[16:19:18.551] Finding globals ... DONE
[16:19:18.551]  - use_args: TRUE
[16:19:18.551]  - Getting '...' globals ...
[16:19:18.552] resolve() on list ...
[16:19:18.552]  recursive: 0
[16:19:18.552]  length: 1
[16:19:18.552]  elements: ‘...’
[16:19:18.552]  length: 0 (resolved future 1)
[16:19:18.552] resolve() on list ... DONE
[16:19:18.552]    - '...' content: [n=0] 
[16:19:18.552] List of 1
[16:19:18.552]  $ ...: list()
[16:19:18.552]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:18.552]  - attr(*, "where")=List of 1
[16:19:18.552]   ..$ ...:<environment: 0x56199f291378> 
[16:19:18.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:18.552]  - attr(*, "resolved")= logi TRUE
[16:19:18.552]  - attr(*, "total_size")= num NA
[16:19:18.555]  - Getting '...' globals ... DONE
[16:19:18.555] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:18.555] List of 8
[16:19:18.555]  $ ...future.FUN:function (x, ...)  
[16:19:18.555]  $ x_FUN        :function (x)  
[16:19:18.555]  $ times        : int 4
[16:19:18.555]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:18.555]  $ stop_if_not  :function (...)  
[16:19:18.555]  $ dim          : int [1:2] 2 2
[16:19:18.555]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:18.555]  $ ...          : list()
[16:19:18.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:18.555]  - attr(*, "where")=List of 8
[16:19:18.555]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:18.555]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:18.555]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:18.555]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:18.555]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:18.555]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:18.555]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:18.555]   ..$ ...          :<environment: 0x56199f291378> 
[16:19:18.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:18.555]  - attr(*, "resolved")= logi FALSE
[16:19:18.555]  - attr(*, "total_size")= num 97304
[16:19:18.561] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:18.561] getGlobalsAndPackagesXApply() ... DONE
[16:19:18.561] Number of futures (= number of chunks): 2
[16:19:18.561] Launching 2 futures (chunks) ...
[16:19:18.561] Chunk #1 of 2 ...
[16:19:18.561]  - Finding globals in 'X' for chunk #1 ...
[16:19:18.561] getGlobalsAndPackages() ...
[16:19:18.561] Searching for globals...
[16:19:18.562] 
[16:19:18.562] Searching for globals ... DONE
[16:19:18.562] - globals: [0] <none>
[16:19:18.562] getGlobalsAndPackages() ... DONE
[16:19:18.562]    + additional globals found: [n=0] 
[16:19:18.562]    + additional namespaces needed: [n=0] 
[16:19:18.562]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:18.562]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:18.562]  - seeds: <none>
[16:19:18.562]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.563] getGlobalsAndPackages() ...
[16:19:18.563] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.563] Resolving globals: FALSE
[16:19:18.563] Tweak future expression to call with '...' arguments ...
[16:19:18.563] {
[16:19:18.563]     do.call(function(...) {
[16:19:18.563]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.563]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.563]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.563]             on.exit(options(oopts), add = TRUE)
[16:19:18.563]         }
[16:19:18.563]         {
[16:19:18.563]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.563]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.563]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.563]             })
[16:19:18.563]         }
[16:19:18.563]     }, args = future.call.arguments)
[16:19:18.563] }
[16:19:18.563] Tweak future expression to call with '...' arguments ... DONE
[16:19:18.564] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.564] - packages: [1] ‘future.apply’
[16:19:18.564] getGlobalsAndPackages() ... DONE
[16:19:18.564] run() for ‘Future’ ...
[16:19:18.564] - state: ‘created’
[16:19:18.565] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:18.579] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:18.579]   - Field: ‘node’
[16:19:18.579]   - Field: ‘label’
[16:19:18.579]   - Field: ‘local’
[16:19:18.579]   - Field: ‘owner’
[16:19:18.579]   - Field: ‘envir’
[16:19:18.579]   - Field: ‘workers’
[16:19:18.579]   - Field: ‘packages’
[16:19:18.579]   - Field: ‘gc’
[16:19:18.580]   - Field: ‘conditions’
[16:19:18.580]   - Field: ‘persistent’
[16:19:18.580]   - Field: ‘expr’
[16:19:18.580]   - Field: ‘uuid’
[16:19:18.580]   - Field: ‘seed’
[16:19:18.580]   - Field: ‘version’
[16:19:18.580]   - Field: ‘result’
[16:19:18.580]   - Field: ‘asynchronous’
[16:19:18.580]   - Field: ‘calls’
[16:19:18.580]   - Field: ‘globals’
[16:19:18.581]   - Field: ‘stdout’
[16:19:18.581]   - Field: ‘earlySignal’
[16:19:18.581]   - Field: ‘lazy’
[16:19:18.581]   - Field: ‘state’
[16:19:18.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:18.581] - Launch lazy future ...
[16:19:18.581] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:18.581] Packages needed by future strategies (n = 0): <none>
[16:19:18.582] {
[16:19:18.582]     {
[16:19:18.582]         {
[16:19:18.582]             ...future.startTime <- base::Sys.time()
[16:19:18.582]             {
[16:19:18.582]                 {
[16:19:18.582]                   {
[16:19:18.582]                     {
[16:19:18.582]                       {
[16:19:18.582]                         base::local({
[16:19:18.582]                           has_future <- base::requireNamespace("future", 
[16:19:18.582]                             quietly = TRUE)
[16:19:18.582]                           if (has_future) {
[16:19:18.582]                             ns <- base::getNamespace("future")
[16:19:18.582]                             version <- ns[[".package"]][["version"]]
[16:19:18.582]                             if (is.null(version)) 
[16:19:18.582]                               version <- utils::packageVersion("future")
[16:19:18.582]                           }
[16:19:18.582]                           else {
[16:19:18.582]                             version <- NULL
[16:19:18.582]                           }
[16:19:18.582]                           if (!has_future || version < "1.8.0") {
[16:19:18.582]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:18.582]                               "", base::R.version$version.string), 
[16:19:18.582]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:18.582]                                 base::R.version$platform, 8 * 
[16:19:18.582]                                   base::.Machine$sizeof.pointer), 
[16:19:18.582]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:18.582]                                 "release", "version")], collapse = " "), 
[16:19:18.582]                               hostname = base::Sys.info()[["nodename"]])
[16:19:18.582]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:18.582]                               info)
[16:19:18.582]                             info <- base::paste(info, collapse = "; ")
[16:19:18.582]                             if (!has_future) {
[16:19:18.582]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:18.582]                                 info)
[16:19:18.582]                             }
[16:19:18.582]                             else {
[16:19:18.582]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:18.582]                                 info, version)
[16:19:18.582]                             }
[16:19:18.582]                             base::stop(msg)
[16:19:18.582]                           }
[16:19:18.582]                         })
[16:19:18.582]                       }
[16:19:18.582]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:18.582]                       base::options(mc.cores = 1L)
[16:19:18.582]                     }
[16:19:18.582]                     base::local({
[16:19:18.582]                       for (pkg in "future.apply") {
[16:19:18.582]                         base::loadNamespace(pkg)
[16:19:18.582]                         base::library(pkg, character.only = TRUE)
[16:19:18.582]                       }
[16:19:18.582]                     })
[16:19:18.582]                   }
[16:19:18.582]                   ...future.strategy.old <- future::plan("list")
[16:19:18.582]                   options(future.plan = NULL)
[16:19:18.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:18.582]                 }
[16:19:18.582]                 ...future.workdir <- getwd()
[16:19:18.582]             }
[16:19:18.582]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:18.582]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:18.582]         }
[16:19:18.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:18.582]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:18.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:18.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:18.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:18.582]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:18.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:18.582]             base::names(...future.oldOptions))
[16:19:18.582]     }
[16:19:18.582]     if (FALSE) {
[16:19:18.582]     }
[16:19:18.582]     else {
[16:19:18.582]         if (TRUE) {
[16:19:18.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:18.582]                 open = "w")
[16:19:18.582]         }
[16:19:18.582]         else {
[16:19:18.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:18.582]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:18.582]         }
[16:19:18.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:18.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:18.582]             base::sink(type = "output", split = FALSE)
[16:19:18.582]             base::close(...future.stdout)
[16:19:18.582]         }, add = TRUE)
[16:19:18.582]     }
[16:19:18.582]     ...future.frame <- base::sys.nframe()
[16:19:18.582]     ...future.conditions <- base::list()
[16:19:18.582]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:18.582]     if (FALSE) {
[16:19:18.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:18.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:18.582]     }
[16:19:18.582]     ...future.result <- base::tryCatch({
[16:19:18.582]         base::withCallingHandlers({
[16:19:18.582]             ...future.value <- base::withVisible(base::local({
[16:19:18.582]                 ...future.makeSendCondition <- base::local({
[16:19:18.582]                   sendCondition <- NULL
[16:19:18.582]                   function(frame = 1L) {
[16:19:18.582]                     if (is.function(sendCondition)) 
[16:19:18.582]                       return(sendCondition)
[16:19:18.582]                     ns <- getNamespace("parallel")
[16:19:18.582]                     if (exists("sendData", mode = "function", 
[16:19:18.582]                       envir = ns)) {
[16:19:18.582]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:18.582]                         envir = ns)
[16:19:18.582]                       envir <- sys.frame(frame)
[16:19:18.582]                       master <- NULL
[16:19:18.582]                       while (!identical(envir, .GlobalEnv) && 
[16:19:18.582]                         !identical(envir, emptyenv())) {
[16:19:18.582]                         if (exists("master", mode = "list", envir = envir, 
[16:19:18.582]                           inherits = FALSE)) {
[16:19:18.582]                           master <- get("master", mode = "list", 
[16:19:18.582]                             envir = envir, inherits = FALSE)
[16:19:18.582]                           if (inherits(master, c("SOCKnode", 
[16:19:18.582]                             "SOCK0node"))) {
[16:19:18.582]                             sendCondition <<- function(cond) {
[16:19:18.582]                               data <- list(type = "VALUE", value = cond, 
[16:19:18.582]                                 success = TRUE)
[16:19:18.582]                               parallel_sendData(master, data)
[16:19:18.582]                             }
[16:19:18.582]                             return(sendCondition)
[16:19:18.582]                           }
[16:19:18.582]                         }
[16:19:18.582]                         frame <- frame + 1L
[16:19:18.582]                         envir <- sys.frame(frame)
[16:19:18.582]                       }
[16:19:18.582]                     }
[16:19:18.582]                     sendCondition <<- function(cond) NULL
[16:19:18.582]                   }
[16:19:18.582]                 })
[16:19:18.582]                 withCallingHandlers({
[16:19:18.582]                   {
[16:19:18.582]                     do.call(function(...) {
[16:19:18.582]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.582]                       if (!identical(...future.globals.maxSize.org, 
[16:19:18.582]                         ...future.globals.maxSize)) {
[16:19:18.582]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.582]                         on.exit(options(oopts), add = TRUE)
[16:19:18.582]                       }
[16:19:18.582]                       {
[16:19:18.582]                         lapply(seq_along(...future.elements_ii), 
[16:19:18.582]                           FUN = function(jj) {
[16:19:18.582]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.582]                             ...future.FUN(...future.X_jj, ...)
[16:19:18.582]                           })
[16:19:18.582]                       }
[16:19:18.582]                     }, args = future.call.arguments)
[16:19:18.582]                   }
[16:19:18.582]                 }, immediateCondition = function(cond) {
[16:19:18.582]                   sendCondition <- ...future.makeSendCondition()
[16:19:18.582]                   sendCondition(cond)
[16:19:18.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.582]                   {
[16:19:18.582]                     inherits <- base::inherits
[16:19:18.582]                     invokeRestart <- base::invokeRestart
[16:19:18.582]                     is.null <- base::is.null
[16:19:18.582]                     muffled <- FALSE
[16:19:18.582]                     if (inherits(cond, "message")) {
[16:19:18.582]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:18.582]                       if (muffled) 
[16:19:18.582]                         invokeRestart("muffleMessage")
[16:19:18.582]                     }
[16:19:18.582]                     else if (inherits(cond, "warning")) {
[16:19:18.582]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:18.582]                       if (muffled) 
[16:19:18.582]                         invokeRestart("muffleWarning")
[16:19:18.582]                     }
[16:19:18.582]                     else if (inherits(cond, "condition")) {
[16:19:18.582]                       if (!is.null(pattern)) {
[16:19:18.582]                         computeRestarts <- base::computeRestarts
[16:19:18.582]                         grepl <- base::grepl
[16:19:18.582]                         restarts <- computeRestarts(cond)
[16:19:18.582]                         for (restart in restarts) {
[16:19:18.582]                           name <- restart$name
[16:19:18.582]                           if (is.null(name)) 
[16:19:18.582]                             next
[16:19:18.582]                           if (!grepl(pattern, name)) 
[16:19:18.582]                             next
[16:19:18.582]                           invokeRestart(restart)
[16:19:18.582]                           muffled <- TRUE
[16:19:18.582]                           break
[16:19:18.582]                         }
[16:19:18.582]                       }
[16:19:18.582]                     }
[16:19:18.582]                     invisible(muffled)
[16:19:18.582]                   }
[16:19:18.582]                   muffleCondition(cond)
[16:19:18.582]                 })
[16:19:18.582]             }))
[16:19:18.582]             future::FutureResult(value = ...future.value$value, 
[16:19:18.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.582]                   ...future.rng), globalenv = if (FALSE) 
[16:19:18.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:18.582]                     ...future.globalenv.names))
[16:19:18.582]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:18.582]         }, condition = base::local({
[16:19:18.582]             c <- base::c
[16:19:18.582]             inherits <- base::inherits
[16:19:18.582]             invokeRestart <- base::invokeRestart
[16:19:18.582]             length <- base::length
[16:19:18.582]             list <- base::list
[16:19:18.582]             seq.int <- base::seq.int
[16:19:18.582]             signalCondition <- base::signalCondition
[16:19:18.582]             sys.calls <- base::sys.calls
[16:19:18.582]             `[[` <- base::`[[`
[16:19:18.582]             `+` <- base::`+`
[16:19:18.582]             `<<-` <- base::`<<-`
[16:19:18.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:18.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:18.582]                   3L)]
[16:19:18.582]             }
[16:19:18.582]             function(cond) {
[16:19:18.582]                 is_error <- inherits(cond, "error")
[16:19:18.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:18.582]                   NULL)
[16:19:18.582]                 if (is_error) {
[16:19:18.582]                   sessionInformation <- function() {
[16:19:18.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:18.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:18.582]                       search = base::search(), system = base::Sys.info())
[16:19:18.582]                   }
[16:19:18.582]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:18.582]                     cond$call), session = sessionInformation(), 
[16:19:18.582]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:18.582]                   signalCondition(cond)
[16:19:18.582]                 }
[16:19:18.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:18.582]                 "immediateCondition"))) {
[16:19:18.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:18.582]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:18.582]                   if (TRUE && !signal) {
[16:19:18.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.582]                     {
[16:19:18.582]                       inherits <- base::inherits
[16:19:18.582]                       invokeRestart <- base::invokeRestart
[16:19:18.582]                       is.null <- base::is.null
[16:19:18.582]                       muffled <- FALSE
[16:19:18.582]                       if (inherits(cond, "message")) {
[16:19:18.582]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.582]                         if (muffled) 
[16:19:18.582]                           invokeRestart("muffleMessage")
[16:19:18.582]                       }
[16:19:18.582]                       else if (inherits(cond, "warning")) {
[16:19:18.582]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.582]                         if (muffled) 
[16:19:18.582]                           invokeRestart("muffleWarning")
[16:19:18.582]                       }
[16:19:18.582]                       else if (inherits(cond, "condition")) {
[16:19:18.582]                         if (!is.null(pattern)) {
[16:19:18.582]                           computeRestarts <- base::computeRestarts
[16:19:18.582]                           grepl <- base::grepl
[16:19:18.582]                           restarts <- computeRestarts(cond)
[16:19:18.582]                           for (restart in restarts) {
[16:19:18.582]                             name <- restart$name
[16:19:18.582]                             if (is.null(name)) 
[16:19:18.582]                               next
[16:19:18.582]                             if (!grepl(pattern, name)) 
[16:19:18.582]                               next
[16:19:18.582]                             invokeRestart(restart)
[16:19:18.582]                             muffled <- TRUE
[16:19:18.582]                             break
[16:19:18.582]                           }
[16:19:18.582]                         }
[16:19:18.582]                       }
[16:19:18.582]                       invisible(muffled)
[16:19:18.582]                     }
[16:19:18.582]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.582]                   }
[16:19:18.582]                 }
[16:19:18.582]                 else {
[16:19:18.582]                   if (TRUE) {
[16:19:18.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.582]                     {
[16:19:18.582]                       inherits <- base::inherits
[16:19:18.582]                       invokeRestart <- base::invokeRestart
[16:19:18.582]                       is.null <- base::is.null
[16:19:18.582]                       muffled <- FALSE
[16:19:18.582]                       if (inherits(cond, "message")) {
[16:19:18.582]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.582]                         if (muffled) 
[16:19:18.582]                           invokeRestart("muffleMessage")
[16:19:18.582]                       }
[16:19:18.582]                       else if (inherits(cond, "warning")) {
[16:19:18.582]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.582]                         if (muffled) 
[16:19:18.582]                           invokeRestart("muffleWarning")
[16:19:18.582]                       }
[16:19:18.582]                       else if (inherits(cond, "condition")) {
[16:19:18.582]                         if (!is.null(pattern)) {
[16:19:18.582]                           computeRestarts <- base::computeRestarts
[16:19:18.582]                           grepl <- base::grepl
[16:19:18.582]                           restarts <- computeRestarts(cond)
[16:19:18.582]                           for (restart in restarts) {
[16:19:18.582]                             name <- restart$name
[16:19:18.582]                             if (is.null(name)) 
[16:19:18.582]                               next
[16:19:18.582]                             if (!grepl(pattern, name)) 
[16:19:18.582]                               next
[16:19:18.582]                             invokeRestart(restart)
[16:19:18.582]                             muffled <- TRUE
[16:19:18.582]                             break
[16:19:18.582]                           }
[16:19:18.582]                         }
[16:19:18.582]                       }
[16:19:18.582]                       invisible(muffled)
[16:19:18.582]                     }
[16:19:18.582]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.582]                   }
[16:19:18.582]                 }
[16:19:18.582]             }
[16:19:18.582]         }))
[16:19:18.582]     }, error = function(ex) {
[16:19:18.582]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:18.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.582]                 ...future.rng), started = ...future.startTime, 
[16:19:18.582]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:18.582]             version = "1.8"), class = "FutureResult")
[16:19:18.582]     }, finally = {
[16:19:18.582]         if (!identical(...future.workdir, getwd())) 
[16:19:18.582]             setwd(...future.workdir)
[16:19:18.582]         {
[16:19:18.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:18.582]                 ...future.oldOptions$nwarnings <- NULL
[16:19:18.582]             }
[16:19:18.582]             base::options(...future.oldOptions)
[16:19:18.582]             if (.Platform$OS.type == "windows") {
[16:19:18.582]                 old_names <- names(...future.oldEnvVars)
[16:19:18.582]                 envs <- base::Sys.getenv()
[16:19:18.582]                 names <- names(envs)
[16:19:18.582]                 common <- intersect(names, old_names)
[16:19:18.582]                 added <- setdiff(names, old_names)
[16:19:18.582]                 removed <- setdiff(old_names, names)
[16:19:18.582]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:18.582]                   envs[common]]
[16:19:18.582]                 NAMES <- toupper(changed)
[16:19:18.582]                 args <- list()
[16:19:18.582]                 for (kk in seq_along(NAMES)) {
[16:19:18.582]                   name <- changed[[kk]]
[16:19:18.582]                   NAME <- NAMES[[kk]]
[16:19:18.582]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.582]                     next
[16:19:18.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.582]                 }
[16:19:18.582]                 NAMES <- toupper(added)
[16:19:18.582]                 for (kk in seq_along(NAMES)) {
[16:19:18.582]                   name <- added[[kk]]
[16:19:18.582]                   NAME <- NAMES[[kk]]
[16:19:18.582]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.582]                     next
[16:19:18.582]                   args[[name]] <- ""
[16:19:18.582]                 }
[16:19:18.582]                 NAMES <- toupper(removed)
[16:19:18.582]                 for (kk in seq_along(NAMES)) {
[16:19:18.582]                   name <- removed[[kk]]
[16:19:18.582]                   NAME <- NAMES[[kk]]
[16:19:18.582]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.582]                     next
[16:19:18.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.582]                 }
[16:19:18.582]                 if (length(args) > 0) 
[16:19:18.582]                   base::do.call(base::Sys.setenv, args = args)
[16:19:18.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:18.582]             }
[16:19:18.582]             else {
[16:19:18.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:18.582]             }
[16:19:18.582]             {
[16:19:18.582]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:18.582]                   0L) {
[16:19:18.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:18.582]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:18.582]                   base::options(opts)
[16:19:18.582]                 }
[16:19:18.582]                 {
[16:19:18.582]                   {
[16:19:18.582]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:18.582]                     NULL
[16:19:18.582]                   }
[16:19:18.582]                   options(future.plan = NULL)
[16:19:18.582]                   if (is.na(NA_character_)) 
[16:19:18.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:18.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:18.582]                     .init = FALSE)
[16:19:18.582]                 }
[16:19:18.582]             }
[16:19:18.582]         }
[16:19:18.582]     })
[16:19:18.582]     if (TRUE) {
[16:19:18.582]         base::sink(type = "output", split = FALSE)
[16:19:18.582]         if (TRUE) {
[16:19:18.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:18.582]         }
[16:19:18.582]         else {
[16:19:18.582]             ...future.result["stdout"] <- base::list(NULL)
[16:19:18.582]         }
[16:19:18.582]         base::close(...future.stdout)
[16:19:18.582]         ...future.stdout <- NULL
[16:19:18.582]     }
[16:19:18.582]     ...future.result$conditions <- ...future.conditions
[16:19:18.582]     ...future.result$finished <- base::Sys.time()
[16:19:18.582]     ...future.result
[16:19:18.582] }
[16:19:18.585] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[16:19:18.585] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:18.629] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:18.629] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[16:19:18.629] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[16:19:18.630] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:18.630] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:18.630] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:18.673] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:18.673] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:18.717] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:18.717] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:19:18.717] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:19:18.718] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:18.718] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:18.718] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:18.719] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.719] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:18.719] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:18.719] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:18.720] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.720] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:18.720] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:18.720] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[16:19:18.721] MultisessionFuture started
[16:19:18.721] - Launch lazy future ... done
[16:19:18.721] run() for ‘MultisessionFuture’ ... done
[16:19:18.722] Created future:
[16:19:18.722] MultisessionFuture:
[16:19:18.722] Label: ‘future_vapply-1’
[16:19:18.722] Expression:
[16:19:18.722] {
[16:19:18.722]     do.call(function(...) {
[16:19:18.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.722]             on.exit(options(oopts), add = TRUE)
[16:19:18.722]         }
[16:19:18.722]         {
[16:19:18.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.722]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.722]             })
[16:19:18.722]         }
[16:19:18.722]     }, args = future.call.arguments)
[16:19:18.722] }
[16:19:18.722] Lazy evaluation: FALSE
[16:19:18.722] Asynchronous evaluation: TRUE
[16:19:18.722] Local evaluation: TRUE
[16:19:18.722] Environment: R_GlobalEnv
[16:19:18.722] Capture standard output: TRUE
[16:19:18.722] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:18.722] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:18.722] Packages: 1 packages (‘future.apply’)
[16:19:18.722] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:18.722] Resolved: FALSE
[16:19:18.722] Value: <not collected>
[16:19:18.722] Conditions captured: <none>
[16:19:18.722] Early signaling: FALSE
[16:19:18.722] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:18.722] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.734] Chunk #1 of 2 ... DONE
[16:19:18.734] Chunk #2 of 2 ...
[16:19:18.734]  - Finding globals in 'X' for chunk #2 ...
[16:19:18.734] getGlobalsAndPackages() ...
[16:19:18.734] Searching for globals...
[16:19:18.734] 
[16:19:18.735] Searching for globals ... DONE
[16:19:18.735] - globals: [0] <none>
[16:19:18.735] getGlobalsAndPackages() ... DONE
[16:19:18.735]    + additional globals found: [n=0] 
[16:19:18.735]    + additional namespaces needed: [n=0] 
[16:19:18.735]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:18.735]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:18.735]  - seeds: <none>
[16:19:18.735]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.735] getGlobalsAndPackages() ...
[16:19:18.735] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.736] Resolving globals: FALSE
[16:19:18.736] Tweak future expression to call with '...' arguments ...
[16:19:18.736] {
[16:19:18.736]     do.call(function(...) {
[16:19:18.736]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.736]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.736]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.736]             on.exit(options(oopts), add = TRUE)
[16:19:18.736]         }
[16:19:18.736]         {
[16:19:18.736]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.736]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.736]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.736]             })
[16:19:18.736]         }
[16:19:18.736]     }, args = future.call.arguments)
[16:19:18.736] }
[16:19:18.736] Tweak future expression to call with '...' arguments ... DONE
[16:19:18.737] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.737] - packages: [1] ‘future.apply’
[16:19:18.737] getGlobalsAndPackages() ... DONE
[16:19:18.737] run() for ‘Future’ ...
[16:19:18.737] - state: ‘created’
[16:19:18.737] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:18.752] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.752] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:18.752]   - Field: ‘node’
[16:19:18.752]   - Field: ‘label’
[16:19:18.753]   - Field: ‘local’
[16:19:18.753]   - Field: ‘owner’
[16:19:18.753]   - Field: ‘envir’
[16:19:18.753]   - Field: ‘workers’
[16:19:18.753]   - Field: ‘packages’
[16:19:18.753]   - Field: ‘gc’
[16:19:18.753]   - Field: ‘conditions’
[16:19:18.753]   - Field: ‘persistent’
[16:19:18.753]   - Field: ‘expr’
[16:19:18.753]   - Field: ‘uuid’
[16:19:18.754]   - Field: ‘seed’
[16:19:18.754]   - Field: ‘version’
[16:19:18.754]   - Field: ‘result’
[16:19:18.754]   - Field: ‘asynchronous’
[16:19:18.754]   - Field: ‘calls’
[16:19:18.754]   - Field: ‘globals’
[16:19:18.754]   - Field: ‘stdout’
[16:19:18.754]   - Field: ‘earlySignal’
[16:19:18.754]   - Field: ‘lazy’
[16:19:18.754]   - Field: ‘state’
[16:19:18.754] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:18.755] - Launch lazy future ...
[16:19:18.755] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:18.755] Packages needed by future strategies (n = 0): <none>
[16:19:18.756] {
[16:19:18.756]     {
[16:19:18.756]         {
[16:19:18.756]             ...future.startTime <- base::Sys.time()
[16:19:18.756]             {
[16:19:18.756]                 {
[16:19:18.756]                   {
[16:19:18.756]                     {
[16:19:18.756]                       {
[16:19:18.756]                         base::local({
[16:19:18.756]                           has_future <- base::requireNamespace("future", 
[16:19:18.756]                             quietly = TRUE)
[16:19:18.756]                           if (has_future) {
[16:19:18.756]                             ns <- base::getNamespace("future")
[16:19:18.756]                             version <- ns[[".package"]][["version"]]
[16:19:18.756]                             if (is.null(version)) 
[16:19:18.756]                               version <- utils::packageVersion("future")
[16:19:18.756]                           }
[16:19:18.756]                           else {
[16:19:18.756]                             version <- NULL
[16:19:18.756]                           }
[16:19:18.756]                           if (!has_future || version < "1.8.0") {
[16:19:18.756]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:18.756]                               "", base::R.version$version.string), 
[16:19:18.756]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:18.756]                                 base::R.version$platform, 8 * 
[16:19:18.756]                                   base::.Machine$sizeof.pointer), 
[16:19:18.756]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:18.756]                                 "release", "version")], collapse = " "), 
[16:19:18.756]                               hostname = base::Sys.info()[["nodename"]])
[16:19:18.756]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:18.756]                               info)
[16:19:18.756]                             info <- base::paste(info, collapse = "; ")
[16:19:18.756]                             if (!has_future) {
[16:19:18.756]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:18.756]                                 info)
[16:19:18.756]                             }
[16:19:18.756]                             else {
[16:19:18.756]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:18.756]                                 info, version)
[16:19:18.756]                             }
[16:19:18.756]                             base::stop(msg)
[16:19:18.756]                           }
[16:19:18.756]                         })
[16:19:18.756]                       }
[16:19:18.756]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:18.756]                       base::options(mc.cores = 1L)
[16:19:18.756]                     }
[16:19:18.756]                     base::local({
[16:19:18.756]                       for (pkg in "future.apply") {
[16:19:18.756]                         base::loadNamespace(pkg)
[16:19:18.756]                         base::library(pkg, character.only = TRUE)
[16:19:18.756]                       }
[16:19:18.756]                     })
[16:19:18.756]                   }
[16:19:18.756]                   ...future.strategy.old <- future::plan("list")
[16:19:18.756]                   options(future.plan = NULL)
[16:19:18.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:18.756]                 }
[16:19:18.756]                 ...future.workdir <- getwd()
[16:19:18.756]             }
[16:19:18.756]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:18.756]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:18.756]         }
[16:19:18.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:18.756]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:18.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:18.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:18.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:18.756]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:18.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:18.756]             base::names(...future.oldOptions))
[16:19:18.756]     }
[16:19:18.756]     if (FALSE) {
[16:19:18.756]     }
[16:19:18.756]     else {
[16:19:18.756]         if (TRUE) {
[16:19:18.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:18.756]                 open = "w")
[16:19:18.756]         }
[16:19:18.756]         else {
[16:19:18.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:18.756]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:18.756]         }
[16:19:18.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:18.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:18.756]             base::sink(type = "output", split = FALSE)
[16:19:18.756]             base::close(...future.stdout)
[16:19:18.756]         }, add = TRUE)
[16:19:18.756]     }
[16:19:18.756]     ...future.frame <- base::sys.nframe()
[16:19:18.756]     ...future.conditions <- base::list()
[16:19:18.756]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:18.756]     if (FALSE) {
[16:19:18.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:18.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:18.756]     }
[16:19:18.756]     ...future.result <- base::tryCatch({
[16:19:18.756]         base::withCallingHandlers({
[16:19:18.756]             ...future.value <- base::withVisible(base::local({
[16:19:18.756]                 ...future.makeSendCondition <- base::local({
[16:19:18.756]                   sendCondition <- NULL
[16:19:18.756]                   function(frame = 1L) {
[16:19:18.756]                     if (is.function(sendCondition)) 
[16:19:18.756]                       return(sendCondition)
[16:19:18.756]                     ns <- getNamespace("parallel")
[16:19:18.756]                     if (exists("sendData", mode = "function", 
[16:19:18.756]                       envir = ns)) {
[16:19:18.756]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:18.756]                         envir = ns)
[16:19:18.756]                       envir <- sys.frame(frame)
[16:19:18.756]                       master <- NULL
[16:19:18.756]                       while (!identical(envir, .GlobalEnv) && 
[16:19:18.756]                         !identical(envir, emptyenv())) {
[16:19:18.756]                         if (exists("master", mode = "list", envir = envir, 
[16:19:18.756]                           inherits = FALSE)) {
[16:19:18.756]                           master <- get("master", mode = "list", 
[16:19:18.756]                             envir = envir, inherits = FALSE)
[16:19:18.756]                           if (inherits(master, c("SOCKnode", 
[16:19:18.756]                             "SOCK0node"))) {
[16:19:18.756]                             sendCondition <<- function(cond) {
[16:19:18.756]                               data <- list(type = "VALUE", value = cond, 
[16:19:18.756]                                 success = TRUE)
[16:19:18.756]                               parallel_sendData(master, data)
[16:19:18.756]                             }
[16:19:18.756]                             return(sendCondition)
[16:19:18.756]                           }
[16:19:18.756]                         }
[16:19:18.756]                         frame <- frame + 1L
[16:19:18.756]                         envir <- sys.frame(frame)
[16:19:18.756]                       }
[16:19:18.756]                     }
[16:19:18.756]                     sendCondition <<- function(cond) NULL
[16:19:18.756]                   }
[16:19:18.756]                 })
[16:19:18.756]                 withCallingHandlers({
[16:19:18.756]                   {
[16:19:18.756]                     do.call(function(...) {
[16:19:18.756]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.756]                       if (!identical(...future.globals.maxSize.org, 
[16:19:18.756]                         ...future.globals.maxSize)) {
[16:19:18.756]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.756]                         on.exit(options(oopts), add = TRUE)
[16:19:18.756]                       }
[16:19:18.756]                       {
[16:19:18.756]                         lapply(seq_along(...future.elements_ii), 
[16:19:18.756]                           FUN = function(jj) {
[16:19:18.756]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.756]                             ...future.FUN(...future.X_jj, ...)
[16:19:18.756]                           })
[16:19:18.756]                       }
[16:19:18.756]                     }, args = future.call.arguments)
[16:19:18.756]                   }
[16:19:18.756]                 }, immediateCondition = function(cond) {
[16:19:18.756]                   sendCondition <- ...future.makeSendCondition()
[16:19:18.756]                   sendCondition(cond)
[16:19:18.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.756]                   {
[16:19:18.756]                     inherits <- base::inherits
[16:19:18.756]                     invokeRestart <- base::invokeRestart
[16:19:18.756]                     is.null <- base::is.null
[16:19:18.756]                     muffled <- FALSE
[16:19:18.756]                     if (inherits(cond, "message")) {
[16:19:18.756]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:18.756]                       if (muffled) 
[16:19:18.756]                         invokeRestart("muffleMessage")
[16:19:18.756]                     }
[16:19:18.756]                     else if (inherits(cond, "warning")) {
[16:19:18.756]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:18.756]                       if (muffled) 
[16:19:18.756]                         invokeRestart("muffleWarning")
[16:19:18.756]                     }
[16:19:18.756]                     else if (inherits(cond, "condition")) {
[16:19:18.756]                       if (!is.null(pattern)) {
[16:19:18.756]                         computeRestarts <- base::computeRestarts
[16:19:18.756]                         grepl <- base::grepl
[16:19:18.756]                         restarts <- computeRestarts(cond)
[16:19:18.756]                         for (restart in restarts) {
[16:19:18.756]                           name <- restart$name
[16:19:18.756]                           if (is.null(name)) 
[16:19:18.756]                             next
[16:19:18.756]                           if (!grepl(pattern, name)) 
[16:19:18.756]                             next
[16:19:18.756]                           invokeRestart(restart)
[16:19:18.756]                           muffled <- TRUE
[16:19:18.756]                           break
[16:19:18.756]                         }
[16:19:18.756]                       }
[16:19:18.756]                     }
[16:19:18.756]                     invisible(muffled)
[16:19:18.756]                   }
[16:19:18.756]                   muffleCondition(cond)
[16:19:18.756]                 })
[16:19:18.756]             }))
[16:19:18.756]             future::FutureResult(value = ...future.value$value, 
[16:19:18.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.756]                   ...future.rng), globalenv = if (FALSE) 
[16:19:18.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:18.756]                     ...future.globalenv.names))
[16:19:18.756]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:18.756]         }, condition = base::local({
[16:19:18.756]             c <- base::c
[16:19:18.756]             inherits <- base::inherits
[16:19:18.756]             invokeRestart <- base::invokeRestart
[16:19:18.756]             length <- base::length
[16:19:18.756]             list <- base::list
[16:19:18.756]             seq.int <- base::seq.int
[16:19:18.756]             signalCondition <- base::signalCondition
[16:19:18.756]             sys.calls <- base::sys.calls
[16:19:18.756]             `[[` <- base::`[[`
[16:19:18.756]             `+` <- base::`+`
[16:19:18.756]             `<<-` <- base::`<<-`
[16:19:18.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:18.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:18.756]                   3L)]
[16:19:18.756]             }
[16:19:18.756]             function(cond) {
[16:19:18.756]                 is_error <- inherits(cond, "error")
[16:19:18.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:18.756]                   NULL)
[16:19:18.756]                 if (is_error) {
[16:19:18.756]                   sessionInformation <- function() {
[16:19:18.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:18.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:18.756]                       search = base::search(), system = base::Sys.info())
[16:19:18.756]                   }
[16:19:18.756]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:18.756]                     cond$call), session = sessionInformation(), 
[16:19:18.756]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:18.756]                   signalCondition(cond)
[16:19:18.756]                 }
[16:19:18.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:18.756]                 "immediateCondition"))) {
[16:19:18.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:18.756]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:18.756]                   if (TRUE && !signal) {
[16:19:18.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.756]                     {
[16:19:18.756]                       inherits <- base::inherits
[16:19:18.756]                       invokeRestart <- base::invokeRestart
[16:19:18.756]                       is.null <- base::is.null
[16:19:18.756]                       muffled <- FALSE
[16:19:18.756]                       if (inherits(cond, "message")) {
[16:19:18.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.756]                         if (muffled) 
[16:19:18.756]                           invokeRestart("muffleMessage")
[16:19:18.756]                       }
[16:19:18.756]                       else if (inherits(cond, "warning")) {
[16:19:18.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.756]                         if (muffled) 
[16:19:18.756]                           invokeRestart("muffleWarning")
[16:19:18.756]                       }
[16:19:18.756]                       else if (inherits(cond, "condition")) {
[16:19:18.756]                         if (!is.null(pattern)) {
[16:19:18.756]                           computeRestarts <- base::computeRestarts
[16:19:18.756]                           grepl <- base::grepl
[16:19:18.756]                           restarts <- computeRestarts(cond)
[16:19:18.756]                           for (restart in restarts) {
[16:19:18.756]                             name <- restart$name
[16:19:18.756]                             if (is.null(name)) 
[16:19:18.756]                               next
[16:19:18.756]                             if (!grepl(pattern, name)) 
[16:19:18.756]                               next
[16:19:18.756]                             invokeRestart(restart)
[16:19:18.756]                             muffled <- TRUE
[16:19:18.756]                             break
[16:19:18.756]                           }
[16:19:18.756]                         }
[16:19:18.756]                       }
[16:19:18.756]                       invisible(muffled)
[16:19:18.756]                     }
[16:19:18.756]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.756]                   }
[16:19:18.756]                 }
[16:19:18.756]                 else {
[16:19:18.756]                   if (TRUE) {
[16:19:18.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.756]                     {
[16:19:18.756]                       inherits <- base::inherits
[16:19:18.756]                       invokeRestart <- base::invokeRestart
[16:19:18.756]                       is.null <- base::is.null
[16:19:18.756]                       muffled <- FALSE
[16:19:18.756]                       if (inherits(cond, "message")) {
[16:19:18.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.756]                         if (muffled) 
[16:19:18.756]                           invokeRestart("muffleMessage")
[16:19:18.756]                       }
[16:19:18.756]                       else if (inherits(cond, "warning")) {
[16:19:18.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.756]                         if (muffled) 
[16:19:18.756]                           invokeRestart("muffleWarning")
[16:19:18.756]                       }
[16:19:18.756]                       else if (inherits(cond, "condition")) {
[16:19:18.756]                         if (!is.null(pattern)) {
[16:19:18.756]                           computeRestarts <- base::computeRestarts
[16:19:18.756]                           grepl <- base::grepl
[16:19:18.756]                           restarts <- computeRestarts(cond)
[16:19:18.756]                           for (restart in restarts) {
[16:19:18.756]                             name <- restart$name
[16:19:18.756]                             if (is.null(name)) 
[16:19:18.756]                               next
[16:19:18.756]                             if (!grepl(pattern, name)) 
[16:19:18.756]                               next
[16:19:18.756]                             invokeRestart(restart)
[16:19:18.756]                             muffled <- TRUE
[16:19:18.756]                             break
[16:19:18.756]                           }
[16:19:18.756]                         }
[16:19:18.756]                       }
[16:19:18.756]                       invisible(muffled)
[16:19:18.756]                     }
[16:19:18.756]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.756]                   }
[16:19:18.756]                 }
[16:19:18.756]             }
[16:19:18.756]         }))
[16:19:18.756]     }, error = function(ex) {
[16:19:18.756]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:18.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.756]                 ...future.rng), started = ...future.startTime, 
[16:19:18.756]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:18.756]             version = "1.8"), class = "FutureResult")
[16:19:18.756]     }, finally = {
[16:19:18.756]         if (!identical(...future.workdir, getwd())) 
[16:19:18.756]             setwd(...future.workdir)
[16:19:18.756]         {
[16:19:18.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:18.756]                 ...future.oldOptions$nwarnings <- NULL
[16:19:18.756]             }
[16:19:18.756]             base::options(...future.oldOptions)
[16:19:18.756]             if (.Platform$OS.type == "windows") {
[16:19:18.756]                 old_names <- names(...future.oldEnvVars)
[16:19:18.756]                 envs <- base::Sys.getenv()
[16:19:18.756]                 names <- names(envs)
[16:19:18.756]                 common <- intersect(names, old_names)
[16:19:18.756]                 added <- setdiff(names, old_names)
[16:19:18.756]                 removed <- setdiff(old_names, names)
[16:19:18.756]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:18.756]                   envs[common]]
[16:19:18.756]                 NAMES <- toupper(changed)
[16:19:18.756]                 args <- list()
[16:19:18.756]                 for (kk in seq_along(NAMES)) {
[16:19:18.756]                   name <- changed[[kk]]
[16:19:18.756]                   NAME <- NAMES[[kk]]
[16:19:18.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.756]                     next
[16:19:18.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.756]                 }
[16:19:18.756]                 NAMES <- toupper(added)
[16:19:18.756]                 for (kk in seq_along(NAMES)) {
[16:19:18.756]                   name <- added[[kk]]
[16:19:18.756]                   NAME <- NAMES[[kk]]
[16:19:18.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.756]                     next
[16:19:18.756]                   args[[name]] <- ""
[16:19:18.756]                 }
[16:19:18.756]                 NAMES <- toupper(removed)
[16:19:18.756]                 for (kk in seq_along(NAMES)) {
[16:19:18.756]                   name <- removed[[kk]]
[16:19:18.756]                   NAME <- NAMES[[kk]]
[16:19:18.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.756]                     next
[16:19:18.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.756]                 }
[16:19:18.756]                 if (length(args) > 0) 
[16:19:18.756]                   base::do.call(base::Sys.setenv, args = args)
[16:19:18.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:18.756]             }
[16:19:18.756]             else {
[16:19:18.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:18.756]             }
[16:19:18.756]             {
[16:19:18.756]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:18.756]                   0L) {
[16:19:18.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:18.756]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:18.756]                   base::options(opts)
[16:19:18.756]                 }
[16:19:18.756]                 {
[16:19:18.756]                   {
[16:19:18.756]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:18.756]                     NULL
[16:19:18.756]                   }
[16:19:18.756]                   options(future.plan = NULL)
[16:19:18.756]                   if (is.na(NA_character_)) 
[16:19:18.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:18.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:18.756]                     .init = FALSE)
[16:19:18.756]                 }
[16:19:18.756]             }
[16:19:18.756]         }
[16:19:18.756]     })
[16:19:18.756]     if (TRUE) {
[16:19:18.756]         base::sink(type = "output", split = FALSE)
[16:19:18.756]         if (TRUE) {
[16:19:18.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:18.756]         }
[16:19:18.756]         else {
[16:19:18.756]             ...future.result["stdout"] <- base::list(NULL)
[16:19:18.756]         }
[16:19:18.756]         base::close(...future.stdout)
[16:19:18.756]         ...future.stdout <- NULL
[16:19:18.756]     }
[16:19:18.756]     ...future.result$conditions <- ...future.conditions
[16:19:18.756]     ...future.result$finished <- base::Sys.time()
[16:19:18.756]     ...future.result
[16:19:18.756] }
[16:19:18.759] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[16:19:18.759] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:19:18.801] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:19:18.801] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[16:19:18.801] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[16:19:18.802] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:19:18.802] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:19:18.802] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:19:18.844] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:19:18.845] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:19:18.888] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:19:18.889] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:19:18.889] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:19:18.889] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:19:18.890] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:19:18.890] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:18.890] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:18.890] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:19:18.891] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:19:18.891] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:18.891] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:18.891] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:18.892] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:18.892] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[16:19:18.892] MultisessionFuture started
[16:19:18.893] - Launch lazy future ... done
[16:19:18.893] run() for ‘MultisessionFuture’ ... done
[16:19:18.893] Created future:
[16:19:18.893] MultisessionFuture:
[16:19:18.893] Label: ‘future_vapply-2’
[16:19:18.893] Expression:
[16:19:18.893] {
[16:19:18.893]     do.call(function(...) {
[16:19:18.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.893]             on.exit(options(oopts), add = TRUE)
[16:19:18.893]         }
[16:19:18.893]         {
[16:19:18.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.893]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.893]             })
[16:19:18.893]         }
[16:19:18.893]     }, args = future.call.arguments)
[16:19:18.893] }
[16:19:18.893] Lazy evaluation: FALSE
[16:19:18.893] Asynchronous evaluation: TRUE
[16:19:18.893] Local evaluation: TRUE
[16:19:18.893] Environment: R_GlobalEnv
[16:19:18.893] Capture standard output: TRUE
[16:19:18.893] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:18.893] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:18.893] Packages: 1 packages (‘future.apply’)
[16:19:18.893] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:18.893] Resolved: FALSE
[16:19:18.893] Value: <not collected>
[16:19:18.893] Conditions captured: <none>
[16:19:18.893] Early signaling: FALSE
[16:19:18.893] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:18.893] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.905] Chunk #2 of 2 ... DONE
[16:19:18.905] Launching 2 futures (chunks) ... DONE
[16:19:18.905] Resolving 2 futures (chunks) ...
[16:19:18.905] resolve() on list ...
[16:19:18.905]  recursive: 0
[16:19:18.905]  length: 2
[16:19:18.905] 
[16:19:18.906] receiveMessageFromWorker() for ClusterFuture ...
[16:19:18.906] - Validating connection of MultisessionFuture
[16:19:18.906] - received message: FutureResult
[16:19:18.906] - Received FutureResult
[16:19:18.906] - Erased future from FutureRegistry
[16:19:18.907] result() for ClusterFuture ...
[16:19:18.907] - result already collected: FutureResult
[16:19:18.907] result() for ClusterFuture ... done
[16:19:18.907] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:18.907] Future #1
[16:19:18.907] result() for ClusterFuture ...
[16:19:18.907] - result already collected: FutureResult
[16:19:18.907] result() for ClusterFuture ... done
[16:19:18.907] result() for ClusterFuture ...
[16:19:18.907] - result already collected: FutureResult
[16:19:18.907] result() for ClusterFuture ... done
[16:19:18.908] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:18.908] - nx: 2
[16:19:18.908] - relay: TRUE
[16:19:18.908] - stdout: TRUE
[16:19:18.908] - signal: TRUE
[16:19:18.908] - resignal: FALSE
[16:19:18.908] - force: TRUE
[16:19:18.908] - relayed: [n=2] FALSE, FALSE
[16:19:18.908] - queued futures: [n=2] FALSE, FALSE
[16:19:18.908]  - until=1
[16:19:18.908]  - relaying element #1
[16:19:18.909] result() for ClusterFuture ...
[16:19:18.909] - result already collected: FutureResult
[16:19:18.909] result() for ClusterFuture ... done
[16:19:18.909] result() for ClusterFuture ...
[16:19:18.909] - result already collected: FutureResult
[16:19:18.909] result() for ClusterFuture ... done
[16:19:18.909] result() for ClusterFuture ...
[16:19:18.909] - result already collected: FutureResult
[16:19:18.909] result() for ClusterFuture ... done
[16:19:18.909] result() for ClusterFuture ...
[16:19:18.909] - result already collected: FutureResult
[16:19:18.910] result() for ClusterFuture ... done
[16:19:18.910] - relayed: [n=2] TRUE, FALSE
[16:19:18.910] - queued futures: [n=2] TRUE, FALSE
[16:19:18.910] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:18.910]  length: 1 (resolved future 1)
[16:19:18.938] receiveMessageFromWorker() for ClusterFuture ...
[16:19:18.938] - Validating connection of MultisessionFuture
[16:19:18.938] - received message: FutureResult
[16:19:18.938] - Received FutureResult
[16:19:18.938] - Erased future from FutureRegistry
[16:19:18.939] result() for ClusterFuture ...
[16:19:18.939] - result already collected: FutureResult
[16:19:18.939] result() for ClusterFuture ... done
[16:19:18.939] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:18.939] Future #2
[16:19:18.939] result() for ClusterFuture ...
[16:19:18.939] - result already collected: FutureResult
[16:19:18.939] result() for ClusterFuture ... done
[16:19:18.939] result() for ClusterFuture ...
[16:19:18.939] - result already collected: FutureResult
[16:19:18.939] result() for ClusterFuture ... done
[16:19:18.940] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:18.940] - nx: 2
[16:19:18.940] - relay: TRUE
[16:19:18.940] - stdout: TRUE
[16:19:18.940] - signal: TRUE
[16:19:18.940] - resignal: FALSE
[16:19:18.940] - force: TRUE
[16:19:18.940] - relayed: [n=2] TRUE, FALSE
[16:19:18.940] - queued futures: [n=2] TRUE, FALSE
[16:19:18.940]  - until=2
[16:19:18.940]  - relaying element #2
[16:19:18.941] result() for ClusterFuture ...
[16:19:18.941] - result already collected: FutureResult
[16:19:18.941] result() for ClusterFuture ... done
[16:19:18.941] result() for ClusterFuture ...
[16:19:18.941] - result already collected: FutureResult
[16:19:18.941] result() for ClusterFuture ... done
[16:19:18.941] result() for ClusterFuture ...
[16:19:18.941] - result already collected: FutureResult
[16:19:18.941] result() for ClusterFuture ... done
[16:19:18.941] result() for ClusterFuture ...
[16:19:18.941] - result already collected: FutureResult
[16:19:18.942] result() for ClusterFuture ... done
[16:19:18.942] - relayed: [n=2] TRUE, TRUE
[16:19:18.942] - queued futures: [n=2] TRUE, TRUE
[16:19:18.942] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:18.942]  length: 0 (resolved future 2)
[16:19:18.942] Relaying remaining futures
[16:19:18.942] signalConditionsASAP(NULL, pos=0) ...
[16:19:18.942] - nx: 2
[16:19:18.942] - relay: TRUE
[16:19:18.942] - stdout: TRUE
[16:19:18.942] - signal: TRUE
[16:19:18.942] - resignal: FALSE
[16:19:18.943] - force: TRUE
[16:19:18.943] - relayed: [n=2] TRUE, TRUE
[16:19:18.943] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:18.943] - relayed: [n=2] TRUE, TRUE
[16:19:18.943] - queued futures: [n=2] TRUE, TRUE
[16:19:18.943] signalConditionsASAP(NULL, pos=0) ... done
[16:19:18.943] resolve() on list ... DONE
[16:19:18.943] result() for ClusterFuture ...
[16:19:18.943] - result already collected: FutureResult
[16:19:18.943] result() for ClusterFuture ... done
[16:19:18.943] result() for ClusterFuture ...
[16:19:18.944] - result already collected: FutureResult
[16:19:18.944] result() for ClusterFuture ... done
[16:19:18.944] result() for ClusterFuture ...
[16:19:18.944] - result already collected: FutureResult
[16:19:18.944] result() for ClusterFuture ... done
[16:19:18.944] result() for ClusterFuture ...
[16:19:18.944] - result already collected: FutureResult
[16:19:18.944] result() for ClusterFuture ... done
[16:19:18.944]  - Number of value chunks collected: 2
[16:19:18.944] Resolving 2 futures (chunks) ... DONE
[16:19:18.945] Reducing values from 2 chunks ...
[16:19:18.945]  - Number of values collected after concatenation: 10
[16:19:18.945]  - Number of values expected: 10
[16:19:18.945] Reducing values from 2 chunks ... DONE
[16:19:18.945] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:19:18.947] future_lapply() ...
[16:19:18.954] Number of chunks: 2
[16:19:18.955] getGlobalsAndPackagesXApply() ...
[16:19:18.955]  - future.globals: TRUE
[16:19:18.955] getGlobalsAndPackages() ...
[16:19:18.955] Searching for globals...
[16:19:18.961] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:19:18.961] Searching for globals ... DONE
[16:19:18.961] Resolving globals: FALSE
[16:19:18.962] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:19:18.962] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:18.963] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:18.963] - packages: [1] ‘future.apply’
[16:19:18.963] getGlobalsAndPackages() ... DONE
[16:19:18.963]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:18.963]  - needed namespaces: [n=1] ‘future.apply’
[16:19:18.963] Finding globals ... DONE
[16:19:18.963]  - use_args: TRUE
[16:19:18.963]  - Getting '...' globals ...
[16:19:18.964] resolve() on list ...
[16:19:18.964]  recursive: 0
[16:19:18.964]  length: 1
[16:19:18.964]  elements: ‘...’
[16:19:18.964]  length: 0 (resolved future 1)
[16:19:18.964] resolve() on list ... DONE
[16:19:18.964]    - '...' content: [n=0] 
[16:19:18.964] List of 1
[16:19:18.964]  $ ...: list()
[16:19:18.964]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:18.964]  - attr(*, "where")=List of 1
[16:19:18.964]   ..$ ...:<environment: 0x5619a14a0b28> 
[16:19:18.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:18.964]  - attr(*, "resolved")= logi TRUE
[16:19:18.964]  - attr(*, "total_size")= num NA
[16:19:18.967]  - Getting '...' globals ... DONE
[16:19:18.967] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:18.967] List of 8
[16:19:18.967]  $ ...future.FUN:function (x, ...)  
[16:19:18.967]  $ x_FUN        :function (x)  
[16:19:18.967]  $ times        : int 4
[16:19:18.967]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:18.967]  $ stop_if_not  :function (...)  
[16:19:18.967]  $ dim          : int [1:2] 2 2
[16:19:18.967]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:18.967]  $ ...          : list()
[16:19:18.967]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:18.967]  - attr(*, "where")=List of 8
[16:19:18.967]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:18.967]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:18.967]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:18.967]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:18.967]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:18.967]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:18.967]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:18.967]   ..$ ...          :<environment: 0x5619a14a0b28> 
[16:19:18.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:18.967]  - attr(*, "resolved")= logi FALSE
[16:19:18.967]  - attr(*, "total_size")= num 105552
[16:19:18.973] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:18.973] getGlobalsAndPackagesXApply() ... DONE
[16:19:18.973] Number of futures (= number of chunks): 2
[16:19:18.973] Launching 2 futures (chunks) ...
[16:19:18.973] Chunk #1 of 2 ...
[16:19:18.973]  - Finding globals in 'X' for chunk #1 ...
[16:19:18.973] getGlobalsAndPackages() ...
[16:19:18.973] Searching for globals...
[16:19:18.974] 
[16:19:18.974] Searching for globals ... DONE
[16:19:18.974] - globals: [0] <none>
[16:19:18.974] getGlobalsAndPackages() ... DONE
[16:19:18.974]    + additional globals found: [n=0] 
[16:19:18.974]    + additional namespaces needed: [n=0] 
[16:19:18.974]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:18.974]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:18.974]  - seeds: <none>
[16:19:18.975]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.975] getGlobalsAndPackages() ...
[16:19:18.975] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.975] Resolving globals: FALSE
[16:19:18.975] Tweak future expression to call with '...' arguments ...
[16:19:18.975] {
[16:19:18.975]     do.call(function(...) {
[16:19:18.975]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.975]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:18.975]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.975]             on.exit(options(oopts), add = TRUE)
[16:19:18.975]         }
[16:19:18.975]         {
[16:19:18.975]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:18.975]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.975]                 ...future.FUN(...future.X_jj, ...)
[16:19:18.975]             })
[16:19:18.975]         }
[16:19:18.975]     }, args = future.call.arguments)
[16:19:18.975] }
[16:19:18.975] Tweak future expression to call with '...' arguments ... DONE
[16:19:18.976] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:18.976] - packages: [1] ‘future.apply’
[16:19:18.976] getGlobalsAndPackages() ... DONE
[16:19:18.976] run() for ‘Future’ ...
[16:19:18.977] - state: ‘created’
[16:19:18.977] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:18.990] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:18.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:18.991]   - Field: ‘node’
[16:19:18.991]   - Field: ‘label’
[16:19:18.991]   - Field: ‘local’
[16:19:18.991]   - Field: ‘owner’
[16:19:18.991]   - Field: ‘envir’
[16:19:18.991]   - Field: ‘workers’
[16:19:18.991]   - Field: ‘packages’
[16:19:18.991]   - Field: ‘gc’
[16:19:18.991]   - Field: ‘conditions’
[16:19:18.992]   - Field: ‘persistent’
[16:19:18.992]   - Field: ‘expr’
[16:19:18.992]   - Field: ‘uuid’
[16:19:18.992]   - Field: ‘seed’
[16:19:18.992]   - Field: ‘version’
[16:19:18.992]   - Field: ‘result’
[16:19:18.992]   - Field: ‘asynchronous’
[16:19:18.992]   - Field: ‘calls’
[16:19:18.992]   - Field: ‘globals’
[16:19:18.992]   - Field: ‘stdout’
[16:19:18.992]   - Field: ‘earlySignal’
[16:19:18.993]   - Field: ‘lazy’
[16:19:18.993]   - Field: ‘state’
[16:19:18.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:18.993] - Launch lazy future ...
[16:19:18.993] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:18.993] Packages needed by future strategies (n = 0): <none>
[16:19:18.994] {
[16:19:18.994]     {
[16:19:18.994]         {
[16:19:18.994]             ...future.startTime <- base::Sys.time()
[16:19:18.994]             {
[16:19:18.994]                 {
[16:19:18.994]                   {
[16:19:18.994]                     {
[16:19:18.994]                       {
[16:19:18.994]                         base::local({
[16:19:18.994]                           has_future <- base::requireNamespace("future", 
[16:19:18.994]                             quietly = TRUE)
[16:19:18.994]                           if (has_future) {
[16:19:18.994]                             ns <- base::getNamespace("future")
[16:19:18.994]                             version <- ns[[".package"]][["version"]]
[16:19:18.994]                             if (is.null(version)) 
[16:19:18.994]                               version <- utils::packageVersion("future")
[16:19:18.994]                           }
[16:19:18.994]                           else {
[16:19:18.994]                             version <- NULL
[16:19:18.994]                           }
[16:19:18.994]                           if (!has_future || version < "1.8.0") {
[16:19:18.994]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:18.994]                               "", base::R.version$version.string), 
[16:19:18.994]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:18.994]                                 base::R.version$platform, 8 * 
[16:19:18.994]                                   base::.Machine$sizeof.pointer), 
[16:19:18.994]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:18.994]                                 "release", "version")], collapse = " "), 
[16:19:18.994]                               hostname = base::Sys.info()[["nodename"]])
[16:19:18.994]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:18.994]                               info)
[16:19:18.994]                             info <- base::paste(info, collapse = "; ")
[16:19:18.994]                             if (!has_future) {
[16:19:18.994]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:18.994]                                 info)
[16:19:18.994]                             }
[16:19:18.994]                             else {
[16:19:18.994]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:18.994]                                 info, version)
[16:19:18.994]                             }
[16:19:18.994]                             base::stop(msg)
[16:19:18.994]                           }
[16:19:18.994]                         })
[16:19:18.994]                       }
[16:19:18.994]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:18.994]                       base::options(mc.cores = 1L)
[16:19:18.994]                     }
[16:19:18.994]                     base::local({
[16:19:18.994]                       for (pkg in "future.apply") {
[16:19:18.994]                         base::loadNamespace(pkg)
[16:19:18.994]                         base::library(pkg, character.only = TRUE)
[16:19:18.994]                       }
[16:19:18.994]                     })
[16:19:18.994]                   }
[16:19:18.994]                   ...future.strategy.old <- future::plan("list")
[16:19:18.994]                   options(future.plan = NULL)
[16:19:18.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:18.994]                 }
[16:19:18.994]                 ...future.workdir <- getwd()
[16:19:18.994]             }
[16:19:18.994]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:18.994]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:18.994]         }
[16:19:18.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:18.994]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:18.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:18.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:18.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:18.994]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:18.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:18.994]             base::names(...future.oldOptions))
[16:19:18.994]     }
[16:19:18.994]     if (FALSE) {
[16:19:18.994]     }
[16:19:18.994]     else {
[16:19:18.994]         if (TRUE) {
[16:19:18.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:18.994]                 open = "w")
[16:19:18.994]         }
[16:19:18.994]         else {
[16:19:18.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:18.994]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:18.994]         }
[16:19:18.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:18.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:18.994]             base::sink(type = "output", split = FALSE)
[16:19:18.994]             base::close(...future.stdout)
[16:19:18.994]         }, add = TRUE)
[16:19:18.994]     }
[16:19:18.994]     ...future.frame <- base::sys.nframe()
[16:19:18.994]     ...future.conditions <- base::list()
[16:19:18.994]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:18.994]     if (FALSE) {
[16:19:18.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:18.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:18.994]     }
[16:19:18.994]     ...future.result <- base::tryCatch({
[16:19:18.994]         base::withCallingHandlers({
[16:19:18.994]             ...future.value <- base::withVisible(base::local({
[16:19:18.994]                 ...future.makeSendCondition <- base::local({
[16:19:18.994]                   sendCondition <- NULL
[16:19:18.994]                   function(frame = 1L) {
[16:19:18.994]                     if (is.function(sendCondition)) 
[16:19:18.994]                       return(sendCondition)
[16:19:18.994]                     ns <- getNamespace("parallel")
[16:19:18.994]                     if (exists("sendData", mode = "function", 
[16:19:18.994]                       envir = ns)) {
[16:19:18.994]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:18.994]                         envir = ns)
[16:19:18.994]                       envir <- sys.frame(frame)
[16:19:18.994]                       master <- NULL
[16:19:18.994]                       while (!identical(envir, .GlobalEnv) && 
[16:19:18.994]                         !identical(envir, emptyenv())) {
[16:19:18.994]                         if (exists("master", mode = "list", envir = envir, 
[16:19:18.994]                           inherits = FALSE)) {
[16:19:18.994]                           master <- get("master", mode = "list", 
[16:19:18.994]                             envir = envir, inherits = FALSE)
[16:19:18.994]                           if (inherits(master, c("SOCKnode", 
[16:19:18.994]                             "SOCK0node"))) {
[16:19:18.994]                             sendCondition <<- function(cond) {
[16:19:18.994]                               data <- list(type = "VALUE", value = cond, 
[16:19:18.994]                                 success = TRUE)
[16:19:18.994]                               parallel_sendData(master, data)
[16:19:18.994]                             }
[16:19:18.994]                             return(sendCondition)
[16:19:18.994]                           }
[16:19:18.994]                         }
[16:19:18.994]                         frame <- frame + 1L
[16:19:18.994]                         envir <- sys.frame(frame)
[16:19:18.994]                       }
[16:19:18.994]                     }
[16:19:18.994]                     sendCondition <<- function(cond) NULL
[16:19:18.994]                   }
[16:19:18.994]                 })
[16:19:18.994]                 withCallingHandlers({
[16:19:18.994]                   {
[16:19:18.994]                     do.call(function(...) {
[16:19:18.994]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:18.994]                       if (!identical(...future.globals.maxSize.org, 
[16:19:18.994]                         ...future.globals.maxSize)) {
[16:19:18.994]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:18.994]                         on.exit(options(oopts), add = TRUE)
[16:19:18.994]                       }
[16:19:18.994]                       {
[16:19:18.994]                         lapply(seq_along(...future.elements_ii), 
[16:19:18.994]                           FUN = function(jj) {
[16:19:18.994]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:18.994]                             ...future.FUN(...future.X_jj, ...)
[16:19:18.994]                           })
[16:19:18.994]                       }
[16:19:18.994]                     }, args = future.call.arguments)
[16:19:18.994]                   }
[16:19:18.994]                 }, immediateCondition = function(cond) {
[16:19:18.994]                   sendCondition <- ...future.makeSendCondition()
[16:19:18.994]                   sendCondition(cond)
[16:19:18.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.994]                   {
[16:19:18.994]                     inherits <- base::inherits
[16:19:18.994]                     invokeRestart <- base::invokeRestart
[16:19:18.994]                     is.null <- base::is.null
[16:19:18.994]                     muffled <- FALSE
[16:19:18.994]                     if (inherits(cond, "message")) {
[16:19:18.994]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:18.994]                       if (muffled) 
[16:19:18.994]                         invokeRestart("muffleMessage")
[16:19:18.994]                     }
[16:19:18.994]                     else if (inherits(cond, "warning")) {
[16:19:18.994]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:18.994]                       if (muffled) 
[16:19:18.994]                         invokeRestart("muffleWarning")
[16:19:18.994]                     }
[16:19:18.994]                     else if (inherits(cond, "condition")) {
[16:19:18.994]                       if (!is.null(pattern)) {
[16:19:18.994]                         computeRestarts <- base::computeRestarts
[16:19:18.994]                         grepl <- base::grepl
[16:19:18.994]                         restarts <- computeRestarts(cond)
[16:19:18.994]                         for (restart in restarts) {
[16:19:18.994]                           name <- restart$name
[16:19:18.994]                           if (is.null(name)) 
[16:19:18.994]                             next
[16:19:18.994]                           if (!grepl(pattern, name)) 
[16:19:18.994]                             next
[16:19:18.994]                           invokeRestart(restart)
[16:19:18.994]                           muffled <- TRUE
[16:19:18.994]                           break
[16:19:18.994]                         }
[16:19:18.994]                       }
[16:19:18.994]                     }
[16:19:18.994]                     invisible(muffled)
[16:19:18.994]                   }
[16:19:18.994]                   muffleCondition(cond)
[16:19:18.994]                 })
[16:19:18.994]             }))
[16:19:18.994]             future::FutureResult(value = ...future.value$value, 
[16:19:18.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.994]                   ...future.rng), globalenv = if (FALSE) 
[16:19:18.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:18.994]                     ...future.globalenv.names))
[16:19:18.994]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:18.994]         }, condition = base::local({
[16:19:18.994]             c <- base::c
[16:19:18.994]             inherits <- base::inherits
[16:19:18.994]             invokeRestart <- base::invokeRestart
[16:19:18.994]             length <- base::length
[16:19:18.994]             list <- base::list
[16:19:18.994]             seq.int <- base::seq.int
[16:19:18.994]             signalCondition <- base::signalCondition
[16:19:18.994]             sys.calls <- base::sys.calls
[16:19:18.994]             `[[` <- base::`[[`
[16:19:18.994]             `+` <- base::`+`
[16:19:18.994]             `<<-` <- base::`<<-`
[16:19:18.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:18.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:18.994]                   3L)]
[16:19:18.994]             }
[16:19:18.994]             function(cond) {
[16:19:18.994]                 is_error <- inherits(cond, "error")
[16:19:18.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:18.994]                   NULL)
[16:19:18.994]                 if (is_error) {
[16:19:18.994]                   sessionInformation <- function() {
[16:19:18.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:18.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:18.994]                       search = base::search(), system = base::Sys.info())
[16:19:18.994]                   }
[16:19:18.994]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:18.994]                     cond$call), session = sessionInformation(), 
[16:19:18.994]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:18.994]                   signalCondition(cond)
[16:19:18.994]                 }
[16:19:18.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:18.994]                 "immediateCondition"))) {
[16:19:18.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:18.994]                   ...future.conditions[[length(...future.conditions) + 
[16:19:18.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:18.994]                   if (TRUE && !signal) {
[16:19:18.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.994]                     {
[16:19:18.994]                       inherits <- base::inherits
[16:19:18.994]                       invokeRestart <- base::invokeRestart
[16:19:18.994]                       is.null <- base::is.null
[16:19:18.994]                       muffled <- FALSE
[16:19:18.994]                       if (inherits(cond, "message")) {
[16:19:18.994]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.994]                         if (muffled) 
[16:19:18.994]                           invokeRestart("muffleMessage")
[16:19:18.994]                       }
[16:19:18.994]                       else if (inherits(cond, "warning")) {
[16:19:18.994]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.994]                         if (muffled) 
[16:19:18.994]                           invokeRestart("muffleWarning")
[16:19:18.994]                       }
[16:19:18.994]                       else if (inherits(cond, "condition")) {
[16:19:18.994]                         if (!is.null(pattern)) {
[16:19:18.994]                           computeRestarts <- base::computeRestarts
[16:19:18.994]                           grepl <- base::grepl
[16:19:18.994]                           restarts <- computeRestarts(cond)
[16:19:18.994]                           for (restart in restarts) {
[16:19:18.994]                             name <- restart$name
[16:19:18.994]                             if (is.null(name)) 
[16:19:18.994]                               next
[16:19:18.994]                             if (!grepl(pattern, name)) 
[16:19:18.994]                               next
[16:19:18.994]                             invokeRestart(restart)
[16:19:18.994]                             muffled <- TRUE
[16:19:18.994]                             break
[16:19:18.994]                           }
[16:19:18.994]                         }
[16:19:18.994]                       }
[16:19:18.994]                       invisible(muffled)
[16:19:18.994]                     }
[16:19:18.994]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.994]                   }
[16:19:18.994]                 }
[16:19:18.994]                 else {
[16:19:18.994]                   if (TRUE) {
[16:19:18.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:18.994]                     {
[16:19:18.994]                       inherits <- base::inherits
[16:19:18.994]                       invokeRestart <- base::invokeRestart
[16:19:18.994]                       is.null <- base::is.null
[16:19:18.994]                       muffled <- FALSE
[16:19:18.994]                       if (inherits(cond, "message")) {
[16:19:18.994]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:18.994]                         if (muffled) 
[16:19:18.994]                           invokeRestart("muffleMessage")
[16:19:18.994]                       }
[16:19:18.994]                       else if (inherits(cond, "warning")) {
[16:19:18.994]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:18.994]                         if (muffled) 
[16:19:18.994]                           invokeRestart("muffleWarning")
[16:19:18.994]                       }
[16:19:18.994]                       else if (inherits(cond, "condition")) {
[16:19:18.994]                         if (!is.null(pattern)) {
[16:19:18.994]                           computeRestarts <- base::computeRestarts
[16:19:18.994]                           grepl <- base::grepl
[16:19:18.994]                           restarts <- computeRestarts(cond)
[16:19:18.994]                           for (restart in restarts) {
[16:19:18.994]                             name <- restart$name
[16:19:18.994]                             if (is.null(name)) 
[16:19:18.994]                               next
[16:19:18.994]                             if (!grepl(pattern, name)) 
[16:19:18.994]                               next
[16:19:18.994]                             invokeRestart(restart)
[16:19:18.994]                             muffled <- TRUE
[16:19:18.994]                             break
[16:19:18.994]                           }
[16:19:18.994]                         }
[16:19:18.994]                       }
[16:19:18.994]                       invisible(muffled)
[16:19:18.994]                     }
[16:19:18.994]                     muffleCondition(cond, pattern = "^muffle")
[16:19:18.994]                   }
[16:19:18.994]                 }
[16:19:18.994]             }
[16:19:18.994]         }))
[16:19:18.994]     }, error = function(ex) {
[16:19:18.994]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:18.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:18.994]                 ...future.rng), started = ...future.startTime, 
[16:19:18.994]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:18.994]             version = "1.8"), class = "FutureResult")
[16:19:18.994]     }, finally = {
[16:19:18.994]         if (!identical(...future.workdir, getwd())) 
[16:19:18.994]             setwd(...future.workdir)
[16:19:18.994]         {
[16:19:18.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:18.994]                 ...future.oldOptions$nwarnings <- NULL
[16:19:18.994]             }
[16:19:18.994]             base::options(...future.oldOptions)
[16:19:18.994]             if (.Platform$OS.type == "windows") {
[16:19:18.994]                 old_names <- names(...future.oldEnvVars)
[16:19:18.994]                 envs <- base::Sys.getenv()
[16:19:18.994]                 names <- names(envs)
[16:19:18.994]                 common <- intersect(names, old_names)
[16:19:18.994]                 added <- setdiff(names, old_names)
[16:19:18.994]                 removed <- setdiff(old_names, names)
[16:19:18.994]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:18.994]                   envs[common]]
[16:19:18.994]                 NAMES <- toupper(changed)
[16:19:18.994]                 args <- list()
[16:19:18.994]                 for (kk in seq_along(NAMES)) {
[16:19:18.994]                   name <- changed[[kk]]
[16:19:18.994]                   NAME <- NAMES[[kk]]
[16:19:18.994]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.994]                     next
[16:19:18.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.994]                 }
[16:19:18.994]                 NAMES <- toupper(added)
[16:19:18.994]                 for (kk in seq_along(NAMES)) {
[16:19:18.994]                   name <- added[[kk]]
[16:19:18.994]                   NAME <- NAMES[[kk]]
[16:19:18.994]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.994]                     next
[16:19:18.994]                   args[[name]] <- ""
[16:19:18.994]                 }
[16:19:18.994]                 NAMES <- toupper(removed)
[16:19:18.994]                 for (kk in seq_along(NAMES)) {
[16:19:18.994]                   name <- removed[[kk]]
[16:19:18.994]                   NAME <- NAMES[[kk]]
[16:19:18.994]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:18.994]                     next
[16:19:18.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:18.994]                 }
[16:19:18.994]                 if (length(args) > 0) 
[16:19:18.994]                   base::do.call(base::Sys.setenv, args = args)
[16:19:18.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:18.994]             }
[16:19:18.994]             else {
[16:19:18.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:18.994]             }
[16:19:18.994]             {
[16:19:18.994]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:18.994]                   0L) {
[16:19:18.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:18.994]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:18.994]                   base::options(opts)
[16:19:18.994]                 }
[16:19:18.994]                 {
[16:19:18.994]                   {
[16:19:18.994]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:18.994]                     NULL
[16:19:18.994]                   }
[16:19:18.994]                   options(future.plan = NULL)
[16:19:18.994]                   if (is.na(NA_character_)) 
[16:19:18.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:18.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:18.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:18.994]                     .init = FALSE)
[16:19:18.994]                 }
[16:19:18.994]             }
[16:19:18.994]         }
[16:19:18.994]     })
[16:19:18.994]     if (TRUE) {
[16:19:18.994]         base::sink(type = "output", split = FALSE)
[16:19:18.994]         if (TRUE) {
[16:19:18.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:18.994]         }
[16:19:18.994]         else {
[16:19:18.994]             ...future.result["stdout"] <- base::list(NULL)
[16:19:18.994]         }
[16:19:18.994]         base::close(...future.stdout)
[16:19:18.994]         ...future.stdout <- NULL
[16:19:18.994]     }
[16:19:18.994]     ...future.result$conditions <- ...future.conditions
[16:19:18.994]     ...future.result$finished <- base::Sys.time()
[16:19:18.994]     ...future.result
[16:19:18.994] }
[16:19:18.997] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[16:19:18.997] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:19.041] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:19.041] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[16:19:19.042] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[16:19:19.042] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:19.043] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:19.043] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:19.084] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:19.085] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:19.128] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:19.129] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:19:19.129] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:19:19.129] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:19.130] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:19.130] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:19.130] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.130] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:19:19.131] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:19:19.131] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:19.131] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.131] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:19.132] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.132] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[16:19:19.133] MultisessionFuture started
[16:19:19.133] - Launch lazy future ... done
[16:19:19.133] run() for ‘MultisessionFuture’ ... done
[16:19:19.133] Created future:
[16:19:19.133] MultisessionFuture:
[16:19:19.133] Label: ‘future_vapply-1’
[16:19:19.133] Expression:
[16:19:19.133] {
[16:19:19.133]     do.call(function(...) {
[16:19:19.133]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.133]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.133]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.133]             on.exit(options(oopts), add = TRUE)
[16:19:19.133]         }
[16:19:19.133]         {
[16:19:19.133]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.133]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.133]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.133]             })
[16:19:19.133]         }
[16:19:19.133]     }, args = future.call.arguments)
[16:19:19.133] }
[16:19:19.133] Lazy evaluation: FALSE
[16:19:19.133] Asynchronous evaluation: TRUE
[16:19:19.133] Local evaluation: TRUE
[16:19:19.133] Environment: R_GlobalEnv
[16:19:19.133] Capture standard output: TRUE
[16:19:19.133] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:19.133] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:19.133] Packages: 1 packages (‘future.apply’)
[16:19:19.133] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:19.133] Resolved: FALSE
[16:19:19.133] Value: <not collected>
[16:19:19.133] Conditions captured: <none>
[16:19:19.133] Early signaling: FALSE
[16:19:19.133] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:19.133] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.145] Chunk #1 of 2 ... DONE
[16:19:19.145] Chunk #2 of 2 ...
[16:19:19.145]  - Finding globals in 'X' for chunk #2 ...
[16:19:19.145] getGlobalsAndPackages() ...
[16:19:19.145] Searching for globals...
[16:19:19.146] 
[16:19:19.146] Searching for globals ... DONE
[16:19:19.146] - globals: [0] <none>
[16:19:19.146] getGlobalsAndPackages() ... DONE
[16:19:19.146]    + additional globals found: [n=0] 
[16:19:19.146]    + additional namespaces needed: [n=0] 
[16:19:19.146]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:19.146]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:19.146]  - seeds: <none>
[16:19:19.147]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.147] getGlobalsAndPackages() ...
[16:19:19.147] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.147] Resolving globals: FALSE
[16:19:19.147] Tweak future expression to call with '...' arguments ...
[16:19:19.147] {
[16:19:19.147]     do.call(function(...) {
[16:19:19.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.147]             on.exit(options(oopts), add = TRUE)
[16:19:19.147]         }
[16:19:19.147]         {
[16:19:19.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.147]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.147]             })
[16:19:19.147]         }
[16:19:19.147]     }, args = future.call.arguments)
[16:19:19.147] }
[16:19:19.147] Tweak future expression to call with '...' arguments ... DONE
[16:19:19.148] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.148] - packages: [1] ‘future.apply’
[16:19:19.148] getGlobalsAndPackages() ... DONE
[16:19:19.148] run() for ‘Future’ ...
[16:19:19.149] - state: ‘created’
[16:19:19.149] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:19.163] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:19.163]   - Field: ‘node’
[16:19:19.163]   - Field: ‘label’
[16:19:19.164]   - Field: ‘local’
[16:19:19.164]   - Field: ‘owner’
[16:19:19.164]   - Field: ‘envir’
[16:19:19.164]   - Field: ‘workers’
[16:19:19.164]   - Field: ‘packages’
[16:19:19.164]   - Field: ‘gc’
[16:19:19.164]   - Field: ‘conditions’
[16:19:19.164]   - Field: ‘persistent’
[16:19:19.164]   - Field: ‘expr’
[16:19:19.164]   - Field: ‘uuid’
[16:19:19.165]   - Field: ‘seed’
[16:19:19.165]   - Field: ‘version’
[16:19:19.165]   - Field: ‘result’
[16:19:19.165]   - Field: ‘asynchronous’
[16:19:19.165]   - Field: ‘calls’
[16:19:19.165]   - Field: ‘globals’
[16:19:19.165]   - Field: ‘stdout’
[16:19:19.165]   - Field: ‘earlySignal’
[16:19:19.165]   - Field: ‘lazy’
[16:19:19.165]   - Field: ‘state’
[16:19:19.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:19.166] - Launch lazy future ...
[16:19:19.166] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:19.166] Packages needed by future strategies (n = 0): <none>
[16:19:19.166] {
[16:19:19.166]     {
[16:19:19.166]         {
[16:19:19.166]             ...future.startTime <- base::Sys.time()
[16:19:19.166]             {
[16:19:19.166]                 {
[16:19:19.166]                   {
[16:19:19.166]                     {
[16:19:19.166]                       {
[16:19:19.166]                         base::local({
[16:19:19.166]                           has_future <- base::requireNamespace("future", 
[16:19:19.166]                             quietly = TRUE)
[16:19:19.166]                           if (has_future) {
[16:19:19.166]                             ns <- base::getNamespace("future")
[16:19:19.166]                             version <- ns[[".package"]][["version"]]
[16:19:19.166]                             if (is.null(version)) 
[16:19:19.166]                               version <- utils::packageVersion("future")
[16:19:19.166]                           }
[16:19:19.166]                           else {
[16:19:19.166]                             version <- NULL
[16:19:19.166]                           }
[16:19:19.166]                           if (!has_future || version < "1.8.0") {
[16:19:19.166]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:19.166]                               "", base::R.version$version.string), 
[16:19:19.166]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:19.166]                                 base::R.version$platform, 8 * 
[16:19:19.166]                                   base::.Machine$sizeof.pointer), 
[16:19:19.166]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:19.166]                                 "release", "version")], collapse = " "), 
[16:19:19.166]                               hostname = base::Sys.info()[["nodename"]])
[16:19:19.166]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:19.166]                               info)
[16:19:19.166]                             info <- base::paste(info, collapse = "; ")
[16:19:19.166]                             if (!has_future) {
[16:19:19.166]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:19.166]                                 info)
[16:19:19.166]                             }
[16:19:19.166]                             else {
[16:19:19.166]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:19.166]                                 info, version)
[16:19:19.166]                             }
[16:19:19.166]                             base::stop(msg)
[16:19:19.166]                           }
[16:19:19.166]                         })
[16:19:19.166]                       }
[16:19:19.166]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:19.166]                       base::options(mc.cores = 1L)
[16:19:19.166]                     }
[16:19:19.166]                     base::local({
[16:19:19.166]                       for (pkg in "future.apply") {
[16:19:19.166]                         base::loadNamespace(pkg)
[16:19:19.166]                         base::library(pkg, character.only = TRUE)
[16:19:19.166]                       }
[16:19:19.166]                     })
[16:19:19.166]                   }
[16:19:19.166]                   ...future.strategy.old <- future::plan("list")
[16:19:19.166]                   options(future.plan = NULL)
[16:19:19.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:19.166]                 }
[16:19:19.166]                 ...future.workdir <- getwd()
[16:19:19.166]             }
[16:19:19.166]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:19.166]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:19.166]         }
[16:19:19.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:19.166]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:19.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:19.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:19.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:19.166]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:19.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:19.166]             base::names(...future.oldOptions))
[16:19:19.166]     }
[16:19:19.166]     if (FALSE) {
[16:19:19.166]     }
[16:19:19.166]     else {
[16:19:19.166]         if (TRUE) {
[16:19:19.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:19.166]                 open = "w")
[16:19:19.166]         }
[16:19:19.166]         else {
[16:19:19.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:19.166]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:19.166]         }
[16:19:19.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:19.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:19.166]             base::sink(type = "output", split = FALSE)
[16:19:19.166]             base::close(...future.stdout)
[16:19:19.166]         }, add = TRUE)
[16:19:19.166]     }
[16:19:19.166]     ...future.frame <- base::sys.nframe()
[16:19:19.166]     ...future.conditions <- base::list()
[16:19:19.166]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:19.166]     if (FALSE) {
[16:19:19.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:19.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:19.166]     }
[16:19:19.166]     ...future.result <- base::tryCatch({
[16:19:19.166]         base::withCallingHandlers({
[16:19:19.166]             ...future.value <- base::withVisible(base::local({
[16:19:19.166]                 ...future.makeSendCondition <- base::local({
[16:19:19.166]                   sendCondition <- NULL
[16:19:19.166]                   function(frame = 1L) {
[16:19:19.166]                     if (is.function(sendCondition)) 
[16:19:19.166]                       return(sendCondition)
[16:19:19.166]                     ns <- getNamespace("parallel")
[16:19:19.166]                     if (exists("sendData", mode = "function", 
[16:19:19.166]                       envir = ns)) {
[16:19:19.166]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:19.166]                         envir = ns)
[16:19:19.166]                       envir <- sys.frame(frame)
[16:19:19.166]                       master <- NULL
[16:19:19.166]                       while (!identical(envir, .GlobalEnv) && 
[16:19:19.166]                         !identical(envir, emptyenv())) {
[16:19:19.166]                         if (exists("master", mode = "list", envir = envir, 
[16:19:19.166]                           inherits = FALSE)) {
[16:19:19.166]                           master <- get("master", mode = "list", 
[16:19:19.166]                             envir = envir, inherits = FALSE)
[16:19:19.166]                           if (inherits(master, c("SOCKnode", 
[16:19:19.166]                             "SOCK0node"))) {
[16:19:19.166]                             sendCondition <<- function(cond) {
[16:19:19.166]                               data <- list(type = "VALUE", value = cond, 
[16:19:19.166]                                 success = TRUE)
[16:19:19.166]                               parallel_sendData(master, data)
[16:19:19.166]                             }
[16:19:19.166]                             return(sendCondition)
[16:19:19.166]                           }
[16:19:19.166]                         }
[16:19:19.166]                         frame <- frame + 1L
[16:19:19.166]                         envir <- sys.frame(frame)
[16:19:19.166]                       }
[16:19:19.166]                     }
[16:19:19.166]                     sendCondition <<- function(cond) NULL
[16:19:19.166]                   }
[16:19:19.166]                 })
[16:19:19.166]                 withCallingHandlers({
[16:19:19.166]                   {
[16:19:19.166]                     do.call(function(...) {
[16:19:19.166]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.166]                       if (!identical(...future.globals.maxSize.org, 
[16:19:19.166]                         ...future.globals.maxSize)) {
[16:19:19.166]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.166]                         on.exit(options(oopts), add = TRUE)
[16:19:19.166]                       }
[16:19:19.166]                       {
[16:19:19.166]                         lapply(seq_along(...future.elements_ii), 
[16:19:19.166]                           FUN = function(jj) {
[16:19:19.166]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.166]                             ...future.FUN(...future.X_jj, ...)
[16:19:19.166]                           })
[16:19:19.166]                       }
[16:19:19.166]                     }, args = future.call.arguments)
[16:19:19.166]                   }
[16:19:19.166]                 }, immediateCondition = function(cond) {
[16:19:19.166]                   sendCondition <- ...future.makeSendCondition()
[16:19:19.166]                   sendCondition(cond)
[16:19:19.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.166]                   {
[16:19:19.166]                     inherits <- base::inherits
[16:19:19.166]                     invokeRestart <- base::invokeRestart
[16:19:19.166]                     is.null <- base::is.null
[16:19:19.166]                     muffled <- FALSE
[16:19:19.166]                     if (inherits(cond, "message")) {
[16:19:19.166]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:19.166]                       if (muffled) 
[16:19:19.166]                         invokeRestart("muffleMessage")
[16:19:19.166]                     }
[16:19:19.166]                     else if (inherits(cond, "warning")) {
[16:19:19.166]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:19.166]                       if (muffled) 
[16:19:19.166]                         invokeRestart("muffleWarning")
[16:19:19.166]                     }
[16:19:19.166]                     else if (inherits(cond, "condition")) {
[16:19:19.166]                       if (!is.null(pattern)) {
[16:19:19.166]                         computeRestarts <- base::computeRestarts
[16:19:19.166]                         grepl <- base::grepl
[16:19:19.166]                         restarts <- computeRestarts(cond)
[16:19:19.166]                         for (restart in restarts) {
[16:19:19.166]                           name <- restart$name
[16:19:19.166]                           if (is.null(name)) 
[16:19:19.166]                             next
[16:19:19.166]                           if (!grepl(pattern, name)) 
[16:19:19.166]                             next
[16:19:19.166]                           invokeRestart(restart)
[16:19:19.166]                           muffled <- TRUE
[16:19:19.166]                           break
[16:19:19.166]                         }
[16:19:19.166]                       }
[16:19:19.166]                     }
[16:19:19.166]                     invisible(muffled)
[16:19:19.166]                   }
[16:19:19.166]                   muffleCondition(cond)
[16:19:19.166]                 })
[16:19:19.166]             }))
[16:19:19.166]             future::FutureResult(value = ...future.value$value, 
[16:19:19.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.166]                   ...future.rng), globalenv = if (FALSE) 
[16:19:19.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:19.166]                     ...future.globalenv.names))
[16:19:19.166]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:19.166]         }, condition = base::local({
[16:19:19.166]             c <- base::c
[16:19:19.166]             inherits <- base::inherits
[16:19:19.166]             invokeRestart <- base::invokeRestart
[16:19:19.166]             length <- base::length
[16:19:19.166]             list <- base::list
[16:19:19.166]             seq.int <- base::seq.int
[16:19:19.166]             signalCondition <- base::signalCondition
[16:19:19.166]             sys.calls <- base::sys.calls
[16:19:19.166]             `[[` <- base::`[[`
[16:19:19.166]             `+` <- base::`+`
[16:19:19.166]             `<<-` <- base::`<<-`
[16:19:19.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:19.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:19.166]                   3L)]
[16:19:19.166]             }
[16:19:19.166]             function(cond) {
[16:19:19.166]                 is_error <- inherits(cond, "error")
[16:19:19.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:19.166]                   NULL)
[16:19:19.166]                 if (is_error) {
[16:19:19.166]                   sessionInformation <- function() {
[16:19:19.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:19.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:19.166]                       search = base::search(), system = base::Sys.info())
[16:19:19.166]                   }
[16:19:19.166]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:19.166]                     cond$call), session = sessionInformation(), 
[16:19:19.166]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:19.166]                   signalCondition(cond)
[16:19:19.166]                 }
[16:19:19.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:19.166]                 "immediateCondition"))) {
[16:19:19.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:19.166]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:19.166]                   if (TRUE && !signal) {
[16:19:19.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.166]                     {
[16:19:19.166]                       inherits <- base::inherits
[16:19:19.166]                       invokeRestart <- base::invokeRestart
[16:19:19.166]                       is.null <- base::is.null
[16:19:19.166]                       muffled <- FALSE
[16:19:19.166]                       if (inherits(cond, "message")) {
[16:19:19.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.166]                         if (muffled) 
[16:19:19.166]                           invokeRestart("muffleMessage")
[16:19:19.166]                       }
[16:19:19.166]                       else if (inherits(cond, "warning")) {
[16:19:19.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.166]                         if (muffled) 
[16:19:19.166]                           invokeRestart("muffleWarning")
[16:19:19.166]                       }
[16:19:19.166]                       else if (inherits(cond, "condition")) {
[16:19:19.166]                         if (!is.null(pattern)) {
[16:19:19.166]                           computeRestarts <- base::computeRestarts
[16:19:19.166]                           grepl <- base::grepl
[16:19:19.166]                           restarts <- computeRestarts(cond)
[16:19:19.166]                           for (restart in restarts) {
[16:19:19.166]                             name <- restart$name
[16:19:19.166]                             if (is.null(name)) 
[16:19:19.166]                               next
[16:19:19.166]                             if (!grepl(pattern, name)) 
[16:19:19.166]                               next
[16:19:19.166]                             invokeRestart(restart)
[16:19:19.166]                             muffled <- TRUE
[16:19:19.166]                             break
[16:19:19.166]                           }
[16:19:19.166]                         }
[16:19:19.166]                       }
[16:19:19.166]                       invisible(muffled)
[16:19:19.166]                     }
[16:19:19.166]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.166]                   }
[16:19:19.166]                 }
[16:19:19.166]                 else {
[16:19:19.166]                   if (TRUE) {
[16:19:19.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.166]                     {
[16:19:19.166]                       inherits <- base::inherits
[16:19:19.166]                       invokeRestart <- base::invokeRestart
[16:19:19.166]                       is.null <- base::is.null
[16:19:19.166]                       muffled <- FALSE
[16:19:19.166]                       if (inherits(cond, "message")) {
[16:19:19.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.166]                         if (muffled) 
[16:19:19.166]                           invokeRestart("muffleMessage")
[16:19:19.166]                       }
[16:19:19.166]                       else if (inherits(cond, "warning")) {
[16:19:19.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.166]                         if (muffled) 
[16:19:19.166]                           invokeRestart("muffleWarning")
[16:19:19.166]                       }
[16:19:19.166]                       else if (inherits(cond, "condition")) {
[16:19:19.166]                         if (!is.null(pattern)) {
[16:19:19.166]                           computeRestarts <- base::computeRestarts
[16:19:19.166]                           grepl <- base::grepl
[16:19:19.166]                           restarts <- computeRestarts(cond)
[16:19:19.166]                           for (restart in restarts) {
[16:19:19.166]                             name <- restart$name
[16:19:19.166]                             if (is.null(name)) 
[16:19:19.166]                               next
[16:19:19.166]                             if (!grepl(pattern, name)) 
[16:19:19.166]                               next
[16:19:19.166]                             invokeRestart(restart)
[16:19:19.166]                             muffled <- TRUE
[16:19:19.166]                             break
[16:19:19.166]                           }
[16:19:19.166]                         }
[16:19:19.166]                       }
[16:19:19.166]                       invisible(muffled)
[16:19:19.166]                     }
[16:19:19.166]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.166]                   }
[16:19:19.166]                 }
[16:19:19.166]             }
[16:19:19.166]         }))
[16:19:19.166]     }, error = function(ex) {
[16:19:19.166]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:19.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.166]                 ...future.rng), started = ...future.startTime, 
[16:19:19.166]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:19.166]             version = "1.8"), class = "FutureResult")
[16:19:19.166]     }, finally = {
[16:19:19.166]         if (!identical(...future.workdir, getwd())) 
[16:19:19.166]             setwd(...future.workdir)
[16:19:19.166]         {
[16:19:19.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:19.166]                 ...future.oldOptions$nwarnings <- NULL
[16:19:19.166]             }
[16:19:19.166]             base::options(...future.oldOptions)
[16:19:19.166]             if (.Platform$OS.type == "windows") {
[16:19:19.166]                 old_names <- names(...future.oldEnvVars)
[16:19:19.166]                 envs <- base::Sys.getenv()
[16:19:19.166]                 names <- names(envs)
[16:19:19.166]                 common <- intersect(names, old_names)
[16:19:19.166]                 added <- setdiff(names, old_names)
[16:19:19.166]                 removed <- setdiff(old_names, names)
[16:19:19.166]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:19.166]                   envs[common]]
[16:19:19.166]                 NAMES <- toupper(changed)
[16:19:19.166]                 args <- list()
[16:19:19.166]                 for (kk in seq_along(NAMES)) {
[16:19:19.166]                   name <- changed[[kk]]
[16:19:19.166]                   NAME <- NAMES[[kk]]
[16:19:19.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.166]                     next
[16:19:19.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.166]                 }
[16:19:19.166]                 NAMES <- toupper(added)
[16:19:19.166]                 for (kk in seq_along(NAMES)) {
[16:19:19.166]                   name <- added[[kk]]
[16:19:19.166]                   NAME <- NAMES[[kk]]
[16:19:19.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.166]                     next
[16:19:19.166]                   args[[name]] <- ""
[16:19:19.166]                 }
[16:19:19.166]                 NAMES <- toupper(removed)
[16:19:19.166]                 for (kk in seq_along(NAMES)) {
[16:19:19.166]                   name <- removed[[kk]]
[16:19:19.166]                   NAME <- NAMES[[kk]]
[16:19:19.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.166]                     next
[16:19:19.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.166]                 }
[16:19:19.166]                 if (length(args) > 0) 
[16:19:19.166]                   base::do.call(base::Sys.setenv, args = args)
[16:19:19.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:19.166]             }
[16:19:19.166]             else {
[16:19:19.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:19.166]             }
[16:19:19.166]             {
[16:19:19.166]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:19.166]                   0L) {
[16:19:19.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:19.166]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:19.166]                   base::options(opts)
[16:19:19.166]                 }
[16:19:19.166]                 {
[16:19:19.166]                   {
[16:19:19.166]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:19.166]                     NULL
[16:19:19.166]                   }
[16:19:19.166]                   options(future.plan = NULL)
[16:19:19.166]                   if (is.na(NA_character_)) 
[16:19:19.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:19.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:19.166]                     .init = FALSE)
[16:19:19.166]                 }
[16:19:19.166]             }
[16:19:19.166]         }
[16:19:19.166]     })
[16:19:19.166]     if (TRUE) {
[16:19:19.166]         base::sink(type = "output", split = FALSE)
[16:19:19.166]         if (TRUE) {
[16:19:19.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:19.166]         }
[16:19:19.166]         else {
[16:19:19.166]             ...future.result["stdout"] <- base::list(NULL)
[16:19:19.166]         }
[16:19:19.166]         base::close(...future.stdout)
[16:19:19.166]         ...future.stdout <- NULL
[16:19:19.166]     }
[16:19:19.166]     ...future.result$conditions <- ...future.conditions
[16:19:19.166]     ...future.result$finished <- base::Sys.time()
[16:19:19.166]     ...future.result
[16:19:19.166] }
[16:19:19.169] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[16:19:19.169] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:19:19.213] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:19:19.213] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[16:19:19.213] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[16:19:19.213] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:19:19.214] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:19:19.214] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:19:19.256] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:19:19.257] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:19:19.301] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:19:19.301] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:19:19.301] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:19:19.301] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:19:19.302] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:19:19.302] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:19.302] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:19.302] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:19:19.303] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:19:19.303] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:19.303] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:19.303] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:19.304] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:19.304] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[16:19:19.304] MultisessionFuture started
[16:19:19.304] - Launch lazy future ... done
[16:19:19.305] run() for ‘MultisessionFuture’ ... done
[16:19:19.305] Created future:
[16:19:19.305] MultisessionFuture:
[16:19:19.305] Label: ‘future_vapply-2’
[16:19:19.305] Expression:
[16:19:19.305] {
[16:19:19.305]     do.call(function(...) {
[16:19:19.305]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.305]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.305]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.305]             on.exit(options(oopts), add = TRUE)
[16:19:19.305]         }
[16:19:19.305]         {
[16:19:19.305]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.305]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.305]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.305]             })
[16:19:19.305]         }
[16:19:19.305]     }, args = future.call.arguments)
[16:19:19.305] }
[16:19:19.305] Lazy evaluation: FALSE
[16:19:19.305] Asynchronous evaluation: TRUE
[16:19:19.305] Local evaluation: TRUE
[16:19:19.305] Environment: R_GlobalEnv
[16:19:19.305] Capture standard output: TRUE
[16:19:19.305] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:19.305] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:19.305] Packages: 1 packages (‘future.apply’)
[16:19:19.305] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:19.305] Resolved: FALSE
[16:19:19.305] Value: <not collected>
[16:19:19.305] Conditions captured: <none>
[16:19:19.305] Early signaling: FALSE
[16:19:19.305] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:19.305] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.317] Chunk #2 of 2 ... DONE
[16:19:19.317] Launching 2 futures (chunks) ... DONE
[16:19:19.317] Resolving 2 futures (chunks) ...
[16:19:19.317] resolve() on list ...
[16:19:19.317]  recursive: 0
[16:19:19.317]  length: 2
[16:19:19.317] 
[16:19:19.318] receiveMessageFromWorker() for ClusterFuture ...
[16:19:19.318] - Validating connection of MultisessionFuture
[16:19:19.318] - received message: FutureResult
[16:19:19.318] - Received FutureResult
[16:19:19.318] - Erased future from FutureRegistry
[16:19:19.318] result() for ClusterFuture ...
[16:19:19.318] - result already collected: FutureResult
[16:19:19.318] result() for ClusterFuture ... done
[16:19:19.318] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:19.319] Future #1
[16:19:19.319] result() for ClusterFuture ...
[16:19:19.319] - result already collected: FutureResult
[16:19:19.319] result() for ClusterFuture ... done
[16:19:19.319] result() for ClusterFuture ...
[16:19:19.319] - result already collected: FutureResult
[16:19:19.319] result() for ClusterFuture ... done
[16:19:19.319] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:19.319] - nx: 2
[16:19:19.319] - relay: TRUE
[16:19:19.319] - stdout: TRUE
[16:19:19.319] - signal: TRUE
[16:19:19.320] - resignal: FALSE
[16:19:19.320] - force: TRUE
[16:19:19.320] - relayed: [n=2] FALSE, FALSE
[16:19:19.320] - queued futures: [n=2] FALSE, FALSE
[16:19:19.320]  - until=1
[16:19:19.320]  - relaying element #1
[16:19:19.320] result() for ClusterFuture ...
[16:19:19.320] - result already collected: FutureResult
[16:19:19.320] result() for ClusterFuture ... done
[16:19:19.320] result() for ClusterFuture ...
[16:19:19.320] - result already collected: FutureResult
[16:19:19.321] result() for ClusterFuture ... done
[16:19:19.321] result() for ClusterFuture ...
[16:19:19.321] - result already collected: FutureResult
[16:19:19.321] result() for ClusterFuture ... done
[16:19:19.321] result() for ClusterFuture ...
[16:19:19.321] - result already collected: FutureResult
[16:19:19.321] result() for ClusterFuture ... done
[16:19:19.321] - relayed: [n=2] TRUE, FALSE
[16:19:19.321] - queued futures: [n=2] TRUE, FALSE
[16:19:19.321] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:19.321]  length: 1 (resolved future 1)
[16:19:19.350] receiveMessageFromWorker() for ClusterFuture ...
[16:19:19.350] - Validating connection of MultisessionFuture
[16:19:19.350] - received message: FutureResult
[16:19:19.351] - Received FutureResult
[16:19:19.351] - Erased future from FutureRegistry
[16:19:19.351] result() for ClusterFuture ...
[16:19:19.351] - result already collected: FutureResult
[16:19:19.351] result() for ClusterFuture ... done
[16:19:19.351] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:19.351] Future #2
[16:19:19.351] result() for ClusterFuture ...
[16:19:19.351] - result already collected: FutureResult
[16:19:19.351] result() for ClusterFuture ... done
[16:19:19.351] result() for ClusterFuture ...
[16:19:19.352] - result already collected: FutureResult
[16:19:19.352] result() for ClusterFuture ... done
[16:19:19.352] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:19.352] - nx: 2
[16:19:19.352] - relay: TRUE
[16:19:19.352] - stdout: TRUE
[16:19:19.352] - signal: TRUE
[16:19:19.352] - resignal: FALSE
[16:19:19.352] - force: TRUE
[16:19:19.352] - relayed: [n=2] TRUE, FALSE
[16:19:19.352] - queued futures: [n=2] TRUE, FALSE
[16:19:19.352]  - until=2
[16:19:19.353]  - relaying element #2
[16:19:19.353] result() for ClusterFuture ...
[16:19:19.353] - result already collected: FutureResult
[16:19:19.353] result() for ClusterFuture ... done
[16:19:19.353] result() for ClusterFuture ...
[16:19:19.353] - result already collected: FutureResult
[16:19:19.353] result() for ClusterFuture ... done
[16:19:19.353] result() for ClusterFuture ...
[16:19:19.353] - result already collected: FutureResult
[16:19:19.353] result() for ClusterFuture ... done
[16:19:19.353] result() for ClusterFuture ...
[16:19:19.354] - result already collected: FutureResult
[16:19:19.354] result() for ClusterFuture ... done
[16:19:19.354] - relayed: [n=2] TRUE, TRUE
[16:19:19.354] - queued futures: [n=2] TRUE, TRUE
[16:19:19.354] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:19.354]  length: 0 (resolved future 2)
[16:19:19.354] Relaying remaining futures
[16:19:19.354] signalConditionsASAP(NULL, pos=0) ...
[16:19:19.354] - nx: 2
[16:19:19.354] - relay: TRUE
[16:19:19.354] - stdout: TRUE
[16:19:19.355] - signal: TRUE
[16:19:19.355] - resignal: FALSE
[16:19:19.355] - force: TRUE
[16:19:19.355] - relayed: [n=2] TRUE, TRUE
[16:19:19.355] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:19.355] - relayed: [n=2] TRUE, TRUE
[16:19:19.355] - queued futures: [n=2] TRUE, TRUE
[16:19:19.355] signalConditionsASAP(NULL, pos=0) ... done
[16:19:19.355] resolve() on list ... DONE
[16:19:19.355] result() for ClusterFuture ...
[16:19:19.355] - result already collected: FutureResult
[16:19:19.355] result() for ClusterFuture ... done
[16:19:19.356] result() for ClusterFuture ...
[16:19:19.356] - result already collected: FutureResult
[16:19:19.356] result() for ClusterFuture ... done
[16:19:19.356] result() for ClusterFuture ...
[16:19:19.356] - result already collected: FutureResult
[16:19:19.356] result() for ClusterFuture ... done
[16:19:19.356] result() for ClusterFuture ...
[16:19:19.356] - result already collected: FutureResult
[16:19:19.356] result() for ClusterFuture ... done
[16:19:19.356]  - Number of value chunks collected: 2
[16:19:19.357] Resolving 2 futures (chunks) ... DONE
[16:19:19.357] Reducing values from 2 chunks ...
[16:19:19.357]  - Number of values collected after concatenation: 10
[16:19:19.357]  - Number of values expected: 10
[16:19:19.357] Reducing values from 2 chunks ... DONE
[16:19:19.357] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:19:19.359] future_lapply() ...
[16:19:19.365] Number of chunks: 2
[16:19:19.365] getGlobalsAndPackagesXApply() ...
[16:19:19.365]  - future.globals: TRUE
[16:19:19.365] getGlobalsAndPackages() ...
[16:19:19.365] Searching for globals...
[16:19:19.368] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:19:19.369] Searching for globals ... DONE
[16:19:19.369] Resolving globals: FALSE
[16:19:19.370] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:19:19.370] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:19.370] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:19.370] - packages: [2] ‘stats’, ‘future.apply’
[16:19:19.370] getGlobalsAndPackages() ... DONE
[16:19:19.370]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:19.371]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:19:19.371] Finding globals ... DONE
[16:19:19.371]  - use_args: TRUE
[16:19:19.371]  - Getting '...' globals ...
[16:19:19.371] resolve() on list ...
[16:19:19.371]  recursive: 0
[16:19:19.371]  length: 1
[16:19:19.371]  elements: ‘...’
[16:19:19.372]  length: 0 (resolved future 1)
[16:19:19.372] resolve() on list ... DONE
[16:19:19.372]    - '...' content: [n=0] 
[16:19:19.372] List of 1
[16:19:19.372]  $ ...: list()
[16:19:19.372]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:19.372]  - attr(*, "where")=List of 1
[16:19:19.372]   ..$ ...:<environment: 0x5619a11b8020> 
[16:19:19.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:19.372]  - attr(*, "resolved")= logi TRUE
[16:19:19.372]  - attr(*, "total_size")= num NA
[16:19:19.374]  - Getting '...' globals ... DONE
[16:19:19.374] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:19.375] List of 8
[16:19:19.375]  $ ...future.FUN:function (x, ...)  
[16:19:19.375]  $ x_FUN        :function (x, ...)  
[16:19:19.375]  $ times        : int 5
[16:19:19.375]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:19.375]  $ stop_if_not  :function (...)  
[16:19:19.375]  $ dim          : NULL
[16:19:19.375]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:19.375]  $ ...          : list()
[16:19:19.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:19.375]  - attr(*, "where")=List of 8
[16:19:19.375]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:19.375]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:19.375]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:19.375]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:19.375]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:19.375]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:19.375]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:19.375]   ..$ ...          :<environment: 0x5619a11b8020> 
[16:19:19.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:19.375]  - attr(*, "resolved")= logi FALSE
[16:19:19.375]  - attr(*, "total_size")= num 95528
[16:19:19.380] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:19:19.380] getGlobalsAndPackagesXApply() ... DONE
[16:19:19.380] Number of futures (= number of chunks): 2
[16:19:19.380] Launching 2 futures (chunks) ...
[16:19:19.380] Chunk #1 of 2 ...
[16:19:19.380]  - Finding globals in 'X' for chunk #1 ...
[16:19:19.383] getGlobalsAndPackages() ...
[16:19:19.383] Searching for globals...
[16:19:19.383] 
[16:19:19.384] Searching for globals ... DONE
[16:19:19.384] - globals: [0] <none>
[16:19:19.384] getGlobalsAndPackages() ... DONE
[16:19:19.384]    + additional globals found: [n=0] 
[16:19:19.384]    + additional namespaces needed: [n=0] 
[16:19:19.384]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:19.384]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:19.384]  - seeds: <none>
[16:19:19.384]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.385] getGlobalsAndPackages() ...
[16:19:19.385] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.385] Resolving globals: FALSE
[16:19:19.385] Tweak future expression to call with '...' arguments ...
[16:19:19.385] {
[16:19:19.385]     do.call(function(...) {
[16:19:19.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.385]             on.exit(options(oopts), add = TRUE)
[16:19:19.385]         }
[16:19:19.385]         {
[16:19:19.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.385]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.385]             })
[16:19:19.385]         }
[16:19:19.385]     }, args = future.call.arguments)
[16:19:19.385] }
[16:19:19.385] Tweak future expression to call with '...' arguments ... DONE
[16:19:19.386] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.386] - packages: [2] ‘stats’, ‘future.apply’
[16:19:19.386] getGlobalsAndPackages() ... DONE
[16:19:19.386] run() for ‘Future’ ...
[16:19:19.386] - state: ‘created’
[16:19:19.386] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:19.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:19.400]   - Field: ‘node’
[16:19:19.401]   - Field: ‘label’
[16:19:19.401]   - Field: ‘local’
[16:19:19.401]   - Field: ‘owner’
[16:19:19.401]   - Field: ‘envir’
[16:19:19.401]   - Field: ‘workers’
[16:19:19.401]   - Field: ‘packages’
[16:19:19.401]   - Field: ‘gc’
[16:19:19.401]   - Field: ‘conditions’
[16:19:19.401]   - Field: ‘persistent’
[16:19:19.401]   - Field: ‘expr’
[16:19:19.402]   - Field: ‘uuid’
[16:19:19.402]   - Field: ‘seed’
[16:19:19.402]   - Field: ‘version’
[16:19:19.402]   - Field: ‘result’
[16:19:19.402]   - Field: ‘asynchronous’
[16:19:19.402]   - Field: ‘calls’
[16:19:19.402]   - Field: ‘globals’
[16:19:19.402]   - Field: ‘stdout’
[16:19:19.402]   - Field: ‘earlySignal’
[16:19:19.402]   - Field: ‘lazy’
[16:19:19.402]   - Field: ‘state’
[16:19:19.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:19.403] - Launch lazy future ...
[16:19:19.403] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:19.403] Packages needed by future strategies (n = 0): <none>
[16:19:19.404] {
[16:19:19.404]     {
[16:19:19.404]         {
[16:19:19.404]             ...future.startTime <- base::Sys.time()
[16:19:19.404]             {
[16:19:19.404]                 {
[16:19:19.404]                   {
[16:19:19.404]                     {
[16:19:19.404]                       {
[16:19:19.404]                         base::local({
[16:19:19.404]                           has_future <- base::requireNamespace("future", 
[16:19:19.404]                             quietly = TRUE)
[16:19:19.404]                           if (has_future) {
[16:19:19.404]                             ns <- base::getNamespace("future")
[16:19:19.404]                             version <- ns[[".package"]][["version"]]
[16:19:19.404]                             if (is.null(version)) 
[16:19:19.404]                               version <- utils::packageVersion("future")
[16:19:19.404]                           }
[16:19:19.404]                           else {
[16:19:19.404]                             version <- NULL
[16:19:19.404]                           }
[16:19:19.404]                           if (!has_future || version < "1.8.0") {
[16:19:19.404]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:19.404]                               "", base::R.version$version.string), 
[16:19:19.404]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:19.404]                                 base::R.version$platform, 8 * 
[16:19:19.404]                                   base::.Machine$sizeof.pointer), 
[16:19:19.404]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:19.404]                                 "release", "version")], collapse = " "), 
[16:19:19.404]                               hostname = base::Sys.info()[["nodename"]])
[16:19:19.404]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:19.404]                               info)
[16:19:19.404]                             info <- base::paste(info, collapse = "; ")
[16:19:19.404]                             if (!has_future) {
[16:19:19.404]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:19.404]                                 info)
[16:19:19.404]                             }
[16:19:19.404]                             else {
[16:19:19.404]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:19.404]                                 info, version)
[16:19:19.404]                             }
[16:19:19.404]                             base::stop(msg)
[16:19:19.404]                           }
[16:19:19.404]                         })
[16:19:19.404]                       }
[16:19:19.404]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:19.404]                       base::options(mc.cores = 1L)
[16:19:19.404]                     }
[16:19:19.404]                     base::local({
[16:19:19.404]                       for (pkg in c("stats", "future.apply")) {
[16:19:19.404]                         base::loadNamespace(pkg)
[16:19:19.404]                         base::library(pkg, character.only = TRUE)
[16:19:19.404]                       }
[16:19:19.404]                     })
[16:19:19.404]                   }
[16:19:19.404]                   ...future.strategy.old <- future::plan("list")
[16:19:19.404]                   options(future.plan = NULL)
[16:19:19.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:19.404]                 }
[16:19:19.404]                 ...future.workdir <- getwd()
[16:19:19.404]             }
[16:19:19.404]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:19.404]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:19.404]         }
[16:19:19.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:19.404]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:19.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:19.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:19.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:19.404]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:19.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:19.404]             base::names(...future.oldOptions))
[16:19:19.404]     }
[16:19:19.404]     if (FALSE) {
[16:19:19.404]     }
[16:19:19.404]     else {
[16:19:19.404]         if (TRUE) {
[16:19:19.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:19.404]                 open = "w")
[16:19:19.404]         }
[16:19:19.404]         else {
[16:19:19.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:19.404]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:19.404]         }
[16:19:19.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:19.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:19.404]             base::sink(type = "output", split = FALSE)
[16:19:19.404]             base::close(...future.stdout)
[16:19:19.404]         }, add = TRUE)
[16:19:19.404]     }
[16:19:19.404]     ...future.frame <- base::sys.nframe()
[16:19:19.404]     ...future.conditions <- base::list()
[16:19:19.404]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:19.404]     if (FALSE) {
[16:19:19.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:19.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:19.404]     }
[16:19:19.404]     ...future.result <- base::tryCatch({
[16:19:19.404]         base::withCallingHandlers({
[16:19:19.404]             ...future.value <- base::withVisible(base::local({
[16:19:19.404]                 ...future.makeSendCondition <- base::local({
[16:19:19.404]                   sendCondition <- NULL
[16:19:19.404]                   function(frame = 1L) {
[16:19:19.404]                     if (is.function(sendCondition)) 
[16:19:19.404]                       return(sendCondition)
[16:19:19.404]                     ns <- getNamespace("parallel")
[16:19:19.404]                     if (exists("sendData", mode = "function", 
[16:19:19.404]                       envir = ns)) {
[16:19:19.404]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:19.404]                         envir = ns)
[16:19:19.404]                       envir <- sys.frame(frame)
[16:19:19.404]                       master <- NULL
[16:19:19.404]                       while (!identical(envir, .GlobalEnv) && 
[16:19:19.404]                         !identical(envir, emptyenv())) {
[16:19:19.404]                         if (exists("master", mode = "list", envir = envir, 
[16:19:19.404]                           inherits = FALSE)) {
[16:19:19.404]                           master <- get("master", mode = "list", 
[16:19:19.404]                             envir = envir, inherits = FALSE)
[16:19:19.404]                           if (inherits(master, c("SOCKnode", 
[16:19:19.404]                             "SOCK0node"))) {
[16:19:19.404]                             sendCondition <<- function(cond) {
[16:19:19.404]                               data <- list(type = "VALUE", value = cond, 
[16:19:19.404]                                 success = TRUE)
[16:19:19.404]                               parallel_sendData(master, data)
[16:19:19.404]                             }
[16:19:19.404]                             return(sendCondition)
[16:19:19.404]                           }
[16:19:19.404]                         }
[16:19:19.404]                         frame <- frame + 1L
[16:19:19.404]                         envir <- sys.frame(frame)
[16:19:19.404]                       }
[16:19:19.404]                     }
[16:19:19.404]                     sendCondition <<- function(cond) NULL
[16:19:19.404]                   }
[16:19:19.404]                 })
[16:19:19.404]                 withCallingHandlers({
[16:19:19.404]                   {
[16:19:19.404]                     do.call(function(...) {
[16:19:19.404]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.404]                       if (!identical(...future.globals.maxSize.org, 
[16:19:19.404]                         ...future.globals.maxSize)) {
[16:19:19.404]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.404]                         on.exit(options(oopts), add = TRUE)
[16:19:19.404]                       }
[16:19:19.404]                       {
[16:19:19.404]                         lapply(seq_along(...future.elements_ii), 
[16:19:19.404]                           FUN = function(jj) {
[16:19:19.404]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.404]                             ...future.FUN(...future.X_jj, ...)
[16:19:19.404]                           })
[16:19:19.404]                       }
[16:19:19.404]                     }, args = future.call.arguments)
[16:19:19.404]                   }
[16:19:19.404]                 }, immediateCondition = function(cond) {
[16:19:19.404]                   sendCondition <- ...future.makeSendCondition()
[16:19:19.404]                   sendCondition(cond)
[16:19:19.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.404]                   {
[16:19:19.404]                     inherits <- base::inherits
[16:19:19.404]                     invokeRestart <- base::invokeRestart
[16:19:19.404]                     is.null <- base::is.null
[16:19:19.404]                     muffled <- FALSE
[16:19:19.404]                     if (inherits(cond, "message")) {
[16:19:19.404]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:19.404]                       if (muffled) 
[16:19:19.404]                         invokeRestart("muffleMessage")
[16:19:19.404]                     }
[16:19:19.404]                     else if (inherits(cond, "warning")) {
[16:19:19.404]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:19.404]                       if (muffled) 
[16:19:19.404]                         invokeRestart("muffleWarning")
[16:19:19.404]                     }
[16:19:19.404]                     else if (inherits(cond, "condition")) {
[16:19:19.404]                       if (!is.null(pattern)) {
[16:19:19.404]                         computeRestarts <- base::computeRestarts
[16:19:19.404]                         grepl <- base::grepl
[16:19:19.404]                         restarts <- computeRestarts(cond)
[16:19:19.404]                         for (restart in restarts) {
[16:19:19.404]                           name <- restart$name
[16:19:19.404]                           if (is.null(name)) 
[16:19:19.404]                             next
[16:19:19.404]                           if (!grepl(pattern, name)) 
[16:19:19.404]                             next
[16:19:19.404]                           invokeRestart(restart)
[16:19:19.404]                           muffled <- TRUE
[16:19:19.404]                           break
[16:19:19.404]                         }
[16:19:19.404]                       }
[16:19:19.404]                     }
[16:19:19.404]                     invisible(muffled)
[16:19:19.404]                   }
[16:19:19.404]                   muffleCondition(cond)
[16:19:19.404]                 })
[16:19:19.404]             }))
[16:19:19.404]             future::FutureResult(value = ...future.value$value, 
[16:19:19.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.404]                   ...future.rng), globalenv = if (FALSE) 
[16:19:19.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:19.404]                     ...future.globalenv.names))
[16:19:19.404]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:19.404]         }, condition = base::local({
[16:19:19.404]             c <- base::c
[16:19:19.404]             inherits <- base::inherits
[16:19:19.404]             invokeRestart <- base::invokeRestart
[16:19:19.404]             length <- base::length
[16:19:19.404]             list <- base::list
[16:19:19.404]             seq.int <- base::seq.int
[16:19:19.404]             signalCondition <- base::signalCondition
[16:19:19.404]             sys.calls <- base::sys.calls
[16:19:19.404]             `[[` <- base::`[[`
[16:19:19.404]             `+` <- base::`+`
[16:19:19.404]             `<<-` <- base::`<<-`
[16:19:19.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:19.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:19.404]                   3L)]
[16:19:19.404]             }
[16:19:19.404]             function(cond) {
[16:19:19.404]                 is_error <- inherits(cond, "error")
[16:19:19.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:19.404]                   NULL)
[16:19:19.404]                 if (is_error) {
[16:19:19.404]                   sessionInformation <- function() {
[16:19:19.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:19.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:19.404]                       search = base::search(), system = base::Sys.info())
[16:19:19.404]                   }
[16:19:19.404]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:19.404]                     cond$call), session = sessionInformation(), 
[16:19:19.404]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:19.404]                   signalCondition(cond)
[16:19:19.404]                 }
[16:19:19.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:19.404]                 "immediateCondition"))) {
[16:19:19.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:19.404]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:19.404]                   if (TRUE && !signal) {
[16:19:19.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.404]                     {
[16:19:19.404]                       inherits <- base::inherits
[16:19:19.404]                       invokeRestart <- base::invokeRestart
[16:19:19.404]                       is.null <- base::is.null
[16:19:19.404]                       muffled <- FALSE
[16:19:19.404]                       if (inherits(cond, "message")) {
[16:19:19.404]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.404]                         if (muffled) 
[16:19:19.404]                           invokeRestart("muffleMessage")
[16:19:19.404]                       }
[16:19:19.404]                       else if (inherits(cond, "warning")) {
[16:19:19.404]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.404]                         if (muffled) 
[16:19:19.404]                           invokeRestart("muffleWarning")
[16:19:19.404]                       }
[16:19:19.404]                       else if (inherits(cond, "condition")) {
[16:19:19.404]                         if (!is.null(pattern)) {
[16:19:19.404]                           computeRestarts <- base::computeRestarts
[16:19:19.404]                           grepl <- base::grepl
[16:19:19.404]                           restarts <- computeRestarts(cond)
[16:19:19.404]                           for (restart in restarts) {
[16:19:19.404]                             name <- restart$name
[16:19:19.404]                             if (is.null(name)) 
[16:19:19.404]                               next
[16:19:19.404]                             if (!grepl(pattern, name)) 
[16:19:19.404]                               next
[16:19:19.404]                             invokeRestart(restart)
[16:19:19.404]                             muffled <- TRUE
[16:19:19.404]                             break
[16:19:19.404]                           }
[16:19:19.404]                         }
[16:19:19.404]                       }
[16:19:19.404]                       invisible(muffled)
[16:19:19.404]                     }
[16:19:19.404]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.404]                   }
[16:19:19.404]                 }
[16:19:19.404]                 else {
[16:19:19.404]                   if (TRUE) {
[16:19:19.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.404]                     {
[16:19:19.404]                       inherits <- base::inherits
[16:19:19.404]                       invokeRestart <- base::invokeRestart
[16:19:19.404]                       is.null <- base::is.null
[16:19:19.404]                       muffled <- FALSE
[16:19:19.404]                       if (inherits(cond, "message")) {
[16:19:19.404]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.404]                         if (muffled) 
[16:19:19.404]                           invokeRestart("muffleMessage")
[16:19:19.404]                       }
[16:19:19.404]                       else if (inherits(cond, "warning")) {
[16:19:19.404]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.404]                         if (muffled) 
[16:19:19.404]                           invokeRestart("muffleWarning")
[16:19:19.404]                       }
[16:19:19.404]                       else if (inherits(cond, "condition")) {
[16:19:19.404]                         if (!is.null(pattern)) {
[16:19:19.404]                           computeRestarts <- base::computeRestarts
[16:19:19.404]                           grepl <- base::grepl
[16:19:19.404]                           restarts <- computeRestarts(cond)
[16:19:19.404]                           for (restart in restarts) {
[16:19:19.404]                             name <- restart$name
[16:19:19.404]                             if (is.null(name)) 
[16:19:19.404]                               next
[16:19:19.404]                             if (!grepl(pattern, name)) 
[16:19:19.404]                               next
[16:19:19.404]                             invokeRestart(restart)
[16:19:19.404]                             muffled <- TRUE
[16:19:19.404]                             break
[16:19:19.404]                           }
[16:19:19.404]                         }
[16:19:19.404]                       }
[16:19:19.404]                       invisible(muffled)
[16:19:19.404]                     }
[16:19:19.404]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.404]                   }
[16:19:19.404]                 }
[16:19:19.404]             }
[16:19:19.404]         }))
[16:19:19.404]     }, error = function(ex) {
[16:19:19.404]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:19.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.404]                 ...future.rng), started = ...future.startTime, 
[16:19:19.404]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:19.404]             version = "1.8"), class = "FutureResult")
[16:19:19.404]     }, finally = {
[16:19:19.404]         if (!identical(...future.workdir, getwd())) 
[16:19:19.404]             setwd(...future.workdir)
[16:19:19.404]         {
[16:19:19.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:19.404]                 ...future.oldOptions$nwarnings <- NULL
[16:19:19.404]             }
[16:19:19.404]             base::options(...future.oldOptions)
[16:19:19.404]             if (.Platform$OS.type == "windows") {
[16:19:19.404]                 old_names <- names(...future.oldEnvVars)
[16:19:19.404]                 envs <- base::Sys.getenv()
[16:19:19.404]                 names <- names(envs)
[16:19:19.404]                 common <- intersect(names, old_names)
[16:19:19.404]                 added <- setdiff(names, old_names)
[16:19:19.404]                 removed <- setdiff(old_names, names)
[16:19:19.404]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:19.404]                   envs[common]]
[16:19:19.404]                 NAMES <- toupper(changed)
[16:19:19.404]                 args <- list()
[16:19:19.404]                 for (kk in seq_along(NAMES)) {
[16:19:19.404]                   name <- changed[[kk]]
[16:19:19.404]                   NAME <- NAMES[[kk]]
[16:19:19.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.404]                     next
[16:19:19.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.404]                 }
[16:19:19.404]                 NAMES <- toupper(added)
[16:19:19.404]                 for (kk in seq_along(NAMES)) {
[16:19:19.404]                   name <- added[[kk]]
[16:19:19.404]                   NAME <- NAMES[[kk]]
[16:19:19.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.404]                     next
[16:19:19.404]                   args[[name]] <- ""
[16:19:19.404]                 }
[16:19:19.404]                 NAMES <- toupper(removed)
[16:19:19.404]                 for (kk in seq_along(NAMES)) {
[16:19:19.404]                   name <- removed[[kk]]
[16:19:19.404]                   NAME <- NAMES[[kk]]
[16:19:19.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.404]                     next
[16:19:19.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.404]                 }
[16:19:19.404]                 if (length(args) > 0) 
[16:19:19.404]                   base::do.call(base::Sys.setenv, args = args)
[16:19:19.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:19.404]             }
[16:19:19.404]             else {
[16:19:19.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:19.404]             }
[16:19:19.404]             {
[16:19:19.404]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:19.404]                   0L) {
[16:19:19.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:19.404]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:19.404]                   base::options(opts)
[16:19:19.404]                 }
[16:19:19.404]                 {
[16:19:19.404]                   {
[16:19:19.404]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:19.404]                     NULL
[16:19:19.404]                   }
[16:19:19.404]                   options(future.plan = NULL)
[16:19:19.404]                   if (is.na(NA_character_)) 
[16:19:19.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:19.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:19.404]                     .init = FALSE)
[16:19:19.404]                 }
[16:19:19.404]             }
[16:19:19.404]         }
[16:19:19.404]     })
[16:19:19.404]     if (TRUE) {
[16:19:19.404]         base::sink(type = "output", split = FALSE)
[16:19:19.404]         if (TRUE) {
[16:19:19.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:19.404]         }
[16:19:19.404]         else {
[16:19:19.404]             ...future.result["stdout"] <- base::list(NULL)
[16:19:19.404]         }
[16:19:19.404]         base::close(...future.stdout)
[16:19:19.404]         ...future.stdout <- NULL
[16:19:19.404]     }
[16:19:19.404]     ...future.result$conditions <- ...future.conditions
[16:19:19.404]     ...future.result$finished <- base::Sys.time()
[16:19:19.404]     ...future.result
[16:19:19.404] }
[16:19:19.406] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[16:19:19.407] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:19.449] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:19.449] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[16:19:19.449] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:19:19.449] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:19.450] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:19.450] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:19.492] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:19.493] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:19.536] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:19.537] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:19.537] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.537] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:19.538] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:19.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:19.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.538] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[16:19:19.539] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[16:19:19.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:19.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.539] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:19.540] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.540] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[16:19:19.540] MultisessionFuture started
[16:19:19.540] - Launch lazy future ... done
[16:19:19.541] run() for ‘MultisessionFuture’ ... done
[16:19:19.541] Created future:
[16:19:19.544] receiveMessageFromWorker() for ClusterFuture ...
[16:19:19.544] - Validating connection of MultisessionFuture
[16:19:19.544] - received message: FutureResult
[16:19:19.545] - Received FutureResult
[16:19:19.545] - Erased future from FutureRegistry
[16:19:19.545] result() for ClusterFuture ...
[16:19:19.545] - result already collected: FutureResult
[16:19:19.545] result() for ClusterFuture ... done
[16:19:19.545] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:19.541] MultisessionFuture:
[16:19:19.541] Label: ‘future_vapply-1’
[16:19:19.541] Expression:
[16:19:19.541] {
[16:19:19.541]     do.call(function(...) {
[16:19:19.541]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.541]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.541]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.541]             on.exit(options(oopts), add = TRUE)
[16:19:19.541]         }
[16:19:19.541]         {
[16:19:19.541]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.541]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.541]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.541]             })
[16:19:19.541]         }
[16:19:19.541]     }, args = future.call.arguments)
[16:19:19.541] }
[16:19:19.541] Lazy evaluation: FALSE
[16:19:19.541] Asynchronous evaluation: TRUE
[16:19:19.541] Local evaluation: TRUE
[16:19:19.541] Environment: R_GlobalEnv
[16:19:19.541] Capture standard output: TRUE
[16:19:19.541] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:19.541] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:19.541] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:19.541] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:19.541] Resolved: TRUE
[16:19:19.541] Value: <not collected>
[16:19:19.541] Conditions captured: <none>
[16:19:19.541] Early signaling: FALSE
[16:19:19.541] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:19.541] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.545] Chunk #1 of 2 ... DONE
[16:19:19.546] Chunk #2 of 2 ...
[16:19:19.546]  - Finding globals in 'X' for chunk #2 ...
[16:19:19.546] getGlobalsAndPackages() ...
[16:19:19.546] Searching for globals...
[16:19:19.546] 
[16:19:19.546] Searching for globals ... DONE
[16:19:19.546] - globals: [0] <none>
[16:19:19.546] getGlobalsAndPackages() ... DONE
[16:19:19.546]    + additional globals found: [n=0] 
[16:19:19.547]    + additional namespaces needed: [n=0] 
[16:19:19.547]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:19.547]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:19.547]  - seeds: <none>
[16:19:19.547]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.547] getGlobalsAndPackages() ...
[16:19:19.547] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.547] Resolving globals: FALSE
[16:19:19.547] Tweak future expression to call with '...' arguments ...
[16:19:19.547] {
[16:19:19.547]     do.call(function(...) {
[16:19:19.547]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.547]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.547]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.547]             on.exit(options(oopts), add = TRUE)
[16:19:19.547]         }
[16:19:19.547]         {
[16:19:19.547]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.547]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.547]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.547]             })
[16:19:19.547]         }
[16:19:19.547]     }, args = future.call.arguments)
[16:19:19.547] }
[16:19:19.548] Tweak future expression to call with '...' arguments ... DONE
[16:19:19.548] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.548] - packages: [2] ‘stats’, ‘future.apply’
[16:19:19.549] getGlobalsAndPackages() ... DONE
[16:19:19.549] run() for ‘Future’ ...
[16:19:19.549] - state: ‘created’
[16:19:19.549] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:19.563] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:19.563]   - Field: ‘node’
[16:19:19.563]   - Field: ‘label’
[16:19:19.563]   - Field: ‘local’
[16:19:19.563]   - Field: ‘owner’
[16:19:19.563]   - Field: ‘envir’
[16:19:19.564]   - Field: ‘workers’
[16:19:19.564]   - Field: ‘packages’
[16:19:19.564]   - Field: ‘gc’
[16:19:19.564]   - Field: ‘conditions’
[16:19:19.564]   - Field: ‘persistent’
[16:19:19.564]   - Field: ‘expr’
[16:19:19.564]   - Field: ‘uuid’
[16:19:19.564]   - Field: ‘seed’
[16:19:19.564]   - Field: ‘version’
[16:19:19.564]   - Field: ‘result’
[16:19:19.565]   - Field: ‘asynchronous’
[16:19:19.565]   - Field: ‘calls’
[16:19:19.565]   - Field: ‘globals’
[16:19:19.565]   - Field: ‘stdout’
[16:19:19.565]   - Field: ‘earlySignal’
[16:19:19.565]   - Field: ‘lazy’
[16:19:19.565]   - Field: ‘state’
[16:19:19.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:19.565] - Launch lazy future ...
[16:19:19.566] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:19.566] Packages needed by future strategies (n = 0): <none>
[16:19:19.566] {
[16:19:19.566]     {
[16:19:19.566]         {
[16:19:19.566]             ...future.startTime <- base::Sys.time()
[16:19:19.566]             {
[16:19:19.566]                 {
[16:19:19.566]                   {
[16:19:19.566]                     {
[16:19:19.566]                       {
[16:19:19.566]                         base::local({
[16:19:19.566]                           has_future <- base::requireNamespace("future", 
[16:19:19.566]                             quietly = TRUE)
[16:19:19.566]                           if (has_future) {
[16:19:19.566]                             ns <- base::getNamespace("future")
[16:19:19.566]                             version <- ns[[".package"]][["version"]]
[16:19:19.566]                             if (is.null(version)) 
[16:19:19.566]                               version <- utils::packageVersion("future")
[16:19:19.566]                           }
[16:19:19.566]                           else {
[16:19:19.566]                             version <- NULL
[16:19:19.566]                           }
[16:19:19.566]                           if (!has_future || version < "1.8.0") {
[16:19:19.566]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:19.566]                               "", base::R.version$version.string), 
[16:19:19.566]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:19.566]                                 base::R.version$platform, 8 * 
[16:19:19.566]                                   base::.Machine$sizeof.pointer), 
[16:19:19.566]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:19.566]                                 "release", "version")], collapse = " "), 
[16:19:19.566]                               hostname = base::Sys.info()[["nodename"]])
[16:19:19.566]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:19.566]                               info)
[16:19:19.566]                             info <- base::paste(info, collapse = "; ")
[16:19:19.566]                             if (!has_future) {
[16:19:19.566]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:19.566]                                 info)
[16:19:19.566]                             }
[16:19:19.566]                             else {
[16:19:19.566]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:19.566]                                 info, version)
[16:19:19.566]                             }
[16:19:19.566]                             base::stop(msg)
[16:19:19.566]                           }
[16:19:19.566]                         })
[16:19:19.566]                       }
[16:19:19.566]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:19.566]                       base::options(mc.cores = 1L)
[16:19:19.566]                     }
[16:19:19.566]                     base::local({
[16:19:19.566]                       for (pkg in c("stats", "future.apply")) {
[16:19:19.566]                         base::loadNamespace(pkg)
[16:19:19.566]                         base::library(pkg, character.only = TRUE)
[16:19:19.566]                       }
[16:19:19.566]                     })
[16:19:19.566]                   }
[16:19:19.566]                   ...future.strategy.old <- future::plan("list")
[16:19:19.566]                   options(future.plan = NULL)
[16:19:19.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:19.566]                 }
[16:19:19.566]                 ...future.workdir <- getwd()
[16:19:19.566]             }
[16:19:19.566]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:19.566]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:19.566]         }
[16:19:19.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:19.566]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:19.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:19.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:19.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:19.566]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:19.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:19.566]             base::names(...future.oldOptions))
[16:19:19.566]     }
[16:19:19.566]     if (FALSE) {
[16:19:19.566]     }
[16:19:19.566]     else {
[16:19:19.566]         if (TRUE) {
[16:19:19.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:19.566]                 open = "w")
[16:19:19.566]         }
[16:19:19.566]         else {
[16:19:19.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:19.566]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:19.566]         }
[16:19:19.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:19.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:19.566]             base::sink(type = "output", split = FALSE)
[16:19:19.566]             base::close(...future.stdout)
[16:19:19.566]         }, add = TRUE)
[16:19:19.566]     }
[16:19:19.566]     ...future.frame <- base::sys.nframe()
[16:19:19.566]     ...future.conditions <- base::list()
[16:19:19.566]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:19.566]     if (FALSE) {
[16:19:19.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:19.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:19.566]     }
[16:19:19.566]     ...future.result <- base::tryCatch({
[16:19:19.566]         base::withCallingHandlers({
[16:19:19.566]             ...future.value <- base::withVisible(base::local({
[16:19:19.566]                 ...future.makeSendCondition <- base::local({
[16:19:19.566]                   sendCondition <- NULL
[16:19:19.566]                   function(frame = 1L) {
[16:19:19.566]                     if (is.function(sendCondition)) 
[16:19:19.566]                       return(sendCondition)
[16:19:19.566]                     ns <- getNamespace("parallel")
[16:19:19.566]                     if (exists("sendData", mode = "function", 
[16:19:19.566]                       envir = ns)) {
[16:19:19.566]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:19.566]                         envir = ns)
[16:19:19.566]                       envir <- sys.frame(frame)
[16:19:19.566]                       master <- NULL
[16:19:19.566]                       while (!identical(envir, .GlobalEnv) && 
[16:19:19.566]                         !identical(envir, emptyenv())) {
[16:19:19.566]                         if (exists("master", mode = "list", envir = envir, 
[16:19:19.566]                           inherits = FALSE)) {
[16:19:19.566]                           master <- get("master", mode = "list", 
[16:19:19.566]                             envir = envir, inherits = FALSE)
[16:19:19.566]                           if (inherits(master, c("SOCKnode", 
[16:19:19.566]                             "SOCK0node"))) {
[16:19:19.566]                             sendCondition <<- function(cond) {
[16:19:19.566]                               data <- list(type = "VALUE", value = cond, 
[16:19:19.566]                                 success = TRUE)
[16:19:19.566]                               parallel_sendData(master, data)
[16:19:19.566]                             }
[16:19:19.566]                             return(sendCondition)
[16:19:19.566]                           }
[16:19:19.566]                         }
[16:19:19.566]                         frame <- frame + 1L
[16:19:19.566]                         envir <- sys.frame(frame)
[16:19:19.566]                       }
[16:19:19.566]                     }
[16:19:19.566]                     sendCondition <<- function(cond) NULL
[16:19:19.566]                   }
[16:19:19.566]                 })
[16:19:19.566]                 withCallingHandlers({
[16:19:19.566]                   {
[16:19:19.566]                     do.call(function(...) {
[16:19:19.566]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.566]                       if (!identical(...future.globals.maxSize.org, 
[16:19:19.566]                         ...future.globals.maxSize)) {
[16:19:19.566]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.566]                         on.exit(options(oopts), add = TRUE)
[16:19:19.566]                       }
[16:19:19.566]                       {
[16:19:19.566]                         lapply(seq_along(...future.elements_ii), 
[16:19:19.566]                           FUN = function(jj) {
[16:19:19.566]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.566]                             ...future.FUN(...future.X_jj, ...)
[16:19:19.566]                           })
[16:19:19.566]                       }
[16:19:19.566]                     }, args = future.call.arguments)
[16:19:19.566]                   }
[16:19:19.566]                 }, immediateCondition = function(cond) {
[16:19:19.566]                   sendCondition <- ...future.makeSendCondition()
[16:19:19.566]                   sendCondition(cond)
[16:19:19.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.566]                   {
[16:19:19.566]                     inherits <- base::inherits
[16:19:19.566]                     invokeRestart <- base::invokeRestart
[16:19:19.566]                     is.null <- base::is.null
[16:19:19.566]                     muffled <- FALSE
[16:19:19.566]                     if (inherits(cond, "message")) {
[16:19:19.566]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:19.566]                       if (muffled) 
[16:19:19.566]                         invokeRestart("muffleMessage")
[16:19:19.566]                     }
[16:19:19.566]                     else if (inherits(cond, "warning")) {
[16:19:19.566]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:19.566]                       if (muffled) 
[16:19:19.566]                         invokeRestart("muffleWarning")
[16:19:19.566]                     }
[16:19:19.566]                     else if (inherits(cond, "condition")) {
[16:19:19.566]                       if (!is.null(pattern)) {
[16:19:19.566]                         computeRestarts <- base::computeRestarts
[16:19:19.566]                         grepl <- base::grepl
[16:19:19.566]                         restarts <- computeRestarts(cond)
[16:19:19.566]                         for (restart in restarts) {
[16:19:19.566]                           name <- restart$name
[16:19:19.566]                           if (is.null(name)) 
[16:19:19.566]                             next
[16:19:19.566]                           if (!grepl(pattern, name)) 
[16:19:19.566]                             next
[16:19:19.566]                           invokeRestart(restart)
[16:19:19.566]                           muffled <- TRUE
[16:19:19.566]                           break
[16:19:19.566]                         }
[16:19:19.566]                       }
[16:19:19.566]                     }
[16:19:19.566]                     invisible(muffled)
[16:19:19.566]                   }
[16:19:19.566]                   muffleCondition(cond)
[16:19:19.566]                 })
[16:19:19.566]             }))
[16:19:19.566]             future::FutureResult(value = ...future.value$value, 
[16:19:19.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.566]                   ...future.rng), globalenv = if (FALSE) 
[16:19:19.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:19.566]                     ...future.globalenv.names))
[16:19:19.566]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:19.566]         }, condition = base::local({
[16:19:19.566]             c <- base::c
[16:19:19.566]             inherits <- base::inherits
[16:19:19.566]             invokeRestart <- base::invokeRestart
[16:19:19.566]             length <- base::length
[16:19:19.566]             list <- base::list
[16:19:19.566]             seq.int <- base::seq.int
[16:19:19.566]             signalCondition <- base::signalCondition
[16:19:19.566]             sys.calls <- base::sys.calls
[16:19:19.566]             `[[` <- base::`[[`
[16:19:19.566]             `+` <- base::`+`
[16:19:19.566]             `<<-` <- base::`<<-`
[16:19:19.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:19.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:19.566]                   3L)]
[16:19:19.566]             }
[16:19:19.566]             function(cond) {
[16:19:19.566]                 is_error <- inherits(cond, "error")
[16:19:19.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:19.566]                   NULL)
[16:19:19.566]                 if (is_error) {
[16:19:19.566]                   sessionInformation <- function() {
[16:19:19.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:19.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:19.566]                       search = base::search(), system = base::Sys.info())
[16:19:19.566]                   }
[16:19:19.566]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:19.566]                     cond$call), session = sessionInformation(), 
[16:19:19.566]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:19.566]                   signalCondition(cond)
[16:19:19.566]                 }
[16:19:19.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:19.566]                 "immediateCondition"))) {
[16:19:19.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:19.566]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:19.566]                   if (TRUE && !signal) {
[16:19:19.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.566]                     {
[16:19:19.566]                       inherits <- base::inherits
[16:19:19.566]                       invokeRestart <- base::invokeRestart
[16:19:19.566]                       is.null <- base::is.null
[16:19:19.566]                       muffled <- FALSE
[16:19:19.566]                       if (inherits(cond, "message")) {
[16:19:19.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.566]                         if (muffled) 
[16:19:19.566]                           invokeRestart("muffleMessage")
[16:19:19.566]                       }
[16:19:19.566]                       else if (inherits(cond, "warning")) {
[16:19:19.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.566]                         if (muffled) 
[16:19:19.566]                           invokeRestart("muffleWarning")
[16:19:19.566]                       }
[16:19:19.566]                       else if (inherits(cond, "condition")) {
[16:19:19.566]                         if (!is.null(pattern)) {
[16:19:19.566]                           computeRestarts <- base::computeRestarts
[16:19:19.566]                           grepl <- base::grepl
[16:19:19.566]                           restarts <- computeRestarts(cond)
[16:19:19.566]                           for (restart in restarts) {
[16:19:19.566]                             name <- restart$name
[16:19:19.566]                             if (is.null(name)) 
[16:19:19.566]                               next
[16:19:19.566]                             if (!grepl(pattern, name)) 
[16:19:19.566]                               next
[16:19:19.566]                             invokeRestart(restart)
[16:19:19.566]                             muffled <- TRUE
[16:19:19.566]                             break
[16:19:19.566]                           }
[16:19:19.566]                         }
[16:19:19.566]                       }
[16:19:19.566]                       invisible(muffled)
[16:19:19.566]                     }
[16:19:19.566]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.566]                   }
[16:19:19.566]                 }
[16:19:19.566]                 else {
[16:19:19.566]                   if (TRUE) {
[16:19:19.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.566]                     {
[16:19:19.566]                       inherits <- base::inherits
[16:19:19.566]                       invokeRestart <- base::invokeRestart
[16:19:19.566]                       is.null <- base::is.null
[16:19:19.566]                       muffled <- FALSE
[16:19:19.566]                       if (inherits(cond, "message")) {
[16:19:19.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.566]                         if (muffled) 
[16:19:19.566]                           invokeRestart("muffleMessage")
[16:19:19.566]                       }
[16:19:19.566]                       else if (inherits(cond, "warning")) {
[16:19:19.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.566]                         if (muffled) 
[16:19:19.566]                           invokeRestart("muffleWarning")
[16:19:19.566]                       }
[16:19:19.566]                       else if (inherits(cond, "condition")) {
[16:19:19.566]                         if (!is.null(pattern)) {
[16:19:19.566]                           computeRestarts <- base::computeRestarts
[16:19:19.566]                           grepl <- base::grepl
[16:19:19.566]                           restarts <- computeRestarts(cond)
[16:19:19.566]                           for (restart in restarts) {
[16:19:19.566]                             name <- restart$name
[16:19:19.566]                             if (is.null(name)) 
[16:19:19.566]                               next
[16:19:19.566]                             if (!grepl(pattern, name)) 
[16:19:19.566]                               next
[16:19:19.566]                             invokeRestart(restart)
[16:19:19.566]                             muffled <- TRUE
[16:19:19.566]                             break
[16:19:19.566]                           }
[16:19:19.566]                         }
[16:19:19.566]                       }
[16:19:19.566]                       invisible(muffled)
[16:19:19.566]                     }
[16:19:19.566]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.566]                   }
[16:19:19.566]                 }
[16:19:19.566]             }
[16:19:19.566]         }))
[16:19:19.566]     }, error = function(ex) {
[16:19:19.566]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:19.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.566]                 ...future.rng), started = ...future.startTime, 
[16:19:19.566]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:19.566]             version = "1.8"), class = "FutureResult")
[16:19:19.566]     }, finally = {
[16:19:19.566]         if (!identical(...future.workdir, getwd())) 
[16:19:19.566]             setwd(...future.workdir)
[16:19:19.566]         {
[16:19:19.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:19.566]                 ...future.oldOptions$nwarnings <- NULL
[16:19:19.566]             }
[16:19:19.566]             base::options(...future.oldOptions)
[16:19:19.566]             if (.Platform$OS.type == "windows") {
[16:19:19.566]                 old_names <- names(...future.oldEnvVars)
[16:19:19.566]                 envs <- base::Sys.getenv()
[16:19:19.566]                 names <- names(envs)
[16:19:19.566]                 common <- intersect(names, old_names)
[16:19:19.566]                 added <- setdiff(names, old_names)
[16:19:19.566]                 removed <- setdiff(old_names, names)
[16:19:19.566]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:19.566]                   envs[common]]
[16:19:19.566]                 NAMES <- toupper(changed)
[16:19:19.566]                 args <- list()
[16:19:19.566]                 for (kk in seq_along(NAMES)) {
[16:19:19.566]                   name <- changed[[kk]]
[16:19:19.566]                   NAME <- NAMES[[kk]]
[16:19:19.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.566]                     next
[16:19:19.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.566]                 }
[16:19:19.566]                 NAMES <- toupper(added)
[16:19:19.566]                 for (kk in seq_along(NAMES)) {
[16:19:19.566]                   name <- added[[kk]]
[16:19:19.566]                   NAME <- NAMES[[kk]]
[16:19:19.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.566]                     next
[16:19:19.566]                   args[[name]] <- ""
[16:19:19.566]                 }
[16:19:19.566]                 NAMES <- toupper(removed)
[16:19:19.566]                 for (kk in seq_along(NAMES)) {
[16:19:19.566]                   name <- removed[[kk]]
[16:19:19.566]                   NAME <- NAMES[[kk]]
[16:19:19.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.566]                     next
[16:19:19.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.566]                 }
[16:19:19.566]                 if (length(args) > 0) 
[16:19:19.566]                   base::do.call(base::Sys.setenv, args = args)
[16:19:19.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:19.566]             }
[16:19:19.566]             else {
[16:19:19.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:19.566]             }
[16:19:19.566]             {
[16:19:19.566]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:19.566]                   0L) {
[16:19:19.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:19.566]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:19.566]                   base::options(opts)
[16:19:19.566]                 }
[16:19:19.566]                 {
[16:19:19.566]                   {
[16:19:19.566]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:19.566]                     NULL
[16:19:19.566]                   }
[16:19:19.566]                   options(future.plan = NULL)
[16:19:19.566]                   if (is.na(NA_character_)) 
[16:19:19.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:19.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:19.566]                     .init = FALSE)
[16:19:19.566]                 }
[16:19:19.566]             }
[16:19:19.566]         }
[16:19:19.566]     })
[16:19:19.566]     if (TRUE) {
[16:19:19.566]         base::sink(type = "output", split = FALSE)
[16:19:19.566]         if (TRUE) {
[16:19:19.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:19.566]         }
[16:19:19.566]         else {
[16:19:19.566]             ...future.result["stdout"] <- base::list(NULL)
[16:19:19.566]         }
[16:19:19.566]         base::close(...future.stdout)
[16:19:19.566]         ...future.stdout <- NULL
[16:19:19.566]     }
[16:19:19.566]     ...future.result$conditions <- ...future.conditions
[16:19:19.566]     ...future.result$finished <- base::Sys.time()
[16:19:19.566]     ...future.result
[16:19:19.566] }
[16:19:19.569] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[16:19:19.569] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:19.612] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:19.613] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[16:19:19.613] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:19:19.613] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:19.614] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:19.614] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:19.656] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:19.657] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:19.701] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:19.701] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:19.701] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.701] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:19.702] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:19.702] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:19.702] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.703] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ...
[16:19:19.703] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ... DONE
[16:19:19.703] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:19.703] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.704] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:19.704] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.704] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[16:19:19.705] MultisessionFuture started
[16:19:19.705] - Launch lazy future ... done
[16:19:19.705] run() for ‘MultisessionFuture’ ... done
[16:19:19.705] Created future:
[16:19:19.705] MultisessionFuture:
[16:19:19.705] Label: ‘future_vapply-2’
[16:19:19.705] Expression:
[16:19:19.705] {
[16:19:19.705]     do.call(function(...) {
[16:19:19.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.705]             on.exit(options(oopts), add = TRUE)
[16:19:19.705]         }
[16:19:19.705]         {
[16:19:19.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.705]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.705]             })
[16:19:19.705]         }
[16:19:19.705]     }, args = future.call.arguments)
[16:19:19.705] }
[16:19:19.705] Lazy evaluation: FALSE
[16:19:19.705] Asynchronous evaluation: TRUE
[16:19:19.705] Local evaluation: TRUE
[16:19:19.705] Environment: R_GlobalEnv
[16:19:19.705] Capture standard output: TRUE
[16:19:19.705] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:19.705] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:19.705] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:19.705] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:19.705] Resolved: FALSE
[16:19:19.705] Value: <not collected>
[16:19:19.705] Conditions captured: <none>
[16:19:19.705] Early signaling: FALSE
[16:19:19.705] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:19.705] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.717] Chunk #2 of 2 ... DONE
[16:19:19.717] Launching 2 futures (chunks) ... DONE
[16:19:19.717] Resolving 2 futures (chunks) ...
[16:19:19.717] resolve() on list ...
[16:19:19.717]  recursive: 0
[16:19:19.717]  length: 2
[16:19:19.718] 
[16:19:19.718] Future #1
[16:19:19.718] result() for ClusterFuture ...
[16:19:19.718] - result already collected: FutureResult
[16:19:19.718] result() for ClusterFuture ... done
[16:19:19.718] result() for ClusterFuture ...
[16:19:19.718] - result already collected: FutureResult
[16:19:19.718] result() for ClusterFuture ... done
[16:19:19.718] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:19.718] - nx: 2
[16:19:19.719] - relay: TRUE
[16:19:19.719] - stdout: TRUE
[16:19:19.719] - signal: TRUE
[16:19:19.719] - resignal: FALSE
[16:19:19.719] - force: TRUE
[16:19:19.719] - relayed: [n=2] FALSE, FALSE
[16:19:19.719] - queued futures: [n=2] FALSE, FALSE
[16:19:19.719]  - until=1
[16:19:19.719]  - relaying element #1
[16:19:19.719] result() for ClusterFuture ...
[16:19:19.719] - result already collected: FutureResult
[16:19:19.719] result() for ClusterFuture ... done
[16:19:19.720] result() for ClusterFuture ...
[16:19:19.720] - result already collected: FutureResult
[16:19:19.720] result() for ClusterFuture ... done
[16:19:19.720] result() for ClusterFuture ...
[16:19:19.720] - result already collected: FutureResult
[16:19:19.720] result() for ClusterFuture ... done
[16:19:19.720] result() for ClusterFuture ...
[16:19:19.720] - result already collected: FutureResult
[16:19:19.720] result() for ClusterFuture ... done
[16:19:19.720] - relayed: [n=2] TRUE, FALSE
[16:19:19.720] - queued futures: [n=2] TRUE, FALSE
[16:19:19.721] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:19.721]  length: 1 (resolved future 1)
[16:19:19.762] receiveMessageFromWorker() for ClusterFuture ...
[16:19:19.762] - Validating connection of MultisessionFuture
[16:19:19.763] - received message: FutureResult
[16:19:19.763] - Received FutureResult
[16:19:19.763] - Erased future from FutureRegistry
[16:19:19.763] result() for ClusterFuture ...
[16:19:19.763] - result already collected: FutureResult
[16:19:19.763] result() for ClusterFuture ... done
[16:19:19.763] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:19.763] Future #2
[16:19:19.763] result() for ClusterFuture ...
[16:19:19.763] - result already collected: FutureResult
[16:19:19.764] result() for ClusterFuture ... done
[16:19:19.764] result() for ClusterFuture ...
[16:19:19.764] - result already collected: FutureResult
[16:19:19.764] result() for ClusterFuture ... done
[16:19:19.764] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:19.764] - nx: 2
[16:19:19.764] - relay: TRUE
[16:19:19.764] - stdout: TRUE
[16:19:19.764] - signal: TRUE
[16:19:19.764] - resignal: FALSE
[16:19:19.764] - force: TRUE
[16:19:19.765] - relayed: [n=2] TRUE, FALSE
[16:19:19.765] - queued futures: [n=2] TRUE, FALSE
[16:19:19.765]  - until=2
[16:19:19.765]  - relaying element #2
[16:19:19.765] result() for ClusterFuture ...
[16:19:19.765] - result already collected: FutureResult
[16:19:19.765] result() for ClusterFuture ... done
[16:19:19.765] result() for ClusterFuture ...
[16:19:19.765] - result already collected: FutureResult
[16:19:19.765] result() for ClusterFuture ... done
[16:19:19.765] result() for ClusterFuture ...
[16:19:19.766] - result already collected: FutureResult
[16:19:19.766] result() for ClusterFuture ... done
[16:19:19.766] result() for ClusterFuture ...
[16:19:19.766] - result already collected: FutureResult
[16:19:19.766] result() for ClusterFuture ... done
[16:19:19.766] - relayed: [n=2] TRUE, TRUE
[16:19:19.766] - queued futures: [n=2] TRUE, TRUE
[16:19:19.766] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:19.766]  length: 0 (resolved future 2)
[16:19:19.766] Relaying remaining futures
[16:19:19.766] signalConditionsASAP(NULL, pos=0) ...
[16:19:19.767] - nx: 2
[16:19:19.767] - relay: TRUE
[16:19:19.767] - stdout: TRUE
[16:19:19.767] - signal: TRUE
[16:19:19.767] - resignal: FALSE
[16:19:19.767] - force: TRUE
[16:19:19.767] - relayed: [n=2] TRUE, TRUE
[16:19:19.767] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:19.767] - relayed: [n=2] TRUE, TRUE
[16:19:19.767] - queued futures: [n=2] TRUE, TRUE
[16:19:19.767] signalConditionsASAP(NULL, pos=0) ... done
[16:19:19.768] resolve() on list ... DONE
[16:19:19.768] result() for ClusterFuture ...
[16:19:19.768] - result already collected: FutureResult
[16:19:19.768] result() for ClusterFuture ... done
[16:19:19.768] result() for ClusterFuture ...
[16:19:19.768] - result already collected: FutureResult
[16:19:19.768] result() for ClusterFuture ... done
[16:19:19.768] result() for ClusterFuture ...
[16:19:19.768] - result already collected: FutureResult
[16:19:19.768] result() for ClusterFuture ... done
[16:19:19.768] result() for ClusterFuture ...
[16:19:19.768] - result already collected: FutureResult
[16:19:19.769] result() for ClusterFuture ... done
[16:19:19.769]  - Number of value chunks collected: 2
[16:19:19.769] Resolving 2 futures (chunks) ... DONE
[16:19:19.769] Reducing values from 2 chunks ...
[16:19:19.769]  - Number of values collected after concatenation: 3
[16:19:19.769]  - Number of values expected: 3
[16:19:19.769] Reducing values from 2 chunks ... DONE
[16:19:19.769] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:19:19.771] future_lapply() ...
[16:19:19.779] Number of chunks: 2
[16:19:19.779] getGlobalsAndPackagesXApply() ...
[16:19:19.779]  - future.globals: TRUE
[16:19:19.779] getGlobalsAndPackages() ...
[16:19:19.779] Searching for globals...
[16:19:19.784] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:19:19.784] Searching for globals ... DONE
[16:19:19.784] Resolving globals: FALSE
[16:19:19.785] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:19:19.785] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:19:19.785] - globals: [1] ‘FUN’
[16:19:19.785] - packages: [1] ‘stats’
[16:19:19.786] getGlobalsAndPackages() ... DONE
[16:19:19.786]  - globals found/used: [n=1] ‘FUN’
[16:19:19.786]  - needed namespaces: [n=1] ‘stats’
[16:19:19.786] Finding globals ... DONE
[16:19:19.786]  - use_args: TRUE
[16:19:19.786]  - Getting '...' globals ...
[16:19:19.786] resolve() on list ...
[16:19:19.786]  recursive: 0
[16:19:19.786]  length: 1
[16:19:19.787]  elements: ‘...’
[16:19:19.787]  length: 0 (resolved future 1)
[16:19:19.787] resolve() on list ... DONE
[16:19:19.787]    - '...' content: [n=0] 
[16:19:19.787] List of 1
[16:19:19.787]  $ ...: list()
[16:19:19.787]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:19.787]  - attr(*, "where")=List of 1
[16:19:19.787]   ..$ ...:<environment: 0x5619a057b768> 
[16:19:19.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:19.787]  - attr(*, "resolved")= logi TRUE
[16:19:19.787]  - attr(*, "total_size")= num NA
[16:19:19.789]  - Getting '...' globals ... DONE
[16:19:19.790] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:19.790] List of 2
[16:19:19.790]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:19:19.790]  $ ...          : list()
[16:19:19.790]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:19.790]  - attr(*, "where")=List of 2
[16:19:19.790]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:19.790]   ..$ ...          :<environment: 0x5619a057b768> 
[16:19:19.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:19.790]  - attr(*, "resolved")= logi FALSE
[16:19:19.790]  - attr(*, "total_size")= num 46960
[16:19:19.792] Packages to be attached in all futures: [n=1] ‘stats’
[16:19:19.793] getGlobalsAndPackagesXApply() ... DONE
[16:19:19.793] Number of futures (= number of chunks): 2
[16:19:19.793] Launching 2 futures (chunks) ...
[16:19:19.793] Chunk #1 of 2 ...
[16:19:19.793]  - Finding globals in 'X' for chunk #1 ...
[16:19:19.793] getGlobalsAndPackages() ...
[16:19:19.793] Searching for globals...
[16:19:19.794] 
[16:19:19.794] Searching for globals ... DONE
[16:19:19.794] - globals: [0] <none>
[16:19:19.794] getGlobalsAndPackages() ... DONE
[16:19:19.794]    + additional globals found: [n=0] 
[16:19:19.794]    + additional namespaces needed: [n=0] 
[16:19:19.794]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:19.794]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:19.794]  - seeds: <none>
[16:19:19.794]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.794] getGlobalsAndPackages() ...
[16:19:19.795] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.795] Resolving globals: FALSE
[16:19:19.795] Tweak future expression to call with '...' arguments ...
[16:19:19.795] {
[16:19:19.795]     do.call(function(...) {
[16:19:19.795]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.795]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.795]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.795]             on.exit(options(oopts), add = TRUE)
[16:19:19.795]         }
[16:19:19.795]         {
[16:19:19.795]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.795]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.795]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.795]             })
[16:19:19.795]         }
[16:19:19.795]     }, args = future.call.arguments)
[16:19:19.795] }
[16:19:19.795] Tweak future expression to call with '...' arguments ... DONE
[16:19:19.795] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.796] - packages: [1] ‘stats’
[16:19:19.796] getGlobalsAndPackages() ... DONE
[16:19:19.796] run() for ‘Future’ ...
[16:19:19.796] - state: ‘created’
[16:19:19.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:19.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:19.810]   - Field: ‘node’
[16:19:19.810]   - Field: ‘label’
[16:19:19.810]   - Field: ‘local’
[16:19:19.811]   - Field: ‘owner’
[16:19:19.811]   - Field: ‘envir’
[16:19:19.811]   - Field: ‘workers’
[16:19:19.811]   - Field: ‘packages’
[16:19:19.811]   - Field: ‘gc’
[16:19:19.811]   - Field: ‘conditions’
[16:19:19.811]   - Field: ‘persistent’
[16:19:19.811]   - Field: ‘expr’
[16:19:19.811]   - Field: ‘uuid’
[16:19:19.811]   - Field: ‘seed’
[16:19:19.811]   - Field: ‘version’
[16:19:19.811]   - Field: ‘result’
[16:19:19.812]   - Field: ‘asynchronous’
[16:19:19.812]   - Field: ‘calls’
[16:19:19.812]   - Field: ‘globals’
[16:19:19.812]   - Field: ‘stdout’
[16:19:19.812]   - Field: ‘earlySignal’
[16:19:19.812]   - Field: ‘lazy’
[16:19:19.812]   - Field: ‘state’
[16:19:19.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:19.812] - Launch lazy future ...
[16:19:19.813] Packages needed by the future expression (n = 1): ‘stats’
[16:19:19.813] Packages needed by future strategies (n = 0): <none>
[16:19:19.813] {
[16:19:19.813]     {
[16:19:19.813]         {
[16:19:19.813]             ...future.startTime <- base::Sys.time()
[16:19:19.813]             {
[16:19:19.813]                 {
[16:19:19.813]                   {
[16:19:19.813]                     {
[16:19:19.813]                       {
[16:19:19.813]                         base::local({
[16:19:19.813]                           has_future <- base::requireNamespace("future", 
[16:19:19.813]                             quietly = TRUE)
[16:19:19.813]                           if (has_future) {
[16:19:19.813]                             ns <- base::getNamespace("future")
[16:19:19.813]                             version <- ns[[".package"]][["version"]]
[16:19:19.813]                             if (is.null(version)) 
[16:19:19.813]                               version <- utils::packageVersion("future")
[16:19:19.813]                           }
[16:19:19.813]                           else {
[16:19:19.813]                             version <- NULL
[16:19:19.813]                           }
[16:19:19.813]                           if (!has_future || version < "1.8.0") {
[16:19:19.813]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:19.813]                               "", base::R.version$version.string), 
[16:19:19.813]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:19.813]                                 base::R.version$platform, 8 * 
[16:19:19.813]                                   base::.Machine$sizeof.pointer), 
[16:19:19.813]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:19.813]                                 "release", "version")], collapse = " "), 
[16:19:19.813]                               hostname = base::Sys.info()[["nodename"]])
[16:19:19.813]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:19.813]                               info)
[16:19:19.813]                             info <- base::paste(info, collapse = "; ")
[16:19:19.813]                             if (!has_future) {
[16:19:19.813]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:19.813]                                 info)
[16:19:19.813]                             }
[16:19:19.813]                             else {
[16:19:19.813]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:19.813]                                 info, version)
[16:19:19.813]                             }
[16:19:19.813]                             base::stop(msg)
[16:19:19.813]                           }
[16:19:19.813]                         })
[16:19:19.813]                       }
[16:19:19.813]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:19.813]                       base::options(mc.cores = 1L)
[16:19:19.813]                     }
[16:19:19.813]                     base::local({
[16:19:19.813]                       for (pkg in "stats") {
[16:19:19.813]                         base::loadNamespace(pkg)
[16:19:19.813]                         base::library(pkg, character.only = TRUE)
[16:19:19.813]                       }
[16:19:19.813]                     })
[16:19:19.813]                   }
[16:19:19.813]                   ...future.strategy.old <- future::plan("list")
[16:19:19.813]                   options(future.plan = NULL)
[16:19:19.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:19.813]                 }
[16:19:19.813]                 ...future.workdir <- getwd()
[16:19:19.813]             }
[16:19:19.813]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:19.813]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:19.813]         }
[16:19:19.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:19.813]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:19.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:19.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:19.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:19.813]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:19.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:19.813]             base::names(...future.oldOptions))
[16:19:19.813]     }
[16:19:19.813]     if (FALSE) {
[16:19:19.813]     }
[16:19:19.813]     else {
[16:19:19.813]         if (TRUE) {
[16:19:19.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:19.813]                 open = "w")
[16:19:19.813]         }
[16:19:19.813]         else {
[16:19:19.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:19.813]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:19.813]         }
[16:19:19.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:19.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:19.813]             base::sink(type = "output", split = FALSE)
[16:19:19.813]             base::close(...future.stdout)
[16:19:19.813]         }, add = TRUE)
[16:19:19.813]     }
[16:19:19.813]     ...future.frame <- base::sys.nframe()
[16:19:19.813]     ...future.conditions <- base::list()
[16:19:19.813]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:19.813]     if (FALSE) {
[16:19:19.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:19.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:19.813]     }
[16:19:19.813]     ...future.result <- base::tryCatch({
[16:19:19.813]         base::withCallingHandlers({
[16:19:19.813]             ...future.value <- base::withVisible(base::local({
[16:19:19.813]                 ...future.makeSendCondition <- base::local({
[16:19:19.813]                   sendCondition <- NULL
[16:19:19.813]                   function(frame = 1L) {
[16:19:19.813]                     if (is.function(sendCondition)) 
[16:19:19.813]                       return(sendCondition)
[16:19:19.813]                     ns <- getNamespace("parallel")
[16:19:19.813]                     if (exists("sendData", mode = "function", 
[16:19:19.813]                       envir = ns)) {
[16:19:19.813]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:19.813]                         envir = ns)
[16:19:19.813]                       envir <- sys.frame(frame)
[16:19:19.813]                       master <- NULL
[16:19:19.813]                       while (!identical(envir, .GlobalEnv) && 
[16:19:19.813]                         !identical(envir, emptyenv())) {
[16:19:19.813]                         if (exists("master", mode = "list", envir = envir, 
[16:19:19.813]                           inherits = FALSE)) {
[16:19:19.813]                           master <- get("master", mode = "list", 
[16:19:19.813]                             envir = envir, inherits = FALSE)
[16:19:19.813]                           if (inherits(master, c("SOCKnode", 
[16:19:19.813]                             "SOCK0node"))) {
[16:19:19.813]                             sendCondition <<- function(cond) {
[16:19:19.813]                               data <- list(type = "VALUE", value = cond, 
[16:19:19.813]                                 success = TRUE)
[16:19:19.813]                               parallel_sendData(master, data)
[16:19:19.813]                             }
[16:19:19.813]                             return(sendCondition)
[16:19:19.813]                           }
[16:19:19.813]                         }
[16:19:19.813]                         frame <- frame + 1L
[16:19:19.813]                         envir <- sys.frame(frame)
[16:19:19.813]                       }
[16:19:19.813]                     }
[16:19:19.813]                     sendCondition <<- function(cond) NULL
[16:19:19.813]                   }
[16:19:19.813]                 })
[16:19:19.813]                 withCallingHandlers({
[16:19:19.813]                   {
[16:19:19.813]                     do.call(function(...) {
[16:19:19.813]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.813]                       if (!identical(...future.globals.maxSize.org, 
[16:19:19.813]                         ...future.globals.maxSize)) {
[16:19:19.813]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.813]                         on.exit(options(oopts), add = TRUE)
[16:19:19.813]                       }
[16:19:19.813]                       {
[16:19:19.813]                         lapply(seq_along(...future.elements_ii), 
[16:19:19.813]                           FUN = function(jj) {
[16:19:19.813]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.813]                             ...future.FUN(...future.X_jj, ...)
[16:19:19.813]                           })
[16:19:19.813]                       }
[16:19:19.813]                     }, args = future.call.arguments)
[16:19:19.813]                   }
[16:19:19.813]                 }, immediateCondition = function(cond) {
[16:19:19.813]                   sendCondition <- ...future.makeSendCondition()
[16:19:19.813]                   sendCondition(cond)
[16:19:19.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.813]                   {
[16:19:19.813]                     inherits <- base::inherits
[16:19:19.813]                     invokeRestart <- base::invokeRestart
[16:19:19.813]                     is.null <- base::is.null
[16:19:19.813]                     muffled <- FALSE
[16:19:19.813]                     if (inherits(cond, "message")) {
[16:19:19.813]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:19.813]                       if (muffled) 
[16:19:19.813]                         invokeRestart("muffleMessage")
[16:19:19.813]                     }
[16:19:19.813]                     else if (inherits(cond, "warning")) {
[16:19:19.813]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:19.813]                       if (muffled) 
[16:19:19.813]                         invokeRestart("muffleWarning")
[16:19:19.813]                     }
[16:19:19.813]                     else if (inherits(cond, "condition")) {
[16:19:19.813]                       if (!is.null(pattern)) {
[16:19:19.813]                         computeRestarts <- base::computeRestarts
[16:19:19.813]                         grepl <- base::grepl
[16:19:19.813]                         restarts <- computeRestarts(cond)
[16:19:19.813]                         for (restart in restarts) {
[16:19:19.813]                           name <- restart$name
[16:19:19.813]                           if (is.null(name)) 
[16:19:19.813]                             next
[16:19:19.813]                           if (!grepl(pattern, name)) 
[16:19:19.813]                             next
[16:19:19.813]                           invokeRestart(restart)
[16:19:19.813]                           muffled <- TRUE
[16:19:19.813]                           break
[16:19:19.813]                         }
[16:19:19.813]                       }
[16:19:19.813]                     }
[16:19:19.813]                     invisible(muffled)
[16:19:19.813]                   }
[16:19:19.813]                   muffleCondition(cond)
[16:19:19.813]                 })
[16:19:19.813]             }))
[16:19:19.813]             future::FutureResult(value = ...future.value$value, 
[16:19:19.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.813]                   ...future.rng), globalenv = if (FALSE) 
[16:19:19.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:19.813]                     ...future.globalenv.names))
[16:19:19.813]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:19.813]         }, condition = base::local({
[16:19:19.813]             c <- base::c
[16:19:19.813]             inherits <- base::inherits
[16:19:19.813]             invokeRestart <- base::invokeRestart
[16:19:19.813]             length <- base::length
[16:19:19.813]             list <- base::list
[16:19:19.813]             seq.int <- base::seq.int
[16:19:19.813]             signalCondition <- base::signalCondition
[16:19:19.813]             sys.calls <- base::sys.calls
[16:19:19.813]             `[[` <- base::`[[`
[16:19:19.813]             `+` <- base::`+`
[16:19:19.813]             `<<-` <- base::`<<-`
[16:19:19.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:19.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:19.813]                   3L)]
[16:19:19.813]             }
[16:19:19.813]             function(cond) {
[16:19:19.813]                 is_error <- inherits(cond, "error")
[16:19:19.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:19.813]                   NULL)
[16:19:19.813]                 if (is_error) {
[16:19:19.813]                   sessionInformation <- function() {
[16:19:19.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:19.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:19.813]                       search = base::search(), system = base::Sys.info())
[16:19:19.813]                   }
[16:19:19.813]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:19.813]                     cond$call), session = sessionInformation(), 
[16:19:19.813]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:19.813]                   signalCondition(cond)
[16:19:19.813]                 }
[16:19:19.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:19.813]                 "immediateCondition"))) {
[16:19:19.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:19.813]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:19.813]                   if (TRUE && !signal) {
[16:19:19.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.813]                     {
[16:19:19.813]                       inherits <- base::inherits
[16:19:19.813]                       invokeRestart <- base::invokeRestart
[16:19:19.813]                       is.null <- base::is.null
[16:19:19.813]                       muffled <- FALSE
[16:19:19.813]                       if (inherits(cond, "message")) {
[16:19:19.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.813]                         if (muffled) 
[16:19:19.813]                           invokeRestart("muffleMessage")
[16:19:19.813]                       }
[16:19:19.813]                       else if (inherits(cond, "warning")) {
[16:19:19.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.813]                         if (muffled) 
[16:19:19.813]                           invokeRestart("muffleWarning")
[16:19:19.813]                       }
[16:19:19.813]                       else if (inherits(cond, "condition")) {
[16:19:19.813]                         if (!is.null(pattern)) {
[16:19:19.813]                           computeRestarts <- base::computeRestarts
[16:19:19.813]                           grepl <- base::grepl
[16:19:19.813]                           restarts <- computeRestarts(cond)
[16:19:19.813]                           for (restart in restarts) {
[16:19:19.813]                             name <- restart$name
[16:19:19.813]                             if (is.null(name)) 
[16:19:19.813]                               next
[16:19:19.813]                             if (!grepl(pattern, name)) 
[16:19:19.813]                               next
[16:19:19.813]                             invokeRestart(restart)
[16:19:19.813]                             muffled <- TRUE
[16:19:19.813]                             break
[16:19:19.813]                           }
[16:19:19.813]                         }
[16:19:19.813]                       }
[16:19:19.813]                       invisible(muffled)
[16:19:19.813]                     }
[16:19:19.813]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.813]                   }
[16:19:19.813]                 }
[16:19:19.813]                 else {
[16:19:19.813]                   if (TRUE) {
[16:19:19.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.813]                     {
[16:19:19.813]                       inherits <- base::inherits
[16:19:19.813]                       invokeRestart <- base::invokeRestart
[16:19:19.813]                       is.null <- base::is.null
[16:19:19.813]                       muffled <- FALSE
[16:19:19.813]                       if (inherits(cond, "message")) {
[16:19:19.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.813]                         if (muffled) 
[16:19:19.813]                           invokeRestart("muffleMessage")
[16:19:19.813]                       }
[16:19:19.813]                       else if (inherits(cond, "warning")) {
[16:19:19.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.813]                         if (muffled) 
[16:19:19.813]                           invokeRestart("muffleWarning")
[16:19:19.813]                       }
[16:19:19.813]                       else if (inherits(cond, "condition")) {
[16:19:19.813]                         if (!is.null(pattern)) {
[16:19:19.813]                           computeRestarts <- base::computeRestarts
[16:19:19.813]                           grepl <- base::grepl
[16:19:19.813]                           restarts <- computeRestarts(cond)
[16:19:19.813]                           for (restart in restarts) {
[16:19:19.813]                             name <- restart$name
[16:19:19.813]                             if (is.null(name)) 
[16:19:19.813]                               next
[16:19:19.813]                             if (!grepl(pattern, name)) 
[16:19:19.813]                               next
[16:19:19.813]                             invokeRestart(restart)
[16:19:19.813]                             muffled <- TRUE
[16:19:19.813]                             break
[16:19:19.813]                           }
[16:19:19.813]                         }
[16:19:19.813]                       }
[16:19:19.813]                       invisible(muffled)
[16:19:19.813]                     }
[16:19:19.813]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.813]                   }
[16:19:19.813]                 }
[16:19:19.813]             }
[16:19:19.813]         }))
[16:19:19.813]     }, error = function(ex) {
[16:19:19.813]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:19.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.813]                 ...future.rng), started = ...future.startTime, 
[16:19:19.813]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:19.813]             version = "1.8"), class = "FutureResult")
[16:19:19.813]     }, finally = {
[16:19:19.813]         if (!identical(...future.workdir, getwd())) 
[16:19:19.813]             setwd(...future.workdir)
[16:19:19.813]         {
[16:19:19.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:19.813]                 ...future.oldOptions$nwarnings <- NULL
[16:19:19.813]             }
[16:19:19.813]             base::options(...future.oldOptions)
[16:19:19.813]             if (.Platform$OS.type == "windows") {
[16:19:19.813]                 old_names <- names(...future.oldEnvVars)
[16:19:19.813]                 envs <- base::Sys.getenv()
[16:19:19.813]                 names <- names(envs)
[16:19:19.813]                 common <- intersect(names, old_names)
[16:19:19.813]                 added <- setdiff(names, old_names)
[16:19:19.813]                 removed <- setdiff(old_names, names)
[16:19:19.813]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:19.813]                   envs[common]]
[16:19:19.813]                 NAMES <- toupper(changed)
[16:19:19.813]                 args <- list()
[16:19:19.813]                 for (kk in seq_along(NAMES)) {
[16:19:19.813]                   name <- changed[[kk]]
[16:19:19.813]                   NAME <- NAMES[[kk]]
[16:19:19.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.813]                     next
[16:19:19.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.813]                 }
[16:19:19.813]                 NAMES <- toupper(added)
[16:19:19.813]                 for (kk in seq_along(NAMES)) {
[16:19:19.813]                   name <- added[[kk]]
[16:19:19.813]                   NAME <- NAMES[[kk]]
[16:19:19.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.813]                     next
[16:19:19.813]                   args[[name]] <- ""
[16:19:19.813]                 }
[16:19:19.813]                 NAMES <- toupper(removed)
[16:19:19.813]                 for (kk in seq_along(NAMES)) {
[16:19:19.813]                   name <- removed[[kk]]
[16:19:19.813]                   NAME <- NAMES[[kk]]
[16:19:19.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.813]                     next
[16:19:19.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.813]                 }
[16:19:19.813]                 if (length(args) > 0) 
[16:19:19.813]                   base::do.call(base::Sys.setenv, args = args)
[16:19:19.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:19.813]             }
[16:19:19.813]             else {
[16:19:19.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:19.813]             }
[16:19:19.813]             {
[16:19:19.813]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:19.813]                   0L) {
[16:19:19.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:19.813]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:19.813]                   base::options(opts)
[16:19:19.813]                 }
[16:19:19.813]                 {
[16:19:19.813]                   {
[16:19:19.813]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:19.813]                     NULL
[16:19:19.813]                   }
[16:19:19.813]                   options(future.plan = NULL)
[16:19:19.813]                   if (is.na(NA_character_)) 
[16:19:19.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:19.813]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:19.813]                     .init = FALSE)
[16:19:19.813]                 }
[16:19:19.813]             }
[16:19:19.813]         }
[16:19:19.813]     })
[16:19:19.813]     if (TRUE) {
[16:19:19.813]         base::sink(type = "output", split = FALSE)
[16:19:19.813]         if (TRUE) {
[16:19:19.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:19.813]         }
[16:19:19.813]         else {
[16:19:19.813]             ...future.result["stdout"] <- base::list(NULL)
[16:19:19.813]         }
[16:19:19.813]         base::close(...future.stdout)
[16:19:19.813]         ...future.stdout <- NULL
[16:19:19.813]     }
[16:19:19.813]     ...future.result$conditions <- ...future.conditions
[16:19:19.813]     ...future.result$finished <- base::Sys.time()
[16:19:19.813]     ...future.result
[16:19:19.813] }
[16:19:19.816] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[16:19:19.816] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[16:19:19.860] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[16:19:19.861] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:19.861] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.861] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[16:19:19.862] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[16:19:19.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:19.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.862] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:19.863] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:19.863] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[16:19:19.863] MultisessionFuture started
[16:19:19.863] - Launch lazy future ... done
[16:19:19.863] run() for ‘MultisessionFuture’ ... done
[16:19:19.864] Created future:
[16:19:19.864] MultisessionFuture:
[16:19:19.864] Label: ‘future_sapply-1’
[16:19:19.864] Expression:
[16:19:19.864] {
[16:19:19.864]     do.call(function(...) {
[16:19:19.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.864]             on.exit(options(oopts), add = TRUE)
[16:19:19.864]         }
[16:19:19.864]         {
[16:19:19.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.864]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.864]             })
[16:19:19.864]         }
[16:19:19.864]     }, args = future.call.arguments)
[16:19:19.864] }
[16:19:19.864] Lazy evaluation: FALSE
[16:19:19.864] Asynchronous evaluation: TRUE
[16:19:19.864] Local evaluation: TRUE
[16:19:19.864] Environment: R_GlobalEnv
[16:19:19.864] Capture standard output: TRUE
[16:19:19.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:19.864] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:19.864] Packages: 1 packages (‘stats’)
[16:19:19.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:19.864] Resolved: FALSE
[16:19:19.864] Value: <not collected>
[16:19:19.864] Conditions captured: <none>
[16:19:19.864] Early signaling: FALSE
[16:19:19.864] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:19.864] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.875] Chunk #1 of 2 ... DONE
[16:19:19.875] Chunk #2 of 2 ...
[16:19:19.875]  - Finding globals in 'X' for chunk #2 ...
[16:19:19.876] getGlobalsAndPackages() ...
[16:19:19.876] Searching for globals...
[16:19:19.876] 
[16:19:19.876] Searching for globals ... DONE
[16:19:19.879] - globals: [0] <none>
[16:19:19.879] getGlobalsAndPackages() ... DONE
[16:19:19.879]    + additional globals found: [n=0] 
[16:19:19.879]    + additional namespaces needed: [n=0] 
[16:19:19.879]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:19.879]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:19.879]  - seeds: <none>
[16:19:19.879]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.880] getGlobalsAndPackages() ...
[16:19:19.880] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.880] Resolving globals: FALSE
[16:19:19.880] Tweak future expression to call with '...' arguments ...
[16:19:19.880] {
[16:19:19.880]     do.call(function(...) {
[16:19:19.880]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.880]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.880]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.880]             on.exit(options(oopts), add = TRUE)
[16:19:19.880]         }
[16:19:19.880]         {
[16:19:19.880]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.880]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.880]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.880]             })
[16:19:19.880]         }
[16:19:19.880]     }, args = future.call.arguments)
[16:19:19.880] }
[16:19:19.880] Tweak future expression to call with '...' arguments ... DONE
[16:19:19.881] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:19.881] - packages: [1] ‘stats’
[16:19:19.881] getGlobalsAndPackages() ... DONE
[16:19:19.881] run() for ‘Future’ ...
[16:19:19.881] - state: ‘created’
[16:19:19.881] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:19.895] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:19.895]   - Field: ‘node’
[16:19:19.895]   - Field: ‘label’
[16:19:19.896]   - Field: ‘local’
[16:19:19.896]   - Field: ‘owner’
[16:19:19.896]   - Field: ‘envir’
[16:19:19.896]   - Field: ‘workers’
[16:19:19.896]   - Field: ‘packages’
[16:19:19.896]   - Field: ‘gc’
[16:19:19.896]   - Field: ‘conditions’
[16:19:19.896]   - Field: ‘persistent’
[16:19:19.896]   - Field: ‘expr’
[16:19:19.896]   - Field: ‘uuid’
[16:19:19.896]   - Field: ‘seed’
[16:19:19.897]   - Field: ‘version’
[16:19:19.897]   - Field: ‘result’
[16:19:19.897]   - Field: ‘asynchronous’
[16:19:19.897]   - Field: ‘calls’
[16:19:19.897]   - Field: ‘globals’
[16:19:19.897]   - Field: ‘stdout’
[16:19:19.897]   - Field: ‘earlySignal’
[16:19:19.897]   - Field: ‘lazy’
[16:19:19.897]   - Field: ‘state’
[16:19:19.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:19.897] - Launch lazy future ...
[16:19:19.898] Packages needed by the future expression (n = 1): ‘stats’
[16:19:19.898] Packages needed by future strategies (n = 0): <none>
[16:19:19.898] {
[16:19:19.898]     {
[16:19:19.898]         {
[16:19:19.898]             ...future.startTime <- base::Sys.time()
[16:19:19.898]             {
[16:19:19.898]                 {
[16:19:19.898]                   {
[16:19:19.898]                     {
[16:19:19.898]                       {
[16:19:19.898]                         base::local({
[16:19:19.898]                           has_future <- base::requireNamespace("future", 
[16:19:19.898]                             quietly = TRUE)
[16:19:19.898]                           if (has_future) {
[16:19:19.898]                             ns <- base::getNamespace("future")
[16:19:19.898]                             version <- ns[[".package"]][["version"]]
[16:19:19.898]                             if (is.null(version)) 
[16:19:19.898]                               version <- utils::packageVersion("future")
[16:19:19.898]                           }
[16:19:19.898]                           else {
[16:19:19.898]                             version <- NULL
[16:19:19.898]                           }
[16:19:19.898]                           if (!has_future || version < "1.8.0") {
[16:19:19.898]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:19.898]                               "", base::R.version$version.string), 
[16:19:19.898]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:19.898]                                 base::R.version$platform, 8 * 
[16:19:19.898]                                   base::.Machine$sizeof.pointer), 
[16:19:19.898]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:19.898]                                 "release", "version")], collapse = " "), 
[16:19:19.898]                               hostname = base::Sys.info()[["nodename"]])
[16:19:19.898]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:19.898]                               info)
[16:19:19.898]                             info <- base::paste(info, collapse = "; ")
[16:19:19.898]                             if (!has_future) {
[16:19:19.898]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:19.898]                                 info)
[16:19:19.898]                             }
[16:19:19.898]                             else {
[16:19:19.898]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:19.898]                                 info, version)
[16:19:19.898]                             }
[16:19:19.898]                             base::stop(msg)
[16:19:19.898]                           }
[16:19:19.898]                         })
[16:19:19.898]                       }
[16:19:19.898]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:19.898]                       base::options(mc.cores = 1L)
[16:19:19.898]                     }
[16:19:19.898]                     base::local({
[16:19:19.898]                       for (pkg in "stats") {
[16:19:19.898]                         base::loadNamespace(pkg)
[16:19:19.898]                         base::library(pkg, character.only = TRUE)
[16:19:19.898]                       }
[16:19:19.898]                     })
[16:19:19.898]                   }
[16:19:19.898]                   ...future.strategy.old <- future::plan("list")
[16:19:19.898]                   options(future.plan = NULL)
[16:19:19.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:19.898]                 }
[16:19:19.898]                 ...future.workdir <- getwd()
[16:19:19.898]             }
[16:19:19.898]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:19.898]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:19.898]         }
[16:19:19.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:19.898]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:19.898]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:19.898]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:19.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:19.898]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:19.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:19.898]             base::names(...future.oldOptions))
[16:19:19.898]     }
[16:19:19.898]     if (FALSE) {
[16:19:19.898]     }
[16:19:19.898]     else {
[16:19:19.898]         if (TRUE) {
[16:19:19.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:19.898]                 open = "w")
[16:19:19.898]         }
[16:19:19.898]         else {
[16:19:19.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:19.898]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:19.898]         }
[16:19:19.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:19.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:19.898]             base::sink(type = "output", split = FALSE)
[16:19:19.898]             base::close(...future.stdout)
[16:19:19.898]         }, add = TRUE)
[16:19:19.898]     }
[16:19:19.898]     ...future.frame <- base::sys.nframe()
[16:19:19.898]     ...future.conditions <- base::list()
[16:19:19.898]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:19.898]     if (FALSE) {
[16:19:19.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:19.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:19.898]     }
[16:19:19.898]     ...future.result <- base::tryCatch({
[16:19:19.898]         base::withCallingHandlers({
[16:19:19.898]             ...future.value <- base::withVisible(base::local({
[16:19:19.898]                 ...future.makeSendCondition <- base::local({
[16:19:19.898]                   sendCondition <- NULL
[16:19:19.898]                   function(frame = 1L) {
[16:19:19.898]                     if (is.function(sendCondition)) 
[16:19:19.898]                       return(sendCondition)
[16:19:19.898]                     ns <- getNamespace("parallel")
[16:19:19.898]                     if (exists("sendData", mode = "function", 
[16:19:19.898]                       envir = ns)) {
[16:19:19.898]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:19.898]                         envir = ns)
[16:19:19.898]                       envir <- sys.frame(frame)
[16:19:19.898]                       master <- NULL
[16:19:19.898]                       while (!identical(envir, .GlobalEnv) && 
[16:19:19.898]                         !identical(envir, emptyenv())) {
[16:19:19.898]                         if (exists("master", mode = "list", envir = envir, 
[16:19:19.898]                           inherits = FALSE)) {
[16:19:19.898]                           master <- get("master", mode = "list", 
[16:19:19.898]                             envir = envir, inherits = FALSE)
[16:19:19.898]                           if (inherits(master, c("SOCKnode", 
[16:19:19.898]                             "SOCK0node"))) {
[16:19:19.898]                             sendCondition <<- function(cond) {
[16:19:19.898]                               data <- list(type = "VALUE", value = cond, 
[16:19:19.898]                                 success = TRUE)
[16:19:19.898]                               parallel_sendData(master, data)
[16:19:19.898]                             }
[16:19:19.898]                             return(sendCondition)
[16:19:19.898]                           }
[16:19:19.898]                         }
[16:19:19.898]                         frame <- frame + 1L
[16:19:19.898]                         envir <- sys.frame(frame)
[16:19:19.898]                       }
[16:19:19.898]                     }
[16:19:19.898]                     sendCondition <<- function(cond) NULL
[16:19:19.898]                   }
[16:19:19.898]                 })
[16:19:19.898]                 withCallingHandlers({
[16:19:19.898]                   {
[16:19:19.898]                     do.call(function(...) {
[16:19:19.898]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.898]                       if (!identical(...future.globals.maxSize.org, 
[16:19:19.898]                         ...future.globals.maxSize)) {
[16:19:19.898]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.898]                         on.exit(options(oopts), add = TRUE)
[16:19:19.898]                       }
[16:19:19.898]                       {
[16:19:19.898]                         lapply(seq_along(...future.elements_ii), 
[16:19:19.898]                           FUN = function(jj) {
[16:19:19.898]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.898]                             ...future.FUN(...future.X_jj, ...)
[16:19:19.898]                           })
[16:19:19.898]                       }
[16:19:19.898]                     }, args = future.call.arguments)
[16:19:19.898]                   }
[16:19:19.898]                 }, immediateCondition = function(cond) {
[16:19:19.898]                   sendCondition <- ...future.makeSendCondition()
[16:19:19.898]                   sendCondition(cond)
[16:19:19.898]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.898]                   {
[16:19:19.898]                     inherits <- base::inherits
[16:19:19.898]                     invokeRestart <- base::invokeRestart
[16:19:19.898]                     is.null <- base::is.null
[16:19:19.898]                     muffled <- FALSE
[16:19:19.898]                     if (inherits(cond, "message")) {
[16:19:19.898]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:19.898]                       if (muffled) 
[16:19:19.898]                         invokeRestart("muffleMessage")
[16:19:19.898]                     }
[16:19:19.898]                     else if (inherits(cond, "warning")) {
[16:19:19.898]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:19.898]                       if (muffled) 
[16:19:19.898]                         invokeRestart("muffleWarning")
[16:19:19.898]                     }
[16:19:19.898]                     else if (inherits(cond, "condition")) {
[16:19:19.898]                       if (!is.null(pattern)) {
[16:19:19.898]                         computeRestarts <- base::computeRestarts
[16:19:19.898]                         grepl <- base::grepl
[16:19:19.898]                         restarts <- computeRestarts(cond)
[16:19:19.898]                         for (restart in restarts) {
[16:19:19.898]                           name <- restart$name
[16:19:19.898]                           if (is.null(name)) 
[16:19:19.898]                             next
[16:19:19.898]                           if (!grepl(pattern, name)) 
[16:19:19.898]                             next
[16:19:19.898]                           invokeRestart(restart)
[16:19:19.898]                           muffled <- TRUE
[16:19:19.898]                           break
[16:19:19.898]                         }
[16:19:19.898]                       }
[16:19:19.898]                     }
[16:19:19.898]                     invisible(muffled)
[16:19:19.898]                   }
[16:19:19.898]                   muffleCondition(cond)
[16:19:19.898]                 })
[16:19:19.898]             }))
[16:19:19.898]             future::FutureResult(value = ...future.value$value, 
[16:19:19.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.898]                   ...future.rng), globalenv = if (FALSE) 
[16:19:19.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:19.898]                     ...future.globalenv.names))
[16:19:19.898]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:19.898]         }, condition = base::local({
[16:19:19.898]             c <- base::c
[16:19:19.898]             inherits <- base::inherits
[16:19:19.898]             invokeRestart <- base::invokeRestart
[16:19:19.898]             length <- base::length
[16:19:19.898]             list <- base::list
[16:19:19.898]             seq.int <- base::seq.int
[16:19:19.898]             signalCondition <- base::signalCondition
[16:19:19.898]             sys.calls <- base::sys.calls
[16:19:19.898]             `[[` <- base::`[[`
[16:19:19.898]             `+` <- base::`+`
[16:19:19.898]             `<<-` <- base::`<<-`
[16:19:19.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:19.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:19.898]                   3L)]
[16:19:19.898]             }
[16:19:19.898]             function(cond) {
[16:19:19.898]                 is_error <- inherits(cond, "error")
[16:19:19.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:19.898]                   NULL)
[16:19:19.898]                 if (is_error) {
[16:19:19.898]                   sessionInformation <- function() {
[16:19:19.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:19.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:19.898]                       search = base::search(), system = base::Sys.info())
[16:19:19.898]                   }
[16:19:19.898]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:19.898]                     cond$call), session = sessionInformation(), 
[16:19:19.898]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:19.898]                   signalCondition(cond)
[16:19:19.898]                 }
[16:19:19.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:19.898]                 "immediateCondition"))) {
[16:19:19.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:19.898]                   ...future.conditions[[length(...future.conditions) + 
[16:19:19.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:19.898]                   if (TRUE && !signal) {
[16:19:19.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.898]                     {
[16:19:19.898]                       inherits <- base::inherits
[16:19:19.898]                       invokeRestart <- base::invokeRestart
[16:19:19.898]                       is.null <- base::is.null
[16:19:19.898]                       muffled <- FALSE
[16:19:19.898]                       if (inherits(cond, "message")) {
[16:19:19.898]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.898]                         if (muffled) 
[16:19:19.898]                           invokeRestart("muffleMessage")
[16:19:19.898]                       }
[16:19:19.898]                       else if (inherits(cond, "warning")) {
[16:19:19.898]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.898]                         if (muffled) 
[16:19:19.898]                           invokeRestart("muffleWarning")
[16:19:19.898]                       }
[16:19:19.898]                       else if (inherits(cond, "condition")) {
[16:19:19.898]                         if (!is.null(pattern)) {
[16:19:19.898]                           computeRestarts <- base::computeRestarts
[16:19:19.898]                           grepl <- base::grepl
[16:19:19.898]                           restarts <- computeRestarts(cond)
[16:19:19.898]                           for (restart in restarts) {
[16:19:19.898]                             name <- restart$name
[16:19:19.898]                             if (is.null(name)) 
[16:19:19.898]                               next
[16:19:19.898]                             if (!grepl(pattern, name)) 
[16:19:19.898]                               next
[16:19:19.898]                             invokeRestart(restart)
[16:19:19.898]                             muffled <- TRUE
[16:19:19.898]                             break
[16:19:19.898]                           }
[16:19:19.898]                         }
[16:19:19.898]                       }
[16:19:19.898]                       invisible(muffled)
[16:19:19.898]                     }
[16:19:19.898]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.898]                   }
[16:19:19.898]                 }
[16:19:19.898]                 else {
[16:19:19.898]                   if (TRUE) {
[16:19:19.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:19.898]                     {
[16:19:19.898]                       inherits <- base::inherits
[16:19:19.898]                       invokeRestart <- base::invokeRestart
[16:19:19.898]                       is.null <- base::is.null
[16:19:19.898]                       muffled <- FALSE
[16:19:19.898]                       if (inherits(cond, "message")) {
[16:19:19.898]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:19.898]                         if (muffled) 
[16:19:19.898]                           invokeRestart("muffleMessage")
[16:19:19.898]                       }
[16:19:19.898]                       else if (inherits(cond, "warning")) {
[16:19:19.898]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:19.898]                         if (muffled) 
[16:19:19.898]                           invokeRestart("muffleWarning")
[16:19:19.898]                       }
[16:19:19.898]                       else if (inherits(cond, "condition")) {
[16:19:19.898]                         if (!is.null(pattern)) {
[16:19:19.898]                           computeRestarts <- base::computeRestarts
[16:19:19.898]                           grepl <- base::grepl
[16:19:19.898]                           restarts <- computeRestarts(cond)
[16:19:19.898]                           for (restart in restarts) {
[16:19:19.898]                             name <- restart$name
[16:19:19.898]                             if (is.null(name)) 
[16:19:19.898]                               next
[16:19:19.898]                             if (!grepl(pattern, name)) 
[16:19:19.898]                               next
[16:19:19.898]                             invokeRestart(restart)
[16:19:19.898]                             muffled <- TRUE
[16:19:19.898]                             break
[16:19:19.898]                           }
[16:19:19.898]                         }
[16:19:19.898]                       }
[16:19:19.898]                       invisible(muffled)
[16:19:19.898]                     }
[16:19:19.898]                     muffleCondition(cond, pattern = "^muffle")
[16:19:19.898]                   }
[16:19:19.898]                 }
[16:19:19.898]             }
[16:19:19.898]         }))
[16:19:19.898]     }, error = function(ex) {
[16:19:19.898]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:19.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:19.898]                 ...future.rng), started = ...future.startTime, 
[16:19:19.898]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:19.898]             version = "1.8"), class = "FutureResult")
[16:19:19.898]     }, finally = {
[16:19:19.898]         if (!identical(...future.workdir, getwd())) 
[16:19:19.898]             setwd(...future.workdir)
[16:19:19.898]         {
[16:19:19.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:19.898]                 ...future.oldOptions$nwarnings <- NULL
[16:19:19.898]             }
[16:19:19.898]             base::options(...future.oldOptions)
[16:19:19.898]             if (.Platform$OS.type == "windows") {
[16:19:19.898]                 old_names <- names(...future.oldEnvVars)
[16:19:19.898]                 envs <- base::Sys.getenv()
[16:19:19.898]                 names <- names(envs)
[16:19:19.898]                 common <- intersect(names, old_names)
[16:19:19.898]                 added <- setdiff(names, old_names)
[16:19:19.898]                 removed <- setdiff(old_names, names)
[16:19:19.898]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:19.898]                   envs[common]]
[16:19:19.898]                 NAMES <- toupper(changed)
[16:19:19.898]                 args <- list()
[16:19:19.898]                 for (kk in seq_along(NAMES)) {
[16:19:19.898]                   name <- changed[[kk]]
[16:19:19.898]                   NAME <- NAMES[[kk]]
[16:19:19.898]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.898]                     next
[16:19:19.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.898]                 }
[16:19:19.898]                 NAMES <- toupper(added)
[16:19:19.898]                 for (kk in seq_along(NAMES)) {
[16:19:19.898]                   name <- added[[kk]]
[16:19:19.898]                   NAME <- NAMES[[kk]]
[16:19:19.898]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.898]                     next
[16:19:19.898]                   args[[name]] <- ""
[16:19:19.898]                 }
[16:19:19.898]                 NAMES <- toupper(removed)
[16:19:19.898]                 for (kk in seq_along(NAMES)) {
[16:19:19.898]                   name <- removed[[kk]]
[16:19:19.898]                   NAME <- NAMES[[kk]]
[16:19:19.898]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:19.898]                     next
[16:19:19.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:19.898]                 }
[16:19:19.898]                 if (length(args) > 0) 
[16:19:19.898]                   base::do.call(base::Sys.setenv, args = args)
[16:19:19.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:19.898]             }
[16:19:19.898]             else {
[16:19:19.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:19.898]             }
[16:19:19.898]             {
[16:19:19.898]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:19.898]                   0L) {
[16:19:19.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:19.898]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:19.898]                   base::options(opts)
[16:19:19.898]                 }
[16:19:19.898]                 {
[16:19:19.898]                   {
[16:19:19.898]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:19.898]                     NULL
[16:19:19.898]                   }
[16:19:19.898]                   options(future.plan = NULL)
[16:19:19.898]                   if (is.na(NA_character_)) 
[16:19:19.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:19.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:19.898]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:19.898]                     .init = FALSE)
[16:19:19.898]                 }
[16:19:19.898]             }
[16:19:19.898]         }
[16:19:19.898]     })
[16:19:19.898]     if (TRUE) {
[16:19:19.898]         base::sink(type = "output", split = FALSE)
[16:19:19.898]         if (TRUE) {
[16:19:19.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:19.898]         }
[16:19:19.898]         else {
[16:19:19.898]             ...future.result["stdout"] <- base::list(NULL)
[16:19:19.898]         }
[16:19:19.898]         base::close(...future.stdout)
[16:19:19.898]         ...future.stdout <- NULL
[16:19:19.898]     }
[16:19:19.898]     ...future.result$conditions <- ...future.conditions
[16:19:19.898]     ...future.result$finished <- base::Sys.time()
[16:19:19.898]     ...future.result
[16:19:19.898] }
[16:19:19.901] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[16:19:19.901] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[16:19:19.944] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[16:19:19.945] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:19.945] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:19.945] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[16:19:19.946] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[16:19:19.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:19.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:19.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:19.947] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:19.947] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[16:19:19.947] MultisessionFuture started
[16:19:19.947] - Launch lazy future ... done
[16:19:19.947] run() for ‘MultisessionFuture’ ... done
[16:19:19.948] Created future:
[16:19:19.948] MultisessionFuture:
[16:19:19.948] Label: ‘future_sapply-2’
[16:19:19.948] Expression:
[16:19:19.948] {
[16:19:19.948]     do.call(function(...) {
[16:19:19.948]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:19.948]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:19.948]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:19.948]             on.exit(options(oopts), add = TRUE)
[16:19:19.948]         }
[16:19:19.948]         {
[16:19:19.948]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:19.948]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:19.948]                 ...future.FUN(...future.X_jj, ...)
[16:19:19.948]             })
[16:19:19.948]         }
[16:19:19.948]     }, args = future.call.arguments)
[16:19:19.948] }
[16:19:19.948] Lazy evaluation: FALSE
[16:19:19.948] Asynchronous evaluation: TRUE
[16:19:19.948] Local evaluation: TRUE
[16:19:19.948] Environment: R_GlobalEnv
[16:19:19.948] Capture standard output: TRUE
[16:19:19.948] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:19.948] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:19.948] Packages: 1 packages (‘stats’)
[16:19:19.948] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:19.948] Resolved: FALSE
[16:19:19.948] Value: <not collected>
[16:19:19.948] Conditions captured: <none>
[16:19:19.948] Early signaling: FALSE
[16:19:19.948] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:19.948] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:19.959] Chunk #2 of 2 ... DONE
[16:19:19.959] Launching 2 futures (chunks) ... DONE
[16:19:19.959] Resolving 2 futures (chunks) ...
[16:19:19.960] resolve() on list ...
[16:19:19.960]  recursive: 0
[16:19:19.960]  length: 2
[16:19:19.960] 
[16:19:19.960] receiveMessageFromWorker() for ClusterFuture ...
[16:19:19.960] - Validating connection of MultisessionFuture
[16:19:19.961] - received message: FutureResult
[16:19:19.961] - Received FutureResult
[16:19:19.961] - Erased future from FutureRegistry
[16:19:19.961] result() for ClusterFuture ...
[16:19:19.961] - result already collected: FutureResult
[16:19:19.961] result() for ClusterFuture ... done
[16:19:19.961] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:19.961] Future #1
[16:19:19.961] result() for ClusterFuture ...
[16:19:19.962] - result already collected: FutureResult
[16:19:19.962] result() for ClusterFuture ... done
[16:19:19.962] result() for ClusterFuture ...
[16:19:19.962] - result already collected: FutureResult
[16:19:19.962] result() for ClusterFuture ... done
[16:19:19.962] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:19.962] - nx: 2
[16:19:19.962] - relay: TRUE
[16:19:19.962] - stdout: TRUE
[16:19:19.962] - signal: TRUE
[16:19:19.962] - resignal: FALSE
[16:19:19.962] - force: TRUE
[16:19:19.963] - relayed: [n=2] FALSE, FALSE
[16:19:19.963] - queued futures: [n=2] FALSE, FALSE
[16:19:19.963]  - until=1
[16:19:19.963]  - relaying element #1
[16:19:19.963] result() for ClusterFuture ...
[16:19:19.963] - result already collected: FutureResult
[16:19:19.963] result() for ClusterFuture ... done
[16:19:19.963] result() for ClusterFuture ...
[16:19:19.963] - result already collected: FutureResult
[16:19:19.963] result() for ClusterFuture ... done
[16:19:19.963] result() for ClusterFuture ...
[16:19:19.964] - result already collected: FutureResult
[16:19:19.964] result() for ClusterFuture ... done
[16:19:19.964] result() for ClusterFuture ...
[16:19:19.964] - result already collected: FutureResult
[16:19:19.964] result() for ClusterFuture ... done
[16:19:19.964] - relayed: [n=2] TRUE, FALSE
[16:19:19.964] - queued futures: [n=2] TRUE, FALSE
[16:19:19.964] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:19.964]  length: 1 (resolved future 1)
[16:19:19.990] receiveMessageFromWorker() for ClusterFuture ...
[16:19:19.990] - Validating connection of MultisessionFuture
[16:19:19.991] - received message: FutureResult
[16:19:19.991] - Received FutureResult
[16:19:19.991] - Erased future from FutureRegistry
[16:19:19.991] result() for ClusterFuture ...
[16:19:19.991] - result already collected: FutureResult
[16:19:19.991] result() for ClusterFuture ... done
[16:19:19.991] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:19.991] Future #2
[16:19:19.991] result() for ClusterFuture ...
[16:19:19.991] - result already collected: FutureResult
[16:19:19.992] result() for ClusterFuture ... done
[16:19:19.992] result() for ClusterFuture ...
[16:19:19.992] - result already collected: FutureResult
[16:19:19.992] result() for ClusterFuture ... done
[16:19:19.992] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:19.992] - nx: 2
[16:19:19.992] - relay: TRUE
[16:19:19.992] - stdout: TRUE
[16:19:19.992] - signal: TRUE
[16:19:19.992] - resignal: FALSE
[16:19:19.992] - force: TRUE
[16:19:19.993] - relayed: [n=2] TRUE, FALSE
[16:19:19.993] - queued futures: [n=2] TRUE, FALSE
[16:19:19.993]  - until=2
[16:19:19.993]  - relaying element #2
[16:19:19.993] result() for ClusterFuture ...
[16:19:19.993] - result already collected: FutureResult
[16:19:19.993] result() for ClusterFuture ... done
[16:19:19.993] result() for ClusterFuture ...
[16:19:19.993] - result already collected: FutureResult
[16:19:19.993] result() for ClusterFuture ... done
[16:19:19.993] result() for ClusterFuture ...
[16:19:19.994] - result already collected: FutureResult
[16:19:19.994] result() for ClusterFuture ... done
[16:19:19.994] result() for ClusterFuture ...
[16:19:19.994] - result already collected: FutureResult
[16:19:19.994] result() for ClusterFuture ... done
[16:19:19.994] - relayed: [n=2] TRUE, TRUE
[16:19:19.994] - queued futures: [n=2] TRUE, TRUE
[16:19:19.994] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:19.994]  length: 0 (resolved future 2)
[16:19:19.994] Relaying remaining futures
[16:19:19.994] signalConditionsASAP(NULL, pos=0) ...
[16:19:19.995] - nx: 2
[16:19:19.995] - relay: TRUE
[16:19:19.995] - stdout: TRUE
[16:19:19.995] - signal: TRUE
[16:19:19.995] - resignal: FALSE
[16:19:19.995] - force: TRUE
[16:19:19.995] - relayed: [n=2] TRUE, TRUE
[16:19:19.995] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:19.995] - relayed: [n=2] TRUE, TRUE
[16:19:19.995] - queued futures: [n=2] TRUE, TRUE
[16:19:19.995] signalConditionsASAP(NULL, pos=0) ... done
[16:19:19.995] resolve() on list ... DONE
[16:19:19.996] result() for ClusterFuture ...
[16:19:19.996] - result already collected: FutureResult
[16:19:19.996] result() for ClusterFuture ... done
[16:19:19.996] result() for ClusterFuture ...
[16:19:19.996] - result already collected: FutureResult
[16:19:19.996] result() for ClusterFuture ... done
[16:19:19.996] result() for ClusterFuture ...
[16:19:19.996] - result already collected: FutureResult
[16:19:19.996] result() for ClusterFuture ... done
[16:19:19.996] result() for ClusterFuture ...
[16:19:19.996] - result already collected: FutureResult
[16:19:19.997] result() for ClusterFuture ... done
[16:19:19.997]  - Number of value chunks collected: 2
[16:19:19.997] Resolving 2 futures (chunks) ... DONE
[16:19:19.997] Reducing values from 2 chunks ...
[16:19:19.997]  - Number of values collected after concatenation: 7
[16:19:19.997]  - Number of values expected: 7
[16:19:19.997] Reducing values from 2 chunks ... DONE
[16:19:19.997] future_lapply() ... DONE
[16:19:19.998] future_lapply() ...
[16:19:20.003] Number of chunks: 2
[16:19:20.003] getGlobalsAndPackagesXApply() ...
[16:19:20.003]  - future.globals: TRUE
[16:19:20.003] getGlobalsAndPackages() ...
[16:19:20.003] Searching for globals...
[16:19:20.010] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:19:20.010] Searching for globals ... DONE
[16:19:20.010] Resolving globals: FALSE
[16:19:20.012] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:19:20.012] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:19:20.012] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:20.012] - packages: [2] ‘stats’, ‘future.apply’
[16:19:20.012] getGlobalsAndPackages() ... DONE
[16:19:20.012]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:20.013]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:19:20.013] Finding globals ... DONE
[16:19:20.013]  - use_args: TRUE
[16:19:20.013]  - Getting '...' globals ...
[16:19:20.013] resolve() on list ...
[16:19:20.013]  recursive: 0
[16:19:20.013]  length: 1
[16:19:20.013]  elements: ‘...’
[16:19:20.014]  length: 0 (resolved future 1)
[16:19:20.014] resolve() on list ... DONE
[16:19:20.014]    - '...' content: [n=0] 
[16:19:20.014] List of 1
[16:19:20.014]  $ ...: list()
[16:19:20.014]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:20.014]  - attr(*, "where")=List of 1
[16:19:20.014]   ..$ ...:<environment: 0x56199fb16308> 
[16:19:20.014]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:20.014]  - attr(*, "resolved")= logi TRUE
[16:19:20.014]  - attr(*, "total_size")= num NA
[16:19:20.016]  - Getting '...' globals ... DONE
[16:19:20.017] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:20.017] List of 8
[16:19:20.017]  $ ...future.FUN:function (x, ...)  
[16:19:20.017]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:19:20.017]  $ times        : int 5
[16:19:20.017]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:20.017]  $ stop_if_not  :function (...)  
[16:19:20.017]  $ dim          : NULL
[16:19:20.017]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:20.017]  $ ...          : list()
[16:19:20.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:20.017]  - attr(*, "where")=List of 8
[16:19:20.017]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:20.017]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:20.017]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:20.017]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:20.017]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:20.017]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:20.017]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:20.017]   ..$ ...          :<environment: 0x56199fb16308> 
[16:19:20.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:20.017]  - attr(*, "resolved")= logi FALSE
[16:19:20.017]  - attr(*, "total_size")= num 141240
[16:19:20.022] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:19:20.022] getGlobalsAndPackagesXApply() ... DONE
[16:19:20.022] Number of futures (= number of chunks): 2
[16:19:20.022] Launching 2 futures (chunks) ...
[16:19:20.022] Chunk #1 of 2 ...
[16:19:20.023]  - Finding globals in 'X' for chunk #1 ...
[16:19:20.023] getGlobalsAndPackages() ...
[16:19:20.023] Searching for globals...
[16:19:20.023] 
[16:19:20.023] Searching for globals ... DONE
[16:19:20.023] - globals: [0] <none>
[16:19:20.023] getGlobalsAndPackages() ... DONE
[16:19:20.023]    + additional globals found: [n=0] 
[16:19:20.023]    + additional namespaces needed: [n=0] 
[16:19:20.024]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:20.024]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:20.024]  - seeds: <none>
[16:19:20.024]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.024] getGlobalsAndPackages() ...
[16:19:20.024] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.024] Resolving globals: FALSE
[16:19:20.024] Tweak future expression to call with '...' arguments ...
[16:19:20.024] {
[16:19:20.024]     do.call(function(...) {
[16:19:20.024]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.024]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.024]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.024]             on.exit(options(oopts), add = TRUE)
[16:19:20.024]         }
[16:19:20.024]         {
[16:19:20.024]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.024]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.024]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.024]             })
[16:19:20.024]         }
[16:19:20.024]     }, args = future.call.arguments)
[16:19:20.024] }
[16:19:20.025] Tweak future expression to call with '...' arguments ... DONE
[16:19:20.025] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.025] - packages: [2] ‘stats’, ‘future.apply’
[16:19:20.025] getGlobalsAndPackages() ... DONE
[16:19:20.026] run() for ‘Future’ ...
[16:19:20.026] - state: ‘created’
[16:19:20.026] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:20.040] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.040] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:20.040]   - Field: ‘node’
[16:19:20.040]   - Field: ‘label’
[16:19:20.041]   - Field: ‘local’
[16:19:20.041]   - Field: ‘owner’
[16:19:20.041]   - Field: ‘envir’
[16:19:20.041]   - Field: ‘workers’
[16:19:20.041]   - Field: ‘packages’
[16:19:20.041]   - Field: ‘gc’
[16:19:20.041]   - Field: ‘conditions’
[16:19:20.041]   - Field: ‘persistent’
[16:19:20.041]   - Field: ‘expr’
[16:19:20.041]   - Field: ‘uuid’
[16:19:20.041]   - Field: ‘seed’
[16:19:20.042]   - Field: ‘version’
[16:19:20.042]   - Field: ‘result’
[16:19:20.042]   - Field: ‘asynchronous’
[16:19:20.042]   - Field: ‘calls’
[16:19:20.042]   - Field: ‘globals’
[16:19:20.042]   - Field: ‘stdout’
[16:19:20.042]   - Field: ‘earlySignal’
[16:19:20.042]   - Field: ‘lazy’
[16:19:20.042]   - Field: ‘state’
[16:19:20.042] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:20.042] - Launch lazy future ...
[16:19:20.043] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:20.043] Packages needed by future strategies (n = 0): <none>
[16:19:20.043] {
[16:19:20.043]     {
[16:19:20.043]         {
[16:19:20.043]             ...future.startTime <- base::Sys.time()
[16:19:20.043]             {
[16:19:20.043]                 {
[16:19:20.043]                   {
[16:19:20.043]                     {
[16:19:20.043]                       {
[16:19:20.043]                         base::local({
[16:19:20.043]                           has_future <- base::requireNamespace("future", 
[16:19:20.043]                             quietly = TRUE)
[16:19:20.043]                           if (has_future) {
[16:19:20.043]                             ns <- base::getNamespace("future")
[16:19:20.043]                             version <- ns[[".package"]][["version"]]
[16:19:20.043]                             if (is.null(version)) 
[16:19:20.043]                               version <- utils::packageVersion("future")
[16:19:20.043]                           }
[16:19:20.043]                           else {
[16:19:20.043]                             version <- NULL
[16:19:20.043]                           }
[16:19:20.043]                           if (!has_future || version < "1.8.0") {
[16:19:20.043]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:20.043]                               "", base::R.version$version.string), 
[16:19:20.043]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:20.043]                                 base::R.version$platform, 8 * 
[16:19:20.043]                                   base::.Machine$sizeof.pointer), 
[16:19:20.043]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:20.043]                                 "release", "version")], collapse = " "), 
[16:19:20.043]                               hostname = base::Sys.info()[["nodename"]])
[16:19:20.043]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:20.043]                               info)
[16:19:20.043]                             info <- base::paste(info, collapse = "; ")
[16:19:20.043]                             if (!has_future) {
[16:19:20.043]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:20.043]                                 info)
[16:19:20.043]                             }
[16:19:20.043]                             else {
[16:19:20.043]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:20.043]                                 info, version)
[16:19:20.043]                             }
[16:19:20.043]                             base::stop(msg)
[16:19:20.043]                           }
[16:19:20.043]                         })
[16:19:20.043]                       }
[16:19:20.043]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:20.043]                       base::options(mc.cores = 1L)
[16:19:20.043]                     }
[16:19:20.043]                     base::local({
[16:19:20.043]                       for (pkg in c("stats", "future.apply")) {
[16:19:20.043]                         base::loadNamespace(pkg)
[16:19:20.043]                         base::library(pkg, character.only = TRUE)
[16:19:20.043]                       }
[16:19:20.043]                     })
[16:19:20.043]                   }
[16:19:20.043]                   ...future.strategy.old <- future::plan("list")
[16:19:20.043]                   options(future.plan = NULL)
[16:19:20.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:20.043]                 }
[16:19:20.043]                 ...future.workdir <- getwd()
[16:19:20.043]             }
[16:19:20.043]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:20.043]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:20.043]         }
[16:19:20.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:20.043]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:20.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:20.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:20.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:20.043]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:20.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:20.043]             base::names(...future.oldOptions))
[16:19:20.043]     }
[16:19:20.043]     if (FALSE) {
[16:19:20.043]     }
[16:19:20.043]     else {
[16:19:20.043]         if (TRUE) {
[16:19:20.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:20.043]                 open = "w")
[16:19:20.043]         }
[16:19:20.043]         else {
[16:19:20.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:20.043]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:20.043]         }
[16:19:20.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:20.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:20.043]             base::sink(type = "output", split = FALSE)
[16:19:20.043]             base::close(...future.stdout)
[16:19:20.043]         }, add = TRUE)
[16:19:20.043]     }
[16:19:20.043]     ...future.frame <- base::sys.nframe()
[16:19:20.043]     ...future.conditions <- base::list()
[16:19:20.043]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:20.043]     if (FALSE) {
[16:19:20.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:20.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:20.043]     }
[16:19:20.043]     ...future.result <- base::tryCatch({
[16:19:20.043]         base::withCallingHandlers({
[16:19:20.043]             ...future.value <- base::withVisible(base::local({
[16:19:20.043]                 ...future.makeSendCondition <- base::local({
[16:19:20.043]                   sendCondition <- NULL
[16:19:20.043]                   function(frame = 1L) {
[16:19:20.043]                     if (is.function(sendCondition)) 
[16:19:20.043]                       return(sendCondition)
[16:19:20.043]                     ns <- getNamespace("parallel")
[16:19:20.043]                     if (exists("sendData", mode = "function", 
[16:19:20.043]                       envir = ns)) {
[16:19:20.043]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:20.043]                         envir = ns)
[16:19:20.043]                       envir <- sys.frame(frame)
[16:19:20.043]                       master <- NULL
[16:19:20.043]                       while (!identical(envir, .GlobalEnv) && 
[16:19:20.043]                         !identical(envir, emptyenv())) {
[16:19:20.043]                         if (exists("master", mode = "list", envir = envir, 
[16:19:20.043]                           inherits = FALSE)) {
[16:19:20.043]                           master <- get("master", mode = "list", 
[16:19:20.043]                             envir = envir, inherits = FALSE)
[16:19:20.043]                           if (inherits(master, c("SOCKnode", 
[16:19:20.043]                             "SOCK0node"))) {
[16:19:20.043]                             sendCondition <<- function(cond) {
[16:19:20.043]                               data <- list(type = "VALUE", value = cond, 
[16:19:20.043]                                 success = TRUE)
[16:19:20.043]                               parallel_sendData(master, data)
[16:19:20.043]                             }
[16:19:20.043]                             return(sendCondition)
[16:19:20.043]                           }
[16:19:20.043]                         }
[16:19:20.043]                         frame <- frame + 1L
[16:19:20.043]                         envir <- sys.frame(frame)
[16:19:20.043]                       }
[16:19:20.043]                     }
[16:19:20.043]                     sendCondition <<- function(cond) NULL
[16:19:20.043]                   }
[16:19:20.043]                 })
[16:19:20.043]                 withCallingHandlers({
[16:19:20.043]                   {
[16:19:20.043]                     do.call(function(...) {
[16:19:20.043]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.043]                       if (!identical(...future.globals.maxSize.org, 
[16:19:20.043]                         ...future.globals.maxSize)) {
[16:19:20.043]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.043]                         on.exit(options(oopts), add = TRUE)
[16:19:20.043]                       }
[16:19:20.043]                       {
[16:19:20.043]                         lapply(seq_along(...future.elements_ii), 
[16:19:20.043]                           FUN = function(jj) {
[16:19:20.043]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.043]                             ...future.FUN(...future.X_jj, ...)
[16:19:20.043]                           })
[16:19:20.043]                       }
[16:19:20.043]                     }, args = future.call.arguments)
[16:19:20.043]                   }
[16:19:20.043]                 }, immediateCondition = function(cond) {
[16:19:20.043]                   sendCondition <- ...future.makeSendCondition()
[16:19:20.043]                   sendCondition(cond)
[16:19:20.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.043]                   {
[16:19:20.043]                     inherits <- base::inherits
[16:19:20.043]                     invokeRestart <- base::invokeRestart
[16:19:20.043]                     is.null <- base::is.null
[16:19:20.043]                     muffled <- FALSE
[16:19:20.043]                     if (inherits(cond, "message")) {
[16:19:20.043]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:20.043]                       if (muffled) 
[16:19:20.043]                         invokeRestart("muffleMessage")
[16:19:20.043]                     }
[16:19:20.043]                     else if (inherits(cond, "warning")) {
[16:19:20.043]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:20.043]                       if (muffled) 
[16:19:20.043]                         invokeRestart("muffleWarning")
[16:19:20.043]                     }
[16:19:20.043]                     else if (inherits(cond, "condition")) {
[16:19:20.043]                       if (!is.null(pattern)) {
[16:19:20.043]                         computeRestarts <- base::computeRestarts
[16:19:20.043]                         grepl <- base::grepl
[16:19:20.043]                         restarts <- computeRestarts(cond)
[16:19:20.043]                         for (restart in restarts) {
[16:19:20.043]                           name <- restart$name
[16:19:20.043]                           if (is.null(name)) 
[16:19:20.043]                             next
[16:19:20.043]                           if (!grepl(pattern, name)) 
[16:19:20.043]                             next
[16:19:20.043]                           invokeRestart(restart)
[16:19:20.043]                           muffled <- TRUE
[16:19:20.043]                           break
[16:19:20.043]                         }
[16:19:20.043]                       }
[16:19:20.043]                     }
[16:19:20.043]                     invisible(muffled)
[16:19:20.043]                   }
[16:19:20.043]                   muffleCondition(cond)
[16:19:20.043]                 })
[16:19:20.043]             }))
[16:19:20.043]             future::FutureResult(value = ...future.value$value, 
[16:19:20.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.043]                   ...future.rng), globalenv = if (FALSE) 
[16:19:20.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:20.043]                     ...future.globalenv.names))
[16:19:20.043]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:20.043]         }, condition = base::local({
[16:19:20.043]             c <- base::c
[16:19:20.043]             inherits <- base::inherits
[16:19:20.043]             invokeRestart <- base::invokeRestart
[16:19:20.043]             length <- base::length
[16:19:20.043]             list <- base::list
[16:19:20.043]             seq.int <- base::seq.int
[16:19:20.043]             signalCondition <- base::signalCondition
[16:19:20.043]             sys.calls <- base::sys.calls
[16:19:20.043]             `[[` <- base::`[[`
[16:19:20.043]             `+` <- base::`+`
[16:19:20.043]             `<<-` <- base::`<<-`
[16:19:20.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:20.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:20.043]                   3L)]
[16:19:20.043]             }
[16:19:20.043]             function(cond) {
[16:19:20.043]                 is_error <- inherits(cond, "error")
[16:19:20.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:20.043]                   NULL)
[16:19:20.043]                 if (is_error) {
[16:19:20.043]                   sessionInformation <- function() {
[16:19:20.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:20.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:20.043]                       search = base::search(), system = base::Sys.info())
[16:19:20.043]                   }
[16:19:20.043]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:20.043]                     cond$call), session = sessionInformation(), 
[16:19:20.043]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:20.043]                   signalCondition(cond)
[16:19:20.043]                 }
[16:19:20.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:20.043]                 "immediateCondition"))) {
[16:19:20.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:20.043]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:20.043]                   if (TRUE && !signal) {
[16:19:20.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.043]                     {
[16:19:20.043]                       inherits <- base::inherits
[16:19:20.043]                       invokeRestart <- base::invokeRestart
[16:19:20.043]                       is.null <- base::is.null
[16:19:20.043]                       muffled <- FALSE
[16:19:20.043]                       if (inherits(cond, "message")) {
[16:19:20.043]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.043]                         if (muffled) 
[16:19:20.043]                           invokeRestart("muffleMessage")
[16:19:20.043]                       }
[16:19:20.043]                       else if (inherits(cond, "warning")) {
[16:19:20.043]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.043]                         if (muffled) 
[16:19:20.043]                           invokeRestart("muffleWarning")
[16:19:20.043]                       }
[16:19:20.043]                       else if (inherits(cond, "condition")) {
[16:19:20.043]                         if (!is.null(pattern)) {
[16:19:20.043]                           computeRestarts <- base::computeRestarts
[16:19:20.043]                           grepl <- base::grepl
[16:19:20.043]                           restarts <- computeRestarts(cond)
[16:19:20.043]                           for (restart in restarts) {
[16:19:20.043]                             name <- restart$name
[16:19:20.043]                             if (is.null(name)) 
[16:19:20.043]                               next
[16:19:20.043]                             if (!grepl(pattern, name)) 
[16:19:20.043]                               next
[16:19:20.043]                             invokeRestart(restart)
[16:19:20.043]                             muffled <- TRUE
[16:19:20.043]                             break
[16:19:20.043]                           }
[16:19:20.043]                         }
[16:19:20.043]                       }
[16:19:20.043]                       invisible(muffled)
[16:19:20.043]                     }
[16:19:20.043]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.043]                   }
[16:19:20.043]                 }
[16:19:20.043]                 else {
[16:19:20.043]                   if (TRUE) {
[16:19:20.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.043]                     {
[16:19:20.043]                       inherits <- base::inherits
[16:19:20.043]                       invokeRestart <- base::invokeRestart
[16:19:20.043]                       is.null <- base::is.null
[16:19:20.043]                       muffled <- FALSE
[16:19:20.043]                       if (inherits(cond, "message")) {
[16:19:20.043]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.043]                         if (muffled) 
[16:19:20.043]                           invokeRestart("muffleMessage")
[16:19:20.043]                       }
[16:19:20.043]                       else if (inherits(cond, "warning")) {
[16:19:20.043]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.043]                         if (muffled) 
[16:19:20.043]                           invokeRestart("muffleWarning")
[16:19:20.043]                       }
[16:19:20.043]                       else if (inherits(cond, "condition")) {
[16:19:20.043]                         if (!is.null(pattern)) {
[16:19:20.043]                           computeRestarts <- base::computeRestarts
[16:19:20.043]                           grepl <- base::grepl
[16:19:20.043]                           restarts <- computeRestarts(cond)
[16:19:20.043]                           for (restart in restarts) {
[16:19:20.043]                             name <- restart$name
[16:19:20.043]                             if (is.null(name)) 
[16:19:20.043]                               next
[16:19:20.043]                             if (!grepl(pattern, name)) 
[16:19:20.043]                               next
[16:19:20.043]                             invokeRestart(restart)
[16:19:20.043]                             muffled <- TRUE
[16:19:20.043]                             break
[16:19:20.043]                           }
[16:19:20.043]                         }
[16:19:20.043]                       }
[16:19:20.043]                       invisible(muffled)
[16:19:20.043]                     }
[16:19:20.043]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.043]                   }
[16:19:20.043]                 }
[16:19:20.043]             }
[16:19:20.043]         }))
[16:19:20.043]     }, error = function(ex) {
[16:19:20.043]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:20.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.043]                 ...future.rng), started = ...future.startTime, 
[16:19:20.043]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:20.043]             version = "1.8"), class = "FutureResult")
[16:19:20.043]     }, finally = {
[16:19:20.043]         if (!identical(...future.workdir, getwd())) 
[16:19:20.043]             setwd(...future.workdir)
[16:19:20.043]         {
[16:19:20.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:20.043]                 ...future.oldOptions$nwarnings <- NULL
[16:19:20.043]             }
[16:19:20.043]             base::options(...future.oldOptions)
[16:19:20.043]             if (.Platform$OS.type == "windows") {
[16:19:20.043]                 old_names <- names(...future.oldEnvVars)
[16:19:20.043]                 envs <- base::Sys.getenv()
[16:19:20.043]                 names <- names(envs)
[16:19:20.043]                 common <- intersect(names, old_names)
[16:19:20.043]                 added <- setdiff(names, old_names)
[16:19:20.043]                 removed <- setdiff(old_names, names)
[16:19:20.043]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:20.043]                   envs[common]]
[16:19:20.043]                 NAMES <- toupper(changed)
[16:19:20.043]                 args <- list()
[16:19:20.043]                 for (kk in seq_along(NAMES)) {
[16:19:20.043]                   name <- changed[[kk]]
[16:19:20.043]                   NAME <- NAMES[[kk]]
[16:19:20.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.043]                     next
[16:19:20.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.043]                 }
[16:19:20.043]                 NAMES <- toupper(added)
[16:19:20.043]                 for (kk in seq_along(NAMES)) {
[16:19:20.043]                   name <- added[[kk]]
[16:19:20.043]                   NAME <- NAMES[[kk]]
[16:19:20.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.043]                     next
[16:19:20.043]                   args[[name]] <- ""
[16:19:20.043]                 }
[16:19:20.043]                 NAMES <- toupper(removed)
[16:19:20.043]                 for (kk in seq_along(NAMES)) {
[16:19:20.043]                   name <- removed[[kk]]
[16:19:20.043]                   NAME <- NAMES[[kk]]
[16:19:20.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.043]                     next
[16:19:20.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.043]                 }
[16:19:20.043]                 if (length(args) > 0) 
[16:19:20.043]                   base::do.call(base::Sys.setenv, args = args)
[16:19:20.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:20.043]             }
[16:19:20.043]             else {
[16:19:20.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:20.043]             }
[16:19:20.043]             {
[16:19:20.043]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:20.043]                   0L) {
[16:19:20.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:20.043]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:20.043]                   base::options(opts)
[16:19:20.043]                 }
[16:19:20.043]                 {
[16:19:20.043]                   {
[16:19:20.043]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:20.043]                     NULL
[16:19:20.043]                   }
[16:19:20.043]                   options(future.plan = NULL)
[16:19:20.043]                   if (is.na(NA_character_)) 
[16:19:20.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:20.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:20.043]                     .init = FALSE)
[16:19:20.043]                 }
[16:19:20.043]             }
[16:19:20.043]         }
[16:19:20.043]     })
[16:19:20.043]     if (TRUE) {
[16:19:20.043]         base::sink(type = "output", split = FALSE)
[16:19:20.043]         if (TRUE) {
[16:19:20.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:20.043]         }
[16:19:20.043]         else {
[16:19:20.043]             ...future.result["stdout"] <- base::list(NULL)
[16:19:20.043]         }
[16:19:20.043]         base::close(...future.stdout)
[16:19:20.043]         ...future.stdout <- NULL
[16:19:20.043]     }
[16:19:20.043]     ...future.result$conditions <- ...future.conditions
[16:19:20.043]     ...future.result$finished <- base::Sys.time()
[16:19:20.043]     ...future.result
[16:19:20.043] }
[16:19:20.046] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[16:19:20.046] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:20.089] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:20.089] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[16:19:20.132] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[16:19:20.133] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:20.133] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:20.133] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:20.176] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:20.177] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:20.221] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:20.221] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:20.221] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.221] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:20.222] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:20.222] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:20.223] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.223] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[16:19:20.223] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[16:19:20.223] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:20.224] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.224] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:20.224] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.224] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[16:19:20.225] MultisessionFuture started
[16:19:20.225] - Launch lazy future ... done
[16:19:20.225] run() for ‘MultisessionFuture’ ... done
[16:19:20.225] Created future:
[16:19:20.227] receiveMessageFromWorker() for ClusterFuture ...
[16:19:20.227] - Validating connection of MultisessionFuture
[16:19:20.227] - received message: FutureResult
[16:19:20.227] - Received FutureResult
[16:19:20.227] - Erased future from FutureRegistry
[16:19:20.228] result() for ClusterFuture ...
[16:19:20.228] - result already collected: FutureResult
[16:19:20.228] result() for ClusterFuture ... done
[16:19:20.228] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:20.225] MultisessionFuture:
[16:19:20.225] Label: ‘future_vapply-1’
[16:19:20.225] Expression:
[16:19:20.225] {
[16:19:20.225]     do.call(function(...) {
[16:19:20.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.225]             on.exit(options(oopts), add = TRUE)
[16:19:20.225]         }
[16:19:20.225]         {
[16:19:20.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.225]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.225]             })
[16:19:20.225]         }
[16:19:20.225]     }, args = future.call.arguments)
[16:19:20.225] }
[16:19:20.225] Lazy evaluation: FALSE
[16:19:20.225] Asynchronous evaluation: TRUE
[16:19:20.225] Local evaluation: TRUE
[16:19:20.225] Environment: R_GlobalEnv
[16:19:20.225] Capture standard output: TRUE
[16:19:20.225] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:20.225] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:20.225] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:20.225] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:20.225] Resolved: TRUE
[16:19:20.225] Value: <not collected>
[16:19:20.225] Conditions captured: <none>
[16:19:20.225] Early signaling: FALSE
[16:19:20.225] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:20.225] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.228] Chunk #1 of 2 ... DONE
[16:19:20.228] Chunk #2 of 2 ...
[16:19:20.228]  - Finding globals in 'X' for chunk #2 ...
[16:19:20.229] getGlobalsAndPackages() ...
[16:19:20.229] Searching for globals...
[16:19:20.229] 
[16:19:20.229] Searching for globals ... DONE
[16:19:20.229] - globals: [0] <none>
[16:19:20.229] getGlobalsAndPackages() ... DONE
[16:19:20.229]    + additional globals found: [n=0] 
[16:19:20.229]    + additional namespaces needed: [n=0] 
[16:19:20.229]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:20.230]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:20.230]  - seeds: <none>
[16:19:20.230]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.230] getGlobalsAndPackages() ...
[16:19:20.230] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.230] Resolving globals: FALSE
[16:19:20.230] Tweak future expression to call with '...' arguments ...
[16:19:20.230] {
[16:19:20.230]     do.call(function(...) {
[16:19:20.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.230]             on.exit(options(oopts), add = TRUE)
[16:19:20.230]         }
[16:19:20.230]         {
[16:19:20.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.230]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.230]             })
[16:19:20.230]         }
[16:19:20.230]     }, args = future.call.arguments)
[16:19:20.230] }
[16:19:20.230] Tweak future expression to call with '...' arguments ... DONE
[16:19:20.231] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.231] - packages: [2] ‘stats’, ‘future.apply’
[16:19:20.231] getGlobalsAndPackages() ... DONE
[16:19:20.232] run() for ‘Future’ ...
[16:19:20.232] - state: ‘created’
[16:19:20.232] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:20.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:20.246]   - Field: ‘node’
[16:19:20.246]   - Field: ‘label’
[16:19:20.246]   - Field: ‘local’
[16:19:20.246]   - Field: ‘owner’
[16:19:20.246]   - Field: ‘envir’
[16:19:20.246]   - Field: ‘workers’
[16:19:20.246]   - Field: ‘packages’
[16:19:20.246]   - Field: ‘gc’
[16:19:20.246]   - Field: ‘conditions’
[16:19:20.247]   - Field: ‘persistent’
[16:19:20.247]   - Field: ‘expr’
[16:19:20.247]   - Field: ‘uuid’
[16:19:20.247]   - Field: ‘seed’
[16:19:20.247]   - Field: ‘version’
[16:19:20.247]   - Field: ‘result’
[16:19:20.247]   - Field: ‘asynchronous’
[16:19:20.247]   - Field: ‘calls’
[16:19:20.247]   - Field: ‘globals’
[16:19:20.247]   - Field: ‘stdout’
[16:19:20.247]   - Field: ‘earlySignal’
[16:19:20.247]   - Field: ‘lazy’
[16:19:20.248]   - Field: ‘state’
[16:19:20.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:20.248] - Launch lazy future ...
[16:19:20.248] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:19:20.248] Packages needed by future strategies (n = 0): <none>
[16:19:20.249] {
[16:19:20.249]     {
[16:19:20.249]         {
[16:19:20.249]             ...future.startTime <- base::Sys.time()
[16:19:20.249]             {
[16:19:20.249]                 {
[16:19:20.249]                   {
[16:19:20.249]                     {
[16:19:20.249]                       {
[16:19:20.249]                         base::local({
[16:19:20.249]                           has_future <- base::requireNamespace("future", 
[16:19:20.249]                             quietly = TRUE)
[16:19:20.249]                           if (has_future) {
[16:19:20.249]                             ns <- base::getNamespace("future")
[16:19:20.249]                             version <- ns[[".package"]][["version"]]
[16:19:20.249]                             if (is.null(version)) 
[16:19:20.249]                               version <- utils::packageVersion("future")
[16:19:20.249]                           }
[16:19:20.249]                           else {
[16:19:20.249]                             version <- NULL
[16:19:20.249]                           }
[16:19:20.249]                           if (!has_future || version < "1.8.0") {
[16:19:20.249]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:20.249]                               "", base::R.version$version.string), 
[16:19:20.249]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:20.249]                                 base::R.version$platform, 8 * 
[16:19:20.249]                                   base::.Machine$sizeof.pointer), 
[16:19:20.249]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:20.249]                                 "release", "version")], collapse = " "), 
[16:19:20.249]                               hostname = base::Sys.info()[["nodename"]])
[16:19:20.249]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:20.249]                               info)
[16:19:20.249]                             info <- base::paste(info, collapse = "; ")
[16:19:20.249]                             if (!has_future) {
[16:19:20.249]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:20.249]                                 info)
[16:19:20.249]                             }
[16:19:20.249]                             else {
[16:19:20.249]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:20.249]                                 info, version)
[16:19:20.249]                             }
[16:19:20.249]                             base::stop(msg)
[16:19:20.249]                           }
[16:19:20.249]                         })
[16:19:20.249]                       }
[16:19:20.249]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:20.249]                       base::options(mc.cores = 1L)
[16:19:20.249]                     }
[16:19:20.249]                     base::local({
[16:19:20.249]                       for (pkg in c("stats", "future.apply")) {
[16:19:20.249]                         base::loadNamespace(pkg)
[16:19:20.249]                         base::library(pkg, character.only = TRUE)
[16:19:20.249]                       }
[16:19:20.249]                     })
[16:19:20.249]                   }
[16:19:20.249]                   ...future.strategy.old <- future::plan("list")
[16:19:20.249]                   options(future.plan = NULL)
[16:19:20.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:20.249]                 }
[16:19:20.249]                 ...future.workdir <- getwd()
[16:19:20.249]             }
[16:19:20.249]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:20.249]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:20.249]         }
[16:19:20.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:20.249]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:20.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:20.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:20.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:20.249]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:20.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:20.249]             base::names(...future.oldOptions))
[16:19:20.249]     }
[16:19:20.249]     if (FALSE) {
[16:19:20.249]     }
[16:19:20.249]     else {
[16:19:20.249]         if (TRUE) {
[16:19:20.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:20.249]                 open = "w")
[16:19:20.249]         }
[16:19:20.249]         else {
[16:19:20.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:20.249]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:20.249]         }
[16:19:20.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:20.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:20.249]             base::sink(type = "output", split = FALSE)
[16:19:20.249]             base::close(...future.stdout)
[16:19:20.249]         }, add = TRUE)
[16:19:20.249]     }
[16:19:20.249]     ...future.frame <- base::sys.nframe()
[16:19:20.249]     ...future.conditions <- base::list()
[16:19:20.249]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:20.249]     if (FALSE) {
[16:19:20.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:20.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:20.249]     }
[16:19:20.249]     ...future.result <- base::tryCatch({
[16:19:20.249]         base::withCallingHandlers({
[16:19:20.249]             ...future.value <- base::withVisible(base::local({
[16:19:20.249]                 ...future.makeSendCondition <- base::local({
[16:19:20.249]                   sendCondition <- NULL
[16:19:20.249]                   function(frame = 1L) {
[16:19:20.249]                     if (is.function(sendCondition)) 
[16:19:20.249]                       return(sendCondition)
[16:19:20.249]                     ns <- getNamespace("parallel")
[16:19:20.249]                     if (exists("sendData", mode = "function", 
[16:19:20.249]                       envir = ns)) {
[16:19:20.249]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:20.249]                         envir = ns)
[16:19:20.249]                       envir <- sys.frame(frame)
[16:19:20.249]                       master <- NULL
[16:19:20.249]                       while (!identical(envir, .GlobalEnv) && 
[16:19:20.249]                         !identical(envir, emptyenv())) {
[16:19:20.249]                         if (exists("master", mode = "list", envir = envir, 
[16:19:20.249]                           inherits = FALSE)) {
[16:19:20.249]                           master <- get("master", mode = "list", 
[16:19:20.249]                             envir = envir, inherits = FALSE)
[16:19:20.249]                           if (inherits(master, c("SOCKnode", 
[16:19:20.249]                             "SOCK0node"))) {
[16:19:20.249]                             sendCondition <<- function(cond) {
[16:19:20.249]                               data <- list(type = "VALUE", value = cond, 
[16:19:20.249]                                 success = TRUE)
[16:19:20.249]                               parallel_sendData(master, data)
[16:19:20.249]                             }
[16:19:20.249]                             return(sendCondition)
[16:19:20.249]                           }
[16:19:20.249]                         }
[16:19:20.249]                         frame <- frame + 1L
[16:19:20.249]                         envir <- sys.frame(frame)
[16:19:20.249]                       }
[16:19:20.249]                     }
[16:19:20.249]                     sendCondition <<- function(cond) NULL
[16:19:20.249]                   }
[16:19:20.249]                 })
[16:19:20.249]                 withCallingHandlers({
[16:19:20.249]                   {
[16:19:20.249]                     do.call(function(...) {
[16:19:20.249]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.249]                       if (!identical(...future.globals.maxSize.org, 
[16:19:20.249]                         ...future.globals.maxSize)) {
[16:19:20.249]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.249]                         on.exit(options(oopts), add = TRUE)
[16:19:20.249]                       }
[16:19:20.249]                       {
[16:19:20.249]                         lapply(seq_along(...future.elements_ii), 
[16:19:20.249]                           FUN = function(jj) {
[16:19:20.249]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.249]                             ...future.FUN(...future.X_jj, ...)
[16:19:20.249]                           })
[16:19:20.249]                       }
[16:19:20.249]                     }, args = future.call.arguments)
[16:19:20.249]                   }
[16:19:20.249]                 }, immediateCondition = function(cond) {
[16:19:20.249]                   sendCondition <- ...future.makeSendCondition()
[16:19:20.249]                   sendCondition(cond)
[16:19:20.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.249]                   {
[16:19:20.249]                     inherits <- base::inherits
[16:19:20.249]                     invokeRestart <- base::invokeRestart
[16:19:20.249]                     is.null <- base::is.null
[16:19:20.249]                     muffled <- FALSE
[16:19:20.249]                     if (inherits(cond, "message")) {
[16:19:20.249]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:20.249]                       if (muffled) 
[16:19:20.249]                         invokeRestart("muffleMessage")
[16:19:20.249]                     }
[16:19:20.249]                     else if (inherits(cond, "warning")) {
[16:19:20.249]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:20.249]                       if (muffled) 
[16:19:20.249]                         invokeRestart("muffleWarning")
[16:19:20.249]                     }
[16:19:20.249]                     else if (inherits(cond, "condition")) {
[16:19:20.249]                       if (!is.null(pattern)) {
[16:19:20.249]                         computeRestarts <- base::computeRestarts
[16:19:20.249]                         grepl <- base::grepl
[16:19:20.249]                         restarts <- computeRestarts(cond)
[16:19:20.249]                         for (restart in restarts) {
[16:19:20.249]                           name <- restart$name
[16:19:20.249]                           if (is.null(name)) 
[16:19:20.249]                             next
[16:19:20.249]                           if (!grepl(pattern, name)) 
[16:19:20.249]                             next
[16:19:20.249]                           invokeRestart(restart)
[16:19:20.249]                           muffled <- TRUE
[16:19:20.249]                           break
[16:19:20.249]                         }
[16:19:20.249]                       }
[16:19:20.249]                     }
[16:19:20.249]                     invisible(muffled)
[16:19:20.249]                   }
[16:19:20.249]                   muffleCondition(cond)
[16:19:20.249]                 })
[16:19:20.249]             }))
[16:19:20.249]             future::FutureResult(value = ...future.value$value, 
[16:19:20.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.249]                   ...future.rng), globalenv = if (FALSE) 
[16:19:20.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:20.249]                     ...future.globalenv.names))
[16:19:20.249]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:20.249]         }, condition = base::local({
[16:19:20.249]             c <- base::c
[16:19:20.249]             inherits <- base::inherits
[16:19:20.249]             invokeRestart <- base::invokeRestart
[16:19:20.249]             length <- base::length
[16:19:20.249]             list <- base::list
[16:19:20.249]             seq.int <- base::seq.int
[16:19:20.249]             signalCondition <- base::signalCondition
[16:19:20.249]             sys.calls <- base::sys.calls
[16:19:20.249]             `[[` <- base::`[[`
[16:19:20.249]             `+` <- base::`+`
[16:19:20.249]             `<<-` <- base::`<<-`
[16:19:20.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:20.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:20.249]                   3L)]
[16:19:20.249]             }
[16:19:20.249]             function(cond) {
[16:19:20.249]                 is_error <- inherits(cond, "error")
[16:19:20.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:20.249]                   NULL)
[16:19:20.249]                 if (is_error) {
[16:19:20.249]                   sessionInformation <- function() {
[16:19:20.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:20.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:20.249]                       search = base::search(), system = base::Sys.info())
[16:19:20.249]                   }
[16:19:20.249]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:20.249]                     cond$call), session = sessionInformation(), 
[16:19:20.249]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:20.249]                   signalCondition(cond)
[16:19:20.249]                 }
[16:19:20.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:20.249]                 "immediateCondition"))) {
[16:19:20.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:20.249]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:20.249]                   if (TRUE && !signal) {
[16:19:20.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.249]                     {
[16:19:20.249]                       inherits <- base::inherits
[16:19:20.249]                       invokeRestart <- base::invokeRestart
[16:19:20.249]                       is.null <- base::is.null
[16:19:20.249]                       muffled <- FALSE
[16:19:20.249]                       if (inherits(cond, "message")) {
[16:19:20.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.249]                         if (muffled) 
[16:19:20.249]                           invokeRestart("muffleMessage")
[16:19:20.249]                       }
[16:19:20.249]                       else if (inherits(cond, "warning")) {
[16:19:20.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.249]                         if (muffled) 
[16:19:20.249]                           invokeRestart("muffleWarning")
[16:19:20.249]                       }
[16:19:20.249]                       else if (inherits(cond, "condition")) {
[16:19:20.249]                         if (!is.null(pattern)) {
[16:19:20.249]                           computeRestarts <- base::computeRestarts
[16:19:20.249]                           grepl <- base::grepl
[16:19:20.249]                           restarts <- computeRestarts(cond)
[16:19:20.249]                           for (restart in restarts) {
[16:19:20.249]                             name <- restart$name
[16:19:20.249]                             if (is.null(name)) 
[16:19:20.249]                               next
[16:19:20.249]                             if (!grepl(pattern, name)) 
[16:19:20.249]                               next
[16:19:20.249]                             invokeRestart(restart)
[16:19:20.249]                             muffled <- TRUE
[16:19:20.249]                             break
[16:19:20.249]                           }
[16:19:20.249]                         }
[16:19:20.249]                       }
[16:19:20.249]                       invisible(muffled)
[16:19:20.249]                     }
[16:19:20.249]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.249]                   }
[16:19:20.249]                 }
[16:19:20.249]                 else {
[16:19:20.249]                   if (TRUE) {
[16:19:20.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.249]                     {
[16:19:20.249]                       inherits <- base::inherits
[16:19:20.249]                       invokeRestart <- base::invokeRestart
[16:19:20.249]                       is.null <- base::is.null
[16:19:20.249]                       muffled <- FALSE
[16:19:20.249]                       if (inherits(cond, "message")) {
[16:19:20.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.249]                         if (muffled) 
[16:19:20.249]                           invokeRestart("muffleMessage")
[16:19:20.249]                       }
[16:19:20.249]                       else if (inherits(cond, "warning")) {
[16:19:20.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.249]                         if (muffled) 
[16:19:20.249]                           invokeRestart("muffleWarning")
[16:19:20.249]                       }
[16:19:20.249]                       else if (inherits(cond, "condition")) {
[16:19:20.249]                         if (!is.null(pattern)) {
[16:19:20.249]                           computeRestarts <- base::computeRestarts
[16:19:20.249]                           grepl <- base::grepl
[16:19:20.249]                           restarts <- computeRestarts(cond)
[16:19:20.249]                           for (restart in restarts) {
[16:19:20.249]                             name <- restart$name
[16:19:20.249]                             if (is.null(name)) 
[16:19:20.249]                               next
[16:19:20.249]                             if (!grepl(pattern, name)) 
[16:19:20.249]                               next
[16:19:20.249]                             invokeRestart(restart)
[16:19:20.249]                             muffled <- TRUE
[16:19:20.249]                             break
[16:19:20.249]                           }
[16:19:20.249]                         }
[16:19:20.249]                       }
[16:19:20.249]                       invisible(muffled)
[16:19:20.249]                     }
[16:19:20.249]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.249]                   }
[16:19:20.249]                 }
[16:19:20.249]             }
[16:19:20.249]         }))
[16:19:20.249]     }, error = function(ex) {
[16:19:20.249]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:20.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.249]                 ...future.rng), started = ...future.startTime, 
[16:19:20.249]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:20.249]             version = "1.8"), class = "FutureResult")
[16:19:20.249]     }, finally = {
[16:19:20.249]         if (!identical(...future.workdir, getwd())) 
[16:19:20.249]             setwd(...future.workdir)
[16:19:20.249]         {
[16:19:20.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:20.249]                 ...future.oldOptions$nwarnings <- NULL
[16:19:20.249]             }
[16:19:20.249]             base::options(...future.oldOptions)
[16:19:20.249]             if (.Platform$OS.type == "windows") {
[16:19:20.249]                 old_names <- names(...future.oldEnvVars)
[16:19:20.249]                 envs <- base::Sys.getenv()
[16:19:20.249]                 names <- names(envs)
[16:19:20.249]                 common <- intersect(names, old_names)
[16:19:20.249]                 added <- setdiff(names, old_names)
[16:19:20.249]                 removed <- setdiff(old_names, names)
[16:19:20.249]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:20.249]                   envs[common]]
[16:19:20.249]                 NAMES <- toupper(changed)
[16:19:20.249]                 args <- list()
[16:19:20.249]                 for (kk in seq_along(NAMES)) {
[16:19:20.249]                   name <- changed[[kk]]
[16:19:20.249]                   NAME <- NAMES[[kk]]
[16:19:20.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.249]                     next
[16:19:20.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.249]                 }
[16:19:20.249]                 NAMES <- toupper(added)
[16:19:20.249]                 for (kk in seq_along(NAMES)) {
[16:19:20.249]                   name <- added[[kk]]
[16:19:20.249]                   NAME <- NAMES[[kk]]
[16:19:20.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.249]                     next
[16:19:20.249]                   args[[name]] <- ""
[16:19:20.249]                 }
[16:19:20.249]                 NAMES <- toupper(removed)
[16:19:20.249]                 for (kk in seq_along(NAMES)) {
[16:19:20.249]                   name <- removed[[kk]]
[16:19:20.249]                   NAME <- NAMES[[kk]]
[16:19:20.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.249]                     next
[16:19:20.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.249]                 }
[16:19:20.249]                 if (length(args) > 0) 
[16:19:20.249]                   base::do.call(base::Sys.setenv, args = args)
[16:19:20.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:20.249]             }
[16:19:20.249]             else {
[16:19:20.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:20.249]             }
[16:19:20.249]             {
[16:19:20.249]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:20.249]                   0L) {
[16:19:20.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:20.249]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:20.249]                   base::options(opts)
[16:19:20.249]                 }
[16:19:20.249]                 {
[16:19:20.249]                   {
[16:19:20.249]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:20.249]                     NULL
[16:19:20.249]                   }
[16:19:20.249]                   options(future.plan = NULL)
[16:19:20.249]                   if (is.na(NA_character_)) 
[16:19:20.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:20.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:20.249]                     .init = FALSE)
[16:19:20.249]                 }
[16:19:20.249]             }
[16:19:20.249]         }
[16:19:20.249]     })
[16:19:20.249]     if (TRUE) {
[16:19:20.249]         base::sink(type = "output", split = FALSE)
[16:19:20.249]         if (TRUE) {
[16:19:20.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:20.249]         }
[16:19:20.249]         else {
[16:19:20.249]             ...future.result["stdout"] <- base::list(NULL)
[16:19:20.249]         }
[16:19:20.249]         base::close(...future.stdout)
[16:19:20.249]         ...future.stdout <- NULL
[16:19:20.249]     }
[16:19:20.249]     ...future.result$conditions <- ...future.conditions
[16:19:20.249]     ...future.result$finished <- base::Sys.time()
[16:19:20.249]     ...future.result
[16:19:20.249] }
[16:19:20.251] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[16:19:20.251] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:20.293] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:20.293] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[16:19:20.336] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[16:19:20.337] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:20.337] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:20.337] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:20.380] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:20.381] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:20.425] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:20.425] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:20.425] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.425] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:20.426] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:20.426] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:20.429] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.429] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ...
[16:19:20.430] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ... DONE
[16:19:20.430] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:20.430] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.430] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:20.431] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.431] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[16:19:20.431] MultisessionFuture started
[16:19:20.431] - Launch lazy future ... done
[16:19:20.432] run() for ‘MultisessionFuture’ ... done
[16:19:20.432] Created future:
[16:19:20.433] receiveMessageFromWorker() for ClusterFuture ...
[16:19:20.433] - Validating connection of MultisessionFuture
[16:19:20.434] - received message: FutureResult
[16:19:20.434] - Received FutureResult
[16:19:20.434] - Erased future from FutureRegistry
[16:19:20.434] result() for ClusterFuture ...
[16:19:20.434] - result already collected: FutureResult
[16:19:20.434] result() for ClusterFuture ... done
[16:19:20.434] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:20.432] MultisessionFuture:
[16:19:20.432] Label: ‘future_vapply-2’
[16:19:20.432] Expression:
[16:19:20.432] {
[16:19:20.432]     do.call(function(...) {
[16:19:20.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.432]             on.exit(options(oopts), add = TRUE)
[16:19:20.432]         }
[16:19:20.432]         {
[16:19:20.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.432]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.432]             })
[16:19:20.432]         }
[16:19:20.432]     }, args = future.call.arguments)
[16:19:20.432] }
[16:19:20.432] Lazy evaluation: FALSE
[16:19:20.432] Asynchronous evaluation: TRUE
[16:19:20.432] Local evaluation: TRUE
[16:19:20.432] Environment: R_GlobalEnv
[16:19:20.432] Capture standard output: TRUE
[16:19:20.432] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:20.432] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:20.432] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:19:20.432] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:20.432] Resolved: TRUE
[16:19:20.432] Value: <not collected>
[16:19:20.432] Conditions captured: <none>
[16:19:20.432] Early signaling: FALSE
[16:19:20.432] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:20.432] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.434] Chunk #2 of 2 ... DONE
[16:19:20.435] Launching 2 futures (chunks) ... DONE
[16:19:20.435] Resolving 2 futures (chunks) ...
[16:19:20.435] resolve() on list ...
[16:19:20.435]  recursive: 0
[16:19:20.435]  length: 2
[16:19:20.435] 
[16:19:20.435] Future #1
[16:19:20.435] result() for ClusterFuture ...
[16:19:20.435] - result already collected: FutureResult
[16:19:20.435] result() for ClusterFuture ... done
[16:19:20.435] result() for ClusterFuture ...
[16:19:20.435] - result already collected: FutureResult
[16:19:20.436] result() for ClusterFuture ... done
[16:19:20.436] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:20.436] - nx: 2
[16:19:20.436] - relay: TRUE
[16:19:20.436] - stdout: TRUE
[16:19:20.436] - signal: TRUE
[16:19:20.436] - resignal: FALSE
[16:19:20.436] - force: TRUE
[16:19:20.436] - relayed: [n=2] FALSE, FALSE
[16:19:20.436] - queued futures: [n=2] FALSE, FALSE
[16:19:20.436]  - until=1
[16:19:20.437]  - relaying element #1
[16:19:20.437] result() for ClusterFuture ...
[16:19:20.437] - result already collected: FutureResult
[16:19:20.437] result() for ClusterFuture ... done
[16:19:20.437] result() for ClusterFuture ...
[16:19:20.437] - result already collected: FutureResult
[16:19:20.437] result() for ClusterFuture ... done
[16:19:20.437] result() for ClusterFuture ...
[16:19:20.437] - result already collected: FutureResult
[16:19:20.437] result() for ClusterFuture ... done
[16:19:20.437] result() for ClusterFuture ...
[16:19:20.438] - result already collected: FutureResult
[16:19:20.438] result() for ClusterFuture ... done
[16:19:20.438] - relayed: [n=2] TRUE, FALSE
[16:19:20.438] - queued futures: [n=2] TRUE, FALSE
[16:19:20.438] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:20.438]  length: 1 (resolved future 1)
[16:19:20.438] Future #2
[16:19:20.438] result() for ClusterFuture ...
[16:19:20.438] - result already collected: FutureResult
[16:19:20.438] result() for ClusterFuture ... done
[16:19:20.438] result() for ClusterFuture ...
[16:19:20.439] - result already collected: FutureResult
[16:19:20.439] result() for ClusterFuture ... done
[16:19:20.439] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:20.439] - nx: 2
[16:19:20.439] - relay: TRUE
[16:19:20.439] - stdout: TRUE
[16:19:20.439] - signal: TRUE
[16:19:20.439] - resignal: FALSE
[16:19:20.439] - force: TRUE
[16:19:20.439] - relayed: [n=2] TRUE, FALSE
[16:19:20.439] - queued futures: [n=2] TRUE, FALSE
[16:19:20.440]  - until=2
[16:19:20.440]  - relaying element #2
[16:19:20.440] result() for ClusterFuture ...
[16:19:20.440] - result already collected: FutureResult
[16:19:20.440] result() for ClusterFuture ... done
[16:19:20.440] result() for ClusterFuture ...
[16:19:20.440] - result already collected: FutureResult
[16:19:20.440] result() for ClusterFuture ... done
[16:19:20.440] result() for ClusterFuture ...
[16:19:20.440] - result already collected: FutureResult
[16:19:20.440] result() for ClusterFuture ... done
[16:19:20.441] result() for ClusterFuture ...
[16:19:20.441] - result already collected: FutureResult
[16:19:20.441] result() for ClusterFuture ... done
[16:19:20.441] - relayed: [n=2] TRUE, TRUE
[16:19:20.441] - queued futures: [n=2] TRUE, TRUE
[16:19:20.441] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:20.441]  length: 0 (resolved future 2)
[16:19:20.441] Relaying remaining futures
[16:19:20.441] signalConditionsASAP(NULL, pos=0) ...
[16:19:20.441] - nx: 2
[16:19:20.441] - relay: TRUE
[16:19:20.442] - stdout: TRUE
[16:19:20.442] - signal: TRUE
[16:19:20.442] - resignal: FALSE
[16:19:20.442] - force: TRUE
[16:19:20.442] - relayed: [n=2] TRUE, TRUE
[16:19:20.442] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:20.442] - relayed: [n=2] TRUE, TRUE
[16:19:20.442] - queued futures: [n=2] TRUE, TRUE
[16:19:20.442] signalConditionsASAP(NULL, pos=0) ... done
[16:19:20.442] resolve() on list ... DONE
[16:19:20.443] result() for ClusterFuture ...
[16:19:20.443] - result already collected: FutureResult
[16:19:20.443] result() for ClusterFuture ... done
[16:19:20.443] result() for ClusterFuture ...
[16:19:20.443] - result already collected: FutureResult
[16:19:20.443] result() for ClusterFuture ... done
[16:19:20.443] result() for ClusterFuture ...
[16:19:20.443] - result already collected: FutureResult
[16:19:20.443] result() for ClusterFuture ... done
[16:19:20.443] result() for ClusterFuture ...
[16:19:20.443] - result already collected: FutureResult
[16:19:20.443] result() for ClusterFuture ... done
[16:19:20.444]  - Number of value chunks collected: 2
[16:19:20.444] Resolving 2 futures (chunks) ... DONE
[16:19:20.444] Reducing values from 2 chunks ...
[16:19:20.444]  - Number of values collected after concatenation: 7
[16:19:20.444]  - Number of values expected: 7
[16:19:20.444] Reducing values from 2 chunks ... DONE
[16:19:20.444] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:19:20.446] future_lapply() ...
[16:19:20.450] Number of chunks: 2
[16:19:20.450] getGlobalsAndPackagesXApply() ...
[16:19:20.450]  - future.globals: TRUE
[16:19:20.450] getGlobalsAndPackages() ...
[16:19:20.450] Searching for globals...
[16:19:20.452] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:19:20.452] Searching for globals ... DONE
[16:19:20.452] Resolving globals: FALSE
[16:19:20.452] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:19:20.453] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:19:20.453] - globals: [1] ‘FUN’
[16:19:20.453] 
[16:19:20.453] getGlobalsAndPackages() ... DONE
[16:19:20.453]  - globals found/used: [n=1] ‘FUN’
[16:19:20.453]  - needed namespaces: [n=0] 
[16:19:20.453] Finding globals ... DONE
[16:19:20.453]  - use_args: TRUE
[16:19:20.453]  - Getting '...' globals ...
[16:19:20.454] resolve() on list ...
[16:19:20.454]  recursive: 0
[16:19:20.454]  length: 1
[16:19:20.454]  elements: ‘...’
[16:19:20.454]  length: 0 (resolved future 1)
[16:19:20.454] resolve() on list ... DONE
[16:19:20.454]    - '...' content: [n=1] ‘y’
[16:19:20.454] List of 1
[16:19:20.454]  $ ...:List of 1
[16:19:20.454]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:20.454]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:20.454]  - attr(*, "where")=List of 1
[16:19:20.454]   ..$ ...:<environment: 0x56199e6744c8> 
[16:19:20.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:20.454]  - attr(*, "resolved")= logi TRUE
[16:19:20.454]  - attr(*, "total_size")= num NA
[16:19:20.457]  - Getting '...' globals ... DONE
[16:19:20.457] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:20.457] List of 2
[16:19:20.457]  $ ...future.FUN:function (x, y)  
[16:19:20.457]  $ ...          :List of 1
[16:19:20.457]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:20.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:20.457]  - attr(*, "where")=List of 2
[16:19:20.457]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:20.457]   ..$ ...          :<environment: 0x56199e6744c8> 
[16:19:20.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:20.457]  - attr(*, "resolved")= logi FALSE
[16:19:20.457]  - attr(*, "total_size")= num 4264
[16:19:20.460] Packages to be attached in all futures: [n=0] 
[16:19:20.461] getGlobalsAndPackagesXApply() ... DONE
[16:19:20.461] Number of futures (= number of chunks): 2
[16:19:20.461] Launching 2 futures (chunks) ...
[16:19:20.461] Chunk #1 of 2 ...
[16:19:20.461]  - Finding globals in 'X' for chunk #1 ...
[16:19:20.461] getGlobalsAndPackages() ...
[16:19:20.461] Searching for globals...
[16:19:20.462] 
[16:19:20.462] Searching for globals ... DONE
[16:19:20.462] - globals: [0] <none>
[16:19:20.462] getGlobalsAndPackages() ... DONE
[16:19:20.462]    + additional globals found: [n=0] 
[16:19:20.462]    + additional namespaces needed: [n=0] 
[16:19:20.462]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:20.462]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:20.462]  - seeds: <none>
[16:19:20.462]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.462] getGlobalsAndPackages() ...
[16:19:20.463] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.463] Resolving globals: FALSE
[16:19:20.463] Tweak future expression to call with '...' arguments ...
[16:19:20.463] {
[16:19:20.463]     do.call(function(...) {
[16:19:20.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.463]             on.exit(options(oopts), add = TRUE)
[16:19:20.463]         }
[16:19:20.463]         {
[16:19:20.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.463]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.463]             })
[16:19:20.463]         }
[16:19:20.463]     }, args = future.call.arguments)
[16:19:20.463] }
[16:19:20.463] Tweak future expression to call with '...' arguments ... DONE
[16:19:20.463] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.464] 
[16:19:20.464] getGlobalsAndPackages() ... DONE
[16:19:20.464] run() for ‘Future’ ...
[16:19:20.464] - state: ‘created’
[16:19:20.464] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:20.478] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:20.478]   - Field: ‘node’
[16:19:20.478]   - Field: ‘label’
[16:19:20.478]   - Field: ‘local’
[16:19:20.479]   - Field: ‘owner’
[16:19:20.479]   - Field: ‘envir’
[16:19:20.479]   - Field: ‘workers’
[16:19:20.479]   - Field: ‘packages’
[16:19:20.479]   - Field: ‘gc’
[16:19:20.479]   - Field: ‘conditions’
[16:19:20.479]   - Field: ‘persistent’
[16:19:20.479]   - Field: ‘expr’
[16:19:20.479]   - Field: ‘uuid’
[16:19:20.479]   - Field: ‘seed’
[16:19:20.479]   - Field: ‘version’
[16:19:20.480]   - Field: ‘result’
[16:19:20.480]   - Field: ‘asynchronous’
[16:19:20.480]   - Field: ‘calls’
[16:19:20.480]   - Field: ‘globals’
[16:19:20.480]   - Field: ‘stdout’
[16:19:20.480]   - Field: ‘earlySignal’
[16:19:20.480]   - Field: ‘lazy’
[16:19:20.480]   - Field: ‘state’
[16:19:20.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:20.480] - Launch lazy future ...
[16:19:20.481] Packages needed by the future expression (n = 0): <none>
[16:19:20.481] Packages needed by future strategies (n = 0): <none>
[16:19:20.481] {
[16:19:20.481]     {
[16:19:20.481]         {
[16:19:20.481]             ...future.startTime <- base::Sys.time()
[16:19:20.481]             {
[16:19:20.481]                 {
[16:19:20.481]                   {
[16:19:20.481]                     {
[16:19:20.481]                       base::local({
[16:19:20.481]                         has_future <- base::requireNamespace("future", 
[16:19:20.481]                           quietly = TRUE)
[16:19:20.481]                         if (has_future) {
[16:19:20.481]                           ns <- base::getNamespace("future")
[16:19:20.481]                           version <- ns[[".package"]][["version"]]
[16:19:20.481]                           if (is.null(version)) 
[16:19:20.481]                             version <- utils::packageVersion("future")
[16:19:20.481]                         }
[16:19:20.481]                         else {
[16:19:20.481]                           version <- NULL
[16:19:20.481]                         }
[16:19:20.481]                         if (!has_future || version < "1.8.0") {
[16:19:20.481]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:20.481]                             "", base::R.version$version.string), 
[16:19:20.481]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:20.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:20.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:20.481]                               "release", "version")], collapse = " "), 
[16:19:20.481]                             hostname = base::Sys.info()[["nodename"]])
[16:19:20.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:20.481]                             info)
[16:19:20.481]                           info <- base::paste(info, collapse = "; ")
[16:19:20.481]                           if (!has_future) {
[16:19:20.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:20.481]                               info)
[16:19:20.481]                           }
[16:19:20.481]                           else {
[16:19:20.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:20.481]                               info, version)
[16:19:20.481]                           }
[16:19:20.481]                           base::stop(msg)
[16:19:20.481]                         }
[16:19:20.481]                       })
[16:19:20.481]                     }
[16:19:20.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:20.481]                     base::options(mc.cores = 1L)
[16:19:20.481]                   }
[16:19:20.481]                   ...future.strategy.old <- future::plan("list")
[16:19:20.481]                   options(future.plan = NULL)
[16:19:20.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:20.481]                 }
[16:19:20.481]                 ...future.workdir <- getwd()
[16:19:20.481]             }
[16:19:20.481]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:20.481]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:20.481]         }
[16:19:20.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:20.481]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:20.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:20.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:20.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:20.481]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:20.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:20.481]             base::names(...future.oldOptions))
[16:19:20.481]     }
[16:19:20.481]     if (FALSE) {
[16:19:20.481]     }
[16:19:20.481]     else {
[16:19:20.481]         if (TRUE) {
[16:19:20.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:20.481]                 open = "w")
[16:19:20.481]         }
[16:19:20.481]         else {
[16:19:20.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:20.481]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:20.481]         }
[16:19:20.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:20.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:20.481]             base::sink(type = "output", split = FALSE)
[16:19:20.481]             base::close(...future.stdout)
[16:19:20.481]         }, add = TRUE)
[16:19:20.481]     }
[16:19:20.481]     ...future.frame <- base::sys.nframe()
[16:19:20.481]     ...future.conditions <- base::list()
[16:19:20.481]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:20.481]     if (FALSE) {
[16:19:20.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:20.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:20.481]     }
[16:19:20.481]     ...future.result <- base::tryCatch({
[16:19:20.481]         base::withCallingHandlers({
[16:19:20.481]             ...future.value <- base::withVisible(base::local({
[16:19:20.481]                 ...future.makeSendCondition <- base::local({
[16:19:20.481]                   sendCondition <- NULL
[16:19:20.481]                   function(frame = 1L) {
[16:19:20.481]                     if (is.function(sendCondition)) 
[16:19:20.481]                       return(sendCondition)
[16:19:20.481]                     ns <- getNamespace("parallel")
[16:19:20.481]                     if (exists("sendData", mode = "function", 
[16:19:20.481]                       envir = ns)) {
[16:19:20.481]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:20.481]                         envir = ns)
[16:19:20.481]                       envir <- sys.frame(frame)
[16:19:20.481]                       master <- NULL
[16:19:20.481]                       while (!identical(envir, .GlobalEnv) && 
[16:19:20.481]                         !identical(envir, emptyenv())) {
[16:19:20.481]                         if (exists("master", mode = "list", envir = envir, 
[16:19:20.481]                           inherits = FALSE)) {
[16:19:20.481]                           master <- get("master", mode = "list", 
[16:19:20.481]                             envir = envir, inherits = FALSE)
[16:19:20.481]                           if (inherits(master, c("SOCKnode", 
[16:19:20.481]                             "SOCK0node"))) {
[16:19:20.481]                             sendCondition <<- function(cond) {
[16:19:20.481]                               data <- list(type = "VALUE", value = cond, 
[16:19:20.481]                                 success = TRUE)
[16:19:20.481]                               parallel_sendData(master, data)
[16:19:20.481]                             }
[16:19:20.481]                             return(sendCondition)
[16:19:20.481]                           }
[16:19:20.481]                         }
[16:19:20.481]                         frame <- frame + 1L
[16:19:20.481]                         envir <- sys.frame(frame)
[16:19:20.481]                       }
[16:19:20.481]                     }
[16:19:20.481]                     sendCondition <<- function(cond) NULL
[16:19:20.481]                   }
[16:19:20.481]                 })
[16:19:20.481]                 withCallingHandlers({
[16:19:20.481]                   {
[16:19:20.481]                     do.call(function(...) {
[16:19:20.481]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.481]                       if (!identical(...future.globals.maxSize.org, 
[16:19:20.481]                         ...future.globals.maxSize)) {
[16:19:20.481]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.481]                         on.exit(options(oopts), add = TRUE)
[16:19:20.481]                       }
[16:19:20.481]                       {
[16:19:20.481]                         lapply(seq_along(...future.elements_ii), 
[16:19:20.481]                           FUN = function(jj) {
[16:19:20.481]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.481]                             ...future.FUN(...future.X_jj, ...)
[16:19:20.481]                           })
[16:19:20.481]                       }
[16:19:20.481]                     }, args = future.call.arguments)
[16:19:20.481]                   }
[16:19:20.481]                 }, immediateCondition = function(cond) {
[16:19:20.481]                   sendCondition <- ...future.makeSendCondition()
[16:19:20.481]                   sendCondition(cond)
[16:19:20.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.481]                   {
[16:19:20.481]                     inherits <- base::inherits
[16:19:20.481]                     invokeRestart <- base::invokeRestart
[16:19:20.481]                     is.null <- base::is.null
[16:19:20.481]                     muffled <- FALSE
[16:19:20.481]                     if (inherits(cond, "message")) {
[16:19:20.481]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:20.481]                       if (muffled) 
[16:19:20.481]                         invokeRestart("muffleMessage")
[16:19:20.481]                     }
[16:19:20.481]                     else if (inherits(cond, "warning")) {
[16:19:20.481]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:20.481]                       if (muffled) 
[16:19:20.481]                         invokeRestart("muffleWarning")
[16:19:20.481]                     }
[16:19:20.481]                     else if (inherits(cond, "condition")) {
[16:19:20.481]                       if (!is.null(pattern)) {
[16:19:20.481]                         computeRestarts <- base::computeRestarts
[16:19:20.481]                         grepl <- base::grepl
[16:19:20.481]                         restarts <- computeRestarts(cond)
[16:19:20.481]                         for (restart in restarts) {
[16:19:20.481]                           name <- restart$name
[16:19:20.481]                           if (is.null(name)) 
[16:19:20.481]                             next
[16:19:20.481]                           if (!grepl(pattern, name)) 
[16:19:20.481]                             next
[16:19:20.481]                           invokeRestart(restart)
[16:19:20.481]                           muffled <- TRUE
[16:19:20.481]                           break
[16:19:20.481]                         }
[16:19:20.481]                       }
[16:19:20.481]                     }
[16:19:20.481]                     invisible(muffled)
[16:19:20.481]                   }
[16:19:20.481]                   muffleCondition(cond)
[16:19:20.481]                 })
[16:19:20.481]             }))
[16:19:20.481]             future::FutureResult(value = ...future.value$value, 
[16:19:20.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.481]                   ...future.rng), globalenv = if (FALSE) 
[16:19:20.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:20.481]                     ...future.globalenv.names))
[16:19:20.481]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:20.481]         }, condition = base::local({
[16:19:20.481]             c <- base::c
[16:19:20.481]             inherits <- base::inherits
[16:19:20.481]             invokeRestart <- base::invokeRestart
[16:19:20.481]             length <- base::length
[16:19:20.481]             list <- base::list
[16:19:20.481]             seq.int <- base::seq.int
[16:19:20.481]             signalCondition <- base::signalCondition
[16:19:20.481]             sys.calls <- base::sys.calls
[16:19:20.481]             `[[` <- base::`[[`
[16:19:20.481]             `+` <- base::`+`
[16:19:20.481]             `<<-` <- base::`<<-`
[16:19:20.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:20.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:20.481]                   3L)]
[16:19:20.481]             }
[16:19:20.481]             function(cond) {
[16:19:20.481]                 is_error <- inherits(cond, "error")
[16:19:20.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:20.481]                   NULL)
[16:19:20.481]                 if (is_error) {
[16:19:20.481]                   sessionInformation <- function() {
[16:19:20.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:20.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:20.481]                       search = base::search(), system = base::Sys.info())
[16:19:20.481]                   }
[16:19:20.481]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:20.481]                     cond$call), session = sessionInformation(), 
[16:19:20.481]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:20.481]                   signalCondition(cond)
[16:19:20.481]                 }
[16:19:20.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:20.481]                 "immediateCondition"))) {
[16:19:20.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:20.481]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:20.481]                   if (TRUE && !signal) {
[16:19:20.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.481]                     {
[16:19:20.481]                       inherits <- base::inherits
[16:19:20.481]                       invokeRestart <- base::invokeRestart
[16:19:20.481]                       is.null <- base::is.null
[16:19:20.481]                       muffled <- FALSE
[16:19:20.481]                       if (inherits(cond, "message")) {
[16:19:20.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.481]                         if (muffled) 
[16:19:20.481]                           invokeRestart("muffleMessage")
[16:19:20.481]                       }
[16:19:20.481]                       else if (inherits(cond, "warning")) {
[16:19:20.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.481]                         if (muffled) 
[16:19:20.481]                           invokeRestart("muffleWarning")
[16:19:20.481]                       }
[16:19:20.481]                       else if (inherits(cond, "condition")) {
[16:19:20.481]                         if (!is.null(pattern)) {
[16:19:20.481]                           computeRestarts <- base::computeRestarts
[16:19:20.481]                           grepl <- base::grepl
[16:19:20.481]                           restarts <- computeRestarts(cond)
[16:19:20.481]                           for (restart in restarts) {
[16:19:20.481]                             name <- restart$name
[16:19:20.481]                             if (is.null(name)) 
[16:19:20.481]                               next
[16:19:20.481]                             if (!grepl(pattern, name)) 
[16:19:20.481]                               next
[16:19:20.481]                             invokeRestart(restart)
[16:19:20.481]                             muffled <- TRUE
[16:19:20.481]                             break
[16:19:20.481]                           }
[16:19:20.481]                         }
[16:19:20.481]                       }
[16:19:20.481]                       invisible(muffled)
[16:19:20.481]                     }
[16:19:20.481]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.481]                   }
[16:19:20.481]                 }
[16:19:20.481]                 else {
[16:19:20.481]                   if (TRUE) {
[16:19:20.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.481]                     {
[16:19:20.481]                       inherits <- base::inherits
[16:19:20.481]                       invokeRestart <- base::invokeRestart
[16:19:20.481]                       is.null <- base::is.null
[16:19:20.481]                       muffled <- FALSE
[16:19:20.481]                       if (inherits(cond, "message")) {
[16:19:20.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.481]                         if (muffled) 
[16:19:20.481]                           invokeRestart("muffleMessage")
[16:19:20.481]                       }
[16:19:20.481]                       else if (inherits(cond, "warning")) {
[16:19:20.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.481]                         if (muffled) 
[16:19:20.481]                           invokeRestart("muffleWarning")
[16:19:20.481]                       }
[16:19:20.481]                       else if (inherits(cond, "condition")) {
[16:19:20.481]                         if (!is.null(pattern)) {
[16:19:20.481]                           computeRestarts <- base::computeRestarts
[16:19:20.481]                           grepl <- base::grepl
[16:19:20.481]                           restarts <- computeRestarts(cond)
[16:19:20.481]                           for (restart in restarts) {
[16:19:20.481]                             name <- restart$name
[16:19:20.481]                             if (is.null(name)) 
[16:19:20.481]                               next
[16:19:20.481]                             if (!grepl(pattern, name)) 
[16:19:20.481]                               next
[16:19:20.481]                             invokeRestart(restart)
[16:19:20.481]                             muffled <- TRUE
[16:19:20.481]                             break
[16:19:20.481]                           }
[16:19:20.481]                         }
[16:19:20.481]                       }
[16:19:20.481]                       invisible(muffled)
[16:19:20.481]                     }
[16:19:20.481]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.481]                   }
[16:19:20.481]                 }
[16:19:20.481]             }
[16:19:20.481]         }))
[16:19:20.481]     }, error = function(ex) {
[16:19:20.481]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:20.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.481]                 ...future.rng), started = ...future.startTime, 
[16:19:20.481]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:20.481]             version = "1.8"), class = "FutureResult")
[16:19:20.481]     }, finally = {
[16:19:20.481]         if (!identical(...future.workdir, getwd())) 
[16:19:20.481]             setwd(...future.workdir)
[16:19:20.481]         {
[16:19:20.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:20.481]                 ...future.oldOptions$nwarnings <- NULL
[16:19:20.481]             }
[16:19:20.481]             base::options(...future.oldOptions)
[16:19:20.481]             if (.Platform$OS.type == "windows") {
[16:19:20.481]                 old_names <- names(...future.oldEnvVars)
[16:19:20.481]                 envs <- base::Sys.getenv()
[16:19:20.481]                 names <- names(envs)
[16:19:20.481]                 common <- intersect(names, old_names)
[16:19:20.481]                 added <- setdiff(names, old_names)
[16:19:20.481]                 removed <- setdiff(old_names, names)
[16:19:20.481]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:20.481]                   envs[common]]
[16:19:20.481]                 NAMES <- toupper(changed)
[16:19:20.481]                 args <- list()
[16:19:20.481]                 for (kk in seq_along(NAMES)) {
[16:19:20.481]                   name <- changed[[kk]]
[16:19:20.481]                   NAME <- NAMES[[kk]]
[16:19:20.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.481]                     next
[16:19:20.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.481]                 }
[16:19:20.481]                 NAMES <- toupper(added)
[16:19:20.481]                 for (kk in seq_along(NAMES)) {
[16:19:20.481]                   name <- added[[kk]]
[16:19:20.481]                   NAME <- NAMES[[kk]]
[16:19:20.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.481]                     next
[16:19:20.481]                   args[[name]] <- ""
[16:19:20.481]                 }
[16:19:20.481]                 NAMES <- toupper(removed)
[16:19:20.481]                 for (kk in seq_along(NAMES)) {
[16:19:20.481]                   name <- removed[[kk]]
[16:19:20.481]                   NAME <- NAMES[[kk]]
[16:19:20.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.481]                     next
[16:19:20.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.481]                 }
[16:19:20.481]                 if (length(args) > 0) 
[16:19:20.481]                   base::do.call(base::Sys.setenv, args = args)
[16:19:20.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:20.481]             }
[16:19:20.481]             else {
[16:19:20.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:20.481]             }
[16:19:20.481]             {
[16:19:20.481]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:20.481]                   0L) {
[16:19:20.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:20.481]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:20.481]                   base::options(opts)
[16:19:20.481]                 }
[16:19:20.481]                 {
[16:19:20.481]                   {
[16:19:20.481]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:20.481]                     NULL
[16:19:20.481]                   }
[16:19:20.481]                   options(future.plan = NULL)
[16:19:20.481]                   if (is.na(NA_character_)) 
[16:19:20.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:20.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:20.481]                     .init = FALSE)
[16:19:20.481]                 }
[16:19:20.481]             }
[16:19:20.481]         }
[16:19:20.481]     })
[16:19:20.481]     if (TRUE) {
[16:19:20.481]         base::sink(type = "output", split = FALSE)
[16:19:20.481]         if (TRUE) {
[16:19:20.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:20.481]         }
[16:19:20.481]         else {
[16:19:20.481]             ...future.result["stdout"] <- base::list(NULL)
[16:19:20.481]         }
[16:19:20.481]         base::close(...future.stdout)
[16:19:20.481]         ...future.stdout <- NULL
[16:19:20.481]     }
[16:19:20.481]     ...future.result$conditions <- ...future.conditions
[16:19:20.481]     ...future.result$finished <- base::Sys.time()
[16:19:20.481]     ...future.result
[16:19:20.481] }
[16:19:20.484] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[16:19:20.484] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[16:19:20.484] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[16:19:20.485] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[16:19:20.485] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[16:19:20.485] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:19:20.486] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:19:20.486] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:20.486] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.486] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:20.486] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.487] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[16:19:20.487] MultisessionFuture started
[16:19:20.487] - Launch lazy future ... done
[16:19:20.487] run() for ‘MultisessionFuture’ ... done
[16:19:20.487] Created future:
[16:19:20.488] MultisessionFuture:
[16:19:20.488] Label: ‘future_sapply-1’
[16:19:20.488] Expression:
[16:19:20.488] {
[16:19:20.488]     do.call(function(...) {
[16:19:20.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.488]             on.exit(options(oopts), add = TRUE)
[16:19:20.488]         }
[16:19:20.488]         {
[16:19:20.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.488]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.488]             })
[16:19:20.488]         }
[16:19:20.488]     }, args = future.call.arguments)
[16:19:20.488] }
[16:19:20.488] Lazy evaluation: FALSE
[16:19:20.488] Asynchronous evaluation: TRUE
[16:19:20.488] Local evaluation: TRUE
[16:19:20.488] Environment: R_GlobalEnv
[16:19:20.488] Capture standard output: TRUE
[16:19:20.488] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:20.488] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:20.488] Packages: <none>
[16:19:20.488] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:20.488] Resolved: FALSE
[16:19:20.488] Value: <not collected>
[16:19:20.488] Conditions captured: <none>
[16:19:20.488] Early signaling: FALSE
[16:19:20.488] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:20.488] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.499] Chunk #1 of 2 ... DONE
[16:19:20.499] Chunk #2 of 2 ...
[16:19:20.499]  - Finding globals in 'X' for chunk #2 ...
[16:19:20.499] getGlobalsAndPackages() ...
[16:19:20.500] Searching for globals...
[16:19:20.500] 
[16:19:20.500] Searching for globals ... DONE
[16:19:20.500] - globals: [0] <none>
[16:19:20.500] getGlobalsAndPackages() ... DONE
[16:19:20.500]    + additional globals found: [n=0] 
[16:19:20.500]    + additional namespaces needed: [n=0] 
[16:19:20.500]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:20.501]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:20.501]  - seeds: <none>
[16:19:20.501]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.501] getGlobalsAndPackages() ...
[16:19:20.501] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.501] Resolving globals: FALSE
[16:19:20.501] Tweak future expression to call with '...' arguments ...
[16:19:20.501] {
[16:19:20.501]     do.call(function(...) {
[16:19:20.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.501]             on.exit(options(oopts), add = TRUE)
[16:19:20.501]         }
[16:19:20.501]         {
[16:19:20.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.501]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.501]             })
[16:19:20.501]         }
[16:19:20.501]     }, args = future.call.arguments)
[16:19:20.501] }
[16:19:20.501] Tweak future expression to call with '...' arguments ... DONE
[16:19:20.502] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.502] 
[16:19:20.502] getGlobalsAndPackages() ... DONE
[16:19:20.502] run() for ‘Future’ ...
[16:19:20.502] - state: ‘created’
[16:19:20.503] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:20.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:20.516]   - Field: ‘node’
[16:19:20.516]   - Field: ‘label’
[16:19:20.516]   - Field: ‘local’
[16:19:20.517]   - Field: ‘owner’
[16:19:20.517]   - Field: ‘envir’
[16:19:20.517]   - Field: ‘workers’
[16:19:20.517]   - Field: ‘packages’
[16:19:20.517]   - Field: ‘gc’
[16:19:20.517]   - Field: ‘conditions’
[16:19:20.517]   - Field: ‘persistent’
[16:19:20.517]   - Field: ‘expr’
[16:19:20.517]   - Field: ‘uuid’
[16:19:20.517]   - Field: ‘seed’
[16:19:20.517]   - Field: ‘version’
[16:19:20.518]   - Field: ‘result’
[16:19:20.518]   - Field: ‘asynchronous’
[16:19:20.518]   - Field: ‘calls’
[16:19:20.518]   - Field: ‘globals’
[16:19:20.518]   - Field: ‘stdout’
[16:19:20.518]   - Field: ‘earlySignal’
[16:19:20.518]   - Field: ‘lazy’
[16:19:20.518]   - Field: ‘state’
[16:19:20.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:20.518] - Launch lazy future ...
[16:19:20.519] Packages needed by the future expression (n = 0): <none>
[16:19:20.519] Packages needed by future strategies (n = 0): <none>
[16:19:20.519] {
[16:19:20.519]     {
[16:19:20.519]         {
[16:19:20.519]             ...future.startTime <- base::Sys.time()
[16:19:20.519]             {
[16:19:20.519]                 {
[16:19:20.519]                   {
[16:19:20.519]                     {
[16:19:20.519]                       base::local({
[16:19:20.519]                         has_future <- base::requireNamespace("future", 
[16:19:20.519]                           quietly = TRUE)
[16:19:20.519]                         if (has_future) {
[16:19:20.519]                           ns <- base::getNamespace("future")
[16:19:20.519]                           version <- ns[[".package"]][["version"]]
[16:19:20.519]                           if (is.null(version)) 
[16:19:20.519]                             version <- utils::packageVersion("future")
[16:19:20.519]                         }
[16:19:20.519]                         else {
[16:19:20.519]                           version <- NULL
[16:19:20.519]                         }
[16:19:20.519]                         if (!has_future || version < "1.8.0") {
[16:19:20.519]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:20.519]                             "", base::R.version$version.string), 
[16:19:20.519]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:20.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:20.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:20.519]                               "release", "version")], collapse = " "), 
[16:19:20.519]                             hostname = base::Sys.info()[["nodename"]])
[16:19:20.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:20.519]                             info)
[16:19:20.519]                           info <- base::paste(info, collapse = "; ")
[16:19:20.519]                           if (!has_future) {
[16:19:20.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:20.519]                               info)
[16:19:20.519]                           }
[16:19:20.519]                           else {
[16:19:20.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:20.519]                               info, version)
[16:19:20.519]                           }
[16:19:20.519]                           base::stop(msg)
[16:19:20.519]                         }
[16:19:20.519]                       })
[16:19:20.519]                     }
[16:19:20.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:20.519]                     base::options(mc.cores = 1L)
[16:19:20.519]                   }
[16:19:20.519]                   ...future.strategy.old <- future::plan("list")
[16:19:20.519]                   options(future.plan = NULL)
[16:19:20.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:20.519]                 }
[16:19:20.519]                 ...future.workdir <- getwd()
[16:19:20.519]             }
[16:19:20.519]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:20.519]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:20.519]         }
[16:19:20.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:20.519]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:20.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:20.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:20.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:20.519]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:20.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:20.519]             base::names(...future.oldOptions))
[16:19:20.519]     }
[16:19:20.519]     if (FALSE) {
[16:19:20.519]     }
[16:19:20.519]     else {
[16:19:20.519]         if (TRUE) {
[16:19:20.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:20.519]                 open = "w")
[16:19:20.519]         }
[16:19:20.519]         else {
[16:19:20.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:20.519]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:20.519]         }
[16:19:20.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:20.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:20.519]             base::sink(type = "output", split = FALSE)
[16:19:20.519]             base::close(...future.stdout)
[16:19:20.519]         }, add = TRUE)
[16:19:20.519]     }
[16:19:20.519]     ...future.frame <- base::sys.nframe()
[16:19:20.519]     ...future.conditions <- base::list()
[16:19:20.519]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:20.519]     if (FALSE) {
[16:19:20.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:20.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:20.519]     }
[16:19:20.519]     ...future.result <- base::tryCatch({
[16:19:20.519]         base::withCallingHandlers({
[16:19:20.519]             ...future.value <- base::withVisible(base::local({
[16:19:20.519]                 ...future.makeSendCondition <- base::local({
[16:19:20.519]                   sendCondition <- NULL
[16:19:20.519]                   function(frame = 1L) {
[16:19:20.519]                     if (is.function(sendCondition)) 
[16:19:20.519]                       return(sendCondition)
[16:19:20.519]                     ns <- getNamespace("parallel")
[16:19:20.519]                     if (exists("sendData", mode = "function", 
[16:19:20.519]                       envir = ns)) {
[16:19:20.519]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:20.519]                         envir = ns)
[16:19:20.519]                       envir <- sys.frame(frame)
[16:19:20.519]                       master <- NULL
[16:19:20.519]                       while (!identical(envir, .GlobalEnv) && 
[16:19:20.519]                         !identical(envir, emptyenv())) {
[16:19:20.519]                         if (exists("master", mode = "list", envir = envir, 
[16:19:20.519]                           inherits = FALSE)) {
[16:19:20.519]                           master <- get("master", mode = "list", 
[16:19:20.519]                             envir = envir, inherits = FALSE)
[16:19:20.519]                           if (inherits(master, c("SOCKnode", 
[16:19:20.519]                             "SOCK0node"))) {
[16:19:20.519]                             sendCondition <<- function(cond) {
[16:19:20.519]                               data <- list(type = "VALUE", value = cond, 
[16:19:20.519]                                 success = TRUE)
[16:19:20.519]                               parallel_sendData(master, data)
[16:19:20.519]                             }
[16:19:20.519]                             return(sendCondition)
[16:19:20.519]                           }
[16:19:20.519]                         }
[16:19:20.519]                         frame <- frame + 1L
[16:19:20.519]                         envir <- sys.frame(frame)
[16:19:20.519]                       }
[16:19:20.519]                     }
[16:19:20.519]                     sendCondition <<- function(cond) NULL
[16:19:20.519]                   }
[16:19:20.519]                 })
[16:19:20.519]                 withCallingHandlers({
[16:19:20.519]                   {
[16:19:20.519]                     do.call(function(...) {
[16:19:20.519]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.519]                       if (!identical(...future.globals.maxSize.org, 
[16:19:20.519]                         ...future.globals.maxSize)) {
[16:19:20.519]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.519]                         on.exit(options(oopts), add = TRUE)
[16:19:20.519]                       }
[16:19:20.519]                       {
[16:19:20.519]                         lapply(seq_along(...future.elements_ii), 
[16:19:20.519]                           FUN = function(jj) {
[16:19:20.519]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.519]                             ...future.FUN(...future.X_jj, ...)
[16:19:20.519]                           })
[16:19:20.519]                       }
[16:19:20.519]                     }, args = future.call.arguments)
[16:19:20.519]                   }
[16:19:20.519]                 }, immediateCondition = function(cond) {
[16:19:20.519]                   sendCondition <- ...future.makeSendCondition()
[16:19:20.519]                   sendCondition(cond)
[16:19:20.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.519]                   {
[16:19:20.519]                     inherits <- base::inherits
[16:19:20.519]                     invokeRestart <- base::invokeRestart
[16:19:20.519]                     is.null <- base::is.null
[16:19:20.519]                     muffled <- FALSE
[16:19:20.519]                     if (inherits(cond, "message")) {
[16:19:20.519]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:20.519]                       if (muffled) 
[16:19:20.519]                         invokeRestart("muffleMessage")
[16:19:20.519]                     }
[16:19:20.519]                     else if (inherits(cond, "warning")) {
[16:19:20.519]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:20.519]                       if (muffled) 
[16:19:20.519]                         invokeRestart("muffleWarning")
[16:19:20.519]                     }
[16:19:20.519]                     else if (inherits(cond, "condition")) {
[16:19:20.519]                       if (!is.null(pattern)) {
[16:19:20.519]                         computeRestarts <- base::computeRestarts
[16:19:20.519]                         grepl <- base::grepl
[16:19:20.519]                         restarts <- computeRestarts(cond)
[16:19:20.519]                         for (restart in restarts) {
[16:19:20.519]                           name <- restart$name
[16:19:20.519]                           if (is.null(name)) 
[16:19:20.519]                             next
[16:19:20.519]                           if (!grepl(pattern, name)) 
[16:19:20.519]                             next
[16:19:20.519]                           invokeRestart(restart)
[16:19:20.519]                           muffled <- TRUE
[16:19:20.519]                           break
[16:19:20.519]                         }
[16:19:20.519]                       }
[16:19:20.519]                     }
[16:19:20.519]                     invisible(muffled)
[16:19:20.519]                   }
[16:19:20.519]                   muffleCondition(cond)
[16:19:20.519]                 })
[16:19:20.519]             }))
[16:19:20.519]             future::FutureResult(value = ...future.value$value, 
[16:19:20.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.519]                   ...future.rng), globalenv = if (FALSE) 
[16:19:20.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:20.519]                     ...future.globalenv.names))
[16:19:20.519]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:20.519]         }, condition = base::local({
[16:19:20.519]             c <- base::c
[16:19:20.519]             inherits <- base::inherits
[16:19:20.519]             invokeRestart <- base::invokeRestart
[16:19:20.519]             length <- base::length
[16:19:20.519]             list <- base::list
[16:19:20.519]             seq.int <- base::seq.int
[16:19:20.519]             signalCondition <- base::signalCondition
[16:19:20.519]             sys.calls <- base::sys.calls
[16:19:20.519]             `[[` <- base::`[[`
[16:19:20.519]             `+` <- base::`+`
[16:19:20.519]             `<<-` <- base::`<<-`
[16:19:20.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:20.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:20.519]                   3L)]
[16:19:20.519]             }
[16:19:20.519]             function(cond) {
[16:19:20.519]                 is_error <- inherits(cond, "error")
[16:19:20.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:20.519]                   NULL)
[16:19:20.519]                 if (is_error) {
[16:19:20.519]                   sessionInformation <- function() {
[16:19:20.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:20.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:20.519]                       search = base::search(), system = base::Sys.info())
[16:19:20.519]                   }
[16:19:20.519]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:20.519]                     cond$call), session = sessionInformation(), 
[16:19:20.519]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:20.519]                   signalCondition(cond)
[16:19:20.519]                 }
[16:19:20.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:20.519]                 "immediateCondition"))) {
[16:19:20.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:20.519]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:20.519]                   if (TRUE && !signal) {
[16:19:20.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.519]                     {
[16:19:20.519]                       inherits <- base::inherits
[16:19:20.519]                       invokeRestart <- base::invokeRestart
[16:19:20.519]                       is.null <- base::is.null
[16:19:20.519]                       muffled <- FALSE
[16:19:20.519]                       if (inherits(cond, "message")) {
[16:19:20.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.519]                         if (muffled) 
[16:19:20.519]                           invokeRestart("muffleMessage")
[16:19:20.519]                       }
[16:19:20.519]                       else if (inherits(cond, "warning")) {
[16:19:20.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.519]                         if (muffled) 
[16:19:20.519]                           invokeRestart("muffleWarning")
[16:19:20.519]                       }
[16:19:20.519]                       else if (inherits(cond, "condition")) {
[16:19:20.519]                         if (!is.null(pattern)) {
[16:19:20.519]                           computeRestarts <- base::computeRestarts
[16:19:20.519]                           grepl <- base::grepl
[16:19:20.519]                           restarts <- computeRestarts(cond)
[16:19:20.519]                           for (restart in restarts) {
[16:19:20.519]                             name <- restart$name
[16:19:20.519]                             if (is.null(name)) 
[16:19:20.519]                               next
[16:19:20.519]                             if (!grepl(pattern, name)) 
[16:19:20.519]                               next
[16:19:20.519]                             invokeRestart(restart)
[16:19:20.519]                             muffled <- TRUE
[16:19:20.519]                             break
[16:19:20.519]                           }
[16:19:20.519]                         }
[16:19:20.519]                       }
[16:19:20.519]                       invisible(muffled)
[16:19:20.519]                     }
[16:19:20.519]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.519]                   }
[16:19:20.519]                 }
[16:19:20.519]                 else {
[16:19:20.519]                   if (TRUE) {
[16:19:20.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.519]                     {
[16:19:20.519]                       inherits <- base::inherits
[16:19:20.519]                       invokeRestart <- base::invokeRestart
[16:19:20.519]                       is.null <- base::is.null
[16:19:20.519]                       muffled <- FALSE
[16:19:20.519]                       if (inherits(cond, "message")) {
[16:19:20.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.519]                         if (muffled) 
[16:19:20.519]                           invokeRestart("muffleMessage")
[16:19:20.519]                       }
[16:19:20.519]                       else if (inherits(cond, "warning")) {
[16:19:20.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.519]                         if (muffled) 
[16:19:20.519]                           invokeRestart("muffleWarning")
[16:19:20.519]                       }
[16:19:20.519]                       else if (inherits(cond, "condition")) {
[16:19:20.519]                         if (!is.null(pattern)) {
[16:19:20.519]                           computeRestarts <- base::computeRestarts
[16:19:20.519]                           grepl <- base::grepl
[16:19:20.519]                           restarts <- computeRestarts(cond)
[16:19:20.519]                           for (restart in restarts) {
[16:19:20.519]                             name <- restart$name
[16:19:20.519]                             if (is.null(name)) 
[16:19:20.519]                               next
[16:19:20.519]                             if (!grepl(pattern, name)) 
[16:19:20.519]                               next
[16:19:20.519]                             invokeRestart(restart)
[16:19:20.519]                             muffled <- TRUE
[16:19:20.519]                             break
[16:19:20.519]                           }
[16:19:20.519]                         }
[16:19:20.519]                       }
[16:19:20.519]                       invisible(muffled)
[16:19:20.519]                     }
[16:19:20.519]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.519]                   }
[16:19:20.519]                 }
[16:19:20.519]             }
[16:19:20.519]         }))
[16:19:20.519]     }, error = function(ex) {
[16:19:20.519]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:20.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.519]                 ...future.rng), started = ...future.startTime, 
[16:19:20.519]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:20.519]             version = "1.8"), class = "FutureResult")
[16:19:20.519]     }, finally = {
[16:19:20.519]         if (!identical(...future.workdir, getwd())) 
[16:19:20.519]             setwd(...future.workdir)
[16:19:20.519]         {
[16:19:20.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:20.519]                 ...future.oldOptions$nwarnings <- NULL
[16:19:20.519]             }
[16:19:20.519]             base::options(...future.oldOptions)
[16:19:20.519]             if (.Platform$OS.type == "windows") {
[16:19:20.519]                 old_names <- names(...future.oldEnvVars)
[16:19:20.519]                 envs <- base::Sys.getenv()
[16:19:20.519]                 names <- names(envs)
[16:19:20.519]                 common <- intersect(names, old_names)
[16:19:20.519]                 added <- setdiff(names, old_names)
[16:19:20.519]                 removed <- setdiff(old_names, names)
[16:19:20.519]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:20.519]                   envs[common]]
[16:19:20.519]                 NAMES <- toupper(changed)
[16:19:20.519]                 args <- list()
[16:19:20.519]                 for (kk in seq_along(NAMES)) {
[16:19:20.519]                   name <- changed[[kk]]
[16:19:20.519]                   NAME <- NAMES[[kk]]
[16:19:20.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.519]                     next
[16:19:20.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.519]                 }
[16:19:20.519]                 NAMES <- toupper(added)
[16:19:20.519]                 for (kk in seq_along(NAMES)) {
[16:19:20.519]                   name <- added[[kk]]
[16:19:20.519]                   NAME <- NAMES[[kk]]
[16:19:20.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.519]                     next
[16:19:20.519]                   args[[name]] <- ""
[16:19:20.519]                 }
[16:19:20.519]                 NAMES <- toupper(removed)
[16:19:20.519]                 for (kk in seq_along(NAMES)) {
[16:19:20.519]                   name <- removed[[kk]]
[16:19:20.519]                   NAME <- NAMES[[kk]]
[16:19:20.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.519]                     next
[16:19:20.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.519]                 }
[16:19:20.519]                 if (length(args) > 0) 
[16:19:20.519]                   base::do.call(base::Sys.setenv, args = args)
[16:19:20.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:20.519]             }
[16:19:20.519]             else {
[16:19:20.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:20.519]             }
[16:19:20.519]             {
[16:19:20.519]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:20.519]                   0L) {
[16:19:20.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:20.519]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:20.519]                   base::options(opts)
[16:19:20.519]                 }
[16:19:20.519]                 {
[16:19:20.519]                   {
[16:19:20.519]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:20.519]                     NULL
[16:19:20.519]                   }
[16:19:20.519]                   options(future.plan = NULL)
[16:19:20.519]                   if (is.na(NA_character_)) 
[16:19:20.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:20.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:20.519]                     .init = FALSE)
[16:19:20.519]                 }
[16:19:20.519]             }
[16:19:20.519]         }
[16:19:20.519]     })
[16:19:20.519]     if (TRUE) {
[16:19:20.519]         base::sink(type = "output", split = FALSE)
[16:19:20.519]         if (TRUE) {
[16:19:20.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:20.519]         }
[16:19:20.519]         else {
[16:19:20.519]             ...future.result["stdout"] <- base::list(NULL)
[16:19:20.519]         }
[16:19:20.519]         base::close(...future.stdout)
[16:19:20.519]         ...future.stdout <- NULL
[16:19:20.519]     }
[16:19:20.519]     ...future.result$conditions <- ...future.conditions
[16:19:20.519]     ...future.result$finished <- base::Sys.time()
[16:19:20.519]     ...future.result
[16:19:20.519] }
[16:19:20.522] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[16:19:20.522] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[16:19:20.522] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[16:19:20.523] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[16:19:20.523] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[16:19:20.523] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:19:20.523] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:19:20.524] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:20.524] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:20.524] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:20.524] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:20.524] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[16:19:20.525] MultisessionFuture started
[16:19:20.525] - Launch lazy future ... done
[16:19:20.525] run() for ‘MultisessionFuture’ ... done
[16:19:20.525] Created future:
[16:19:20.525] MultisessionFuture:
[16:19:20.525] Label: ‘future_sapply-2’
[16:19:20.525] Expression:
[16:19:20.525] {
[16:19:20.525]     do.call(function(...) {
[16:19:20.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.525]             on.exit(options(oopts), add = TRUE)
[16:19:20.525]         }
[16:19:20.525]         {
[16:19:20.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.525]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.525]             })
[16:19:20.525]         }
[16:19:20.525]     }, args = future.call.arguments)
[16:19:20.525] }
[16:19:20.525] Lazy evaluation: FALSE
[16:19:20.525] Asynchronous evaluation: TRUE
[16:19:20.525] Local evaluation: TRUE
[16:19:20.525] Environment: R_GlobalEnv
[16:19:20.525] Capture standard output: TRUE
[16:19:20.525] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:20.525] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:20.525] Packages: <none>
[16:19:20.525] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:20.525] Resolved: FALSE
[16:19:20.525] Value: <not collected>
[16:19:20.525] Conditions captured: <none>
[16:19:20.525] Early signaling: FALSE
[16:19:20.525] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:20.525] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.537] Chunk #2 of 2 ... DONE
[16:19:20.537] Launching 2 futures (chunks) ... DONE
[16:19:20.537] Resolving 2 futures (chunks) ...
[16:19:20.537] resolve() on list ...
[16:19:20.537]  recursive: 0
[16:19:20.537]  length: 2
[16:19:20.537] 
[16:19:20.538] receiveMessageFromWorker() for ClusterFuture ...
[16:19:20.538] - Validating connection of MultisessionFuture
[16:19:20.538] - received message: FutureResult
[16:19:20.538] - Received FutureResult
[16:19:20.538] - Erased future from FutureRegistry
[16:19:20.538] result() for ClusterFuture ...
[16:19:20.538] - result already collected: FutureResult
[16:19:20.539] result() for ClusterFuture ... done
[16:19:20.539] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:20.539] Future #1
[16:19:20.539] result() for ClusterFuture ...
[16:19:20.539] - result already collected: FutureResult
[16:19:20.539] result() for ClusterFuture ... done
[16:19:20.539] result() for ClusterFuture ...
[16:19:20.539] - result already collected: FutureResult
[16:19:20.539] result() for ClusterFuture ... done
[16:19:20.539] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:20.539] - nx: 2
[16:19:20.540] - relay: TRUE
[16:19:20.540] - stdout: TRUE
[16:19:20.540] - signal: TRUE
[16:19:20.540] - resignal: FALSE
[16:19:20.540] - force: TRUE
[16:19:20.540] - relayed: [n=2] FALSE, FALSE
[16:19:20.540] - queued futures: [n=2] FALSE, FALSE
[16:19:20.540]  - until=1
[16:19:20.540]  - relaying element #1
[16:19:20.540] result() for ClusterFuture ...
[16:19:20.540] - result already collected: FutureResult
[16:19:20.540] result() for ClusterFuture ... done
[16:19:20.541] result() for ClusterFuture ...
[16:19:20.541] - result already collected: FutureResult
[16:19:20.541] result() for ClusterFuture ... done
[16:19:20.541] result() for ClusterFuture ...
[16:19:20.541] - result already collected: FutureResult
[16:19:20.541] result() for ClusterFuture ... done
[16:19:20.541] result() for ClusterFuture ...
[16:19:20.541] - result already collected: FutureResult
[16:19:20.541] result() for ClusterFuture ... done
[16:19:20.541] - relayed: [n=2] TRUE, FALSE
[16:19:20.541] - queued futures: [n=2] TRUE, FALSE
[16:19:20.542] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:20.542]  length: 1 (resolved future 1)
[16:19:20.583] receiveMessageFromWorker() for ClusterFuture ...
[16:19:20.583] - Validating connection of MultisessionFuture
[16:19:20.584] - received message: FutureResult
[16:19:20.584] - Received FutureResult
[16:19:20.584] - Erased future from FutureRegistry
[16:19:20.584] result() for ClusterFuture ...
[16:19:20.584] - result already collected: FutureResult
[16:19:20.584] result() for ClusterFuture ... done
[16:19:20.584] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:20.584] Future #2
[16:19:20.584] result() for ClusterFuture ...
[16:19:20.584] - result already collected: FutureResult
[16:19:20.585] result() for ClusterFuture ... done
[16:19:20.585] result() for ClusterFuture ...
[16:19:20.585] - result already collected: FutureResult
[16:19:20.585] result() for ClusterFuture ... done
[16:19:20.585] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:20.585] - nx: 2
[16:19:20.585] - relay: TRUE
[16:19:20.585] - stdout: TRUE
[16:19:20.585] - signal: TRUE
[16:19:20.585] - resignal: FALSE
[16:19:20.585] - force: TRUE
[16:19:20.585] - relayed: [n=2] TRUE, FALSE
[16:19:20.586] - queued futures: [n=2] TRUE, FALSE
[16:19:20.586]  - until=2
[16:19:20.586]  - relaying element #2
[16:19:20.586] result() for ClusterFuture ...
[16:19:20.586] - result already collected: FutureResult
[16:19:20.586] result() for ClusterFuture ... done
[16:19:20.586] result() for ClusterFuture ...
[16:19:20.586] - result already collected: FutureResult
[16:19:20.586] result() for ClusterFuture ... done
[16:19:20.586] result() for ClusterFuture ...
[16:19:20.586] - result already collected: FutureResult
[16:19:20.587] result() for ClusterFuture ... done
[16:19:20.587] result() for ClusterFuture ...
[16:19:20.587] - result already collected: FutureResult
[16:19:20.587] result() for ClusterFuture ... done
[16:19:20.587] - relayed: [n=2] TRUE, TRUE
[16:19:20.587] - queued futures: [n=2] TRUE, TRUE
[16:19:20.587] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:20.587]  length: 0 (resolved future 2)
[16:19:20.587] Relaying remaining futures
[16:19:20.587] signalConditionsASAP(NULL, pos=0) ...
[16:19:20.587] - nx: 2
[16:19:20.587] - relay: TRUE
[16:19:20.588] - stdout: TRUE
[16:19:20.588] - signal: TRUE
[16:19:20.588] - resignal: FALSE
[16:19:20.588] - force: TRUE
[16:19:20.588] - relayed: [n=2] TRUE, TRUE
[16:19:20.588] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:20.588] - relayed: [n=2] TRUE, TRUE
[16:19:20.588] - queued futures: [n=2] TRUE, TRUE
[16:19:20.588] signalConditionsASAP(NULL, pos=0) ... done
[16:19:20.588] resolve() on list ... DONE
[16:19:20.588] result() for ClusterFuture ...
[16:19:20.589] - result already collected: FutureResult
[16:19:20.589] result() for ClusterFuture ... done
[16:19:20.589] result() for ClusterFuture ...
[16:19:20.589] - result already collected: FutureResult
[16:19:20.589] result() for ClusterFuture ... done
[16:19:20.589] result() for ClusterFuture ...
[16:19:20.589] - result already collected: FutureResult
[16:19:20.589] result() for ClusterFuture ... done
[16:19:20.589] result() for ClusterFuture ...
[16:19:20.589] - result already collected: FutureResult
[16:19:20.589] result() for ClusterFuture ... done
[16:19:20.590]  - Number of value chunks collected: 2
[16:19:20.590] Resolving 2 futures (chunks) ... DONE
[16:19:20.590] Reducing values from 2 chunks ...
[16:19:20.590]  - Number of values collected after concatenation: 4
[16:19:20.590]  - Number of values expected: 4
[16:19:20.590] Reducing values from 2 chunks ... DONE
[16:19:20.590] future_lapply() ... DONE
[16:19:20.590] future_lapply() ...
[16:19:20.596] Number of chunks: 2
[16:19:20.596] getGlobalsAndPackagesXApply() ...
[16:19:20.596]  - future.globals: TRUE
[16:19:20.596] getGlobalsAndPackages() ...
[16:19:20.596] Searching for globals...
[16:19:20.599] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:19:20.600] Searching for globals ... DONE
[16:19:20.600] Resolving globals: FALSE
[16:19:20.601] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:19:20.601] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:20.601] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:20.601] - packages: [1] ‘future.apply’
[16:19:20.601] getGlobalsAndPackages() ... DONE
[16:19:20.601]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:20.602]  - needed namespaces: [n=1] ‘future.apply’
[16:19:20.602] Finding globals ... DONE
[16:19:20.602]  - use_args: TRUE
[16:19:20.602]  - Getting '...' globals ...
[16:19:20.602] resolve() on list ...
[16:19:20.602]  recursive: 0
[16:19:20.602]  length: 1
[16:19:20.602]  elements: ‘...’
[16:19:20.603]  length: 0 (resolved future 1)
[16:19:20.603] resolve() on list ... DONE
[16:19:20.603]    - '...' content: [n=1] ‘y’
[16:19:20.603] List of 1
[16:19:20.603]  $ ...:List of 1
[16:19:20.603]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:20.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:20.603]  - attr(*, "where")=List of 1
[16:19:20.603]   ..$ ...:<environment: 0x5619a018ec00> 
[16:19:20.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:20.603]  - attr(*, "resolved")= logi TRUE
[16:19:20.603]  - attr(*, "total_size")= num NA
[16:19:20.609]  - Getting '...' globals ... DONE
[16:19:20.609] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:20.609] List of 8
[16:19:20.609]  $ ...future.FUN:function (x, ...)  
[16:19:20.609]  $ x_FUN        :function (x, y)  
[16:19:20.609]  $ times        : int 15
[16:19:20.609]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:20.609]  $ stop_if_not  :function (...)  
[16:19:20.609]  $ dim          : int [1:2] 3 5
[16:19:20.609]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:20.609]  $ ...          :List of 1
[16:19:20.609]   ..$ y: num [1:5] 2 4 6 8 10
[16:19:20.609]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:20.609]  - attr(*, "where")=List of 8
[16:19:20.609]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:20.609]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:20.609]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:20.609]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:20.609]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:20.609]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:20.609]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:20.609]   ..$ ...          :<environment: 0x5619a018ec00> 
[16:19:20.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:20.609]  - attr(*, "resolved")= logi FALSE
[16:19:20.609]  - attr(*, "total_size")= num 98600
[16:19:20.615] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:20.615] getGlobalsAndPackagesXApply() ... DONE
[16:19:20.615] Number of futures (= number of chunks): 2
[16:19:20.615] Launching 2 futures (chunks) ...
[16:19:20.615] Chunk #1 of 2 ...
[16:19:20.615]  - Finding globals in 'X' for chunk #1 ...
[16:19:20.616] getGlobalsAndPackages() ...
[16:19:20.616] Searching for globals...
[16:19:20.616] 
[16:19:20.616] Searching for globals ... DONE
[16:19:20.616] - globals: [0] <none>
[16:19:20.616] getGlobalsAndPackages() ... DONE
[16:19:20.616]    + additional globals found: [n=0] 
[16:19:20.616]    + additional namespaces needed: [n=0] 
[16:19:20.617]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:20.617]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:20.617]  - seeds: <none>
[16:19:20.617]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.617] getGlobalsAndPackages() ...
[16:19:20.617] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.617] Resolving globals: FALSE
[16:19:20.617] Tweak future expression to call with '...' arguments ...
[16:19:20.617] {
[16:19:20.617]     do.call(function(...) {
[16:19:20.617]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.617]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.617]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.617]             on.exit(options(oopts), add = TRUE)
[16:19:20.617]         }
[16:19:20.617]         {
[16:19:20.617]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.617]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.617]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.617]             })
[16:19:20.617]         }
[16:19:20.617]     }, args = future.call.arguments)
[16:19:20.617] }
[16:19:20.618] Tweak future expression to call with '...' arguments ... DONE
[16:19:20.618] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.618] - packages: [1] ‘future.apply’
[16:19:20.618] getGlobalsAndPackages() ... DONE
[16:19:20.619] run() for ‘Future’ ...
[16:19:20.619] - state: ‘created’
[16:19:20.619] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:20.634] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:20.634]   - Field: ‘node’
[16:19:20.634]   - Field: ‘label’
[16:19:20.634]   - Field: ‘local’
[16:19:20.634]   - Field: ‘owner’
[16:19:20.634]   - Field: ‘envir’
[16:19:20.634]   - Field: ‘workers’
[16:19:20.635]   - Field: ‘packages’
[16:19:20.635]   - Field: ‘gc’
[16:19:20.635]   - Field: ‘conditions’
[16:19:20.635]   - Field: ‘persistent’
[16:19:20.635]   - Field: ‘expr’
[16:19:20.635]   - Field: ‘uuid’
[16:19:20.635]   - Field: ‘seed’
[16:19:20.635]   - Field: ‘version’
[16:19:20.635]   - Field: ‘result’
[16:19:20.635]   - Field: ‘asynchronous’
[16:19:20.635]   - Field: ‘calls’
[16:19:20.636]   - Field: ‘globals’
[16:19:20.636]   - Field: ‘stdout’
[16:19:20.636]   - Field: ‘earlySignal’
[16:19:20.636]   - Field: ‘lazy’
[16:19:20.636]   - Field: ‘state’
[16:19:20.636] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:20.636] - Launch lazy future ...
[16:19:20.636] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:20.637] Packages needed by future strategies (n = 0): <none>
[16:19:20.637] {
[16:19:20.637]     {
[16:19:20.637]         {
[16:19:20.637]             ...future.startTime <- base::Sys.time()
[16:19:20.637]             {
[16:19:20.637]                 {
[16:19:20.637]                   {
[16:19:20.637]                     {
[16:19:20.637]                       {
[16:19:20.637]                         base::local({
[16:19:20.637]                           has_future <- base::requireNamespace("future", 
[16:19:20.637]                             quietly = TRUE)
[16:19:20.637]                           if (has_future) {
[16:19:20.637]                             ns <- base::getNamespace("future")
[16:19:20.637]                             version <- ns[[".package"]][["version"]]
[16:19:20.637]                             if (is.null(version)) 
[16:19:20.637]                               version <- utils::packageVersion("future")
[16:19:20.637]                           }
[16:19:20.637]                           else {
[16:19:20.637]                             version <- NULL
[16:19:20.637]                           }
[16:19:20.637]                           if (!has_future || version < "1.8.0") {
[16:19:20.637]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:20.637]                               "", base::R.version$version.string), 
[16:19:20.637]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:20.637]                                 base::R.version$platform, 8 * 
[16:19:20.637]                                   base::.Machine$sizeof.pointer), 
[16:19:20.637]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:20.637]                                 "release", "version")], collapse = " "), 
[16:19:20.637]                               hostname = base::Sys.info()[["nodename"]])
[16:19:20.637]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:20.637]                               info)
[16:19:20.637]                             info <- base::paste(info, collapse = "; ")
[16:19:20.637]                             if (!has_future) {
[16:19:20.637]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:20.637]                                 info)
[16:19:20.637]                             }
[16:19:20.637]                             else {
[16:19:20.637]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:20.637]                                 info, version)
[16:19:20.637]                             }
[16:19:20.637]                             base::stop(msg)
[16:19:20.637]                           }
[16:19:20.637]                         })
[16:19:20.637]                       }
[16:19:20.637]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:20.637]                       base::options(mc.cores = 1L)
[16:19:20.637]                     }
[16:19:20.637]                     base::local({
[16:19:20.637]                       for (pkg in "future.apply") {
[16:19:20.637]                         base::loadNamespace(pkg)
[16:19:20.637]                         base::library(pkg, character.only = TRUE)
[16:19:20.637]                       }
[16:19:20.637]                     })
[16:19:20.637]                   }
[16:19:20.637]                   ...future.strategy.old <- future::plan("list")
[16:19:20.637]                   options(future.plan = NULL)
[16:19:20.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:20.637]                 }
[16:19:20.637]                 ...future.workdir <- getwd()
[16:19:20.637]             }
[16:19:20.637]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:20.637]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:20.637]         }
[16:19:20.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:20.637]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:20.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:20.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:20.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:20.637]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:20.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:20.637]             base::names(...future.oldOptions))
[16:19:20.637]     }
[16:19:20.637]     if (FALSE) {
[16:19:20.637]     }
[16:19:20.637]     else {
[16:19:20.637]         if (TRUE) {
[16:19:20.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:20.637]                 open = "w")
[16:19:20.637]         }
[16:19:20.637]         else {
[16:19:20.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:20.637]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:20.637]         }
[16:19:20.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:20.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:20.637]             base::sink(type = "output", split = FALSE)
[16:19:20.637]             base::close(...future.stdout)
[16:19:20.637]         }, add = TRUE)
[16:19:20.637]     }
[16:19:20.637]     ...future.frame <- base::sys.nframe()
[16:19:20.637]     ...future.conditions <- base::list()
[16:19:20.637]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:20.637]     if (FALSE) {
[16:19:20.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:20.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:20.637]     }
[16:19:20.637]     ...future.result <- base::tryCatch({
[16:19:20.637]         base::withCallingHandlers({
[16:19:20.637]             ...future.value <- base::withVisible(base::local({
[16:19:20.637]                 ...future.makeSendCondition <- base::local({
[16:19:20.637]                   sendCondition <- NULL
[16:19:20.637]                   function(frame = 1L) {
[16:19:20.637]                     if (is.function(sendCondition)) 
[16:19:20.637]                       return(sendCondition)
[16:19:20.637]                     ns <- getNamespace("parallel")
[16:19:20.637]                     if (exists("sendData", mode = "function", 
[16:19:20.637]                       envir = ns)) {
[16:19:20.637]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:20.637]                         envir = ns)
[16:19:20.637]                       envir <- sys.frame(frame)
[16:19:20.637]                       master <- NULL
[16:19:20.637]                       while (!identical(envir, .GlobalEnv) && 
[16:19:20.637]                         !identical(envir, emptyenv())) {
[16:19:20.637]                         if (exists("master", mode = "list", envir = envir, 
[16:19:20.637]                           inherits = FALSE)) {
[16:19:20.637]                           master <- get("master", mode = "list", 
[16:19:20.637]                             envir = envir, inherits = FALSE)
[16:19:20.637]                           if (inherits(master, c("SOCKnode", 
[16:19:20.637]                             "SOCK0node"))) {
[16:19:20.637]                             sendCondition <<- function(cond) {
[16:19:20.637]                               data <- list(type = "VALUE", value = cond, 
[16:19:20.637]                                 success = TRUE)
[16:19:20.637]                               parallel_sendData(master, data)
[16:19:20.637]                             }
[16:19:20.637]                             return(sendCondition)
[16:19:20.637]                           }
[16:19:20.637]                         }
[16:19:20.637]                         frame <- frame + 1L
[16:19:20.637]                         envir <- sys.frame(frame)
[16:19:20.637]                       }
[16:19:20.637]                     }
[16:19:20.637]                     sendCondition <<- function(cond) NULL
[16:19:20.637]                   }
[16:19:20.637]                 })
[16:19:20.637]                 withCallingHandlers({
[16:19:20.637]                   {
[16:19:20.637]                     do.call(function(...) {
[16:19:20.637]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.637]                       if (!identical(...future.globals.maxSize.org, 
[16:19:20.637]                         ...future.globals.maxSize)) {
[16:19:20.637]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.637]                         on.exit(options(oopts), add = TRUE)
[16:19:20.637]                       }
[16:19:20.637]                       {
[16:19:20.637]                         lapply(seq_along(...future.elements_ii), 
[16:19:20.637]                           FUN = function(jj) {
[16:19:20.637]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.637]                             ...future.FUN(...future.X_jj, ...)
[16:19:20.637]                           })
[16:19:20.637]                       }
[16:19:20.637]                     }, args = future.call.arguments)
[16:19:20.637]                   }
[16:19:20.637]                 }, immediateCondition = function(cond) {
[16:19:20.637]                   sendCondition <- ...future.makeSendCondition()
[16:19:20.637]                   sendCondition(cond)
[16:19:20.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.637]                   {
[16:19:20.637]                     inherits <- base::inherits
[16:19:20.637]                     invokeRestart <- base::invokeRestart
[16:19:20.637]                     is.null <- base::is.null
[16:19:20.637]                     muffled <- FALSE
[16:19:20.637]                     if (inherits(cond, "message")) {
[16:19:20.637]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:20.637]                       if (muffled) 
[16:19:20.637]                         invokeRestart("muffleMessage")
[16:19:20.637]                     }
[16:19:20.637]                     else if (inherits(cond, "warning")) {
[16:19:20.637]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:20.637]                       if (muffled) 
[16:19:20.637]                         invokeRestart("muffleWarning")
[16:19:20.637]                     }
[16:19:20.637]                     else if (inherits(cond, "condition")) {
[16:19:20.637]                       if (!is.null(pattern)) {
[16:19:20.637]                         computeRestarts <- base::computeRestarts
[16:19:20.637]                         grepl <- base::grepl
[16:19:20.637]                         restarts <- computeRestarts(cond)
[16:19:20.637]                         for (restart in restarts) {
[16:19:20.637]                           name <- restart$name
[16:19:20.637]                           if (is.null(name)) 
[16:19:20.637]                             next
[16:19:20.637]                           if (!grepl(pattern, name)) 
[16:19:20.637]                             next
[16:19:20.637]                           invokeRestart(restart)
[16:19:20.637]                           muffled <- TRUE
[16:19:20.637]                           break
[16:19:20.637]                         }
[16:19:20.637]                       }
[16:19:20.637]                     }
[16:19:20.637]                     invisible(muffled)
[16:19:20.637]                   }
[16:19:20.637]                   muffleCondition(cond)
[16:19:20.637]                 })
[16:19:20.637]             }))
[16:19:20.637]             future::FutureResult(value = ...future.value$value, 
[16:19:20.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.637]                   ...future.rng), globalenv = if (FALSE) 
[16:19:20.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:20.637]                     ...future.globalenv.names))
[16:19:20.637]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:20.637]         }, condition = base::local({
[16:19:20.637]             c <- base::c
[16:19:20.637]             inherits <- base::inherits
[16:19:20.637]             invokeRestart <- base::invokeRestart
[16:19:20.637]             length <- base::length
[16:19:20.637]             list <- base::list
[16:19:20.637]             seq.int <- base::seq.int
[16:19:20.637]             signalCondition <- base::signalCondition
[16:19:20.637]             sys.calls <- base::sys.calls
[16:19:20.637]             `[[` <- base::`[[`
[16:19:20.637]             `+` <- base::`+`
[16:19:20.637]             `<<-` <- base::`<<-`
[16:19:20.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:20.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:20.637]                   3L)]
[16:19:20.637]             }
[16:19:20.637]             function(cond) {
[16:19:20.637]                 is_error <- inherits(cond, "error")
[16:19:20.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:20.637]                   NULL)
[16:19:20.637]                 if (is_error) {
[16:19:20.637]                   sessionInformation <- function() {
[16:19:20.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:20.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:20.637]                       search = base::search(), system = base::Sys.info())
[16:19:20.637]                   }
[16:19:20.637]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:20.637]                     cond$call), session = sessionInformation(), 
[16:19:20.637]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:20.637]                   signalCondition(cond)
[16:19:20.637]                 }
[16:19:20.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:20.637]                 "immediateCondition"))) {
[16:19:20.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:20.637]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:20.637]                   if (TRUE && !signal) {
[16:19:20.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.637]                     {
[16:19:20.637]                       inherits <- base::inherits
[16:19:20.637]                       invokeRestart <- base::invokeRestart
[16:19:20.637]                       is.null <- base::is.null
[16:19:20.637]                       muffled <- FALSE
[16:19:20.637]                       if (inherits(cond, "message")) {
[16:19:20.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.637]                         if (muffled) 
[16:19:20.637]                           invokeRestart("muffleMessage")
[16:19:20.637]                       }
[16:19:20.637]                       else if (inherits(cond, "warning")) {
[16:19:20.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.637]                         if (muffled) 
[16:19:20.637]                           invokeRestart("muffleWarning")
[16:19:20.637]                       }
[16:19:20.637]                       else if (inherits(cond, "condition")) {
[16:19:20.637]                         if (!is.null(pattern)) {
[16:19:20.637]                           computeRestarts <- base::computeRestarts
[16:19:20.637]                           grepl <- base::grepl
[16:19:20.637]                           restarts <- computeRestarts(cond)
[16:19:20.637]                           for (restart in restarts) {
[16:19:20.637]                             name <- restart$name
[16:19:20.637]                             if (is.null(name)) 
[16:19:20.637]                               next
[16:19:20.637]                             if (!grepl(pattern, name)) 
[16:19:20.637]                               next
[16:19:20.637]                             invokeRestart(restart)
[16:19:20.637]                             muffled <- TRUE
[16:19:20.637]                             break
[16:19:20.637]                           }
[16:19:20.637]                         }
[16:19:20.637]                       }
[16:19:20.637]                       invisible(muffled)
[16:19:20.637]                     }
[16:19:20.637]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.637]                   }
[16:19:20.637]                 }
[16:19:20.637]                 else {
[16:19:20.637]                   if (TRUE) {
[16:19:20.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.637]                     {
[16:19:20.637]                       inherits <- base::inherits
[16:19:20.637]                       invokeRestart <- base::invokeRestart
[16:19:20.637]                       is.null <- base::is.null
[16:19:20.637]                       muffled <- FALSE
[16:19:20.637]                       if (inherits(cond, "message")) {
[16:19:20.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.637]                         if (muffled) 
[16:19:20.637]                           invokeRestart("muffleMessage")
[16:19:20.637]                       }
[16:19:20.637]                       else if (inherits(cond, "warning")) {
[16:19:20.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.637]                         if (muffled) 
[16:19:20.637]                           invokeRestart("muffleWarning")
[16:19:20.637]                       }
[16:19:20.637]                       else if (inherits(cond, "condition")) {
[16:19:20.637]                         if (!is.null(pattern)) {
[16:19:20.637]                           computeRestarts <- base::computeRestarts
[16:19:20.637]                           grepl <- base::grepl
[16:19:20.637]                           restarts <- computeRestarts(cond)
[16:19:20.637]                           for (restart in restarts) {
[16:19:20.637]                             name <- restart$name
[16:19:20.637]                             if (is.null(name)) 
[16:19:20.637]                               next
[16:19:20.637]                             if (!grepl(pattern, name)) 
[16:19:20.637]                               next
[16:19:20.637]                             invokeRestart(restart)
[16:19:20.637]                             muffled <- TRUE
[16:19:20.637]                             break
[16:19:20.637]                           }
[16:19:20.637]                         }
[16:19:20.637]                       }
[16:19:20.637]                       invisible(muffled)
[16:19:20.637]                     }
[16:19:20.637]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.637]                   }
[16:19:20.637]                 }
[16:19:20.637]             }
[16:19:20.637]         }))
[16:19:20.637]     }, error = function(ex) {
[16:19:20.637]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:20.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.637]                 ...future.rng), started = ...future.startTime, 
[16:19:20.637]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:20.637]             version = "1.8"), class = "FutureResult")
[16:19:20.637]     }, finally = {
[16:19:20.637]         if (!identical(...future.workdir, getwd())) 
[16:19:20.637]             setwd(...future.workdir)
[16:19:20.637]         {
[16:19:20.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:20.637]                 ...future.oldOptions$nwarnings <- NULL
[16:19:20.637]             }
[16:19:20.637]             base::options(...future.oldOptions)
[16:19:20.637]             if (.Platform$OS.type == "windows") {
[16:19:20.637]                 old_names <- names(...future.oldEnvVars)
[16:19:20.637]                 envs <- base::Sys.getenv()
[16:19:20.637]                 names <- names(envs)
[16:19:20.637]                 common <- intersect(names, old_names)
[16:19:20.637]                 added <- setdiff(names, old_names)
[16:19:20.637]                 removed <- setdiff(old_names, names)
[16:19:20.637]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:20.637]                   envs[common]]
[16:19:20.637]                 NAMES <- toupper(changed)
[16:19:20.637]                 args <- list()
[16:19:20.637]                 for (kk in seq_along(NAMES)) {
[16:19:20.637]                   name <- changed[[kk]]
[16:19:20.637]                   NAME <- NAMES[[kk]]
[16:19:20.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.637]                     next
[16:19:20.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.637]                 }
[16:19:20.637]                 NAMES <- toupper(added)
[16:19:20.637]                 for (kk in seq_along(NAMES)) {
[16:19:20.637]                   name <- added[[kk]]
[16:19:20.637]                   NAME <- NAMES[[kk]]
[16:19:20.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.637]                     next
[16:19:20.637]                   args[[name]] <- ""
[16:19:20.637]                 }
[16:19:20.637]                 NAMES <- toupper(removed)
[16:19:20.637]                 for (kk in seq_along(NAMES)) {
[16:19:20.637]                   name <- removed[[kk]]
[16:19:20.637]                   NAME <- NAMES[[kk]]
[16:19:20.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.637]                     next
[16:19:20.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.637]                 }
[16:19:20.637]                 if (length(args) > 0) 
[16:19:20.637]                   base::do.call(base::Sys.setenv, args = args)
[16:19:20.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:20.637]             }
[16:19:20.637]             else {
[16:19:20.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:20.637]             }
[16:19:20.637]             {
[16:19:20.637]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:20.637]                   0L) {
[16:19:20.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:20.637]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:20.637]                   base::options(opts)
[16:19:20.637]                 }
[16:19:20.637]                 {
[16:19:20.637]                   {
[16:19:20.637]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:20.637]                     NULL
[16:19:20.637]                   }
[16:19:20.637]                   options(future.plan = NULL)
[16:19:20.637]                   if (is.na(NA_character_)) 
[16:19:20.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:20.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:20.637]                     .init = FALSE)
[16:19:20.637]                 }
[16:19:20.637]             }
[16:19:20.637]         }
[16:19:20.637]     })
[16:19:20.637]     if (TRUE) {
[16:19:20.637]         base::sink(type = "output", split = FALSE)
[16:19:20.637]         if (TRUE) {
[16:19:20.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:20.637]         }
[16:19:20.637]         else {
[16:19:20.637]             ...future.result["stdout"] <- base::list(NULL)
[16:19:20.637]         }
[16:19:20.637]         base::close(...future.stdout)
[16:19:20.637]         ...future.stdout <- NULL
[16:19:20.637]     }
[16:19:20.637]     ...future.result$conditions <- ...future.conditions
[16:19:20.637]     ...future.result$finished <- base::Sys.time()
[16:19:20.637]     ...future.result
[16:19:20.637] }
[16:19:20.640] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[16:19:20.640] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:20.681] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:20.681] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[16:19:20.681] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[16:19:20.681] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:20.682] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:20.682] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:20.724] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:20.725] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:20.769] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:20.769] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:19:20.769] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:19:20.769] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:20.770] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:20.770] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[16:19:20.770] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[16:19:20.770] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:19:20.771] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:19:20.771] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:20.771] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.771] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:20.772] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.772] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[16:19:20.773] MultisessionFuture started
[16:19:20.773] - Launch lazy future ... done
[16:19:20.773] run() for ‘MultisessionFuture’ ... done
[16:19:20.773] Created future:
[16:19:20.774] receiveMessageFromWorker() for ClusterFuture ...
[16:19:20.775] - Validating connection of MultisessionFuture
[16:19:20.775] - received message: FutureResult
[16:19:20.775] - Received FutureResult
[16:19:20.775] - Erased future from FutureRegistry
[16:19:20.775] result() for ClusterFuture ...
[16:19:20.775] - result already collected: FutureResult
[16:19:20.775] result() for ClusterFuture ... done
[16:19:20.775] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:20.773] MultisessionFuture:
[16:19:20.773] Label: ‘future_vapply-1’
[16:19:20.773] Expression:
[16:19:20.773] {
[16:19:20.773]     do.call(function(...) {
[16:19:20.773]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.773]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.773]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.773]             on.exit(options(oopts), add = TRUE)
[16:19:20.773]         }
[16:19:20.773]         {
[16:19:20.773]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.773]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.773]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.773]             })
[16:19:20.773]         }
[16:19:20.773]     }, args = future.call.arguments)
[16:19:20.773] }
[16:19:20.773] Lazy evaluation: FALSE
[16:19:20.773] Asynchronous evaluation: TRUE
[16:19:20.773] Local evaluation: TRUE
[16:19:20.773] Environment: R_GlobalEnv
[16:19:20.773] Capture standard output: TRUE
[16:19:20.773] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:20.773] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:20.773] Packages: 1 packages (‘future.apply’)
[16:19:20.773] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:20.773] Resolved: TRUE
[16:19:20.773] Value: <not collected>
[16:19:20.773] Conditions captured: <none>
[16:19:20.773] Early signaling: FALSE
[16:19:20.773] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:20.773] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.776] Chunk #1 of 2 ... DONE
[16:19:20.776] Chunk #2 of 2 ...
[16:19:20.776]  - Finding globals in 'X' for chunk #2 ...
[16:19:20.776] getGlobalsAndPackages() ...
[16:19:20.776] Searching for globals...
[16:19:20.776] 
[16:19:20.777] Searching for globals ... DONE
[16:19:20.777] - globals: [0] <none>
[16:19:20.777] getGlobalsAndPackages() ... DONE
[16:19:20.777]    + additional globals found: [n=0] 
[16:19:20.777]    + additional namespaces needed: [n=0] 
[16:19:20.777]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:20.777]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:20.777]  - seeds: <none>
[16:19:20.777]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.777] getGlobalsAndPackages() ...
[16:19:20.777] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.778] Resolving globals: FALSE
[16:19:20.778] Tweak future expression to call with '...' arguments ...
[16:19:20.778] {
[16:19:20.778]     do.call(function(...) {
[16:19:20.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.778]             on.exit(options(oopts), add = TRUE)
[16:19:20.778]         }
[16:19:20.778]         {
[16:19:20.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.778]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.778]             })
[16:19:20.778]         }
[16:19:20.778]     }, args = future.call.arguments)
[16:19:20.778] }
[16:19:20.778] Tweak future expression to call with '...' arguments ... DONE
[16:19:20.779] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:20.779] - packages: [1] ‘future.apply’
[16:19:20.779] getGlobalsAndPackages() ... DONE
[16:19:20.779] run() for ‘Future’ ...
[16:19:20.779] - state: ‘created’
[16:19:20.779] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:20.794] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:20.794]   - Field: ‘node’
[16:19:20.794]   - Field: ‘label’
[16:19:20.794]   - Field: ‘local’
[16:19:20.794]   - Field: ‘owner’
[16:19:20.794]   - Field: ‘envir’
[16:19:20.794]   - Field: ‘workers’
[16:19:20.794]   - Field: ‘packages’
[16:19:20.795]   - Field: ‘gc’
[16:19:20.795]   - Field: ‘conditions’
[16:19:20.795]   - Field: ‘persistent’
[16:19:20.795]   - Field: ‘expr’
[16:19:20.795]   - Field: ‘uuid’
[16:19:20.795]   - Field: ‘seed’
[16:19:20.795]   - Field: ‘version’
[16:19:20.795]   - Field: ‘result’
[16:19:20.795]   - Field: ‘asynchronous’
[16:19:20.795]   - Field: ‘calls’
[16:19:20.795]   - Field: ‘globals’
[16:19:20.796]   - Field: ‘stdout’
[16:19:20.796]   - Field: ‘earlySignal’
[16:19:20.796]   - Field: ‘lazy’
[16:19:20.796]   - Field: ‘state’
[16:19:20.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:20.796] - Launch lazy future ...
[16:19:20.796] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:20.796] Packages needed by future strategies (n = 0): <none>
[16:19:20.797] {
[16:19:20.797]     {
[16:19:20.797]         {
[16:19:20.797]             ...future.startTime <- base::Sys.time()
[16:19:20.797]             {
[16:19:20.797]                 {
[16:19:20.797]                   {
[16:19:20.797]                     {
[16:19:20.797]                       {
[16:19:20.797]                         base::local({
[16:19:20.797]                           has_future <- base::requireNamespace("future", 
[16:19:20.797]                             quietly = TRUE)
[16:19:20.797]                           if (has_future) {
[16:19:20.797]                             ns <- base::getNamespace("future")
[16:19:20.797]                             version <- ns[[".package"]][["version"]]
[16:19:20.797]                             if (is.null(version)) 
[16:19:20.797]                               version <- utils::packageVersion("future")
[16:19:20.797]                           }
[16:19:20.797]                           else {
[16:19:20.797]                             version <- NULL
[16:19:20.797]                           }
[16:19:20.797]                           if (!has_future || version < "1.8.0") {
[16:19:20.797]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:20.797]                               "", base::R.version$version.string), 
[16:19:20.797]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:20.797]                                 base::R.version$platform, 8 * 
[16:19:20.797]                                   base::.Machine$sizeof.pointer), 
[16:19:20.797]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:20.797]                                 "release", "version")], collapse = " "), 
[16:19:20.797]                               hostname = base::Sys.info()[["nodename"]])
[16:19:20.797]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:20.797]                               info)
[16:19:20.797]                             info <- base::paste(info, collapse = "; ")
[16:19:20.797]                             if (!has_future) {
[16:19:20.797]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:20.797]                                 info)
[16:19:20.797]                             }
[16:19:20.797]                             else {
[16:19:20.797]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:20.797]                                 info, version)
[16:19:20.797]                             }
[16:19:20.797]                             base::stop(msg)
[16:19:20.797]                           }
[16:19:20.797]                         })
[16:19:20.797]                       }
[16:19:20.797]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:20.797]                       base::options(mc.cores = 1L)
[16:19:20.797]                     }
[16:19:20.797]                     base::local({
[16:19:20.797]                       for (pkg in "future.apply") {
[16:19:20.797]                         base::loadNamespace(pkg)
[16:19:20.797]                         base::library(pkg, character.only = TRUE)
[16:19:20.797]                       }
[16:19:20.797]                     })
[16:19:20.797]                   }
[16:19:20.797]                   ...future.strategy.old <- future::plan("list")
[16:19:20.797]                   options(future.plan = NULL)
[16:19:20.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:20.797]                 }
[16:19:20.797]                 ...future.workdir <- getwd()
[16:19:20.797]             }
[16:19:20.797]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:20.797]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:20.797]         }
[16:19:20.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:20.797]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:20.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:20.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:20.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:20.797]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:20.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:20.797]             base::names(...future.oldOptions))
[16:19:20.797]     }
[16:19:20.797]     if (FALSE) {
[16:19:20.797]     }
[16:19:20.797]     else {
[16:19:20.797]         if (TRUE) {
[16:19:20.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:20.797]                 open = "w")
[16:19:20.797]         }
[16:19:20.797]         else {
[16:19:20.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:20.797]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:20.797]         }
[16:19:20.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:20.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:20.797]             base::sink(type = "output", split = FALSE)
[16:19:20.797]             base::close(...future.stdout)
[16:19:20.797]         }, add = TRUE)
[16:19:20.797]     }
[16:19:20.797]     ...future.frame <- base::sys.nframe()
[16:19:20.797]     ...future.conditions <- base::list()
[16:19:20.797]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:20.797]     if (FALSE) {
[16:19:20.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:20.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:20.797]     }
[16:19:20.797]     ...future.result <- base::tryCatch({
[16:19:20.797]         base::withCallingHandlers({
[16:19:20.797]             ...future.value <- base::withVisible(base::local({
[16:19:20.797]                 ...future.makeSendCondition <- base::local({
[16:19:20.797]                   sendCondition <- NULL
[16:19:20.797]                   function(frame = 1L) {
[16:19:20.797]                     if (is.function(sendCondition)) 
[16:19:20.797]                       return(sendCondition)
[16:19:20.797]                     ns <- getNamespace("parallel")
[16:19:20.797]                     if (exists("sendData", mode = "function", 
[16:19:20.797]                       envir = ns)) {
[16:19:20.797]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:20.797]                         envir = ns)
[16:19:20.797]                       envir <- sys.frame(frame)
[16:19:20.797]                       master <- NULL
[16:19:20.797]                       while (!identical(envir, .GlobalEnv) && 
[16:19:20.797]                         !identical(envir, emptyenv())) {
[16:19:20.797]                         if (exists("master", mode = "list", envir = envir, 
[16:19:20.797]                           inherits = FALSE)) {
[16:19:20.797]                           master <- get("master", mode = "list", 
[16:19:20.797]                             envir = envir, inherits = FALSE)
[16:19:20.797]                           if (inherits(master, c("SOCKnode", 
[16:19:20.797]                             "SOCK0node"))) {
[16:19:20.797]                             sendCondition <<- function(cond) {
[16:19:20.797]                               data <- list(type = "VALUE", value = cond, 
[16:19:20.797]                                 success = TRUE)
[16:19:20.797]                               parallel_sendData(master, data)
[16:19:20.797]                             }
[16:19:20.797]                             return(sendCondition)
[16:19:20.797]                           }
[16:19:20.797]                         }
[16:19:20.797]                         frame <- frame + 1L
[16:19:20.797]                         envir <- sys.frame(frame)
[16:19:20.797]                       }
[16:19:20.797]                     }
[16:19:20.797]                     sendCondition <<- function(cond) NULL
[16:19:20.797]                   }
[16:19:20.797]                 })
[16:19:20.797]                 withCallingHandlers({
[16:19:20.797]                   {
[16:19:20.797]                     do.call(function(...) {
[16:19:20.797]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.797]                       if (!identical(...future.globals.maxSize.org, 
[16:19:20.797]                         ...future.globals.maxSize)) {
[16:19:20.797]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.797]                         on.exit(options(oopts), add = TRUE)
[16:19:20.797]                       }
[16:19:20.797]                       {
[16:19:20.797]                         lapply(seq_along(...future.elements_ii), 
[16:19:20.797]                           FUN = function(jj) {
[16:19:20.797]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.797]                             ...future.FUN(...future.X_jj, ...)
[16:19:20.797]                           })
[16:19:20.797]                       }
[16:19:20.797]                     }, args = future.call.arguments)
[16:19:20.797]                   }
[16:19:20.797]                 }, immediateCondition = function(cond) {
[16:19:20.797]                   sendCondition <- ...future.makeSendCondition()
[16:19:20.797]                   sendCondition(cond)
[16:19:20.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.797]                   {
[16:19:20.797]                     inherits <- base::inherits
[16:19:20.797]                     invokeRestart <- base::invokeRestart
[16:19:20.797]                     is.null <- base::is.null
[16:19:20.797]                     muffled <- FALSE
[16:19:20.797]                     if (inherits(cond, "message")) {
[16:19:20.797]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:20.797]                       if (muffled) 
[16:19:20.797]                         invokeRestart("muffleMessage")
[16:19:20.797]                     }
[16:19:20.797]                     else if (inherits(cond, "warning")) {
[16:19:20.797]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:20.797]                       if (muffled) 
[16:19:20.797]                         invokeRestart("muffleWarning")
[16:19:20.797]                     }
[16:19:20.797]                     else if (inherits(cond, "condition")) {
[16:19:20.797]                       if (!is.null(pattern)) {
[16:19:20.797]                         computeRestarts <- base::computeRestarts
[16:19:20.797]                         grepl <- base::grepl
[16:19:20.797]                         restarts <- computeRestarts(cond)
[16:19:20.797]                         for (restart in restarts) {
[16:19:20.797]                           name <- restart$name
[16:19:20.797]                           if (is.null(name)) 
[16:19:20.797]                             next
[16:19:20.797]                           if (!grepl(pattern, name)) 
[16:19:20.797]                             next
[16:19:20.797]                           invokeRestart(restart)
[16:19:20.797]                           muffled <- TRUE
[16:19:20.797]                           break
[16:19:20.797]                         }
[16:19:20.797]                       }
[16:19:20.797]                     }
[16:19:20.797]                     invisible(muffled)
[16:19:20.797]                   }
[16:19:20.797]                   muffleCondition(cond)
[16:19:20.797]                 })
[16:19:20.797]             }))
[16:19:20.797]             future::FutureResult(value = ...future.value$value, 
[16:19:20.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.797]                   ...future.rng), globalenv = if (FALSE) 
[16:19:20.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:20.797]                     ...future.globalenv.names))
[16:19:20.797]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:20.797]         }, condition = base::local({
[16:19:20.797]             c <- base::c
[16:19:20.797]             inherits <- base::inherits
[16:19:20.797]             invokeRestart <- base::invokeRestart
[16:19:20.797]             length <- base::length
[16:19:20.797]             list <- base::list
[16:19:20.797]             seq.int <- base::seq.int
[16:19:20.797]             signalCondition <- base::signalCondition
[16:19:20.797]             sys.calls <- base::sys.calls
[16:19:20.797]             `[[` <- base::`[[`
[16:19:20.797]             `+` <- base::`+`
[16:19:20.797]             `<<-` <- base::`<<-`
[16:19:20.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:20.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:20.797]                   3L)]
[16:19:20.797]             }
[16:19:20.797]             function(cond) {
[16:19:20.797]                 is_error <- inherits(cond, "error")
[16:19:20.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:20.797]                   NULL)
[16:19:20.797]                 if (is_error) {
[16:19:20.797]                   sessionInformation <- function() {
[16:19:20.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:20.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:20.797]                       search = base::search(), system = base::Sys.info())
[16:19:20.797]                   }
[16:19:20.797]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:20.797]                     cond$call), session = sessionInformation(), 
[16:19:20.797]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:20.797]                   signalCondition(cond)
[16:19:20.797]                 }
[16:19:20.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:20.797]                 "immediateCondition"))) {
[16:19:20.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:20.797]                   ...future.conditions[[length(...future.conditions) + 
[16:19:20.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:20.797]                   if (TRUE && !signal) {
[16:19:20.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.797]                     {
[16:19:20.797]                       inherits <- base::inherits
[16:19:20.797]                       invokeRestart <- base::invokeRestart
[16:19:20.797]                       is.null <- base::is.null
[16:19:20.797]                       muffled <- FALSE
[16:19:20.797]                       if (inherits(cond, "message")) {
[16:19:20.797]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.797]                         if (muffled) 
[16:19:20.797]                           invokeRestart("muffleMessage")
[16:19:20.797]                       }
[16:19:20.797]                       else if (inherits(cond, "warning")) {
[16:19:20.797]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.797]                         if (muffled) 
[16:19:20.797]                           invokeRestart("muffleWarning")
[16:19:20.797]                       }
[16:19:20.797]                       else if (inherits(cond, "condition")) {
[16:19:20.797]                         if (!is.null(pattern)) {
[16:19:20.797]                           computeRestarts <- base::computeRestarts
[16:19:20.797]                           grepl <- base::grepl
[16:19:20.797]                           restarts <- computeRestarts(cond)
[16:19:20.797]                           for (restart in restarts) {
[16:19:20.797]                             name <- restart$name
[16:19:20.797]                             if (is.null(name)) 
[16:19:20.797]                               next
[16:19:20.797]                             if (!grepl(pattern, name)) 
[16:19:20.797]                               next
[16:19:20.797]                             invokeRestart(restart)
[16:19:20.797]                             muffled <- TRUE
[16:19:20.797]                             break
[16:19:20.797]                           }
[16:19:20.797]                         }
[16:19:20.797]                       }
[16:19:20.797]                       invisible(muffled)
[16:19:20.797]                     }
[16:19:20.797]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.797]                   }
[16:19:20.797]                 }
[16:19:20.797]                 else {
[16:19:20.797]                   if (TRUE) {
[16:19:20.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:20.797]                     {
[16:19:20.797]                       inherits <- base::inherits
[16:19:20.797]                       invokeRestart <- base::invokeRestart
[16:19:20.797]                       is.null <- base::is.null
[16:19:20.797]                       muffled <- FALSE
[16:19:20.797]                       if (inherits(cond, "message")) {
[16:19:20.797]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:20.797]                         if (muffled) 
[16:19:20.797]                           invokeRestart("muffleMessage")
[16:19:20.797]                       }
[16:19:20.797]                       else if (inherits(cond, "warning")) {
[16:19:20.797]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:20.797]                         if (muffled) 
[16:19:20.797]                           invokeRestart("muffleWarning")
[16:19:20.797]                       }
[16:19:20.797]                       else if (inherits(cond, "condition")) {
[16:19:20.797]                         if (!is.null(pattern)) {
[16:19:20.797]                           computeRestarts <- base::computeRestarts
[16:19:20.797]                           grepl <- base::grepl
[16:19:20.797]                           restarts <- computeRestarts(cond)
[16:19:20.797]                           for (restart in restarts) {
[16:19:20.797]                             name <- restart$name
[16:19:20.797]                             if (is.null(name)) 
[16:19:20.797]                               next
[16:19:20.797]                             if (!grepl(pattern, name)) 
[16:19:20.797]                               next
[16:19:20.797]                             invokeRestart(restart)
[16:19:20.797]                             muffled <- TRUE
[16:19:20.797]                             break
[16:19:20.797]                           }
[16:19:20.797]                         }
[16:19:20.797]                       }
[16:19:20.797]                       invisible(muffled)
[16:19:20.797]                     }
[16:19:20.797]                     muffleCondition(cond, pattern = "^muffle")
[16:19:20.797]                   }
[16:19:20.797]                 }
[16:19:20.797]             }
[16:19:20.797]         }))
[16:19:20.797]     }, error = function(ex) {
[16:19:20.797]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:20.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:20.797]                 ...future.rng), started = ...future.startTime, 
[16:19:20.797]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:20.797]             version = "1.8"), class = "FutureResult")
[16:19:20.797]     }, finally = {
[16:19:20.797]         if (!identical(...future.workdir, getwd())) 
[16:19:20.797]             setwd(...future.workdir)
[16:19:20.797]         {
[16:19:20.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:20.797]                 ...future.oldOptions$nwarnings <- NULL
[16:19:20.797]             }
[16:19:20.797]             base::options(...future.oldOptions)
[16:19:20.797]             if (.Platform$OS.type == "windows") {
[16:19:20.797]                 old_names <- names(...future.oldEnvVars)
[16:19:20.797]                 envs <- base::Sys.getenv()
[16:19:20.797]                 names <- names(envs)
[16:19:20.797]                 common <- intersect(names, old_names)
[16:19:20.797]                 added <- setdiff(names, old_names)
[16:19:20.797]                 removed <- setdiff(old_names, names)
[16:19:20.797]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:20.797]                   envs[common]]
[16:19:20.797]                 NAMES <- toupper(changed)
[16:19:20.797]                 args <- list()
[16:19:20.797]                 for (kk in seq_along(NAMES)) {
[16:19:20.797]                   name <- changed[[kk]]
[16:19:20.797]                   NAME <- NAMES[[kk]]
[16:19:20.797]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.797]                     next
[16:19:20.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.797]                 }
[16:19:20.797]                 NAMES <- toupper(added)
[16:19:20.797]                 for (kk in seq_along(NAMES)) {
[16:19:20.797]                   name <- added[[kk]]
[16:19:20.797]                   NAME <- NAMES[[kk]]
[16:19:20.797]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.797]                     next
[16:19:20.797]                   args[[name]] <- ""
[16:19:20.797]                 }
[16:19:20.797]                 NAMES <- toupper(removed)
[16:19:20.797]                 for (kk in seq_along(NAMES)) {
[16:19:20.797]                   name <- removed[[kk]]
[16:19:20.797]                   NAME <- NAMES[[kk]]
[16:19:20.797]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:20.797]                     next
[16:19:20.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:20.797]                 }
[16:19:20.797]                 if (length(args) > 0) 
[16:19:20.797]                   base::do.call(base::Sys.setenv, args = args)
[16:19:20.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:20.797]             }
[16:19:20.797]             else {
[16:19:20.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:20.797]             }
[16:19:20.797]             {
[16:19:20.797]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:20.797]                   0L) {
[16:19:20.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:20.797]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:20.797]                   base::options(opts)
[16:19:20.797]                 }
[16:19:20.797]                 {
[16:19:20.797]                   {
[16:19:20.797]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:20.797]                     NULL
[16:19:20.797]                   }
[16:19:20.797]                   options(future.plan = NULL)
[16:19:20.797]                   if (is.na(NA_character_)) 
[16:19:20.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:20.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:20.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:20.797]                     .init = FALSE)
[16:19:20.797]                 }
[16:19:20.797]             }
[16:19:20.797]         }
[16:19:20.797]     })
[16:19:20.797]     if (TRUE) {
[16:19:20.797]         base::sink(type = "output", split = FALSE)
[16:19:20.797]         if (TRUE) {
[16:19:20.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:20.797]         }
[16:19:20.797]         else {
[16:19:20.797]             ...future.result["stdout"] <- base::list(NULL)
[16:19:20.797]         }
[16:19:20.797]         base::close(...future.stdout)
[16:19:20.797]         ...future.stdout <- NULL
[16:19:20.797]     }
[16:19:20.797]     ...future.result$conditions <- ...future.conditions
[16:19:20.797]     ...future.result$finished <- base::Sys.time()
[16:19:20.797]     ...future.result
[16:19:20.797] }
[16:19:20.800] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[16:19:20.800] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:20.840] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:20.841] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[16:19:20.841] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[16:19:20.842] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:20.842] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:20.842] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:20.885] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:20.885] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:20.929] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:20.929] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:19:20.929] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:19:20.929] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:20.930] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:20.930] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[16:19:20.930] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[16:19:20.931] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:19:20.931] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:19:20.931] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:20.931] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.932] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:20.932] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:20.932] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[16:19:20.932] MultisessionFuture started
[16:19:20.933] - Launch lazy future ... done
[16:19:20.933] run() for ‘MultisessionFuture’ ... done
[16:19:20.933] Created future:
[16:19:20.933] MultisessionFuture:
[16:19:20.933] Label: ‘future_vapply-2’
[16:19:20.933] Expression:
[16:19:20.933] {
[16:19:20.933]     do.call(function(...) {
[16:19:20.933]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:20.933]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:20.933]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:20.933]             on.exit(options(oopts), add = TRUE)
[16:19:20.933]         }
[16:19:20.933]         {
[16:19:20.933]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:20.933]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:20.933]                 ...future.FUN(...future.X_jj, ...)
[16:19:20.933]             })
[16:19:20.933]         }
[16:19:20.933]     }, args = future.call.arguments)
[16:19:20.933] }
[16:19:20.933] Lazy evaluation: FALSE
[16:19:20.933] Asynchronous evaluation: TRUE
[16:19:20.933] Local evaluation: TRUE
[16:19:20.933] Environment: R_GlobalEnv
[16:19:20.933] Capture standard output: TRUE
[16:19:20.933] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:20.933] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:20.933] Packages: 1 packages (‘future.apply’)
[16:19:20.933] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:20.933] Resolved: FALSE
[16:19:20.933] Value: <not collected>
[16:19:20.933] Conditions captured: <none>
[16:19:20.933] Early signaling: FALSE
[16:19:20.933] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:20.933] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:20.944] Chunk #2 of 2 ... DONE
[16:19:20.945] Launching 2 futures (chunks) ... DONE
[16:19:20.945] Resolving 2 futures (chunks) ...
[16:19:20.945] resolve() on list ...
[16:19:20.945]  recursive: 0
[16:19:20.945]  length: 2
[16:19:20.945] 
[16:19:20.945] Future #1
[16:19:20.945] result() for ClusterFuture ...
[16:19:20.945] - result already collected: FutureResult
[16:19:20.945] result() for ClusterFuture ... done
[16:19:20.946] result() for ClusterFuture ...
[16:19:20.946] - result already collected: FutureResult
[16:19:20.946] result() for ClusterFuture ... done
[16:19:20.946] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:20.946] - nx: 2
[16:19:20.946] - relay: TRUE
[16:19:20.946] - stdout: TRUE
[16:19:20.946] - signal: TRUE
[16:19:20.946] - resignal: FALSE
[16:19:20.946] - force: TRUE
[16:19:20.946] - relayed: [n=2] FALSE, FALSE
[16:19:20.946] - queued futures: [n=2] FALSE, FALSE
[16:19:20.947]  - until=1
[16:19:20.947]  - relaying element #1
[16:19:20.947] result() for ClusterFuture ...
[16:19:20.947] - result already collected: FutureResult
[16:19:20.947] result() for ClusterFuture ... done
[16:19:20.947] result() for ClusterFuture ...
[16:19:20.947] - result already collected: FutureResult
[16:19:20.947] result() for ClusterFuture ... done
[16:19:20.947] result() for ClusterFuture ...
[16:19:20.947] - result already collected: FutureResult
[16:19:20.947] result() for ClusterFuture ... done
[16:19:20.948] result() for ClusterFuture ...
[16:19:20.948] - result already collected: FutureResult
[16:19:20.948] result() for ClusterFuture ... done
[16:19:20.948] - relayed: [n=2] TRUE, FALSE
[16:19:20.948] - queued futures: [n=2] TRUE, FALSE
[16:19:20.948] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:20.948]  length: 1 (resolved future 1)
[16:19:20.978] receiveMessageFromWorker() for ClusterFuture ...
[16:19:20.978] - Validating connection of MultisessionFuture
[16:19:20.978] - received message: FutureResult
[16:19:20.978] - Received FutureResult
[16:19:20.979] - Erased future from FutureRegistry
[16:19:20.979] result() for ClusterFuture ...
[16:19:20.979] - result already collected: FutureResult
[16:19:20.979] result() for ClusterFuture ... done
[16:19:20.979] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:20.979] Future #2
[16:19:20.979] result() for ClusterFuture ...
[16:19:20.979] - result already collected: FutureResult
[16:19:20.979] result() for ClusterFuture ... done
[16:19:20.979] result() for ClusterFuture ...
[16:19:20.979] - result already collected: FutureResult
[16:19:20.979] result() for ClusterFuture ... done
[16:19:20.980] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:20.980] - nx: 2
[16:19:20.980] - relay: TRUE
[16:19:20.980] - stdout: TRUE
[16:19:20.980] - signal: TRUE
[16:19:20.980] - resignal: FALSE
[16:19:20.980] - force: TRUE
[16:19:20.980] - relayed: [n=2] TRUE, FALSE
[16:19:20.980] - queued futures: [n=2] TRUE, FALSE
[16:19:20.980]  - until=2
[16:19:20.980]  - relaying element #2
[16:19:20.981] result() for ClusterFuture ...
[16:19:20.981] - result already collected: FutureResult
[16:19:20.981] result() for ClusterFuture ... done
[16:19:20.981] result() for ClusterFuture ...
[16:19:20.981] - result already collected: FutureResult
[16:19:20.981] result() for ClusterFuture ... done
[16:19:20.981] result() for ClusterFuture ...
[16:19:20.981] - result already collected: FutureResult
[16:19:20.981] result() for ClusterFuture ... done
[16:19:20.981] result() for ClusterFuture ...
[16:19:20.981] - result already collected: FutureResult
[16:19:20.982] result() for ClusterFuture ... done
[16:19:20.982] - relayed: [n=2] TRUE, TRUE
[16:19:20.982] - queued futures: [n=2] TRUE, TRUE
[16:19:20.982] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:20.982]  length: 0 (resolved future 2)
[16:19:20.982] Relaying remaining futures
[16:19:20.982] signalConditionsASAP(NULL, pos=0) ...
[16:19:20.982] - nx: 2
[16:19:20.982] - relay: TRUE
[16:19:20.982] - stdout: TRUE
[16:19:20.982] - signal: TRUE
[16:19:20.982] - resignal: FALSE
[16:19:20.983] - force: TRUE
[16:19:20.983] - relayed: [n=2] TRUE, TRUE
[16:19:20.983] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:20.983] - relayed: [n=2] TRUE, TRUE
[16:19:20.983] - queued futures: [n=2] TRUE, TRUE
[16:19:20.983] signalConditionsASAP(NULL, pos=0) ... done
[16:19:20.983] resolve() on list ... DONE
[16:19:20.983] result() for ClusterFuture ...
[16:19:20.983] - result already collected: FutureResult
[16:19:20.983] result() for ClusterFuture ... done
[16:19:20.983] result() for ClusterFuture ...
[16:19:20.984] - result already collected: FutureResult
[16:19:20.984] result() for ClusterFuture ... done
[16:19:20.984] result() for ClusterFuture ...
[16:19:20.984] - result already collected: FutureResult
[16:19:20.984] result() for ClusterFuture ... done
[16:19:20.984] result() for ClusterFuture ...
[16:19:20.984] - result already collected: FutureResult
[16:19:20.984] result() for ClusterFuture ... done
[16:19:20.984]  - Number of value chunks collected: 2
[16:19:20.984] Resolving 2 futures (chunks) ... DONE
[16:19:20.984] Reducing values from 2 chunks ...
[16:19:20.985]  - Number of values collected after concatenation: 4
[16:19:20.985]  - Number of values expected: 4
[16:19:20.985] Reducing values from 2 chunks ... DONE
[16:19:20.985] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:19:20.986] future_lapply() ...
[16:19:20.992] Number of chunks: 2
[16:19:20.992] getGlobalsAndPackagesXApply() ...
[16:19:20.992]  - future.globals: TRUE
[16:19:20.992] getGlobalsAndPackages() ...
[16:19:20.992] Searching for globals...
[16:19:20.996] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:20.996] Searching for globals ... DONE
[16:19:20.996] Resolving globals: FALSE
[16:19:20.997] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:19:20.997] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:20.997] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:20.997] - packages: [1] ‘future.apply’
[16:19:20.997] getGlobalsAndPackages() ... DONE
[16:19:20.998]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:20.998]  - needed namespaces: [n=1] ‘future.apply’
[16:19:20.998] Finding globals ... DONE
[16:19:20.998]  - use_args: TRUE
[16:19:20.998]  - Getting '...' globals ...
[16:19:20.998] resolve() on list ...
[16:19:20.998]  recursive: 0
[16:19:20.998]  length: 1
[16:19:20.999]  elements: ‘...’
[16:19:20.999]  length: 0 (resolved future 1)
[16:19:20.999] resolve() on list ... DONE
[16:19:20.999]    - '...' content: [n=0] 
[16:19:20.999] List of 1
[16:19:20.999]  $ ...: list()
[16:19:20.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:20.999]  - attr(*, "where")=List of 1
[16:19:20.999]   ..$ ...:<environment: 0x5619a01c31b8> 
[16:19:20.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:20.999]  - attr(*, "resolved")= logi TRUE
[16:19:20.999]  - attr(*, "total_size")= num NA
[16:19:21.001]  - Getting '...' globals ... DONE
[16:19:21.002] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:21.002] List of 8
[16:19:21.002]  $ ...future.FUN:function (x, ...)  
[16:19:21.002]  $ x_FUN        :function (x)  
[16:19:21.002]  $ times        : int 1
[16:19:21.002]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:21.002]  $ stop_if_not  :function (...)  
[16:19:21.002]  $ dim          : NULL
[16:19:21.002]  $ valid_types  : chr "logical"
[16:19:21.002]  $ ...          : list()
[16:19:21.002]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:21.002]  - attr(*, "where")=List of 8
[16:19:21.002]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:21.002]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:21.002]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:21.002]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:21.002]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:21.002]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:21.002]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:21.002]   ..$ ...          :<environment: 0x5619a01c31b8> 
[16:19:21.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:21.002]  - attr(*, "resolved")= logi FALSE
[16:19:21.002]  - attr(*, "total_size")= num 94200
[16:19:21.007] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:21.007] getGlobalsAndPackagesXApply() ... DONE
[16:19:21.007] Number of futures (= number of chunks): 2
[16:19:21.007] Launching 2 futures (chunks) ...
[16:19:21.008] Chunk #1 of 2 ...
[16:19:21.008]  - Finding globals in 'X' for chunk #1 ...
[16:19:21.008] getGlobalsAndPackages() ...
[16:19:21.008] Searching for globals...
[16:19:21.008] 
[16:19:21.008] Searching for globals ... DONE
[16:19:21.008] - globals: [0] <none>
[16:19:21.008] getGlobalsAndPackages() ... DONE
[16:19:21.008]    + additional globals found: [n=0] 
[16:19:21.009]    + additional namespaces needed: [n=0] 
[16:19:21.009]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:21.009]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:21.009]  - seeds: <none>
[16:19:21.009]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.009] getGlobalsAndPackages() ...
[16:19:21.009] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.009] Resolving globals: FALSE
[16:19:21.009] Tweak future expression to call with '...' arguments ...
[16:19:21.009] {
[16:19:21.009]     do.call(function(...) {
[16:19:21.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.009]             on.exit(options(oopts), add = TRUE)
[16:19:21.009]         }
[16:19:21.009]         {
[16:19:21.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.009]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.009]             })
[16:19:21.009]         }
[16:19:21.009]     }, args = future.call.arguments)
[16:19:21.009] }
[16:19:21.010] Tweak future expression to call with '...' arguments ... DONE
[16:19:21.010] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.010] - packages: [1] ‘future.apply’
[16:19:21.010] getGlobalsAndPackages() ... DONE
[16:19:21.011] run() for ‘Future’ ...
[16:19:21.011] - state: ‘created’
[16:19:21.011] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:21.030] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:21.031]   - Field: ‘node’
[16:19:21.031]   - Field: ‘label’
[16:19:21.031]   - Field: ‘local’
[16:19:21.031]   - Field: ‘owner’
[16:19:21.031]   - Field: ‘envir’
[16:19:21.031]   - Field: ‘workers’
[16:19:21.031]   - Field: ‘packages’
[16:19:21.031]   - Field: ‘gc’
[16:19:21.031]   - Field: ‘conditions’
[16:19:21.031]   - Field: ‘persistent’
[16:19:21.032]   - Field: ‘expr’
[16:19:21.032]   - Field: ‘uuid’
[16:19:21.032]   - Field: ‘seed’
[16:19:21.032]   - Field: ‘version’
[16:19:21.032]   - Field: ‘result’
[16:19:21.032]   - Field: ‘asynchronous’
[16:19:21.032]   - Field: ‘calls’
[16:19:21.032]   - Field: ‘globals’
[16:19:21.032]   - Field: ‘stdout’
[16:19:21.032]   - Field: ‘earlySignal’
[16:19:21.032]   - Field: ‘lazy’
[16:19:21.033]   - Field: ‘state’
[16:19:21.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:21.033] - Launch lazy future ...
[16:19:21.033] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:21.033] Packages needed by future strategies (n = 0): <none>
[16:19:21.034] {
[16:19:21.034]     {
[16:19:21.034]         {
[16:19:21.034]             ...future.startTime <- base::Sys.time()
[16:19:21.034]             {
[16:19:21.034]                 {
[16:19:21.034]                   {
[16:19:21.034]                     {
[16:19:21.034]                       {
[16:19:21.034]                         base::local({
[16:19:21.034]                           has_future <- base::requireNamespace("future", 
[16:19:21.034]                             quietly = TRUE)
[16:19:21.034]                           if (has_future) {
[16:19:21.034]                             ns <- base::getNamespace("future")
[16:19:21.034]                             version <- ns[[".package"]][["version"]]
[16:19:21.034]                             if (is.null(version)) 
[16:19:21.034]                               version <- utils::packageVersion("future")
[16:19:21.034]                           }
[16:19:21.034]                           else {
[16:19:21.034]                             version <- NULL
[16:19:21.034]                           }
[16:19:21.034]                           if (!has_future || version < "1.8.0") {
[16:19:21.034]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:21.034]                               "", base::R.version$version.string), 
[16:19:21.034]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:21.034]                                 base::R.version$platform, 8 * 
[16:19:21.034]                                   base::.Machine$sizeof.pointer), 
[16:19:21.034]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:21.034]                                 "release", "version")], collapse = " "), 
[16:19:21.034]                               hostname = base::Sys.info()[["nodename"]])
[16:19:21.034]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:21.034]                               info)
[16:19:21.034]                             info <- base::paste(info, collapse = "; ")
[16:19:21.034]                             if (!has_future) {
[16:19:21.034]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:21.034]                                 info)
[16:19:21.034]                             }
[16:19:21.034]                             else {
[16:19:21.034]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:21.034]                                 info, version)
[16:19:21.034]                             }
[16:19:21.034]                             base::stop(msg)
[16:19:21.034]                           }
[16:19:21.034]                         })
[16:19:21.034]                       }
[16:19:21.034]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:21.034]                       base::options(mc.cores = 1L)
[16:19:21.034]                     }
[16:19:21.034]                     base::local({
[16:19:21.034]                       for (pkg in "future.apply") {
[16:19:21.034]                         base::loadNamespace(pkg)
[16:19:21.034]                         base::library(pkg, character.only = TRUE)
[16:19:21.034]                       }
[16:19:21.034]                     })
[16:19:21.034]                   }
[16:19:21.034]                   ...future.strategy.old <- future::plan("list")
[16:19:21.034]                   options(future.plan = NULL)
[16:19:21.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:21.034]                 }
[16:19:21.034]                 ...future.workdir <- getwd()
[16:19:21.034]             }
[16:19:21.034]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:21.034]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:21.034]         }
[16:19:21.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:21.034]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:21.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:21.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:21.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:21.034]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:21.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:21.034]             base::names(...future.oldOptions))
[16:19:21.034]     }
[16:19:21.034]     if (FALSE) {
[16:19:21.034]     }
[16:19:21.034]     else {
[16:19:21.034]         if (TRUE) {
[16:19:21.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:21.034]                 open = "w")
[16:19:21.034]         }
[16:19:21.034]         else {
[16:19:21.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:21.034]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:21.034]         }
[16:19:21.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:21.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:21.034]             base::sink(type = "output", split = FALSE)
[16:19:21.034]             base::close(...future.stdout)
[16:19:21.034]         }, add = TRUE)
[16:19:21.034]     }
[16:19:21.034]     ...future.frame <- base::sys.nframe()
[16:19:21.034]     ...future.conditions <- base::list()
[16:19:21.034]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:21.034]     if (FALSE) {
[16:19:21.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:21.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:21.034]     }
[16:19:21.034]     ...future.result <- base::tryCatch({
[16:19:21.034]         base::withCallingHandlers({
[16:19:21.034]             ...future.value <- base::withVisible(base::local({
[16:19:21.034]                 ...future.makeSendCondition <- base::local({
[16:19:21.034]                   sendCondition <- NULL
[16:19:21.034]                   function(frame = 1L) {
[16:19:21.034]                     if (is.function(sendCondition)) 
[16:19:21.034]                       return(sendCondition)
[16:19:21.034]                     ns <- getNamespace("parallel")
[16:19:21.034]                     if (exists("sendData", mode = "function", 
[16:19:21.034]                       envir = ns)) {
[16:19:21.034]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:21.034]                         envir = ns)
[16:19:21.034]                       envir <- sys.frame(frame)
[16:19:21.034]                       master <- NULL
[16:19:21.034]                       while (!identical(envir, .GlobalEnv) && 
[16:19:21.034]                         !identical(envir, emptyenv())) {
[16:19:21.034]                         if (exists("master", mode = "list", envir = envir, 
[16:19:21.034]                           inherits = FALSE)) {
[16:19:21.034]                           master <- get("master", mode = "list", 
[16:19:21.034]                             envir = envir, inherits = FALSE)
[16:19:21.034]                           if (inherits(master, c("SOCKnode", 
[16:19:21.034]                             "SOCK0node"))) {
[16:19:21.034]                             sendCondition <<- function(cond) {
[16:19:21.034]                               data <- list(type = "VALUE", value = cond, 
[16:19:21.034]                                 success = TRUE)
[16:19:21.034]                               parallel_sendData(master, data)
[16:19:21.034]                             }
[16:19:21.034]                             return(sendCondition)
[16:19:21.034]                           }
[16:19:21.034]                         }
[16:19:21.034]                         frame <- frame + 1L
[16:19:21.034]                         envir <- sys.frame(frame)
[16:19:21.034]                       }
[16:19:21.034]                     }
[16:19:21.034]                     sendCondition <<- function(cond) NULL
[16:19:21.034]                   }
[16:19:21.034]                 })
[16:19:21.034]                 withCallingHandlers({
[16:19:21.034]                   {
[16:19:21.034]                     do.call(function(...) {
[16:19:21.034]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.034]                       if (!identical(...future.globals.maxSize.org, 
[16:19:21.034]                         ...future.globals.maxSize)) {
[16:19:21.034]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.034]                         on.exit(options(oopts), add = TRUE)
[16:19:21.034]                       }
[16:19:21.034]                       {
[16:19:21.034]                         lapply(seq_along(...future.elements_ii), 
[16:19:21.034]                           FUN = function(jj) {
[16:19:21.034]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.034]                             ...future.FUN(...future.X_jj, ...)
[16:19:21.034]                           })
[16:19:21.034]                       }
[16:19:21.034]                     }, args = future.call.arguments)
[16:19:21.034]                   }
[16:19:21.034]                 }, immediateCondition = function(cond) {
[16:19:21.034]                   sendCondition <- ...future.makeSendCondition()
[16:19:21.034]                   sendCondition(cond)
[16:19:21.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.034]                   {
[16:19:21.034]                     inherits <- base::inherits
[16:19:21.034]                     invokeRestart <- base::invokeRestart
[16:19:21.034]                     is.null <- base::is.null
[16:19:21.034]                     muffled <- FALSE
[16:19:21.034]                     if (inherits(cond, "message")) {
[16:19:21.034]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:21.034]                       if (muffled) 
[16:19:21.034]                         invokeRestart("muffleMessage")
[16:19:21.034]                     }
[16:19:21.034]                     else if (inherits(cond, "warning")) {
[16:19:21.034]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:21.034]                       if (muffled) 
[16:19:21.034]                         invokeRestart("muffleWarning")
[16:19:21.034]                     }
[16:19:21.034]                     else if (inherits(cond, "condition")) {
[16:19:21.034]                       if (!is.null(pattern)) {
[16:19:21.034]                         computeRestarts <- base::computeRestarts
[16:19:21.034]                         grepl <- base::grepl
[16:19:21.034]                         restarts <- computeRestarts(cond)
[16:19:21.034]                         for (restart in restarts) {
[16:19:21.034]                           name <- restart$name
[16:19:21.034]                           if (is.null(name)) 
[16:19:21.034]                             next
[16:19:21.034]                           if (!grepl(pattern, name)) 
[16:19:21.034]                             next
[16:19:21.034]                           invokeRestart(restart)
[16:19:21.034]                           muffled <- TRUE
[16:19:21.034]                           break
[16:19:21.034]                         }
[16:19:21.034]                       }
[16:19:21.034]                     }
[16:19:21.034]                     invisible(muffled)
[16:19:21.034]                   }
[16:19:21.034]                   muffleCondition(cond)
[16:19:21.034]                 })
[16:19:21.034]             }))
[16:19:21.034]             future::FutureResult(value = ...future.value$value, 
[16:19:21.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.034]                   ...future.rng), globalenv = if (FALSE) 
[16:19:21.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:21.034]                     ...future.globalenv.names))
[16:19:21.034]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:21.034]         }, condition = base::local({
[16:19:21.034]             c <- base::c
[16:19:21.034]             inherits <- base::inherits
[16:19:21.034]             invokeRestart <- base::invokeRestart
[16:19:21.034]             length <- base::length
[16:19:21.034]             list <- base::list
[16:19:21.034]             seq.int <- base::seq.int
[16:19:21.034]             signalCondition <- base::signalCondition
[16:19:21.034]             sys.calls <- base::sys.calls
[16:19:21.034]             `[[` <- base::`[[`
[16:19:21.034]             `+` <- base::`+`
[16:19:21.034]             `<<-` <- base::`<<-`
[16:19:21.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:21.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:21.034]                   3L)]
[16:19:21.034]             }
[16:19:21.034]             function(cond) {
[16:19:21.034]                 is_error <- inherits(cond, "error")
[16:19:21.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:21.034]                   NULL)
[16:19:21.034]                 if (is_error) {
[16:19:21.034]                   sessionInformation <- function() {
[16:19:21.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:21.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:21.034]                       search = base::search(), system = base::Sys.info())
[16:19:21.034]                   }
[16:19:21.034]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:21.034]                     cond$call), session = sessionInformation(), 
[16:19:21.034]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:21.034]                   signalCondition(cond)
[16:19:21.034]                 }
[16:19:21.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:21.034]                 "immediateCondition"))) {
[16:19:21.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:21.034]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:21.034]                   if (TRUE && !signal) {
[16:19:21.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.034]                     {
[16:19:21.034]                       inherits <- base::inherits
[16:19:21.034]                       invokeRestart <- base::invokeRestart
[16:19:21.034]                       is.null <- base::is.null
[16:19:21.034]                       muffled <- FALSE
[16:19:21.034]                       if (inherits(cond, "message")) {
[16:19:21.034]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.034]                         if (muffled) 
[16:19:21.034]                           invokeRestart("muffleMessage")
[16:19:21.034]                       }
[16:19:21.034]                       else if (inherits(cond, "warning")) {
[16:19:21.034]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.034]                         if (muffled) 
[16:19:21.034]                           invokeRestart("muffleWarning")
[16:19:21.034]                       }
[16:19:21.034]                       else if (inherits(cond, "condition")) {
[16:19:21.034]                         if (!is.null(pattern)) {
[16:19:21.034]                           computeRestarts <- base::computeRestarts
[16:19:21.034]                           grepl <- base::grepl
[16:19:21.034]                           restarts <- computeRestarts(cond)
[16:19:21.034]                           for (restart in restarts) {
[16:19:21.034]                             name <- restart$name
[16:19:21.034]                             if (is.null(name)) 
[16:19:21.034]                               next
[16:19:21.034]                             if (!grepl(pattern, name)) 
[16:19:21.034]                               next
[16:19:21.034]                             invokeRestart(restart)
[16:19:21.034]                             muffled <- TRUE
[16:19:21.034]                             break
[16:19:21.034]                           }
[16:19:21.034]                         }
[16:19:21.034]                       }
[16:19:21.034]                       invisible(muffled)
[16:19:21.034]                     }
[16:19:21.034]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.034]                   }
[16:19:21.034]                 }
[16:19:21.034]                 else {
[16:19:21.034]                   if (TRUE) {
[16:19:21.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.034]                     {
[16:19:21.034]                       inherits <- base::inherits
[16:19:21.034]                       invokeRestart <- base::invokeRestart
[16:19:21.034]                       is.null <- base::is.null
[16:19:21.034]                       muffled <- FALSE
[16:19:21.034]                       if (inherits(cond, "message")) {
[16:19:21.034]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.034]                         if (muffled) 
[16:19:21.034]                           invokeRestart("muffleMessage")
[16:19:21.034]                       }
[16:19:21.034]                       else if (inherits(cond, "warning")) {
[16:19:21.034]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.034]                         if (muffled) 
[16:19:21.034]                           invokeRestart("muffleWarning")
[16:19:21.034]                       }
[16:19:21.034]                       else if (inherits(cond, "condition")) {
[16:19:21.034]                         if (!is.null(pattern)) {
[16:19:21.034]                           computeRestarts <- base::computeRestarts
[16:19:21.034]                           grepl <- base::grepl
[16:19:21.034]                           restarts <- computeRestarts(cond)
[16:19:21.034]                           for (restart in restarts) {
[16:19:21.034]                             name <- restart$name
[16:19:21.034]                             if (is.null(name)) 
[16:19:21.034]                               next
[16:19:21.034]                             if (!grepl(pattern, name)) 
[16:19:21.034]                               next
[16:19:21.034]                             invokeRestart(restart)
[16:19:21.034]                             muffled <- TRUE
[16:19:21.034]                             break
[16:19:21.034]                           }
[16:19:21.034]                         }
[16:19:21.034]                       }
[16:19:21.034]                       invisible(muffled)
[16:19:21.034]                     }
[16:19:21.034]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.034]                   }
[16:19:21.034]                 }
[16:19:21.034]             }
[16:19:21.034]         }))
[16:19:21.034]     }, error = function(ex) {
[16:19:21.034]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:21.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.034]                 ...future.rng), started = ...future.startTime, 
[16:19:21.034]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:21.034]             version = "1.8"), class = "FutureResult")
[16:19:21.034]     }, finally = {
[16:19:21.034]         if (!identical(...future.workdir, getwd())) 
[16:19:21.034]             setwd(...future.workdir)
[16:19:21.034]         {
[16:19:21.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:21.034]                 ...future.oldOptions$nwarnings <- NULL
[16:19:21.034]             }
[16:19:21.034]             base::options(...future.oldOptions)
[16:19:21.034]             if (.Platform$OS.type == "windows") {
[16:19:21.034]                 old_names <- names(...future.oldEnvVars)
[16:19:21.034]                 envs <- base::Sys.getenv()
[16:19:21.034]                 names <- names(envs)
[16:19:21.034]                 common <- intersect(names, old_names)
[16:19:21.034]                 added <- setdiff(names, old_names)
[16:19:21.034]                 removed <- setdiff(old_names, names)
[16:19:21.034]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:21.034]                   envs[common]]
[16:19:21.034]                 NAMES <- toupper(changed)
[16:19:21.034]                 args <- list()
[16:19:21.034]                 for (kk in seq_along(NAMES)) {
[16:19:21.034]                   name <- changed[[kk]]
[16:19:21.034]                   NAME <- NAMES[[kk]]
[16:19:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.034]                     next
[16:19:21.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.034]                 }
[16:19:21.034]                 NAMES <- toupper(added)
[16:19:21.034]                 for (kk in seq_along(NAMES)) {
[16:19:21.034]                   name <- added[[kk]]
[16:19:21.034]                   NAME <- NAMES[[kk]]
[16:19:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.034]                     next
[16:19:21.034]                   args[[name]] <- ""
[16:19:21.034]                 }
[16:19:21.034]                 NAMES <- toupper(removed)
[16:19:21.034]                 for (kk in seq_along(NAMES)) {
[16:19:21.034]                   name <- removed[[kk]]
[16:19:21.034]                   NAME <- NAMES[[kk]]
[16:19:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.034]                     next
[16:19:21.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.034]                 }
[16:19:21.034]                 if (length(args) > 0) 
[16:19:21.034]                   base::do.call(base::Sys.setenv, args = args)
[16:19:21.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:21.034]             }
[16:19:21.034]             else {
[16:19:21.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:21.034]             }
[16:19:21.034]             {
[16:19:21.034]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:21.034]                   0L) {
[16:19:21.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:21.034]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:21.034]                   base::options(opts)
[16:19:21.034]                 }
[16:19:21.034]                 {
[16:19:21.034]                   {
[16:19:21.034]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:21.034]                     NULL
[16:19:21.034]                   }
[16:19:21.034]                   options(future.plan = NULL)
[16:19:21.034]                   if (is.na(NA_character_)) 
[16:19:21.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:21.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:21.034]                     .init = FALSE)
[16:19:21.034]                 }
[16:19:21.034]             }
[16:19:21.034]         }
[16:19:21.034]     })
[16:19:21.034]     if (TRUE) {
[16:19:21.034]         base::sink(type = "output", split = FALSE)
[16:19:21.034]         if (TRUE) {
[16:19:21.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:21.034]         }
[16:19:21.034]         else {
[16:19:21.034]             ...future.result["stdout"] <- base::list(NULL)
[16:19:21.034]         }
[16:19:21.034]         base::close(...future.stdout)
[16:19:21.034]         ...future.stdout <- NULL
[16:19:21.034]     }
[16:19:21.034]     ...future.result$conditions <- ...future.conditions
[16:19:21.034]     ...future.result$finished <- base::Sys.time()
[16:19:21.034]     ...future.result
[16:19:21.034] }
[16:19:21.036] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[16:19:21.036] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:21.081] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:21.081] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:19:21.081] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.081] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:21.082] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.082] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:21.124] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:21.125] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:21.168] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:21.169] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:21.169] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.169] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[16:19:21.170] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[16:19:21.170] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:21.170] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.170] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[16:19:21.171] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[16:19:21.171] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:21.171] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.171] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:21.172] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.172] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[16:19:21.172] MultisessionFuture started
[16:19:21.172] - Launch lazy future ... done
[16:19:21.172] run() for ‘MultisessionFuture’ ... done
[16:19:21.173] Created future:
[16:19:21.174] receiveMessageFromWorker() for ClusterFuture ...
[16:19:21.174] - Validating connection of MultisessionFuture
[16:19:21.174] - received message: FutureResult
[16:19:21.174] - Received FutureResult
[16:19:21.175] - Erased future from FutureRegistry
[16:19:21.175] result() for ClusterFuture ...
[16:19:21.175] - result already collected: FutureResult
[16:19:21.175] result() for ClusterFuture ... done
[16:19:21.175] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:21.173] MultisessionFuture:
[16:19:21.173] Label: ‘future_vapply-1’
[16:19:21.173] Expression:
[16:19:21.173] {
[16:19:21.173]     do.call(function(...) {
[16:19:21.173]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.173]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.173]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.173]             on.exit(options(oopts), add = TRUE)
[16:19:21.173]         }
[16:19:21.173]         {
[16:19:21.173]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.173]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.173]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.173]             })
[16:19:21.173]         }
[16:19:21.173]     }, args = future.call.arguments)
[16:19:21.173] }
[16:19:21.173] Lazy evaluation: FALSE
[16:19:21.173] Asynchronous evaluation: TRUE
[16:19:21.173] Local evaluation: TRUE
[16:19:21.173] Environment: R_GlobalEnv
[16:19:21.173] Capture standard output: TRUE
[16:19:21.173] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:21.173] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:21.173] Packages: 1 packages (‘future.apply’)
[16:19:21.173] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:21.173] Resolved: TRUE
[16:19:21.173] Value: <not collected>
[16:19:21.173] Conditions captured: <none>
[16:19:21.173] Early signaling: FALSE
[16:19:21.173] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:21.173] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.175] Chunk #1 of 2 ... DONE
[16:19:21.175] Chunk #2 of 2 ...
[16:19:21.176]  - Finding globals in 'X' for chunk #2 ...
[16:19:21.176] getGlobalsAndPackages() ...
[16:19:21.176] Searching for globals...
[16:19:21.176] 
[16:19:21.176] Searching for globals ... DONE
[16:19:21.176] - globals: [0] <none>
[16:19:21.176] getGlobalsAndPackages() ... DONE
[16:19:21.176]    + additional globals found: [n=0] 
[16:19:21.177]    + additional namespaces needed: [n=0] 
[16:19:21.177]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:21.177]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:21.177]  - seeds: <none>
[16:19:21.177]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.177] getGlobalsAndPackages() ...
[16:19:21.177] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.177] Resolving globals: FALSE
[16:19:21.177] Tweak future expression to call with '...' arguments ...
[16:19:21.177] {
[16:19:21.177]     do.call(function(...) {
[16:19:21.177]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.177]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.177]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.177]             on.exit(options(oopts), add = TRUE)
[16:19:21.177]         }
[16:19:21.177]         {
[16:19:21.177]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.177]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.177]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.177]             })
[16:19:21.177]         }
[16:19:21.177]     }, args = future.call.arguments)
[16:19:21.177] }
[16:19:21.178] Tweak future expression to call with '...' arguments ... DONE
[16:19:21.178] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.178] - packages: [1] ‘future.apply’
[16:19:21.179] getGlobalsAndPackages() ... DONE
[16:19:21.179] run() for ‘Future’ ...
[16:19:21.179] - state: ‘created’
[16:19:21.179] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:21.194] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:21.194]   - Field: ‘node’
[16:19:21.195]   - Field: ‘label’
[16:19:21.195]   - Field: ‘local’
[16:19:21.195]   - Field: ‘owner’
[16:19:21.195]   - Field: ‘envir’
[16:19:21.195]   - Field: ‘workers’
[16:19:21.195]   - Field: ‘packages’
[16:19:21.195]   - Field: ‘gc’
[16:19:21.195]   - Field: ‘conditions’
[16:19:21.195]   - Field: ‘persistent’
[16:19:21.195]   - Field: ‘expr’
[16:19:21.196]   - Field: ‘uuid’
[16:19:21.196]   - Field: ‘seed’
[16:19:21.196]   - Field: ‘version’
[16:19:21.196]   - Field: ‘result’
[16:19:21.196]   - Field: ‘asynchronous’
[16:19:21.196]   - Field: ‘calls’
[16:19:21.196]   - Field: ‘globals’
[16:19:21.196]   - Field: ‘stdout’
[16:19:21.196]   - Field: ‘earlySignal’
[16:19:21.196]   - Field: ‘lazy’
[16:19:21.196]   - Field: ‘state’
[16:19:21.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:21.197] - Launch lazy future ...
[16:19:21.197] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:21.197] Packages needed by future strategies (n = 0): <none>
[16:19:21.198] {
[16:19:21.198]     {
[16:19:21.198]         {
[16:19:21.198]             ...future.startTime <- base::Sys.time()
[16:19:21.198]             {
[16:19:21.198]                 {
[16:19:21.198]                   {
[16:19:21.198]                     {
[16:19:21.198]                       {
[16:19:21.198]                         base::local({
[16:19:21.198]                           has_future <- base::requireNamespace("future", 
[16:19:21.198]                             quietly = TRUE)
[16:19:21.198]                           if (has_future) {
[16:19:21.198]                             ns <- base::getNamespace("future")
[16:19:21.198]                             version <- ns[[".package"]][["version"]]
[16:19:21.198]                             if (is.null(version)) 
[16:19:21.198]                               version <- utils::packageVersion("future")
[16:19:21.198]                           }
[16:19:21.198]                           else {
[16:19:21.198]                             version <- NULL
[16:19:21.198]                           }
[16:19:21.198]                           if (!has_future || version < "1.8.0") {
[16:19:21.198]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:21.198]                               "", base::R.version$version.string), 
[16:19:21.198]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:21.198]                                 base::R.version$platform, 8 * 
[16:19:21.198]                                   base::.Machine$sizeof.pointer), 
[16:19:21.198]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:21.198]                                 "release", "version")], collapse = " "), 
[16:19:21.198]                               hostname = base::Sys.info()[["nodename"]])
[16:19:21.198]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:21.198]                               info)
[16:19:21.198]                             info <- base::paste(info, collapse = "; ")
[16:19:21.198]                             if (!has_future) {
[16:19:21.198]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:21.198]                                 info)
[16:19:21.198]                             }
[16:19:21.198]                             else {
[16:19:21.198]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:21.198]                                 info, version)
[16:19:21.198]                             }
[16:19:21.198]                             base::stop(msg)
[16:19:21.198]                           }
[16:19:21.198]                         })
[16:19:21.198]                       }
[16:19:21.198]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:21.198]                       base::options(mc.cores = 1L)
[16:19:21.198]                     }
[16:19:21.198]                     base::local({
[16:19:21.198]                       for (pkg in "future.apply") {
[16:19:21.198]                         base::loadNamespace(pkg)
[16:19:21.198]                         base::library(pkg, character.only = TRUE)
[16:19:21.198]                       }
[16:19:21.198]                     })
[16:19:21.198]                   }
[16:19:21.198]                   ...future.strategy.old <- future::plan("list")
[16:19:21.198]                   options(future.plan = NULL)
[16:19:21.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:21.198]                 }
[16:19:21.198]                 ...future.workdir <- getwd()
[16:19:21.198]             }
[16:19:21.198]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:21.198]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:21.198]         }
[16:19:21.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:21.198]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:21.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:21.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:21.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:21.198]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:21.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:21.198]             base::names(...future.oldOptions))
[16:19:21.198]     }
[16:19:21.198]     if (FALSE) {
[16:19:21.198]     }
[16:19:21.198]     else {
[16:19:21.198]         if (TRUE) {
[16:19:21.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:21.198]                 open = "w")
[16:19:21.198]         }
[16:19:21.198]         else {
[16:19:21.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:21.198]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:21.198]         }
[16:19:21.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:21.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:21.198]             base::sink(type = "output", split = FALSE)
[16:19:21.198]             base::close(...future.stdout)
[16:19:21.198]         }, add = TRUE)
[16:19:21.198]     }
[16:19:21.198]     ...future.frame <- base::sys.nframe()
[16:19:21.198]     ...future.conditions <- base::list()
[16:19:21.198]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:21.198]     if (FALSE) {
[16:19:21.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:21.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:21.198]     }
[16:19:21.198]     ...future.result <- base::tryCatch({
[16:19:21.198]         base::withCallingHandlers({
[16:19:21.198]             ...future.value <- base::withVisible(base::local({
[16:19:21.198]                 ...future.makeSendCondition <- base::local({
[16:19:21.198]                   sendCondition <- NULL
[16:19:21.198]                   function(frame = 1L) {
[16:19:21.198]                     if (is.function(sendCondition)) 
[16:19:21.198]                       return(sendCondition)
[16:19:21.198]                     ns <- getNamespace("parallel")
[16:19:21.198]                     if (exists("sendData", mode = "function", 
[16:19:21.198]                       envir = ns)) {
[16:19:21.198]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:21.198]                         envir = ns)
[16:19:21.198]                       envir <- sys.frame(frame)
[16:19:21.198]                       master <- NULL
[16:19:21.198]                       while (!identical(envir, .GlobalEnv) && 
[16:19:21.198]                         !identical(envir, emptyenv())) {
[16:19:21.198]                         if (exists("master", mode = "list", envir = envir, 
[16:19:21.198]                           inherits = FALSE)) {
[16:19:21.198]                           master <- get("master", mode = "list", 
[16:19:21.198]                             envir = envir, inherits = FALSE)
[16:19:21.198]                           if (inherits(master, c("SOCKnode", 
[16:19:21.198]                             "SOCK0node"))) {
[16:19:21.198]                             sendCondition <<- function(cond) {
[16:19:21.198]                               data <- list(type = "VALUE", value = cond, 
[16:19:21.198]                                 success = TRUE)
[16:19:21.198]                               parallel_sendData(master, data)
[16:19:21.198]                             }
[16:19:21.198]                             return(sendCondition)
[16:19:21.198]                           }
[16:19:21.198]                         }
[16:19:21.198]                         frame <- frame + 1L
[16:19:21.198]                         envir <- sys.frame(frame)
[16:19:21.198]                       }
[16:19:21.198]                     }
[16:19:21.198]                     sendCondition <<- function(cond) NULL
[16:19:21.198]                   }
[16:19:21.198]                 })
[16:19:21.198]                 withCallingHandlers({
[16:19:21.198]                   {
[16:19:21.198]                     do.call(function(...) {
[16:19:21.198]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.198]                       if (!identical(...future.globals.maxSize.org, 
[16:19:21.198]                         ...future.globals.maxSize)) {
[16:19:21.198]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.198]                         on.exit(options(oopts), add = TRUE)
[16:19:21.198]                       }
[16:19:21.198]                       {
[16:19:21.198]                         lapply(seq_along(...future.elements_ii), 
[16:19:21.198]                           FUN = function(jj) {
[16:19:21.198]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.198]                             ...future.FUN(...future.X_jj, ...)
[16:19:21.198]                           })
[16:19:21.198]                       }
[16:19:21.198]                     }, args = future.call.arguments)
[16:19:21.198]                   }
[16:19:21.198]                 }, immediateCondition = function(cond) {
[16:19:21.198]                   sendCondition <- ...future.makeSendCondition()
[16:19:21.198]                   sendCondition(cond)
[16:19:21.198]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.198]                   {
[16:19:21.198]                     inherits <- base::inherits
[16:19:21.198]                     invokeRestart <- base::invokeRestart
[16:19:21.198]                     is.null <- base::is.null
[16:19:21.198]                     muffled <- FALSE
[16:19:21.198]                     if (inherits(cond, "message")) {
[16:19:21.198]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:21.198]                       if (muffled) 
[16:19:21.198]                         invokeRestart("muffleMessage")
[16:19:21.198]                     }
[16:19:21.198]                     else if (inherits(cond, "warning")) {
[16:19:21.198]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:21.198]                       if (muffled) 
[16:19:21.198]                         invokeRestart("muffleWarning")
[16:19:21.198]                     }
[16:19:21.198]                     else if (inherits(cond, "condition")) {
[16:19:21.198]                       if (!is.null(pattern)) {
[16:19:21.198]                         computeRestarts <- base::computeRestarts
[16:19:21.198]                         grepl <- base::grepl
[16:19:21.198]                         restarts <- computeRestarts(cond)
[16:19:21.198]                         for (restart in restarts) {
[16:19:21.198]                           name <- restart$name
[16:19:21.198]                           if (is.null(name)) 
[16:19:21.198]                             next
[16:19:21.198]                           if (!grepl(pattern, name)) 
[16:19:21.198]                             next
[16:19:21.198]                           invokeRestart(restart)
[16:19:21.198]                           muffled <- TRUE
[16:19:21.198]                           break
[16:19:21.198]                         }
[16:19:21.198]                       }
[16:19:21.198]                     }
[16:19:21.198]                     invisible(muffled)
[16:19:21.198]                   }
[16:19:21.198]                   muffleCondition(cond)
[16:19:21.198]                 })
[16:19:21.198]             }))
[16:19:21.198]             future::FutureResult(value = ...future.value$value, 
[16:19:21.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.198]                   ...future.rng), globalenv = if (FALSE) 
[16:19:21.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:21.198]                     ...future.globalenv.names))
[16:19:21.198]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:21.198]         }, condition = base::local({
[16:19:21.198]             c <- base::c
[16:19:21.198]             inherits <- base::inherits
[16:19:21.198]             invokeRestart <- base::invokeRestart
[16:19:21.198]             length <- base::length
[16:19:21.198]             list <- base::list
[16:19:21.198]             seq.int <- base::seq.int
[16:19:21.198]             signalCondition <- base::signalCondition
[16:19:21.198]             sys.calls <- base::sys.calls
[16:19:21.198]             `[[` <- base::`[[`
[16:19:21.198]             `+` <- base::`+`
[16:19:21.198]             `<<-` <- base::`<<-`
[16:19:21.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:21.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:21.198]                   3L)]
[16:19:21.198]             }
[16:19:21.198]             function(cond) {
[16:19:21.198]                 is_error <- inherits(cond, "error")
[16:19:21.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:21.198]                   NULL)
[16:19:21.198]                 if (is_error) {
[16:19:21.198]                   sessionInformation <- function() {
[16:19:21.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:21.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:21.198]                       search = base::search(), system = base::Sys.info())
[16:19:21.198]                   }
[16:19:21.198]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:21.198]                     cond$call), session = sessionInformation(), 
[16:19:21.198]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:21.198]                   signalCondition(cond)
[16:19:21.198]                 }
[16:19:21.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:21.198]                 "immediateCondition"))) {
[16:19:21.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:21.198]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:21.198]                   if (TRUE && !signal) {
[16:19:21.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.198]                     {
[16:19:21.198]                       inherits <- base::inherits
[16:19:21.198]                       invokeRestart <- base::invokeRestart
[16:19:21.198]                       is.null <- base::is.null
[16:19:21.198]                       muffled <- FALSE
[16:19:21.198]                       if (inherits(cond, "message")) {
[16:19:21.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.198]                         if (muffled) 
[16:19:21.198]                           invokeRestart("muffleMessage")
[16:19:21.198]                       }
[16:19:21.198]                       else if (inherits(cond, "warning")) {
[16:19:21.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.198]                         if (muffled) 
[16:19:21.198]                           invokeRestart("muffleWarning")
[16:19:21.198]                       }
[16:19:21.198]                       else if (inherits(cond, "condition")) {
[16:19:21.198]                         if (!is.null(pattern)) {
[16:19:21.198]                           computeRestarts <- base::computeRestarts
[16:19:21.198]                           grepl <- base::grepl
[16:19:21.198]                           restarts <- computeRestarts(cond)
[16:19:21.198]                           for (restart in restarts) {
[16:19:21.198]                             name <- restart$name
[16:19:21.198]                             if (is.null(name)) 
[16:19:21.198]                               next
[16:19:21.198]                             if (!grepl(pattern, name)) 
[16:19:21.198]                               next
[16:19:21.198]                             invokeRestart(restart)
[16:19:21.198]                             muffled <- TRUE
[16:19:21.198]                             break
[16:19:21.198]                           }
[16:19:21.198]                         }
[16:19:21.198]                       }
[16:19:21.198]                       invisible(muffled)
[16:19:21.198]                     }
[16:19:21.198]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.198]                   }
[16:19:21.198]                 }
[16:19:21.198]                 else {
[16:19:21.198]                   if (TRUE) {
[16:19:21.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.198]                     {
[16:19:21.198]                       inherits <- base::inherits
[16:19:21.198]                       invokeRestart <- base::invokeRestart
[16:19:21.198]                       is.null <- base::is.null
[16:19:21.198]                       muffled <- FALSE
[16:19:21.198]                       if (inherits(cond, "message")) {
[16:19:21.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.198]                         if (muffled) 
[16:19:21.198]                           invokeRestart("muffleMessage")
[16:19:21.198]                       }
[16:19:21.198]                       else if (inherits(cond, "warning")) {
[16:19:21.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.198]                         if (muffled) 
[16:19:21.198]                           invokeRestart("muffleWarning")
[16:19:21.198]                       }
[16:19:21.198]                       else if (inherits(cond, "condition")) {
[16:19:21.198]                         if (!is.null(pattern)) {
[16:19:21.198]                           computeRestarts <- base::computeRestarts
[16:19:21.198]                           grepl <- base::grepl
[16:19:21.198]                           restarts <- computeRestarts(cond)
[16:19:21.198]                           for (restart in restarts) {
[16:19:21.198]                             name <- restart$name
[16:19:21.198]                             if (is.null(name)) 
[16:19:21.198]                               next
[16:19:21.198]                             if (!grepl(pattern, name)) 
[16:19:21.198]                               next
[16:19:21.198]                             invokeRestart(restart)
[16:19:21.198]                             muffled <- TRUE
[16:19:21.198]                             break
[16:19:21.198]                           }
[16:19:21.198]                         }
[16:19:21.198]                       }
[16:19:21.198]                       invisible(muffled)
[16:19:21.198]                     }
[16:19:21.198]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.198]                   }
[16:19:21.198]                 }
[16:19:21.198]             }
[16:19:21.198]         }))
[16:19:21.198]     }, error = function(ex) {
[16:19:21.198]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:21.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.198]                 ...future.rng), started = ...future.startTime, 
[16:19:21.198]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:21.198]             version = "1.8"), class = "FutureResult")
[16:19:21.198]     }, finally = {
[16:19:21.198]         if (!identical(...future.workdir, getwd())) 
[16:19:21.198]             setwd(...future.workdir)
[16:19:21.198]         {
[16:19:21.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:21.198]                 ...future.oldOptions$nwarnings <- NULL
[16:19:21.198]             }
[16:19:21.198]             base::options(...future.oldOptions)
[16:19:21.198]             if (.Platform$OS.type == "windows") {
[16:19:21.198]                 old_names <- names(...future.oldEnvVars)
[16:19:21.198]                 envs <- base::Sys.getenv()
[16:19:21.198]                 names <- names(envs)
[16:19:21.198]                 common <- intersect(names, old_names)
[16:19:21.198]                 added <- setdiff(names, old_names)
[16:19:21.198]                 removed <- setdiff(old_names, names)
[16:19:21.198]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:21.198]                   envs[common]]
[16:19:21.198]                 NAMES <- toupper(changed)
[16:19:21.198]                 args <- list()
[16:19:21.198]                 for (kk in seq_along(NAMES)) {
[16:19:21.198]                   name <- changed[[kk]]
[16:19:21.198]                   NAME <- NAMES[[kk]]
[16:19:21.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.198]                     next
[16:19:21.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.198]                 }
[16:19:21.198]                 NAMES <- toupper(added)
[16:19:21.198]                 for (kk in seq_along(NAMES)) {
[16:19:21.198]                   name <- added[[kk]]
[16:19:21.198]                   NAME <- NAMES[[kk]]
[16:19:21.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.198]                     next
[16:19:21.198]                   args[[name]] <- ""
[16:19:21.198]                 }
[16:19:21.198]                 NAMES <- toupper(removed)
[16:19:21.198]                 for (kk in seq_along(NAMES)) {
[16:19:21.198]                   name <- removed[[kk]]
[16:19:21.198]                   NAME <- NAMES[[kk]]
[16:19:21.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.198]                     next
[16:19:21.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.198]                 }
[16:19:21.198]                 if (length(args) > 0) 
[16:19:21.198]                   base::do.call(base::Sys.setenv, args = args)
[16:19:21.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:21.198]             }
[16:19:21.198]             else {
[16:19:21.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:21.198]             }
[16:19:21.198]             {
[16:19:21.198]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:21.198]                   0L) {
[16:19:21.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:21.198]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:21.198]                   base::options(opts)
[16:19:21.198]                 }
[16:19:21.198]                 {
[16:19:21.198]                   {
[16:19:21.198]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:21.198]                     NULL
[16:19:21.198]                   }
[16:19:21.198]                   options(future.plan = NULL)
[16:19:21.198]                   if (is.na(NA_character_)) 
[16:19:21.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:21.198]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:21.198]                     .init = FALSE)
[16:19:21.198]                 }
[16:19:21.198]             }
[16:19:21.198]         }
[16:19:21.198]     })
[16:19:21.198]     if (TRUE) {
[16:19:21.198]         base::sink(type = "output", split = FALSE)
[16:19:21.198]         if (TRUE) {
[16:19:21.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:21.198]         }
[16:19:21.198]         else {
[16:19:21.198]             ...future.result["stdout"] <- base::list(NULL)
[16:19:21.198]         }
[16:19:21.198]         base::close(...future.stdout)
[16:19:21.198]         ...future.stdout <- NULL
[16:19:21.198]     }
[16:19:21.198]     ...future.result$conditions <- ...future.conditions
[16:19:21.198]     ...future.result$finished <- base::Sys.time()
[16:19:21.198]     ...future.result
[16:19:21.198] }
[16:19:21.200] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[16:19:21.201] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:21.245] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:21.245] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:19:21.245] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.245] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:21.246] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.246] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:21.289] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:21.289] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:21.332] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:21.333] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:21.333] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.333] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[16:19:21.334] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[16:19:21.334] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:21.334] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.334] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #1 ...
[16:19:21.335] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #1 ... DONE
[16:19:21.335] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:21.335] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.335] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:21.335] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.336] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[16:19:21.336] MultisessionFuture started
[16:19:21.336] - Launch lazy future ... done
[16:19:21.336] run() for ‘MultisessionFuture’ ... done
[16:19:21.336] Created future:
[16:19:21.336] MultisessionFuture:
[16:19:21.336] Label: ‘future_vapply-2’
[16:19:21.336] Expression:
[16:19:21.336] {
[16:19:21.336]     do.call(function(...) {
[16:19:21.336]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.336]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.336]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.336]             on.exit(options(oopts), add = TRUE)
[16:19:21.336]         }
[16:19:21.336]         {
[16:19:21.336]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.336]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.336]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.336]             })
[16:19:21.336]         }
[16:19:21.336]     }, args = future.call.arguments)
[16:19:21.336] }
[16:19:21.336] Lazy evaluation: FALSE
[16:19:21.336] Asynchronous evaluation: TRUE
[16:19:21.336] Local evaluation: TRUE
[16:19:21.336] Environment: R_GlobalEnv
[16:19:21.336] Capture standard output: TRUE
[16:19:21.336] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:21.336] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:21.336] Packages: 1 packages (‘future.apply’)
[16:19:21.336] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:21.336] Resolved: FALSE
[16:19:21.336] Value: <not collected>
[16:19:21.336] Conditions captured: <none>
[16:19:21.336] Early signaling: FALSE
[16:19:21.336] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:21.336] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.348] Chunk #2 of 2 ... DONE
[16:19:21.348] Launching 2 futures (chunks) ... DONE
[16:19:21.348] Resolving 2 futures (chunks) ...
[16:19:21.348] resolve() on list ...
[16:19:21.349]  recursive: 0
[16:19:21.349]  length: 2
[16:19:21.349] 
[16:19:21.349] Future #1
[16:19:21.349] result() for ClusterFuture ...
[16:19:21.349] - result already collected: FutureResult
[16:19:21.349] result() for ClusterFuture ... done
[16:19:21.349] result() for ClusterFuture ...
[16:19:21.349] - result already collected: FutureResult
[16:19:21.349] result() for ClusterFuture ... done
[16:19:21.349] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:21.350] - nx: 2
[16:19:21.350] - relay: TRUE
[16:19:21.350] - stdout: TRUE
[16:19:21.350] - signal: TRUE
[16:19:21.350] - resignal: FALSE
[16:19:21.350] - force: TRUE
[16:19:21.350] - relayed: [n=2] FALSE, FALSE
[16:19:21.350] - queued futures: [n=2] FALSE, FALSE
[16:19:21.350]  - until=1
[16:19:21.350]  - relaying element #1
[16:19:21.350] result() for ClusterFuture ...
[16:19:21.350] - result already collected: FutureResult
[16:19:21.351] result() for ClusterFuture ... done
[16:19:21.351] result() for ClusterFuture ...
[16:19:21.351] - result already collected: FutureResult
[16:19:21.351] result() for ClusterFuture ... done
[16:19:21.351] result() for ClusterFuture ...
[16:19:21.351] - result already collected: FutureResult
[16:19:21.351] result() for ClusterFuture ... done
[16:19:21.351] result() for ClusterFuture ...
[16:19:21.351] - result already collected: FutureResult
[16:19:21.351] result() for ClusterFuture ... done
[16:19:21.351] - relayed: [n=2] TRUE, FALSE
[16:19:21.352] - queued futures: [n=2] TRUE, FALSE
[16:19:21.352] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:21.352]  length: 1 (resolved future 1)
[16:19:21.378] receiveMessageFromWorker() for ClusterFuture ...
[16:19:21.378] - Validating connection of MultisessionFuture
[16:19:21.378] - received message: FutureResult
[16:19:21.378] - Received FutureResult
[16:19:21.379] - Erased future from FutureRegistry
[16:19:21.379] result() for ClusterFuture ...
[16:19:21.379] - result already collected: FutureResult
[16:19:21.379] result() for ClusterFuture ... done
[16:19:21.379] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:21.379] Future #2
[16:19:21.379] result() for ClusterFuture ...
[16:19:21.379] - result already collected: FutureResult
[16:19:21.379] result() for ClusterFuture ... done
[16:19:21.379] result() for ClusterFuture ...
[16:19:21.379] - result already collected: FutureResult
[16:19:21.380] result() for ClusterFuture ... done
[16:19:21.380] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:21.380] - nx: 2
[16:19:21.380] - relay: TRUE
[16:19:21.380] - stdout: TRUE
[16:19:21.380] - signal: TRUE
[16:19:21.380] - resignal: FALSE
[16:19:21.380] - force: TRUE
[16:19:21.380] - relayed: [n=2] TRUE, FALSE
[16:19:21.380] - queued futures: [n=2] TRUE, FALSE
[16:19:21.380]  - until=2
[16:19:21.381]  - relaying element #2
[16:19:21.381] result() for ClusterFuture ...
[16:19:21.381] - result already collected: FutureResult
[16:19:21.381] result() for ClusterFuture ... done
[16:19:21.381] result() for ClusterFuture ...
[16:19:21.381] - result already collected: FutureResult
[16:19:21.381] result() for ClusterFuture ... done
[16:19:21.381] result() for ClusterFuture ...
[16:19:21.381] - result already collected: FutureResult
[16:19:21.381] result() for ClusterFuture ... done
[16:19:21.381] result() for ClusterFuture ...
[16:19:21.382] - result already collected: FutureResult
[16:19:21.382] result() for ClusterFuture ... done
[16:19:21.382] - relayed: [n=2] TRUE, TRUE
[16:19:21.382] - queued futures: [n=2] TRUE, TRUE
[16:19:21.382] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:21.382]  length: 0 (resolved future 2)
[16:19:21.382] Relaying remaining futures
[16:19:21.382] signalConditionsASAP(NULL, pos=0) ...
[16:19:21.382] - nx: 2
[16:19:21.382] - relay: TRUE
[16:19:21.382] - stdout: TRUE
[16:19:21.382] - signal: TRUE
[16:19:21.383] - resignal: FALSE
[16:19:21.383] - force: TRUE
[16:19:21.383] - relayed: [n=2] TRUE, TRUE
[16:19:21.383] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:21.383] - relayed: [n=2] TRUE, TRUE
[16:19:21.383] - queued futures: [n=2] TRUE, TRUE
[16:19:21.383] signalConditionsASAP(NULL, pos=0) ... done
[16:19:21.383] resolve() on list ... DONE
[16:19:21.383] result() for ClusterFuture ...
[16:19:21.383] - result already collected: FutureResult
[16:19:21.383] result() for ClusterFuture ... done
[16:19:21.384] result() for ClusterFuture ...
[16:19:21.384] - result already collected: FutureResult
[16:19:21.384] result() for ClusterFuture ... done
[16:19:21.384] result() for ClusterFuture ...
[16:19:21.384] - result already collected: FutureResult
[16:19:21.384] result() for ClusterFuture ... done
[16:19:21.384] result() for ClusterFuture ...
[16:19:21.384] - result already collected: FutureResult
[16:19:21.384] result() for ClusterFuture ... done
[16:19:21.384]  - Number of value chunks collected: 2
[16:19:21.384] Resolving 2 futures (chunks) ... DONE
[16:19:21.385] Reducing values from 2 chunks ...
[16:19:21.385]  - Number of values collected after concatenation: 11
[16:19:21.385]  - Number of values expected: 11
[16:19:21.385] Reducing values from 2 chunks ... DONE
[16:19:21.385] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:19:21.386] future_lapply() ...
[16:19:21.391] Number of chunks: 2
[16:19:21.391] getGlobalsAndPackagesXApply() ...
[16:19:21.391]  - future.globals: TRUE
[16:19:21.391] getGlobalsAndPackages() ...
[16:19:21.392] Searching for globals...
[16:19:21.394] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:21.395] Searching for globals ... DONE
[16:19:21.395] Resolving globals: FALSE
[16:19:21.395] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:19:21.396] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:21.396] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:21.396] - packages: [1] ‘future.apply’
[16:19:21.396] getGlobalsAndPackages() ... DONE
[16:19:21.396]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:21.396]  - needed namespaces: [n=1] ‘future.apply’
[16:19:21.397] Finding globals ... DONE
[16:19:21.397]  - use_args: TRUE
[16:19:21.397]  - Getting '...' globals ...
[16:19:21.397] resolve() on list ...
[16:19:21.397]  recursive: 0
[16:19:21.397]  length: 1
[16:19:21.397]  elements: ‘...’
[16:19:21.397]  length: 0 (resolved future 1)
[16:19:21.398] resolve() on list ... DONE
[16:19:21.398]    - '...' content: [n=0] 
[16:19:21.398] List of 1
[16:19:21.398]  $ ...: list()
[16:19:21.398]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:21.398]  - attr(*, "where")=List of 1
[16:19:21.398]   ..$ ...:<environment: 0x5619a0fb12e8> 
[16:19:21.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:21.398]  - attr(*, "resolved")= logi TRUE
[16:19:21.398]  - attr(*, "total_size")= num NA
[16:19:21.400]  - Getting '...' globals ... DONE
[16:19:21.400] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:21.401] List of 8
[16:19:21.401]  $ ...future.FUN:function (x, ...)  
[16:19:21.401]  $ x_FUN        :function (x)  
[16:19:21.401]  $ times        : int 1
[16:19:21.401]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:21.401]  $ stop_if_not  :function (...)  
[16:19:21.401]  $ dim          : NULL
[16:19:21.401]  $ valid_types  : chr [1:2] "logical" "integer"
[16:19:21.401]  $ ...          : list()
[16:19:21.401]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:21.401]  - attr(*, "where")=List of 8
[16:19:21.401]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:21.401]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:21.401]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:21.401]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:21.401]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:21.401]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:21.401]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:21.401]   ..$ ...          :<environment: 0x5619a0fb12e8> 
[16:19:21.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:21.401]  - attr(*, "resolved")= logi FALSE
[16:19:21.401]  - attr(*, "total_size")= num 94264
[16:19:21.406] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:21.406] getGlobalsAndPackagesXApply() ... DONE
[16:19:21.406] Number of futures (= number of chunks): 2
[16:19:21.406] Launching 2 futures (chunks) ...
[16:19:21.406] Chunk #1 of 2 ...
[16:19:21.406]  - Finding globals in 'X' for chunk #1 ...
[16:19:21.407] getGlobalsAndPackages() ...
[16:19:21.407] Searching for globals...
[16:19:21.407] 
[16:19:21.407] Searching for globals ... DONE
[16:19:21.407] - globals: [0] <none>
[16:19:21.407] getGlobalsAndPackages() ... DONE
[16:19:21.407]    + additional globals found: [n=0] 
[16:19:21.407]    + additional namespaces needed: [n=0] 
[16:19:21.407]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:21.408]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:21.408]  - seeds: <none>
[16:19:21.408]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.408] getGlobalsAndPackages() ...
[16:19:21.408] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.408] Resolving globals: FALSE
[16:19:21.408] Tweak future expression to call with '...' arguments ...
[16:19:21.408] {
[16:19:21.408]     do.call(function(...) {
[16:19:21.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.408]             on.exit(options(oopts), add = TRUE)
[16:19:21.408]         }
[16:19:21.408]         {
[16:19:21.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.408]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.408]             })
[16:19:21.408]         }
[16:19:21.408]     }, args = future.call.arguments)
[16:19:21.408] }
[16:19:21.409] Tweak future expression to call with '...' arguments ... DONE
[16:19:21.409] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.409] - packages: [1] ‘future.apply’
[16:19:21.409] getGlobalsAndPackages() ... DONE
[16:19:21.410] run() for ‘Future’ ...
[16:19:21.410] - state: ‘created’
[16:19:21.410] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:21.424] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:21.424]   - Field: ‘node’
[16:19:21.424]   - Field: ‘label’
[16:19:21.424]   - Field: ‘local’
[16:19:21.424]   - Field: ‘owner’
[16:19:21.424]   - Field: ‘envir’
[16:19:21.424]   - Field: ‘workers’
[16:19:21.425]   - Field: ‘packages’
[16:19:21.425]   - Field: ‘gc’
[16:19:21.425]   - Field: ‘conditions’
[16:19:21.425]   - Field: ‘persistent’
[16:19:21.425]   - Field: ‘expr’
[16:19:21.425]   - Field: ‘uuid’
[16:19:21.425]   - Field: ‘seed’
[16:19:21.425]   - Field: ‘version’
[16:19:21.425]   - Field: ‘result’
[16:19:21.425]   - Field: ‘asynchronous’
[16:19:21.425]   - Field: ‘calls’
[16:19:21.426]   - Field: ‘globals’
[16:19:21.426]   - Field: ‘stdout’
[16:19:21.426]   - Field: ‘earlySignal’
[16:19:21.426]   - Field: ‘lazy’
[16:19:21.426]   - Field: ‘state’
[16:19:21.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:21.426] - Launch lazy future ...
[16:19:21.426] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:21.426] Packages needed by future strategies (n = 0): <none>
[16:19:21.427] {
[16:19:21.427]     {
[16:19:21.427]         {
[16:19:21.427]             ...future.startTime <- base::Sys.time()
[16:19:21.427]             {
[16:19:21.427]                 {
[16:19:21.427]                   {
[16:19:21.427]                     {
[16:19:21.427]                       {
[16:19:21.427]                         base::local({
[16:19:21.427]                           has_future <- base::requireNamespace("future", 
[16:19:21.427]                             quietly = TRUE)
[16:19:21.427]                           if (has_future) {
[16:19:21.427]                             ns <- base::getNamespace("future")
[16:19:21.427]                             version <- ns[[".package"]][["version"]]
[16:19:21.427]                             if (is.null(version)) 
[16:19:21.427]                               version <- utils::packageVersion("future")
[16:19:21.427]                           }
[16:19:21.427]                           else {
[16:19:21.427]                             version <- NULL
[16:19:21.427]                           }
[16:19:21.427]                           if (!has_future || version < "1.8.0") {
[16:19:21.427]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:21.427]                               "", base::R.version$version.string), 
[16:19:21.427]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:21.427]                                 base::R.version$platform, 8 * 
[16:19:21.427]                                   base::.Machine$sizeof.pointer), 
[16:19:21.427]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:21.427]                                 "release", "version")], collapse = " "), 
[16:19:21.427]                               hostname = base::Sys.info()[["nodename"]])
[16:19:21.427]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:21.427]                               info)
[16:19:21.427]                             info <- base::paste(info, collapse = "; ")
[16:19:21.427]                             if (!has_future) {
[16:19:21.427]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:21.427]                                 info)
[16:19:21.427]                             }
[16:19:21.427]                             else {
[16:19:21.427]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:21.427]                                 info, version)
[16:19:21.427]                             }
[16:19:21.427]                             base::stop(msg)
[16:19:21.427]                           }
[16:19:21.427]                         })
[16:19:21.427]                       }
[16:19:21.427]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:21.427]                       base::options(mc.cores = 1L)
[16:19:21.427]                     }
[16:19:21.427]                     base::local({
[16:19:21.427]                       for (pkg in "future.apply") {
[16:19:21.427]                         base::loadNamespace(pkg)
[16:19:21.427]                         base::library(pkg, character.only = TRUE)
[16:19:21.427]                       }
[16:19:21.427]                     })
[16:19:21.427]                   }
[16:19:21.427]                   ...future.strategy.old <- future::plan("list")
[16:19:21.427]                   options(future.plan = NULL)
[16:19:21.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:21.427]                 }
[16:19:21.427]                 ...future.workdir <- getwd()
[16:19:21.427]             }
[16:19:21.427]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:21.427]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:21.427]         }
[16:19:21.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:21.427]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:21.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:21.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:21.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:21.427]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:21.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:21.427]             base::names(...future.oldOptions))
[16:19:21.427]     }
[16:19:21.427]     if (FALSE) {
[16:19:21.427]     }
[16:19:21.427]     else {
[16:19:21.427]         if (TRUE) {
[16:19:21.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:21.427]                 open = "w")
[16:19:21.427]         }
[16:19:21.427]         else {
[16:19:21.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:21.427]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:21.427]         }
[16:19:21.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:21.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:21.427]             base::sink(type = "output", split = FALSE)
[16:19:21.427]             base::close(...future.stdout)
[16:19:21.427]         }, add = TRUE)
[16:19:21.427]     }
[16:19:21.427]     ...future.frame <- base::sys.nframe()
[16:19:21.427]     ...future.conditions <- base::list()
[16:19:21.427]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:21.427]     if (FALSE) {
[16:19:21.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:21.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:21.427]     }
[16:19:21.427]     ...future.result <- base::tryCatch({
[16:19:21.427]         base::withCallingHandlers({
[16:19:21.427]             ...future.value <- base::withVisible(base::local({
[16:19:21.427]                 ...future.makeSendCondition <- base::local({
[16:19:21.427]                   sendCondition <- NULL
[16:19:21.427]                   function(frame = 1L) {
[16:19:21.427]                     if (is.function(sendCondition)) 
[16:19:21.427]                       return(sendCondition)
[16:19:21.427]                     ns <- getNamespace("parallel")
[16:19:21.427]                     if (exists("sendData", mode = "function", 
[16:19:21.427]                       envir = ns)) {
[16:19:21.427]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:21.427]                         envir = ns)
[16:19:21.427]                       envir <- sys.frame(frame)
[16:19:21.427]                       master <- NULL
[16:19:21.427]                       while (!identical(envir, .GlobalEnv) && 
[16:19:21.427]                         !identical(envir, emptyenv())) {
[16:19:21.427]                         if (exists("master", mode = "list", envir = envir, 
[16:19:21.427]                           inherits = FALSE)) {
[16:19:21.427]                           master <- get("master", mode = "list", 
[16:19:21.427]                             envir = envir, inherits = FALSE)
[16:19:21.427]                           if (inherits(master, c("SOCKnode", 
[16:19:21.427]                             "SOCK0node"))) {
[16:19:21.427]                             sendCondition <<- function(cond) {
[16:19:21.427]                               data <- list(type = "VALUE", value = cond, 
[16:19:21.427]                                 success = TRUE)
[16:19:21.427]                               parallel_sendData(master, data)
[16:19:21.427]                             }
[16:19:21.427]                             return(sendCondition)
[16:19:21.427]                           }
[16:19:21.427]                         }
[16:19:21.427]                         frame <- frame + 1L
[16:19:21.427]                         envir <- sys.frame(frame)
[16:19:21.427]                       }
[16:19:21.427]                     }
[16:19:21.427]                     sendCondition <<- function(cond) NULL
[16:19:21.427]                   }
[16:19:21.427]                 })
[16:19:21.427]                 withCallingHandlers({
[16:19:21.427]                   {
[16:19:21.427]                     do.call(function(...) {
[16:19:21.427]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.427]                       if (!identical(...future.globals.maxSize.org, 
[16:19:21.427]                         ...future.globals.maxSize)) {
[16:19:21.427]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.427]                         on.exit(options(oopts), add = TRUE)
[16:19:21.427]                       }
[16:19:21.427]                       {
[16:19:21.427]                         lapply(seq_along(...future.elements_ii), 
[16:19:21.427]                           FUN = function(jj) {
[16:19:21.427]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.427]                             ...future.FUN(...future.X_jj, ...)
[16:19:21.427]                           })
[16:19:21.427]                       }
[16:19:21.427]                     }, args = future.call.arguments)
[16:19:21.427]                   }
[16:19:21.427]                 }, immediateCondition = function(cond) {
[16:19:21.427]                   sendCondition <- ...future.makeSendCondition()
[16:19:21.427]                   sendCondition(cond)
[16:19:21.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.427]                   {
[16:19:21.427]                     inherits <- base::inherits
[16:19:21.427]                     invokeRestart <- base::invokeRestart
[16:19:21.427]                     is.null <- base::is.null
[16:19:21.427]                     muffled <- FALSE
[16:19:21.427]                     if (inherits(cond, "message")) {
[16:19:21.427]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:21.427]                       if (muffled) 
[16:19:21.427]                         invokeRestart("muffleMessage")
[16:19:21.427]                     }
[16:19:21.427]                     else if (inherits(cond, "warning")) {
[16:19:21.427]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:21.427]                       if (muffled) 
[16:19:21.427]                         invokeRestart("muffleWarning")
[16:19:21.427]                     }
[16:19:21.427]                     else if (inherits(cond, "condition")) {
[16:19:21.427]                       if (!is.null(pattern)) {
[16:19:21.427]                         computeRestarts <- base::computeRestarts
[16:19:21.427]                         grepl <- base::grepl
[16:19:21.427]                         restarts <- computeRestarts(cond)
[16:19:21.427]                         for (restart in restarts) {
[16:19:21.427]                           name <- restart$name
[16:19:21.427]                           if (is.null(name)) 
[16:19:21.427]                             next
[16:19:21.427]                           if (!grepl(pattern, name)) 
[16:19:21.427]                             next
[16:19:21.427]                           invokeRestart(restart)
[16:19:21.427]                           muffled <- TRUE
[16:19:21.427]                           break
[16:19:21.427]                         }
[16:19:21.427]                       }
[16:19:21.427]                     }
[16:19:21.427]                     invisible(muffled)
[16:19:21.427]                   }
[16:19:21.427]                   muffleCondition(cond)
[16:19:21.427]                 })
[16:19:21.427]             }))
[16:19:21.427]             future::FutureResult(value = ...future.value$value, 
[16:19:21.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.427]                   ...future.rng), globalenv = if (FALSE) 
[16:19:21.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:21.427]                     ...future.globalenv.names))
[16:19:21.427]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:21.427]         }, condition = base::local({
[16:19:21.427]             c <- base::c
[16:19:21.427]             inherits <- base::inherits
[16:19:21.427]             invokeRestart <- base::invokeRestart
[16:19:21.427]             length <- base::length
[16:19:21.427]             list <- base::list
[16:19:21.427]             seq.int <- base::seq.int
[16:19:21.427]             signalCondition <- base::signalCondition
[16:19:21.427]             sys.calls <- base::sys.calls
[16:19:21.427]             `[[` <- base::`[[`
[16:19:21.427]             `+` <- base::`+`
[16:19:21.427]             `<<-` <- base::`<<-`
[16:19:21.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:21.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:21.427]                   3L)]
[16:19:21.427]             }
[16:19:21.427]             function(cond) {
[16:19:21.427]                 is_error <- inherits(cond, "error")
[16:19:21.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:21.427]                   NULL)
[16:19:21.427]                 if (is_error) {
[16:19:21.427]                   sessionInformation <- function() {
[16:19:21.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:21.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:21.427]                       search = base::search(), system = base::Sys.info())
[16:19:21.427]                   }
[16:19:21.427]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:21.427]                     cond$call), session = sessionInformation(), 
[16:19:21.427]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:21.427]                   signalCondition(cond)
[16:19:21.427]                 }
[16:19:21.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:21.427]                 "immediateCondition"))) {
[16:19:21.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:21.427]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:21.427]                   if (TRUE && !signal) {
[16:19:21.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.427]                     {
[16:19:21.427]                       inherits <- base::inherits
[16:19:21.427]                       invokeRestart <- base::invokeRestart
[16:19:21.427]                       is.null <- base::is.null
[16:19:21.427]                       muffled <- FALSE
[16:19:21.427]                       if (inherits(cond, "message")) {
[16:19:21.427]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.427]                         if (muffled) 
[16:19:21.427]                           invokeRestart("muffleMessage")
[16:19:21.427]                       }
[16:19:21.427]                       else if (inherits(cond, "warning")) {
[16:19:21.427]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.427]                         if (muffled) 
[16:19:21.427]                           invokeRestart("muffleWarning")
[16:19:21.427]                       }
[16:19:21.427]                       else if (inherits(cond, "condition")) {
[16:19:21.427]                         if (!is.null(pattern)) {
[16:19:21.427]                           computeRestarts <- base::computeRestarts
[16:19:21.427]                           grepl <- base::grepl
[16:19:21.427]                           restarts <- computeRestarts(cond)
[16:19:21.427]                           for (restart in restarts) {
[16:19:21.427]                             name <- restart$name
[16:19:21.427]                             if (is.null(name)) 
[16:19:21.427]                               next
[16:19:21.427]                             if (!grepl(pattern, name)) 
[16:19:21.427]                               next
[16:19:21.427]                             invokeRestart(restart)
[16:19:21.427]                             muffled <- TRUE
[16:19:21.427]                             break
[16:19:21.427]                           }
[16:19:21.427]                         }
[16:19:21.427]                       }
[16:19:21.427]                       invisible(muffled)
[16:19:21.427]                     }
[16:19:21.427]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.427]                   }
[16:19:21.427]                 }
[16:19:21.427]                 else {
[16:19:21.427]                   if (TRUE) {
[16:19:21.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.427]                     {
[16:19:21.427]                       inherits <- base::inherits
[16:19:21.427]                       invokeRestart <- base::invokeRestart
[16:19:21.427]                       is.null <- base::is.null
[16:19:21.427]                       muffled <- FALSE
[16:19:21.427]                       if (inherits(cond, "message")) {
[16:19:21.427]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.427]                         if (muffled) 
[16:19:21.427]                           invokeRestart("muffleMessage")
[16:19:21.427]                       }
[16:19:21.427]                       else if (inherits(cond, "warning")) {
[16:19:21.427]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.427]                         if (muffled) 
[16:19:21.427]                           invokeRestart("muffleWarning")
[16:19:21.427]                       }
[16:19:21.427]                       else if (inherits(cond, "condition")) {
[16:19:21.427]                         if (!is.null(pattern)) {
[16:19:21.427]                           computeRestarts <- base::computeRestarts
[16:19:21.427]                           grepl <- base::grepl
[16:19:21.427]                           restarts <- computeRestarts(cond)
[16:19:21.427]                           for (restart in restarts) {
[16:19:21.427]                             name <- restart$name
[16:19:21.427]                             if (is.null(name)) 
[16:19:21.427]                               next
[16:19:21.427]                             if (!grepl(pattern, name)) 
[16:19:21.427]                               next
[16:19:21.427]                             invokeRestart(restart)
[16:19:21.427]                             muffled <- TRUE
[16:19:21.427]                             break
[16:19:21.427]                           }
[16:19:21.427]                         }
[16:19:21.427]                       }
[16:19:21.427]                       invisible(muffled)
[16:19:21.427]                     }
[16:19:21.427]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.427]                   }
[16:19:21.427]                 }
[16:19:21.427]             }
[16:19:21.427]         }))
[16:19:21.427]     }, error = function(ex) {
[16:19:21.427]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:21.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.427]                 ...future.rng), started = ...future.startTime, 
[16:19:21.427]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:21.427]             version = "1.8"), class = "FutureResult")
[16:19:21.427]     }, finally = {
[16:19:21.427]         if (!identical(...future.workdir, getwd())) 
[16:19:21.427]             setwd(...future.workdir)
[16:19:21.427]         {
[16:19:21.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:21.427]                 ...future.oldOptions$nwarnings <- NULL
[16:19:21.427]             }
[16:19:21.427]             base::options(...future.oldOptions)
[16:19:21.427]             if (.Platform$OS.type == "windows") {
[16:19:21.427]                 old_names <- names(...future.oldEnvVars)
[16:19:21.427]                 envs <- base::Sys.getenv()
[16:19:21.427]                 names <- names(envs)
[16:19:21.427]                 common <- intersect(names, old_names)
[16:19:21.427]                 added <- setdiff(names, old_names)
[16:19:21.427]                 removed <- setdiff(old_names, names)
[16:19:21.427]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:21.427]                   envs[common]]
[16:19:21.427]                 NAMES <- toupper(changed)
[16:19:21.427]                 args <- list()
[16:19:21.427]                 for (kk in seq_along(NAMES)) {
[16:19:21.427]                   name <- changed[[kk]]
[16:19:21.427]                   NAME <- NAMES[[kk]]
[16:19:21.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.427]                     next
[16:19:21.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.427]                 }
[16:19:21.427]                 NAMES <- toupper(added)
[16:19:21.427]                 for (kk in seq_along(NAMES)) {
[16:19:21.427]                   name <- added[[kk]]
[16:19:21.427]                   NAME <- NAMES[[kk]]
[16:19:21.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.427]                     next
[16:19:21.427]                   args[[name]] <- ""
[16:19:21.427]                 }
[16:19:21.427]                 NAMES <- toupper(removed)
[16:19:21.427]                 for (kk in seq_along(NAMES)) {
[16:19:21.427]                   name <- removed[[kk]]
[16:19:21.427]                   NAME <- NAMES[[kk]]
[16:19:21.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.427]                     next
[16:19:21.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.427]                 }
[16:19:21.427]                 if (length(args) > 0) 
[16:19:21.427]                   base::do.call(base::Sys.setenv, args = args)
[16:19:21.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:21.427]             }
[16:19:21.427]             else {
[16:19:21.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:21.427]             }
[16:19:21.427]             {
[16:19:21.427]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:21.427]                   0L) {
[16:19:21.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:21.427]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:21.427]                   base::options(opts)
[16:19:21.427]                 }
[16:19:21.427]                 {
[16:19:21.427]                   {
[16:19:21.427]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:21.427]                     NULL
[16:19:21.427]                   }
[16:19:21.427]                   options(future.plan = NULL)
[16:19:21.427]                   if (is.na(NA_character_)) 
[16:19:21.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:21.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:21.427]                     .init = FALSE)
[16:19:21.427]                 }
[16:19:21.427]             }
[16:19:21.427]         }
[16:19:21.427]     })
[16:19:21.427]     if (TRUE) {
[16:19:21.427]         base::sink(type = "output", split = FALSE)
[16:19:21.427]         if (TRUE) {
[16:19:21.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:21.427]         }
[16:19:21.427]         else {
[16:19:21.427]             ...future.result["stdout"] <- base::list(NULL)
[16:19:21.427]         }
[16:19:21.427]         base::close(...future.stdout)
[16:19:21.427]         ...future.stdout <- NULL
[16:19:21.427]     }
[16:19:21.427]     ...future.result$conditions <- ...future.conditions
[16:19:21.427]     ...future.result$finished <- base::Sys.time()
[16:19:21.427]     ...future.result
[16:19:21.427] }
[16:19:21.430] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[16:19:21.430] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:21.472] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:21.473] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:19:21.473] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.473] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:21.474] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.474] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:21.516] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:21.517] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:21.561] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:21.561] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:21.561] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.561] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:19:21.562] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:19:21.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:21.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.563] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:19:21.563] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.563] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:21.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:21.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.565] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[16:19:21.565] MultisessionFuture started
[16:19:21.565] - Launch lazy future ... done
[16:19:21.565] run() for ‘MultisessionFuture’ ... done
[16:19:21.565] Created future:
[16:19:21.567] receiveMessageFromWorker() for ClusterFuture ...
[16:19:21.567] - Validating connection of MultisessionFuture
[16:19:21.567] - received message: FutureResult
[16:19:21.567] - Received FutureResult
[16:19:21.567] - Erased future from FutureRegistry
[16:19:21.568] result() for ClusterFuture ...
[16:19:21.568] - result already collected: FutureResult
[16:19:21.568] result() for ClusterFuture ... done
[16:19:21.568] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:21.566] MultisessionFuture:
[16:19:21.566] Label: ‘future_vapply-1’
[16:19:21.566] Expression:
[16:19:21.566] {
[16:19:21.566]     do.call(function(...) {
[16:19:21.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.566]             on.exit(options(oopts), add = TRUE)
[16:19:21.566]         }
[16:19:21.566]         {
[16:19:21.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.566]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.566]             })
[16:19:21.566]         }
[16:19:21.566]     }, args = future.call.arguments)
[16:19:21.566] }
[16:19:21.566] Lazy evaluation: FALSE
[16:19:21.566] Asynchronous evaluation: TRUE
[16:19:21.566] Local evaluation: TRUE
[16:19:21.566] Environment: R_GlobalEnv
[16:19:21.566] Capture standard output: TRUE
[16:19:21.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:21.566] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:21.566] Packages: 1 packages (‘future.apply’)
[16:19:21.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:21.566] Resolved: TRUE
[16:19:21.566] Value: <not collected>
[16:19:21.566] Conditions captured: <none>
[16:19:21.566] Early signaling: FALSE
[16:19:21.566] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:21.566] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.568] Chunk #1 of 2 ... DONE
[16:19:21.568] Chunk #2 of 2 ...
[16:19:21.568]  - Finding globals in 'X' for chunk #2 ...
[16:19:21.568] getGlobalsAndPackages() ...
[16:19:21.569] Searching for globals...
[16:19:21.569] 
[16:19:21.569] Searching for globals ... DONE
[16:19:21.569] - globals: [0] <none>
[16:19:21.569] getGlobalsAndPackages() ... DONE
[16:19:21.569]    + additional globals found: [n=0] 
[16:19:21.569]    + additional namespaces needed: [n=0] 
[16:19:21.569]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:21.569]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:21.570]  - seeds: <none>
[16:19:21.570]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.570] getGlobalsAndPackages() ...
[16:19:21.570] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.570] Resolving globals: FALSE
[16:19:21.570] Tweak future expression to call with '...' arguments ...
[16:19:21.570] {
[16:19:21.570]     do.call(function(...) {
[16:19:21.570]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.570]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.570]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.570]             on.exit(options(oopts), add = TRUE)
[16:19:21.570]         }
[16:19:21.570]         {
[16:19:21.570]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.570]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.570]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.570]             })
[16:19:21.570]         }
[16:19:21.570]     }, args = future.call.arguments)
[16:19:21.570] }
[16:19:21.571] Tweak future expression to call with '...' arguments ... DONE
[16:19:21.571] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.571] - packages: [1] ‘future.apply’
[16:19:21.571] getGlobalsAndPackages() ... DONE
[16:19:21.572] run() for ‘Future’ ...
[16:19:21.572] - state: ‘created’
[16:19:21.572] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:21.589] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:21.589]   - Field: ‘node’
[16:19:21.589]   - Field: ‘label’
[16:19:21.589]   - Field: ‘local’
[16:19:21.589]   - Field: ‘owner’
[16:19:21.589]   - Field: ‘envir’
[16:19:21.589]   - Field: ‘workers’
[16:19:21.589]   - Field: ‘packages’
[16:19:21.590]   - Field: ‘gc’
[16:19:21.590]   - Field: ‘conditions’
[16:19:21.590]   - Field: ‘persistent’
[16:19:21.590]   - Field: ‘expr’
[16:19:21.590]   - Field: ‘uuid’
[16:19:21.590]   - Field: ‘seed’
[16:19:21.590]   - Field: ‘version’
[16:19:21.590]   - Field: ‘result’
[16:19:21.590]   - Field: ‘asynchronous’
[16:19:21.590]   - Field: ‘calls’
[16:19:21.590]   - Field: ‘globals’
[16:19:21.591]   - Field: ‘stdout’
[16:19:21.591]   - Field: ‘earlySignal’
[16:19:21.591]   - Field: ‘lazy’
[16:19:21.591]   - Field: ‘state’
[16:19:21.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:21.591] - Launch lazy future ...
[16:19:21.591] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:21.591] Packages needed by future strategies (n = 0): <none>
[16:19:21.592] {
[16:19:21.592]     {
[16:19:21.592]         {
[16:19:21.592]             ...future.startTime <- base::Sys.time()
[16:19:21.592]             {
[16:19:21.592]                 {
[16:19:21.592]                   {
[16:19:21.592]                     {
[16:19:21.592]                       {
[16:19:21.592]                         base::local({
[16:19:21.592]                           has_future <- base::requireNamespace("future", 
[16:19:21.592]                             quietly = TRUE)
[16:19:21.592]                           if (has_future) {
[16:19:21.592]                             ns <- base::getNamespace("future")
[16:19:21.592]                             version <- ns[[".package"]][["version"]]
[16:19:21.592]                             if (is.null(version)) 
[16:19:21.592]                               version <- utils::packageVersion("future")
[16:19:21.592]                           }
[16:19:21.592]                           else {
[16:19:21.592]                             version <- NULL
[16:19:21.592]                           }
[16:19:21.592]                           if (!has_future || version < "1.8.0") {
[16:19:21.592]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:21.592]                               "", base::R.version$version.string), 
[16:19:21.592]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:21.592]                                 base::R.version$platform, 8 * 
[16:19:21.592]                                   base::.Machine$sizeof.pointer), 
[16:19:21.592]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:21.592]                                 "release", "version")], collapse = " "), 
[16:19:21.592]                               hostname = base::Sys.info()[["nodename"]])
[16:19:21.592]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:21.592]                               info)
[16:19:21.592]                             info <- base::paste(info, collapse = "; ")
[16:19:21.592]                             if (!has_future) {
[16:19:21.592]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:21.592]                                 info)
[16:19:21.592]                             }
[16:19:21.592]                             else {
[16:19:21.592]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:21.592]                                 info, version)
[16:19:21.592]                             }
[16:19:21.592]                             base::stop(msg)
[16:19:21.592]                           }
[16:19:21.592]                         })
[16:19:21.592]                       }
[16:19:21.592]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:21.592]                       base::options(mc.cores = 1L)
[16:19:21.592]                     }
[16:19:21.592]                     base::local({
[16:19:21.592]                       for (pkg in "future.apply") {
[16:19:21.592]                         base::loadNamespace(pkg)
[16:19:21.592]                         base::library(pkg, character.only = TRUE)
[16:19:21.592]                       }
[16:19:21.592]                     })
[16:19:21.592]                   }
[16:19:21.592]                   ...future.strategy.old <- future::plan("list")
[16:19:21.592]                   options(future.plan = NULL)
[16:19:21.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:21.592]                 }
[16:19:21.592]                 ...future.workdir <- getwd()
[16:19:21.592]             }
[16:19:21.592]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:21.592]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:21.592]         }
[16:19:21.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:21.592]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:21.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:21.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:21.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:21.592]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:21.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:21.592]             base::names(...future.oldOptions))
[16:19:21.592]     }
[16:19:21.592]     if (FALSE) {
[16:19:21.592]     }
[16:19:21.592]     else {
[16:19:21.592]         if (TRUE) {
[16:19:21.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:21.592]                 open = "w")
[16:19:21.592]         }
[16:19:21.592]         else {
[16:19:21.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:21.592]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:21.592]         }
[16:19:21.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:21.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:21.592]             base::sink(type = "output", split = FALSE)
[16:19:21.592]             base::close(...future.stdout)
[16:19:21.592]         }, add = TRUE)
[16:19:21.592]     }
[16:19:21.592]     ...future.frame <- base::sys.nframe()
[16:19:21.592]     ...future.conditions <- base::list()
[16:19:21.592]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:21.592]     if (FALSE) {
[16:19:21.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:21.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:21.592]     }
[16:19:21.592]     ...future.result <- base::tryCatch({
[16:19:21.592]         base::withCallingHandlers({
[16:19:21.592]             ...future.value <- base::withVisible(base::local({
[16:19:21.592]                 ...future.makeSendCondition <- base::local({
[16:19:21.592]                   sendCondition <- NULL
[16:19:21.592]                   function(frame = 1L) {
[16:19:21.592]                     if (is.function(sendCondition)) 
[16:19:21.592]                       return(sendCondition)
[16:19:21.592]                     ns <- getNamespace("parallel")
[16:19:21.592]                     if (exists("sendData", mode = "function", 
[16:19:21.592]                       envir = ns)) {
[16:19:21.592]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:21.592]                         envir = ns)
[16:19:21.592]                       envir <- sys.frame(frame)
[16:19:21.592]                       master <- NULL
[16:19:21.592]                       while (!identical(envir, .GlobalEnv) && 
[16:19:21.592]                         !identical(envir, emptyenv())) {
[16:19:21.592]                         if (exists("master", mode = "list", envir = envir, 
[16:19:21.592]                           inherits = FALSE)) {
[16:19:21.592]                           master <- get("master", mode = "list", 
[16:19:21.592]                             envir = envir, inherits = FALSE)
[16:19:21.592]                           if (inherits(master, c("SOCKnode", 
[16:19:21.592]                             "SOCK0node"))) {
[16:19:21.592]                             sendCondition <<- function(cond) {
[16:19:21.592]                               data <- list(type = "VALUE", value = cond, 
[16:19:21.592]                                 success = TRUE)
[16:19:21.592]                               parallel_sendData(master, data)
[16:19:21.592]                             }
[16:19:21.592]                             return(sendCondition)
[16:19:21.592]                           }
[16:19:21.592]                         }
[16:19:21.592]                         frame <- frame + 1L
[16:19:21.592]                         envir <- sys.frame(frame)
[16:19:21.592]                       }
[16:19:21.592]                     }
[16:19:21.592]                     sendCondition <<- function(cond) NULL
[16:19:21.592]                   }
[16:19:21.592]                 })
[16:19:21.592]                 withCallingHandlers({
[16:19:21.592]                   {
[16:19:21.592]                     do.call(function(...) {
[16:19:21.592]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.592]                       if (!identical(...future.globals.maxSize.org, 
[16:19:21.592]                         ...future.globals.maxSize)) {
[16:19:21.592]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.592]                         on.exit(options(oopts), add = TRUE)
[16:19:21.592]                       }
[16:19:21.592]                       {
[16:19:21.592]                         lapply(seq_along(...future.elements_ii), 
[16:19:21.592]                           FUN = function(jj) {
[16:19:21.592]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.592]                             ...future.FUN(...future.X_jj, ...)
[16:19:21.592]                           })
[16:19:21.592]                       }
[16:19:21.592]                     }, args = future.call.arguments)
[16:19:21.592]                   }
[16:19:21.592]                 }, immediateCondition = function(cond) {
[16:19:21.592]                   sendCondition <- ...future.makeSendCondition()
[16:19:21.592]                   sendCondition(cond)
[16:19:21.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.592]                   {
[16:19:21.592]                     inherits <- base::inherits
[16:19:21.592]                     invokeRestart <- base::invokeRestart
[16:19:21.592]                     is.null <- base::is.null
[16:19:21.592]                     muffled <- FALSE
[16:19:21.592]                     if (inherits(cond, "message")) {
[16:19:21.592]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:21.592]                       if (muffled) 
[16:19:21.592]                         invokeRestart("muffleMessage")
[16:19:21.592]                     }
[16:19:21.592]                     else if (inherits(cond, "warning")) {
[16:19:21.592]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:21.592]                       if (muffled) 
[16:19:21.592]                         invokeRestart("muffleWarning")
[16:19:21.592]                     }
[16:19:21.592]                     else if (inherits(cond, "condition")) {
[16:19:21.592]                       if (!is.null(pattern)) {
[16:19:21.592]                         computeRestarts <- base::computeRestarts
[16:19:21.592]                         grepl <- base::grepl
[16:19:21.592]                         restarts <- computeRestarts(cond)
[16:19:21.592]                         for (restart in restarts) {
[16:19:21.592]                           name <- restart$name
[16:19:21.592]                           if (is.null(name)) 
[16:19:21.592]                             next
[16:19:21.592]                           if (!grepl(pattern, name)) 
[16:19:21.592]                             next
[16:19:21.592]                           invokeRestart(restart)
[16:19:21.592]                           muffled <- TRUE
[16:19:21.592]                           break
[16:19:21.592]                         }
[16:19:21.592]                       }
[16:19:21.592]                     }
[16:19:21.592]                     invisible(muffled)
[16:19:21.592]                   }
[16:19:21.592]                   muffleCondition(cond)
[16:19:21.592]                 })
[16:19:21.592]             }))
[16:19:21.592]             future::FutureResult(value = ...future.value$value, 
[16:19:21.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.592]                   ...future.rng), globalenv = if (FALSE) 
[16:19:21.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:21.592]                     ...future.globalenv.names))
[16:19:21.592]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:21.592]         }, condition = base::local({
[16:19:21.592]             c <- base::c
[16:19:21.592]             inherits <- base::inherits
[16:19:21.592]             invokeRestart <- base::invokeRestart
[16:19:21.592]             length <- base::length
[16:19:21.592]             list <- base::list
[16:19:21.592]             seq.int <- base::seq.int
[16:19:21.592]             signalCondition <- base::signalCondition
[16:19:21.592]             sys.calls <- base::sys.calls
[16:19:21.592]             `[[` <- base::`[[`
[16:19:21.592]             `+` <- base::`+`
[16:19:21.592]             `<<-` <- base::`<<-`
[16:19:21.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:21.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:21.592]                   3L)]
[16:19:21.592]             }
[16:19:21.592]             function(cond) {
[16:19:21.592]                 is_error <- inherits(cond, "error")
[16:19:21.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:21.592]                   NULL)
[16:19:21.592]                 if (is_error) {
[16:19:21.592]                   sessionInformation <- function() {
[16:19:21.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:21.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:21.592]                       search = base::search(), system = base::Sys.info())
[16:19:21.592]                   }
[16:19:21.592]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:21.592]                     cond$call), session = sessionInformation(), 
[16:19:21.592]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:21.592]                   signalCondition(cond)
[16:19:21.592]                 }
[16:19:21.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:21.592]                 "immediateCondition"))) {
[16:19:21.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:21.592]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:21.592]                   if (TRUE && !signal) {
[16:19:21.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.592]                     {
[16:19:21.592]                       inherits <- base::inherits
[16:19:21.592]                       invokeRestart <- base::invokeRestart
[16:19:21.592]                       is.null <- base::is.null
[16:19:21.592]                       muffled <- FALSE
[16:19:21.592]                       if (inherits(cond, "message")) {
[16:19:21.592]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.592]                         if (muffled) 
[16:19:21.592]                           invokeRestart("muffleMessage")
[16:19:21.592]                       }
[16:19:21.592]                       else if (inherits(cond, "warning")) {
[16:19:21.592]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.592]                         if (muffled) 
[16:19:21.592]                           invokeRestart("muffleWarning")
[16:19:21.592]                       }
[16:19:21.592]                       else if (inherits(cond, "condition")) {
[16:19:21.592]                         if (!is.null(pattern)) {
[16:19:21.592]                           computeRestarts <- base::computeRestarts
[16:19:21.592]                           grepl <- base::grepl
[16:19:21.592]                           restarts <- computeRestarts(cond)
[16:19:21.592]                           for (restart in restarts) {
[16:19:21.592]                             name <- restart$name
[16:19:21.592]                             if (is.null(name)) 
[16:19:21.592]                               next
[16:19:21.592]                             if (!grepl(pattern, name)) 
[16:19:21.592]                               next
[16:19:21.592]                             invokeRestart(restart)
[16:19:21.592]                             muffled <- TRUE
[16:19:21.592]                             break
[16:19:21.592]                           }
[16:19:21.592]                         }
[16:19:21.592]                       }
[16:19:21.592]                       invisible(muffled)
[16:19:21.592]                     }
[16:19:21.592]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.592]                   }
[16:19:21.592]                 }
[16:19:21.592]                 else {
[16:19:21.592]                   if (TRUE) {
[16:19:21.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.592]                     {
[16:19:21.592]                       inherits <- base::inherits
[16:19:21.592]                       invokeRestart <- base::invokeRestart
[16:19:21.592]                       is.null <- base::is.null
[16:19:21.592]                       muffled <- FALSE
[16:19:21.592]                       if (inherits(cond, "message")) {
[16:19:21.592]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.592]                         if (muffled) 
[16:19:21.592]                           invokeRestart("muffleMessage")
[16:19:21.592]                       }
[16:19:21.592]                       else if (inherits(cond, "warning")) {
[16:19:21.592]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.592]                         if (muffled) 
[16:19:21.592]                           invokeRestart("muffleWarning")
[16:19:21.592]                       }
[16:19:21.592]                       else if (inherits(cond, "condition")) {
[16:19:21.592]                         if (!is.null(pattern)) {
[16:19:21.592]                           computeRestarts <- base::computeRestarts
[16:19:21.592]                           grepl <- base::grepl
[16:19:21.592]                           restarts <- computeRestarts(cond)
[16:19:21.592]                           for (restart in restarts) {
[16:19:21.592]                             name <- restart$name
[16:19:21.592]                             if (is.null(name)) 
[16:19:21.592]                               next
[16:19:21.592]                             if (!grepl(pattern, name)) 
[16:19:21.592]                               next
[16:19:21.592]                             invokeRestart(restart)
[16:19:21.592]                             muffled <- TRUE
[16:19:21.592]                             break
[16:19:21.592]                           }
[16:19:21.592]                         }
[16:19:21.592]                       }
[16:19:21.592]                       invisible(muffled)
[16:19:21.592]                     }
[16:19:21.592]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.592]                   }
[16:19:21.592]                 }
[16:19:21.592]             }
[16:19:21.592]         }))
[16:19:21.592]     }, error = function(ex) {
[16:19:21.592]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:21.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.592]                 ...future.rng), started = ...future.startTime, 
[16:19:21.592]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:21.592]             version = "1.8"), class = "FutureResult")
[16:19:21.592]     }, finally = {
[16:19:21.592]         if (!identical(...future.workdir, getwd())) 
[16:19:21.592]             setwd(...future.workdir)
[16:19:21.592]         {
[16:19:21.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:21.592]                 ...future.oldOptions$nwarnings <- NULL
[16:19:21.592]             }
[16:19:21.592]             base::options(...future.oldOptions)
[16:19:21.592]             if (.Platform$OS.type == "windows") {
[16:19:21.592]                 old_names <- names(...future.oldEnvVars)
[16:19:21.592]                 envs <- base::Sys.getenv()
[16:19:21.592]                 names <- names(envs)
[16:19:21.592]                 common <- intersect(names, old_names)
[16:19:21.592]                 added <- setdiff(names, old_names)
[16:19:21.592]                 removed <- setdiff(old_names, names)
[16:19:21.592]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:21.592]                   envs[common]]
[16:19:21.592]                 NAMES <- toupper(changed)
[16:19:21.592]                 args <- list()
[16:19:21.592]                 for (kk in seq_along(NAMES)) {
[16:19:21.592]                   name <- changed[[kk]]
[16:19:21.592]                   NAME <- NAMES[[kk]]
[16:19:21.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.592]                     next
[16:19:21.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.592]                 }
[16:19:21.592]                 NAMES <- toupper(added)
[16:19:21.592]                 for (kk in seq_along(NAMES)) {
[16:19:21.592]                   name <- added[[kk]]
[16:19:21.592]                   NAME <- NAMES[[kk]]
[16:19:21.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.592]                     next
[16:19:21.592]                   args[[name]] <- ""
[16:19:21.592]                 }
[16:19:21.592]                 NAMES <- toupper(removed)
[16:19:21.592]                 for (kk in seq_along(NAMES)) {
[16:19:21.592]                   name <- removed[[kk]]
[16:19:21.592]                   NAME <- NAMES[[kk]]
[16:19:21.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.592]                     next
[16:19:21.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.592]                 }
[16:19:21.592]                 if (length(args) > 0) 
[16:19:21.592]                   base::do.call(base::Sys.setenv, args = args)
[16:19:21.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:21.592]             }
[16:19:21.592]             else {
[16:19:21.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:21.592]             }
[16:19:21.592]             {
[16:19:21.592]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:21.592]                   0L) {
[16:19:21.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:21.592]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:21.592]                   base::options(opts)
[16:19:21.592]                 }
[16:19:21.592]                 {
[16:19:21.592]                   {
[16:19:21.592]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:21.592]                     NULL
[16:19:21.592]                   }
[16:19:21.592]                   options(future.plan = NULL)
[16:19:21.592]                   if (is.na(NA_character_)) 
[16:19:21.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:21.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:21.592]                     .init = FALSE)
[16:19:21.592]                 }
[16:19:21.592]             }
[16:19:21.592]         }
[16:19:21.592]     })
[16:19:21.592]     if (TRUE) {
[16:19:21.592]         base::sink(type = "output", split = FALSE)
[16:19:21.592]         if (TRUE) {
[16:19:21.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:21.592]         }
[16:19:21.592]         else {
[16:19:21.592]             ...future.result["stdout"] <- base::list(NULL)
[16:19:21.592]         }
[16:19:21.592]         base::close(...future.stdout)
[16:19:21.592]         ...future.stdout <- NULL
[16:19:21.592]     }
[16:19:21.592]     ...future.result$conditions <- ...future.conditions
[16:19:21.592]     ...future.result$finished <- base::Sys.time()
[16:19:21.592]     ...future.result
[16:19:21.592] }
[16:19:21.594] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[16:19:21.595] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:21.636] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:21.637] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:19:21.637] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.637] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:21.638] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.638] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:21.680] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:21.681] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:21.724] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:21.725] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:21.725] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.725] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:19:21.726] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:19:21.726] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:21.726] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.726] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:19:21.727] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:19:21.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:21.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:21.728] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.728] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[16:19:21.728] MultisessionFuture started
[16:19:21.728] - Launch lazy future ... done
[16:19:21.728] run() for ‘MultisessionFuture’ ... done
[16:19:21.729] Created future:
[16:19:21.730] receiveMessageFromWorker() for ClusterFuture ...
[16:19:21.730] - Validating connection of MultisessionFuture
[16:19:21.730] - received message: FutureResult
[16:19:21.731] - Received FutureResult
[16:19:21.731] - Erased future from FutureRegistry
[16:19:21.731] result() for ClusterFuture ...
[16:19:21.731] - result already collected: FutureResult
[16:19:21.731] result() for ClusterFuture ... done
[16:19:21.731] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:21.729] MultisessionFuture:
[16:19:21.729] Label: ‘future_vapply-2’
[16:19:21.729] Expression:
[16:19:21.729] {
[16:19:21.729]     do.call(function(...) {
[16:19:21.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.729]             on.exit(options(oopts), add = TRUE)
[16:19:21.729]         }
[16:19:21.729]         {
[16:19:21.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.729]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.729]             })
[16:19:21.729]         }
[16:19:21.729]     }, args = future.call.arguments)
[16:19:21.729] }
[16:19:21.729] Lazy evaluation: FALSE
[16:19:21.729] Asynchronous evaluation: TRUE
[16:19:21.729] Local evaluation: TRUE
[16:19:21.729] Environment: R_GlobalEnv
[16:19:21.729] Capture standard output: TRUE
[16:19:21.729] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:21.729] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:21.729] Packages: 1 packages (‘future.apply’)
[16:19:21.729] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:21.729] Resolved: TRUE
[16:19:21.729] Value: <not collected>
[16:19:21.729] Conditions captured: <none>
[16:19:21.729] Early signaling: FALSE
[16:19:21.729] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:21.729] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.731] Chunk #2 of 2 ... DONE
[16:19:21.731] Launching 2 futures (chunks) ... DONE
[16:19:21.731] Resolving 2 futures (chunks) ...
[16:19:21.732] resolve() on list ...
[16:19:21.732]  recursive: 0
[16:19:21.732]  length: 2
[16:19:21.732] 
[16:19:21.732] Future #1
[16:19:21.732] result() for ClusterFuture ...
[16:19:21.732] - result already collected: FutureResult
[16:19:21.732] result() for ClusterFuture ... done
[16:19:21.732] result() for ClusterFuture ...
[16:19:21.732] - result already collected: FutureResult
[16:19:21.733] result() for ClusterFuture ... done
[16:19:21.733] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:21.733] - nx: 2
[16:19:21.733] - relay: TRUE
[16:19:21.733] - stdout: TRUE
[16:19:21.733] - signal: TRUE
[16:19:21.733] - resignal: FALSE
[16:19:21.733] - force: TRUE
[16:19:21.733] - relayed: [n=2] FALSE, FALSE
[16:19:21.733] - queued futures: [n=2] FALSE, FALSE
[16:19:21.733]  - until=1
[16:19:21.733]  - relaying element #1
[16:19:21.734] result() for ClusterFuture ...
[16:19:21.734] - result already collected: FutureResult
[16:19:21.734] result() for ClusterFuture ... done
[16:19:21.734] result() for ClusterFuture ...
[16:19:21.734] - result already collected: FutureResult
[16:19:21.734] result() for ClusterFuture ... done
[16:19:21.734] result() for ClusterFuture ...
[16:19:21.734] - result already collected: FutureResult
[16:19:21.734] result() for ClusterFuture ... done
[16:19:21.734] result() for ClusterFuture ...
[16:19:21.734] - result already collected: FutureResult
[16:19:21.735] result() for ClusterFuture ... done
[16:19:21.735] - relayed: [n=2] TRUE, FALSE
[16:19:21.735] - queued futures: [n=2] TRUE, FALSE
[16:19:21.735] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:21.735]  length: 1 (resolved future 1)
[16:19:21.735] Future #2
[16:19:21.735] result() for ClusterFuture ...
[16:19:21.735] - result already collected: FutureResult
[16:19:21.735] result() for ClusterFuture ... done
[16:19:21.735] result() for ClusterFuture ...
[16:19:21.736] - result already collected: FutureResult
[16:19:21.736] result() for ClusterFuture ... done
[16:19:21.736] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:21.736] - nx: 2
[16:19:21.736] - relay: TRUE
[16:19:21.736] - stdout: TRUE
[16:19:21.736] - signal: TRUE
[16:19:21.736] - resignal: FALSE
[16:19:21.736] - force: TRUE
[16:19:21.736] - relayed: [n=2] TRUE, FALSE
[16:19:21.736] - queued futures: [n=2] TRUE, FALSE
[16:19:21.736]  - until=2
[16:19:21.737]  - relaying element #2
[16:19:21.737] result() for ClusterFuture ...
[16:19:21.737] - result already collected: FutureResult
[16:19:21.737] result() for ClusterFuture ... done
[16:19:21.737] result() for ClusterFuture ...
[16:19:21.737] - result already collected: FutureResult
[16:19:21.737] result() for ClusterFuture ... done
[16:19:21.737] result() for ClusterFuture ...
[16:19:21.737] - result already collected: FutureResult
[16:19:21.737] result() for ClusterFuture ... done
[16:19:21.738] result() for ClusterFuture ...
[16:19:21.738] - result already collected: FutureResult
[16:19:21.738] result() for ClusterFuture ... done
[16:19:21.738] - relayed: [n=2] TRUE, TRUE
[16:19:21.738] - queued futures: [n=2] TRUE, TRUE
[16:19:21.738] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:19:21.738]  length: 0 (resolved future 2)
[16:19:21.738] Relaying remaining futures
[16:19:21.738] signalConditionsASAP(NULL, pos=0) ...
[16:19:21.738] - nx: 2
[16:19:21.738] - relay: TRUE
[16:19:21.739] - stdout: TRUE
[16:19:21.739] - signal: TRUE
[16:19:21.739] - resignal: FALSE
[16:19:21.739] - force: TRUE
[16:19:21.739] - relayed: [n=2] TRUE, TRUE
[16:19:21.739] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:21.739] - relayed: [n=2] TRUE, TRUE
[16:19:21.739] - queued futures: [n=2] TRUE, TRUE
[16:19:21.739] signalConditionsASAP(NULL, pos=0) ... done
[16:19:21.739] resolve() on list ... DONE
[16:19:21.739] result() for ClusterFuture ...
[16:19:21.740] - result already collected: FutureResult
[16:19:21.740] result() for ClusterFuture ... done
[16:19:21.740] result() for ClusterFuture ...
[16:19:21.740] - result already collected: FutureResult
[16:19:21.740] result() for ClusterFuture ... done
[16:19:21.740] result() for ClusterFuture ...
[16:19:21.740] - result already collected: FutureResult
[16:19:21.740] result() for ClusterFuture ... done
[16:19:21.740] result() for ClusterFuture ...
[16:19:21.740] - result already collected: FutureResult
[16:19:21.740] result() for ClusterFuture ... done
[16:19:21.741]  - Number of value chunks collected: 2
[16:19:21.741] Resolving 2 futures (chunks) ... DONE
[16:19:21.741] Reducing values from 2 chunks ...
[16:19:21.741]  - Number of values collected after concatenation: 3
[16:19:21.741]  - Number of values expected: 3
[16:19:21.741] Reducing values from 2 chunks ... DONE
[16:19:21.741] future_lapply() ... DONE
- exceptions ...
[16:19:21.741] future_lapply() ...
[16:19:21.747] Number of chunks: 2
[16:19:21.747] getGlobalsAndPackagesXApply() ...
[16:19:21.747]  - future.globals: TRUE
[16:19:21.747] getGlobalsAndPackages() ...
[16:19:21.747] Searching for globals...
[16:19:21.750] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:19:21.750] Searching for globals ... DONE
[16:19:21.751] Resolving globals: FALSE
[16:19:21.751] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:19:21.752] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:19:21.752] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:21.752] - packages: [1] ‘future.apply’
[16:19:21.752] getGlobalsAndPackages() ... DONE
[16:19:21.752]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:19:21.752]  - needed namespaces: [n=1] ‘future.apply’
[16:19:21.752] Finding globals ... DONE
[16:19:21.753]  - use_args: TRUE
[16:19:21.753]  - Getting '...' globals ...
[16:19:21.753] resolve() on list ...
[16:19:21.753]  recursive: 0
[16:19:21.753]  length: 1
[16:19:21.753]  elements: ‘...’
[16:19:21.753]  length: 0 (resolved future 1)
[16:19:21.753] resolve() on list ... DONE
[16:19:21.754]    - '...' content: [n=0] 
[16:19:21.754] List of 1
[16:19:21.754]  $ ...: list()
[16:19:21.754]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:21.754]  - attr(*, "where")=List of 1
[16:19:21.754]   ..$ ...:<environment: 0x5619a0148160> 
[16:19:21.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:21.754]  - attr(*, "resolved")= logi TRUE
[16:19:21.754]  - attr(*, "total_size")= num NA
[16:19:21.756]  - Getting '...' globals ... DONE
[16:19:21.756] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:19:21.756] List of 8
[16:19:21.756]  $ ...future.FUN:function (x, ...)  
[16:19:21.756]  $ x_FUN        :function (x)  
[16:19:21.756]  $ times        : int 2
[16:19:21.756]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:19:21.756]  $ stop_if_not  :function (...)  
[16:19:21.756]  $ dim          : NULL
[16:19:21.756]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:19:21.756]  $ ...          : list()
[16:19:21.756]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:21.756]  - attr(*, "where")=List of 8
[16:19:21.756]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:21.756]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:19:21.756]   ..$ times        :<environment: R_EmptyEnv> 
[16:19:21.756]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:19:21.756]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:19:21.756]   ..$ dim          :<environment: R_EmptyEnv> 
[16:19:21.756]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:19:21.756]   ..$ ...          :<environment: 0x5619a0148160> 
[16:19:21.756]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:21.756]  - attr(*, "resolved")= logi FALSE
[16:19:21.756]  - attr(*, "total_size")= num 95128
[16:19:21.762] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:19:21.762] getGlobalsAndPackagesXApply() ... DONE
[16:19:21.762] Number of futures (= number of chunks): 2
[16:19:21.762] Launching 2 futures (chunks) ...
[16:19:21.762] Chunk #1 of 2 ...
[16:19:21.762]  - Finding globals in 'X' for chunk #1 ...
[16:19:21.762] getGlobalsAndPackages() ...
[16:19:21.762] Searching for globals...
[16:19:21.763] 
[16:19:21.763] Searching for globals ... DONE
[16:19:21.763] - globals: [0] <none>
[16:19:21.763] getGlobalsAndPackages() ... DONE
[16:19:21.763]    + additional globals found: [n=0] 
[16:19:21.763]    + additional namespaces needed: [n=0] 
[16:19:21.763]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:21.763]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:21.763]  - seeds: <none>
[16:19:21.764]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.764] getGlobalsAndPackages() ...
[16:19:21.764] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.764] Resolving globals: FALSE
[16:19:21.764] Tweak future expression to call with '...' arguments ...
[16:19:21.764] {
[16:19:21.764]     do.call(function(...) {
[16:19:21.764]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.764]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.764]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.764]             on.exit(options(oopts), add = TRUE)
[16:19:21.764]         }
[16:19:21.764]         {
[16:19:21.764]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.764]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.764]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.764]             })
[16:19:21.764]         }
[16:19:21.764]     }, args = future.call.arguments)
[16:19:21.764] }
[16:19:21.764] Tweak future expression to call with '...' arguments ... DONE
[16:19:21.765] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.765] - packages: [1] ‘future.apply’
[16:19:21.765] getGlobalsAndPackages() ... DONE
[16:19:21.765] run() for ‘Future’ ...
[16:19:21.766] - state: ‘created’
[16:19:21.766] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:21.779] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:21.780]   - Field: ‘node’
[16:19:21.780]   - Field: ‘label’
[16:19:21.780]   - Field: ‘local’
[16:19:21.780]   - Field: ‘owner’
[16:19:21.780]   - Field: ‘envir’
[16:19:21.780]   - Field: ‘workers’
[16:19:21.780]   - Field: ‘packages’
[16:19:21.780]   - Field: ‘gc’
[16:19:21.780]   - Field: ‘conditions’
[16:19:21.780]   - Field: ‘persistent’
[16:19:21.781]   - Field: ‘expr’
[16:19:21.781]   - Field: ‘uuid’
[16:19:21.781]   - Field: ‘seed’
[16:19:21.781]   - Field: ‘version’
[16:19:21.781]   - Field: ‘result’
[16:19:21.781]   - Field: ‘asynchronous’
[16:19:21.781]   - Field: ‘calls’
[16:19:21.781]   - Field: ‘globals’
[16:19:21.781]   - Field: ‘stdout’
[16:19:21.781]   - Field: ‘earlySignal’
[16:19:21.781]   - Field: ‘lazy’
[16:19:21.782]   - Field: ‘state’
[16:19:21.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:21.782] - Launch lazy future ...
[16:19:21.782] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:21.782] Packages needed by future strategies (n = 0): <none>
[16:19:21.783] {
[16:19:21.783]     {
[16:19:21.783]         {
[16:19:21.783]             ...future.startTime <- base::Sys.time()
[16:19:21.783]             {
[16:19:21.783]                 {
[16:19:21.783]                   {
[16:19:21.783]                     {
[16:19:21.783]                       {
[16:19:21.783]                         base::local({
[16:19:21.783]                           has_future <- base::requireNamespace("future", 
[16:19:21.783]                             quietly = TRUE)
[16:19:21.783]                           if (has_future) {
[16:19:21.783]                             ns <- base::getNamespace("future")
[16:19:21.783]                             version <- ns[[".package"]][["version"]]
[16:19:21.783]                             if (is.null(version)) 
[16:19:21.783]                               version <- utils::packageVersion("future")
[16:19:21.783]                           }
[16:19:21.783]                           else {
[16:19:21.783]                             version <- NULL
[16:19:21.783]                           }
[16:19:21.783]                           if (!has_future || version < "1.8.0") {
[16:19:21.783]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:21.783]                               "", base::R.version$version.string), 
[16:19:21.783]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:21.783]                                 base::R.version$platform, 8 * 
[16:19:21.783]                                   base::.Machine$sizeof.pointer), 
[16:19:21.783]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:21.783]                                 "release", "version")], collapse = " "), 
[16:19:21.783]                               hostname = base::Sys.info()[["nodename"]])
[16:19:21.783]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:21.783]                               info)
[16:19:21.783]                             info <- base::paste(info, collapse = "; ")
[16:19:21.783]                             if (!has_future) {
[16:19:21.783]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:21.783]                                 info)
[16:19:21.783]                             }
[16:19:21.783]                             else {
[16:19:21.783]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:21.783]                                 info, version)
[16:19:21.783]                             }
[16:19:21.783]                             base::stop(msg)
[16:19:21.783]                           }
[16:19:21.783]                         })
[16:19:21.783]                       }
[16:19:21.783]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:21.783]                       base::options(mc.cores = 1L)
[16:19:21.783]                     }
[16:19:21.783]                     base::local({
[16:19:21.783]                       for (pkg in "future.apply") {
[16:19:21.783]                         base::loadNamespace(pkg)
[16:19:21.783]                         base::library(pkg, character.only = TRUE)
[16:19:21.783]                       }
[16:19:21.783]                     })
[16:19:21.783]                   }
[16:19:21.783]                   ...future.strategy.old <- future::plan("list")
[16:19:21.783]                   options(future.plan = NULL)
[16:19:21.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:21.783]                 }
[16:19:21.783]                 ...future.workdir <- getwd()
[16:19:21.783]             }
[16:19:21.783]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:21.783]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:21.783]         }
[16:19:21.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:21.783]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:21.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:21.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:21.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:21.783]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:21.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:21.783]             base::names(...future.oldOptions))
[16:19:21.783]     }
[16:19:21.783]     if (FALSE) {
[16:19:21.783]     }
[16:19:21.783]     else {
[16:19:21.783]         if (TRUE) {
[16:19:21.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:21.783]                 open = "w")
[16:19:21.783]         }
[16:19:21.783]         else {
[16:19:21.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:21.783]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:21.783]         }
[16:19:21.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:21.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:21.783]             base::sink(type = "output", split = FALSE)
[16:19:21.783]             base::close(...future.stdout)
[16:19:21.783]         }, add = TRUE)
[16:19:21.783]     }
[16:19:21.783]     ...future.frame <- base::sys.nframe()
[16:19:21.783]     ...future.conditions <- base::list()
[16:19:21.783]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:21.783]     if (FALSE) {
[16:19:21.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:21.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:21.783]     }
[16:19:21.783]     ...future.result <- base::tryCatch({
[16:19:21.783]         base::withCallingHandlers({
[16:19:21.783]             ...future.value <- base::withVisible(base::local({
[16:19:21.783]                 ...future.makeSendCondition <- base::local({
[16:19:21.783]                   sendCondition <- NULL
[16:19:21.783]                   function(frame = 1L) {
[16:19:21.783]                     if (is.function(sendCondition)) 
[16:19:21.783]                       return(sendCondition)
[16:19:21.783]                     ns <- getNamespace("parallel")
[16:19:21.783]                     if (exists("sendData", mode = "function", 
[16:19:21.783]                       envir = ns)) {
[16:19:21.783]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:21.783]                         envir = ns)
[16:19:21.783]                       envir <- sys.frame(frame)
[16:19:21.783]                       master <- NULL
[16:19:21.783]                       while (!identical(envir, .GlobalEnv) && 
[16:19:21.783]                         !identical(envir, emptyenv())) {
[16:19:21.783]                         if (exists("master", mode = "list", envir = envir, 
[16:19:21.783]                           inherits = FALSE)) {
[16:19:21.783]                           master <- get("master", mode = "list", 
[16:19:21.783]                             envir = envir, inherits = FALSE)
[16:19:21.783]                           if (inherits(master, c("SOCKnode", 
[16:19:21.783]                             "SOCK0node"))) {
[16:19:21.783]                             sendCondition <<- function(cond) {
[16:19:21.783]                               data <- list(type = "VALUE", value = cond, 
[16:19:21.783]                                 success = TRUE)
[16:19:21.783]                               parallel_sendData(master, data)
[16:19:21.783]                             }
[16:19:21.783]                             return(sendCondition)
[16:19:21.783]                           }
[16:19:21.783]                         }
[16:19:21.783]                         frame <- frame + 1L
[16:19:21.783]                         envir <- sys.frame(frame)
[16:19:21.783]                       }
[16:19:21.783]                     }
[16:19:21.783]                     sendCondition <<- function(cond) NULL
[16:19:21.783]                   }
[16:19:21.783]                 })
[16:19:21.783]                 withCallingHandlers({
[16:19:21.783]                   {
[16:19:21.783]                     do.call(function(...) {
[16:19:21.783]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.783]                       if (!identical(...future.globals.maxSize.org, 
[16:19:21.783]                         ...future.globals.maxSize)) {
[16:19:21.783]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.783]                         on.exit(options(oopts), add = TRUE)
[16:19:21.783]                       }
[16:19:21.783]                       {
[16:19:21.783]                         lapply(seq_along(...future.elements_ii), 
[16:19:21.783]                           FUN = function(jj) {
[16:19:21.783]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.783]                             ...future.FUN(...future.X_jj, ...)
[16:19:21.783]                           })
[16:19:21.783]                       }
[16:19:21.783]                     }, args = future.call.arguments)
[16:19:21.783]                   }
[16:19:21.783]                 }, immediateCondition = function(cond) {
[16:19:21.783]                   sendCondition <- ...future.makeSendCondition()
[16:19:21.783]                   sendCondition(cond)
[16:19:21.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.783]                   {
[16:19:21.783]                     inherits <- base::inherits
[16:19:21.783]                     invokeRestart <- base::invokeRestart
[16:19:21.783]                     is.null <- base::is.null
[16:19:21.783]                     muffled <- FALSE
[16:19:21.783]                     if (inherits(cond, "message")) {
[16:19:21.783]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:21.783]                       if (muffled) 
[16:19:21.783]                         invokeRestart("muffleMessage")
[16:19:21.783]                     }
[16:19:21.783]                     else if (inherits(cond, "warning")) {
[16:19:21.783]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:21.783]                       if (muffled) 
[16:19:21.783]                         invokeRestart("muffleWarning")
[16:19:21.783]                     }
[16:19:21.783]                     else if (inherits(cond, "condition")) {
[16:19:21.783]                       if (!is.null(pattern)) {
[16:19:21.783]                         computeRestarts <- base::computeRestarts
[16:19:21.783]                         grepl <- base::grepl
[16:19:21.783]                         restarts <- computeRestarts(cond)
[16:19:21.783]                         for (restart in restarts) {
[16:19:21.783]                           name <- restart$name
[16:19:21.783]                           if (is.null(name)) 
[16:19:21.783]                             next
[16:19:21.783]                           if (!grepl(pattern, name)) 
[16:19:21.783]                             next
[16:19:21.783]                           invokeRestart(restart)
[16:19:21.783]                           muffled <- TRUE
[16:19:21.783]                           break
[16:19:21.783]                         }
[16:19:21.783]                       }
[16:19:21.783]                     }
[16:19:21.783]                     invisible(muffled)
[16:19:21.783]                   }
[16:19:21.783]                   muffleCondition(cond)
[16:19:21.783]                 })
[16:19:21.783]             }))
[16:19:21.783]             future::FutureResult(value = ...future.value$value, 
[16:19:21.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.783]                   ...future.rng), globalenv = if (FALSE) 
[16:19:21.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:21.783]                     ...future.globalenv.names))
[16:19:21.783]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:21.783]         }, condition = base::local({
[16:19:21.783]             c <- base::c
[16:19:21.783]             inherits <- base::inherits
[16:19:21.783]             invokeRestart <- base::invokeRestart
[16:19:21.783]             length <- base::length
[16:19:21.783]             list <- base::list
[16:19:21.783]             seq.int <- base::seq.int
[16:19:21.783]             signalCondition <- base::signalCondition
[16:19:21.783]             sys.calls <- base::sys.calls
[16:19:21.783]             `[[` <- base::`[[`
[16:19:21.783]             `+` <- base::`+`
[16:19:21.783]             `<<-` <- base::`<<-`
[16:19:21.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:21.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:21.783]                   3L)]
[16:19:21.783]             }
[16:19:21.783]             function(cond) {
[16:19:21.783]                 is_error <- inherits(cond, "error")
[16:19:21.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:21.783]                   NULL)
[16:19:21.783]                 if (is_error) {
[16:19:21.783]                   sessionInformation <- function() {
[16:19:21.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:21.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:21.783]                       search = base::search(), system = base::Sys.info())
[16:19:21.783]                   }
[16:19:21.783]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:21.783]                     cond$call), session = sessionInformation(), 
[16:19:21.783]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:21.783]                   signalCondition(cond)
[16:19:21.783]                 }
[16:19:21.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:21.783]                 "immediateCondition"))) {
[16:19:21.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:21.783]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:21.783]                   if (TRUE && !signal) {
[16:19:21.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.783]                     {
[16:19:21.783]                       inherits <- base::inherits
[16:19:21.783]                       invokeRestart <- base::invokeRestart
[16:19:21.783]                       is.null <- base::is.null
[16:19:21.783]                       muffled <- FALSE
[16:19:21.783]                       if (inherits(cond, "message")) {
[16:19:21.783]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.783]                         if (muffled) 
[16:19:21.783]                           invokeRestart("muffleMessage")
[16:19:21.783]                       }
[16:19:21.783]                       else if (inherits(cond, "warning")) {
[16:19:21.783]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.783]                         if (muffled) 
[16:19:21.783]                           invokeRestart("muffleWarning")
[16:19:21.783]                       }
[16:19:21.783]                       else if (inherits(cond, "condition")) {
[16:19:21.783]                         if (!is.null(pattern)) {
[16:19:21.783]                           computeRestarts <- base::computeRestarts
[16:19:21.783]                           grepl <- base::grepl
[16:19:21.783]                           restarts <- computeRestarts(cond)
[16:19:21.783]                           for (restart in restarts) {
[16:19:21.783]                             name <- restart$name
[16:19:21.783]                             if (is.null(name)) 
[16:19:21.783]                               next
[16:19:21.783]                             if (!grepl(pattern, name)) 
[16:19:21.783]                               next
[16:19:21.783]                             invokeRestart(restart)
[16:19:21.783]                             muffled <- TRUE
[16:19:21.783]                             break
[16:19:21.783]                           }
[16:19:21.783]                         }
[16:19:21.783]                       }
[16:19:21.783]                       invisible(muffled)
[16:19:21.783]                     }
[16:19:21.783]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.783]                   }
[16:19:21.783]                 }
[16:19:21.783]                 else {
[16:19:21.783]                   if (TRUE) {
[16:19:21.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.783]                     {
[16:19:21.783]                       inherits <- base::inherits
[16:19:21.783]                       invokeRestart <- base::invokeRestart
[16:19:21.783]                       is.null <- base::is.null
[16:19:21.783]                       muffled <- FALSE
[16:19:21.783]                       if (inherits(cond, "message")) {
[16:19:21.783]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.783]                         if (muffled) 
[16:19:21.783]                           invokeRestart("muffleMessage")
[16:19:21.783]                       }
[16:19:21.783]                       else if (inherits(cond, "warning")) {
[16:19:21.783]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.783]                         if (muffled) 
[16:19:21.783]                           invokeRestart("muffleWarning")
[16:19:21.783]                       }
[16:19:21.783]                       else if (inherits(cond, "condition")) {
[16:19:21.783]                         if (!is.null(pattern)) {
[16:19:21.783]                           computeRestarts <- base::computeRestarts
[16:19:21.783]                           grepl <- base::grepl
[16:19:21.783]                           restarts <- computeRestarts(cond)
[16:19:21.783]                           for (restart in restarts) {
[16:19:21.783]                             name <- restart$name
[16:19:21.783]                             if (is.null(name)) 
[16:19:21.783]                               next
[16:19:21.783]                             if (!grepl(pattern, name)) 
[16:19:21.783]                               next
[16:19:21.783]                             invokeRestart(restart)
[16:19:21.783]                             muffled <- TRUE
[16:19:21.783]                             break
[16:19:21.783]                           }
[16:19:21.783]                         }
[16:19:21.783]                       }
[16:19:21.783]                       invisible(muffled)
[16:19:21.783]                     }
[16:19:21.783]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.783]                   }
[16:19:21.783]                 }
[16:19:21.783]             }
[16:19:21.783]         }))
[16:19:21.783]     }, error = function(ex) {
[16:19:21.783]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:21.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.783]                 ...future.rng), started = ...future.startTime, 
[16:19:21.783]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:21.783]             version = "1.8"), class = "FutureResult")
[16:19:21.783]     }, finally = {
[16:19:21.783]         if (!identical(...future.workdir, getwd())) 
[16:19:21.783]             setwd(...future.workdir)
[16:19:21.783]         {
[16:19:21.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:21.783]                 ...future.oldOptions$nwarnings <- NULL
[16:19:21.783]             }
[16:19:21.783]             base::options(...future.oldOptions)
[16:19:21.783]             if (.Platform$OS.type == "windows") {
[16:19:21.783]                 old_names <- names(...future.oldEnvVars)
[16:19:21.783]                 envs <- base::Sys.getenv()
[16:19:21.783]                 names <- names(envs)
[16:19:21.783]                 common <- intersect(names, old_names)
[16:19:21.783]                 added <- setdiff(names, old_names)
[16:19:21.783]                 removed <- setdiff(old_names, names)
[16:19:21.783]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:21.783]                   envs[common]]
[16:19:21.783]                 NAMES <- toupper(changed)
[16:19:21.783]                 args <- list()
[16:19:21.783]                 for (kk in seq_along(NAMES)) {
[16:19:21.783]                   name <- changed[[kk]]
[16:19:21.783]                   NAME <- NAMES[[kk]]
[16:19:21.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.783]                     next
[16:19:21.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.783]                 }
[16:19:21.783]                 NAMES <- toupper(added)
[16:19:21.783]                 for (kk in seq_along(NAMES)) {
[16:19:21.783]                   name <- added[[kk]]
[16:19:21.783]                   NAME <- NAMES[[kk]]
[16:19:21.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.783]                     next
[16:19:21.783]                   args[[name]] <- ""
[16:19:21.783]                 }
[16:19:21.783]                 NAMES <- toupper(removed)
[16:19:21.783]                 for (kk in seq_along(NAMES)) {
[16:19:21.783]                   name <- removed[[kk]]
[16:19:21.783]                   NAME <- NAMES[[kk]]
[16:19:21.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.783]                     next
[16:19:21.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.783]                 }
[16:19:21.783]                 if (length(args) > 0) 
[16:19:21.783]                   base::do.call(base::Sys.setenv, args = args)
[16:19:21.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:21.783]             }
[16:19:21.783]             else {
[16:19:21.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:21.783]             }
[16:19:21.783]             {
[16:19:21.783]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:21.783]                   0L) {
[16:19:21.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:21.783]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:21.783]                   base::options(opts)
[16:19:21.783]                 }
[16:19:21.783]                 {
[16:19:21.783]                   {
[16:19:21.783]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:21.783]                     NULL
[16:19:21.783]                   }
[16:19:21.783]                   options(future.plan = NULL)
[16:19:21.783]                   if (is.na(NA_character_)) 
[16:19:21.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:21.783]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:21.783]                     .init = FALSE)
[16:19:21.783]                 }
[16:19:21.783]             }
[16:19:21.783]         }
[16:19:21.783]     })
[16:19:21.783]     if (TRUE) {
[16:19:21.783]         base::sink(type = "output", split = FALSE)
[16:19:21.783]         if (TRUE) {
[16:19:21.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:21.783]         }
[16:19:21.783]         else {
[16:19:21.783]             ...future.result["stdout"] <- base::list(NULL)
[16:19:21.783]         }
[16:19:21.783]         base::close(...future.stdout)
[16:19:21.783]         ...future.stdout <- NULL
[16:19:21.783]     }
[16:19:21.783]     ...future.result$conditions <- ...future.conditions
[16:19:21.783]     ...future.result$finished <- base::Sys.time()
[16:19:21.783]     ...future.result
[16:19:21.783] }
[16:19:21.785] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[16:19:21.786] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:19:21.828] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:19:21.829] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[16:19:21.829] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[16:19:21.829] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:19:21.830] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.830] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:19:21.872] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:19:21.873] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:19:21.916] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:19:21.917] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:19:21.917] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.917] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:19:21.918] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:19:21.918] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:21.919] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.919] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:19:21.919] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:19:21.919] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:21.919] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.920] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:21.920] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:21.920] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[16:19:21.921] MultisessionFuture started
[16:19:21.921] - Launch lazy future ... done
[16:19:21.921] run() for ‘MultisessionFuture’ ... done
[16:19:21.921] Created future:
[16:19:21.921] MultisessionFuture:
[16:19:21.921] Label: ‘future_vapply-1’
[16:19:21.921] Expression:
[16:19:21.921] {
[16:19:21.921]     do.call(function(...) {
[16:19:21.921]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.921]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.921]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.921]             on.exit(options(oopts), add = TRUE)
[16:19:21.921]         }
[16:19:21.921]         {
[16:19:21.921]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.921]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.921]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.921]             })
[16:19:21.921]         }
[16:19:21.921]     }, args = future.call.arguments)
[16:19:21.921] }
[16:19:21.921] Lazy evaluation: FALSE
[16:19:21.921] Asynchronous evaluation: TRUE
[16:19:21.921] Local evaluation: TRUE
[16:19:21.921] Environment: R_GlobalEnv
[16:19:21.921] Capture standard output: TRUE
[16:19:21.921] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:21.921] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:21.921] Packages: 1 packages (‘future.apply’)
[16:19:21.921] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:21.921] Resolved: FALSE
[16:19:21.921] Value: <not collected>
[16:19:21.921] Conditions captured: <none>
[16:19:21.921] Early signaling: FALSE
[16:19:21.921] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:21.921] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.933] Chunk #1 of 2 ... DONE
[16:19:21.933] Chunk #2 of 2 ...
[16:19:21.933]  - Finding globals in 'X' for chunk #2 ...
[16:19:21.933] getGlobalsAndPackages() ...
[16:19:21.933] Searching for globals...
[16:19:21.933] 
[16:19:21.933] Searching for globals ... DONE
[16:19:21.934] - globals: [0] <none>
[16:19:21.934] getGlobalsAndPackages() ... DONE
[16:19:21.934]    + additional globals found: [n=0] 
[16:19:21.934]    + additional namespaces needed: [n=0] 
[16:19:21.934]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:21.934]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:21.934]  - seeds: <none>
[16:19:21.934]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.934] getGlobalsAndPackages() ...
[16:19:21.934] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.935] Resolving globals: FALSE
[16:19:21.935] Tweak future expression to call with '...' arguments ...
[16:19:21.935] {
[16:19:21.935]     do.call(function(...) {
[16:19:21.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:21.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.935]             on.exit(options(oopts), add = TRUE)
[16:19:21.935]         }
[16:19:21.935]         {
[16:19:21.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:21.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.935]                 ...future.FUN(...future.X_jj, ...)
[16:19:21.935]             })
[16:19:21.935]         }
[16:19:21.935]     }, args = future.call.arguments)
[16:19:21.935] }
[16:19:21.935] Tweak future expression to call with '...' arguments ... DONE
[16:19:21.935] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:21.936] - packages: [1] ‘future.apply’
[16:19:21.936] getGlobalsAndPackages() ... DONE
[16:19:21.936] run() for ‘Future’ ...
[16:19:21.936] - state: ‘created’
[16:19:21.936] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:21.950] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:21.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:21.951]   - Field: ‘node’
[16:19:21.951]   - Field: ‘label’
[16:19:21.951]   - Field: ‘local’
[16:19:21.951]   - Field: ‘owner’
[16:19:21.951]   - Field: ‘envir’
[16:19:21.951]   - Field: ‘workers’
[16:19:21.951]   - Field: ‘packages’
[16:19:21.951]   - Field: ‘gc’
[16:19:21.951]   - Field: ‘conditions’
[16:19:21.952]   - Field: ‘persistent’
[16:19:21.952]   - Field: ‘expr’
[16:19:21.952]   - Field: ‘uuid’
[16:19:21.952]   - Field: ‘seed’
[16:19:21.952]   - Field: ‘version’
[16:19:21.952]   - Field: ‘result’
[16:19:21.952]   - Field: ‘asynchronous’
[16:19:21.952]   - Field: ‘calls’
[16:19:21.952]   - Field: ‘globals’
[16:19:21.952]   - Field: ‘stdout’
[16:19:21.953]   - Field: ‘earlySignal’
[16:19:21.953]   - Field: ‘lazy’
[16:19:21.953]   - Field: ‘state’
[16:19:21.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:21.953] - Launch lazy future ...
[16:19:21.953] Packages needed by the future expression (n = 1): ‘future.apply’
[16:19:21.953] Packages needed by future strategies (n = 0): <none>
[16:19:21.954] {
[16:19:21.954]     {
[16:19:21.954]         {
[16:19:21.954]             ...future.startTime <- base::Sys.time()
[16:19:21.954]             {
[16:19:21.954]                 {
[16:19:21.954]                   {
[16:19:21.954]                     {
[16:19:21.954]                       {
[16:19:21.954]                         base::local({
[16:19:21.954]                           has_future <- base::requireNamespace("future", 
[16:19:21.954]                             quietly = TRUE)
[16:19:21.954]                           if (has_future) {
[16:19:21.954]                             ns <- base::getNamespace("future")
[16:19:21.954]                             version <- ns[[".package"]][["version"]]
[16:19:21.954]                             if (is.null(version)) 
[16:19:21.954]                               version <- utils::packageVersion("future")
[16:19:21.954]                           }
[16:19:21.954]                           else {
[16:19:21.954]                             version <- NULL
[16:19:21.954]                           }
[16:19:21.954]                           if (!has_future || version < "1.8.0") {
[16:19:21.954]                             info <- base::c(r_version = base::gsub("R version ", 
[16:19:21.954]                               "", base::R.version$version.string), 
[16:19:21.954]                               platform = base::sprintf("%s (%s-bit)", 
[16:19:21.954]                                 base::R.version$platform, 8 * 
[16:19:21.954]                                   base::.Machine$sizeof.pointer), 
[16:19:21.954]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:21.954]                                 "release", "version")], collapse = " "), 
[16:19:21.954]                               hostname = base::Sys.info()[["nodename"]])
[16:19:21.954]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:19:21.954]                               info)
[16:19:21.954]                             info <- base::paste(info, collapse = "; ")
[16:19:21.954]                             if (!has_future) {
[16:19:21.954]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:21.954]                                 info)
[16:19:21.954]                             }
[16:19:21.954]                             else {
[16:19:21.954]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:21.954]                                 info, version)
[16:19:21.954]                             }
[16:19:21.954]                             base::stop(msg)
[16:19:21.954]                           }
[16:19:21.954]                         })
[16:19:21.954]                       }
[16:19:21.954]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:21.954]                       base::options(mc.cores = 1L)
[16:19:21.954]                     }
[16:19:21.954]                     base::local({
[16:19:21.954]                       for (pkg in "future.apply") {
[16:19:21.954]                         base::loadNamespace(pkg)
[16:19:21.954]                         base::library(pkg, character.only = TRUE)
[16:19:21.954]                       }
[16:19:21.954]                     })
[16:19:21.954]                   }
[16:19:21.954]                   ...future.strategy.old <- future::plan("list")
[16:19:21.954]                   options(future.plan = NULL)
[16:19:21.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:21.954]                 }
[16:19:21.954]                 ...future.workdir <- getwd()
[16:19:21.954]             }
[16:19:21.954]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:21.954]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:21.954]         }
[16:19:21.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:21.954]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:21.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:21.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:21.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:21.954]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:21.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:21.954]             base::names(...future.oldOptions))
[16:19:21.954]     }
[16:19:21.954]     if (FALSE) {
[16:19:21.954]     }
[16:19:21.954]     else {
[16:19:21.954]         if (TRUE) {
[16:19:21.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:21.954]                 open = "w")
[16:19:21.954]         }
[16:19:21.954]         else {
[16:19:21.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:21.954]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:21.954]         }
[16:19:21.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:21.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:21.954]             base::sink(type = "output", split = FALSE)
[16:19:21.954]             base::close(...future.stdout)
[16:19:21.954]         }, add = TRUE)
[16:19:21.954]     }
[16:19:21.954]     ...future.frame <- base::sys.nframe()
[16:19:21.954]     ...future.conditions <- base::list()
[16:19:21.954]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:21.954]     if (FALSE) {
[16:19:21.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:21.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:21.954]     }
[16:19:21.954]     ...future.result <- base::tryCatch({
[16:19:21.954]         base::withCallingHandlers({
[16:19:21.954]             ...future.value <- base::withVisible(base::local({
[16:19:21.954]                 ...future.makeSendCondition <- base::local({
[16:19:21.954]                   sendCondition <- NULL
[16:19:21.954]                   function(frame = 1L) {
[16:19:21.954]                     if (is.function(sendCondition)) 
[16:19:21.954]                       return(sendCondition)
[16:19:21.954]                     ns <- getNamespace("parallel")
[16:19:21.954]                     if (exists("sendData", mode = "function", 
[16:19:21.954]                       envir = ns)) {
[16:19:21.954]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:21.954]                         envir = ns)
[16:19:21.954]                       envir <- sys.frame(frame)
[16:19:21.954]                       master <- NULL
[16:19:21.954]                       while (!identical(envir, .GlobalEnv) && 
[16:19:21.954]                         !identical(envir, emptyenv())) {
[16:19:21.954]                         if (exists("master", mode = "list", envir = envir, 
[16:19:21.954]                           inherits = FALSE)) {
[16:19:21.954]                           master <- get("master", mode = "list", 
[16:19:21.954]                             envir = envir, inherits = FALSE)
[16:19:21.954]                           if (inherits(master, c("SOCKnode", 
[16:19:21.954]                             "SOCK0node"))) {
[16:19:21.954]                             sendCondition <<- function(cond) {
[16:19:21.954]                               data <- list(type = "VALUE", value = cond, 
[16:19:21.954]                                 success = TRUE)
[16:19:21.954]                               parallel_sendData(master, data)
[16:19:21.954]                             }
[16:19:21.954]                             return(sendCondition)
[16:19:21.954]                           }
[16:19:21.954]                         }
[16:19:21.954]                         frame <- frame + 1L
[16:19:21.954]                         envir <- sys.frame(frame)
[16:19:21.954]                       }
[16:19:21.954]                     }
[16:19:21.954]                     sendCondition <<- function(cond) NULL
[16:19:21.954]                   }
[16:19:21.954]                 })
[16:19:21.954]                 withCallingHandlers({
[16:19:21.954]                   {
[16:19:21.954]                     do.call(function(...) {
[16:19:21.954]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:21.954]                       if (!identical(...future.globals.maxSize.org, 
[16:19:21.954]                         ...future.globals.maxSize)) {
[16:19:21.954]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:21.954]                         on.exit(options(oopts), add = TRUE)
[16:19:21.954]                       }
[16:19:21.954]                       {
[16:19:21.954]                         lapply(seq_along(...future.elements_ii), 
[16:19:21.954]                           FUN = function(jj) {
[16:19:21.954]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:21.954]                             ...future.FUN(...future.X_jj, ...)
[16:19:21.954]                           })
[16:19:21.954]                       }
[16:19:21.954]                     }, args = future.call.arguments)
[16:19:21.954]                   }
[16:19:21.954]                 }, immediateCondition = function(cond) {
[16:19:21.954]                   sendCondition <- ...future.makeSendCondition()
[16:19:21.954]                   sendCondition(cond)
[16:19:21.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.954]                   {
[16:19:21.954]                     inherits <- base::inherits
[16:19:21.954]                     invokeRestart <- base::invokeRestart
[16:19:21.954]                     is.null <- base::is.null
[16:19:21.954]                     muffled <- FALSE
[16:19:21.954]                     if (inherits(cond, "message")) {
[16:19:21.954]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:21.954]                       if (muffled) 
[16:19:21.954]                         invokeRestart("muffleMessage")
[16:19:21.954]                     }
[16:19:21.954]                     else if (inherits(cond, "warning")) {
[16:19:21.954]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:21.954]                       if (muffled) 
[16:19:21.954]                         invokeRestart("muffleWarning")
[16:19:21.954]                     }
[16:19:21.954]                     else if (inherits(cond, "condition")) {
[16:19:21.954]                       if (!is.null(pattern)) {
[16:19:21.954]                         computeRestarts <- base::computeRestarts
[16:19:21.954]                         grepl <- base::grepl
[16:19:21.954]                         restarts <- computeRestarts(cond)
[16:19:21.954]                         for (restart in restarts) {
[16:19:21.954]                           name <- restart$name
[16:19:21.954]                           if (is.null(name)) 
[16:19:21.954]                             next
[16:19:21.954]                           if (!grepl(pattern, name)) 
[16:19:21.954]                             next
[16:19:21.954]                           invokeRestart(restart)
[16:19:21.954]                           muffled <- TRUE
[16:19:21.954]                           break
[16:19:21.954]                         }
[16:19:21.954]                       }
[16:19:21.954]                     }
[16:19:21.954]                     invisible(muffled)
[16:19:21.954]                   }
[16:19:21.954]                   muffleCondition(cond)
[16:19:21.954]                 })
[16:19:21.954]             }))
[16:19:21.954]             future::FutureResult(value = ...future.value$value, 
[16:19:21.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.954]                   ...future.rng), globalenv = if (FALSE) 
[16:19:21.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:21.954]                     ...future.globalenv.names))
[16:19:21.954]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:21.954]         }, condition = base::local({
[16:19:21.954]             c <- base::c
[16:19:21.954]             inherits <- base::inherits
[16:19:21.954]             invokeRestart <- base::invokeRestart
[16:19:21.954]             length <- base::length
[16:19:21.954]             list <- base::list
[16:19:21.954]             seq.int <- base::seq.int
[16:19:21.954]             signalCondition <- base::signalCondition
[16:19:21.954]             sys.calls <- base::sys.calls
[16:19:21.954]             `[[` <- base::`[[`
[16:19:21.954]             `+` <- base::`+`
[16:19:21.954]             `<<-` <- base::`<<-`
[16:19:21.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:21.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:21.954]                   3L)]
[16:19:21.954]             }
[16:19:21.954]             function(cond) {
[16:19:21.954]                 is_error <- inherits(cond, "error")
[16:19:21.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:21.954]                   NULL)
[16:19:21.954]                 if (is_error) {
[16:19:21.954]                   sessionInformation <- function() {
[16:19:21.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:21.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:21.954]                       search = base::search(), system = base::Sys.info())
[16:19:21.954]                   }
[16:19:21.954]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:21.954]                     cond$call), session = sessionInformation(), 
[16:19:21.954]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:21.954]                   signalCondition(cond)
[16:19:21.954]                 }
[16:19:21.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:21.954]                 "immediateCondition"))) {
[16:19:21.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:21.954]                   ...future.conditions[[length(...future.conditions) + 
[16:19:21.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:21.954]                   if (TRUE && !signal) {
[16:19:21.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.954]                     {
[16:19:21.954]                       inherits <- base::inherits
[16:19:21.954]                       invokeRestart <- base::invokeRestart
[16:19:21.954]                       is.null <- base::is.null
[16:19:21.954]                       muffled <- FALSE
[16:19:21.954]                       if (inherits(cond, "message")) {
[16:19:21.954]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.954]                         if (muffled) 
[16:19:21.954]                           invokeRestart("muffleMessage")
[16:19:21.954]                       }
[16:19:21.954]                       else if (inherits(cond, "warning")) {
[16:19:21.954]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.954]                         if (muffled) 
[16:19:21.954]                           invokeRestart("muffleWarning")
[16:19:21.954]                       }
[16:19:21.954]                       else if (inherits(cond, "condition")) {
[16:19:21.954]                         if (!is.null(pattern)) {
[16:19:21.954]                           computeRestarts <- base::computeRestarts
[16:19:21.954]                           grepl <- base::grepl
[16:19:21.954]                           restarts <- computeRestarts(cond)
[16:19:21.954]                           for (restart in restarts) {
[16:19:21.954]                             name <- restart$name
[16:19:21.954]                             if (is.null(name)) 
[16:19:21.954]                               next
[16:19:21.954]                             if (!grepl(pattern, name)) 
[16:19:21.954]                               next
[16:19:21.954]                             invokeRestart(restart)
[16:19:21.954]                             muffled <- TRUE
[16:19:21.954]                             break
[16:19:21.954]                           }
[16:19:21.954]                         }
[16:19:21.954]                       }
[16:19:21.954]                       invisible(muffled)
[16:19:21.954]                     }
[16:19:21.954]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.954]                   }
[16:19:21.954]                 }
[16:19:21.954]                 else {
[16:19:21.954]                   if (TRUE) {
[16:19:21.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:21.954]                     {
[16:19:21.954]                       inherits <- base::inherits
[16:19:21.954]                       invokeRestart <- base::invokeRestart
[16:19:21.954]                       is.null <- base::is.null
[16:19:21.954]                       muffled <- FALSE
[16:19:21.954]                       if (inherits(cond, "message")) {
[16:19:21.954]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:21.954]                         if (muffled) 
[16:19:21.954]                           invokeRestart("muffleMessage")
[16:19:21.954]                       }
[16:19:21.954]                       else if (inherits(cond, "warning")) {
[16:19:21.954]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:21.954]                         if (muffled) 
[16:19:21.954]                           invokeRestart("muffleWarning")
[16:19:21.954]                       }
[16:19:21.954]                       else if (inherits(cond, "condition")) {
[16:19:21.954]                         if (!is.null(pattern)) {
[16:19:21.954]                           computeRestarts <- base::computeRestarts
[16:19:21.954]                           grepl <- base::grepl
[16:19:21.954]                           restarts <- computeRestarts(cond)
[16:19:21.954]                           for (restart in restarts) {
[16:19:21.954]                             name <- restart$name
[16:19:21.954]                             if (is.null(name)) 
[16:19:21.954]                               next
[16:19:21.954]                             if (!grepl(pattern, name)) 
[16:19:21.954]                               next
[16:19:21.954]                             invokeRestart(restart)
[16:19:21.954]                             muffled <- TRUE
[16:19:21.954]                             break
[16:19:21.954]                           }
[16:19:21.954]                         }
[16:19:21.954]                       }
[16:19:21.954]                       invisible(muffled)
[16:19:21.954]                     }
[16:19:21.954]                     muffleCondition(cond, pattern = "^muffle")
[16:19:21.954]                   }
[16:19:21.954]                 }
[16:19:21.954]             }
[16:19:21.954]         }))
[16:19:21.954]     }, error = function(ex) {
[16:19:21.954]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:21.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:21.954]                 ...future.rng), started = ...future.startTime, 
[16:19:21.954]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:21.954]             version = "1.8"), class = "FutureResult")
[16:19:21.954]     }, finally = {
[16:19:21.954]         if (!identical(...future.workdir, getwd())) 
[16:19:21.954]             setwd(...future.workdir)
[16:19:21.954]         {
[16:19:21.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:21.954]                 ...future.oldOptions$nwarnings <- NULL
[16:19:21.954]             }
[16:19:21.954]             base::options(...future.oldOptions)
[16:19:21.954]             if (.Platform$OS.type == "windows") {
[16:19:21.954]                 old_names <- names(...future.oldEnvVars)
[16:19:21.954]                 envs <- base::Sys.getenv()
[16:19:21.954]                 names <- names(envs)
[16:19:21.954]                 common <- intersect(names, old_names)
[16:19:21.954]                 added <- setdiff(names, old_names)
[16:19:21.954]                 removed <- setdiff(old_names, names)
[16:19:21.954]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:21.954]                   envs[common]]
[16:19:21.954]                 NAMES <- toupper(changed)
[16:19:21.954]                 args <- list()
[16:19:21.954]                 for (kk in seq_along(NAMES)) {
[16:19:21.954]                   name <- changed[[kk]]
[16:19:21.954]                   NAME <- NAMES[[kk]]
[16:19:21.954]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.954]                     next
[16:19:21.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.954]                 }
[16:19:21.954]                 NAMES <- toupper(added)
[16:19:21.954]                 for (kk in seq_along(NAMES)) {
[16:19:21.954]                   name <- added[[kk]]
[16:19:21.954]                   NAME <- NAMES[[kk]]
[16:19:21.954]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.954]                     next
[16:19:21.954]                   args[[name]] <- ""
[16:19:21.954]                 }
[16:19:21.954]                 NAMES <- toupper(removed)
[16:19:21.954]                 for (kk in seq_along(NAMES)) {
[16:19:21.954]                   name <- removed[[kk]]
[16:19:21.954]                   NAME <- NAMES[[kk]]
[16:19:21.954]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:21.954]                     next
[16:19:21.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:21.954]                 }
[16:19:21.954]                 if (length(args) > 0) 
[16:19:21.954]                   base::do.call(base::Sys.setenv, args = args)
[16:19:21.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:21.954]             }
[16:19:21.954]             else {
[16:19:21.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:21.954]             }
[16:19:21.954]             {
[16:19:21.954]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:21.954]                   0L) {
[16:19:21.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:21.954]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:21.954]                   base::options(opts)
[16:19:21.954]                 }
[16:19:21.954]                 {
[16:19:21.954]                   {
[16:19:21.954]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:21.954]                     NULL
[16:19:21.954]                   }
[16:19:21.954]                   options(future.plan = NULL)
[16:19:21.954]                   if (is.na(NA_character_)) 
[16:19:21.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:21.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:21.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:21.954]                     .init = FALSE)
[16:19:21.954]                 }
[16:19:21.954]             }
[16:19:21.954]         }
[16:19:21.954]     })
[16:19:21.954]     if (TRUE) {
[16:19:21.954]         base::sink(type = "output", split = FALSE)
[16:19:21.954]         if (TRUE) {
[16:19:21.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:21.954]         }
[16:19:21.954]         else {
[16:19:21.954]             ...future.result["stdout"] <- base::list(NULL)
[16:19:21.954]         }
[16:19:21.954]         base::close(...future.stdout)
[16:19:21.954]         ...future.stdout <- NULL
[16:19:21.954]     }
[16:19:21.954]     ...future.result$conditions <- ...future.conditions
[16:19:21.954]     ...future.result$finished <- base::Sys.time()
[16:19:21.954]     ...future.result
[16:19:21.954] }
[16:19:21.957] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[16:19:21.957] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:19:22.001] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:19:22.001] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[16:19:22.001] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[16:19:22.001] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:19:22.002] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:19:22.002] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:19:22.044] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:19:22.045] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:19:22.089] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:19:22.089] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:19:22.089] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:19:22.089] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:19:22.090] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:19:22.090] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:22.090] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:22.091] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:19:22.091] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:19:22.091] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:22.092] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:22.092] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:22.092] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:22.092] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[16:19:22.093] MultisessionFuture started
[16:19:22.093] - Launch lazy future ... done
[16:19:22.093] run() for ‘MultisessionFuture’ ... done
[16:19:22.093] Created future:
[16:19:22.093] MultisessionFuture:
[16:19:22.093] Label: ‘future_vapply-2’
[16:19:22.093] Expression:
[16:19:22.093] {
[16:19:22.093]     do.call(function(...) {
[16:19:22.093]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:22.093]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:22.093]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:22.093]             on.exit(options(oopts), add = TRUE)
[16:19:22.093]         }
[16:19:22.093]         {
[16:19:22.093]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:22.093]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:22.093]                 ...future.FUN(...future.X_jj, ...)
[16:19:22.093]             })
[16:19:22.093]         }
[16:19:22.093]     }, args = future.call.arguments)
[16:19:22.093] }
[16:19:22.093] Lazy evaluation: FALSE
[16:19:22.093] Asynchronous evaluation: TRUE
[16:19:22.093] Local evaluation: TRUE
[16:19:22.093] Environment: R_GlobalEnv
[16:19:22.093] Capture standard output: TRUE
[16:19:22.093] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:22.093] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:19:22.093] Packages: 1 packages (‘future.apply’)
[16:19:22.093] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:22.093] Resolved: FALSE
[16:19:22.093] Value: <not collected>
[16:19:22.093] Conditions captured: <none>
[16:19:22.093] Early signaling: FALSE
[16:19:22.093] Owner process: 767f574a-5550-3546-38ca-4eb259674bdd
[16:19:22.093] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:22.105] Chunk #2 of 2 ... DONE
[16:19:22.105] Launching 2 futures (chunks) ... DONE
[16:19:22.105] Resolving 2 futures (chunks) ...
[16:19:22.105] resolve() on list ...
[16:19:22.105]  recursive: 0
[16:19:22.105]  length: 2
[16:19:22.106] 
[16:19:22.106] receiveMessageFromWorker() for ClusterFuture ...
[16:19:22.106] - Validating connection of MultisessionFuture
[16:19:22.107] - received message: FutureResult
[16:19:22.107] - Received FutureResult
[16:19:22.107] - Erased future from FutureRegistry
[16:19:22.107] result() for ClusterFuture ...
[16:19:22.107] - result already collected: FutureResult
[16:19:22.107] result() for ClusterFuture ... done
[16:19:22.107] signalConditions() ...
[16:19:22.107]  - include = ‘immediateCondition’
[16:19:22.107]  - exclude = 
[16:19:22.107]  - resignal = FALSE
[16:19:22.108]  - Number of conditions: 1
[16:19:22.108] signalConditions() ... done
[16:19:22.108] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:22.108] Future #1
[16:19:22.108] result() for ClusterFuture ...
[16:19:22.108] - result already collected: FutureResult
[16:19:22.108] result() for ClusterFuture ... done
[16:19:22.108] result() for ClusterFuture ...
[16:19:22.108] - result already collected: FutureResult
[16:19:22.108] result() for ClusterFuture ... done
[16:19:22.109] signalConditions() ...
[16:19:22.109]  - include = ‘immediateCondition’
[16:19:22.109]  - exclude = 
[16:19:22.109]  - resignal = FALSE
[16:19:22.109]  - Number of conditions: 1
[16:19:22.109] signalConditions() ... done
[16:19:22.109] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:22.109] - nx: 2
[16:19:22.109] - relay: TRUE
[16:19:22.109] - stdout: TRUE
[16:19:22.109] - signal: TRUE
[16:19:22.109] - resignal: FALSE
[16:19:22.110] - force: TRUE
[16:19:22.110] - relayed: [n=2] FALSE, FALSE
[16:19:22.110] - queued futures: [n=2] FALSE, FALSE
[16:19:22.110]  - until=1
[16:19:22.113]  - relaying element #1
[16:19:22.113] result() for ClusterFuture ...
[16:19:22.113] - result already collected: FutureResult
[16:19:22.113] result() for ClusterFuture ... done
[16:19:22.113] result() for ClusterFuture ...
[16:19:22.113] - result already collected: FutureResult
[16:19:22.113] result() for ClusterFuture ... done
[16:19:22.113] signalConditions() ...
[16:19:22.113]  - include = ‘immediateCondition’
[16:19:22.114]  - exclude = 
[16:19:22.114]  - resignal = FALSE
[16:19:22.114]  - Number of conditions: 1
[16:19:22.114] signalConditions() ... done
[16:19:22.114] result() for ClusterFuture ...
[16:19:22.114] - result already collected: FutureResult
[16:19:22.114] result() for ClusterFuture ... done
[16:19:22.114] signalConditions() ...
[16:19:22.114]  - include = ‘immediateCondition’
[16:19:22.114]  - exclude = 
[16:19:22.114]  - resignal = FALSE
[16:19:22.115]  - Number of conditions: 1
[16:19:22.115] signalConditions() ... done
[16:19:22.115] result() for ClusterFuture ...
[16:19:22.115] - result already collected: FutureResult
[16:19:22.115] result() for ClusterFuture ... done
[16:19:22.115] signalConditions() ...
[16:19:22.115]  - include = ‘condition’
[16:19:22.115]  - exclude = ‘immediateCondition’
[16:19:22.115]  - resignal = TRUE
[16:19:22.115]  - Number of conditions: 1
[16:19:22.115]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:19:22.115] signalConditions() ... done
[16:19:22.116] - relayed: [n=2] FALSE, FALSE
[16:19:22.116] - queued futures: [n=2] TRUE, FALSE
[16:19:22.116] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:22.116] plan(): Setting new future strategy stack:
[16:19:22.116] List of future strategies:
[16:19:22.116] 1. sequential:
[16:19:22.116]    - args: function (..., envir = parent.frame())
[16:19:22.116]    - tweaked: FALSE
[16:19:22.116]    - call: plan(sequential)
[16:19:22.117] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[16:19:22.118] plan(): Setting new future strategy stack:
[16:19:22.118] List of future strategies:
[16:19:22.118] 1. FutureStrategy:
[16:19:22.118]    - args: function (..., envir = parent.frame())
[16:19:22.118]    - tweaked: FALSE
[16:19:22.118]    - call: future::plan(oplan)
[16:19:22.119] plan(): nbrOfWorkers() = 1
> 
