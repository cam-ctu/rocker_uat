
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "dbplyr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('dbplyr')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("arrange.tbl_lazy")
> ### * arrange.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arrange.tbl_lazy
> ### Title: Arrange rows by column values
> ### Aliases: arrange.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(a = c(3, 4, 1, 2), b = c(5, 1, 2, NA))
> db %>% arrange(a) %>% show_query()
<SQL>
SELECT `dbplyr_4dMaH8wQnr`.*
FROM `dbplyr_4dMaH8wQnr`
ORDER BY `a`
> 
> # Note that NAs are sorted first
> db %>% arrange(b)
# Source:     SQL [?? x 2]
# Database:   sqlite 3.47.1 [:memory:]
# Ordered by: b
      a     b
  <dbl> <dbl>
1     2    NA
2     4     1
3     1     2
4     3     5
> # override by sorting on is.na() first
> db %>% arrange(is.na(b), b)
# Source:     SQL [?? x 2]
# Database:   sqlite 3.47.1 [:memory:]
# Ordered by: is.na(b), b
      a     b
  <dbl> <dbl>
1     4     1
2     1     2
3     3     5
4     2    NA
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("backend-access")
> ### * backend-access
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-access
> ### Title: Backend: MS Access
> ### Aliases: simulate_access
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> lf <- lazy_frame(x = 1, y = 2, z = "a", con = simulate_access())
> 
> lf %>% head()
<SQL>
SELECT TOP 6 `df`.*
FROM `df`
> lf %>% mutate(y = as.numeric(y), z = sqrt(x^2 + 10))
<SQL>
SELECT `x`, CDBL(`y`) AS `y`, SQR((`x` ^ 2.0) + 10.0) AS `z`
FROM `df`
> lf %>% mutate(a = paste0(z, " times"))
<SQL>
SELECT `df`.*, `z` & ' times' AS `a`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-hana")
> ### * backend-hana
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-hana
> ### Title: Backend: SAP HANA
> ### Aliases: simulate_hana
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_hana())
> lf %>% transmute(x = paste0(d, " times"))
<SQL>
SELECT `d` || ' times' AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-hive")
> ### * backend-hive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-hive
> ### Title: Backend: Hive
> ### Aliases: simulate_hive
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, d = 2, c = "z", con = simulate_hive())
> lf %>% transmute(x = cot(b))
<SQL>
SELECT 1.0 / TAN(`b`) AS `x`
FROM `df`
> lf %>% transmute(x = bitwShiftL(c, 1L))
<SQL>
SELECT SHIFTLEFT(`c`, 1) AS `x`
FROM `df`
> lf %>% transmute(x = str_replace_all(c, "a", "b"))
<SQL>
SELECT REGEXP_REPLACE(`c`, 'a', 'b') AS `x`
FROM `df`
> 
> lf %>% summarise(x = median(d, na.rm = TRUE))
<SQL>
SELECT PERCENTILE(`d`, 0.5) AS `x`
FROM `df`
> lf %>% summarise(x = var(c, na.rm = TRUE))
<SQL>
SELECT VARIANCE(`c`) AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-impala")
> ### * backend-impala
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-impala
> ### Title: Backend: Impala
> ### Aliases: simulate_impala
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_impala())
> lf %>% transmute(X = bitwNot(bitwOr(b, c)))
<SQL>
SELECT BITNOT(BITOR(`b`, `c`)) AS `X`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-mssql")
> ### * backend-mssql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-mssql
> ### Title: Backend: SQL server
> ### Aliases: simulate_mssql
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_mssql())
> lf %>% head()
<SQL>
SELECT TOP 6 `df`.*
FROM `df`
> lf %>% transmute(x = paste(b, c, d))
<SQL>
SELECT `b` + ' ' + `c` + ' ' + `d` AS `x`
FROM `df`
> 
> # Can use boolean as is:
> lf %>% filter(c > d)
<SQL>
SELECT `df`.*
FROM `df`
WHERE (`c` > `d`)
> # Need to convert from boolean to bit:
> lf %>% transmute(x = c > d)
<SQL>
SELECT CAST(IIF(`c` > `d`, 1, 0) AS BIT) AS `x`
FROM `df`
> # Can use boolean as is:
> lf %>% transmute(x = ifelse(c > d, "c", "d"))
<SQL>
SELECT IIF(`c` > `d`, 'c', 'd') AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-mysql")
> ### * backend-mysql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-mysql
> ### Title: Backend: MySQL/MariaDB
> ### Aliases: simulate_mysql simulate_mariadb
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_mysql())
> lf %>% transmute(x = paste0(d, " times"))
Warning: call dbDisconnect() when finished working with a connection
<SQL>
SELECT CONCAT_WS('', `d`, ' times') AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-odbc")
> ### * backend-odbc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-odbc
> ### Title: Backend: ODBC
> ### Aliases: simulate_odbc
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, d = 2, c = "z", con = simulate_odbc())
> lf %>% transmute(x = as.numeric(b))
<SQL>
SELECT CAST(`b` AS DOUBLE) AS `x`
FROM `df`
> lf %>% transmute(x = as.integer(b))
<SQL>
SELECT CAST(`b` AS INT) AS `x`
FROM `df`
> lf %>% transmute(x = as.character(b))
<SQL>
SELECT CAST(`b` AS STRING) AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-oracle")
> ### * backend-oracle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-oracle
> ### Title: Backend: Oracle
> ### Aliases: simulate_oracle
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_oracle())
> lf %>% transmute(x = paste0(c, " times"))
<SQL>
SELECT `c` || ' times' AS `x`
FROM `df`
> lf %>% setdiff(lf)
<SQL>
(
  SELECT *
  FROM `df`
)
MINUS
(
  SELECT *
  FROM `df`
)
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-postgres")
> ### * backend-postgres
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-postgres
> ### Title: Backend: PostgreSQL
> ### Aliases: simulate_postgres
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_postgres())
> lf %>% summarise(x = sd(b, na.rm = TRUE))
<SQL>
SELECT STDDEV_SAMP(`b`) AS `x`
FROM `df`
> lf %>% summarise(y = cor(b, c), z = cov(b, c))
<SQL>
SELECT CORR(`b`, `c`) AS `y`, COVAR_SAMP(`b`, `c`) AS `z`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-redshift")
> ### * backend-redshift
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-redshift
> ### Title: Backend: Redshift
> ### Aliases: simulate_redshift
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_redshift())
> lf %>% transmute(x = paste(c, " times"))
<SQL>
SELECT `c` || ' ' || ' times' AS `x`
FROM `df`
> lf %>% transmute(x = substr(c, 2, 3))
<SQL>
SELECT SUBSTRING(`c`, 2, 2) AS `x`
FROM `df`
> lf %>% transmute(x = str_replace_all(c, "a", "z"))
<SQL>
SELECT REGEXP_REPLACE(`c`, 'a', 'z') AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-snowflake")
> ### * backend-snowflake
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-snowflake
> ### Title: Backend: Snowflake
> ### Aliases: simulate_snowflake
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_snowflake())
> lf %>% transmute(x = paste0(d, " times"))
<SQL>
SELECT ARRAY_TO_STRING(ARRAY_CONSTRUCT_COMPACT(`d`, ' times'), '') AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-spark-sql")
> ### * backend-spark-sql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-spark-sql
> ### Title: Backend: Databricks Spark SQL
> ### Aliases: simulate_spark_sql
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, d = 2, c = "z", con = simulate_spark_sql())
> 
> lf %>% summarise(x = median(d, na.rm = TRUE))
<SQL>
SELECT MEDIAN(`d`) AS `x`
FROM `df`
> lf %>% summarise(x = var(c, na.rm = TRUE), .by = d)
<SQL>
SELECT `d`, VARIANCE(`c`) AS `x`
FROM `df`
GROUP BY `d`
> 
> lf %>% mutate(x = first(c))
<SQL>
SELECT `df`.*, FIRST_VALUE(`c`) OVER () AS `x`
FROM `df`
> lf %>% mutate(x = first(c), .by = d)
<SQL>
SELECT `df`.*, FIRST_VALUE(`c`) OVER (PARTITION BY `d`) AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-sqlite")
> ### * backend-sqlite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-sqlite
> ### Title: Backend: SQLite
> ### Aliases: simulate_sqlite
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_sqlite())
> lf %>% transmute(x = paste(c, " times"))
<SQL>
SELECT `c` || ' ' || ' times' AS `x`
FROM `df`
> lf %>% transmute(x = log(b), y = log(b, base = 2))
<SQL>
SELECT LOG(`b`) AS `x`, LOG(`b`) / LOG(2.0) AS `y`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("backend-teradata")
> ### * backend-teradata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backend-teradata
> ### Title: Backend: Teradata
> ### Aliases: simulate_teradata
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_teradata())
> lf %>% head()
<SQL>
SELECT TOP 6 `df`.*
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("build_sql")
> ### * build_sql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: build_sql
> ### Title: Build a SQL string.
> ### Aliases: build_sql
> ### Keywords: internal
> 
> ### ** Examples
> 
> con <- simulate_dbi()
> build_sql("SELECT * FROM TABLE", con = con)
<SQL> SELECT * FROM TABLE
> x <- "TABLE"
> build_sql("SELECT * FROM ", x, con = con)
<SQL> SELECT * FROM 'TABLE'
> build_sql("SELECT * FROM ", ident(x), con = con)
<SQL> SELECT * FROM `TABLE`
> build_sql("SELECT * FROM ", sql(x), con = con)
<SQL> SELECT * FROM TABLE
> 
> # http://xkcd.com/327/
> name <- "Robert'); DROP TABLE Students;--"
> build_sql("INSERT INTO Students (Name) VALUES (", name, ")", con = con)
<SQL> INSERT INTO Students (Name) VALUES ('Robert''); DROP TABLE Students;--')
> 
> 
> 
> cleanEx()
> nameEx("collapse.tbl_sql")
> ### * collapse.tbl_sql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: collapse.tbl_sql
> ### Title: Compute results of a query
> ### Aliases: collapse.tbl_sql compute.tbl_sql collect.tbl_sql
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(a = c(3, 4, 1, 2), b = c(5, 1, 2, NA))
> db %>% filter(a <= 2) %>% collect()
# A tibble: 2 × 2
      a     b
  <dbl> <dbl>
1     1     2
2     2    NA
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("complete.tbl_lazy")
> ### * complete.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complete.tbl_lazy
> ### Title: Complete a SQL table with missing combinations of data
> ### Aliases: complete.tbl_lazy
> 
> ### ** Examples
> 
> ## Don't show: 
> if (rlang::is_installed("tidyr", version = "1.0.0")) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ df <- memdb_frame(
+   group = c(1:2, 1),
+   item_id = c(1:2, 2),
+   item_name = c("a", "b", "b"),
+   value1 = 1:3,
+   value2 = 4:6
+ )
+ 
+ df %>% tidyr::complete(group, nesting(item_id, item_name))
+ 
+ # You can also choose to fill in missing values
+ df %>% tidyr::complete(group, nesting(item_id, item_name), fill = list(value1 = 0))
+ ## Don't show: 
+ }) # examplesIf
> df <- memdb_frame(group = c(1:2, 1), item_id = c(1:2, 2), item_name = c("a", 
+     "b", "b"), value1 = 1:3, value2 = 4:6)
> df %>% tidyr::complete(group, nesting(item_id, item_name))
# Source:   SQL [?? x 5]
# Database: sqlite 3.47.1 [:memory:]
  group item_id item_name value1 value2
  <dbl>   <dbl> <chr>      <int>  <int>
1     1       1 a              1      4
2     1       2 b              3      6
3     2       1 a             NA     NA
4     2       2 b              2      5
> df %>% tidyr::complete(group, nesting(item_id, item_name), fill = list(value1 = 0))
# Source:   SQL [?? x 5]
# Database: sqlite 3.47.1 [:memory:]
  group item_id item_name value1 value2
  <dbl>   <dbl> <chr>      <dbl>  <int>
1     1       1 a              1      4
2     1       2 b              3      6
3     2       1 a              0     NA
4     2       2 b              2      5
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘dbplyr_cache’

> nameEx("copy_inline")
> ### * copy_inline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: copy_inline
> ### Title: Use a local data frame in a dbplyr query
> ### Aliases: copy_inline
> 
> ### ** Examples
> 
> df <- data.frame(x = 1:3, y = c("a", "b", "c"))
> con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
> 
> copy_inline(con, df)
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
      x y    
  <int> <chr>
1     1 a    
2     2 b    
3     3 c    
> 
> copy_inline(con, df) %>% dplyr::show_query()
<SQL>
SELECT CAST(`x` AS INTEGER) AS `x`, CAST(`y` AS TEXT) AS `y`
FROM (
  SELECT NULL AS `x`, NULL AS `y`
  WHERE (0 = 1)

  UNION ALL

  VALUES (1, 'a'), (2, 'b'), (3, 'c')
) AS `values_table`
> 
> 
> 
> cleanEx()
> nameEx("copy_to.src_sql")
> ### * copy_to.src_sql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: copy_to.src_sql
> ### Title: Copy a local data frame to a remote database
> ### Aliases: copy_to.src_sql
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> df <- data.frame(x = 1:5, y = letters[5:1])
> db <- copy_to(src_memdb(), df)
> db
# Source:   table<`df`> [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
      x y    
  <int> <chr>
1     1 e    
2     2 d    
3     3 c    
4     4 b    
5     5 a    
> 
> df2 <- data.frame(y = c("a", "d"), fruit = c("apple", "date"))
> # copy_to() is called automatically if you set copy = TRUE
> # in the join functions
> db %>% left_join(df2, copy = TRUE)
Joining with `by = join_by(y)`
# Source:   SQL [?? x 3]
# Database: sqlite 3.47.1 [:memory:]
      x y     fruit
  <int> <chr> <chr>
1     1 e     <NA> 
2     2 d     date 
3     3 c     <NA> 
4     4 b     <NA> 
5     5 a     apple
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("count.tbl_lazy")
> ### * count.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: count.tbl_lazy
> ### Title: Count observations by group
> ### Aliases: count.tbl_lazy add_count.tbl_lazy tally.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2))
> db %>% count(g) %>% show_query()
<SQL>
SELECT `g`, COUNT(*) AS `n`
FROM `dbplyr_4dMaH8wQnr`
GROUP BY `g`
> db %>% count(g, wt = x) %>% show_query()
<SQL>
SELECT `g`, SUM(`x`) AS `n`
FROM `dbplyr_4dMaH8wQnr`
GROUP BY `g`
> db %>% count(g, wt = x, sort = TRUE) %>% show_query()
<SQL>
SELECT `g`, SUM(`x`) AS `n`
FROM `dbplyr_4dMaH8wQnr`
GROUP BY `g`
ORDER BY `n` DESC
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("db-quote")
> ### * db-quote
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: db-quote
> ### Title: SQL escaping/quoting generics
> ### Aliases: sql_escape_logical sql_escape_date sql_escape_datetime
> ###   sql_escape_raw
> ### Keywords: internal
> 
> ### ** Examples
> 
> con <- simulate_dbi()
> sql_escape_logical(con, c(TRUE, FALSE, NA))
[1] "TRUE"  "FALSE" "NULL" 
> sql_escape_date(con, Sys.Date())
[1] "'2025-01-07'"
> sql_escape_date(con, Sys.time())
[1] "'2025-01-07 09:53:49.360547'"
> sql_escape_raw(con, charToRaw("hi"))
[1] "X'6869'"
> 
> 
> 
> cleanEx()
> nameEx("dbplyr-slice")
> ### * dbplyr-slice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dbplyr-slice
> ### Title: Subset rows using their positions
> ### Aliases: slice_min.tbl_lazy slice_max.tbl_lazy slice_sample.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(x = 1:3, y = c(1, 1, 2))
> db %>% slice_min(x) %>% show_query()
<SQL>
SELECT `x`, `y`
FROM (
  SELECT `dbplyr_4dMaH8wQnr`.*, RANK() OVER (ORDER BY `x`) AS `col01`
  FROM `dbplyr_4dMaH8wQnr`
) AS `q01`
WHERE (`col01` <= 1)
> db %>% slice_max(x) %>% show_query()
<SQL>
SELECT `x`, `y`
FROM (
  SELECT `dbplyr_4dMaH8wQnr`.*, RANK() OVER (ORDER BY `x` DESC) AS `col01`
  FROM `dbplyr_4dMaH8wQnr`
) AS `q01`
WHERE (`col01` <= 1)
> db %>% slice_sample() %>% show_query()
<SQL>
SELECT `x`, `y`
FROM (
  SELECT
    `dbplyr_4dMaH8wQnr`.*,
    ROW_NUMBER() OVER (ORDER BY (0.5 + RANDOM() / 18446744073709551616.0)) AS `col01`
  FROM `dbplyr_4dMaH8wQnr`
) AS `q01`
WHERE (`col01` <= 1)
> 
> db %>% group_by(y) %>% slice_min(x) %>% show_query()
<SQL>
SELECT `x`, `y`
FROM (
  SELECT
    `dbplyr_4dMaH8wQnr`.*,
    RANK() OVER (PARTITION BY `y` ORDER BY `x`) AS `col01`
  FROM `dbplyr_4dMaH8wQnr`
) AS `q01`
WHERE (`col01` <= 1)
> 
> # By default, ties are includes so you may get more rows
> # than you expect
> db %>% slice_min(y, n = 1)
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
      x     y
  <int> <dbl>
1     1     1
2     2     1
> db %>% slice_min(y, n = 1, with_ties = FALSE)
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
      x     y
  <int> <dbl>
1     1     1
> 
> # Non-integer group sizes are rounded down
> db %>% slice_min(x, prop = 0.5)
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
      x     y
  <int> <dbl>
1     1     1
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("dbplyr_uncount")
> ### * dbplyr_uncount
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dbplyr_uncount
> ### Title: "Uncount" a database table
> ### Aliases: dbplyr_uncount
> 
> ### ** Examples
> 
> df <- memdb_frame(x = c("a", "b"), n = c(1, 2))
> dbplyr_uncount(df, n)
# Source:   SQL [?? x 1]
# Database: sqlite 3.47.1 [:memory:]
  x    
  <chr>
1 a    
2 b    
3 b    
> dbplyr_uncount(df, n, .id = "id")
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
  x        id
  <chr> <int>
1 a         1
2 b         1
3 b         2
> 
> # You can also use constants
> dbplyr_uncount(df, 2)
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
  x         n
  <chr> <dbl>
1 a         1
2 a         1
3 b         2
4 b         2
> 
> # Or expressions
> dbplyr_uncount(df, 2 / n)
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
  x         n
  <chr> <dbl>
1 a         1
2 a         1
3 b         2
> 
> 
> 
> cleanEx()

detaching ‘dbplyr_cache’

> nameEx("distinct.tbl_lazy")
> ### * distinct.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distinct.tbl_lazy
> ### Title: Subset distinct/unique rows
> ### Aliases: distinct.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(x = c(1, 1, 2, 2), y = c(1, 2, 1, 1))
> db %>% distinct() %>% show_query()
<SQL>
SELECT DISTINCT `dbplyr_4dMaH8wQnr`.*
FROM `dbplyr_4dMaH8wQnr`
> db %>% distinct(x) %>% show_query()
<SQL>
SELECT DISTINCT `x`
FROM `dbplyr_4dMaH8wQnr`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("escape")
> ### * escape
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: escape
> ### Title: Escape/quote a string.
> ### Aliases: escape escape_ansi sql_vector
> 
> ### ** Examples
> 
> # Doubles vs. integers
> escape_ansi(1:5)
<SQL> (12345)
> escape_ansi(c(1, 5.4))
<SQL> (1.05.4)
> 
> # String vs known sql vs. sql identifier
> escape_ansi("X")
<SQL> 'X'
> escape_ansi(sql("X"))
<SQL> X
> escape_ansi(ident("X"))
<SQL> `X`
> 
> # Escaping is idempotent
> escape_ansi("X")
<SQL> 'X'
> escape_ansi(escape_ansi("X"))
<SQL> 'X'
> escape_ansi(escape_ansi(escape_ansi("X")))
<SQL> 'X'
> 
> 
> 
> cleanEx()
> nameEx("expand.tbl_lazy")
> ### * expand.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand.tbl_lazy
> ### Title: Expand SQL tables to include all possible combinations of values
> ### Aliases: expand.tbl_lazy
> 
> ### ** Examples
> 
> ## Don't show: 
> if (rlang::is_installed("tidyr", version = "1.0.0")) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ fruits <- memdb_frame(
+   type   = c("apple", "orange", "apple", "orange", "orange", "orange"),
+   year   = c(2010, 2010, 2012, 2010, 2010, 2012),
+   size = c("XS", "S",  "M", "S", "S", "M"),
+   weights = rnorm(6)
+ )
+ 
+ # All possible combinations ---------------------------------------
+ fruits %>% tidyr::expand(type)
+ fruits %>% tidyr::expand(type, size)
+ 
+ # Only combinations that already appear in the data ---------------
+ fruits %>% tidyr::expand(nesting(type, size))
+ ## Don't show: 
+ }) # examplesIf
> fruits <- memdb_frame(type = c("apple", "orange", "apple", "orange", "orange", 
+     "orange"), year = c(2010, 2010, 2012, 2010, 2010, 2012), size = c("XS", "S", 
+     "M", "S", "S", "M"), weights = rnorm(6))
> fruits %>% tidyr::expand(type)
# Source:   SQL [?? x 1]
# Database: sqlite 3.47.1 [:memory:]
  type  
  <chr> 
1 apple 
2 orange
> fruits %>% tidyr::expand(type, size)
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
  type   size 
  <chr>  <chr>
1 apple  XS   
2 apple  S    
3 apple  M    
4 orange XS   
5 orange S    
6 orange M    
> fruits %>% tidyr::expand(nesting(type, size))
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
  type   size 
  <chr>  <chr>
1 apple  XS   
2 orange S    
3 apple  M    
4 orange M    
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘dbplyr_cache’

> nameEx("fill.tbl_lazy")
> ### * fill.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fill.tbl_lazy
> ### Title: Fill in missing values with previous or next value
> ### Aliases: fill.tbl_lazy
> 
> ### ** Examples
> 
> ## Don't show: 
> if (rlang::is_installed("tidyr", version = "1.0.0")) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ squirrels <- tibble::tribble(
+   ~group,    ~name,     ~role,     ~n_squirrels, ~ n_squirrels2,
+   1,      "Sam",    "Observer",   NA,                 1,
+   1,     "Mara", "Scorekeeper",    8,                NA,
+   1,    "Jesse",    "Observer",   NA,                NA,
+   1,      "Tom",    "Observer",   NA,                 4,
+   2,     "Mike",    "Observer",   NA,                NA,
+   2,  "Rachael",    "Observer",   NA,                 6,
+   2,  "Sydekea", "Scorekeeper",   14,                NA,
+   2, "Gabriela",    "Observer",   NA,                NA,
+   3,  "Derrick",    "Observer",   NA,                NA,
+   3,     "Kara", "Scorekeeper",    9,                 10,
+   3,    "Emily",    "Observer",   NA,                NA,
+   3, "Danielle",    "Observer",   NA,                NA
+ )
+ squirrels$id <- 1:12
+ 
+ tbl_memdb(squirrels) %>%
+   window_order(id) %>%
+   tidyr::fill(
+     n_squirrels,
+     n_squirrels2,
+   )
+ ## Don't show: 
+ }) # examplesIf
> squirrels <- tibble::tribble(~group, ~name, ~role, ~n_squirrels, ~n_squirrels2, 
+     1, "Sam", "Observer", NA, 1, 1, "Mara", "Scorekeeper", 8, NA, 1, "Jesse", "Observer", 
+     NA, NA, 1, "Tom", "Observer", NA, 4, 2, "Mike", "Observer", NA, NA, 2, "Rachael", 
+     "Observer", NA, 6, 2, "Sydekea", "Scorekeeper", 14, NA, 2, "Gabriela", "Observer", 
+     NA, NA, 3, "Derrick", "Observer", NA, NA, 3, "Kara", "Scorekeeper", 9, 10, 3, 
+     "Emily", "Observer", NA, NA, 3, "Danielle", "Observer", NA, NA)
> squirrels$id <- 1:12
> tbl_memdb(squirrels) %>% window_order(id) %>% tidyr::fill(n_squirrels, 
+     n_squirrels2, )
# Source:     SQL [?? x 6]
# Database:   sqlite 3.47.1 [:memory:]
# Ordered by: id
   group name     role        n_squirrels n_squirrels2    id
   <dbl> <chr>    <chr>             <dbl>        <dbl> <int>
 1     1 Sam      Observer             NA            1     1
 2     1 Mara     Scorekeeper           8            1     2
 3     1 Jesse    Observer              8            1     3
 4     1 Tom      Observer              8            4     4
 5     2 Mike     Observer              8            4     5
 6     2 Rachael  Observer              8            6     6
 7     2 Sydekea  Scorekeeper          14            6     7
 8     2 Gabriela Observer             14            6     8
 9     3 Derrick  Observer             14            6     9
10     3 Kara     Scorekeeper           9           10    10
# ℹ more rows
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘dbplyr_cache’

> nameEx("filter.tbl_lazy")
> ### * filter.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: filter.tbl_lazy
> ### Title: Subset rows using column values
> ### Aliases: filter.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(x = c(2, NA, 5, NA, 10), y = 1:5)
> db %>% filter(x < 5) %>% show_query()
<SQL>
SELECT `dbplyr_4dMaH8wQnr`.*
FROM `dbplyr_4dMaH8wQnr`
WHERE (`x` < 5.0)
> db %>% filter(is.na(x)) %>% show_query()
<SQL>
SELECT `dbplyr_4dMaH8wQnr`.*
FROM `dbplyr_4dMaH8wQnr`
WHERE ((`x` IS NULL))
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("get_returned_rows")
> ### * get_returned_rows
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_returned_rows
> ### Title: Extract and check the 'RETURNING' rows
> ### Aliases: get_returned_rows has_returned_rows
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:dbplyr’:

    ident, sql

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> 
> con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
> DBI::dbExecute(con, "CREATE TABLE Info (
+    id INTEGER PRIMARY KEY AUTOINCREMENT,
+    number INTEGER
+ )")
[1] 0
> info <- tbl(con, "Info")
> 
> rows1 <- copy_inline(con, data.frame(number = c(1, 5)))
> rows_insert(info, rows1, conflict = "ignore", in_place = TRUE)
Matching, by = "number"
> info
# Source:   table<`Info`> [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
     id number
  <int>  <int>
1     1      1
2     2      5
> 
> # If the table has an auto incrementing primary key, you can use
> # the returning argument + `get_returned_rows()` its value
> rows2 <- copy_inline(con, data.frame(number = c(13, 27)))
> info <- rows_insert(
+   info,
+   rows2,
+   conflict = "ignore",
+   in_place = TRUE,
+   returning = id
+ )
Matching, by = "number"
> info
# Source:   table<`Info`> [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
     id number
  <int>  <int>
1     1      1
2     2      5
3     3     13
4     4     27
> get_returned_rows(info)
# A tibble: 2 × 1
     id
  <int>
1     3
2     4
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("group_by.tbl_lazy")
> ### * group_by.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: group_by.tbl_lazy
> ### Title: Group by one or more variables
> ### Aliases: group_by.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2))
> db %>%
+   group_by(g) %>%
+   summarise(n()) %>%
+   show_query()
<SQL>
SELECT `g`, COUNT(*) AS `n()`
FROM `dbplyr_4dMaH8wQnr`
GROUP BY `g`
> 
> db %>%
+   group_by(g) %>%
+   mutate(x2 = x / sum(x, na.rm = TRUE)) %>%
+   show_query()
<SQL>
SELECT `dbplyr_4dMaH8wQnr`.*, `x` / SUM(`x`) OVER (PARTITION BY `g`) AS `x2`
FROM `dbplyr_4dMaH8wQnr`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("head.tbl_lazy")
> ### * head.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: head.tbl_lazy
> ### Title: Subset the first rows
> ### Aliases: head.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(x = 1:100)
> db %>% head() %>% show_query()
<SQL>
SELECT `dbplyr_4dMaH8wQnr`.*
FROM `dbplyr_4dMaH8wQnr`
LIMIT 6
> 
> # Pretend we have data in a SQL server database
> db2 <- lazy_frame(x = 1:100, con = simulate_mssql())
> db2 %>% head() %>% show_query()
<SQL>
SELECT TOP 6 `df`.*
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("ident")
> ### * ident
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ident
> ### Title: Flag a character vector as SQL identifiers
> ### Aliases: ident is.ident
> ### Keywords: internal
> 
> ### ** Examples
> 
> # SQL92 quotes strings with '
> escape_ansi("x")
<SQL> 'x'
> 
> # And identifiers with "
> ident("x")
<IDENT> x
> escape_ansi(ident("x"))
<SQL> `x`
> 
> # You can supply multiple inputs
> ident(a = "x", b = "y")
<IDENT> x
<IDENT> y
> ident_q(a = "x", b = "y")
<IDENT> x
<IDENT> y
> 
> 
> 
> cleanEx()
> nameEx("in_schema")
> ### * in_schema
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: in_schema
> ### Title: Refer to a table in another schema/catalog
> ### Aliases: in_schema in_catalog
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Previously:
> in_schema("my_schema", "my_table")
<SCHEMA> `my_schema`.`my_table`
> in_catalog("my_catalog", "my_schema", "my_table")
<CATALOG> `my_catalog`.`my_schema`.`my_table`
> in_schema(sql("my_schema"), sql("my_table"))
<SCHEMA> my_schema.my_table
> 
> # Now
> I("my_schema.my_table")
[1] "my_schema.my_table"
> I("my_catalog.my_schema.my_table")
[1] "my_catalog.my_schema.my_table"
> I("my_schema.my_table")
[1] "my_schema.my_table"
> 
> # Example using schemas with SQLite
> con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
> 
> # Add auxiliary schema
> tmp <- tempfile()
> DBI::dbExecute(con, paste0("ATTACH '", tmp, "' AS aux"))
[1] 0
> 
> library(dplyr, warn.conflicts = FALSE)
> copy_to(con, iris, "df", temporary = FALSE)
> copy_to(con, mtcars, I("aux.df"), temporary = FALSE)
> 
> con %>% tbl("df")
# Source:   table<`df`> [?? x 5]
# Database: sqlite 3.47.1 [:memory:]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <chr>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ more rows
> con %>% tbl(I("aux.df"))
# Source:   table<aux.df> [?? x 11]
# Database: sqlite 3.47.1 [:memory:]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ more rows
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("join.tbl_sql")
> ### * join.tbl_sql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: join.tbl_sql
> ### Title: Join SQL tables
> ### Aliases: join.tbl_sql inner_join.tbl_lazy left_join.tbl_lazy
> ###   right_join.tbl_lazy full_join.tbl_lazy cross_join.tbl_lazy
> ###   semi_join.tbl_lazy anti_join.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> band_db <- tbl_memdb(dplyr::band_members)
> instrument_db <- tbl_memdb(dplyr::band_instruments)
> band_db %>% left_join(instrument_db) %>% show_query()
Joining with `by = join_by(name)`
<SQL>
SELECT `dplyr::band_members`.*, `plays`
FROM `dplyr::band_members`
LEFT JOIN `dplyr::band_instruments`
  ON (`dplyr::band_members`.`name` = `dplyr::band_instruments`.`name`)
> 
> # Can join with local data frames by setting copy = TRUE
> band_db %>%
+   left_join(dplyr::band_instruments, copy = TRUE)
Joining with `by = join_by(name)`
# Source:   SQL [?? x 3]
# Database: sqlite 3.47.1 [:memory:]
  name  band    plays 
  <chr> <chr>   <chr> 
1 Mick  Stones  <NA>  
2 John  Beatles guitar
3 Paul  Beatles bass  
> 
> # Unlike R, joins in SQL don't usually match NAs (NULLs)
> db <- memdb_frame(x = c(1, 2, NA))
> label <- memdb_frame(x = c(1, NA), label = c("one", "missing"))
> db %>% left_join(label, by = "x")
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
      x label
  <dbl> <chr>
1     1 one  
2     2 <NA> 
3    NA <NA> 
> # But you can activate R's usual behaviour with the na_matches argument
> db %>% left_join(label, by = "x", na_matches = "na")
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
      x label  
  <dbl> <chr>  
1     1 one    
2     2 <NA>   
3    NA missing
> 
> # By default, joins are equijoins, but you can use `sql_on` to
> # express richer relationships
> db1 <- memdb_frame(x = 1:5)
> db2 <- memdb_frame(x = 1:3, y = letters[1:3])
> db1 %>% left_join(db2) %>% show_query()
Joining with `by = join_by(x)`
<SQL>
SELECT `dbplyr_szIQaCnvfB`.`x` AS `x`, `y`
FROM `dbplyr_szIQaCnvfB`
LEFT JOIN `dbplyr_2UAgUt4xY0`
  ON (`dbplyr_szIQaCnvfB`.`x` = `dbplyr_2UAgUt4xY0`.`x`)
> db1 %>% left_join(db2, sql_on = "LHS.x < RHS.x") %>% show_query()
<SQL>
SELECT `LHS`.`x` AS `x.x`, `RHS`.`x` AS `x.y`, `y`
FROM `dbplyr_szIQaCnvfB` AS `LHS`
LEFT JOIN `dbplyr_2UAgUt4xY0` AS `RHS`
  ON (LHS.x < RHS.x)
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("lahman")
> ### * lahman
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lahman
> ### Title: Cache and retrieve an 'src_sqlite' of the Lahman baseball
> ###   database.
> ### Aliases: lahman lahman_sqlite lahman_postgres lahman_mysql copy_lahman
> ###   has_lahman lahman_srcs
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Connect to a local sqlite database, if already created
> 
> 
> 
> cleanEx()
> nameEx("memdb_frame")
> ### * memdb_frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: memdb_frame
> ### Title: Create a database table in temporary in-memory database.
> ### Aliases: memdb_frame tbl_memdb src_memdb
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:dbplyr’:

    ident, sql

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> df <- memdb_frame(x = runif(100), y = runif(100))
> df %>% arrange(x)
# Source:     SQL [?? x 2]
# Database:   sqlite 3.47.1 [:memory:]
# Ordered by: x
        x     y
    <dbl> <dbl>
 1 0.0134 0.511
 2 0.0233 0.175
 3 0.0589 0.389
 4 0.0618 0.599
 5 0.0707 0.500
 6 0.0842 0.724
 7 0.0995 0.181
 8 0.108  0.526
 9 0.122  0.724
10 0.126  0.173
# ℹ more rows
> df %>% arrange(x) %>% show_query()
<SQL>
SELECT `dbplyr_75mzHbsqHk`.*
FROM `dbplyr_75mzHbsqHk`
ORDER BY `x`
> 
> mtcars_db <- tbl_memdb(mtcars)
> mtcars_db %>% group_by(cyl) %>% summarise(n = n()) %>% show_query()
<SQL>
SELECT `cyl`, COUNT(*) AS `n`
FROM `mtcars`
GROUP BY `cyl`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("mutate.tbl_lazy")
> ### * mutate.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mutate.tbl_lazy
> ### Title: Create, modify, and delete columns
> ### Aliases: mutate.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(x = 1:5, y = 5:1)
> db %>%
+   mutate(a = (x + y) / 2, b = sqrt(x^2L + y^2L)) %>%
+   show_query()
<SQL>
SELECT
  `dbplyr_4dMaH8wQnr`.*,
  (`x` + `y`) / 2.0 AS `a`,
  SQRT((POWER(`x`, 2)) + POWER(`y`, 2)) AS `b`
FROM `dbplyr_4dMaH8wQnr`
> 
> # dbplyr automatically creates subqueries as needed
> db %>%
+   mutate(x1 = x + 1, x2 = x1 * 2) %>%
+   show_query()
<SQL>
SELECT `q01`.*, `x1` * 2.0 AS `x2`
FROM (
  SELECT `dbplyr_4dMaH8wQnr`.*, `x` + 1.0 AS `x1`
  FROM `dbplyr_4dMaH8wQnr`
) AS `q01`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("partial_eval")
> ### * partial_eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: partial_eval
> ### Title: Partially evaluate an expression.
> ### Aliases: partial_eval
> ### Keywords: internal
> 
> ### ** Examples
> 
> lf <- lazy_frame(year = 1980, id = 1)
> partial_eval(quote(year > 1980), data = lf)
year > 1980
> 
> ids <- c("ansonca01", "forceda01", "mathebo01")
> partial_eval(quote(id %in% ids), lf)
id %in% c("ansonca01", "forceda01", "mathebo01")
> 
> # cf.
> partial_eval(quote(id == .data$id), lf)
id == id
> 
> # You can use local() or .env to disambiguate between local and remote
> # variables: otherwise remote is always preferred
> year <- 1980
> partial_eval(quote(year > year), lf)
year > year
> partial_eval(quote(year > local(year)), lf)
year > 1980
> partial_eval(quote(year > .env$year), lf)
year > 1980
> 
> # Functions are always assumed to be remote. Use local to force evaluation
> # in R.
> f <- function(x) x + 1
> partial_eval(quote(year > f(1980)), lf)
year > f(1980)
> partial_eval(quote(year > local(f(1980))), lf)
year > 1981
> 
> 
> 
> cleanEx()
> nameEx("pivot_longer.tbl_lazy")
> ### * pivot_longer.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pivot_longer.tbl_lazy
> ### Title: Pivot data from wide to long
> ### Aliases: pivot_longer.tbl_lazy
> 
> ### ** Examples
> 
> ## Don't show: 
> if (rlang::is_installed("tidyr", version = "1.0.0")) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # See vignette("pivot") for examples and explanation
+ 
+ # Simplest case where column names are character data
+ memdb_frame(
+   id = c("a", "b"),
+   x = 1:2,
+   y = 3:4
+ ) %>%
+   tidyr::pivot_longer(-id)
+ ## Don't show: 
+ }) # examplesIf
> memdb_frame(id = c("a", "b"), x = 1:2, y = 3:4) %>% tidyr::pivot_longer(-id)
# Source:   SQL [?? x 3]
# Database: sqlite 3.47.1 [:memory:]
  id    name  value
  <chr> <chr> <int>
1 a     x         1
2 b     x         2
3 a     y         3
4 b     y         4
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘dbplyr_cache’

> nameEx("pivot_wider.tbl_lazy")
> ### * pivot_wider.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pivot_wider.tbl_lazy
> ### Title: Pivot data from long to wide
> ### Aliases: pivot_wider.tbl_lazy dbplyr_pivot_wider_spec
> 
> ### ** Examples
> 
> ## Don't show: 
> if (rlang::is_installed("tidyr", version = "1.0.0")) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ memdb_frame(
+   id = 1,
+   key = c("x", "y"),
+   value = 1:2
+ ) %>%
+   tidyr::pivot_wider(
+     id_cols = id,
+     names_from = key,
+     values_from = value
+   )
+ ## Don't show: 
+ }) # examplesIf
> memdb_frame(id = 1, key = c("x", "y"), value = 1:2) %>% tidyr::pivot_wider(id_cols = id, 
+     names_from = key, values_from = value)
# Source:   SQL [?? x 3]
# Database: sqlite 3.47.1 [:memory:]
     id     x     y
  <dbl> <int> <int>
1     1     1     2
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘dbplyr_cache’

> nameEx("pull.tbl_sql")
> ### * pull.tbl_sql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pull.tbl_sql
> ### Title: Extract a single column
> ### Aliases: pull.tbl_sql
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(x = 1:5, y = 5:1)
> db %>%
+   mutate(z = x + y * 2) %>%
+   pull()
[1] 11 10  9  8  7
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("remote_name")
> ### * remote_name
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: remote_name
> ### Title: Metadata about a remote table
> ### Aliases: remote_name remote_table remote_src remote_con remote_query
> ###   remote_query_plan
> 
> ### ** Examples
> 
> mf <- memdb_frame(x = 1:5, y = 5:1, .name = "blorp")
> remote_name(mf)
[1] "blorp"
> remote_src(mf)
src:  sqlite 3.47.1 [:memory:]
tbls: blorp, sqlite_stat1, sqlite_stat4
> remote_con(mf)
<SQLiteConnection>
  Path: :memory:
  Extensions: TRUE
> remote_query(mf)
<SQL> SELECT *
FROM `blorp`
> 
> mf2 <- dplyr::filter(mf, x > 3)
> remote_name(mf2)
NULL
> remote_src(mf2)
src:  sqlite 3.47.1 [:memory:]
tbls: blorp, sqlite_stat1, sqlite_stat4
> remote_con(mf2)
<SQLiteConnection>
  Path: :memory:
  Extensions: TRUE
> remote_query(mf2)
<SQL> SELECT `blorp`.*
FROM `blorp`
WHERE (`x` > 3.0)
> 
> 
> 
> cleanEx()

detaching ‘dbplyr_cache’

> nameEx("replace_na.tbl_lazy")
> ### * replace_na.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: replace_na.tbl_lazy
> ### Title: Replace NAs with specified values
> ### Aliases: replace_na.tbl_lazy
> 
> ### ** Examples
> 
> ## Don't show: 
> if (rlang::is_installed("tidyr", version = "1.0.0")) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ df <- memdb_frame(x = c(1, 2, NA), y = c("a", NA, "b"))
+ df %>% tidyr::replace_na(list(x = 0, y = "unknown"))
+ ## Don't show: 
+ }) # examplesIf
> df <- memdb_frame(x = c(1, 2, NA), y = c("a", NA, "b"))
> df %>% tidyr::replace_na(list(x = 0, y = "unknown"))
# Source:   SQL [?? x 2]
# Database: sqlite 3.47.1 [:memory:]
      x y      
  <dbl> <chr>  
1     1 a      
2     2 unknown
3     0 b      
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘dbplyr_cache’

> nameEx("rows-db")
> ### * rows-db
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rows_insert.tbl_lazy
> ### Title: Edit individual rows in the underlying database table
> ### Aliases: rows_insert.tbl_lazy rows_append.tbl_lazy rows_update.tbl_lazy
> ###   rows_patch.tbl_lazy rows_upsert.tbl_lazy rows_delete.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:dbplyr’:

    ident, sql

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> 
> con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
> DBI::dbExecute(con, "CREATE TABLE Ponies (
+    id INTEGER PRIMARY KEY AUTOINCREMENT,
+    name TEXT,
+    cutie_mark TEXT
+ )")
[1] 0
> 
> ponies <- tbl(con, "Ponies")
> 
> applejack <- copy_inline(con, data.frame(
+   name = "Apple Jack",
+   cutie_mark = "three apples"
+ ))
> 
> # The default behavior is to generate a SELECT query
> rows_insert(ponies, applejack, conflict = "ignore")
Matching, by = "name"
# Source:   SQL [?? x 3]
# Database: sqlite 3.47.1 [:memory:]
  id    name       cutie_mark  
  <lgl> <chr>      <chr>       
1 NA    Apple Jack three apples
> # And the original table is left unchanged:
> ponies
# Source:   table<`Ponies`> [?? x 3]
# Database: sqlite 3.47.1 [:memory:]
# ℹ 3 variables: id <int>, name <chr>, cutie_mark <chr>
> 
> # You can also choose to modify the table with in_place = TRUE:
> rows_insert(ponies, applejack, conflict = "ignore", in_place = TRUE)
Matching, by = "name"
> # In this case `rows_insert()` returns nothing and the underlying
> # data is modified
> ponies
# Source:   table<`Ponies`> [?? x 3]
# Database: sqlite 3.47.1 [:memory:]
     id name       cutie_mark  
  <int> <chr>      <chr>       
1     1 Apple Jack three apples
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("select.tbl_lazy")
> ### * select.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: select.tbl_lazy
> ### Title: Subset, rename, and reorder columns using their names
> ### Aliases: select.tbl_lazy rename.tbl_lazy rename_with.tbl_lazy
> ###   relocate.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(x = 1, y = 2, z = 3)
> db %>% select(-y) %>% show_query()
<SQL>
SELECT `x`, `z`
FROM `dbplyr_4dMaH8wQnr`
> db %>% relocate(z) %>% show_query()
<SQL>
SELECT `z`, `x`, `y`
FROM `dbplyr_4dMaH8wQnr`
> db %>% rename(first = x, last = z) %>% show_query()
<SQL>
SELECT `x` AS `first`, `y`, `z` AS `last`
FROM `dbplyr_4dMaH8wQnr`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("sql_expr")
> ### * sql_expr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sql_expr
> ### Title: Generate SQL from R expressions
> ### Aliases: sql_expr sql_call2
> ### Keywords: internal
> 
> ### ** Examples
> 
> con <- simulate_dbi() # not necessary when writing translations
> 
> sql_expr(f(x + 1), con = con)
<SQL> F(x + 1.0)
> sql_expr(f("x", "y"), con = con)
<SQL> F('x', 'y')
> sql_expr(f(x, y), con = con)
<SQL> F(x, y)
> 
> x <- ident("x")
> sql_expr(f(!!x, y), con = con)
<SQL> F(`x`, y)
> 
> sql_expr(cast("x" %as% DECIMAL), con = con)
<SQL> CAST('x' AS DECIMAL)
> sql_expr(round(x) %::% numeric, con = con)
<SQL> ROUND(x) :: numeric
> 
> sql_call2("+", quote(x), 1, con = con)
<SQL> x + 1.0
> sql_call2("+", "x", 1, con = con)
<SQL> 'x' + 1.0
> 
> 
> 
> cleanEx()
> nameEx("sql_options")
> ### * sql_options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sql_options
> ### Title: Options for generating SQL
> ### Aliases: sql_options
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> lf1 <- lazy_frame(key = 1, a = 1, b = 2)
> lf2 <- lazy_frame(key = 1, a = 1, c = 3)
> 
> result <- left_join(lf1, lf2, by = "key") %>%
+   filter(c >= 3)
> 
> show_query(result)
<SQL>
SELECT `q01`.*
FROM (
  SELECT
    `df_LHS`.`key` AS `key`,
    `df_LHS`.`a` AS `a.x`,
    `b`,
    `df_RHS`.`a` AS `a.y`,
    `c`
  FROM `df` AS `df_LHS`
  LEFT JOIN `df` AS `df_RHS`
    ON (`df_LHS`.`key` = `df_RHS`.`key`)
) AS `q01`
WHERE (`c` >= 3.0)
> sql_options <- sql_options(cte = TRUE, qualify_all_columns = TRUE)
> show_query(result, sql_options = sql_options)
<SQL>
WITH `q01` AS (
  SELECT
    `df_LHS`.`key` AS `key`,
    `df_LHS`.`a` AS `a.x`,
    `df_LHS`.`b` AS `b`,
    `df_RHS`.`a` AS `a.y`,
    `df_RHS`.`c` AS `c`
  FROM `df` AS `df_LHS`
  LEFT JOIN `df` AS `df_RHS`
    ON (`df_LHS`.`key` = `df_RHS`.`key`)
)
SELECT `q01`.*
FROM `q01`
WHERE (`c` >= 3.0)
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("sql_query_insert")
> ### * sql_query_insert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sql_query_insert
> ### Title: Generate SQL for Insert, Update, Upsert, and Delete
> ### Aliases: sql_query_insert sql_query_append sql_query_update_from
> ###   sql_query_upsert sql_query_delete
> 
> ### ** Examples
> 
> sql_query_upsert(
+   con = simulate_postgres(),
+   table = ident("airlines"),
+   from = ident("df"),
+   by = "carrier",
+   update_cols = "name"
+ )
<SQL> INSERT INTO `airlines` (`carrier`, `name`)
SELECT `carrier`, `name`
FROM `df` AS `...y`
WHERE true
ON CONFLICT  (`carrier`)
DO UPDATE
SET `name` = `excluded`.`name`
> 
> 
> 
> cleanEx()
> nameEx("sql_quote")
> ### * sql_quote
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sql_quote
> ### Title: Helper function for quoting sql elements.
> ### Aliases: sql_quote
> ### Keywords: internal
> 
> ### ** Examples
> 
> sql_quote("abc", "'")
[1] "'abc'"
> sql_quote("I've had a good day", "'")
[1] "'I''ve had a good day'"
> sql_quote(c("abc", NA), "'")
[1] "'abc'" "NULL" 
> 
> 
> 
> cleanEx()
> nameEx("sql_variant")
> ### * sql_variant
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sql_substr
> ### Title: Create an sql translator
> ### Aliases: sql_substr sql_str_sub sql_paste sql_paste_infix sql_variant
> ###   sql_translator sql_infix sql_prefix sql_aggregate sql_aggregate_2
> ###   sql_aggregate_n sql_not_supported sql_cast sql_try_cast sql_log
> ###   sql_cot sql_runif base_scalar base_agg base_win base_no_win
> ###   base_odbc_scalar base_odbc_agg base_odbc_win
> ### Keywords: datasets internal
> 
> ### ** Examples
> 
> # An example of adding some mappings for the statistical functions that
> # postgresql provides: http://bit.ly/K5EdTn
> 
> postgres_agg <- sql_translator(.parent = base_agg,
+   cor = sql_aggregate_2("CORR"),
+   cov = sql_aggregate_2("COVAR_SAMP"),
+   sd =  sql_aggregate("STDDEV_SAMP", "sd"),
+   var = sql_aggregate("VAR_SAMP", "var")
+ )
> 
> # Next we have to simulate a connection that uses this variant
> con <- simulate_dbi("TestCon")
> sql_translation.TestCon <- function(x) {
+   sql_variant(
+     base_scalar,
+     postgres_agg,
+     base_no_win
+   )
+ }
> 
> translate_sql(cor(x, y), con = con, window = FALSE)
<SQL> CORR(`x`, `y`)
> translate_sql(sd(income / years), con = con, window = FALSE)
Warning: Missing values are always removed in SQL aggregation functions.
Use `na.rm = TRUE` to silence this warning
This warning is displayed once every 8 hours.
<SQL> STDDEV_SAMP(`income` / `years`)
> 
> # Any functions not explicitly listed in the converter will be translated
> # to sql as is, so you don't need to convert all functions.
> translate_sql(regr_intercept(y, x), con = con)
<SQL> regr_intercept(`y`, `x`)
> 
> 
> 
> cleanEx()
> nameEx("summarise.tbl_lazy")
> ### * summarise.tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summarise.tbl_lazy
> ### Title: Summarise each group to one row
> ### Aliases: summarise.tbl_lazy
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2))
> db %>%
+   summarise(n()) %>%
+   show_query()
<SQL>
SELECT COUNT(*) AS `n()`
FROM `dbplyr_4dMaH8wQnr`
> 
> db %>%
+   group_by(g) %>%
+   summarise(n()) %>%
+   show_query()
<SQL>
SELECT `g`, COUNT(*) AS `n()`
FROM `dbplyr_4dMaH8wQnr`
GROUP BY `g`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("tbl.src_dbi")
> ### * tbl.src_dbi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tbl.src_dbi
> ### Title: Use dplyr verbs with a remote database table
> ### Aliases: tbl.src_dbi tbl_dbi
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:dbplyr’:

    ident, sql

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> 
> # Connect to a temporary in-memory SQLite database
> con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
> 
> # Add some data
> copy_to(con, mtcars)
> DBI::dbListTables(con)
[1] "mtcars"       "sqlite_stat1" "sqlite_stat4"
> 
> # To retrieve a single table from a source, use `tbl()`
> con %>% tbl("mtcars")
# Source:   table<`mtcars`> [?? x 11]
# Database: sqlite 3.47.1 [:memory:]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ more rows
> 
> # Use `I()` for qualified table names
> con %>% tbl(I("temp.mtcars")) %>% head(1)
# Source:   SQL [?? x 11]
# Database: sqlite 3.47.1 [:memory:]
    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1    21     6   160   110   3.9  2.62  16.5     0     1     4     4
> 
> # You can also use pass raw SQL if you want a more sophisticated query
> con %>% tbl(sql("SELECT * FROM mtcars WHERE cyl = 8"))
# Source:   SQL [?? x 11]
# Database: sqlite 3.47.1 [:memory:]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 2  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 3  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3
 4  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3
 5  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
 6  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
 7  10.4     8  460    215  3     5.42  17.8     0     0     3     4
 8  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
 9  15.5     8  318    150  2.76  3.52  16.9     0     0     3     2
10  15.2     8  304    150  3.15  3.44  17.3     0     0     3     2
# ℹ more rows
> 
> # If you just want a temporary in-memory database, use src_memdb()
> src2 <- src_memdb()
> 
> # To show off the full features of dplyr's database integration,
> # we'll use the Lahman database. lahman_sqlite() takes care of
> # creating the database.
> 
> if (requireNamespace("Lahman", quietly = TRUE)) {
+ batting <- copy_to(con, Lahman::Batting)
+ batting
+ 
+ # Basic data manipulation verbs work in the same way as with a tibble
+ batting %>% filter(yearID > 2005, G > 130)
+ batting %>% select(playerID:lgID)
+ batting %>% arrange(playerID, desc(yearID))
+ batting %>% summarise(G = mean(G), n = n())
+ 
+ # There are a few exceptions. For example, databases give integer results
+ # when dividing one integer by another. Multiply by 1 to fix the problem
+ batting %>%
+   select(playerID:lgID, AB, R, G) %>%
+   mutate(
+    R_per_game1 = R / G,
+    R_per_game2 = R * 1.0 / G
+  )
+ 
+ # All operations are lazy: they don't do anything until you request the
+ # data, either by `print()`ing it (which shows the first ten rows),
+ # or by `collect()`ing the results locally.
+ system.time(recent <- filter(batting, yearID > 2010))
+ system.time(collect(recent))
+ 
+ # You can see the query that dplyr creates with show_query()
+ batting %>%
+   filter(G > 0) %>%
+   group_by(playerID) %>%
+   summarise(n = n()) %>%
+   show_query()
+ }
<SQL>
SELECT `playerID`, COUNT(*) AS `n`
FROM (
  SELECT `Lahman::Batting`.*
  FROM `Lahman::Batting`
  WHERE (`G` > 0.0)
) AS `q01`
GROUP BY `playerID`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> nameEx("tbl_lazy")
> ### * tbl_lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tbl_lazy
> ### Title: Create a local lazy tibble
> ### Aliases: tbl_lazy lazy_frame
> ### Keywords: internal
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:dbplyr’:

    ident, sql

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> df <- data.frame(x = 1, y = 2)
> 
> df_sqlite <- tbl_lazy(df, con = simulate_sqlite())
> df_sqlite %>% summarise(x = sd(x, na.rm = TRUE)) %>% show_query()
<SQL>
SELECT STDEV(`x`) AS `x`
FROM `df`
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("testing")
> ### * testing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: testing
> ### Title: Infrastructure for testing dplyr
> ### Aliases: testing test_register_src test_register_con src_test test_load
> ###   test_frame
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Not run: 
> ##D test_register_src("sqlite", {
> ##D   DBI::dbConnect(RSQLite::SQLite(), ":memory:", create = TRUE)
> ##D })
> ##D 
> ##D test_frame(x = 1:3, y = 3:1)
> ##D test_load(mtcars)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("translate_sql")
> ### * translate_sql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: translate_sql
> ### Title: Translate an expression to SQL
> ### Aliases: translate_sql translate_sql_
> 
> ### ** Examples
> 
> con <- simulate_dbi()
> 
> # Regular maths is translated in a very straightforward way
> translate_sql(x + 1, con = con)
<SQL> `x` + 1.0
> translate_sql(sin(x) + tan(y), con = con)
<SQL> SIN(`x`) + TAN(`y`)
> 
> # Note that all variable names are escaped
> translate_sql(like == "x", con = con)
<SQL> `like` = 'x'
> # In ANSI SQL: "" quotes variable _names_, '' quotes strings
> 
> # Logical operators are converted to their sql equivalents
> translate_sql(x < 5 & !(y >= 5), con = con)
<SQL> `x` < 5.0 AND NOT((`y` >= 5.0))
> # xor() doesn't have a direct SQL equivalent
> translate_sql(xor(x, y), con = con)
<SQL> `x` OR `y` AND NOT (`x` AND `y`)
> 
> # If is translated into case when
> translate_sql(if (x > 5) "big" else "small", con = con)
<SQL> CASE WHEN (`x` > 5.0) THEN 'big' WHEN NOT (`x` > 5.0) THEN 'small' END
> 
> # Infix functions are passed onto SQL with % removed
> translate_sql(first %like% "Had%", con = con)
<SQL> `first` like 'Had%'
> translate_sql(first %is% NA, con = con)
<SQL> `first` is NULL
> translate_sql(first %in% c("John", "Roger", "Robert"), con = con)
<SQL> `first` IN ('John', 'Roger', 'Robert')
> 
> # And be careful if you really want integers
> translate_sql(x == 1, con = con)
<SQL> `x` = 1.0
> translate_sql(x == 1L, con = con)
<SQL> `x` = 1
> 
> # If you have an already quoted object, use translate_sql_:
> x <- quote(y + 1 / sin(t))
> translate_sql_(list(x), con = simulate_dbi())
<SQL> `y` + 1.0 / SIN(`t`)
> 
> # Windowed translation --------------------------------------------
> # Known window functions automatically get OVER()
> translate_sql(mpg > mean(mpg), con = con)
<SQL> `mpg` > AVG(`mpg`) OVER ()
> 
> # Suppress this with window = FALSE
> translate_sql(mpg > mean(mpg), window = FALSE, con = con)
<SQL> `mpg` > AVG(`mpg`)
> 
> # vars_group controls partition:
> translate_sql(mpg > mean(mpg), vars_group = "cyl", con = con)
<SQL> `mpg` > AVG(`mpg`) OVER (PARTITION BY `cyl`)
> 
> # and vars_order controls ordering for those functions that need it
> translate_sql(cumsum(mpg), con = con)
Warning: Windowed expression `SUM(`mpg`)` does not have explicit order.
ℹ Please use `arrange()` or `window_order()` to make deterministic.
<SQL> SUM(`mpg`) OVER (ROWS UNBOUNDED PRECEDING)
> translate_sql(cumsum(mpg), vars_order = "mpg", con = con)
<SQL> SUM(`mpg`) OVER (ORDER BY `mpg` ROWS UNBOUNDED PRECEDING)
> 
> 
> 
> cleanEx()
> nameEx("win_over")
> ### * win_over
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: win_over
> ### Title: Generate SQL expression for window functions
> ### Aliases: win_over win_rank win_aggregate win_aggregate_2 win_recycled
> ###   win_cumulative win_absent win_current_group win_current_order
> ###   win_current_frame win_rank_tdata
> ### Keywords: internal
> 
> ### ** Examples
> 
> con <- simulate_dbi()
> 
> win_over(sql("avg(x)"), con = con)
<SQL> avg(x) OVER ()
> win_over(sql("avg(x)"), "y", con = con)
<SQL> avg(x) OVER (PARTITION BY `y`)
> win_over(sql("avg(x)"), order = "y", con = con)
<SQL> avg(x) OVER (ORDER BY `y`)
> win_over(sql("avg(x)"), order = c("x", "y"), con = con)
<SQL> avg(x) OVER (ORDER BY `x`, `y`)
> win_over(sql("avg(x)"), frame = c(-Inf, 0), order = "y", con = con)
<SQL> avg(x) OVER (ORDER BY `y` ROWS UNBOUNDED PRECEDING)
> 
> 
> 
> cleanEx()
> nameEx("window_order")
> ### * window_order
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: window_order
> ### Title: Override window order and frame
> ### Aliases: window_order window_frame
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> 
> db <- memdb_frame(g = rep(1:2, each = 5), y = runif(10), z = 1:10)
> db %>%
+   window_order(y) %>%
+   mutate(z = cumsum(y)) %>%
+   show_query()
<SQL>
SELECT `g`, `y`, SUM(`y`) OVER (ORDER BY `y` ROWS UNBOUNDED PRECEDING) AS `z`
FROM `dbplyr_6YGuuP1Tjg`
> 
> db %>%
+   group_by(g) %>%
+   window_frame(-3, 0) %>%
+   window_order(z) %>%
+   mutate(z = sum(y)) %>%
+   show_query()
<SQL>
SELECT
  `g`,
  `y`,
  SUM(`y`) OVER (PARTITION BY `g` ORDER BY `z` ROWS 3 PRECEDING) AS `z`
FROM `dbplyr_6YGuuP1Tjg`
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:dplyr’, ‘dbplyr_cache’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  5.151 0.099 5.253 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
