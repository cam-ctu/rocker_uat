
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "checkmate"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('checkmate')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AssertCollection")
> ### * AssertCollection
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AssertCollection
> ### Title: Collect multiple assertions
> ### Aliases: AssertCollection makeAssertCollection reportAssertions
> 
> ### ** Examples
> 
> x = "a"
> coll = makeAssertCollection()
> 
> print(coll$isEmpty())
[1] TRUE
> assertNumeric(x, add = coll)
> coll$isEmpty()
[1] FALSE
> coll$push("Custom error message")
> coll$getMessages()
[1] "Variable 'x': Must be of type 'numeric', not 'character'."
[2] "Custom error message"                                     
> ## Not run: 
> ##D   reportAssertions(coll)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("anyInfinite")
> ### * anyInfinite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anyInfinite
> ### Title: Check if an object contains infinite values
> ### Aliases: anyInfinite
> 
> ### ** Examples
> 
> anyInfinite(1:10)
[1] FALSE
> anyInfinite(c(1:10, Inf))
[1] TRUE
> iris[3, 3] = Inf
> anyInfinite(iris)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("anyMissing")
> ### * anyMissing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: allMissing
> ### Title: Check if an object contains missing values
> ### Aliases: allMissing anyMissing
> 
> ### ** Examples
> 
> allMissing(1:2)
[1] FALSE
> allMissing(c(1, NA))
[1] FALSE
> allMissing(c(NA, NA))
[1] TRUE
> x = data.frame(a = 1:2, b = NA)
> # Note how allMissing combines the results for data frames:
> allMissing(x)
[1] TRUE
> all(sapply(x, allMissing))
[1] FALSE
> anyMissing(c(1, 1))
[1] FALSE
> anyMissing(c(1, NA))
[1] TRUE
> anyMissing(list(1, NULL))
[1] TRUE
> 
> x = iris
> x[, "Species"] = NA
> anyMissing(x)
[1] TRUE
> allMissing(x)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("anyNaN")
> ### * anyNaN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anyNaN
> ### Title: Check if an object contains NaN values
> ### Aliases: anyNaN
> 
> ### ** Examples
> 
> anyNaN(1:10)
[1] FALSE
> anyNaN(c(1:10, NaN))
[1] TRUE
> iris[3, 3] = NaN
> anyNaN(iris)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("asInteger")
> ### * asInteger
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asInteger
> ### Title: Convert an argument to an integer
> ### Aliases: asInteger asCount asInt
> 
> ### ** Examples
> 
> asInteger(c(1, 2, 3))
[1] 1 2 3
> asCount(1)
[1] 1
> asInt(1)
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("assert")
> ### * assert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: assert
> ### Title: Combine multiple checks into one assertion
> ### Aliases: assert
> 
> ### ** Examples
> 
> x = 1:10
> assert(checkNull(x), checkInteger(x, any.missing = FALSE))
> collection <- makeAssertCollection()
> assert(checkChoice(x, c("a", "b")), checkDataFrame(x), add = collection)
> collection$getMessages()
[1] "Variable 'x': One of the following must apply:\n * checkChoice(x): Must be element of set {'a','b'}, but is not atomic\n * scalar\n * checkDataFrame(x): Must be of type 'data.frame', not 'integer'."
> 
> 
> 
> cleanEx()
> nameEx("checkAccess")
> ### * checkAccess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkAccess
> ### Title: Check file system access rights
> ### Aliases: checkAccess check_access assertAccess assert_access testAccess
> ###   test_access expect_access
> 
> ### ** Examples
> 
> # Is R's home directory readable?
> testAccess(R.home(), "r")
[1] TRUE
> 
> # Is R's home directory writeable?
> testAccess(R.home(), "w")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkArray")
> ### * checkArray
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkArray
> ### Title: Check if an argument is an array
> ### Aliases: checkArray check_array assertArray assert_array testArray
> ###   test_array expect_array
> 
> ### ** Examples
> 
> checkArray(array(1:27, dim = c(3, 3, 3)), d = 3)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkAtomic")
> ### * checkAtomic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkAtomic
> ### Title: Check that an argument is an atomic vector
> ### Aliases: checkAtomic check_atomic assertAtomic assert_atomic testAtomic
> ###   test_atomic expect_atomic
> 
> ### ** Examples
> 
> testAtomic(letters, min.len = 1L, any.missing = FALSE)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkAtomicVector")
> ### * checkAtomicVector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkAtomicVector
> ### Title: Check that an argument is an atomic vector
> ### Aliases: checkAtomicVector check_atomic_vector assertAtomicVector
> ###   assert_atomic_vector testAtomicVector test_atomic_vector
> ###   expect_atomic_vector
> 
> ### ** Examples
> 
> testAtomicVector(letters, min.len = 1L, any.missing = FALSE)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkCharacter")
> ### * checkCharacter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkCharacter
> ### Title: Check if an argument is a vector of type character
> ### Aliases: checkCharacter check_character assertCharacter
> ###   assert_character testCharacter test_character expect_character
> 
> ### ** Examples
> 
> testCharacter(letters, min.len = 1, any.missing = FALSE)
[1] TRUE
> testCharacter(letters, min.chars = 2)
[1] FALSE
> testCharacter("example", pattern = "xa")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkChoice")
> ### * checkChoice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkChoice
> ### Title: Check if an object is an element of a given set
> ### Aliases: checkChoice check_choice assertChoice assert_choice testChoice
> ###   test_choice expect_choice
> 
> ### ** Examples
> 
> testChoice("x", letters)
[1] TRUE
> 
> # x is not converted before the comparison (except for numerics)
> testChoice(factor("a"), "a")
[1] FALSE
> testChoice(1, "1")
[1] FALSE
> testChoice(1, as.integer(1))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkClass")
> ### * checkClass
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkClass
> ### Title: Check the class membership of an argument
> ### Aliases: checkClass check_class assertClass assert_class testClass
> ###   test_class expect_class
> 
> ### ** Examples
> 
> # Create an object with classes "foo" and "bar"
> x = 1
> class(x) = c("foo", "bar")
> 
> # is x of class "foo"?
> testClass(x, "foo")
[1] TRUE
> 
> # is x of class "foo" and "bar"?
> testClass(x, c("foo", "bar"))
[1] TRUE
> 
> # is x of class "foo" or "bar"?
> ## Not run: 
> ##D assert(
> ##D   checkClass(x, "foo"),
> ##D   checkClass(x, "bar")
> ##D )
> ## End(Not run)
> # is x most specialized as "bar"?
> testClass(x, "bar", ordered = TRUE)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkComplex")
> ### * checkComplex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkComplex
> ### Title: Check if an argument is a vector of type complex
> ### Aliases: checkComplex check_complex assertComplex assert_complex
> ###   testComplex test_complex expect_complex
> 
> ### ** Examples
> 
> testComplex(1)
[1] FALSE
> testComplex(1+1i)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkCount")
> ### * checkCount
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkCount
> ### Title: Check if an argument is a count
> ### Aliases: checkCount check_count assertCount assert_count testCount
> ###   test_count expect_count
> 
> ### ** Examples
> 
> testCount(1)
[1] TRUE
> testCount(-1)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkDataFrame")
> ### * checkDataFrame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkDataFrame
> ### Title: Check if an argument is a data frame
> ### Aliases: checkDataFrame check_data_frame assertDataFrame
> ###   assert_data_frame testDataFrame test_data_frame expect_data_frame
> 
> ### ** Examples
> 
> testDataFrame(iris)
[1] TRUE
> testDataFrame(iris, types = c("numeric", "factor"), min.rows = 1, col.names = "named")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkDataTable")
> ### * checkDataTable
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkDataTable
> ### Title: Check if an argument is a data table
> ### Aliases: checkDataTable check_data_table assertDataTable
> ###   assert_data_table testDataTable test_data_table expect_data_table
> 
> ### ** Examples
> 
> library(data.table)
> dt = as.data.table(iris)
> setkeyv(dt, "Species")
> setkeyv(dt, "Sepal.Length", physical = FALSE)
> testDataTable(dt)
[1] TRUE
> testDataTable(dt, key = "Species", index = "Sepal.Length", any.missing = FALSE)
[1] TRUE
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("checkDirectoryExists")
> ### * checkDirectoryExists
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkDirectoryExists
> ### Title: Check for existence and access rights of directories
> ### Aliases: checkDirectoryExists check_directory_exists
> ###   assertDirectoryExists assert_directory_exists testDirectoryExists
> ###   test_directory_exists expect_directory_exists checkDirectory
> ###   assertDirectory assert_directory testDirectory test_directory
> ###   expect_directory
> 
> ### ** Examples
> 
> # Is R's home directory readable?
> testDirectory(R.home(), "r")
[1] TRUE
> 
> # Is R's home directory readable and writable?
> testDirectory(R.home(), "rw")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkDisjunct")
> ### * checkDisjunct
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkDisjunct
> ### Title: Check if an argument is disjunct from a given set
> ### Aliases: checkDisjunct check_disjunct assertDisjunct assert_disjunct
> ###   testDisjunct test_disjunct expect_disjunct
> 
> ### ** Examples
> 
> testDisjunct(1L, letters)
[1] TRUE
> testDisjunct(c("a", "z"), letters)
[1] FALSE
> 
> # x is not converted before the comparison (except for numerics)
> testDisjunct(factor("a"), "a")
[1] FALSE
> testDisjunct(1, "1")
[1] FALSE
> testDisjunct(1, as.integer(1))
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkDouble")
> ### * checkDouble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkDouble
> ### Title: Check that an argument is a vector of type double
> ### Aliases: checkDouble check_double assertDouble assert_double testDouble
> ###   test_double expect_double
> 
> ### ** Examples
> 
> testDouble(1)
[1] TRUE
> testDouble(1L)
[1] FALSE
> testDouble(1, min.len = 1, lower = 0)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkEnvironment")
> ### * checkEnvironment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkEnvironment
> ### Title: Check if an argument is an environment
> ### Aliases: checkEnvironment check_environment assertEnvironment
> ###   assert_environment testEnvironment test_environment
> ###   expect_environment
> 
> ### ** Examples
> 
> ee = as.environment(list(a = 1))
> testEnvironment(ee)
[1] TRUE
> testEnvironment(ee, contains = "a")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkFALSE")
> ### * checkFALSE
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkFALSE
> ### Title: Check if an argument is FALSE
> ### Aliases: checkFALSE check_false assertFALSE assert_false testFALSE
> ###   test_false
> 
> ### ** Examples
> 
> testFALSE(FALSE)
[1] TRUE
> testFALSE(TRUE)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkFactor")
> ### * checkFactor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkFactor
> ### Title: Check if an argument is a factor
> ### Aliases: checkFactor check_factor assertFactor assert_factor testFactor
> ###   test_factor expect_factor
> 
> ### ** Examples
> 
> x = factor("a", levels = c("a", "b"))
> testFactor(x)
[1] TRUE
> testFactor(x, empty.levels.ok = FALSE)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkFileExists")
> ### * checkFileExists
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkFileExists
> ### Title: Check existence and access rights of files
> ### Aliases: checkFileExists check_file_exists assertFileExists
> ###   assert_file_exists testFileExists test_file_exists expect_file_exists
> ###   checkFile assertFile assert_file testFile expect_file
> 
> ### ** Examples
> 
> # Check if R's COPYING file is readable
> testFileExists(file.path(R.home(), "COPYING"), access = "r")
[1] TRUE
> 
> # Check if R's COPYING file is readable and writable
> testFileExists(file.path(R.home(), "COPYING"), access = "rw")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkFlag")
> ### * checkFlag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkFlag
> ### Title: Check if an argument is a flag
> ### Aliases: checkFlag check_flag assertFlag assert_flag testFlag test_flag
> ###   expect_flag
> 
> ### ** Examples
> 
> testFlag(TRUE)
[1] TRUE
> testFlag(1)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkFormula")
> ### * checkFormula
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkFormula
> ### Title: Check if an argument is a formula
> ### Aliases: checkFormula check_formula assertFormula assert_formula
> ###   testFormula test_formula expect_formula
> 
> ### ** Examples
> 
> f = Species ~ Sepal.Length + Sepal.Width
> checkFormula(f)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkFunction")
> ### * checkFunction
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkFunction
> ### Title: Check if an argument is a function
> ### Aliases: checkFunction check_function assertFunction assert_function
> ###   testFunction test_function expect_function
> 
> ### ** Examples
> 
> testFunction(mean)
[1] TRUE
> testFunction(mean, args = "x")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkInt")
> ### * checkInt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkInt
> ### Title: Check if an argument is a single integerish value
> ### Aliases: checkInt check_int assertInt assert_int testInt test_int
> ###   expect_int
> 
> ### ** Examples
> 
> testInt(1)
[1] TRUE
> testInt(-1, lower = 0)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkInteger")
> ### * checkInteger
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkInteger
> ### Title: Check if an argument is vector of type integer
> ### Aliases: checkInteger check_integer assertInteger assert_integer
> ###   testInteger test_integer expect_integer
> 
> ### ** Examples
> 
> testInteger(1L)
[1] TRUE
> testInteger(1.)
[1] FALSE
> testInteger(1:2, lower = 1, upper = 2, any.missing = FALSE)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkIntegerish")
> ### * checkIntegerish
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkIntegerish
> ### Title: Check if an object is an integerish vector
> ### Aliases: checkIntegerish check_integerish assertIntegerish
> ###   assert_integerish testIntegerish test_integerish expect_integerish
> 
> ### ** Examples
> 
> testIntegerish(1L)
[1] TRUE
> testIntegerish(1.)
[1] TRUE
> testIntegerish(1:2, lower = 1L, upper = 2L, any.missing = FALSE)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkList")
> ### * checkList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkList
> ### Title: Check if an argument is a list
> ### Aliases: checkList check_list assertList assert_list testList test_list
> ###   expect_list
> 
> ### ** Examples
> 
> testList(list())
[1] TRUE
> testList(as.list(iris), types = c("numeric", "factor"))
[1] TRUE
> 
> # Missingness
> testList(list(1, NA), any.missing = FALSE)
[1] TRUE
> testList(list(1, NULL), any.missing = FALSE)
[1] FALSE
> 
> # Uniqueness differentiates between different NA types:
> testList(list(NA, NA), unique = TRUE)
[1] FALSE
> testList(list(NA, NA_real_), unique = TRUE)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkLogical")
> ### * checkLogical
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkLogical
> ### Title: Check if an argument is a vector of type logical
> ### Aliases: checkLogical check_logical assertLogical assert_logical
> ###   testLogical test_logical expect_logical
> 
> ### ** Examples
> 
> testLogical(TRUE)
[1] TRUE
> testLogical(TRUE, min.len = 1)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkMatrix")
> ### * checkMatrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkMatrix
> ### Title: Check if an argument is a matrix
> ### Aliases: checkMatrix check_matrix assertMatrix assert_matrix testMatrix
> ###   test_matrix expect_matrix
> 
> ### ** Examples
> 
> x = matrix(1:9, 3)
> colnames(x) = letters[1:3]
> testMatrix(x, nrows = 3, min.cols = 1, col.names = "named")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkMultiClass")
> ### * checkMultiClass
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkMultiClass
> ### Title: Check the class membership of an argument
> ### Aliases: checkMultiClass check_multi_class assertMultiClass
> ###   assert_multi_class testMultiClass test_multi_class expect_multi_class
> 
> ### ** Examples
> 
> x = 1
> class(x) = "bar"
> checkMultiClass(x, c("foo", "bar"))
[1] TRUE
> checkMultiClass(x, c("foo", "foobar"))
[1] "Must inherit from class 'foo'/'foobar', but has class 'bar'"
> 
> 
> 
> cleanEx()
> nameEx("checkNamed")
> ### * checkNamed
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkNamed
> ### Title: Check if an argument is named
> ### Aliases: checkNamed check_named assertNamed assert_named testNamed
> ###   test_named
> 
> ### ** Examples
> 
> x = 1:3
> testNamed(x, "unnamed")
[1] TRUE
> names(x) = letters[1:3]
> testNamed(x, "unique")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkNames")
> ### * checkNames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkNames
> ### Title: Check names to comply to specific rules
> ### Aliases: checkNames check_names assertNames assert_names testNames
> ###   test_names expect_names
> 
> ### ** Examples
> 
> x = 1:3
> testNames(names(x), "unnamed")
[1] TRUE
> names(x) = letters[1:3]
> testNames(names(x), "unique")
[1] TRUE
> 
> cn = c("Species", "Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")
> assertNames(names(iris), permutation.of = cn)
> 
> 
> 
> cleanEx()
> nameEx("checkNull")
> ### * checkNull
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkNull
> ### Title: Check if an argument is NULL
> ### Aliases: checkNull check_null assertNull assert_null testNull test_null
> 
> ### ** Examples
> 
> testNull(NULL)
[1] TRUE
> testNull(1)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkNumber")
> ### * checkNumber
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkNumber
> ### Title: Check if an argument is a single numeric value
> ### Aliases: checkNumber check_number assertNumber assert_number testNumber
> ###   test_number expect_number
> 
> ### ** Examples
> 
> testNumber(1)
[1] TRUE
> testNumber(1:2)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkNumeric")
> ### * checkNumeric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkNumeric
> ### Title: Check that an argument is a vector of type numeric
> ### Aliases: checkNumeric check_numeric assertNumeric assert_numeric
> ###   testNumeric test_numeric expect_numeric
> 
> ### ** Examples
> 
> testNumeric(1)
[1] TRUE
> testNumeric(1, min.len = 1, lower = 0)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkOS")
> ### * checkOS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkOS
> ### Title: Check the operating system
> ### Aliases: checkOS check_os assertOS assert_os testOS test_os expect_os
> 
> ### ** Examples
> 
> testOS("linux")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkPathForOutput")
> ### * checkPathForOutput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkPathForOutput
> ### Title: Check if a path is suited for creating an output file
> ### Aliases: checkPathForOutput check_path_for_output assertPathForOutput
> ###   assert_path_for_output testPathForOutput test_path_for_output
> ###   expect_path_for_output
> 
> ### ** Examples
> 
> # Can we create a file in the tempdir?
> testPathForOutput(file.path(tempdir(), "process.log"))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkPermutation")
> ### * checkPermutation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkPermutation
> ### Title: Check if the arguments are permutations of each other.
> ### Aliases: checkPermutation check_permutation assertPermutation
> ###   assert_permutation testPermutation test_permutation
> ###   expect_permutation
> 
> ### ** Examples
> 
> testPermutation(letters[1:2], letters[2:1])
[1] TRUE
> testPermutation(letters[c(1, 1, 2)], letters[1:2])
[1] FALSE
> testPermutation(c(NA, 1, 2), c(1, 2, NA))
[1] TRUE
> testPermutation(c(NA, 1, 2), c(1, 2, NA), na.ok = FALSE)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkR6")
> ### * checkR6
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkR6
> ### Title: Check if an argument is an R6 class
> ### Aliases: checkR6 check_r6 assertR6 assert_r6 testR6 test_r6 expect_r6
> 
> ### ** Examples
> 
> library(R6)
> generator = R6Class("Bar",
+   public = list(a = 5),
+   private = list(b = 42),
+   active = list(c = function() 99)
+ )
> x = generator$new()
> checkR6(x, "Bar", cloneable = TRUE, public = "a")
[1] TRUE
> 
> 
> 
> cleanEx()

detaching ‘package:R6’

> nameEx("checkRaw")
> ### * checkRaw
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkRaw
> ### Title: Check if an argument is a raw vector
> ### Aliases: checkRaw check_raw assertRaw assert_raw testRaw test_raw
> ###   expect_raw
> 
> ### ** Examples
> 
> testRaw(as.raw(2), min.len = 1L)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkScalar")
> ### * checkScalar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkScalar
> ### Title: Check if an argument is a single atomic value
> ### Aliases: checkScalar check_scalar assertScalar assert_scalar testScalar
> ###   test_scalar expect_scalar
> 
> ### ** Examples
> 
> testScalar(1)
[1] TRUE
> testScalar(1:10)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkScalarNA")
> ### * checkScalarNA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkScalarNA
> ### Title: Check if an argument is a single missing value
> ### Aliases: checkScalarNA check_scalar_na assertScalarNA assert_scalar_na
> ###   testScalarNA test_scalar_na expect_scalar_na
> 
> ### ** Examples
> 
> testScalarNA(1)
[1] FALSE
> testScalarNA(NA_real_)
[1] TRUE
> testScalarNA(rep(NA, 2))
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkSetEqual")
> ### * checkSetEqual
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkSetEqual
> ### Title: Check if an argument is equal to a given set
> ### Aliases: checkSetEqual check_set_equal assertSetEqual assert_set_equal
> ###   testSetEqual test_set_equal expect_set_equal
> 
> ### ** Examples
> 
> testSetEqual(c("a", "b"), c("a", "b"))
[1] TRUE
> testSetEqual(1:3, 1:4)
[1] FALSE
> 
> # x is not converted before the comparison (except for numerics)
> testSetEqual(factor("a"), "a")
[1] FALSE
> testSetEqual(1, "1")
[1] FALSE
> testSetEqual(1, as.integer(1))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkString")
> ### * checkString
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkString
> ### Title: Check if an argument is a string
> ### Aliases: checkString check_string assertString assert_string testString
> ###   test_string expect_string
> 
> ### ** Examples
> 
> testString("a")
[1] TRUE
> testString(letters)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkSubset")
> ### * checkSubset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkSubset
> ### Title: Check if an argument is a subset of a given set
> ### Aliases: checkSubset check_subset assertSubset assert_subset testSubset
> ###   test_subset expect_subset
> 
> ### ** Examples
> 
> testSubset(c("a", "z"), letters)
[1] TRUE
> testSubset("ab", letters)
[1] FALSE
> testSubset("Species", names(iris))
[1] TRUE
> 
> # x is not converted before the comparison (except for numerics)
> testSubset(factor("a"), "a")
[1] FALSE
> testSubset(1, "1")
[1] FALSE
> testSubset(1, as.integer(1))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("checkTRUE")
> ### * checkTRUE
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkTRUE
> ### Title: Check if an argument is TRUE
> ### Aliases: checkTRUE check_true assertTRUE assert_true testTRUE test_true
> 
> ### ** Examples
> 
> testTRUE(TRUE)
[1] TRUE
> testTRUE(FALSE)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("checkTibble")
> ### * checkTibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkTibble
> ### Title: Check if an argument is a tibble
> ### Aliases: checkTibble check_tibble assertTibble assert_tibble testTibble
> ###   test_tibble expect_tibble
> 
> ### ** Examples
> 
> library(tibble)
> x = as_tibble(iris)
> testTibble(x)
[1] TRUE
> testTibble(x, nrow = 150, any.missing = FALSE)
[1] TRUE
> 
> 
> 
> cleanEx()

detaching ‘package:tibble’

> nameEx("checkVector")
> ### * checkVector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkVector
> ### Title: Check if an argument is a vector
> ### Aliases: checkVector check_vector assertVector assert_vector testVector
> ###   test_vector
> 
> ### ** Examples
> 
> testVector(letters, min.len = 1L, any.missing = FALSE)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("coalesce")
> ### * coalesce
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: %??%
> ### Title: Coalesce operator
> ### Aliases: %??%
> 
> ### ** Examples
> 
> print(NULL %??% 1 %??% 2)
[1] 1
> print(names(iris) %??% letters[seq_len(ncol(iris))])
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"     
> 
> 
> 
> cleanEx()
> nameEx("makeAssertion")
> ### * makeAssertion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeAssertion
> ### Title: Turn a Check into an Assertion
> ### Aliases: makeAssertion makeAssertionFunction
> 
> ### ** Examples
> 
> # Simple custom check function
> checkFalse = function(x) if (!identical(x, FALSE)) "Must be FALSE" else TRUE
> 
> # Create the respective assert function
> assertFalse = function(x, .var.name = vname(x), add = NULL) {
+   res = checkFalse(x)
+   makeAssertion(x, res, .var.name, add)
+ }
> 
> # Alternative: Automatically create such a function
> assertFalse = makeAssertionFunction(checkFalse)
> print(assertFalse)
function (x, .var.name = checkmate::vname(x), add = NULL) 
{
    if (missing(x)) 
        stop(sprintf("argument \"%s\" is missing, with no default", 
            .var.name))
    res = checkFalse(x)
    checkmate::makeAssertion(x, res, .var.name, add)
}
> 
> 
> 
> cleanEx()
> nameEx("makeExpectation")
> ### * makeExpectation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeExpectation
> ### Title: Turn a Check into an Expectation
> ### Aliases: makeExpectation makeExpectationFunction
> 
> ### ** Examples
> 
> # Simple custom check function
> checkFalse = function(x) if (!identical(x, FALSE)) "Must be FALSE" else TRUE
> 
> # Create the respective expect function
> expect_false = function(x, info = NULL, label = vname(x)) {
+   res = checkFalse(x)
+   makeExpectation(x, res, info = info, label = label)
+ }
> 
> # Alternative: Automatically create such a function
> expect_false = makeExpectationFunction(checkFalse)
> print(expect_false)
function (x, info = NULL, label = vname(x)) 
{
    if (missing(x)) 
        stop(sprintf("Argument '%s' is missing", label))
    res = checkFalse(x)
    makeExpectation(x, res, info, label)
}
> 
> 
> 
> cleanEx()
> nameEx("makeTest")
> ### * makeTest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeTest
> ### Title: Turn a Check into a Test
> ### Aliases: makeTest makeTestFunction
> 
> ### ** Examples
> 
> # Simple custom check function
> checkFalse = function(x) if (!identical(x, FALSE)) "Must be FALSE" else TRUE
> 
> # Create the respective test function
> testFalse = function(x) {
+   res = checkFalse(x)
+   makeTest(res)
+ }
> 
> # Alternative: Automatically create such a function
> testFalse = makeTestFunction(checkFalse)
> print(testFalse)
function (x) 
{
    isTRUE(checkFalse(x))
}
> 
> 
> 
> cleanEx()
> nameEx("matchArg")
> ### * matchArg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matchArg
> ### Title: Partial Argument Matching
> ### Aliases: matchArg
> 
> ### ** Examples
> 
> matchArg("k", choices = c("kendall", "pearson"))
[1] "kendall"
> 
> 
> 
> cleanEx()
> nameEx("qassert")
> ### * qassert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qassert
> ### Title: Quick argument checks on (builtin) R types
> ### Aliases: qassert qtest qexpect
> 
> ### ** Examples
> 
> # logical of length 1
> qtest(NA, "b1")
[1] TRUE
> 
> # logical of length 1, NA not allowed
> qtest(NA, "B1")
[1] FALSE
> 
> # logical of length 0 or 1, NA not allowed
> qtest(TRUE, "B?")
[1] TRUE
> 
> # numeric with length > 0
> qtest(runif(10), "n+")
[1] TRUE
> 
> # integer with length > 0, NAs not allowed, all integers >= 0 and < Inf
> qtest(1:3, "I+[0,)")
[1] TRUE
> 
> # either an emtpy list or a character vector with <=5 elements
> qtest(1, c("l0", "s<=5"))
[1] FALSE
> 
> # data frame with at least one column and no missing value in any column
> qtest(iris, "D+")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("qassertr")
> ### * qassertr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qassertr
> ### Title: Quick recursive arguments checks on lists and data frames
> ### Aliases: qassertr qtestr qexpectr
> 
> ### ** Examples
> 
> # All list elements are integers with length >= 1?
> qtestr(as.list(1:10), "i+")
[1] TRUE
> 
> # All list elements (i.e. data frame columns) are numeric?
> qtestr(iris, "n")
[1] FALSE
> 
> # All list elements are numeric, w/o NAs?
> qtestr(list(a = 1:3, b = rnorm(1), c = letters), "N+")
[1] FALSE
> 
> # All list elements are numeric OR character
> qtestr(list(a = 1:3, b = rnorm(1), c = letters), c("N+", "S+"))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("wf")
> ### * wf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: wf
> ### Title: Get the index of the first/last TRUE
> ### Aliases: wf wl
> 
> ### ** Examples
> 
> wf(c(FALSE, TRUE))
[1] 2
> wl(c(FALSE, FALSE))
integer(0)
> wf(NA)
integer(0)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.379 0.023 0.402 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
