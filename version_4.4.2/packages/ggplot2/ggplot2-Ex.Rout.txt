
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ggplot2"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ggplot2')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aes")
> ### * aes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes
> ### Title: Construct aesthetic mappings
> ### Aliases: aes
> 
> ### ** Examples
> 
> aes(x = mpg, y = wt)
Aesthetic mapping: 
* `x` -> `mpg`
* `y` -> `wt`
> aes(mpg, wt)
Aesthetic mapping: 
* `x` -> `mpg`
* `y` -> `wt`
> 
> # You can also map aesthetics to functions of variables
> aes(x = mpg ^ 2, y = wt / cyl)
Aesthetic mapping: 
* `x` -> `mpg^2`
* `y` -> `wt/cyl`
> 
> # Or to constants
> aes(x = 1, colour = "smooth")
Aesthetic mapping: 
* `x`      -> 1
* `colour` -> "smooth"
> 
> # Aesthetic names are automatically standardised
> aes(col = x)
Aesthetic mapping: 
* `colour` -> `x`
> aes(fg = x)
Aesthetic mapping: 
* `colour` -> `x`
> aes(color = x)
Aesthetic mapping: 
* `colour` -> `x`
> aes(colour = x)
Aesthetic mapping: 
* `colour` -> `x`
> 
> # aes() is passed to either ggplot() or specific layer. Aesthetics supplied
> # to ggplot() are used as defaults for every layer.
> ggplot(mpg, aes(displ, hwy)) + geom_point()
> ggplot(mpg) + geom_point(aes(displ, hwy))
> 
> # Tidy evaluation ----------------------------------------------------
> # aes() automatically quotes all its arguments, so you need to use tidy
> # evaluation to create wrappers around ggplot2 pipelines. The
> # simplest case occurs when your wrapper takes dots:
> scatter_by <- function(data, ...) {
+   ggplot(data) + geom_point(aes(...))
+ }
> scatter_by(mtcars, disp, drat)
> 
> # If your wrapper has a more specific interface with named arguments,
> # you need the "embrace operator":
> scatter_by <- function(data, x, y) {
+   ggplot(data) + geom_point(aes({{ x }}, {{ y }}))
+ }
> scatter_by(mtcars, disp, drat)
> 
> # Note that users of your wrapper can use their own functions in the
> # quoted expressions and all will resolve as it should!
> cut3 <- function(x) cut_number(x, 3)
> scatter_by(mtcars, cut3(disp), drat)
> 
> 
> 
> cleanEx()
> nameEx("aes_all")
> ### * aes_all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_all
> ### Title: Given a character vector, create a set of identity mappings
> ### Aliases: aes_all
> ### Keywords: internal
> 
> ### ** Examples
> 
> aes_all(names(mtcars))
Aesthetic mapping: 
* `mpg`  -> `mpg`
* `cyl`  -> `cyl`
* `disp` -> `disp`
* `hp`   -> `hp`
* `drat` -> `drat`
* `wt`   -> `wt`
* `qsec` -> `qsec`
* `vs`   -> `vs`
* `am`   -> `am`
* `gear` -> `gear`
* `carb` -> `carb`
> aes_all(c("x", "y", "col", "pch"))
Aesthetic mapping: 
* `x`      -> `x`
* `y`      -> `y`
* `colour` -> `col`
* `shape`  -> `pch`
> 
> 
> 
> cleanEx()
> nameEx("aes_colour_fill_alpha")
> ### * aes_colour_fill_alpha
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_colour_fill_alpha
> ### Title: Colour related aesthetics: colour, fill, and alpha
> ### Aliases: aes_colour_fill_alpha colour color fill
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("aes_eval")
> ### * aes_eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_eval
> ### Title: Control aesthetic evaluation
> ### Aliases: aes_eval after_stat stat after_scale stage
> 
> ### ** Examples
> 
> # Default histogram display
> ggplot(mpg, aes(displ)) +
+   geom_histogram(aes(y = after_stat(count)))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # Scale tallest bin to 1
> ggplot(mpg, aes(displ)) +
+   geom_histogram(aes(y = after_stat(count / max(count))))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # Use a transparent version of colour for fill
> ggplot(mpg, aes(class, hwy)) +
+   geom_boxplot(aes(colour = class, fill = after_scale(alpha(colour, 0.4))))
> 
> # Use stage to modify the scaled fill
> ggplot(mpg, aes(class, hwy)) +
+   geom_boxplot(aes(fill = stage(class, after_scale = alpha(fill, 0.4))))
> 
> # Making a proportional stacked density plot
> ggplot(mpg, aes(cty)) +
+   geom_density(
+     aes(
+       colour = factor(cyl),
+       fill = after_scale(alpha(colour, 0.3)),
+       y = after_stat(count / sum(n[!duplicated(group)]))
+     ),
+     position = "stack", bw = 1
+   ) +
+   geom_density(bw = 1)
> 
> # Imitating a ridgeline plot
> ggplot(mpg, aes(cty, colour = factor(cyl))) +
+   geom_ribbon(
+     stat = "density", outline.type = "upper",
+     aes(
+       fill = after_scale(alpha(colour, 0.3)),
+       ymin = after_stat(group),
+       ymax = after_stat(group + ndensity)
+     )
+   )
> 
> # Labelling a bar plot
> ggplot(mpg, aes(class)) +
+   geom_bar() +
+   geom_text(
+     aes(
+       y = after_stat(count + 2),
+       label = after_stat(count)
+     ),
+     stat = "count"
+   )
> 
> # Labelling the upper hinge of a boxplot,
> # inspired by June Choe
> ggplot(mpg, aes(displ, class)) +
+   geom_boxplot(outlier.shape = NA) +
+   geom_text(
+     aes(
+       label = after_stat(xmax),
+       x = stage(displ, after_stat = xmax)
+     ),
+     stat = "boxplot", hjust = -0.5
+   )
> 
> 
> 
> cleanEx()
> nameEx("aes_group_order")
> ### * aes_group_order
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_group_order
> ### Title: Aesthetics: grouping
> ### Aliases: aes_group_order group
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("aes_linetype_size_shape")
> ### * aes_linetype_size_shape
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_linetype_size_shape
> ### Title: Differentiation related aesthetics: linetype, size, shape
> ### Aliases: aes_linetype_size_shape linetype size shape
> 
> ### ** Examples
> 
> 
> df <- data.frame(x = 1:10 , y = 1:10)
> p <- ggplot(df, aes(x, y))
> p + geom_line(linetype = 2)
> p + geom_line(linetype = "dotdash")
> 
> # An example with hex strings; the string "33" specifies three units on followed
> # by three off and "3313" specifies three units on followed by three off followed
> # by one on and finally three off.
> p + geom_line(linetype = "3313")
> 
> # Mapping line type from a grouping variable
> ggplot(economics_long, aes(date, value01)) +
+   geom_line(aes(linetype = variable))
> 
> # Linewidth examples
> ggplot(economics, aes(date, unemploy)) +
+   geom_line(linewidth = 2, lineend = "round")
> ggplot(economics, aes(date, unemploy)) +
+   geom_line(aes(linewidth = uempmed), lineend = "round")
> 
> # Size examples
> p <- ggplot(mtcars, aes(wt, mpg))
> p + geom_point(size = 4)
> p + geom_point(aes(size = qsec))
> p + geom_point(size = 2.5) +
+   geom_hline(yintercept = 25, size = 3.5)
Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
ℹ Please use `linewidth` instead.
> 
> # Shape examples
> p + geom_point()
> p + geom_point(shape = 5)
> p + geom_point(shape = "k", size = 3)
> p + geom_point(shape = ".")
> p + geom_point(shape = NA)
Warning: Removed 32 rows containing missing values or values outside the scale range
(`geom_point()`).
> p + geom_point(aes(shape = factor(cyl)))
> 
> # A look at all 25 symbols
> df2 <- data.frame(x = 1:5 , y = 1:25, z = 1:25)
> p <- ggplot(df2, aes(x, y))
> p + geom_point(aes(shape = z), size = 4) +
+   scale_shape_identity()
> # While all symbols have a foreground colour, symbols 19-25 also take a
> # background colour (fill)
> p + geom_point(aes(shape = z), size = 4, colour = "Red") +
+   scale_shape_identity()
> p + geom_point(aes(shape = z), size = 4, colour = "Red", fill = "Black") +
+   scale_shape_identity()
> 
> 
> 
> cleanEx()
> nameEx("aes_position")
> ### * aes_position
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_position
> ### Title: Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend,
> ###   yend
> ### Aliases: aes_position x y xmin xmax ymin ymax xend yend
> 
> ### ** Examples
> 
> 
> # Generate data: means and standard errors of means for prices
> # for each type of cut
> dmod <- lm(price ~ cut, data = diamonds)
> cut <- unique(diamonds$cut)
> cuts_df <- data.frame(
+   cut,
+   predict(dmod, data.frame(cut), se = TRUE)[c("fit", "se.fit")]
+ )
> ggplot(cuts_df) +
+   aes(
+    x = cut,
+    y = fit,
+    ymin = fit - se.fit,
+    ymax = fit + se.fit,
+    colour = cut
+   ) +
+   geom_pointrange()
> 
> # Using annotate
> p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
> p
> p + annotate(
+   "rect", xmin = 2, xmax = 3.5, ymin = 2, ymax = 25,
+   fill = "dark grey", alpha = .5
+ )
> 
> # Geom_segment examples
> p + geom_segment(
+   aes(x = 2, y = 15, xend = 2, yend = 25),
+   arrow = arrow(length = unit(0.5, "cm"))
+ )
Warning in geom_segment(aes(x = 2, y = 15, xend = 2, yend = 25), arrow = arrow(length = unit(0.5,  :
  All aesthetics have length 1, but the data has 32 rows.
ℹ Please consider using `annotate()` or provide this layer with data containing
  a single row.
> p + geom_segment(
+   aes(x = 2, y = 15, xend = 3, yend = 15),
+   arrow = arrow(length = unit(0.5, "cm"))
+ )
Warning in geom_segment(aes(x = 2, y = 15, xend = 3, yend = 15), arrow = arrow(length = unit(0.5,  :
  All aesthetics have length 1, but the data has 32 rows.
ℹ Please consider using `annotate()` or provide this layer with data containing
  a single row.
> p + geom_segment(
+   aes(x = 5, y = 30, xend = 3.5, yend = 25),
+   arrow = arrow(length = unit(0.5, "cm"))
+ )
Warning in geom_segment(aes(x = 5, y = 30, xend = 3.5, yend = 25), arrow = arrow(length = unit(0.5,  :
  All aesthetics have length 1, but the data has 32 rows.
ℹ Please consider using `annotate()` or provide this layer with data containing
  a single row.
> 
> # You can also use geom_segment() to recreate plot(type = "h")
> # from base R:
> set.seed(1)
> counts <- as.data.frame(table(x = rpois(100, 5)))
> counts$x <- as.numeric(as.character(counts$x))
> with(counts, plot(x, Freq, type = "h", lwd = 10))
> 
> ggplot(counts, aes(x = x, y = Freq)) +
+   geom_segment(aes(yend = 0, xend = x), size = 10)
> 
> 
> 
> cleanEx()
> nameEx("annotate")
> ### * annotate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotate
> ### Title: Create an annotation layer
> ### Aliases: annotate
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
> p + annotate("text", x = 4, y = 25, label = "Some text")
> p + annotate("text", x = 2:5, y = 25, label = "Some text")
> p + annotate("rect", xmin = 3, xmax = 4.2, ymin = 12, ymax = 21,
+   alpha = .2)
> p + annotate("segment", x = 2.5, xend = 4, y = 15, yend = 25,
+   colour = "blue")
> p + annotate("pointrange", x = 3.5, y = 20, ymin = 12, ymax = 28,
+   colour = "red", size = 2.5, linewidth = 1.5)
> 
> p + annotate("text", x = 2:3, y = 20:21, label = c("my label", "label 2"))
> 
> p + annotate("text", x = 4, y = 25, label = "italic(R) ^ 2 == 0.75",
+   parse = TRUE)
> p + annotate("text", x = 4, y = 25,
+   label = "paste(italic(R) ^ 2, \" = .75\")", parse = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("annotation_custom")
> ### * annotation_custom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotation_custom
> ### Title: Annotation: Custom grob
> ### Aliases: annotation_custom
> 
> ### ** Examples
> 
> # Dummy plot
> df <- data.frame(x = 1:10, y = 1:10)
> base <- ggplot(df, aes(x, y)) +
+   geom_blank() +
+   theme_bw()
> 
> # Full panel annotation
> base + annotation_custom(
+   grob = grid::roundrectGrob(),
+   xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
+ )
> 
> # Inset plot
> df2 <- data.frame(x = 1 , y = 1)
> g <- ggplotGrob(ggplot(df2, aes(x, y)) +
+   geom_point() +
+   theme(plot.background = element_rect(colour = "black")))
> base +
+   annotation_custom(grob = g, xmin = 1, xmax = 10, ymin = 8, ymax = 10)
> 
> 
> 
> cleanEx()
> nameEx("annotation_logticks")
> ### * annotation_logticks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotation_logticks
> ### Title: Annotation: log tick marks
> ### Aliases: annotation_logticks
> 
> ### ** Examples
> 
> # Make a log-log plot (without log ticks)
> a <- ggplot(msleep, aes(bodywt, brainwt)) +
+  geom_point(na.rm = TRUE) +
+  scale_x_log10(
+    breaks = scales::trans_breaks("log10", function(x) 10^x),
+    labels = scales::trans_format("log10", scales::math_format(10^.x))
+  ) +
+  scale_y_log10(
+    breaks = scales::trans_breaks("log10", function(x) 10^x),
+    labels = scales::trans_format("log10", scales::math_format(10^.x))
+  ) +
+  theme_bw()
> 
> a + annotation_logticks()                # Default: log ticks on bottom and left
> a + annotation_logticks(sides = "lr")    # Log ticks for y, on left and right
> a + annotation_logticks(sides = "trbl")  # All four sides
> 
> a + annotation_logticks(sides = "lr", outside = TRUE) +
+  coord_cartesian(clip = "off")  # Ticks outside plot
> 
> # Hide the minor grid lines because they don't align with the ticks
> a + annotation_logticks(sides = "trbl") + theme(panel.grid.minor = element_blank())
> 
> # Another way to get the same results as 'a' above: log-transform the data before
> # plotting it. Also hide the minor grid lines.
> b <- ggplot(msleep, aes(log10(bodywt), log10(brainwt))) +
+  geom_point(na.rm = TRUE) +
+  scale_x_continuous(name = "body", labels = scales::label_math(10^.x)) +
+  scale_y_continuous(name = "brain", labels = scales::label_math(10^.x)) +
+  theme_bw() + theme(panel.grid.minor = element_blank())
> 
> b + annotation_logticks()
> 
> # Using a coordinate transform requires scaled = FALSE
> t <- ggplot(msleep, aes(bodywt, brainwt)) +
+   geom_point() +
+   coord_trans(x = "log10", y = "log10") +
+   theme_bw()
> t + annotation_logticks(scaled = FALSE)
Warning: Removed 27 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> # Change the length of the ticks
> a + annotation_logticks(
+   short = unit(.5,"mm"),
+   mid = unit(3,"mm"),
+   long = unit(4,"mm")
+ )
> 
> 
> 
> cleanEx()
> nameEx("annotation_map")
> ### * annotation_map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotation_map
> ### Title: Annotation: a map
> ### Aliases: annotation_map
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (requireNamespace("maps", quietly = TRUE)) {
> ##D # location of cities in North Carolina
> ##D df <- data.frame(
> ##D   name = c("Charlotte", "Raleigh", "Greensboro"),
> ##D   lat = c(35.227, 35.772, 36.073),
> ##D   long = c(-80.843, -78.639, -79.792)
> ##D )
> ##D 
> ##D p <- ggplot(df, aes(x = long, y = lat)) +
> ##D   annotation_map(
> ##D     map_data("state"),
> ##D     fill = "antiquewhite", colour = "darkgrey"
> ##D   ) +
> ##D   geom_point(color = "blue") +
> ##D   geom_text(
> ##D     aes(label = name),
> ##D     hjust = 1.105, vjust = 1.05, color = "blue"
> ##D   )
> ##D 
> ##D # use without coord_sf() is possible but not recommended
> ##D p + xlim(-84, -76) + ylim(34, 37.2)
> ##D 
> ##D if (requireNamespace("sf", quietly = TRUE)) {
> ##D # use with coord_sf() for appropriate projection
> ##D p +
> ##D   coord_sf(
> ##D     crs = sf::st_crs(3347),
> ##D     default_crs = sf::st_crs(4326),  # data is provided as long-lat
> ##D     xlim = c(-84, -76),
> ##D     ylim = c(34, 37.2)
> ##D   )
> ##D 
> ##D # you can mix annotation_map() and geom_sf()
> ##D nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
> ##D p +
> ##D   geom_sf(
> ##D     data = nc, inherit.aes = FALSE,
> ##D     fill = NA, color = "black", linewidth = 0.1
> ##D   ) +
> ##D   coord_sf(crs = sf::st_crs(3347), default_crs = sf::st_crs(4326))
> ##D }}
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("annotation_raster")
> ### * annotation_raster
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotation_raster
> ### Title: Annotation: high-performance rectangular tiling
> ### Aliases: annotation_raster
> 
> ### ** Examples
> 
> # Generate data
> rainbow <- matrix(hcl(seq(0, 360, length.out = 50 * 50), 80, 70), nrow = 50)
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point() +
+   annotation_raster(rainbow, 15, 20, 3, 4)
> # To fill up whole plot
> ggplot(mtcars, aes(mpg, wt)) +
+   annotation_raster(rainbow, -Inf, Inf, -Inf, Inf) +
+   geom_point()
> 
> rainbow2 <- matrix(hcl(seq(0, 360, length.out = 10), 80, 70), nrow = 1)
> ggplot(mtcars, aes(mpg, wt)) +
+   annotation_raster(rainbow2, -Inf, Inf, -Inf, Inf) +
+   geom_point()
> rainbow2 <- matrix(hcl(seq(0, 360, length.out = 10), 80, 70), nrow = 1)
> ggplot(mtcars, aes(mpg, wt)) +
+   annotation_raster(rainbow2, -Inf, Inf, -Inf, Inf, interpolate = TRUE) +
+   geom_point()
> 
> 
> 
> cleanEx()
> nameEx("as_labeller")
> ### * as_labeller
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_labeller
> ### Title: Coerce to labeller function
> ### Aliases: as_labeller
> ### Keywords: internal
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(disp, drat)) + geom_point()
> p + facet_wrap(~am)
> 
> # Rename labels on the fly with a lookup character vector
> to_string <- as_labeller(c(`0` = "Zero", `1` = "One"))
> p + facet_wrap(~am, labeller = to_string)
> 
> # Quickly transform a function operating on character vectors to a
> # labeller function:
> appender <- function(string, suffix = "-foo") paste0(string, suffix)
> p + facet_wrap(~am, labeller = as_labeller(appender))
> 
> # If you have more than one faceting variable, be sure to dispatch
> # your labeller to the right variable with labeller()
> p + facet_grid(cyl ~ am, labeller = labeller(am = to_string))
> 
> 
> 
> cleanEx()
> nameEx("benchplot")
> ### * benchplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: benchplot
> ### Title: Benchmark plot creation time. Broken down into construct, build,
> ###   render and draw times.
> ### Aliases: benchplot
> ### Keywords: internal
> 
> ### ** Examples
> 
> benchplot(ggplot(mtcars, aes(mpg, wt)) + geom_point())
       step user.self sys.self elapsed
1 construct     0.002        0   0.002
2     build     0.016        0   0.016
3    render     0.016        0   0.016
4      draw     0.019        0   0.018
5     TOTAL     0.053        0   0.052
> benchplot(ggplot(mtcars, aes(mpg, wt)) + geom_point() + facet_grid(. ~ cyl))
       step user.self sys.self elapsed
1 construct     0.002        0   0.002
2     build     0.034        0   0.035
3    render     0.040        0   0.040
4      draw     0.032        0   0.032
5     TOTAL     0.108        0   0.109
> 
> # With tidy eval:
> p <- expr(ggplot(mtcars, aes(mpg, wt)) + geom_point())
> benchplot(!!p)
       step user.self sys.self elapsed
1 construct     0.002        0   0.002
2     build     0.017        0   0.016
3    render     0.016        0   0.016
4      draw     0.018        0   0.018
5     TOTAL     0.053        0   0.052
> 
> 
> 
> cleanEx()
> nameEx("borders")
> ### * borders
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: borders
> ### Title: Create a layer of map borders
> ### Aliases: borders
> 
> ### ** Examples
> 
> if (require("maps")) {
+ 
+ ia <- map_data("county", "iowa")
+ mid_range <- function(x) mean(range(x))
+ seats <- do.call(rbind, lapply(split(ia, ia$subregion), function(d) {
+   data.frame(lat = mid_range(d$lat), long = mid_range(d$long), subregion = unique(d$subregion))
+ }))
+ 
+ ggplot(ia, aes(long, lat)) +
+   geom_polygon(aes(group = group), fill = NA, colour = "grey60") +
+   geom_text(aes(label = subregion), data = seats, size = 2, angle = 45)
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ data(us.cities)
+ capitals <- subset(us.cities, capital == 2)
+ ggplot(capitals, aes(long, lat)) +
+   borders("state") +
+   geom_point(aes(size = pop)) +
+   scale_size_area() +
+   coord_quickmap()
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ # Same map, with some world context
+ ggplot(capitals, aes(long, lat)) +
+   borders("world", xlim = c(-130, -60), ylim = c(20, 50)) +
+   geom_point(aes(size = pop)) +
+   scale_size_area() +
+   coord_quickmap()
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> 
> 
> cleanEx()
> nameEx("calc_element")
> ### * calc_element
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calc_element
> ### Title: Calculate the element properties, by inheriting properties from
> ###   its parents
> ### Aliases: calc_element
> ### Keywords: internal
> 
> ### ** Examples
> 
> t <- theme_grey()
> calc_element('text', t)
List of 11
 $ family       : chr ""
 $ face         : chr "plain"
 $ colour       : chr "black"
 $ size         : num 11
 $ hjust        : num 0.5
 $ vjust        : num 0.5
 $ angle        : num 0
 $ lineheight   : num 0.9
 $ margin       : 'margin' num [1:4] 0points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : logi FALSE
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> # Compare the "raw" element definition to the element with calculated inheritance
> t$axis.text.x
List of 11
 $ family       : NULL
 $ face         : NULL
 $ colour       : NULL
 $ size         : NULL
 $ hjust        : NULL
 $ vjust        : num 1
 $ angle        : NULL
 $ lineheight   : NULL
 $ margin       : 'margin' num [1:4] 2.2points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : NULL
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> calc_element('axis.text.x', t, verbose = TRUE)
axis.text.x -->
axis.text
axis.text -->
text
text -->
nothing (top level)
List of 11
 $ family       : chr ""
 $ face         : chr "plain"
 $ colour       : chr "grey30"
 $ size         : num 8.8
 $ hjust        : num 0.5
 $ vjust        : num 1
 $ angle        : num 0
 $ lineheight   : num 0.9
 $ margin       : 'margin' num [1:4] 2.2points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : logi FALSE
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> # This reports that axis.text.x inherits from axis.text,
> # which inherits from text. You can view each of them with:
> t$axis.text.x
List of 11
 $ family       : NULL
 $ face         : NULL
 $ colour       : NULL
 $ size         : NULL
 $ hjust        : NULL
 $ vjust        : num 1
 $ angle        : NULL
 $ lineheight   : NULL
 $ margin       : 'margin' num [1:4] 2.2points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : NULL
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> t$axis.text
List of 11
 $ family       : NULL
 $ face         : NULL
 $ colour       : chr "grey30"
 $ size         : 'rel' num 0.8
 $ hjust        : NULL
 $ vjust        : NULL
 $ angle        : NULL
 $ lineheight   : NULL
 $ margin       : NULL
 $ debug        : NULL
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> t$text
List of 11
 $ family       : chr ""
 $ face         : chr "plain"
 $ colour       : chr "black"
 $ size         : num 11
 $ hjust        : num 0.5
 $ vjust        : num 0.5
 $ angle        : num 0
 $ lineheight   : num 0.9
 $ margin       : 'margin' num [1:4] 0points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : logi FALSE
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> 
> 
> cleanEx()
> nameEx("check_device")
> ### * check_device
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: check_device
> ### Title: Check graphics device capabilities
> ### Aliases: check_device
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Typically you'd run `check_device()` inside a function that might produce
> # advanced graphics.
> # The check is designed for use in control flow statements in the test mode
> if (check_device("patterns", action = "test")) {
+   print("Yay")
+ } else {
+   print("Nay")
+ }
[1] "Yay"
> 
> # Automatically throw a warning when unavailable
> if (check_device("compositing", action = "warn")) {
+   print("Yay")
+ } else {
+   print("Nay")
+ }
Warning: The pdf device does not support compositing.
[1] "Nay"
> 
> # Possibly throw an error
> try(check_device("glyphs", action = "abort"))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("coord_cartesian")
> ### * coord_cartesian
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_cartesian
> ### Title: Cartesian coordinates
> ### Aliases: coord_cartesian
> 
> ### ** Examples
> 
> # There are two ways of zooming the plot display: with scales or
> # with coordinate systems.  They work in two rather different ways.
> 
> p <- ggplot(mtcars, aes(disp, wt)) +
+   geom_point() +
+   geom_smooth()
> p
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # Setting the limits on a scale converts all values outside the range to NA.
> p + scale_x_continuous(limits = c(325, 500))
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
Warning: Removed 24 rows containing non-finite outside the scale range
(`stat_smooth()`).
Warning: Removed 24 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> # Setting the limits on the coordinate system performs a visual zoom.
> # The data is unchanged, and we just view a small portion of the original
> # plot. Note how smooth continues past the points visible on this plot.
> p + coord_cartesian(xlim = c(325, 500))
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # By default, the same expansion factor is applied as when setting scale
> # limits. You can set the limits precisely by setting expand = FALSE
> p + coord_cartesian(xlim = c(325, 500), expand = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # Similarly, we can use expand = FALSE to turn off expansion with the
> # default limits
> p + coord_cartesian(expand = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # You can see the same thing with this 2d histogram
> d <- ggplot(diamonds, aes(carat, price)) +
+   stat_bin_2d(bins = 25, colour = "white")
> d
> 
> # When zooming the scale, the we get 25 new bins that are the same
> # size on the plot, but represent smaller regions of the data space
> d + scale_x_continuous(limits = c(0, 1))
Warning: Removed 17502 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 17 rows containing missing values or values outside the scale range
(`geom_tile()`).
> 
> # When zooming the coordinate system, we see a subset of original 50 bins,
> # displayed bigger
> d + coord_cartesian(xlim = c(0, 1))
> 
> 
> 
> cleanEx()
> nameEx("coord_fixed")
> ### * coord_fixed
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_fixed
> ### Title: Cartesian coordinates with fixed "aspect ratio"
> ### Aliases: coord_fixed coord_equal
> 
> ### ** Examples
> 
> # ensures that the ranges of axes are equal to the specified ratio by
> # adjusting the plot aspect ratio
> 
> p <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
> p + coord_fixed(ratio = 1)
> p + coord_fixed(ratio = 5)
> p + coord_fixed(ratio = 1/5)
> p + coord_fixed(xlim = c(15, 30))
> 
> # Resize the plot to see that the specified aspect ratio is maintained
> 
> 
> 
> cleanEx()
> nameEx("coord_flip")
> ### * coord_flip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_flip
> ### Title: Cartesian coordinates with x and y flipped
> ### Aliases: coord_flip
> 
> ### ** Examples
> 
> # The preferred method of creating horizontal instead of vertical boxplots
> ggplot(diamonds, aes(price, cut)) +
+   geom_boxplot()
> 
> # Using `coord_flip()` to make the same plot
> ggplot(diamonds, aes(cut, price)) +
+   geom_boxplot() +
+   coord_flip()
> 
> # With swapped aesthetics, the y-scale controls the left axis
> ggplot(diamonds, aes(y = carat)) +
+   geom_histogram() +
+   scale_y_reverse()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # In `coord_flip()`, the x-scale controls the left axis
> ggplot(diamonds, aes(carat)) +
+   geom_histogram() +
+   coord_flip() +
+   scale_x_reverse()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # In line and area plots, swapped aesthetics require an explicit orientation
> df <- data.frame(a = 1:5, b = (1:5) ^ 2)
> ggplot(df, aes(b, a)) +
+   geom_area(orientation = "y")
> 
> # The same plot with `coord_flip()`
> ggplot(df, aes(a, b)) +
+   geom_area() +
+   coord_flip()
> 
> 
> 
> cleanEx()
> nameEx("coord_map")
> ### * coord_map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_map
> ### Title: Map projections
> ### Aliases: coord_map coord_quickmap
> 
> ### ** Examples
> 
> if (require("maps")) {
+ nz <- map_data("nz")
+ # Prepare a map of NZ
+ nzmap <- ggplot(nz, aes(x = long, y = lat, group = group)) +
+   geom_polygon(fill = "white", colour = "black")
+ 
+ # Plot it in cartesian coordinates
+ nzmap
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ # With correct mercator projection
+ nzmap + coord_map()
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ # With the aspect ratio approximation
+ nzmap + coord_quickmap()
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ # Other projections
+ nzmap + coord_map("azequalarea", orientation = c(-36.92, 174.6, 0))
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ states <- map_data("state")
+ usamap <- ggplot(states, aes(long, lat, group = group)) +
+   geom_polygon(fill = "white", colour = "black")
+ 
+ # Use cartesian coordinates
+ usamap
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ # With mercator projection
+ usamap + coord_map()
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ # See ?mapproject for coordinate systems and their parameters
+ usamap + coord_map("gilbert")
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ # For most projections, you'll need to set the orientation yourself
+ # as the automatic selection done by mapproject is not available to
+ # ggplot
+ usamap + coord_map("orthographic")
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ usamap + coord_map("conic", lat0 = 30)
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ usamap + coord_map("bonne", lat0 = 50)
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> ## Not run: 
> ##D if (require("maps")) {
> ##D # World map, using geom_path instead of geom_polygon
> ##D world <- map_data("world")
> ##D worldmap <- ggplot(world, aes(x = long, y = lat, group = group)) +
> ##D   geom_path() +
> ##D   scale_y_continuous(breaks = (-2:2) * 30) +
> ##D   scale_x_continuous(breaks = (-4:4) * 45)
> ##D 
> ##D # Orthographic projection with default orientation (looking down at North pole)
> ##D worldmap + coord_map("ortho")
> ##D }
> ##D 
> ##D if (require("maps")) {
> ##D # Looking up up at South Pole
> ##D worldmap + coord_map("ortho", orientation = c(-90, 0, 0))
> ##D }
> ##D 
> ##D if (require("maps")) {
> ##D # Centered on New York (currently has issues with closing polygons)
> ##D worldmap + coord_map("ortho", orientation = c(41, -74, 0))
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("coord_polar")
> ### * coord_polar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_polar
> ### Title: Polar coordinates
> ### Aliases: coord_polar coord_radial
> 
> ### ** Examples
> 
> # NOTE: Use these plots with caution - polar coordinates has
> # major perceptual problems.  The main point of these examples is
> # to demonstrate how these common plots can be described in the
> # grammar.  Use with EXTREME caution.
> 
> #' # A pie chart = stacked bar chart + polar coordinates
> pie <- ggplot(mtcars, aes(x = factor(1), fill = factor(cyl))) +
+  geom_bar(width = 1)
> pie + coord_polar(theta = "y")
> 
> # A partial polar plot
> ggplot(mtcars, aes(disp, mpg)) +
+   geom_point() +
+   coord_radial(start = -0.4 * pi, end = 0.4 * pi, inner.radius = 0.3)
> 
> 
> 
> cleanEx()
> nameEx("coord_trans")
> ### * coord_trans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_trans
> ### Title: Transformed Cartesian coordinate system
> ### Aliases: coord_trans
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("cut_interval")
> ### * cut_interval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut_interval
> ### Title: Discretise numeric data into categorical
> ### Aliases: cut_interval cut_number cut_width
> 
> ### ** Examples
> 
> table(cut_interval(1:100, 10))

   [1,10.9] (10.9,20.8] (20.8,30.7] (30.7,40.6] (40.6,50.5] (50.5,60.4] 
         10          10          10          10          10          10 
(60.4,70.3] (70.3,80.2] (80.2,90.1]  (90.1,100] 
         10          10          10          10 
> table(cut_interval(1:100, 11))

  [1,10]  (10,19]  (19,28]  (28,37]  (37,46]  (46,55]  (55,64]  (64,73] 
      10        9        9        9        9        9        9        9 
 (73,82]  (82,91] (91,100] 
       9        9        9 
> 
> set.seed(1)
> 
> table(cut_number(runif(1000), 10))

[0.00131,0.105]   (0.105,0.201]   (0.201,0.312]   (0.312,0.398]   (0.398,0.483] 
            100             100             100             100             100 
  (0.483,0.596]   (0.596,0.706]   (0.706,0.797]    (0.797,0.91]        (0.91,1] 
            100             100             100             100             100 
> 
> table(cut_width(runif(1000), 0.1))

[-0.05,0.05]  (0.05,0.15]  (0.15,0.25]  (0.25,0.35]  (0.35,0.45]  (0.45,0.55] 
          59          109          103           96          110           85 
 (0.55,0.65]  (0.65,0.75]  (0.75,0.85]  (0.85,0.95]  (0.95,1.05] 
          89           86          113           97           53 
> table(cut_width(runif(1000), 0.1, boundary = 0))

  [0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
      106       106       108       100        99       107        84        96 
(0.8,0.9]   (0.9,1] 
       95        99 
> table(cut_width(runif(1000), 0.1, center = 0))

[-0.05,0.05]  (0.05,0.15]  (0.15,0.25]  (0.25,0.35]  (0.35,0.45]  (0.45,0.55] 
          72          104           80          104          100           91 
 (0.55,0.65]  (0.65,0.75]  (0.75,0.85]  (0.85,0.95]  (0.95,1.05] 
          94           75          115          110           55 
> table(cut_width(runif(1000), 0.1, labels = FALSE))

  1   2   3   4   5   6   7   8   9  10  11 
 49  92 100  98 112 102  88  89  97 116  57 
> 
> 
> 
> cleanEx()
> nameEx("draw_key")
> ### * draw_key
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_key
> ### Title: Key glyphs for legends
> ### Aliases: draw_key draw_key_point draw_key_abline draw_key_rect
> ###   draw_key_polygon draw_key_blank draw_key_boxplot draw_key_crossbar
> ###   draw_key_path draw_key_vpath draw_key_dotplot draw_key_linerange
> ###   draw_key_pointrange draw_key_smooth draw_key_text draw_key_label
> ###   draw_key_vline draw_key_timeseries
> 
> ### ** Examples
> 
> p <- ggplot(economics, aes(date, psavert, color = "savings rate"))
> # key glyphs can be specified by their name
> p + geom_line(key_glyph = "timeseries")
> 
> # key glyphs can be specified via their drawing function
> p + geom_line(key_glyph = draw_key_rect)
> 
> 
> 
> cleanEx()
> nameEx("element")
> ### * element
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: element
> ### Title: Theme elements
> ### Aliases: element_blank element_rect element_line element_text rel
> ###   margin
> 
> ### ** Examples
> 
> plot <- ggplot(mpg, aes(displ, hwy)) + geom_point()
> 
> plot + theme(
+   panel.background = element_blank(),
+   axis.text = element_blank()
+ )
> 
> plot + theme(
+   axis.text = element_text(colour = "red", size = rel(1.5))
+ )
> 
> plot + theme(
+   axis.line = element_line(arrow = arrow())
+ )
> 
> plot + theme(
+   panel.background = element_rect(fill = "white"),
+   plot.margin = margin(2, 2, 2, 2, "cm"),
+   plot.background = element_rect(
+     fill = "grey90",
+     colour = "black",
+     linewidth = 1
+   )
+ )
> 
> 
> 
> cleanEx()
> nameEx("expand_limits")
> ### * expand_limits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand_limits
> ### Title: Expand the plot limits, using data
> ### Aliases: expand_limits
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
> p + expand_limits(x = 0)
> p + expand_limits(y = c(1, 9))
> p + expand_limits(x = 0, y = 0)
> 
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(colour = cyl)) +
+   expand_limits(colour = seq(2, 10, by = 2))
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(colour = factor(cyl))) +
+   expand_limits(colour = factor(seq(2, 10, by = 2)))
> 
> 
> 
> cleanEx()
> nameEx("expansion")
> ### * expansion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expansion
> ### Title: Generate expansion vector for scales
> ### Aliases: expansion expand_scale
> 
> ### ** Examples
> 
> # No space below the bars but 10% above them
> ggplot(mtcars) +
+   geom_bar(aes(x = factor(cyl))) +
+   scale_y_continuous(expand = expansion(mult = c(0, .1)))
> 
> # Add 2 units of space on the left and right of the data
> ggplot(subset(diamonds, carat > 2), aes(cut, clarity)) +
+   geom_jitter() +
+   scale_x_discrete(expand = expansion(add = 2))
> 
> # Reproduce the default range expansion used
> # when the 'expand' argument is not specified
> ggplot(subset(diamonds, carat > 2), aes(cut, price)) +
+   geom_jitter() +
+   scale_x_discrete(expand = expansion(add = .6)) +
+   scale_y_continuous(expand = expansion(mult = .05))
> 
> 
> 
> 
> cleanEx()
> nameEx("facet_grid")
> ### * facet_grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: facet_grid
> ### Title: Lay out panels in a grid
> ### Aliases: facet_grid
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(displ, cty)) + geom_point()
> 
> # Use vars() to supply variables from the dataset:
> p + facet_grid(rows = vars(drv))
> p + facet_grid(cols = vars(cyl))
> p + facet_grid(vars(drv), vars(cyl))
> 
> # To change plot order of facet grid,
> # change the order of variable levels with factor()
> 
> # If you combine a facetted dataset with a dataset that lacks those
> # faceting variables, the data will be repeated across the missing
> # combinations:
> df <- data.frame(displ = mean(mpg$displ), cty = mean(mpg$cty))
> p +
+   facet_grid(cols = vars(cyl)) +
+   geom_point(data = df, colour = "red", size = 2)
> 
> # When scales are constant, duplicated axes can be shown with
> # or without labels
> ggplot(mpg, aes(cty, hwy)) +
+   geom_point() +
+   facet_grid(year ~ drv, axes = "all", axis.labels = "all_x")
> 
> # Free scales -------------------------------------------------------
> # You can also choose whether the scales should be constant
> # across all panels (the default), or whether they should be allowed
> # to vary
> mt <- ggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) +
+   geom_point()
> 
> mt + facet_grid(vars(cyl), scales = "free")
> 
> # If scales and space are free, then the mapping between position
> # and values in the data will be the same across all panels. This
> # is particularly useful for categorical axes
> ggplot(mpg, aes(drv, model)) +
+   geom_point() +
+   facet_grid(manufacturer ~ ., scales = "free", space = "free") +
+   theme(strip.text.y = element_text(angle = 0))
> 
> # Margins ----------------------------------------------------------
> 
> 
> 
> cleanEx()
> nameEx("facet_null")
> ### * facet_null
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: facet_null
> ### Title: Facet specification: a single panel.
> ### Aliases: facet_null
> ### Keywords: internal
> 
> ### ** Examples
> 
> # facet_null is the default faceting specification if you
> # don't override it with facet_grid or facet_wrap
> ggplot(mtcars, aes(mpg, wt)) + geom_point()
> 
> 
> 
> cleanEx()
> nameEx("facet_wrap")
> ### * facet_wrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: facet_wrap
> ### Title: Wrap a 1d ribbon of panels into 2d
> ### Aliases: facet_wrap
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(displ, hwy)) + geom_point()
> 
> # Use vars() to supply faceting variables:
> p + facet_wrap(vars(class))
> 
> # Control the number of rows and columns with nrow and ncol
> p + facet_wrap(vars(class), nrow = 4)
> 
> 
> 
> 
> cleanEx()
> nameEx("fill_alpha")
> ### * fill_alpha
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fill_alpha
> ### Title: Modify fill transparency
> ### Aliases: fill_alpha
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Typical colour input
> fill_alpha("red", 0.5)
[1] "#FF000080"
> 
> if (utils::packageVersion("grid") > "4.2") {
+   # Pattern input
+   fill_alpha(list(grid::linearGradient()), 0.5)
+ }
[[1]]
$x1
[1] 0npc

$y1
[1] 0npc

$x2
[1] 1npc

$y2
[1] 1npc

$stops
[1] 0 1

$colours
[1] "#00000080" "#FFFFFF80"

$extend
[1] "pad"

$group
[1] TRUE

attr(,"class")
[1] "GridLinearGradient" "GridPattern"       

> 
> 
> 
> cleanEx()
> nameEx("fortify-multcomp")
> ### * fortify-multcomp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fortify-multcomp
> ### Title: Fortify methods for objects produced by 'multcomp'
> ### Aliases: fortify-multcomp fortify.glht fortify.confint.glht
> ###   fortify.summary.glht fortify.cld
> ### Keywords: internal
> 
> ### ** Examples
> 
> if (require("multcomp")) {
+ amod <- aov(breaks ~ wool + tension, data = warpbreaks)
+ wht <- glht(amod, linfct = mcp(tension = "Tukey"))
+ 
+ fortify(wht)
+ ggplot(wht, aes(lhs, estimate)) + geom_point()
+ 
+ CI <- confint(wht)
+ fortify(CI)
+ ggplot(CI, aes(lhs, estimate, ymin = lwr, ymax = upr)) +
+    geom_pointrange()
+ 
+ fortify(summary(wht))
+ ggplot(mapping = aes(lhs, estimate)) +
+    geom_linerange(aes(ymin = lwr, ymax = upr), data = CI) +
+    geom_point(aes(size = p), data = summary(wht)) +
+    scale_size(transform = "reverse")
+ 
+ cld <- cld(wht)
+ fortify(cld)
+ }
Loading required package: multcomp
Loading required package: mvtnorm
Loading required package: survival
Loading required package: TH.data
Loading required package: MASS

Attaching package: ‘TH.data’

The following object is masked from ‘package:MASS’:

    geyser

  lhs letters
L   L       a
M   M       b
H   H       b
> 
> 
> 
> cleanEx()

detaching ‘package:multcomp’, ‘package:TH.data’, ‘package:MASS’,
  ‘package:survival’, ‘package:mvtnorm’

> nameEx("fortify.lm")
> ### * fortify.lm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fortify.lm
> ### Title: Supplement the data fitted to a linear model with model fit
> ###   statistics.
> ### Aliases: fortify.lm
> ### Keywords: internal
> 
> ### ** Examples
> 
> mod <- lm(mpg ~ wt, data = mtcars)
> head(fortify(mod))
                   mpg    wt       .hat   .sigma      .cooksd  .fitted
Mazda RX4         21.0 2.620 0.04326896 3.067494 1.327407e-02 23.28261
Mazda RX4 Wag     21.0 2.875 0.03519677 3.093068 1.723963e-03 21.91977
Datsun 710        22.8 2.320 0.05837573 3.072127 1.543937e-02 24.88595
Hornet 4 Drive    21.4 3.215 0.03125017 3.088268 3.020558e-03 20.10265
Hornet Sportabout 18.7 3.440 0.03292182 3.097722 7.599578e-05 18.90014
Valiant           18.1 3.460 0.03323551 3.095184 9.210650e-04 18.79325
                      .resid   .stdresid
Mazda RX4         -2.2826106 -0.76616765
Mazda RX4 Wag     -0.9197704 -0.30743051
Datsun 710        -2.0859521 -0.70575249
Hornet 4 Drive     1.2973499  0.43275114
Hornet Sportabout -0.2001440 -0.06681879
Valiant           -0.6932545 -0.23148309
> head(fortify(mod, mtcars))
                   mpg cyl disp  hp drat    wt  qsec vs am gear carb       .hat
Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 0.04326896
Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 0.03519677
Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 0.05837573
Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 0.03125017
Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 0.03292182
Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 0.03323551
                    .sigma      .cooksd  .fitted     .resid   .stdresid
Mazda RX4         3.067494 1.327407e-02 23.28261 -2.2826106 -0.76616765
Mazda RX4 Wag     3.093068 1.723963e-03 21.91977 -0.9197704 -0.30743051
Datsun 710        3.072127 1.543937e-02 24.88595 -2.0859521 -0.70575249
Hornet 4 Drive    3.088268 3.020558e-03 20.10265  1.2973499  0.43275114
Hornet Sportabout 3.097722 7.599578e-05 18.90014 -0.2001440 -0.06681879
Valiant           3.095184 9.210650e-04 18.79325 -0.6932545 -0.23148309
> 
> plot(mod, which = 1)
> 
> ggplot(mod, aes(.fitted, .resid)) +
+   geom_point() +
+   geom_hline(yintercept = 0) +
+   geom_smooth(se = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> ggplot(mod, aes(.fitted, .stdresid)) +
+   geom_point() +
+   geom_hline(yintercept = 0) +
+   geom_smooth(se = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> ggplot(fortify(mod, mtcars), aes(.fitted, .stdresid)) +
+   geom_point(aes(colour = factor(cyl)))
> 
> ggplot(fortify(mod, mtcars), aes(mpg, .stdresid)) +
+   geom_point(aes(colour = factor(cyl)))
> 
> plot(mod, which = 2)
> ggplot(mod) +
+   stat_qq(aes(sample = .stdresid)) +
+   geom_abline()
> 
> plot(mod, which = 3)
> ggplot(mod, aes(.fitted, sqrt(abs(.stdresid)))) +
+   geom_point() +
+   geom_smooth(se = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> plot(mod, which = 4)
> ggplot(mod, aes(seq_along(.cooksd), .cooksd)) +
+   geom_col()
> 
> plot(mod, which = 5)
> ggplot(mod, aes(.hat, .stdresid)) +
+   geom_vline(linewidth = 2, colour = "white", xintercept = 0) +
+   geom_hline(linewidth = 2, colour = "white", yintercept = 0) +
+   geom_point() + geom_smooth(se = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> ggplot(mod, aes(.hat, .stdresid)) +
+   geom_point(aes(size = .cooksd)) +
+   geom_smooth(se = FALSE, linewidth = 0.5)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> plot(mod, which = 6)
> ggplot(mod, aes(.hat, .cooksd)) +
+   geom_vline(xintercept = 0, colour = NA) +
+   geom_abline(slope = seq(0, 3, by = 0.5), colour = "white") +
+   geom_smooth(se = FALSE) +
+   geom_point()
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> ggplot(mod, aes(.hat, .cooksd)) +
+   geom_point(aes(size = .cooksd / .hat)) +
+   scale_size_area()
> 
> 
> 
> cleanEx()
> nameEx("fortify.map")
> ### * fortify.map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fortify.map
> ### Title: Fortify method for map objects
> ### Aliases: fortify.map
> ### Keywords: internal
> 
> ### ** Examples
> 
> if (require("maps")) {
+ ca <- map("county", "ca", plot = FALSE, fill = TRUE)
+ head(fortify(ca))
+ ggplot(ca, aes(long, lat)) +
+   geom_polygon(aes(group = group))
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ tx <- map("county", "texas", plot = FALSE, fill = TRUE)
+ head(fortify(tx))
+ ggplot(tx, aes(long, lat)) +
+   geom_polygon(aes(group = group), colour = "white")
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> 
> 
> cleanEx()
> nameEx("geom_abline")
> ### * geom_abline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_abline
> ### Title: Reference lines: horizontal, vertical, and diagonal
> ### Aliases: geom_abline geom_hline geom_vline
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
> 
> # Fixed values
> p + geom_vline(xintercept = 5)
> p + geom_vline(xintercept = 1:5)
> p + geom_hline(yintercept = 20)
> 
> p + geom_abline() # Can't see it - outside the range of the data
> p + geom_abline(intercept = 20)
> 
> # Calculate slope and intercept of line of best fit
> coef(lm(mpg ~ wt, data = mtcars))
(Intercept)          wt 
  37.285126   -5.344472 
> p + geom_abline(intercept = 37, slope = -5)
> # But this is easier to do with geom_smooth:
> p + geom_smooth(method = "lm", se = FALSE)
`geom_smooth()` using formula = 'y ~ x'
> 
> # To show different lines in different facets, use aesthetics
> p <- ggplot(mtcars, aes(mpg, wt)) +
+   geom_point() +
+   facet_wrap(~ cyl)
> 
> mean_wt <- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
> p + geom_hline(aes(yintercept = wt), mean_wt)
> 
> # You can also control other aesthetics
> ggplot(mtcars, aes(mpg, wt, colour = wt)) +
+   geom_point() +
+   geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
+   facet_wrap(~ cyl)
> 
> 
> 
> cleanEx()
> nameEx("geom_bar")
> ### * geom_bar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_bar
> ### Title: Bar charts
> ### Aliases: geom_bar geom_col stat_count
> 
> ### ** Examples
> 
> # geom_bar is designed to make it easy to create bar charts that show
> # counts (or sums of weights)
> g <- ggplot(mpg, aes(class))
> # Number of cars in each class:
> g + geom_bar()
> # Total engine displacement of each class
> g + geom_bar(aes(weight = displ))
> # Map class to y instead to flip the orientation
> ggplot(mpg) + geom_bar(aes(y = class))
> 
> # Bar charts are automatically stacked when multiple bars are placed
> # at the same location. The order of the fill is designed to match
> # the legend
> g + geom_bar(aes(fill = drv))
> 
> # If you need to flip the order (because you've flipped the orientation)
> # call position_stack() explicitly:
> ggplot(mpg, aes(y = class)) +
+  geom_bar(aes(fill = drv), position = position_stack(reverse = TRUE)) +
+  theme(legend.position = "top")
> 
> # To show (e.g.) means, you need geom_col()
> df <- data.frame(trt = c("a", "b", "c"), outcome = c(2.3, 1.9, 3.2))
> ggplot(df, aes(trt, outcome)) +
+   geom_col()
> # But geom_point() displays exactly the same information and doesn't
> # require the y-axis to touch zero.
> ggplot(df, aes(trt, outcome)) +
+   geom_point()
> 
> # You can also use geom_bar() with continuous data, in which case
> # it will show counts at unique locations
> df <- data.frame(x = rep(c(2.9, 3.1, 4.5), c(5, 10, 4)))
> ggplot(df, aes(x)) + geom_bar()
> # cf. a histogram of the same data
> ggplot(df, aes(x)) + geom_histogram(binwidth = 0.5)
> 
> # Use `just` to control how columns are aligned with axis breaks:
> df <- data.frame(x = as.Date(c("2020-01-01", "2020-02-01")), y = 1:2)
> # Columns centered on the first day of the month
> ggplot(df, aes(x, y)) + geom_col(just = 0.5)
> # Columns begin on the first day of the month
> ggplot(df, aes(x, y)) + geom_col(just = 1)
> 
> 
> 
> cleanEx()
> nameEx("geom_bin_2d")
> ### * geom_bin_2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_bin_2d
> ### Title: Heatmap of 2d bin counts
> ### Aliases: geom_bin_2d geom_bin2d stat_bin_2d stat_bin2d
> 
> ### ** Examples
> 
> d <- ggplot(diamonds, aes(x, y)) + xlim(4, 10) + ylim(4, 10)
> d + geom_bin_2d()
Warning: Removed 478 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 5 rows containing missing values or values outside the scale range
(`geom_tile()`).
> 
> # You can control the size of the bins by specifying the number of
> # bins in each direction:
> d + geom_bin_2d(bins = 10)
Warning: Removed 478 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 6 rows containing missing values or values outside the scale range
(`geom_tile()`).
> d + geom_bin_2d(bins = 30)
Warning: Removed 478 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 5 rows containing missing values or values outside the scale range
(`geom_tile()`).
> 
> # Or by specifying the width of the bins
> d + geom_bin_2d(binwidth = c(0.1, 0.1))
Warning: Removed 478 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 5 rows containing missing values or values outside the scale range
(`geom_tile()`).
> 
> 
> 
> cleanEx()
> nameEx("geom_blank")
> ### * geom_blank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_blank
> ### Title: Draw nothing
> ### Aliases: geom_blank
> 
> ### ** Examples
> 
> ggplot(mtcars, aes(wt, mpg))
> # Nothing to see here!
> 
> 
> 
> cleanEx()
> nameEx("geom_boxplot")
> ### * geom_boxplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_boxplot
> ### Title: A box and whiskers plot (in the style of Tukey)
> ### Aliases: geom_boxplot stat_boxplot
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(class, hwy))
> p + geom_boxplot()
> # Orientation follows the discrete axis
> ggplot(mpg, aes(hwy, class)) + geom_boxplot()
> 
> p + geom_boxplot(notch = TRUE)
Notch went outside hinges
ℹ Do you want `notch = FALSE`?
Notch went outside hinges
ℹ Do you want `notch = FALSE`?
> p + geom_boxplot(varwidth = TRUE)
> p + geom_boxplot(fill = "white", colour = "#3366FF")
> # By default, outlier points match the colour of the box. Use
> # outlier.colour to override
> p + geom_boxplot(outlier.colour = "red", outlier.shape = 1)
> # Remove outliers when overlaying boxplot with original data points
> p + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2)
> 
> # Boxplots are automatically dodged when any aesthetic is a factor
> p + geom_boxplot(aes(colour = drv))
> 
> # You can also use boxplots with continuous x, as long as you supply
> # a grouping variable. cut_width is particularly useful
> ggplot(diamonds, aes(carat, price)) +
+   geom_boxplot()
Warning: Continuous x aesthetic
ℹ did you forget `aes(group = ...)`?
> ggplot(diamonds, aes(carat, price)) +
+   geom_boxplot(aes(group = cut_width(carat, 0.25)))
> # Adjust the transparency of outliers using outlier.alpha
> ggplot(diamonds, aes(carat, price)) +
+   geom_boxplot(aes(group = cut_width(carat, 0.25)), outlier.alpha = 0.1)
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_contour")
> ### * geom_contour
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_contour
> ### Title: 2D contours of a 3D surface
> ### Aliases: geom_contour geom_contour_filled stat_contour
> ###   stat_contour_filled
> 
> ### ** Examples
> 
> # Basic plot
> v <- ggplot(faithfuld, aes(waiting, eruptions, z = density))
> v + geom_contour()
> 
> # Or compute from raw data
> ggplot(faithful, aes(waiting, eruptions)) +
+   geom_density_2d()
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_count")
> ### * geom_count
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_count
> ### Title: Count overlapping points
> ### Aliases: geom_count stat_sum
> 
> ### ** Examples
> 
> ggplot(mpg, aes(cty, hwy)) +
+  geom_point()
> 
> ggplot(mpg, aes(cty, hwy)) +
+  geom_count()
> 
> # Best used in conjunction with scale_size_area which ensures that
> # counts of zero would be given size 0. Doesn't make much different
> # here because the smallest count is already close to 0.
> ggplot(mpg, aes(cty, hwy)) +
+  geom_count() +
+  scale_size_area()
> 
> # Display proportions instead of counts -------------------------------------
> # By default, all categorical variables in the plot form the groups.
> # Specifying geom_count without a group identifier leads to a plot which is
> # not useful:
> d <- ggplot(diamonds, aes(x = cut, y = clarity))
> d + geom_count(aes(size = after_stat(prop)))
> # To correct this problem and achieve a more desirable plot, we need
> # to specify which group the proportion is to be calculated over.
> d + geom_count(aes(size = after_stat(prop), group = 1)) +
+   scale_size_area(max_size = 10)
> 
> # Or group by x/y variables to have rows/columns sum to 1.
> d + geom_count(aes(size = after_stat(prop), group = cut)) +
+   scale_size_area(max_size = 10)
> d + geom_count(aes(size = after_stat(prop), group = clarity)) +
+   scale_size_area(max_size = 10)
> 
> 
> 
> cleanEx()
> nameEx("geom_density")
> ### * geom_density
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_density
> ### Title: Smoothed density estimates
> ### Aliases: geom_density stat_density
> 
> ### ** Examples
> 
> ggplot(diamonds, aes(carat)) +
+   geom_density()
> # Map the values to y to flip the orientation
> ggplot(diamonds, aes(y = carat)) +
+   geom_density()
> 
> ggplot(diamonds, aes(carat)) +
+   geom_density(adjust = 1/5)
> ggplot(diamonds, aes(carat)) +
+   geom_density(adjust = 5)
> 
> ggplot(diamonds, aes(depth, colour = cut)) +
+   geom_density() +
+   xlim(55, 70)
Warning: Removed 45 rows containing non-finite outside the scale range
(`stat_density()`).
> ggplot(diamonds, aes(depth, fill = cut, colour = cut)) +
+   geom_density(alpha = 0.1) +
+   xlim(55, 70)
Warning: Removed 45 rows containing non-finite outside the scale range
(`stat_density()`).
> 
> # Use `bounds` to adjust computation for known data limits
> big_diamonds <- diamonds[diamonds$carat >= 1, ]
> ggplot(big_diamonds, aes(carat)) +
+   geom_density(color = 'red') +
+   geom_density(bounds = c(1, Inf), color = 'blue')
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_density_2d")
> ### * geom_density_2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_density_2d
> ### Title: Contours of a 2D density estimate
> ### Aliases: geom_density_2d geom_density2d geom_density_2d_filled
> ###   geom_density2d_filled stat_density_2d stat_density2d
> ###   stat_density_2d_filled stat_density2d_filled
> 
> ### ** Examples
> 
> m <- ggplot(faithful, aes(x = eruptions, y = waiting)) +
+  geom_point() +
+  xlim(0.5, 6) +
+  ylim(40, 110)
> 
> # contour lines
> m + geom_density_2d()
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_dotplot")
> ### * geom_dotplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_dotplot
> ### Title: Dot plot
> ### Aliases: geom_dotplot
> 
> ### ** Examples
> 
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot()
Bin width defaults to 1/30 of the range of the data. Pick better value with
`binwidth`.
> 
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5)
> 
> # Use fixed-width bins
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(method="histodot", binwidth = 1.5)
> 
> # Some other stacking methods
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, stackdir = "center")
> 
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, stackdir = "centerwhole")
> 
> # y axis isn't really meaningful, so hide it
> ggplot(mtcars, aes(x = mpg)) + geom_dotplot(binwidth = 1.5) +
+   scale_y_continuous(NULL, breaks = NULL)
> 
> # Overlap dots vertically
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, stackratio = .7)
> 
> # Expand dot diameter
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, dotsize = 1.25)
> 
> # Change dot fill colour, stroke width
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, fill = "white", stroke = 2)
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_errorbarh")
> ### * geom_errorbarh
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_errorbarh
> ### Title: Horizontal error bars
> ### Aliases: geom_errorbarh
> 
> ### ** Examples
> 
> df <- data.frame(
+   trt = factor(c(1, 1, 2, 2)),
+   resp = c(1, 5, 3, 4),
+   group = factor(c(1, 2, 1, 2)),
+   se = c(0.1, 0.3, 0.3, 0.2)
+ )
> 
> # Define the top and bottom of the errorbars
> 
> p <- ggplot(df, aes(resp, trt, colour = group))
> p +
+   geom_point() +
+   geom_errorbarh(aes(xmax = resp + se, xmin = resp - se))
> 
> p +
+   geom_point() +
+   geom_errorbarh(aes(xmax = resp + se, xmin = resp - se, height = .2))
> 
> 
> 
> cleanEx()
> nameEx("geom_function")
> ### * geom_function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_function
> ### Title: Draw a function as a continuous curve
> ### Aliases: geom_function stat_function
> 
> ### ** Examples
> 
> 
> # geom_function() is useful for overlaying functions
> set.seed(1492)
> ggplot(data.frame(x = rnorm(100)), aes(x)) +
+   geom_density() +
+   geom_function(fun = dnorm, colour = "red")
> 
> # To plot functions without data, specify range of x-axis
> base <-
+   ggplot() +
+   xlim(-5, 5)
> 
> base + geom_function(fun = dnorm)
> 
> base + geom_function(fun = dnorm, args = list(mean = 2, sd = .5))
> 
> # The underlying mechanics evaluate the function at discrete points
> # and connect the points with lines
> base + stat_function(fun = dnorm, geom = "point")
> 
> base + stat_function(fun = dnorm, geom = "point", n = 20)
> 
> base + stat_function(fun = dnorm, geom = "polygon", color = "blue", fill = "blue", alpha = 0.5)
> 
> base + geom_function(fun = dnorm, n = 20)
> 
> # Two functions on the same plot
> base +
+   geom_function(aes(colour = "normal"), fun = dnorm) +
+   geom_function(aes(colour = "t, df = 1"), fun = dt, args = list(df = 1))
> 
> # Using a custom anonymous function
> base + geom_function(fun = function(x) 0.5 * exp(-abs(x)))
> # or using lambda syntax:
> # base + geom_function(fun = ~ 0.5 * exp(-abs(.x)))
> # or in R4.1.0 and above:
> # base + geom_function(fun = \(x) 0.5 * exp(-abs(x)))
> # or using a custom named function:
> # f <- function(x) 0.5 * exp(-abs(x))
> # base + geom_function(fun = f)
> 
> # Using xlim to restrict the range of function
> ggplot(data.frame(x = rnorm(100)), aes(x)) +
+ geom_density() +
+ geom_function(fun = dnorm, colour = "red", xlim=c(-1, 1))
> 
> # Using xlim to widen the range of function
> ggplot(data.frame(x = rnorm(100)), aes(x)) +
+ geom_density() +
+ geom_function(fun = dnorm, colour = "red", xlim=c(-7, 7))
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_hex")
> ### * geom_hex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_hex
> ### Title: Hexagonal heatmap of 2d bin counts
> ### Aliases: geom_hex stat_bin_hex stat_binhex
> 
> ### ** Examples
> 
> d <- ggplot(diamonds, aes(carat, price))
> d + geom_hex()
Warning: Computation failed in `stat_binhex()`.
Caused by error in `compute_group()`:
! The package "hexbin" is required for `stat_bin_hex()`.
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_histogram")
> ### * geom_histogram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_freqpoly
> ### Title: Histograms and frequency polygons
> ### Aliases: geom_freqpoly geom_histogram stat_bin
> 
> ### ** Examples
> 
> ggplot(diamonds, aes(carat)) +
+   geom_histogram()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ggplot(diamonds, aes(carat)) +
+   geom_histogram(binwidth = 0.01)
> ggplot(diamonds, aes(carat)) +
+   geom_histogram(bins = 200)
> # Map values to y to flip the orientation
> ggplot(diamonds, aes(y = carat)) +
+   geom_histogram()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # For histograms with tick marks between each bin, use `geom_bar()` with
> # `scale_x_binned()`.
> ggplot(diamonds, aes(carat)) +
+   geom_bar() +
+   scale_x_binned()
> 
> # Rather than stacking histograms, it's easier to compare frequency
> # polygons
> ggplot(diamonds, aes(price, fill = cut)) +
+   geom_histogram(binwidth = 500)
> ggplot(diamonds, aes(price, colour = cut)) +
+   geom_freqpoly(binwidth = 500)
> 
> # To make it easier to compare distributions with very different counts,
> # put density on the y axis instead of the default count
> ggplot(diamonds, aes(price, after_stat(density), colour = cut)) +
+   geom_freqpoly(binwidth = 500)
> 
> if (require("ggplot2movies")) {
+ # Often we don't want the height of the bar to represent the
+ # count of observations, but the sum of some other variable.
+ # For example, the following plot shows the number of movies
+ # in each rating.
+ m <- ggplot(movies, aes(rating))
+ m + geom_histogram(binwidth = 0.1)
+ 
+ # If, however, we want to see the number of votes cast in each
+ # category, we need to weight by the votes variable
+ m +
+   geom_histogram(aes(weight = votes), binwidth = 0.1) +
+   ylab("votes")
+ 
+ # For transformed scales, binwidth applies to the transformed data.
+ # The bins have constant width on the transformed scale.
+ m +
+  geom_histogram() +
+  scale_x_log10()
+ m +
+   geom_histogram(binwidth = 0.05) +
+   scale_x_log10()
+ 
+ # For transformed coordinate systems, the binwidth applies to the
+ # raw data. The bins have constant width on the original scale.
+ 
+ # Using log scales does not work here, because the first
+ # bar is anchored at zero, and so when transformed becomes negative
+ # infinity. This is not a problem when transforming the scales, because
+ # no observations have 0 ratings.
+ m +
+   geom_histogram(boundary = 0) +
+   coord_trans(x = "log10")
+ # Use boundary = 0, to make sure we don't take sqrt of negative values
+ m +
+   geom_histogram(boundary = 0) +
+   coord_trans(x = "sqrt")
+ 
+ # You can also transform the y axis.  Remember that the base of the bars
+ # has value 0, so log transformations are not appropriate
+ m <- ggplot(movies, aes(x = rating))
+ m +
+   geom_histogram(binwidth = 0.5) +
+   scale_y_sqrt()
+ }
Loading required package: ggplot2movies
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘ggplot2movies’
> 
> # You can specify a function for calculating binwidth, which is
> # particularly useful when faceting along variables with
> # different ranges because the function will be called once per facet
> ggplot(economics_long, aes(value)) +
+   facet_wrap(~variable, scales = 'free_x') +
+   geom_histogram(binwidth = function(x) 2 * IQR(x) / (length(x)^(1/3)))
> 
> 
> 
> cleanEx()
> nameEx("geom_jitter")
> ### * geom_jitter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_jitter
> ### Title: Jittered points
> ### Aliases: geom_jitter
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(cyl, hwy))
> p + geom_point()
> p + geom_jitter()
> 
> # Add aesthetic mappings
> p + geom_jitter(aes(colour = class))
> 
> # Use smaller width/height to emphasise categories
> ggplot(mpg, aes(cyl, hwy)) +
+   geom_jitter()
> ggplot(mpg, aes(cyl, hwy)) +
+   geom_jitter(width = 0.25)
> 
> # Use larger width/height to completely smooth away discreteness
> ggplot(mpg, aes(cty, hwy)) +
+   geom_jitter()
> ggplot(mpg, aes(cty, hwy)) +
+   geom_jitter(width = 0.5, height = 0.5)
> 
> 
> 
> cleanEx()
> nameEx("geom_linerange")
> ### * geom_linerange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_crossbar
> ### Title: Vertical intervals: lines, crossbars & errorbars
> ### Aliases: geom_crossbar geom_errorbar geom_linerange geom_pointrange
> 
> ### ** Examples
> 
> # Create a simple example dataset
> df <- data.frame(
+   trt = factor(c(1, 1, 2, 2)),
+   resp = c(1, 5, 3, 4),
+   group = factor(c(1, 2, 1, 2)),
+   upper = c(1.1, 5.3, 3.3, 4.2),
+   lower = c(0.8, 4.6, 2.4, 3.6)
+ )
> 
> p <- ggplot(df, aes(trt, resp, colour = group))
> p + geom_linerange(aes(ymin = lower, ymax = upper))
> p + geom_pointrange(aes(ymin = lower, ymax = upper))
> p + geom_crossbar(aes(ymin = lower, ymax = upper), width = 0.2)
> p + geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)
> 
> # Flip the orientation by changing mapping
> ggplot(df, aes(resp, trt, colour = group)) +
+   geom_linerange(aes(xmin = lower, xmax = upper))
> 
> # Draw lines connecting group means
> p +
+   geom_line(aes(group = group)) +
+   geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)
> 
> # If you want to dodge bars and errorbars, you need to manually
> # specify the dodge width
> p <- ggplot(df, aes(trt, resp, fill = group))
> p +
+  geom_col(position = "dodge") +
+  geom_errorbar(aes(ymin = lower, ymax = upper), position = "dodge", width = 0.25)
> 
> # Because the bars and errorbars have different widths
> # we need to specify how wide the objects we are dodging are
> dodge <- position_dodge(width=0.9)
> p +
+   geom_col(position = dodge) +
+   geom_errorbar(aes(ymin = lower, ymax = upper), position = dodge, width = 0.25)
> 
> # When using geom_errorbar() with position_dodge2(), extra padding will be
> # needed between the error bars to keep them aligned with the bars.
> p +
+ geom_col(position = "dodge2") +
+ geom_errorbar(
+   aes(ymin = lower, ymax = upper),
+   position = position_dodge2(width = 0.5, padding = 0.5)
+ )
> 
> 
> 
> cleanEx()
> nameEx("geom_map")
> ### * geom_map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_map
> ### Title: Polygons from a reference map
> ### Aliases: geom_map
> 
> ### ** Examples
> 
> # First, a made-up example containing a few polygons, to explain
> # how `geom_map()` works. It requires two data frames:
> # One contains the coordinates of each polygon (`positions`), and is
> # provided via the `map` argument. The other contains the
> # other the values associated with each polygon (`values`).  An id
> # variable links the two together.
> 
> ids <- factor(c("1.1", "2.1", "1.2", "2.2", "1.3", "2.3"))
> 
> values <- data.frame(
+   id = ids,
+   value = c(3, 3.1, 3.1, 3.2, 3.15, 3.5)
+ )
> 
> positions <- data.frame(
+   id = rep(ids, each = 4),
+   x = c(2, 1, 1.1, 2.2, 1, 0, 0.3, 1.1, 2.2, 1.1, 1.2, 2.5, 1.1, 0.3,
+   0.5, 1.2, 2.5, 1.2, 1.3, 2.7, 1.2, 0.5, 0.6, 1.3),
+   y = c(-0.5, 0, 1, 0.5, 0, 0.5, 1.5, 1, 0.5, 1, 2.1, 1.7, 1, 1.5,
+   2.2, 2.1, 1.7, 2.1, 3.2, 2.8, 2.1, 2.2, 3.3, 3.2)
+ )
> 
> ggplot(values) +
+   geom_map(aes(map_id = id), map = positions) +
+   expand_limits(positions)
> ggplot(values, aes(fill = value)) +
+   geom_map(aes(map_id = id), map = positions) +
+   expand_limits(positions)
> ggplot(values, aes(fill = value)) +
+   geom_map(aes(map_id = id), map = positions) +
+   expand_limits(positions) + ylim(0, 3)
> 
> # Now some examples with real maps
> if (require(maps)) {
+ 
+   crimes <- data.frame(state = tolower(rownames(USArrests)), USArrests)
+ 
+   # Equivalent to crimes %>% tidyr::pivot_longer(Murder:Rape)
+   vars <- lapply(names(crimes)[-1], function(j) {
+     data.frame(state = crimes$state, variable = j, value = crimes[[j]])
+   })
+   crimes_long <- do.call("rbind", vars)
+ 
+   states_map <- map_data("state")
+ 
+   # without geospatial coordinate system, the resulting plot
+   # looks weird
+   ggplot(crimes, aes(map_id = state)) +
+     geom_map(aes(fill = Murder), map = states_map) +
+     expand_limits(x = states_map$long, y = states_map$lat)
+ 
+   # in combination with `coord_sf()` we get an appropriate result
+   ggplot(crimes, aes(map_id = state)) +
+     geom_map(aes(fill = Murder), map = states_map) +
+     # crs = 5070 is a Conus Albers projection for North America,
+     #   see: https://epsg.io/5070
+     # default_crs = 4326 tells coord_sf() that the input map data
+     #   are in longitude-latitude format
+     coord_sf(
+       crs = 5070, default_crs = 4326,
+       xlim = c(-125, -70), ylim = c(25, 52)
+     )
+ 
+  ggplot(crimes_long, aes(map_id = state)) +
+    geom_map(aes(fill = value), map = states_map) +
+    coord_sf(
+      crs = 5070, default_crs = 4326,
+      xlim = c(-125, -70), ylim = c(25, 52)
+    ) +
+    facet_wrap(~variable)
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> 
> 
> cleanEx()
> nameEx("geom_path")
> ### * geom_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_path
> ### Title: Connect observations
> ### Aliases: geom_path geom_line geom_step
> 
> ### ** Examples
> 
> # geom_line() is suitable for time series
> ggplot(economics, aes(date, unemploy)) + geom_line()
> ggplot(economics_long, aes(date, value01, colour = variable)) +
+   geom_line()
> 
> # You can get a timeseries that run vertically by setting the orientation
> ggplot(economics, aes(unemploy, date)) + geom_line(orientation = "y")
> 
> # geom_step() is useful when you want to highlight exactly when
> # the y value changes
> recent <- economics[economics$date > as.Date("2013-01-01"), ]
> ggplot(recent, aes(date, unemploy)) + geom_line()
> ggplot(recent, aes(date, unemploy)) + geom_step()
> 
> # geom_path lets you explore how two variables are related over time,
> # e.g. unemployment and personal savings rate
> m <- ggplot(economics, aes(unemploy/pop, psavert))
> m + geom_path()
> m + geom_path(aes(colour = as.numeric(date)))
> 
> # Changing parameters ----------------------------------------------
> ggplot(economics, aes(date, unemploy)) +
+   geom_line(colour = "red")
> 
> # Use the arrow parameter to add an arrow to the line
> # See ?arrow for more details
> c <- ggplot(economics, aes(x = date, y = pop))
> c + geom_line(arrow = arrow())
> c + geom_line(
+   arrow = arrow(angle = 15, ends = "both", type = "closed")
+ )
> 
> # Control line join parameters
> df <- data.frame(x = 1:3, y = c(4, 1, 9))
> base <- ggplot(df, aes(x, y))
> base + geom_path(linewidth = 10)
> base + geom_path(linewidth = 10, lineend = "round")
> base + geom_path(linewidth = 10, linejoin = "mitre", lineend = "butt")
> 
> # You can use NAs to break the line.
> df <- data.frame(x = 1:5, y = c(1, 2, NA, 4, 5))
> ggplot(df, aes(x, y)) + geom_point() + geom_line()
Warning: Removed 1 row containing missing values or values outside the scale range
(`geom_point()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_point")
> ### * geom_point
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_point
> ### Title: Points
> ### Aliases: geom_point
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(wt, mpg))
> p + geom_point()
> 
> # Add aesthetic mappings
> p + geom_point(aes(colour = factor(cyl)))
> p + geom_point(aes(shape = factor(cyl)))
> # A "bubblechart":
> p + geom_point(aes(size = qsec))
> 
> # Set aesthetics to fixed value
> ggplot(mtcars, aes(wt, mpg)) + geom_point(colour = "red", size = 3)
> 
> 
> # For shapes that have a border (like 21), you can colour the inside and
> # outside separately. Use the stroke aesthetic to modify the width of the
> # border
> ggplot(mtcars, aes(wt, mpg)) +
+   geom_point(shape = 21, colour = "black", fill = "white", size = 5, stroke = 5)
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_polygon")
> ### * geom_polygon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_polygon
> ### Title: Polygons
> ### Aliases: geom_polygon
> 
> ### ** Examples
> 
> # When using geom_polygon, you will typically need two data frames:
> # one contains the coordinates of each polygon (positions),  and the
> # other the values associated with each polygon (values).  An id
> # variable links the two together
> 
> ids <- factor(c("1.1", "2.1", "1.2", "2.2", "1.3", "2.3"))
> 
> values <- data.frame(
+   id = ids,
+   value = c(3, 3.1, 3.1, 3.2, 3.15, 3.5)
+ )
> 
> positions <- data.frame(
+   id = rep(ids, each = 4),
+   x = c(2, 1, 1.1, 2.2, 1, 0, 0.3, 1.1, 2.2, 1.1, 1.2, 2.5, 1.1, 0.3,
+   0.5, 1.2, 2.5, 1.2, 1.3, 2.7, 1.2, 0.5, 0.6, 1.3),
+   y = c(-0.5, 0, 1, 0.5, 0, 0.5, 1.5, 1, 0.5, 1, 2.1, 1.7, 1, 1.5,
+   2.2, 2.1, 1.7, 2.1, 3.2, 2.8, 2.1, 2.2, 3.3, 3.2)
+ )
> 
> # Currently we need to manually merge the two together
> datapoly <- merge(values, positions, by = c("id"))
> 
> p <- ggplot(datapoly, aes(x = x, y = y)) +
+   geom_polygon(aes(fill = value, group = id))
> p
> 
> # Which seems like a lot of work, but then it's easy to add on
> # other features in this coordinate system, e.g.:
> 
> set.seed(1)
> stream <- data.frame(
+   x = cumsum(runif(50, max = 0.1)),
+   y = cumsum(runif(50,max = 0.1))
+ )
> 
> p + geom_line(data = stream, colour = "grey30", linewidth = 5)
> 
> # And if the positions are in longitude and latitude, you can use
> # coord_map to produce different map projections.
> 
> if (packageVersion("grid") >= "3.6") {
+   # As of R version 3.6 geom_polygon() supports polygons with holes
+   # Use the subgroup aesthetic to differentiate holes from the main polygon
+ 
+   holes <- do.call(rbind, lapply(split(datapoly, datapoly$id), function(df) {
+     df$x <- df$x + 0.5 * (mean(df$x) - df$x)
+     df$y <- df$y + 0.5 * (mean(df$y) - df$y)
+     df
+   }))
+   datapoly$subid <- 1L
+   holes$subid <- 2L
+   datapoly <- rbind(datapoly, holes)
+ 
+   p <- ggplot(datapoly, aes(x = x, y = y)) +
+     geom_polygon(aes(fill = value, group = id, subgroup = subid))
+   p
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_qq")
> ### * geom_qq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_qq_line
> ### Title: A quantile-quantile plot
> ### Aliases: geom_qq_line stat_qq_line geom_qq stat_qq
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_quantile")
> ### * geom_quantile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_quantile
> ### Title: Quantile regression
> ### Aliases: geom_quantile stat_quantile
> 
> ### ** Examples
> 
> m <-
+   ggplot(mpg, aes(displ, 1 / hwy)) +
+   geom_point()
> m + geom_quantile()
Smoothing formula not specified. Using: y ~ x
> m + geom_quantile(quantiles = 0.5)
Smoothing formula not specified. Using: y ~ x
> q10 <- seq(0.05, 0.95, by = 0.05)
> m + geom_quantile(quantiles = q10)
Smoothing formula not specified. Using: y ~ x
> 
> # You can also use rqss to fit smooth quantiles
> m + geom_quantile(method = "rqss")
Smoothing formula not specified. Using: y ~ qss(x, lambda = 1)
> # Note that rqss doesn't pick a smoothing constant automatically, so
> # you'll need to tweak lambda yourself
> m + geom_quantile(method = "rqss", lambda = 0.1)
Smoothing formula not specified. Using: y ~ qss(x, lambda = 0.1)
Warning in rq.fit.sfn(x, y, tau = tau, rhs = rhs, control = control, ...) :
  tiny diagonals replaced with Inf when calling blkfct

Warning in rq.fit.sfn(x, y, tau = tau, rhs = rhs, control = control, ...) :
  tiny diagonals replaced with Inf when calling blkfct

Warning in rq.fit.sfn(x, y, tau = tau, rhs = rhs, control = control, ...) :
  tiny diagonals replaced with Inf when calling blkfct

> 
> # Set aesthetics to fixed value
> m + geom_quantile(colour = "red", linewidth = 2, alpha = 0.5)
Smoothing formula not specified. Using: y ~ x
> 
> 
> 
> cleanEx()
> nameEx("geom_ribbon")
> ### * geom_ribbon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_ribbon
> ### Title: Ribbons and area plots
> ### Aliases: geom_ribbon geom_area stat_align
> 
> ### ** Examples
> 
> # Generate data
> huron <- data.frame(year = 1875:1972, level = as.vector(LakeHuron))
> h <- ggplot(huron, aes(year))
> 
> h + geom_ribbon(aes(ymin=0, ymax=level))
> h + geom_area(aes(y = level))
> 
> # Orientation cannot be deduced by mapping, so must be given explicitly for
> # flipped orientation
> h + geom_area(aes(x = level, y = year), orientation = "y")
> 
> # Add aesthetic mappings
> h +
+   geom_ribbon(aes(ymin = level - 1, ymax = level + 1), fill = "grey70") +
+   geom_line(aes(y = level))
> 
> # The underlying stat_align() takes care of unaligned data points
> df <- data.frame(
+   g = c("a", "a", "a", "b", "b", "b"),
+   x = c(1, 3, 5, 2, 4, 6),
+   y = c(2, 5, 1, 3, 6, 7)
+ )
> a <- ggplot(df, aes(x, y, fill = g)) +
+   geom_area()
> 
> # Two groups have points on different X values.
> a + geom_point(size = 8) + facet_grid(g ~ .)
> 
> # stat_align() interpolates and aligns the value so that the areas can stack
> # properly.
> a + geom_point(stat = "align", position = "stack", size = 8)
> 
> # To turn off the alignment, the stat can be set to "identity"
> ggplot(df, aes(x, y, fill = g)) +
+   geom_area(stat = "identity")
> 
> 
> 
> cleanEx()
> nameEx("geom_rug")
> ### * geom_rug
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_rug
> ### Title: Rug plots in the margins
> ### Aliases: geom_rug
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(wt, mpg)) +
+   geom_point()
> p
> p + geom_rug()
> p + geom_rug(sides="b")    # Rug on bottom only
> p + geom_rug(sides="trbl") # All four sides
> 
> # Use jittering to avoid overplotting for smaller datasets
> ggplot(mpg, aes(displ, cty)) +
+   geom_point() +
+   geom_rug()
> 
> ggplot(mpg, aes(displ, cty)) +
+   geom_jitter() +
+   geom_rug(alpha = 1/2, position = "jitter")
> 
> # move the rug tassels to outside the plot
> # remember to set clip = "off".
> p +
+   geom_rug(outside = TRUE) +
+   coord_cartesian(clip = "off")
> 
> # set sides to top right, and then move the margins
> p +
+   geom_rug(outside = TRUE, sides = "tr") +
+   coord_cartesian(clip = "off") +
+   theme(plot.margin = margin(1, 1, 1, 1, "cm"))
> 
> # increase the line length and
> # expand axis to avoid overplotting
> p +
+   geom_rug(length = unit(0.05, "npc")) +
+   scale_y_continuous(expand = c(0.1, 0.1))
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_segment")
> ### * geom_segment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_segment
> ### Title: Line segments and curves
> ### Aliases: geom_segment geom_curve
> 
> ### ** Examples
> 
> b <- ggplot(mtcars, aes(wt, mpg)) +
+   geom_point()
> 
> df <- data.frame(x1 = 2.62, x2 = 3.57, y1 = 21.0, y2 = 15.0)
> b +
+  geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = df) +
+  geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "segment"), data = df)
> 
> b + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2), data = df, curvature = -0.2)
> b + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2), data = df, curvature = 1)
> b + geom_curve(
+   aes(x = x1, y = y1, xend = x2, yend = y2),
+   data = df,
+   arrow = arrow(length = unit(0.03, "npc"))
+ )
> 
> if (requireNamespace('maps', quietly = TRUE)) {
+ ggplot(seals, aes(long, lat)) +
+   geom_segment(aes(xend = long + delta_long, yend = lat + delta_lat),
+     arrow = arrow(length = unit(0.1,"cm"))) +
+   borders("state")
+ }
> 
> # Use lineend and linejoin to change the style of the segments
> df2 <- expand.grid(
+   lineend = c('round', 'butt', 'square'),
+   linejoin = c('round', 'mitre', 'bevel'),
+   stringsAsFactors = FALSE
+ )
> df2 <- data.frame(df2, y = 1:9)
> ggplot(df2, aes(x = 1, y = y, xend = 2, yend = y, label = paste(lineend, linejoin))) +
+   geom_segment(
+      lineend = df2$lineend, linejoin = df2$linejoin,
+      size = 3, arrow = arrow(length = unit(0.3, "inches"))
+   ) +
+   geom_text(hjust = 'outside', nudge_x = -0.2) +
+   xlim(0.5, 2)
> 
> # You can also use geom_segment to recreate plot(type = "h") :
> set.seed(1)
> counts <- as.data.frame(table(x = rpois(100,5)))
> counts$x <- as.numeric(as.character(counts$x))
> with(counts, plot(x, Freq, type = "h", lwd = 10))
> 
> ggplot(counts, aes(x, Freq)) +
+   geom_segment(aes(xend = x, yend = 0), linewidth = 10, lineend = "butt")
> 
> 
> 
> cleanEx()
> nameEx("geom_smooth")
> ### * geom_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_smooth
> ### Title: Smoothed conditional means
> ### Aliases: geom_smooth stat_smooth
> 
> ### ** Examples
> 
> ggplot(mpg, aes(displ, hwy)) +
+   geom_point() +
+   geom_smooth()
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # If you need the fitting to be done along the y-axis set the orientation
> ggplot(mpg, aes(displ, hwy)) +
+   geom_point() +
+   geom_smooth(orientation = "y")
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # Use span to control the "wiggliness" of the default loess smoother.
> # The span is the fraction of points used to fit each local regression:
> # small numbers make a wigglier curve, larger numbers make a smoother curve.
> ggplot(mpg, aes(displ, hwy)) +
+   geom_point() +
+   geom_smooth(span = 0.3)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # Instead of a loess smooth, you can use any other modelling function:
> ggplot(mpg, aes(displ, hwy)) +
+   geom_point() +
+   geom_smooth(method = lm, se = FALSE)
`geom_smooth()` using formula = 'y ~ x'
> 
> ggplot(mpg, aes(displ, hwy)) +
+   geom_point() +
+   geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = FALSE)
> 
> # Smooths are automatically fit to each group (defined by categorical
> # aesthetics or the group aesthetic) and for each facet.
> 
> ggplot(mpg, aes(displ, hwy, colour = class)) +
+   geom_point() +
+   geom_smooth(se = FALSE, method = lm)
`geom_smooth()` using formula = 'y ~ x'
> ggplot(mpg, aes(displ, hwy)) +
+   geom_point() +
+   geom_smooth(span = 0.8) +
+   facet_wrap(~drv)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_spoke")
> ### * geom_spoke
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_spoke
> ### Title: Line segments parameterised by location, direction and distance
> ### Aliases: geom_spoke stat_spoke
> 
> ### ** Examples
> 
> df <- expand.grid(x = 1:10, y=1:10)
> 
> set.seed(1)
> df$angle <- runif(100, 0, 2*pi)
> df$speed <- runif(100, 0, sqrt(0.1 * df$x))
> 
> ggplot(df, aes(x, y)) +
+   geom_point() +
+   geom_spoke(aes(angle = angle), radius = 0.5)
> 
> ggplot(df, aes(x, y)) +
+   geom_point() +
+   geom_spoke(aes(angle = angle, radius = speed))
> 
> 
> 
> cleanEx()
> nameEx("geom_text")
> ### * geom_text
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_label
> ### Title: Text
> ### Aliases: geom_label geom_text
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(wt, mpg, label = rownames(mtcars)))
> 
> p + geom_text()
> # Avoid overlaps
> p + geom_text(check_overlap = TRUE)
> # Labels with background
> p + geom_label()
> # Change size of the label
> p + geom_text(size = 10)
> 
> # Set aesthetics to fixed value
> p +
+   geom_point() +
+   geom_text(hjust = 0, nudge_x = 0.05)
> p +
+   geom_point() +
+   geom_text(vjust = 0, nudge_y = 0.5)
> p +
+   geom_point() +
+   geom_text(angle = 45)
> ## Not run: 
> ##D # Doesn't work on all systems
> ##D p +
> ##D   geom_text(family = "Times New Roman")
> ## End(Not run)
> 
> # Add aesthetic mappings
> p + geom_text(aes(colour = factor(cyl)))
> p + geom_text(aes(colour = factor(cyl))) +
+   scale_colour_discrete(l = 40)
> p + geom_label(aes(fill = factor(cyl)), colour = "white", fontface = "bold")
> 
> p + geom_text(aes(size = wt))
> # Scale height of text, rather than sqrt(height)
> p +
+   geom_text(aes(size = wt)) +
+   scale_radius(range = c(3,6))
> 
> # You can display expressions by setting parse = TRUE.  The
> # details of the display are described in ?plotmath, but note that
> # geom_text uses strings, not expressions.
> p +
+   geom_text(
+     aes(label = paste(wt, "^(", cyl, ")", sep = "")),
+     parse = TRUE
+   )
> 
> # Add a text annotation
> p +
+   geom_text() +
+   annotate(
+     "text", label = "plot mpg vs. wt",
+     x = 2, y = 15, size = 8, colour = "red"
+   )
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_tile")
> ### * geom_tile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_raster
> ### Title: Rectangles
> ### Aliases: geom_raster geom_rect geom_tile
> 
> ### ** Examples
> 
> # The most common use for rectangles is to draw a surface. You always want
> # to use geom_raster here because it's so much faster, and produces
> # smaller output when saving to PDF
> ggplot(faithfuld, aes(waiting, eruptions)) +
+  geom_raster(aes(fill = density))
> 
> # Interpolation smooths the surface & is most helpful when rendering images.
> ggplot(faithfuld, aes(waiting, eruptions)) +
+  geom_raster(aes(fill = density), interpolate = TRUE)
> 
> # If you want to draw arbitrary rectangles, use geom_tile() or geom_rect()
> df <- data.frame(
+   x = rep(c(2, 5, 7, 9, 12), 2),
+   y = rep(c(1, 2), each = 5),
+   z = factor(rep(1:5, each = 2)),
+   w = rep(diff(c(0, 4, 6, 8, 10, 14)), 2)
+ )
> ggplot(df, aes(x, y)) +
+   geom_tile(aes(fill = z), colour = "grey50")
> ggplot(df, aes(x, y, width = w)) +
+   geom_tile(aes(fill = z), colour = "grey50")
> ggplot(df, aes(xmin = x - w / 2, xmax = x + w / 2, ymin = y, ymax = y + 1)) +
+   geom_rect(aes(fill = z), colour = "grey50")
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_violin")
> ### * geom_violin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_violin
> ### Title: Violin plot
> ### Aliases: geom_violin stat_ydensity
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(factor(cyl), mpg))
> p + geom_violin()
> 
> # Orientation follows the discrete axis
> ggplot(mtcars, aes(mpg, factor(cyl))) +
+   geom_violin()
> 
> 
> 
> 
> cleanEx()
> nameEx("get_alt_text")
> ### * get_alt_text
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_alt_text
> ### Title: Extract alt text from a plot
> ### Aliases: get_alt_text alt_text
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(displ, hwy)) +
+   geom_point()
> 
> # Returns an empty string
> get_alt_text(p)
[1] ""
> 
> # A user provided alt text
> p <- p + labs(
+   alt = paste("A scatterplot showing the negative correlation between engine",
+               "displacement as a function of highway miles per gallon")
+ )
> 
> get_alt_text(p)
[1] "A scatterplot showing the negative correlation between engine displacement as a function of highway miles per gallon"
> 
> 
> 
> 
> cleanEx()
> nameEx("get_guide_data")
> ### * get_guide_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_guide_data
> ### Title: Extract tick information from guides
> ### Aliases: get_guide_data
> ### Keywords: internal
> 
> ### ** Examples
> 
> # A standard plot
> p <- ggplot(mtcars) +
+   aes(mpg, disp, colour = drat, size = drat) +
+   geom_point() +
+   facet_wrap(vars(cyl), scales = "free_x")
> 
> # Guide information for legends
> get_guide_data(p, "size")
      size .value .label
1 2.662822    3.0    3.0
2 3.919819    3.5    3.5
3 4.779645    4.0    4.0
4 5.477285    4.5    4.5
> 
> # Note that legend guides can be merged
> merged <- p + guides(colour = "legend")
> get_guide_data(merged, "size")
   colour .value .label     size
1 #1A3855    3.0    3.0 2.662822
2 #28557C    3.5    3.5 3.919819
3 #3874A5    4.0    4.0 4.779645
4 #4894D0    4.5    4.5 5.477285
> 
> # Guide information for positions
> get_guide_data(p, "x", panel = 2)
          x .value .label y
1 0.0959596     18     18 0
2 0.3484848     19     19 0
3 0.6010101     20     20 0
4 0.8535354     21     21 0
> 
> # Coord polar doesn't support proper guides, so we get a list
> polar <- p + coord_polar()
> get_guide_data(polar, "theta", panel = 2)
$theta.range
[1] 17.8 21.4

$theta.major
[1] 18 19 20 21

$theta.minor
[1] 18.0 18.5 19.0 19.5 20.0 20.5 21.0

$theta.labels
[1] "18" "19" "20" "21"

> 
> 
> 
> cleanEx()
> nameEx("gg-add")
> ### * gg-add
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: +.gg
> ### Title: Add components to a plot
> ### Aliases: +.gg %+%
> 
> ### ** Examples
> 
> base <-
+  ggplot(mpg, aes(displ, hwy)) +
+  geom_point()
> base + geom_smooth()
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # To override the data, you must use %+%
> base %+% subset(mpg, fl == "p")
> 
> # Alternatively, you can add multiple components with a list.
> # This can be useful to return from a function.
> base + list(subset(mpg, fl == "p"), geom_smooth())
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> 
> 
> cleanEx()
> nameEx("ggplot")
> ### * ggplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ggplot
> ### Title: Create a new ggplot
> ### Aliases: ggplot
> 
> ### ** Examples
> 
> # Create a data frame with some sample data, then create a data frame
> # containing the mean value for each group in the sample data.
> set.seed(1)
> 
> sample_df <- data.frame(
+   group = factor(rep(letters[1:3], each = 10)),
+   value = rnorm(30)
+ )
> 
> group_means_df <- setNames(
+   aggregate(value ~ group, sample_df, mean),
+   c("group", "group_mean")
+ )
> 
> # The following three code blocks create the same graphic, each using one
> # of the three patterns specified above. In each graphic, the sample data
> # are plotted in the first layer and the group means data frame is used to
> # plot larger red points on top of the sample data in the second layer.
> 
> # Pattern 1
> # Both the `data` and `mapping` arguments are passed into the `ggplot()`
> # call. Those arguments are omitted in the first `geom_point()` layer
> # because they get passed along from the `ggplot()` call. Note that the
> # second `geom_point()` layer re-uses the `x = group` aesthetic through
> # that mechanism but overrides the y-position aesthetic.
> ggplot(data = sample_df, mapping = aes(x = group, y = value)) +
+   geom_point() +
+   geom_point(
+     mapping = aes(y = group_mean), data = group_means_df,
+     colour = 'red', size = 3
+   )
> 
> # Pattern 2
> # Same plot as above, passing only the `data` argument into the `ggplot()`
> # call. The `mapping` arguments are now required in each `geom_point()`
> # layer because there is no `mapping` argument passed along from the
> # `ggplot()` call.
> ggplot(data = sample_df) +
+   geom_point(mapping = aes(x = group, y = value)) +
+   geom_point(
+     mapping = aes(x = group, y = group_mean), data = group_means_df,
+     colour = 'red', size = 3
+   )
> 
> # Pattern 3
> # Same plot as above, passing neither the `data` or `mapping` arguments
> # into the `ggplot()` call. Both those arguments are now required in
> # each `geom_point()` layer. This pattern can be particularly useful when
> # creating more complex graphics with many layers using data from multiple
> # data frames.
> ggplot() +
+   geom_point(mapping = aes(x = group, y = value), data = sample_df) +
+   geom_point(
+     mapping = aes(x = group, y = group_mean), data = group_means_df,
+     colour = 'red', size = 3
+   )
> 
> 
> 
> cleanEx()
> nameEx("ggproto")
> ### * ggproto
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ggproto
> ### Title: Create a new ggproto object
> ### Aliases: ggproto ggproto_parent is.ggproto
> 
> ### ** Examples
> 
> Adder <- ggproto("Adder",
+   x = 0,
+   add = function(self, n) {
+     self$x <- self$x + n
+     self$x
+   }
+  )
> is.ggproto(Adder)
[1] TRUE
> 
> Adder$add(10)
[1] 10
> Adder$add(10)
[1] 20
> 
> Doubler <- ggproto("Doubler", Adder,
+   add = function(self, n) {
+     ggproto_parent(Adder, self)$add(n * 2)
+   }
+ )
> Doubler$x
[1] 20
> Doubler$add(10)
[1] 40
> 
> 
> 
> cleanEx()
> nameEx("ggsave")
> ### * ggsave
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ggsave
> ### Title: Save a ggplot (or other grid object) with sensible defaults
> ### Aliases: ggsave
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggplot(mtcars, aes(mpg, wt)) +
> ##D   geom_point()
> ##D 
> ##D # here, the device is inferred from the filename extension
> ##D ggsave("mtcars.pdf")
> ##D ggsave("mtcars.png")
> ##D 
> ##D # setting dimensions of the plot
> ##D ggsave("mtcars.pdf", width = 4, height = 4)
> ##D ggsave("mtcars.pdf", width = 20, height = 20, units = "cm")
> ##D 
> ##D # passing device-specific arguments to '...'
> ##D ggsave("mtcars.pdf", colormodel = "cmyk")
> ##D 
> ##D # delete files with base::unlink()
> ##D unlink("mtcars.pdf")
> ##D unlink("mtcars.png")
> ##D 
> ##D # specify device when saving to a file with unknown extension
> ##D # (for example a server supplied temporary file)
> ##D file <- tempfile()
> ##D ggsave(file, device = "pdf")
> ##D unlink(file)
> ##D 
> ##D # save plot to file without using ggsave
> ##D p <-
> ##D   ggplot(mtcars, aes(mpg, wt)) +
> ##D   geom_point()
> ##D png("mtcars.png")
> ##D print(p)
> ##D dev.off()
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ggsf")
> ### * ggsf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CoordSf
> ### Title: Visualise sf objects
> ### Aliases: CoordSf coord_sf ggsf GeomSf geom_sf geom_sf_label
> ###   geom_sf_text StatSf stat_sf
> ### Keywords: datasets
> 
> ### ** Examples
> 
> if (requireNamespace("sf", quietly = TRUE)) {
+ nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
+ ggplot(nc) +
+   geom_sf(aes(fill = AREA))
+ 
+ # If not supplied, coord_sf() will take the CRS from the first layer
+ # and automatically transform all other layers to use that CRS. This
+ # ensures that all data will correctly line up
+ nc_3857 <- sf::st_transform(nc, 3857)
+ ggplot() +
+   geom_sf(data = nc) +
+   geom_sf(data = nc_3857, colour = "red", fill = NA)
+ 
+ # Unfortunately if you plot other types of feature you'll need to use
+ # show.legend to tell ggplot2 what type of legend to use
+ nc_3857$mid <- sf::st_centroid(nc_3857$geometry)
+ ggplot(nc_3857) +
+   geom_sf(colour = "white") +
+   geom_sf(aes(geometry = mid, size = AREA), show.legend = "point")
+ 
+ # You can also use layers with x and y aesthetics. To have these interpreted
+ # as longitude/latitude you need to set the default CRS in coord_sf()
+ ggplot(nc_3857) +
+   geom_sf() +
+   annotate("point", x = -80, y = 35, colour = "red", size = 4) +
+   coord_sf(default_crs = sf::st_crs(4326))
+ 
+ # To add labels, use geom_sf_label().
+ ggplot(nc_3857[1:3, ]) +
+    geom_sf(aes(fill = AREA)) +
+    geom_sf_label(aes(label = NAME))
+ }
> 
> # Thanks to the power of sf, a geom_sf nicely handles varying projections
> # setting the aspect ratio correctly.
> if (requireNamespace('maps', quietly = TRUE)) {
+ library(maps)
+ world1 <- sf::st_as_sf(map('world', plot = FALSE, fill = TRUE))
+ ggplot() + geom_sf(data = world1)
+ 
+ world2 <- sf::st_transform(
+   world1,
+   "+proj=laea +y_0=0 +lon_0=155 +lat_0=-90 +ellps=WGS84 +no_defs"
+ )
+ ggplot() + geom_sf(data = world2)
+ }
> 
> 
> 
> cleanEx()
> nameEx("ggtheme")
> ### * ggtheme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ggtheme
> ### Title: Complete themes
> ### Aliases: theme_grey theme_gray theme_bw theme_linedraw theme_light
> ###   theme_dark theme_minimal theme_classic theme_void theme_test
> 
> ### ** Examples
> 
> mtcars2 <- within(mtcars, {
+   vs <- factor(vs, labels = c("V-shaped", "Straight"))
+   am <- factor(am, labels = c("Automatic", "Manual"))
+   cyl  <- factor(cyl)
+   gear <- factor(gear)
+ })
> 
> p1 <- ggplot(mtcars2) +
+   geom_point(aes(x = wt, y = mpg, colour = gear)) +
+   labs(
+     title = "Fuel economy declines as weight increases",
+     subtitle = "(1973-74)",
+     caption = "Data from the 1974 Motor Trend US magazine.",
+     tag = "Figure 1",
+     x = "Weight (1000 lbs)",
+     y = "Fuel economy (mpg)",
+     colour = "Gears"
+   )
> 
> p1 + theme_gray() # the default
> p1 + theme_bw()
> p1 + theme_linedraw()
> p1 + theme_light()
> p1 + theme_dark()
> p1 + theme_minimal()
> p1 + theme_classic()
> p1 + theme_void()
> 
> # Theme examples with panels
> 
> 
> 
> cleanEx()
> nameEx("guide_axis")
> ### * guide_axis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_axis
> ### Title: Axis guide
> ### Aliases: guide_axis
> 
> ### ** Examples
> 
> # plot with overlapping text
> p <- ggplot(mpg, aes(cty * 100, hwy * 100)) +
+   geom_point() +
+   facet_wrap(vars(class))
> 
> # axis guides can be customized in the scale_* functions or
> # using guides()
> p + scale_x_continuous(guide = guide_axis(n.dodge = 2))
> p + guides(x = guide_axis(angle = 90))
> 
> # can also be used to add a duplicate guide
> p + guides(x = guide_axis(n.dodge = 2), y.sec = guide_axis())
> 
> 
> 
> cleanEx()
> nameEx("guide_axis_logticks")
> ### * guide_axis_logticks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_axis_logticks
> ### Title: Axis with logarithmic tick marks
> ### Aliases: guide_axis_logticks
> 
> ### ** Examples
> 
> # A standard plot
> p <- ggplot(msleep, aes(bodywt, brainwt)) +
+   geom_point(na.rm = TRUE)
> 
> # The logticks axis works well with log scales
> p + scale_x_log10(guide = "axis_logticks") +
+   scale_y_log10(guide = "axis_logticks")
> 
> # Or with log-transformed coordinates
> p + coord_trans(x = "log10", y = "log10") +
+   guides(x = "axis_logticks", y = "axis_logticks")
> 
> # When data is transformed manually, one should provide `prescale.base`
> # Keep in mind that this axis uses log10 space for placement, not log2
> p + aes(x = log2(bodywt), y = log10(brainwt)) +
+   guides(
+     x = guide_axis_logticks(prescale.base = 2),
+     y = guide_axis_logticks(prescale.base = 10)
+   )
> 
> # A plot with both positive and negative extremes, pseudo-log transformed
> set.seed(42)
> p2 <- ggplot(data.frame(x = rcauchy(1000)), aes(x = x)) +
+   geom_density() +
+   scale_x_continuous(
+     breaks = c(-10^(4:0), 0, 10^(0:4)),
+     transform = "pseudo_log"
+   )
> 
> # The log ticks are mirrored when 0 is included
> p2 + guides(x = "axis_logticks")
> 
> # To control the tick density around 0, one can set `negative.small`
> p2 + guides(x = guide_axis_logticks(negative.small = 1))
> 
> 
> 
> cleanEx()
> nameEx("guide_axis_stack")
> ### * guide_axis_stack
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_axis_stack
> ### Title: Stacked axis guides
> ### Aliases: guide_axis_stack
> 
> ### ** Examples
> 
> #' # A standard plot
> p <- ggplot(mpg, aes(displ, hwy)) +
+   geom_point() +
+   theme(axis.line = element_line())
> 
> # A normal axis first, then a capped axis
> p + guides(x = guide_axis_stack("axis", guide_axis(cap = "both")))
> 
> 
> 
> cleanEx()
> nameEx("guide_axis_theta")
> ### * guide_axis_theta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_axis_theta
> ### Title: Angle axis guide
> ### Aliases: guide_axis_theta
> 
> ### ** Examples
> 
> # A plot using coord_radial
> p <- ggplot(mtcars, aes(disp, mpg)) +
+   geom_point() +
+   coord_radial()
> 
> # The `angle` argument can be used to set relative angles
> p + guides(theta = guide_axis_theta(angle = 0))
> 
> 
> 
> cleanEx()
> nameEx("guide_bins")
> ### * guide_bins
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_bins
> ### Title: A binned version of guide_legend
> ### Aliases: guide_bins
> 
> ### ** Examples
> 
> p <- ggplot(mtcars) +
+   geom_point(aes(disp, mpg, size = hp)) +
+   scale_size_binned()
> 
> # Standard look
> p
> 
> # Remove the axis or style it
> p + guides(size = guide_bins(
+   theme = theme(legend.axis.line = element_blank())
+ ))
> 
> p + guides(size = guide_bins(show.limits = TRUE))
> 
> my_arrow <- arrow(length = unit(1.5, "mm"), ends = "both")
> p + guides(size = guide_bins(
+   theme = theme(legend.axis.line = element_line(arrow = my_arrow))
+ ))
> 
> # Guides are merged together if possible
> ggplot(mtcars) +
+   geom_point(aes(disp, mpg, size = hp, colour = hp)) +
+   scale_size_binned() +
+   scale_colour_binned(guide = "bins")
> 
> 
> 
> 
> cleanEx()
> nameEx("guide_colourbar")
> ### * guide_colourbar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_colourbar
> ### Title: Continuous colour bar guide
> ### Aliases: guide_colourbar guide_colorbar
> 
> ### ** Examples
> 
> df <- expand.grid(X1 = 1:10, X2 = 1:10)
> df$value <- df$X1 * df$X2
> 
> p1 <- ggplot(df, aes(X1, X2)) + geom_tile(aes(fill = value))
> p2 <- p1 + geom_point(aes(size = value))
> 
> # Basic form
> p1 + scale_fill_continuous(guide = "colourbar")
> p1 + scale_fill_continuous(guide = guide_colourbar())
> p1 + guides(fill = guide_colourbar())
> 
> # Control styles
> 
> # bar size
> p1 + guides(fill = guide_colourbar(theme = theme(
+   legend.key.width  = unit(0.5, "lines"),
+   legend.key.height = unit(10, "lines")
+ )))
> 
> 
> # no label
> p1 + guides(fill = guide_colourbar(theme = theme(
+   legend.text = element_blank()
+ )))
> 
> # no tick marks
> p1 + guides(fill = guide_colourbar(theme = theme(
+   legend.ticks = element_blank()
+ )))
> 
> # label position
> p1 + guides(fill = guide_colourbar(theme = theme(
+   legend.text.position = "left"
+ )))
> 
> # label theme
> p1 + guides(fill = guide_colourbar(theme = theme(
+   legend.text = element_text(colour = "blue", angle = 0)
+ )))
> 
> # small number of bins
> p1 + guides(fill = guide_colourbar(nbin = 3))
> 
> # large number of bins
> p1 + guides(fill = guide_colourbar(nbin = 100))
> 
> # make top- and bottom-most ticks invisible
> p1 +
+   scale_fill_continuous(
+     limits = c(0,20), breaks = c(0, 5, 10, 15, 20),
+     guide = guide_colourbar(nbin = 100, draw.ulim = FALSE, draw.llim = FALSE)
+   )
> 
> # guides can be controlled independently
> p2 +
+   scale_fill_continuous(guide = "colourbar") +
+   scale_size(guide = "legend")
> p2 + guides(fill = "colourbar", size = "legend")
> 
> p2 +
+   scale_fill_continuous(guide = guide_colourbar(theme = theme(
+     legend.direction = "horizontal"
+   ))) +
+   scale_size(guide = guide_legend(theme = theme(
+     legend.direction = "vertical"
+   )))
> 
> 
> 
> cleanEx()
> nameEx("guide_coloursteps")
> ### * guide_coloursteps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_coloursteps
> ### Title: Discretized colourbar guide
> ### Aliases: guide_coloursteps guide_colorsteps
> 
> ### ** Examples
> 
> df <- expand.grid(X1 = 1:10, X2 = 1:10)
> df$value <- df$X1 * df$X2
> 
> p <- ggplot(df, aes(X1, X2)) + geom_tile(aes(fill = value))
> 
> # Coloursteps guide is the default for binned colour scales
> p + scale_fill_binned()
> 
> # By default each bin in the guide is the same size irrespectively of how
> # their sizes relate in data space
> p + scale_fill_binned(breaks = c(10, 25, 50))
> 
> # This can be changed with the `even.steps` argument
> p + scale_fill_binned(
+   breaks = c(10, 25, 50),
+   guide = guide_coloursteps(even.steps = FALSE)
+ )
> 
> # By default the limits is not shown, but this can be changed
> p + scale_fill_binned(guide = guide_coloursteps(show.limits = TRUE))
> 
> # (can also be set in the scale)
> p + scale_fill_binned(show.limits = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("guide_custom")
> ### * guide_custom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_custom
> ### Title: Custom guides
> ### Aliases: guide_custom
> 
> ### ** Examples
> 
> # A standard plot
> p <- ggplot(mpg, aes(displ, hwy)) +
+   geom_point()
> 
> # Define a graphical object
> circle <- grid::circleGrob()
> 
> # Rendering a grob as a guide
> p + guides(custom = guide_custom(circle, title = "My circle"))
> 
> # Controlling the size of the grob defined in relative units
> p + guides(custom = guide_custom(
+   circle, title = "My circle",
+   width = unit(2, "cm"), height = unit(2, "cm"))
+ )
> 
> # Size of grobs in absolute units is taken directly without the need to
> # set these manually
> p + guides(custom = guide_custom(
+   title = "My circle",
+   grob = grid::circleGrob(r = unit(1, "cm"))
+ ))
> 
> 
> 
> cleanEx()
> nameEx("guide_legend")
> ### * guide_legend
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guide_legend
> ### Title: Legend guide
> ### Aliases: guide_legend
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("guides")
> ### * guides
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guides
> ### Title: Set guides for each scale
> ### Aliases: guides
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("hmisc")
> ### * hmisc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hmisc
> ### Title: A selection of summary functions from Hmisc
> ### Aliases: hmisc mean_cl_boot mean_cl_normal mean_sdl median_hilow
> 
> ### ** Examples
> 
> if (requireNamespace("Hmisc", quietly = TRUE)) {
+ set.seed(1)
+ x <- rnorm(100)
+ mean_cl_boot(x)
+ mean_cl_normal(x)
+ mean_sdl(x)
+ median_hilow(x)
+ }
          y      ymin     ymax
1 0.1139092 -1.671298 1.797468
> 
> 
> 
> cleanEx()
> nameEx("ignoring_data")
> ### * ignoring_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ignoring_data
> ### Title: Ignoring and exposing data
> ### Aliases: ignoring_data .ignore_data .expose_data
> ### Keywords: internal
> 
> ### ** Examples
> 
> data <- list(
+   data.frame(x = 1:3, y = I(1:3)),
+   data.frame(w = I(1:3), z = 1:3)
+ )
> 
> ignored <- .ignore_data(data)
> str(ignored)
List of 2
 $ :'data.frame':	3 obs. of  2 variables:
  ..$ x       : int [1:3] 1 2 3
  ..$ .ignored:'data.frame':	3 obs. of  1 variable:
  .. ..$ y: 'AsIs' int [1:3] 1 2 3
 $ :'data.frame':	3 obs. of  2 variables:
  ..$ z       : int [1:3] 1 2 3
  ..$ .ignored:'data.frame':	3 obs. of  1 variable:
  .. ..$ w: 'AsIs' int [1:3] 1 2 3
> 
> .expose_data(ignored)
[[1]]
  x y
1 1 1
2 2 2
3 3 3

[[2]]
  z w
1 1 1
2 2 2
3 3 3

> 
> 
> 
> cleanEx()
> nameEx("label_bquote")
> ### * label_bquote
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_bquote
> ### Title: Label with mathematical expressions
> ### Aliases: label_bquote
> 
> ### ** Examples
> 
> # The variables mentioned in the plotmath expression must be
> # backquoted and referred to by their names.
> p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
> p + facet_grid(vs ~ ., labeller = label_bquote(alpha ^ .(vs)))
> p + facet_grid(. ~ vs, labeller = label_bquote(cols = .(vs) ^ .(vs)))
> p + facet_grid(. ~ vs + am, labeller = label_bquote(cols = .(am) ^ .(vs)))
> 
> 
> 
> cleanEx()
> nameEx("labeller")
> ### * labeller
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: labeller
> ### Title: Construct labelling specification
> ### Aliases: labeller
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("labellers")
> ### * labellers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: labellers
> ### Title: Useful labeller functions
> ### Aliases: labellers label_value label_both label_context label_parsed
> ###   label_wrap_gen
> 
> ### ** Examples
> 
> mtcars$cyl2 <- factor(mtcars$cyl, labels = c("alpha", "beta", "gamma"))
> p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
> 
> # The default is label_value
> p + facet_grid(. ~ cyl, labeller = label_value)
> 
> 
> 
> 
> cleanEx()
> nameEx("labs")
> ### * labs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: labs
> ### Title: Modify axis, legend, and plot labels
> ### Aliases: labs xlab ylab ggtitle
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(mpg, wt, colour = cyl)) + geom_point()
> p + labs(colour = "Cylinders")
> p + labs(x = "New x label")
> 
> # The plot title appears at the top-left, with the subtitle
> # display in smaller text underneath it
> p + labs(title = "New plot title")
> p + labs(title = "New plot title", subtitle = "A subtitle")
> 
> # The caption appears in the bottom-right, and is often used for
> # sources, notes or copyright
> p + labs(caption = "(based on data from ...)")
> 
> # The plot tag appears at the top-left, and is typically used
> # for labelling a subplot with a letter.
> p + labs(title = "title", tag = "A")
> 
> # If you want to remove a label, set it to NULL.
> p +
+  labs(title = "title") +
+  labs(title = NULL)
> 
> 
> 
> cleanEx()
> nameEx("layer")
> ### * layer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: layer
> ### Title: Create a new layer
> ### Aliases: layer
> ### Keywords: internal
> 
> ### ** Examples
> 
> # geom calls are just a short cut for layer
> ggplot(mpg, aes(displ, hwy)) + geom_point()
> # shortcut for
> ggplot(mpg, aes(displ, hwy)) +
+   layer(
+     geom = "point", stat = "identity", position = "identity",
+     params = list(na.rm = FALSE)
+   )
> 
> # use a function as data to plot a subset of global data
> ggplot(mpg, aes(displ, hwy)) +
+   layer(
+     geom = "point", stat = "identity", position = "identity",
+     data = head, params = list(na.rm = FALSE)
+   )
> 
> 
> 
> 
> cleanEx()
> nameEx("limits")
> ### * limits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: limits
> ### Title: Generate correct scale type for specified limits
> ### Aliases: limits
> ### Keywords: internal
> 
> ### ** Examples
> 
> ggplot2:::limits(c(1, 5), "x")
<ScaleContinuousPosition>
 Range:  
 Limits:    1 --    5
> ggplot2:::limits(c(5, 1), "x")
<ScaleContinuousPosition>
 Range:  
 Limits:   -5 --   -1
> ggplot2:::limits(c("A", "b", "c"), "x")
<ggproto object: Class ScaleDiscretePosition, ScaleDiscrete, Scale, gg>
    aesthetics: x xmin xmax xend
    axis_order: function
    break_info: function
    break_positions: function
    breaks: waiver
    call: environment
    clone: function
    dimension: function
    drop: TRUE
    expand: waiver
    get_breaks: function
    get_breaks_minor: function
    get_labels: function
    get_limits: function
    get_transformation: function
    guide: waiver
    is_discrete: function
    is_empty: function
    labels: waiver
    limits: A b c
    make_sec_title: function
    make_title: function
    map: function
    map_df: function
    n.breaks.cache: NULL
    na.translate: TRUE
    na.value: NA
    name: waiver
    palette: function
    palette.cache: NULL
    position: bottom
    range: environment
    range_c: environment
    rescale: function
    reset: function
    train: function
    train_df: function
    transform: function
    transform_df: function
    super:  <ggproto object: Class ScaleDiscretePosition, ScaleDiscrete, Scale, gg>
> ggplot2:::limits(c("A", "b", "c"), "fill")
<ggproto object: Class ScaleDiscrete, Scale, gg>
    aesthetics: fill
    axis_order: function
    break_info: function
    break_positions: function
    breaks: waiver
    call: environment
    clone: function
    dimension: function
    drop: TRUE
    expand: waiver
    get_breaks: function
    get_breaks_minor: function
    get_labels: function
    get_limits: function
    get_transformation: function
    guide: legend
    is_discrete: function
    is_empty: function
    labels: waiver
    limits: A b c
    make_sec_title: function
    make_title: function
    map: function
    map_df: function
    n.breaks.cache: NULL
    na.translate: TRUE
    na.value: grey50
    name: waiver
    palette: function
    palette.cache: NULL
    position: left
    range: environment
    rescale: function
    reset: function
    train: function
    train_df: function
    transform: function
    transform_df: function
    super:  <ggproto object: Class ScaleDiscrete, Scale, gg>
> ggplot2:::limits(as.Date(c("2008-01-01", "2009-01-01")), "x")
<ScaleContinuousDate>
 Range:  
 Limits: 1.39e+04 -- 1.42e+04
> 
> 
> 
> cleanEx()
> nameEx("lims")
> ### * lims
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lims
> ### Title: Set scale limits
> ### Aliases: lims xlim ylim
> 
> ### ** Examples
> 
> # Zoom into a specified area
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point() +
+   xlim(15, 20)
Warning: Removed 19 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> # reverse scale
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point() +
+   xlim(20, 15)
Warning: Removed 19 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> # with automatic lower limit
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point() +
+   xlim(NA, 20)
Warning: Removed 14 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> # You can also supply limits that are larger than the data.
> # This is useful if you want to match scales across different plots
> small <- subset(mtcars, cyl == 4)
> big <- subset(mtcars, cyl > 4)
> 
> ggplot(small, aes(mpg, wt, colour = factor(cyl))) +
+   geom_point() +
+   lims(colour = c("4", "6", "8"))
> 
> ggplot(big, aes(mpg, wt, colour = factor(cyl))) +
+   geom_point() +
+   lims(colour = c("4", "6", "8"))
> 
> # There are two ways of setting the axis limits: with limits or
> # with coordinate systems. They work in two rather different ways.
> 
> set.seed(1)
> last_month <- Sys.Date() - 0:59
> df <- data.frame(
+   date = last_month,
+   price = c(rnorm(30, mean = 15), runif(30) + 0.2 * (1:30))
+ )
> 
> p <- ggplot(df, aes(date, price)) +
+   geom_line() +
+   stat_smooth()
> 
> p
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # Setting the limits with the scale discards all data outside the range.
> p + lims(x= c(Sys.Date() - 30, NA), y = c(10, 20))
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
Warning: Removed 30 rows containing non-finite outside the scale range
(`stat_smooth()`).
Warning: Removed 30 rows containing missing values or values outside the scale range
(`geom_line()`).
> 
> # For changing x or y axis limits **without** dropping data
> # observations use [coord_cartesian()]. Setting the limits on the
> # coordinate system performs a visual zoom.
> p + coord_cartesian(xlim =c(Sys.Date() - 30, NA), ylim = c(10, 20))
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> 
> 
> 
> cleanEx()
> nameEx("map_data")
> ### * map_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: map_data
> ### Title: Create a data frame of map data
> ### Aliases: map_data
> ### Keywords: internal
> 
> ### ** Examples
> 
> if (require("maps")) {
+ states <- map_data("state")
+ arrests <- USArrests
+ names(arrests) <- tolower(names(arrests))
+ arrests$region <- tolower(rownames(USArrests))
+ 
+ choro <- merge(states, arrests, sort = FALSE, by = "region")
+ choro <- choro[order(choro$order), ]
+ ggplot(choro, aes(long, lat)) +
+   geom_polygon(aes(group = group, fill = assault)) +
+   coord_map("albers",  lat0 = 45.5, lat1 = 29.5)
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> if (require("maps")) {
+ ggplot(choro, aes(long, lat)) +
+   geom_polygon(aes(group = group, fill = assault / murder)) +
+   coord_map("albers",  lat0 = 45.5, lat1 = 29.5)
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> 
> 
> cleanEx()
> nameEx("mean_se")
> ### * mean_se
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mean_se
> ### Title: Calculate mean and standard error of the mean
> ### Aliases: mean_se
> 
> ### ** Examples
> 
> set.seed(1)
> x <- rnorm(100)
> mean_se(x)
          y       ymin      ymax
1 0.1088874 0.01906743 0.1987073
> 
> 
> 
> cleanEx()
> nameEx("merge_element")
> ### * merge_element
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: merge_element
> ### Title: Merge a parent element into a child element
> ### Aliases: merge_element merge_element.default
> ###   merge_element.element_blank merge_element.element
> ### Keywords: internal
> 
> ### ** Examples
> 
> new <- element_text(colour = "red")
> old <- element_text(colour = "blue", size = 10)
> 
> # Adopt size but ignore colour
> merge_element(new, old)
List of 11
 $ family       : NULL
 $ face         : NULL
 $ colour       : chr "red"
 $ size         : num 10
 $ hjust        : NULL
 $ vjust        : NULL
 $ angle        : NULL
 $ lineheight   : NULL
 $ margin       : NULL
 $ debug        : NULL
 $ inherit.blank: logi FALSE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> 
> 
> 
> cleanEx()
> nameEx("position_dodge")
> ### * position_dodge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: position_dodge
> ### Title: Dodge overlapping objects side-to-side
> ### Aliases: position_dodge position_dodge2
> 
> ### ** Examples
> 
> ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
+   geom_bar(position = "dodge2")
> 
> # By default, dodging with `position_dodge2()` preserves the total width of
> # the elements. You can choose to preserve the width of each element with:
> ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
+   geom_bar(position = position_dodge2(preserve = "single"))
> 
> 
> # Dodging with various widths -------------------------------------
> # To dodge items with different widths, you need to be explicit
> df <- data.frame(
+   x = c("a","a","b","b"),
+   y = 2:5,
+   g = rep(1:2, 2)
+ )
> p <- ggplot(df, aes(x, y, group = g)) +
+   geom_col(position = "dodge", fill = "grey50", colour = "black")
> p
> 
> # A line range has no width:
> p + geom_linerange(aes(ymin = y - 1, ymax = y + 1), position = "dodge")
Warning: Width not defined
ℹ Set with `position_dodge(width = ...)`
> 
> # So you must explicitly specify the width
> p + geom_linerange(
+   aes(ymin = y - 1, ymax = y + 1),
+   position = position_dodge(width = 0.9)
+ )
> 
> # The same principle applies to error bars, which are usually
> # narrower than the bars
> p + geom_errorbar(
+   aes(ymin = y - 1, ymax = y + 1),
+   width = 0.2,
+   position = "dodge"
+ )
> p + geom_errorbar(
+   aes(ymin = y - 1, ymax = y + 1),
+   width = 0.2,
+   position = position_dodge(width = 0.9)
+ )
> 
> # Box plots use position_dodge2 by default, and bars can use it too
> ggplot(mpg, aes(factor(year), displ)) +
+   geom_boxplot(aes(colour = hwy < 30))
> 
> ggplot(mpg, aes(factor(year), displ)) +
+   geom_boxplot(aes(colour = hwy < 30), varwidth = TRUE)
> 
> ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
+   geom_bar(position = position_dodge2(preserve = "single"))
> 
> ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
+   geom_bar(position = position_dodge2(preserve = "total"))
> 
> 
> 
> cleanEx()
> nameEx("position_jitter")
> ### * position_jitter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: position_jitter
> ### Title: Jitter points to avoid overplotting
> ### Aliases: position_jitter
> 
> ### ** Examples
> 
> # Jittering is useful when you have a discrete position, and a relatively
> # small number of points
> # take up as much space as a boxplot or a bar
> ggplot(mpg, aes(class, hwy)) +
+   geom_boxplot(colour = "grey50") +
+   geom_jitter()
> 
> # If the default jittering is too much, as in this plot:
> ggplot(mtcars, aes(am, vs)) +
+   geom_jitter()
> 
> # You can adjust it in two ways
> ggplot(mtcars, aes(am, vs)) +
+   geom_jitter(width = 0.1, height = 0.1)
> ggplot(mtcars, aes(am, vs)) +
+   geom_jitter(position = position_jitter(width = 0.1, height = 0.1))
> 
> # Create a jitter object for reproducible jitter:
> jitter <- position_jitter(width = 0.1, height = 0.1)
> ggplot(mtcars, aes(am, vs)) +
+   geom_point(position = jitter) +
+   geom_point(position = jitter, color = "red", aes(am + 0.2, vs + 0.2))
> 
> 
> 
> cleanEx()
> nameEx("position_jitterdodge")
> ### * position_jitterdodge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: position_jitterdodge
> ### Title: Simultaneously dodge and jitter
> ### Aliases: position_jitterdodge
> 
> ### ** Examples
> 
> set.seed(596)
> dsub <- diamonds[sample(nrow(diamonds), 1000), ]
> ggplot(dsub, aes(x = cut, y = carat, fill = clarity)) +
+   geom_boxplot(outlier.size = 0) +
+   geom_point(pch = 21, position = position_jitterdodge())
> 
> 
> 
> cleanEx()
> nameEx("position_nudge")
> ### * position_nudge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: position_nudge
> ### Title: Nudge points a fixed distance
> ### Aliases: position_nudge
> 
> ### ** Examples
> 
> df <- data.frame(
+   x = c(1,3,2,5),
+   y = c("a","c","d","c")
+ )
> 
> ggplot(df, aes(x, y)) +
+   geom_point() +
+   geom_text(aes(label = y))
> 
> ggplot(df, aes(x, y)) +
+   geom_point() +
+   geom_text(aes(label = y), position = position_nudge(y = -0.1))
> 
> # Or, in brief
> ggplot(df, aes(x, y)) +
+   geom_point() +
+   geom_text(aes(label = y), nudge_y = -0.1)
> 
> 
> 
> cleanEx()
> nameEx("position_stack")
> ### * position_stack
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: position_stack
> ### Title: Stack overlapping objects on top of each another
> ### Aliases: position_stack position_fill
> 
> ### ** Examples
> 
> # Stacking and filling ------------------------------------------------------
> 
> # Stacking is the default behaviour for most area plots.
> # Fill makes it easier to compare proportions
> ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
+   geom_bar()
> ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
+   geom_bar(position = "fill")
> 
> ggplot(diamonds, aes(price, fill = cut)) +
+   geom_histogram(binwidth = 500)
> ggplot(diamonds, aes(price, fill = cut)) +
+   geom_histogram(binwidth = 500, position = "fill")
> 
> # Stacking is also useful for time series
> set.seed(1)
> series <- data.frame(
+   time = c(rep(1, 4),rep(2, 4), rep(3, 4), rep(4, 4)),
+   type = rep(c('a', 'b', 'c', 'd'), 4),
+   value = rpois(16, 10)
+ )
> ggplot(series, aes(time, value)) +
+   geom_area(aes(fill = type))
> 
> # Stacking order ------------------------------------------------------------
> # The stacking order is carefully designed so that the plot matches
> # the legend.
> 
> # You control the stacking order by setting the levels of the underlying
> # factor. See the forcats package for convenient helpers.
> series$type2 <- factor(series$type, levels = c('c', 'b', 'd', 'a'))
> ggplot(series, aes(time, value)) +
+   geom_area(aes(fill = type2))
> 
> # You can change the order of the levels in the legend using the scale
> ggplot(series, aes(time, value)) +
+   geom_area(aes(fill = type)) +
+   scale_fill_discrete(breaks = c('a', 'b', 'c', 'd'))
> 
> # If you've flipped the plot, use reverse = TRUE so the levels
> # continue to match
> ggplot(series, aes(time, value)) +
+   geom_area(aes(fill = type2), position = position_stack(reverse = TRUE)) +
+   coord_flip() +
+   theme(legend.position = "top")
> 
> # Non-area plots ------------------------------------------------------------
> 
> # When stacking across multiple layers it's a good idea to always set
> # the `group` aesthetic in the ggplot() call. This ensures that all layers
> # are stacked in the same way.
> ggplot(series, aes(time, value, group = type)) +
+   geom_line(aes(colour = type), position = "stack") +
+   geom_point(aes(colour = type), position = "stack")
> 
> ggplot(series, aes(time, value, group = type)) +
+   geom_area(aes(fill = type)) +
+   geom_line(aes(group = type), position = "stack")
> 
> # You can also stack labels, but the default position is suboptimal.
> ggplot(series, aes(time, value, group = type)) +
+   geom_area(aes(fill = type)) +
+   geom_text(aes(label = type), position = "stack")
> 
> # You can override this with the vjust parameter. A vjust of 0.5
> # will center the labels inside the corresponding area
> ggplot(series, aes(time, value, group = type)) +
+   geom_area(aes(fill = type)) +
+   geom_text(aes(label = type), position = position_stack(vjust = 0.5))
> 
> # Negative values -----------------------------------------------------------
> 
> df <- tibble::tribble(
+   ~x, ~y, ~grp,
+   "a", 1,  "x",
+   "a", 2,  "y",
+   "b", 1,  "x",
+   "b", 3,  "y",
+   "b", -1, "y"
+ )
> ggplot(data = df, aes(x, y, group = grp)) +
+   geom_col(aes(fill = grp), position = position_stack(reverse = TRUE)) +
+   geom_hline(yintercept = 0)
> 
> ggplot(data = df, aes(x, y, group = grp)) +
+   geom_col(aes(fill = grp)) +
+   geom_hline(yintercept = 0) +
+   geom_text(aes(label = grp), position = position_stack(vjust = 0.5))
> 
> 
> 
> cleanEx()
> nameEx("print.ggplot")
> ### * print.ggplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.ggplot
> ### Title: Explicitly draw plot
> ### Aliases: print.ggplot plot.ggplot
> ### Keywords: hplot
> 
> ### ** Examples
> 
> colours <- list(~class, ~drv, ~fl)
> 
> # Doesn't seem to do anything!
> for (colour in colours) {
+   ggplot(mpg, aes_(~ displ, ~ hwy, colour = colour)) +
+     geom_point()
+ }
Warning: `aes_()` was deprecated in ggplot2 3.0.0.
ℹ Please use tidy evaluation idioms with `aes()`
> 
> # Works when we explicitly print the plots
> for (colour in colours) {
+   print(ggplot(mpg, aes_(~ displ, ~ hwy, colour = colour)) +
+     geom_point())
+ }
> 
> 
> 
> cleanEx()
> nameEx("print.ggproto")
> ### * print.ggproto
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.ggproto
> ### Title: Format or print a ggproto object
> ### Aliases: print.ggproto format.ggproto
> 
> ### ** Examples
> 
> Dog <- ggproto(
+   print = function(self, n) {
+     cat("Woof!\n")
+   }
+  )
> Dog
Woof!
> cat(format(Dog), "\n")
<ggproto object: Class gg>
    print: function 
> 
> 
> 
> cleanEx()
> nameEx("qplot")
> ### * qplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qplot
> ### Title: Quick plot
> ### Aliases: qplot quickplot
> 
> ### ** Examples
> 
> # Use data from data.frame
> qplot(mpg, wt, data = mtcars)
Warning: `qplot()` was deprecated in ggplot2 3.4.0.
> qplot(mpg, wt, data = mtcars, colour = cyl)
> qplot(mpg, wt, data = mtcars, size = cyl)
> qplot(mpg, wt, data = mtcars, facets = vs ~ am)
> 
> 
> 
> 
> cleanEx()
> nameEx("reexports")
> ### * reexports
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reexports
> ### Title: Objects exported from other packages
> ### Aliases: reexports alpha unit arrow
> ### Keywords: internal
> 
> ### ** Examples
> 
> ggplot(mpg, aes(displ, hwy)) +
+   geom_point(alpha = 0.5, colour = "blue")
> 
> ggplot(mpg, aes(displ, hwy)) +
+   geom_point(colour = alpha("blue", 0.5))
> 
> 
> 
> cleanEx()
> nameEx("register_theme_elements")
> ### * register_theme_elements
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: register_theme_elements
> ### Title: Define and register new theme elements
> ### Aliases: register_theme_elements reset_theme_settings get_element_tree
> ###   el_def
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Let's assume a package `ggxyz` wants to provide an easy way to add annotations to
> # plot panels. To do so, it registers a new theme element `ggxyz.panel.annotation`
> register_theme_elements(
+   ggxyz.panel.annotation = element_text(color = "blue", hjust = 0.95, vjust = 0.05),
+   element_tree = list(ggxyz.panel.annotation = el_def("element_text", "text"))
+ )
> 
> # Now the package can define a new coord that includes a panel annotation
> coord_annotate <- function(label = "panel annotation") {
+   ggproto(NULL, CoordCartesian,
+     limits = list(x = NULL, y = NULL),
+     expand = TRUE,
+     default = FALSE,
+     clip = "on",
+     render_fg = function(panel_params, theme) {
+       element_render(theme, "ggxyz.panel.annotation", label = label)
+     }
+   )
+ }
> 
> # Example plot with this new coord
> df <- data.frame(x = 1:3, y = 1:3)
> ggplot(df, aes(x, y)) +
+   geom_point() +
+   coord_annotate("annotation in blue")
> 
> # Revert to the original ggplot2 settings
> reset_theme_settings()
> 
> 
> 
> cleanEx()
> nameEx("resolution")
> ### * resolution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: resolution
> ### Title: Compute the "resolution" of a numeric vector
> ### Aliases: resolution
> 
> ### ** Examples
> 
> resolution(1:10)
[1] 1
> resolution((1:10) - 0.5)
[1] 0.5
> resolution((1:10) - 0.5, FALSE)
[1] 1
> 
> # Note the difference between numeric and integer vectors
> resolution(c(2, 10, 20, 50))
[1] 2
> resolution(c(2L, 10L, 20L, 50L))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("scale_alpha")
> ### * scale_alpha
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_alpha
> ### Title: Alpha transparency scales
> ### Aliases: scale_alpha scale_alpha_continuous scale_alpha_binned
> ###   scale_alpha_discrete scale_alpha_ordinal scale_alpha_datetime
> ###   scale_alpha_date
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(displ, hwy)) +
+   geom_point(aes(alpha = year))
> 
> # The default range of 0.1-1.0 leaves all data visible
> p
> 
> # Include 0 in the range to make data invisible
> p + scale_alpha(range = c(0, 1))
> 
> # Changing the title
> p + scale_alpha("cylinders")
> 
> 
> 
> cleanEx()
> nameEx("scale_binned")
> ### * scale_binned
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_binned
> ### Title: Positional scales for binning continuous data (x & y)
> ### Aliases: scale_x_binned scale_y_binned
> 
> ### ** Examples
> 
> # Create a histogram by binning the x-axis
> ggplot(mtcars) +
+   geom_bar(aes(mpg)) +
+   scale_x_binned()
> 
> 
> 
> cleanEx()
> nameEx("scale_brewer")
> ### * scale_brewer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_colour_brewer
> ### Title: Sequential, diverging and qualitative colour scales from
> ###   ColorBrewer
> ### Aliases: scale_colour_brewer scale_fill_brewer scale_colour_distiller
> ###   scale_fill_distiller scale_colour_fermenter scale_fill_fermenter
> ###   scale_color_brewer scale_color_distiller scale_color_fermenter
> 
> ### ** Examples
> 
> set.seed(596)
> dsamp <- diamonds[sample(nrow(diamonds), 1000), ]
> (d <- ggplot(dsamp, aes(carat, price)) +
+   geom_point(aes(colour = clarity)))
> d + scale_colour_brewer()
> 
> # Change scale label
> d + scale_colour_brewer("Diamond\nclarity")
> 
> # Select brewer palette to use, see ?scales::pal_brewer for more details
> d + scale_colour_brewer(palette = "Greens")
> d + scale_colour_brewer(palette = "Set1")
> 
> 
> # Use distiller variant with continuous data
> v <- ggplot(faithfuld) +
+   geom_tile(aes(waiting, eruptions, fill = density))
> v
> v + scale_fill_distiller()
> v + scale_fill_distiller(palette = "Spectral")
> # the order of colour can be reversed, but with scale_*_distiller(),
> # the default direction = -1, so to reverse, use direction = 1.
> v + scale_fill_distiller(palette = "Spectral", direction = 1)
> 
> # or use blender variants to discretise continuous data
> v + scale_fill_fermenter()
> 
> 
> 
> 
> cleanEx()
> nameEx("scale_colour_continuous")
> ### * scale_colour_continuous
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_colour_continuous
> ### Title: Continuous and binned colour scales
> ### Aliases: scale_colour_continuous scale_fill_continuous
> ###   scale_colour_binned scale_fill_binned scale_color_continuous
> ###   scale_color_binned
> 
> ### ** Examples
> 
> v <- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) +
+ geom_tile()
> v
> 
> v + scale_fill_continuous(type = "gradient")
> v + scale_fill_continuous(type = "viridis")
> 
> # The above are equivalent to
> v + scale_fill_gradient()
> v + scale_fill_viridis_c()
> 
> # To make a binned version of this plot
> v + scale_fill_binned(type = "viridis")
> 
> # Set a different default scale using the options
> # mechanism
> tmp <- getOption("ggplot2.continuous.fill") # store current setting
> options(ggplot2.continuous.fill = scale_fill_distiller)
> v
> options(ggplot2.continuous.fill = tmp) # restore previous setting
> 
> 
> 
> cleanEx()
> nameEx("scale_colour_discrete")
> ### * scale_colour_discrete
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_colour_discrete
> ### Title: Discrete colour scales
> ### Aliases: scale_colour_discrete scale_fill_discrete scale_color_discrete
> 
> ### ** Examples
> 
> # Template function for creating densities grouped by a variable
> cty_by_var <- function(var) {
+   ggplot(mpg, aes(cty, colour = factor({{var}}), fill = factor({{var}}))) +
+     geom_density(alpha = 0.2)
+ }
> 
> # The default, scale_fill_hue(), is not colour-blind safe
> cty_by_var(class)
> 
> # (Temporarily) set the default to Okabe-Ito (which is colour-blind safe)
> okabe <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
> withr::with_options(
+   list(ggplot2.discrete.fill = okabe),
+   print(cty_by_var(class))
+ )
> 
> # Define a collection of palettes to alter the default based on number of levels to encode
> discrete_palettes <- list(
+   c("skyblue", "orange"),
+   RColorBrewer::brewer.pal(3, "Set2"),
+   RColorBrewer::brewer.pal(6, "Accent")
+ )
> withr::with_options(
+   list(ggplot2.discrete.fill = discrete_palettes), {
+   # 1st palette is used when there 1-2 levels (e.g., year)
+   print(cty_by_var(year))
+   # 2nd palette is used when there are 3 levels
+   print(cty_by_var(drv))
+   # 3rd palette is used when there are 4-6 levels
+   print(cty_by_var(fl))
+ })
Warning: Groups with fewer than two data points have been dropped.
Warning in max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf
> 
> 
> 
> 
> cleanEx()
> nameEx("scale_continuous")
> ### * scale_continuous
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_continuous
> ### Title: Position scales for continuous data (x & y)
> ### Aliases: scale_x_continuous scale_y_continuous scale_x_log10
> ###   scale_y_log10 scale_x_reverse scale_y_reverse scale_x_sqrt
> ###   scale_y_sqrt
> 
> ### ** Examples
> 
> p1 <- ggplot(mpg, aes(displ, hwy)) +
+   geom_point()
> p1
> 
> # Manipulating the default position scales lets you:
> #  * change the axis labels
> p1 +
+   scale_x_continuous("Engine displacement (L)") +
+   scale_y_continuous("Highway MPG")
> 
> # You can also use the short-cut labs().
> # Use NULL to suppress axis labels
> p1 + labs(x = NULL, y = NULL)
> 
> #  * modify the axis limits
> p1 + scale_x_continuous(limits = c(2, 6))
Warning: Removed 27 rows containing missing values or values outside the scale range
(`geom_point()`).
> p1 + scale_x_continuous(limits = c(0, 10))
> 
> # you can also use the short hand functions `xlim()` and `ylim()`
> p1 + xlim(2, 6)
Warning: Removed 27 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> #  * choose where the ticks appear
> p1 + scale_x_continuous(breaks = c(2, 4, 6))
> 
> #  * choose your own labels
> p1 + scale_x_continuous(
+   breaks = c(2, 4, 6),
+   label = c("two", "four", "six")
+ )
> 
> # Typically you'll pass a function to the `labels` argument.
> # Some common formats are built into the scales package:
> set.seed(1)
> df <- data.frame(
+   x = rnorm(10) * 100000,
+   y = seq(0, 1, length.out = 10)
+ )
> p2 <- ggplot(df, aes(x, y)) + geom_point()
> p2 + scale_y_continuous(labels = scales::label_percent())
> p2 + scale_y_continuous(labels = scales::label_dollar())
> p2 + scale_x_continuous(labels = scales::label_comma())
> 
> # You can also override the default linear mapping by using a
> # transformation. There are three shortcuts:
> p1 + scale_y_log10()
> p1 + scale_y_sqrt()
> p1 + scale_y_reverse()
> 
> # Or you can supply a transformation in the `trans` argument:
> p1 + scale_y_continuous(transform = scales::transform_reciprocal())
> 
> # You can also create your own. See ?scales::new_transform
> 
> 
> 
> 
> cleanEx()
> nameEx("scale_date")
> ### * scale_date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_date
> ### Title: Position scales for date/time data
> ### Aliases: scale_x_date scale_y_date scale_x_datetime scale_y_datetime
> ###   scale_x_time scale_y_time
> 
> ### ** Examples
> 
> last_month <- Sys.Date() - 0:29
> set.seed(1)
> df <- data.frame(
+   date = last_month,
+   price = runif(30)
+ )
> base <- ggplot(df, aes(date, price)) +
+   geom_line()
> 
> # The date scale will attempt to pick sensible defaults for
> # major and minor tick marks. Override with date_breaks, date_labels
> # date_minor_breaks arguments.
> base + scale_x_date(date_labels = "%b %d")
> base + scale_x_date(date_breaks = "1 week", date_labels = "%W")
> base + scale_x_date(date_minor_breaks = "1 day")
> 
> # Set limits
> base + scale_x_date(limits = c(Sys.Date() - 7, NA))
Warning: Removed 22 rows containing missing values or values outside the scale range
(`geom_line()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("scale_discrete")
> ### * scale_discrete
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_x_discrete
> ### Title: Position scales for discrete data
> ### Aliases: scale_x_discrete scale_y_discrete
> 
> ### ** Examples
> 
> ggplot(diamonds, aes(cut)) + geom_bar()
> 
> 
> 
> 
> cleanEx()
> nameEx("scale_gradient")
> ### * scale_gradient
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_colour_gradient
> ### Title: Gradient colour scales
> ### Aliases: scale_colour_gradient scale_fill_gradient
> ###   scale_colour_gradient2 scale_fill_gradient2 scale_colour_gradientn
> ###   scale_fill_gradientn scale_colour_datetime scale_color_datetime
> ###   scale_colour_date scale_color_date scale_fill_datetime
> ###   scale_fill_date scale_color_gradient scale_color_gradient2
> ###   scale_color_gradientn
> 
> ### ** Examples
> 
> set.seed(1)
> df <- data.frame(
+   x = runif(100),
+   y = runif(100),
+   z1 = rnorm(100),
+   z2 = abs(rnorm(100))
+ )
> 
> df_na <- data.frame(
+   value = seq(1, 20),
+   x = runif(20),
+   y = runif(20),
+   z1 = c(rep(NA, 10), rnorm(10))
+ )
> 
> # Default colour scale colours from light blue to dark blue
> ggplot(df, aes(x, y)) +
+   geom_point(aes(colour = z2))
> 
> # For diverging colour scales use gradient2
> ggplot(df, aes(x, y)) +
+   geom_point(aes(colour = z1)) +
+   scale_colour_gradient2()
> 
> # Use your own colour scale with gradientn
> ggplot(df, aes(x, y)) +
+   geom_point(aes(colour = z1)) +
+   scale_colour_gradientn(colours = terrain.colors(10))
> 
> # Equivalent fill scales do the same job for the fill aesthetic
> ggplot(faithfuld, aes(waiting, eruptions)) +
+   geom_raster(aes(fill = density)) +
+   scale_fill_gradientn(colours = terrain.colors(10))
> 
> # Adjust colour choices with low and high
> ggplot(df, aes(x, y)) +
+   geom_point(aes(colour = z2)) +
+   scale_colour_gradient(low = "white", high = "black")
> # Avoid red-green colour contrasts because ~10% of men have difficulty
> # seeing them
> 
> # Use `na.value = NA` to hide missing values but keep the original axis range
> ggplot(df_na, aes(x = value, y)) +
+   geom_bar(aes(fill = z1), stat = "identity") +
+   scale_fill_gradient(low = "yellow", high = "red", na.value = NA)
> 
>  ggplot(df_na, aes(x, y)) +
+    geom_point(aes(colour = z1)) +
+    scale_colour_gradient(low = "yellow", high = "red", na.value = NA)
Warning: Removed 10 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("scale_grey")
> ### * scale_grey
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_colour_grey
> ### Title: Sequential grey colour scales
> ### Aliases: scale_colour_grey scale_fill_grey scale_color_grey
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(mpg, wt)) + geom_point(aes(colour = factor(cyl)))
> p + scale_colour_grey()
> p + scale_colour_grey(end = 0)
> 
> # You may want to turn off the pale grey background with this scale
> p + scale_colour_grey() + theme_bw()
> 
> # Colour of missing values is controlled with na.value:
> miss <- factor(sample(c(NA, 1:5), nrow(mtcars), replace = TRUE))
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(colour = miss)) +
+   scale_colour_grey()
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(colour = miss)) +
+   scale_colour_grey(na.value = "green")
> 
> 
> 
> cleanEx()
> nameEx("scale_hue")
> ### * scale_hue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_colour_hue
> ### Title: Evenly spaced colours for discrete data
> ### Aliases: scale_colour_hue scale_fill_hue scale_color_hue
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("scale_identity")
> ### * scale_identity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_identity
> ### Title: Use values without scaling
> ### Aliases: scale_colour_identity scale_fill_identity scale_shape_identity
> ###   scale_linetype_identity scale_linewidth_identity scale_alpha_identity
> ###   scale_size_identity scale_discrete_identity scale_continuous_identity
> ###   scale_color_identity
> 
> ### ** Examples
> 
> ggplot(luv_colours, aes(u, v)) +
+   geom_point(aes(colour = col), size = 3) +
+   scale_color_identity() +
+   coord_fixed()
> 
> df <- data.frame(
+   x = 1:4,
+   y = 1:4,
+   colour = c("red", "green", "blue", "yellow")
+ )
> ggplot(df, aes(x, y)) + geom_tile(aes(fill = colour))
> ggplot(df, aes(x, y)) +
+   geom_tile(aes(fill = colour)) +
+   scale_fill_identity()
> 
> # To get a legend guide, specify guide = "legend"
> ggplot(df, aes(x, y)) +
+   geom_tile(aes(fill = colour)) +
+   scale_fill_identity(guide = "legend")
> # But you'll typically also need to supply breaks and labels:
> ggplot(df, aes(x, y)) +
+   geom_tile(aes(fill = colour)) +
+   scale_fill_identity("trt", labels = letters[1:4], breaks = df$colour,
+   guide = "legend")
> 
> # cyl scaled to appropriate size
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(size = cyl))
> 
> # cyl used as point size
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(size = cyl)) +
+   scale_size_identity()
> 
> 
> 
> cleanEx()
> nameEx("scale_linetype")
> ### * scale_linetype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_linetype
> ### Title: Scale for line patterns
> ### Aliases: scale_linetype scale_linetype_binned scale_linetype_continuous
> ###   scale_linetype_discrete
> 
> ### ** Examples
> 
> base <- ggplot(economics_long, aes(date, value01))
> base + geom_line(aes(group = variable))
> base + geom_line(aes(linetype = variable))
> 
> # See scale_manual for more flexibility
> 
> # Common line types ----------------------------
> df_lines <- data.frame(
+   linetype = factor(
+     1:4,
+     labels = c("solid", "longdash", "dashed", "dotted")
+   )
+ )
> ggplot(df_lines) +
+   geom_hline(aes(linetype = linetype, yintercept = 0), linewidth = 2) +
+   scale_linetype_identity() +
+   facet_grid(linetype ~ .) +
+   theme_void(20)
> 
> 
> 
> cleanEx()
> nameEx("scale_linewidth")
> ### * scale_linewidth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_linewidth
> ### Title: Scales for line width
> ### Aliases: scale_linewidth scale_linewidth_continuous
> ###   scale_linewidth_binned scale_linewidth_discrete
> ###   scale_linewidth_ordinal scale_linewidth_datetime scale_linewidth_date
> 
> ### ** Examples
> 
> p <- ggplot(economics, aes(date, unemploy, linewidth = uempmed)) +
+   geom_line(lineend = "round")
> p
> p + scale_linewidth("Duration of\nunemployment")
> p + scale_linewidth(range = c(0, 4))
> 
> # Binning can sometimes make it easier to match the scaled data to the legend
> p + scale_linewidth_binned()
> 
> 
> 
> 
> cleanEx()
> nameEx("scale_manual")
> ### * scale_manual
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_manual
> ### Title: Create your own discrete scale
> ### Aliases: scale_colour_manual scale_fill_manual scale_size_manual
> ###   scale_shape_manual scale_linetype_manual scale_linewidth_manual
> ###   scale_alpha_manual scale_discrete_manual scale_color_manual
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(colour = factor(cyl)))
> p + scale_colour_manual(values = c("red", "blue", "green"))
> 
> # It's recommended to use a named vector
> cols <- c("8" = "red", "4" = "blue", "6" = "darkgreen", "10" = "orange")
> p + scale_colour_manual(values = cols)
> 
> # You can set color and fill aesthetics at the same time
> ggplot(
+   mtcars,
+   aes(mpg, wt, colour = factor(cyl), fill = factor(cyl))
+ ) +
+   geom_point(shape = 21, alpha = 0.5, size = 2) +
+   scale_colour_manual(
+     values = cols,
+     aesthetics = c("colour", "fill")
+   )
> 
> # As with other scales you can use breaks to control the appearance
> # of the legend.
> p + scale_colour_manual(values = cols)
> p + scale_colour_manual(
+   values = cols,
+   breaks = c("4", "6", "8"),
+   labels = c("four", "six", "eight")
+ )
> 
> # And limits to control the possible values of the scale
> p + scale_colour_manual(values = cols, limits = c("4", "8"))
> p + scale_colour_manual(values = cols, limits = c("4", "6", "8", "10"))
> 
> 
> 
> cleanEx()
> nameEx("scale_shape")
> ### * scale_shape
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_shape
> ### Title: Scales for shapes, aka glyphs
> ### Aliases: scale_shape scale_shape_binned scale_shape_discrete
> ###   scale_shape_ordinal scale_shape_continuous
> 
> ### ** Examples
> 
> set.seed(596)
> dsmall <- diamonds[sample(nrow(diamonds), 100), ]
> 
> (d <- ggplot(dsmall, aes(carat, price)) + geom_point(aes(shape = cut)))
Warning: Using shapes for an ordinal variable is not advised
> d + scale_shape(solid = TRUE) # the default
> d + scale_shape(solid = FALSE)
> d + scale_shape(name = "Cut of diamond")
> 
> # To change order of levels, change order of
> # underlying factor
> levels(dsmall$cut) <- c("Fair", "Good", "Very Good", "Premium", "Ideal")
> 
> # Need to recreate plot to pick up new data
> ggplot(dsmall, aes(price, carat)) + geom_point(aes(shape = cut))
Warning: Using shapes for an ordinal variable is not advised
> 
> # Show a list of available shapes
> df_shapes <- data.frame(shape = 0:24)
> ggplot(df_shapes, aes(0, 0, shape = shape)) +
+   geom_point(aes(shape = shape), size = 5, fill = 'red') +
+   scale_shape_identity() +
+   facet_wrap(~shape) +
+   theme_void()
> 
> 
> 
> cleanEx()
> nameEx("scale_size")
> ### * scale_size
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_size
> ### Title: Scales for area or radius
> ### Aliases: scale_size scale_size_continuous scale_radius
> ###   scale_size_binned scale_size_discrete scale_size_ordinal
> ###   scale_size_area scale_size_binned_area scale_size_datetime
> ###   scale_size_date
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(displ, hwy, size = hwy)) +
+    geom_point()
> p
> p + scale_size("Highway mpg")
> p + scale_size(range = c(0, 10))
> 
> # If you want zero value to have zero size, use scale_size_area:
> p + scale_size_area()
> 
> # Binning can sometimes make it easier to match the scaled data to the legend
> p + scale_size_binned()
> 
> # This is most useful when size is a count
> ggplot(mpg, aes(class, cyl)) +
+   geom_count() +
+   scale_size_area()
> 
> # If you want to map size to radius (usually bad idea), use scale_radius
> p + scale_radius()
> 
> 
> 
> cleanEx()
> nameEx("scale_steps")
> ### * scale_steps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_colour_steps
> ### Title: Binned gradient colour scales
> ### Aliases: scale_colour_steps scale_colour_steps2 scale_colour_stepsn
> ###   scale_fill_steps scale_fill_steps2 scale_fill_stepsn
> ###   scale_color_steps scale_color_steps2 scale_color_stepsn
> 
> ### ** Examples
> 
> set.seed(1)
> df <- data.frame(
+   x = runif(100),
+   y = runif(100),
+   z1 = rnorm(100)
+ )
> 
> # Use scale_colour_steps for a standard binned gradient
> ggplot(df, aes(x, y)) +
+   geom_point(aes(colour = z1)) +
+   scale_colour_steps()
> 
> # Get a divergent binned scale with the *2 variant
> ggplot(df, aes(x, y)) +
+   geom_point(aes(colour = z1)) +
+   scale_colour_steps2()
> 
> # Define your own colour ramp to extract binned colours from
> ggplot(df, aes(x, y)) +
+   geom_point(aes(colour = z1)) +
+   scale_colour_stepsn(colours = terrain.colors(10))
> 
> 
> 
> cleanEx()
> nameEx("scale_type")
> ### * scale_type
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_type
> ### Title: Determine default scale type
> ### Aliases: scale_type
> ### Keywords: internal
> 
> ### ** Examples
> 
> scale_type(1:5)
[1] "continuous"
> scale_type("test")
[1] "discrete"
> scale_type(Sys.Date())
[1] "date"       "continuous"
> 
> 
> 
> cleanEx()
> nameEx("scale_viridis")
> ### * scale_viridis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_colour_viridis_d
> ### Title: Viridis colour scales from viridisLite
> ### Aliases: scale_colour_viridis_d scale_fill_viridis_d
> ###   scale_colour_viridis_c scale_fill_viridis_c scale_colour_viridis_b
> ###   scale_fill_viridis_b scale_colour_ordinal scale_color_ordinal
> ###   scale_fill_ordinal scale_color_viridis_d scale_color_viridis_c
> ###   scale_color_viridis_b
> 
> ### ** Examples
> 
> # viridis is the default colour/fill scale for ordered factors
> set.seed(596)
> dsamp <- diamonds[sample(nrow(diamonds), 1000), ]
> ggplot(dsamp, aes(carat, price)) +
+   geom_point(aes(colour = clarity))
> 
> # Use viridis_d with discrete data
> txsamp <- subset(txhousing, city %in%
+   c("Houston", "Fort Worth", "San Antonio", "Dallas", "Austin"))
> (d <- ggplot(data = txsamp, aes(x = sales, y = median)) +
+    geom_point(aes(colour = city)))
> d + scale_colour_viridis_d()
> 
> # Change scale label
> d + scale_colour_viridis_d("City\nCenter")
> 
> # Select palette to use, see ?scales::pal_viridis for more details
> d + scale_colour_viridis_d(option = "plasma")
> d + scale_colour_viridis_d(option = "inferno")
> 
> # scale_fill_viridis_d works just the same as
> # scale_colour_viridis_d but for fill colours
> p <- ggplot(txsamp, aes(x = median, fill = city)) +
+   geom_histogram(position = "dodge", binwidth = 15000)
> p + scale_fill_viridis_d()
> # the order of colour can be reversed
> p + scale_fill_viridis_d(direction = -1)
> 
> # Use viridis_c with continuous data
> (v <- ggplot(faithfuld) +
+   geom_tile(aes(waiting, eruptions, fill = density)))
> v + scale_fill_viridis_c()
> v + scale_fill_viridis_c(option = "plasma")
> 
> # Use viridis_b to bin continuous data before mapping
> v + scale_fill_viridis_b()
> 
> 
> 
> 
> cleanEx()
> nameEx("sec_axis")
> ### * sec_axis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sec_axis
> ### Title: Specify a secondary axis
> ### Aliases: sec_axis dup_axis derive
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(cyl, mpg)) +
+   geom_point()
> 
> # Create a simple secondary axis
> p + scale_y_continuous(sec.axis = sec_axis(~ . + 10))
> 
> # Inherit the name from the primary axis
> p + scale_y_continuous("Miles/gallon", sec.axis = sec_axis(~ . + 10, name = derive()))
> 
> # Duplicate the primary axis
> p + scale_y_continuous(sec.axis = dup_axis())
> 
> # You can pass in a formula as a shorthand
> p + scale_y_continuous(sec.axis = ~ .^2)
> 
> # Secondary axes work for date and datetime scales too:
> df <- data.frame(
+   dx = seq(
+     as.POSIXct("2012-02-29 12:00:00", tz = "UTC"),
+     length.out = 10,
+     by = "4 hour"
+   ),
+   price = seq(20, 200000, length.out = 10)
+  )
> 
> # This may useful for labelling different time scales in the same plot
> ggplot(df, aes(x = dx, y = price)) +
+   geom_line() +
+   scale_x_datetime(
+     "Date",
+     date_labels = "%b %d",
+     date_breaks = "6 hour",
+     sec.axis = dup_axis(
+       name = "Time of Day",
+       labels = scales::label_time("%I %p")
+     )
+   )
> 
> # or to transform axes for different timezones
> ggplot(df, aes(x = dx, y = price)) +
+   geom_line() +
+   scale_x_datetime("
+     GMT",
+     date_labels = "%b %d %I %p",
+     sec.axis = sec_axis(
+       ~ . + 8 * 3600,
+       name = "GMT+8",
+       labels = scales::label_time("%b %d %I %p")
+     )
+   )
> 
> 
> 
> 
> cleanEx()
> nameEx("sf_transform_xy")
> ### * sf_transform_xy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sf_transform_xy
> ### Title: Transform spatial position data
> ### Aliases: sf_transform_xy
> ### Keywords: internal
> 
> ### ** Examples
> 
> if (requireNamespace("sf", quietly = TRUE)) {
+ # location of cities in NC by long (x) and lat (y)
+ data <- data.frame(
+   city = c("Charlotte", "Raleigh", "Greensboro"),
+   x =  c(-80.843, -78.639, -79.792),
+   y = c(35.227, 35.772, 36.073)
+ )
+ 
+ # transform to projected coordinates
+ data_proj <- sf_transform_xy(data, 3347, 4326)
+ data_proj
+ 
+ # transform back
+ sf_transform_xy(data_proj, 4326, 3347)
+ }
> 
> 
> 
> cleanEx()
> nameEx("should_stop")
> ### * should_stop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: should_stop
> ### Title: Used in examples to illustrate when errors should occur.
> ### Aliases: should_stop
> ### Keywords: internal
> 
> ### ** Examples
> 
> should_stop(stop("Hi!"))
> should_stop(should_stop("Hi!"))
[1] "Hi!"
> 
> 
> 
> cleanEx()
> nameEx("stat_ecdf")
> ### * stat_ecdf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat_ecdf
> ### Title: Compute empirical cumulative distribution
> ### Aliases: stat_ecdf
> 
> ### ** Examples
> 
> set.seed(1)
> df <- data.frame(
+   x = c(rnorm(100, 0, 3), rnorm(100, 0, 10)),
+   g = gl(2, 100)
+ )
> ggplot(df, aes(x)) +
+   stat_ecdf(geom = "step")
> 
> # Don't go to positive/negative infinity
> ggplot(df, aes(x)) +
+   stat_ecdf(geom = "step", pad = FALSE)
> 
> # Multiple ECDFs
> ggplot(df, aes(x, colour = g)) +
+   stat_ecdf()
> 
> 
> 
> cleanEx()
> nameEx("stat_ellipse")
> ### * stat_ellipse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat_ellipse
> ### Title: Compute normal data ellipses
> ### Aliases: stat_ellipse
> 
> ### ** Examples
> 
> ggplot(faithful, aes(waiting, eruptions)) +
+   geom_point() +
+   stat_ellipse()
> 
> ggplot(faithful, aes(waiting, eruptions, color = eruptions > 3)) +
+   geom_point() +
+   stat_ellipse()
> 
> ggplot(faithful, aes(waiting, eruptions, color = eruptions > 3)) +
+   geom_point() +
+   stat_ellipse(type = "norm", linetype = 2) +
+   stat_ellipse(type = "t")
> 
> ggplot(faithful, aes(waiting, eruptions, color = eruptions > 3)) +
+   geom_point() +
+   stat_ellipse(type = "norm", linetype = 2) +
+   stat_ellipse(type = "euclid", level = 3) +
+   coord_fixed()
> 
> ggplot(faithful, aes(waiting, eruptions, fill = eruptions > 3)) +
+   stat_ellipse(geom = "polygon")
> 
> 
> 
> cleanEx()
> nameEx("stat_identity")
> ### * stat_identity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat_identity
> ### Title: Leave data as is
> ### Aliases: stat_identity
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(wt, mpg))
> p + stat_identity()
> 
> 
> 
> cleanEx()
> nameEx("stat_sf_coordinates")
> ### * stat_sf_coordinates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat_sf_coordinates
> ### Title: Extract coordinates from 'sf' objects
> ### Aliases: stat_sf_coordinates StatSfCoordinates
> ### Keywords: datasets
> 
> ### ** Examples
> 
> if (requireNamespace("sf", quietly = TRUE)) {
+ nc <- sf::st_read(system.file("shape/nc.shp", package="sf"))
+ 
+ ggplot(nc) +
+   stat_sf_coordinates()
+ 
+ ggplot(nc) +
+   geom_errorbarh(
+     aes(geometry = geometry,
+         xmin = after_stat(x) - 0.1,
+         xmax = after_stat(x) + 0.1,
+         y = after_stat(y),
+         height = 0.04),
+     stat = "sf_coordinates"
+   )
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("stat_summary")
> ### * stat_summary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat_summary_bin
> ### Title: Summarise y values at unique/binned x
> ### Aliases: stat_summary_bin stat_summary
> 
> ### ** Examples
> 
> d <- ggplot(mtcars, aes(cyl, mpg)) + geom_point()
> d + stat_summary(fun.data = "mean_cl_boot", colour = "red", linewidth = 2, size = 3)
> 
> # Orientation follows the discrete axis
> ggplot(mtcars, aes(mpg, factor(cyl))) +
+   geom_point() +
+   stat_summary(fun.data = "mean_cl_boot", colour = "red", linewidth = 2, size = 3)
> 
> # You can supply individual functions to summarise the value at
> # each x:
> d + stat_summary(fun = "median", colour = "red", size = 2, geom = "point")
> d + stat_summary(fun = "mean", colour = "red", size = 2, geom = "point")
> d + aes(colour = factor(vs)) + stat_summary(fun = mean, geom="line")
> 
> d + stat_summary(fun = mean, fun.min = min, fun.max = max, colour = "red")
> 
> d <- ggplot(diamonds, aes(cut))
> d + geom_bar()
> d + stat_summary(aes(y = price), fun = "mean", geom = "bar")
> 
> # Orientation of stat_summary_bin is ambiguous and must be specified directly
> ggplot(diamonds, aes(carat, price)) +
+   stat_summary_bin(fun = "mean", geom = "bar", orientation = 'y')
> 
> 
> 
> 
> cleanEx()
> nameEx("stat_summary_2d")
> ### * stat_summary_2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat_summary_2d
> ### Title: Bin and summarise in 2d (rectangle & hexagons)
> ### Aliases: stat_summary_2d stat_summary2d stat_summary_hex
> 
> ### ** Examples
> 
> d <- ggplot(diamonds, aes(carat, depth, z = price))
> d + stat_summary_2d()
> 
> # Specifying function
> d + stat_summary_2d(fun = function(x) sum(x^2))
> d + stat_summary_2d(fun = ~ sum(.x^2))
> d + stat_summary_2d(fun = var)
> d + stat_summary_2d(fun = "quantile", fun.args = list(probs = 0.1))
> 
> if (requireNamespace("hexbin")) {
+ d + stat_summary_hex()
+ d + stat_summary_hex(fun = ~ sum(.x^2))
+ }
Loading required namespace: hexbin
Failed with error:  ‘there is no package called ‘hexbin’’
> 
> 
> 
> cleanEx()
> nameEx("stat_unique")
> ### * stat_unique
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat_unique
> ### Title: Remove duplicates
> ### Aliases: stat_unique
> 
> ### ** Examples
> 
> ggplot(mtcars, aes(vs, am)) +
+   geom_point(alpha = 0.1)
> ggplot(mtcars, aes(vs, am)) +
+   geom_point(alpha = 0.1, stat = "unique")
> 
> 
> 
> cleanEx()
> nameEx("summarise_plot")
> ### * summarise_plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summarise_plot
> ### Title: Summarise built plot objects
> ### Aliases: summarise_plot summarise_layout summarise_coord
> ###   summarise_layers
> ### Keywords: internal
> 
> ### ** Examples
> 
> p <-
+   ggplot(mpg, aes(displ, hwy)) +
+   geom_point() +
+   facet_wrap(~class)
> b <- ggplot_build(p)
> 
> summarise_layout(b)
# A tibble: 7 × 10
  panel   row   col vars          xmin  xmax  ymin  ymax xscale     yscale    
  <fct> <int> <int> <list>       <dbl> <dbl> <dbl> <dbl> <list>     <list>    
1 1         1     1 <named list>  1.33  7.27  10.4  45.6 <SclCntnP> <SclCntnP>
2 2         1     2 <named list>  1.33  7.27  10.4  45.6 <SclCntnP> <SclCntnP>
3 3         1     3 <named list>  1.33  7.27  10.4  45.6 <SclCntnP> <SclCntnP>
4 4         2     1 <named list>  1.33  7.27  10.4  45.6 <SclCntnP> <SclCntnP>
5 5         2     2 <named list>  1.33  7.27  10.4  45.6 <SclCntnP> <SclCntnP>
6 6         2     3 <named list>  1.33  7.27  10.4  45.6 <SclCntnP> <SclCntnP>
7 7         3     1 <named list>  1.33  7.27  10.4  45.6 <SclCntnP> <SclCntnP>
> summarise_coord(b)
$xlog
[1] NA

$ylog
[1] NA

$flip
[1] FALSE

> summarise_layers(b)
# A tibble: 1 × 1
  mapping         
  <list>          
1 <named list [2]>
> 
> 
> 
> 
> cleanEx()
> nameEx("summary.ggplot")
> ### * summary.ggplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.ggplot
> ### Title: Displays a useful description of a ggplot object
> ### Aliases: summary.ggplot
> ### Keywords: internal
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(mpg, wt)) +
+   geom_point()
> summary(p)
data: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb [32x11]
mapping:  x = ~mpg, y = ~wt
faceting: <ggproto object: Class FacetNull, Facet, gg>
    compute_layout: function
    draw_back: function
    draw_front: function
    draw_labels: function
    draw_panels: function
    finish_data: function
    init_scales: function
    map_data: function
    params: list
    setup_data: function
    setup_params: function
    shrink: TRUE
    train_scales: function
    vars: function
    super:  <ggproto object: Class FacetNull, Facet, gg>
-----------------------------------
geom_point: na.rm = FALSE
stat_identity: na.rm = FALSE
position_identity 

> 
> 
> 
> cleanEx()
> nameEx("theme")
> ### * theme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: theme
> ### Title: Modify components of a theme
> ### Aliases: theme
> 
> ### ** Examples
> 
> p1 <- ggplot(mtcars, aes(wt, mpg)) +
+   geom_point() +
+   labs(title = "Fuel economy declines as weight increases")
> p1
> 
> # Plot ---------------------------------------------------------------------
> p1 + theme(plot.title = element_text(size = rel(2)))
> p1 + theme(plot.background = element_rect(fill = "green"))
> 
> # Panels --------------------------------------------------------------------
> 
> p1 + theme(panel.background = element_rect(fill = "white", colour = "grey50"))
> p1 + theme(panel.border = element_rect(linetype = "dashed", fill = NA))
> p1 + theme(panel.grid.major = element_line(colour = "black"))
> p1 + theme(
+   panel.grid.major.y = element_blank(),
+   panel.grid.minor.y = element_blank()
+ )
> 
> # Put gridlines on top of data
> p1 + theme(
+   panel.background = element_rect(fill = NA),
+   panel.grid.major = element_line(colour = "grey50"),
+   panel.ontop = TRUE
+ )
> 
> # Axes ----------------------------------------------------------------------
> # Change styles of axes texts and lines
> p1 + theme(axis.line = element_line(linewidth = 3, colour = "grey80"))
> p1 + theme(axis.text = element_text(colour = "blue"))
> p1 + theme(axis.ticks = element_line(linewidth = 2))
> 
> # Change the appearance of the y-axis title
> p1 + theme(axis.title.y = element_text(size = rel(1.5), angle = 90))
> 
> # Make ticks point outwards on y-axis and inwards on x-axis
> p1 + theme(
+   axis.ticks.length.y = unit(.25, "cm"),
+   axis.ticks.length.x = unit(-.25, "cm"),
+   axis.text.x = element_text(margin = margin(t = .3, unit = "cm"))
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("theme_get")
> ### * theme_get
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: theme_get
> ### Title: Get, set, and modify the active theme
> ### Aliases: theme_get theme_set theme_update theme_replace %+replace%
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(mpg, wt)) +
+   geom_point()
> p
> 
> # Use theme_set() to completely override the current theme.
> # theme_update() and theme_replace() are similar except they
> # apply directly to the current/active theme.
> # theme_update() modifies a particular element of the current theme.
> # Here we have the old theme so we can later restore it.
> # Note that the theme is applied when the plot is drawn, not
> # when it is created.
> old <- theme_set(theme_bw())
> p
> 
> theme_set(old)
> theme_update(panel.grid.minor = element_line(colour = "red"))
> p
> 
> theme_set(old)
> theme_replace(panel.grid.minor = element_line(colour = "red"))
> p
> 
> theme_set(old)
> p
> 
> 
> # Modifying theme objects -----------------------------------------
> # You can use + and %+replace% to modify a theme object.
> # They differ in how they deal with missing arguments in
> # the theme elements.
> 
> add_el <- theme_grey() +
+   theme(text = element_text(family = "Times"))
> add_el$text
List of 11
 $ family       : chr "Times"
 $ face         : chr "plain"
 $ colour       : chr "black"
 $ size         : num 11
 $ hjust        : num 0.5
 $ vjust        : num 0.5
 $ angle        : num 0
 $ lineheight   : num 0.9
 $ margin       : 'margin' num [1:4] 0points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : logi FALSE
 $ inherit.blank: logi FALSE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> rep_el <- theme_grey() %+replace%
+   theme(text = element_text(family = "Times"))
> rep_el$text
List of 11
 $ family       : chr "Times"
 $ face         : NULL
 $ colour       : NULL
 $ size         : NULL
 $ hjust        : NULL
 $ vjust        : NULL
 $ angle        : NULL
 $ lineheight   : NULL
 $ margin       : NULL
 $ debug        : NULL
 $ inherit.blank: logi FALSE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> 
> 
> 
> cleanEx()
> nameEx("translate_shape_string")
> ### * translate_shape_string
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: translate_shape_string
> ### Title: Translating shape strings
> ### Aliases: translate_shape_string
> ### Keywords: internal
> 
> ### ** Examples
> 
> translate_shape_string(c("circle", "square", "triangle"))
[1] 19 15 17
> 
> # Strings with 1 or less characters are interpreted as symbols
> translate_shape_string(c("a", "b", "?"))
[1] "a" "b" "?"
> 
> 
> 
> cleanEx()
> nameEx("update_defaults")
> ### * update_defaults
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update_geom_defaults
> ### Title: Modify geom/stat aesthetic defaults for future plots
> ### Aliases: update_geom_defaults update_stat_defaults
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> # updating a geom's default aesthetic settings
> # example: change geom_point()'s default color
> GeomPoint$default_aes
Aesthetic mapping: 
* `shape`  -> 19
* `colour` -> "black"
* `size`   -> 1.5
* `fill`   -> NA
* `alpha`  -> NA
* `stroke` -> 0.5
> update_geom_defaults("point", aes(color = "red"))
> GeomPoint$default_aes
Aesthetic mapping: 
* `shape`  -> 19
* `colour` -> "red"
* `size`   -> 1.5
* `fill`   -> NA
* `alpha`  -> NA
* `stroke` -> 0.5
> ggplot(mtcars, aes(mpg, wt)) + geom_point()
> 
> # reset default
> update_geom_defaults("point", aes(color = "black"))
> 
> 
> # updating a stat's default aesthetic settings
> # example: change stat_bin()'s default y-axis to the density scale
> StatBin$default_aes
Aesthetic mapping: 
* `x`      -> `after_stat(count)`
* `y`      -> `after_stat(count)`
* `weight` -> 1
> update_stat_defaults("bin", aes(y = after_stat(density)))
> StatBin$default_aes
Aesthetic mapping: 
* `x`      -> `after_stat(count)`
* `y`      -> `after_stat(density)`
* `weight` -> 1
> ggplot(data.frame(x = rnorm(1e3)), aes(x)) +
+   geom_histogram() +
+   geom_function(fun = dnorm, color = "red")
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # reset default
> update_stat_defaults("bin", aes(y = after_stat(count)))
> 
> 
> 
> 
> cleanEx()
> nameEx("update_labels")
> ### * update_labels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update_labels
> ### Title: Update axis/legend labels
> ### Aliases: update_labels
> ### Keywords: internal
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
> update_labels(p, list(x = "New x"))
> update_labels(p, list(x = expression(x / y ^ 2)))
> update_labels(p, list(x = "New x", y = "New Y"))
> update_labels(p, list(colour = "Fail silently"))
> 
> 
> 
> cleanEx()
> nameEx("vars")
> ### * vars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vars
> ### Title: Quote faceting variables
> ### Aliases: vars
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(wt, disp)) + geom_point()
> p + facet_wrap(vars(vs, am))
> 
> # vars() makes it easy to pass variables from wrapper functions:
> wrap_by <- function(...) {
+   facet_wrap(vars(...), labeller = label_both)
+ }
> p + wrap_by(vs)
> p + wrap_by(vs, am)
> 
> # You can also supply expressions to vars(). In this case it's often a
> # good idea to supply a name as well:
> p + wrap_by(drat = cut_number(drat, 3))
> 
> # Let's create another function for cutting and wrapping a
> # variable. This time it will take a named argument instead of dots,
> # so we'll have to use the "enquote and unquote" pattern:
> wrap_cut <- function(var, n = 3) {
+   # Let's enquote the named argument `var` to make it auto-quoting:
+   var <- enquo(var)
+ 
+   # `as_label()` will create a nice default name:
+   nm <- as_label(var)
+ 
+   # Now let's unquote everything at the right place. Note that we also
+   # unquote `n` just in case the data frame has a column named
+   # `n`. The latter would have precedence over our local variable
+   # because the data is always masking the environment.
+   wrap_by(!!nm := cut_number(!!var, !!n))
+ }
> 
> # Thanks to tidy eval idioms we now have another useful wrapper:
> p + wrap_cut(drat)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  58.782 3.325 58.698 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
