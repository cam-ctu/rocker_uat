
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ggplot2"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ggplot2')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aes")
> ### * aes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes
> ### Title: Construct aesthetic mappings
> ### Aliases: aes
> 
> ### ** Examples
> 
> aes(x = mpg, y = wt)
Aesthetic mapping: 
* `x` -> `mpg`
* `y` -> `wt`
> aes(mpg, wt)
Aesthetic mapping: 
* `x` -> `mpg`
* `y` -> `wt`
> 
> # You can also map aesthetics to functions of variables
> aes(x = mpg ^ 2, y = wt / cyl)
Aesthetic mapping: 
* `x` -> `mpg^2`
* `y` -> `wt/cyl`
> 
> # Or to constants
> aes(x = 1, colour = "smooth")
Aesthetic mapping: 
* `x`      -> 1
* `colour` -> "smooth"
> 
> # Aesthetic names are automatically standardised
> aes(col = x)
Aesthetic mapping: 
* `colour` -> `x`
> aes(fg = x)
Aesthetic mapping: 
* `colour` -> `x`
> aes(color = x)
Aesthetic mapping: 
* `colour` -> `x`
> aes(colour = x)
Aesthetic mapping: 
* `colour` -> `x`
> 
> # aes() is passed to either ggplot() or specific layer. Aesthetics supplied
> # to ggplot() are used as defaults for every layer.
> ggplot(mpg, aes(displ, hwy)) + geom_point()
> ggplot(mpg) + geom_point(aes(displ, hwy))
> 
> # Tidy evaluation ----------------------------------------------------
> # aes() automatically quotes all its arguments, so you need to use tidy
> # evaluation to create wrappers around ggplot2 pipelines. The
> # simplest case occurs when your wrapper takes dots:
> scatter_by <- function(data, ...) {
+   ggplot(data) + geom_point(aes(...))
+ }
> scatter_by(mtcars, disp, drat)
> 
> # If your wrapper has a more specific interface with named arguments,
> # you need the "embrace operator":
> scatter_by <- function(data, x, y) {
+   ggplot(data) + geom_point(aes({{ x }}, {{ y }}))
+ }
> scatter_by(mtcars, disp, drat)
> 
> # Note that users of your wrapper can use their own functions in the
> # quoted expressions and all will resolve as it should!
> cut3 <- function(x) cut_number(x, 3)
> scatter_by(mtcars, cut3(disp), drat)
> 
> 
> 
> cleanEx()
> nameEx("aes_all")
> ### * aes_all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_all
> ### Title: Given a character vector, create a set of identity mappings
> ### Aliases: aes_all
> ### Keywords: internal
> 
> ### ** Examples
> 
> aes_all(names(mtcars))
Aesthetic mapping: 
* `mpg`  -> `mpg`
* `cyl`  -> `cyl`
* `disp` -> `disp`
* `hp`   -> `hp`
* `drat` -> `drat`
* `wt`   -> `wt`
* `qsec` -> `qsec`
* `vs`   -> `vs`
* `am`   -> `am`
* `gear` -> `gear`
* `carb` -> `carb`
> aes_all(c("x", "y", "col", "pch"))
Aesthetic mapping: 
* `x`      -> `x`
* `y`      -> `y`
* `colour` -> `col`
* `shape`  -> `pch`
> 
> 
> 
> cleanEx()
> nameEx("aes_colour_fill_alpha")
> ### * aes_colour_fill_alpha
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_colour_fill_alpha
> ### Title: Colour related aesthetics: colour, fill, and alpha
> ### Aliases: aes_colour_fill_alpha colour color fill
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("aes_eval")
> ### * aes_eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_eval
> ### Title: Control aesthetic evaluation
> ### Aliases: aes_eval after_stat stat after_scale stage
> 
> ### ** Examples
> 
> # Default histogram display
> ggplot(mpg, aes(displ)) +
+   geom_histogram(aes(y = after_stat(count)))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # Scale tallest bin to 1
> ggplot(mpg, aes(displ)) +
+   geom_histogram(aes(y = after_stat(count / max(count))))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # Use a transparent version of colour for fill
> ggplot(mpg, aes(class, hwy)) +
+   geom_boxplot(aes(colour = class, fill = after_scale(alpha(colour, 0.4))))
> 
> # Use stage to modify the scaled fill
> ggplot(mpg, aes(class, hwy)) +
+   geom_boxplot(aes(fill = stage(class, after_scale = alpha(fill, 0.4))))
> 
> # Making a proportional stacked density plot
> ggplot(mpg, aes(cty)) +
+   geom_density(
+     aes(
+       colour = factor(cyl),
+       fill = after_scale(alpha(colour, 0.3)),
+       y = after_stat(count / sum(n[!duplicated(group)]))
+     ),
+     position = "stack", bw = 1
+   ) +
+   geom_density(bw = 1)
> 
> # Imitating a ridgeline plot
> ggplot(mpg, aes(cty, colour = factor(cyl))) +
+   geom_ribbon(
+     stat = "density", outline.type = "upper",
+     aes(
+       fill = after_scale(alpha(colour, 0.3)),
+       ymin = after_stat(group),
+       ymax = after_stat(group + ndensity)
+     )
+   )
> 
> # Labelling a bar plot
> ggplot(mpg, aes(class)) +
+   geom_bar() +
+   geom_text(
+     aes(
+       y = after_stat(count + 2),
+       label = after_stat(count)
+     ),
+     stat = "count"
+   )
> 
> # Labelling the upper hinge of a boxplot,
> # inspired by June Choe
> ggplot(mpg, aes(displ, class)) +
+   geom_boxplot(outlier.shape = NA) +
+   geom_text(
+     aes(
+       label = after_stat(xmax),
+       x = stage(displ, after_stat = xmax)
+     ),
+     stat = "boxplot", hjust = -0.5
+   )
> 
> 
> 
> cleanEx()
> nameEx("aes_group_order")
> ### * aes_group_order
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_group_order
> ### Title: Aesthetics: grouping
> ### Aliases: aes_group_order group
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("aes_linetype_size_shape")
> ### * aes_linetype_size_shape
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_linetype_size_shape
> ### Title: Differentiation related aesthetics: linetype, size, shape
> ### Aliases: aes_linetype_size_shape linetype size shape
> 
> ### ** Examples
> 
> 
> df <- data.frame(x = 1:10 , y = 1:10)
> p <- ggplot(df, aes(x, y))
> p + geom_line(linetype = 2)
> p + geom_line(linetype = "dotdash")
> 
> # An example with hex strings; the string "33" specifies three units on followed
> # by three off and "3313" specifies three units on followed by three off followed
> # by one on and finally three off.
> p + geom_line(linetype = "3313")
> 
> # Mapping line type from a grouping variable
> ggplot(economics_long, aes(date, value01)) +
+   geom_line(aes(linetype = variable))
> 
> # Linewidth examples
> ggplot(economics, aes(date, unemploy)) +
+   geom_line(linewidth = 2, lineend = "round")
> ggplot(economics, aes(date, unemploy)) +
+   geom_line(aes(linewidth = uempmed), lineend = "round")
> 
> # Size examples
> p <- ggplot(mtcars, aes(wt, mpg))
> p + geom_point(size = 4)
> p + geom_point(aes(size = qsec))
> p + geom_point(size = 2.5) +
+   geom_hline(yintercept = 25, size = 3.5)
Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
ℹ Please use `linewidth` instead.
> 
> # Shape examples
> p + geom_point()
> p + geom_point(shape = 5)
> p + geom_point(shape = "k", size = 3)
> p + geom_point(shape = ".")
> p + geom_point(shape = NA)
Warning: Removed 32 rows containing missing values or values outside the scale range
(`geom_point()`).
> p + geom_point(aes(shape = factor(cyl)))
> 
> # A look at all 25 symbols
> df2 <- data.frame(x = 1:5 , y = 1:25, z = 1:25)
> p <- ggplot(df2, aes(x, y))
> p + geom_point(aes(shape = z), size = 4) +
+   scale_shape_identity()
> # While all symbols have a foreground colour, symbols 19-25 also take a
> # background colour (fill)
> p + geom_point(aes(shape = z), size = 4, colour = "Red") +
+   scale_shape_identity()
> p + geom_point(aes(shape = z), size = 4, colour = "Red", fill = "Black") +
+   scale_shape_identity()
> 
> 
> 
> cleanEx()
> nameEx("aes_position")
> ### * aes_position
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_position
> ### Title: Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend,
> ###   yend
> ### Aliases: aes_position x y xmin xmax ymin ymax xend yend
> 
> ### ** Examples
> 
> 
> # Generate data: means and standard errors of means for prices
> # for each type of cut
> dmod <- lm(price ~ cut, data = diamonds)
> cut <- unique(diamonds$cut)
> cuts_df <- data.frame(
+   cut,
+   predict(dmod, data.frame(cut), se = TRUE)[c("fit", "se.fit")]
+ )
> ggplot(cuts_df) +
+   aes(
+    x = cut,
+    y = fit,
+    ymin = fit - se.fit,
+    ymax = fit + se.fit,
+    colour = cut
+   ) +
+   geom_pointrange()
> 
> # Using annotate
> p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
> p
> p + annotate(
+   "rect", xmin = 2, xmax = 3.5, ymin = 2, ymax = 25,
+   fill = "dark grey", alpha = .5
+ )
> 
> # Geom_segment examples
> p + geom_segment(
+   aes(x = 2, y = 15, xend = 2, yend = 25),
+   arrow = arrow(length = unit(0.5, "cm"))
+ )
Warning in geom_segment(aes(x = 2, y = 15, xend = 2, yend = 25), arrow = arrow(length = unit(0.5,  :
  All aesthetics have length 1, but the data has 32 rows.
ℹ Please consider using `annotate()` or provide this layer with data containing
  a single row.
> p + geom_segment(
+   aes(x = 2, y = 15, xend = 3, yend = 15),
+   arrow = arrow(length = unit(0.5, "cm"))
+ )
Warning in geom_segment(aes(x = 2, y = 15, xend = 3, yend = 15), arrow = arrow(length = unit(0.5,  :
  All aesthetics have length 1, but the data has 32 rows.
ℹ Please consider using `annotate()` or provide this layer with data containing
  a single row.
> p + geom_segment(
+   aes(x = 5, y = 30, xend = 3.5, yend = 25),
+   arrow = arrow(length = unit(0.5, "cm"))
+ )
Warning in geom_segment(aes(x = 5, y = 30, xend = 3.5, yend = 25), arrow = arrow(length = unit(0.5,  :
  All aesthetics have length 1, but the data has 32 rows.
ℹ Please consider using `annotate()` or provide this layer with data containing
  a single row.
> 
> # You can also use geom_segment() to recreate plot(type = "h")
> # from base R:
> set.seed(1)
> counts <- as.data.frame(table(x = rpois(100, 5)))
> counts$x <- as.numeric(as.character(counts$x))
> with(counts, plot(x, Freq, type = "h", lwd = 10))
> 
> ggplot(counts, aes(x = x, y = Freq)) +
+   geom_segment(aes(yend = 0, xend = x), size = 10)
> 
> 
> 
> cleanEx()
> nameEx("annotate")
> ### * annotate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotate
> ### Title: Create an annotation layer
> ### Aliases: annotate
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
> p + annotate("text", x = 4, y = 25, label = "Some text")
> p + annotate("text", x = 2:5, y = 25, label = "Some text")
> p + annotate("rect", xmin = 3, xmax = 4.2, ymin = 12, ymax = 21,
+   alpha = .2)
> p + annotate("segment", x = 2.5, xend = 4, y = 15, yend = 25,
+   colour = "blue")
> p + annotate("pointrange", x = 3.5, y = 20, ymin = 12, ymax = 28,
+   colour = "red", size = 2.5, linewidth = 1.5)
> 
> p + annotate("text", x = 2:3, y = 20:21, label = c("my label", "label 2"))
> 
> p + annotate("text", x = 4, y = 25, label = "italic(R) ^ 2 == 0.75",
+   parse = TRUE)
> p + annotate("text", x = 4, y = 25,
+   label = "paste(italic(R) ^ 2, \" = .75\")", parse = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("annotation_custom")
> ### * annotation_custom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotation_custom
> ### Title: Annotation: Custom grob
> ### Aliases: annotation_custom
> 
> ### ** Examples
> 
> # Dummy plot
> df <- data.frame(x = 1:10, y = 1:10)
> base <- ggplot(df, aes(x, y)) +
+   geom_blank() +
+   theme_bw()
> 
> # Full panel annotation
> base + annotation_custom(
+   grob = grid::roundrectGrob(),
+   xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
+ )
> 
> # Inset plot
> df2 <- data.frame(x = 1 , y = 1)
> g <- ggplotGrob(ggplot(df2, aes(x, y)) +
+   geom_point() +
+   theme(plot.background = element_rect(colour = "black")))
> base +
+   annotation_custom(grob = g, xmin = 1, xmax = 10, ymin = 8, ymax = 10)
> 
> 
> 
> cleanEx()
> nameEx("annotation_logticks")
> ### * annotation_logticks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotation_logticks
> ### Title: Annotation: log tick marks
> ### Aliases: annotation_logticks
> 
> ### ** Examples
> 
> # Make a log-log plot (without log ticks)
> a <- ggplot(msleep, aes(bodywt, brainwt)) +
+  geom_point(na.rm = TRUE) +
+  scale_x_log10(
+    breaks = scales::trans_breaks("log10", function(x) 10^x),
+    labels = scales::trans_format("log10", scales::math_format(10^.x))
+  ) +
+  scale_y_log10(
+    breaks = scales::trans_breaks("log10", function(x) 10^x),
+    labels = scales::trans_format("log10", scales::math_format(10^.x))
+  ) +
+  theme_bw()
> 
> a + annotation_logticks()                # Default: log ticks on bottom and left
> a + annotation_logticks(sides = "lr")    # Log ticks for y, on left and right
> a + annotation_logticks(sides = "trbl")  # All four sides
> 
> a + annotation_logticks(sides = "lr", outside = TRUE) +
+  coord_cartesian(clip = "off")  # Ticks outside plot
> 
> # Hide the minor grid lines because they don't align with the ticks
> a + annotation_logticks(sides = "trbl") + theme(panel.grid.minor = element_blank())
> 
> # Another way to get the same results as 'a' above: log-transform the data before
> # plotting it. Also hide the minor grid lines.
> b <- ggplot(msleep, aes(log10(bodywt), log10(brainwt))) +
+  geom_point(na.rm = TRUE) +
+  scale_x_continuous(name = "body", labels = scales::label_math(10^.x)) +
+  scale_y_continuous(name = "brain", labels = scales::label_math(10^.x)) +
+  theme_bw() + theme(panel.grid.minor = element_blank())
> 
> b + annotation_logticks()
> 
> # Using a coordinate transform requires scaled = FALSE
> t <- ggplot(msleep, aes(bodywt, brainwt)) +
+   geom_point() +
+   coord_trans(x = "log10", y = "log10") +
+   theme_bw()
> t + annotation_logticks(scaled = FALSE)
Warning: Removed 27 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> # Change the length of the ticks
> a + annotation_logticks(
+   short = unit(.5,"mm"),
+   mid = unit(3,"mm"),
+   long = unit(4,"mm")
+ )
> 
> 
> 
> cleanEx()
> nameEx("annotation_map")
> ### * annotation_map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotation_map
> ### Title: Annotation: a map
> ### Aliases: annotation_map
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (requireNamespace("maps", quietly = TRUE)) {
> ##D # location of cities in North Carolina
> ##D df <- data.frame(
> ##D   name = c("Charlotte", "Raleigh", "Greensboro"),
> ##D   lat = c(35.227, 35.772, 36.073),
> ##D   long = c(-80.843, -78.639, -79.792)
> ##D )
> ##D 
> ##D p <- ggplot(df, aes(x = long, y = lat)) +
> ##D   annotation_map(
> ##D     map_data("state"),
> ##D     fill = "antiquewhite", colour = "darkgrey"
> ##D   ) +
> ##D   geom_point(color = "blue") +
> ##D   geom_text(
> ##D     aes(label = name),
> ##D     hjust = 1.105, vjust = 1.05, color = "blue"
> ##D   )
> ##D 
> ##D # use without coord_sf() is possible but not recommended
> ##D p + xlim(-84, -76) + ylim(34, 37.2)
> ##D 
> ##D if (requireNamespace("sf", quietly = TRUE)) {
> ##D # use with coord_sf() for appropriate projection
> ##D p +
> ##D   coord_sf(
> ##D     crs = sf::st_crs(3347),
> ##D     default_crs = sf::st_crs(4326),  # data is provided as long-lat
> ##D     xlim = c(-84, -76),
> ##D     ylim = c(34, 37.2)
> ##D   )
> ##D 
> ##D # you can mix annotation_map() and geom_sf()
> ##D nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
> ##D p +
> ##D   geom_sf(
> ##D     data = nc, inherit.aes = FALSE,
> ##D     fill = NA, color = "black", linewidth = 0.1
> ##D   ) +
> ##D   coord_sf(crs = sf::st_crs(3347), default_crs = sf::st_crs(4326))
> ##D }}
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("annotation_raster")
> ### * annotation_raster
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: annotation_raster
> ### Title: Annotation: high-performance rectangular tiling
> ### Aliases: annotation_raster
> 
> ### ** Examples
> 
> # Generate data
> rainbow <- matrix(hcl(seq(0, 360, length.out = 50 * 50), 80, 70), nrow = 50)
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point() +
+   annotation_raster(rainbow, 15, 20, 3, 4)
> # To fill up whole plot
> ggplot(mtcars, aes(mpg, wt)) +
+   annotation_raster(rainbow, -Inf, Inf, -Inf, Inf) +
+   geom_point()
> 
> rainbow2 <- matrix(hcl(seq(0, 360, length.out = 10), 80, 70), nrow = 1)
> ggplot(mtcars, aes(mpg, wt)) +
+   annotation_raster(rainbow2, -Inf, Inf, -Inf, Inf) +
+   geom_point()
> rainbow2 <- matrix(hcl(seq(0, 360, length.out = 10), 80, 70), nrow = 1)
> ggplot(mtcars, aes(mpg, wt)) +
+   annotation_raster(rainbow2, -Inf, Inf, -Inf, Inf, interpolate = TRUE) +
+   geom_point()
> 
> 
> 
> cleanEx()
> nameEx("as_labeller")
> ### * as_labeller
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_labeller
> ### Title: Coerce to labeller function
> ### Aliases: as_labeller
> ### Keywords: internal
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(disp, drat)) + geom_point()
> p + facet_wrap(~am)
> 
> # Rename labels on the fly with a lookup character vector
> to_string <- as_labeller(c(`0` = "Zero", `1` = "One"))
> p + facet_wrap(~am, labeller = to_string)
> 
> # Quickly transform a function operating on character vectors to a
> # labeller function:
> appender <- function(string, suffix = "-foo") paste0(string, suffix)
> p + facet_wrap(~am, labeller = as_labeller(appender))
> 
> # If you have more than one faceting variable, be sure to dispatch
> # your labeller to the right variable with labeller()
> p + facet_grid(cyl ~ am, labeller = labeller(am = to_string))
> 
> 
> 
> cleanEx()
> nameEx("benchplot")
> ### * benchplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: benchplot
> ### Title: Benchmark plot creation time. Broken down into construct, build,
> ###   render and draw times.
> ### Aliases: benchplot
> ### Keywords: internal
> 
> ### ** Examples
> 
> benchplot(ggplot(mtcars, aes(mpg, wt)) + geom_point())
       step user.self sys.self elapsed
1 construct     0.002        0   0.002
2     build     0.016        0   0.017
3    render     0.016        0   0.016
4      draw     0.018        0   0.018
5     TOTAL     0.052        0   0.053
> benchplot(ggplot(mtcars, aes(mpg, wt)) + geom_point() + facet_grid(. ~ cyl))
       step user.self sys.self elapsed
1 construct     0.002        0   0.002
2     build     0.034        0   0.035
3    render     0.039        0   0.038
4      draw     0.032        0   0.032
5     TOTAL     0.107        0   0.107
> 
> # With tidy eval:
> p <- expr(ggplot(mtcars, aes(mpg, wt)) + geom_point())
> benchplot(!!p)
       step user.self sys.self elapsed
1 construct     0.001        0   0.002
2     build     0.017        0   0.017
3    render     0.017        0   0.017
4      draw     0.018        0   0.019
5     TOTAL     0.053        0   0.055
> 
> 
> 
> cleanEx()
> nameEx("borders")
> ### * borders
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: borders
> ### Title: Create a layer of map borders
> ### Aliases: borders
> 
> ### ** Examples
> 
> if (require("maps")) {
+ 
+ ia <- map_data("county", "iowa")
+ mid_range <- function(x) mean(range(x))
+ seats <- do.call(rbind, lapply(split(ia, ia$subregion), function(d) {
+   data.frame(lat = mid_range(d$lat), long = mid_range(d$long), subregion = unique(d$subregion))
+ }))
+ 
+ ggplot(ia, aes(long, lat)) +
+   geom_polygon(aes(group = group), fill = NA, colour = "grey60") +
+   geom_text(aes(label = subregion), data = seats, size = 2, angle = 45)
+ }
Loading required package: maps
> 
> if (require("maps")) {
+ data(us.cities)
+ capitals <- subset(us.cities, capital == 2)
+ ggplot(capitals, aes(long, lat)) +
+   borders("state") +
+   geom_point(aes(size = pop)) +
+   scale_size_area() +
+   coord_quickmap()
+ }
> 
> if (require("maps")) {
+ # Same map, with some world context
+ ggplot(capitals, aes(long, lat)) +
+   borders("world", xlim = c(-130, -60), ylim = c(20, 50)) +
+   geom_point(aes(size = pop)) +
+   scale_size_area() +
+   coord_quickmap()
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:maps’

> nameEx("calc_element")
> ### * calc_element
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calc_element
> ### Title: Calculate the element properties, by inheriting properties from
> ###   its parents
> ### Aliases: calc_element
> ### Keywords: internal
> 
> ### ** Examples
> 
> t <- theme_grey()
> calc_element('text', t)
List of 11
 $ family       : chr ""
 $ face         : chr "plain"
 $ colour       : chr "black"
 $ size         : num 11
 $ hjust        : num 0.5
 $ vjust        : num 0.5
 $ angle        : num 0
 $ lineheight   : num 0.9
 $ margin       : 'margin' num [1:4] 0points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : logi FALSE
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> # Compare the "raw" element definition to the element with calculated inheritance
> t$axis.text.x
List of 11
 $ family       : NULL
 $ face         : NULL
 $ colour       : NULL
 $ size         : NULL
 $ hjust        : NULL
 $ vjust        : num 1
 $ angle        : NULL
 $ lineheight   : NULL
 $ margin       : 'margin' num [1:4] 2.2points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : NULL
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> calc_element('axis.text.x', t, verbose = TRUE)
axis.text.x -->
axis.text
axis.text -->
text
text -->
nothing (top level)
List of 11
 $ family       : chr ""
 $ face         : chr "plain"
 $ colour       : chr "grey30"
 $ size         : num 8.8
 $ hjust        : num 0.5
 $ vjust        : num 1
 $ angle        : num 0
 $ lineheight   : num 0.9
 $ margin       : 'margin' num [1:4] 2.2points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : logi FALSE
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> # This reports that axis.text.x inherits from axis.text,
> # which inherits from text. You can view each of them with:
> t$axis.text.x
List of 11
 $ family       : NULL
 $ face         : NULL
 $ colour       : NULL
 $ size         : NULL
 $ hjust        : NULL
 $ vjust        : num 1
 $ angle        : NULL
 $ lineheight   : NULL
 $ margin       : 'margin' num [1:4] 2.2points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : NULL
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> t$axis.text
List of 11
 $ family       : NULL
 $ face         : NULL
 $ colour       : chr "grey30"
 $ size         : 'rel' num 0.8
 $ hjust        : NULL
 $ vjust        : NULL
 $ angle        : NULL
 $ lineheight   : NULL
 $ margin       : NULL
 $ debug        : NULL
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> t$text
List of 11
 $ family       : chr ""
 $ face         : chr "plain"
 $ colour       : chr "black"
 $ size         : num 11
 $ hjust        : num 0.5
 $ vjust        : num 0.5
 $ angle        : num 0
 $ lineheight   : num 0.9
 $ margin       : 'margin' num [1:4] 0points 0points 0points 0points
  ..- attr(*, "unit")= int 8
 $ debug        : logi FALSE
 $ inherit.blank: logi TRUE
 - attr(*, "class")= chr [1:2] "element_text" "element"
> 
> 
> 
> cleanEx()
> nameEx("check_device")
> ### * check_device
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: check_device
> ### Title: Check graphics device capabilities
> ### Aliases: check_device
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Typically you'd run `check_device()` inside a function that might produce
> # advanced graphics.
> # The check is designed for use in control flow statements in the test mode
> if (check_device("patterns", action = "test")) {
+   print("Yay")
+ } else {
+   print("Nay")
+ }
[1] "Yay"
> 
> # Automatically throw a warning when unavailable
> if (check_device("compositing", action = "warn")) {
+   print("Yay")
+ } else {
+   print("Nay")
+ }
Warning: The pdf device does not support compositing.
[1] "Nay"
> 
> # Possibly throw an error
> try(check_device("glyphs", action = "abort"))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("coord_cartesian")
> ### * coord_cartesian
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_cartesian
> ### Title: Cartesian coordinates
> ### Aliases: coord_cartesian
> 
> ### ** Examples
> 
> # There are two ways of zooming the plot display: with scales or
> # with coordinate systems.  They work in two rather different ways.
> 
> p <- ggplot(mtcars, aes(disp, wt)) +
+   geom_point() +
+   geom_smooth()
> p
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # Setting the limits on a scale converts all values outside the range to NA.
> p + scale_x_continuous(limits = c(325, 500))
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
Warning: Removed 24 rows containing non-finite outside the scale range
(`stat_smooth()`).
Warning: Removed 24 rows containing missing values or values outside the scale range
(`geom_point()`).
> 
> # Setting the limits on the coordinate system performs a visual zoom.
> # The data is unchanged, and we just view a small portion of the original
> # plot. Note how smooth continues past the points visible on this plot.
> p + coord_cartesian(xlim = c(325, 500))
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # By default, the same expansion factor is applied as when setting scale
> # limits. You can set the limits precisely by setting expand = FALSE
> p + coord_cartesian(xlim = c(325, 500), expand = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # Similarly, we can use expand = FALSE to turn off expansion with the
> # default limits
> p + coord_cartesian(expand = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> # You can see the same thing with this 2d histogram
> d <- ggplot(diamonds, aes(carat, price)) +
+   stat_bin_2d(bins = 25, colour = "white")
> d
> 
> # When zooming the scale, the we get 25 new bins that are the same
> # size on the plot, but represent smaller regions of the data space
> d + scale_x_continuous(limits = c(0, 1))
Warning: Removed 17502 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 17 rows containing missing values or values outside the scale range
(`geom_tile()`).
> 
> # When zooming the coordinate system, we see a subset of original 50 bins,
> # displayed bigger
> d + coord_cartesian(xlim = c(0, 1))
> 
> 
> 
> cleanEx()
> nameEx("coord_fixed")
> ### * coord_fixed
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_fixed
> ### Title: Cartesian coordinates with fixed "aspect ratio"
> ### Aliases: coord_fixed coord_equal
> 
> ### ** Examples
> 
> # ensures that the ranges of axes are equal to the specified ratio by
> # adjusting the plot aspect ratio
> 
> p <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
> p + coord_fixed(ratio = 1)
> p + coord_fixed(ratio = 5)
> p + coord_fixed(ratio = 1/5)
> p + coord_fixed(xlim = c(15, 30))
> 
> # Resize the plot to see that the specified aspect ratio is maintained
> 
> 
> 
> cleanEx()
> nameEx("coord_flip")
> ### * coord_flip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_flip
> ### Title: Cartesian coordinates with x and y flipped
> ### Aliases: coord_flip
> 
> ### ** Examples
> 
> # The preferred method of creating horizontal instead of vertical boxplots
> ggplot(diamonds, aes(price, cut)) +
+   geom_boxplot()
> 
> # Using `coord_flip()` to make the same plot
> ggplot(diamonds, aes(cut, price)) +
+   geom_boxplot() +
+   coord_flip()
> 
> # With swapped aesthetics, the y-scale controls the left axis
> ggplot(diamonds, aes(y = carat)) +
+   geom_histogram() +
+   scale_y_reverse()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # In `coord_flip()`, the x-scale controls the left axis
> ggplot(diamonds, aes(carat)) +
+   geom_histogram() +
+   coord_flip() +
+   scale_x_reverse()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # In line and area plots, swapped aesthetics require an explicit orientation
> df <- data.frame(a = 1:5, b = (1:5) ^ 2)
> ggplot(df, aes(b, a)) +
+   geom_area(orientation = "y")
> 
> # The same plot with `coord_flip()`
> ggplot(df, aes(a, b)) +
+   geom_area() +
+   coord_flip()
> 
> 
> 
> cleanEx()
> nameEx("coord_map")
> ### * coord_map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_map
> ### Title: Map projections
> ### Aliases: coord_map coord_quickmap
> 
> ### ** Examples
> 
> if (require("maps")) {
+ nz <- map_data("nz")
+ # Prepare a map of NZ
+ nzmap <- ggplot(nz, aes(x = long, y = lat, group = group)) +
+   geom_polygon(fill = "white", colour = "black")
+ 
+ # Plot it in cartesian coordinates
+ nzmap
+ }
Loading required package: maps
> 
> if (require("maps")) {
+ # With correct mercator projection
+ nzmap + coord_map()
+ }
> 
> if (require("maps")) {
+ # With the aspect ratio approximation
+ nzmap + coord_quickmap()
+ }
> 
> if (require("maps")) {
+ # Other projections
+ nzmap + coord_map("azequalarea", orientation = c(-36.92, 174.6, 0))
+ }
> 
> if (require("maps")) {
+ states <- map_data("state")
+ usamap <- ggplot(states, aes(long, lat, group = group)) +
+   geom_polygon(fill = "white", colour = "black")
+ 
+ # Use cartesian coordinates
+ usamap
+ }
> 
> if (require("maps")) {
+ # With mercator projection
+ usamap + coord_map()
+ }
> 
> if (require("maps")) {
+ # See ?mapproject for coordinate systems and their parameters
+ usamap + coord_map("gilbert")
+ }
> 
> if (require("maps")) {
+ # For most projections, you'll need to set the orientation yourself
+ # as the automatic selection done by mapproject is not available to
+ # ggplot
+ usamap + coord_map("orthographic")
+ }
> 
> if (require("maps")) {
+ usamap + coord_map("conic", lat0 = 30)
+ }
> 
> if (require("maps")) {
+ usamap + coord_map("bonne", lat0 = 50)
+ }
> 
> ## Not run: 
> ##D if (require("maps")) {
> ##D # World map, using geom_path instead of geom_polygon
> ##D world <- map_data("world")
> ##D worldmap <- ggplot(world, aes(x = long, y = lat, group = group)) +
> ##D   geom_path() +
> ##D   scale_y_continuous(breaks = (-2:2) * 30) +
> ##D   scale_x_continuous(breaks = (-4:4) * 45)
> ##D 
> ##D # Orthographic projection with default orientation (looking down at North pole)
> ##D worldmap + coord_map("ortho")
> ##D }
> ##D 
> ##D if (require("maps")) {
> ##D # Looking up up at South Pole
> ##D worldmap + coord_map("ortho", orientation = c(-90, 0, 0))
> ##D }
> ##D 
> ##D if (require("maps")) {
> ##D # Centered on New York (currently has issues with closing polygons)
> ##D worldmap + coord_map("ortho", orientation = c(41, -74, 0))
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:maps’

> nameEx("coord_polar")
> ### * coord_polar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_polar
> ### Title: Polar coordinates
> ### Aliases: coord_polar coord_radial
> 
> ### ** Examples
> 
> # NOTE: Use these plots with caution - polar coordinates has
> # major perceptual problems.  The main point of these examples is
> # to demonstrate how these common plots can be described in the
> # grammar.  Use with EXTREME caution.
> 
> #' # A pie chart = stacked bar chart + polar coordinates
> pie <- ggplot(mtcars, aes(x = factor(1), fill = factor(cyl))) +
+  geom_bar(width = 1)
> pie + coord_polar(theta = "y")
> 
> # A partial polar plot
> ggplot(mtcars, aes(disp, mpg)) +
+   geom_point() +
+   coord_radial(start = -0.4 * pi, end = 0.4 * pi, inner.radius = 0.3)
> 
> 
> 
> cleanEx()
> nameEx("coord_trans")
> ### * coord_trans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coord_trans
> ### Title: Transformed Cartesian coordinate system
> ### Aliases: coord_trans
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("cut_interval")
> ### * cut_interval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut_interval
> ### Title: Discretise numeric data into categorical
> ### Aliases: cut_interval cut_number cut_width
> 
> ### ** Examples
> 
> table(cut_interval(1:100, 10))

   [1,10.9] (10.9,20.8] (20.8,30.7] (30.7,40.6] (40.6,50.5] (50.5,60.4] 
         10          10          10          10          10          10 
(60.4,70.3] (70.3,80.2] (80.2,90.1]  (90.1,100] 
         10          10          10          10 
> table(cut_interval(1:100, 11))

  [1,10]  (10,19]  (19,28]  (28,37]  (37,46]  (46,55]  (55,64]  (64,73] 
      10        9        9        9        9        9        9        9 
 (73,82]  (82,91] (91,100] 
       9        9        9 
> 
> set.seed(1)
> 
> table(cut_number(runif(1000), 10))

[0.00131,0.105]   (0.105,0.201]   (0.201,0.312]   (0.312,0.398]   (0.398,0.483] 
            100             100             100             100             100 
  (0.483,0.596]   (0.596,0.706]   (0.706,0.797]    (0.797,0.91]        (0.91,1] 
            100             100             100             100             100 
> 
> table(cut_width(runif(1000), 0.1))

[-0.05,0.05]  (0.05,0.15]  (0.15,0.25]  (0.25,0.35]  (0.35,0.45]  (0.45,0.55] 
          59          109          103           96          110           85 
 (0.55,0.65]  (0.65,0.75]  (0.75,0.85]  (0.85,0.95]  (0.95,1.05] 
          89           86          113           97           53 
> table(cut_width(runif(1000), 0.1, boundary = 0))

  [0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
      106       106       108       100        99       107        84        96 
(0.8,0.9]   (0.9,1] 
       95        99 
> table(cut_width(runif(1000), 0.1, center = 0))

[-0.05,0.05]  (0.05,0.15]  (0.15,0.25]  (0.25,0.35]  (0.35,0.45]  (0.45,0.55] 
          72          104           80          104          100           91 
 (0.55,0.65]  (0.65,0.75]  (0.75,0.85]  (0.85,0.95]  (0.95,1.05] 
          94           75          115          110           55 
> table(cut_width(runif(1000), 0.1, labels = FALSE))

  1   2   3   4   5   6   7   8   9  10  11 
 49  92 100  98 112 102  88  89  97 116  57 
> 
> 
> 
> cleanEx()
> nameEx("draw_key")
> ### * draw_key
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_key
> ### Title: Key glyphs for legends
> ### Aliases: draw_key draw_key_point draw_key_abline draw_key_rect
> ###   draw_key_polygon draw_key_blank draw_key_boxplot draw_key_crossbar
> ###   draw_key_path draw_key_vpath draw_key_dotplot draw_key_linerange
> ###   draw_key_pointrange draw_key_smooth draw_key_text draw_key_label
> ###   draw_key_vline draw_key_timeseries
> 
> ### ** Examples
> 
> p <- ggplot(economics, aes(date, psavert, color = "savings rate"))
> # key glyphs can be specified by their name
> p + geom_line(key_glyph = "timeseries")
> 
> # key glyphs can be specified via their drawing function
> p + geom_line(key_glyph = draw_key_rect)
> 
> 
> 
> cleanEx()
> nameEx("element")
> ### * element
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: element
> ### Title: Theme elements
> ### Aliases: element_blank element_rect element_line element_text rel
> ###   margin
> 
> ### ** Examples
> 
> plot <- ggplot(mpg, aes(displ, hwy)) + geom_point()
> 
> plot + theme(
+   panel.background = element_blank(),
+   axis.text = element_blank()
+ )
> 
> plot + theme(
+   axis.text = element_text(colour = "red", size = rel(1.5))
+ )
> 
> plot + theme(
+   axis.line = element_line(arrow = arrow())
+ )
> 
> plot + theme(
+   panel.background = element_rect(fill = "white"),
+   plot.margin = margin(2, 2, 2, 2, "cm"),
+   plot.background = element_rect(
+     fill = "grey90",
+     colour = "black",
+     linewidth = 1
+   )
+ )
> 
> 
> 
> cleanEx()
> nameEx("expand_limits")
> ### * expand_limits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand_limits
> ### Title: Expand the plot limits, using data
> ### Aliases: expand_limits
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
> p + expand_limits(x = 0)
> p + expand_limits(y = c(1, 9))
> p + expand_limits(x = 0, y = 0)
> 
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(colour = cyl)) +
+   expand_limits(colour = seq(2, 10, by = 2))
> ggplot(mtcars, aes(mpg, wt)) +
+   geom_point(aes(colour = factor(cyl))) +
+   expand_limits(colour = factor(seq(2, 10, by = 2)))
> 
> 
> 
> cleanEx()
> nameEx("expansion")
> ### * expansion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expansion
> ### Title: Generate expansion vector for scales
> ### Aliases: expansion expand_scale
> 
> ### ** Examples
> 
> # No space below the bars but 10% above them
> ggplot(mtcars) +
+   geom_bar(aes(x = factor(cyl))) +
+   scale_y_continuous(expand = expansion(mult = c(0, .1)))
> 
> # Add 2 units of space on the left and right of the data
> ggplot(subset(diamonds, carat > 2), aes(cut, clarity)) +
+   geom_jitter() +
+   scale_x_discrete(expand = expansion(add = 2))
> 
> # Reproduce the default range expansion used
> # when the 'expand' argument is not specified
> ggplot(subset(diamonds, carat > 2), aes(cut, price)) +
+   geom_jitter() +
+   scale_x_discrete(expand = expansion(add = .6)) +
+   scale_y_continuous(expand = expansion(mult = .05))
> 
> 
> 
> 
> cleanEx()
> nameEx("facet_grid")
> ### * facet_grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: facet_grid
> ### Title: Lay out panels in a grid
> ### Aliases: facet_grid
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(displ, cty)) + geom_point()
> 
> # Use vars() to supply variables from the dataset:
> p + facet_grid(rows = vars(drv))
> p + facet_grid(cols = vars(cyl))
> p + facet_grid(vars(drv), vars(cyl))
> 
> # To change plot order of facet grid,
> # change the order of variable levels with factor()
> 
> # If you combine a facetted dataset with a dataset that lacks those
> # faceting variables, the data will be repeated across the missing
> # combinations:
> df <- data.frame(displ = mean(mpg$displ), cty = mean(mpg$cty))
> p +
+   facet_grid(cols = vars(cyl)) +
+   geom_point(data = df, colour = "red", size = 2)
> 
> # When scales are constant, duplicated axes can be shown with
> # or without labels
> ggplot(mpg, aes(cty, hwy)) +
+   geom_point() +
+   facet_grid(year ~ drv, axes = "all", axis.labels = "all_x")
> 
> # Free scales -------------------------------------------------------
> # You can also choose whether the scales should be constant
> # across all panels (the default), or whether they should be allowed
> # to vary
> mt <- ggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) +
+   geom_point()
> 
> mt + facet_grid(vars(cyl), scales = "free")
> 
> # If scales and space are free, then the mapping between position
> # and values in the data will be the same across all panels. This
> # is particularly useful for categorical axes
> ggplot(mpg, aes(drv, model)) +
+   geom_point() +
+   facet_grid(manufacturer ~ ., scales = "free", space = "free") +
+   theme(strip.text.y = element_text(angle = 0))
> 
> # Margins ----------------------------------------------------------
> 
> 
> 
> cleanEx()
> nameEx("facet_null")
> ### * facet_null
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: facet_null
> ### Title: Facet specification: a single panel.
> ### Aliases: facet_null
> ### Keywords: internal
> 
> ### ** Examples
> 
> # facet_null is the default faceting specification if you
> # don't override it with facet_grid or facet_wrap
> ggplot(mtcars, aes(mpg, wt)) + geom_point()
> 
> 
> 
> cleanEx()
> nameEx("facet_wrap")
> ### * facet_wrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: facet_wrap
> ### Title: Wrap a 1d ribbon of panels into 2d
> ### Aliases: facet_wrap
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(displ, hwy)) + geom_point()
> 
> # Use vars() to supply faceting variables:
> p + facet_wrap(vars(class))
> 
> # Control the number of rows and columns with nrow and ncol
> p + facet_wrap(vars(class), nrow = 4)
> 
> 
> 
> 
> cleanEx()
> nameEx("fill_alpha")
> ### * fill_alpha
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fill_alpha
> ### Title: Modify fill transparency
> ### Aliases: fill_alpha
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Typical colour input
> fill_alpha("red", 0.5)
[1] "#FF000080"
> 
> if (utils::packageVersion("grid") > "4.2") {
+   # Pattern input
+   fill_alpha(list(grid::linearGradient()), 0.5)
+ }
[[1]]
$x1
[1] 0npc

$y1
[1] 0npc

$x2
[1] 1npc

$y2
[1] 1npc

$stops
[1] 0 1

$colours
[1] "#00000080" "#FFFFFF80"

$extend
[1] "pad"

$group
[1] TRUE

attr(,"class")
[1] "GridLinearGradient" "GridPattern"       

> 
> 
> 
> cleanEx()
> nameEx("fortify-multcomp")
> ### * fortify-multcomp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fortify-multcomp
> ### Title: Fortify methods for objects produced by 'multcomp'
> ### Aliases: fortify-multcomp fortify.glht fortify.confint.glht
> ###   fortify.summary.glht fortify.cld
> ### Keywords: internal
> 
> ### ** Examples
> 
> if (require("multcomp")) {
+ amod <- aov(breaks ~ wool + tension, data = warpbreaks)
+ wht <- glht(amod, linfct = mcp(tension = "Tukey"))
+ 
+ fortify(wht)
+ ggplot(wht, aes(lhs, estimate)) + geom_point()
+ 
+ CI <- confint(wht)
+ fortify(CI)
+ ggplot(CI, aes(lhs, estimate, ymin = lwr, ymax = upr)) +
+    geom_pointrange()
+ 
+ fortify(summary(wht))
+ ggplot(mapping = aes(lhs, estimate)) +
+    geom_linerange(aes(ymin = lwr, ymax = upr), data = CI) +
+    geom_point(aes(size = p), data = summary(wht)) +
+    scale_size(transform = "reverse")
+ 
+ cld <- cld(wht)
+ fortify(cld)
+ }
Loading required package: multcomp
Loading required package: mvtnorm
Loading required package: survival
Loading required package: TH.data
Loading required package: MASS

Attaching package: ‘TH.data’

The following object is masked from ‘package:MASS’:

    geyser

  lhs letters
L   L       a
M   M       b
H   H       b
> 
> 
> 
> cleanEx()

detaching ‘package:multcomp’, ‘package:TH.data’, ‘package:MASS’,
  ‘package:survival’, ‘package:mvtnorm’

> nameEx("fortify.lm")
> ### * fortify.lm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fortify.lm
> ### Title: Supplement the data fitted to a linear model with model fit
> ###   statistics.
> ### Aliases: fortify.lm
> ### Keywords: internal
> 
> ### ** Examples
> 
> mod <- lm(mpg ~ wt, data = mtcars)
> head(fortify(mod))
                   mpg    wt       .hat   .sigma      .cooksd  .fitted
Mazda RX4         21.0 2.620 0.04326896 3.067494 1.327407e-02 23.28261
Mazda RX4 Wag     21.0 2.875 0.03519677 3.093068 1.723963e-03 21.91977
Datsun 710        22.8 2.320 0.05837573 3.072127 1.543937e-02 24.88595
Hornet 4 Drive    21.4 3.215 0.03125017 3.088268 3.020558e-03 20.10265
Hornet Sportabout 18.7 3.440 0.03292182 3.097722 7.599578e-05 18.90014
Valiant           18.1 3.460 0.03323551 3.095184 9.210650e-04 18.79325
                      .resid   .stdresid
Mazda RX4         -2.2826106 -0.76616765
Mazda RX4 Wag     -0.9197704 -0.30743051
Datsun 710        -2.0859521 -0.70575249
Hornet 4 Drive     1.2973499  0.43275114
Hornet Sportabout -0.2001440 -0.06681879
Valiant           -0.6932545 -0.23148309
> head(fortify(mod, mtcars))
                   mpg cyl disp  hp drat    wt  qsec vs am gear carb       .hat
Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 0.04326896
Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 0.03519677
Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 0.05837573
Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 0.03125017
Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 0.03292182
Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 0.03323551
                    .sigma      .cooksd  .fitted     .resid   .stdresid
Mazda RX4         3.067494 1.327407e-02 23.28261 -2.2826106 -0.76616765
Mazda RX4 Wag     3.093068 1.723963e-03 21.91977 -0.9197704 -0.30743051
Datsun 710        3.072127 1.543937e-02 24.88595 -2.0859521 -0.70575249
Hornet 4 Drive    3.088268 3.020558e-03 20.10265  1.2973499  0.43275114
Hornet Sportabout 3.097722 7.599578e-05 18.90014 -0.2001440 -0.06681879
Valiant           3.095184 9.210650e-04 18.79325 -0.6932545 -0.23148309
> 
> plot(mod, which = 1)
> 
> ggplot(mod, aes(.fitted, .resid)) +
+   geom_point() +
+   geom_hline(yintercept = 0) +
+   geom_smooth(se = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> ggplot(mod, aes(.fitted, .stdresid)) +
+   geom_point() +
+   geom_hline(yintercept = 0) +
+   geom_smooth(se = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> ggplot(fortify(mod, mtcars), aes(.fitted, .stdresid)) +
+   geom_point(aes(colour = factor(cyl)))
> 
> ggplot(fortify(mod, mtcars), aes(mpg, .stdresid)) +
+   geom_point(aes(colour = factor(cyl)))
> 
> plot(mod, which = 2)
> ggplot(mod) +
+   stat_qq(aes(sample = .stdresid)) +
+   geom_abline()
> 
> plot(mod, which = 3)
> ggplot(mod, aes(.fitted, sqrt(abs(.stdresid)))) +
+   geom_point() +
+   geom_smooth(se = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> plot(mod, which = 4)
> ggplot(mod, aes(seq_along(.cooksd), .cooksd)) +
+   geom_col()
> 
> plot(mod, which = 5)
> ggplot(mod, aes(.hat, .stdresid)) +
+   geom_vline(linewidth = 2, colour = "white", xintercept = 0) +
+   geom_hline(linewidth = 2, colour = "white", yintercept = 0) +
+   geom_point() + geom_smooth(se = FALSE)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> ggplot(mod, aes(.hat, .stdresid)) +
+   geom_point(aes(size = .cooksd)) +
+   geom_smooth(se = FALSE, linewidth = 0.5)
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> plot(mod, which = 6)
> ggplot(mod, aes(.hat, .cooksd)) +
+   geom_vline(xintercept = 0, colour = NA) +
+   geom_abline(slope = seq(0, 3, by = 0.5), colour = "white") +
+   geom_smooth(se = FALSE) +
+   geom_point()
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
> 
> ggplot(mod, aes(.hat, .cooksd)) +
+   geom_point(aes(size = .cooksd / .hat)) +
+   scale_size_area()
> 
> 
> 
> cleanEx()
> nameEx("fortify.map")
> ### * fortify.map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fortify.map
> ### Title: Fortify method for map objects
> ### Aliases: fortify.map
> ### Keywords: internal
> 
> ### ** Examples
> 
> if (require("maps")) {
+ ca <- map("county", "ca", plot = FALSE, fill = TRUE)
+ head(fortify(ca))
+ ggplot(ca, aes(long, lat)) +
+   geom_polygon(aes(group = group))
+ }
Loading required package: maps
> 
> if (require("maps")) {
+ tx <- map("county", "texas", plot = FALSE, fill = TRUE)
+ head(fortify(tx))
+ ggplot(tx, aes(long, lat)) +
+   geom_polygon(aes(group = group), colour = "white")
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:maps’

> nameEx("geom_abline")
> ### * geom_abline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_abline
> ### Title: Reference lines: horizontal, vertical, and diagonal
> ### Aliases: geom_abline geom_hline geom_vline
> 
> ### ** Examples
> 
> p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
> 
> # Fixed values
> p + geom_vline(xintercept = 5)
> p + geom_vline(xintercept = 1:5)
> p + geom_hline(yintercept = 20)
> 
> p + geom_abline() # Can't see it - outside the range of the data
> p + geom_abline(intercept = 20)
> 
> # Calculate slope and intercept of line of best fit
> coef(lm(mpg ~ wt, data = mtcars))
(Intercept)          wt 
  37.285126   -5.344472 
> p + geom_abline(intercept = 37, slope = -5)
> # But this is easier to do with geom_smooth:
> p + geom_smooth(method = "lm", se = FALSE)
`geom_smooth()` using formula = 'y ~ x'
> 
> # To show different lines in different facets, use aesthetics
> p <- ggplot(mtcars, aes(mpg, wt)) +
+   geom_point() +
+   facet_wrap(~ cyl)
> 
> mean_wt <- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
> p + geom_hline(aes(yintercept = wt), mean_wt)
> 
> # You can also control other aesthetics
> ggplot(mtcars, aes(mpg, wt, colour = wt)) +
+   geom_point() +
+   geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
+   facet_wrap(~ cyl)
> 
> 
> 
> cleanEx()
> nameEx("geom_bar")
> ### * geom_bar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_bar
> ### Title: Bar charts
> ### Aliases: geom_bar geom_col stat_count
> 
> ### ** Examples
> 
> # geom_bar is designed to make it easy to create bar charts that show
> # counts (or sums of weights)
> g <- ggplot(mpg, aes(class))
> # Number of cars in each class:
> g + geom_bar()
> # Total engine displacement of each class
> g + geom_bar(aes(weight = displ))
> # Map class to y instead to flip the orientation
> ggplot(mpg) + geom_bar(aes(y = class))
> 
> # Bar charts are automatically stacked when multiple bars are placed
> # at the same location. The order of the fill is designed to match
> # the legend
> g + geom_bar(aes(fill = drv))
> 
> # If you need to flip the order (because you've flipped the orientation)
> # call position_stack() explicitly:
> ggplot(mpg, aes(y = class)) +
+  geom_bar(aes(fill = drv), position = position_stack(reverse = TRUE)) +
+  theme(legend.position = "top")
> 
> # To show (e.g.) means, you need geom_col()
> df <- data.frame(trt = c("a", "b", "c"), outcome = c(2.3, 1.9, 3.2))
> ggplot(df, aes(trt, outcome)) +
+   geom_col()
> # But geom_point() displays exactly the same information and doesn't
> # require the y-axis to touch zero.
> ggplot(df, aes(trt, outcome)) +
+   geom_point()
> 
> # You can also use geom_bar() with continuous data, in which case
> # it will show counts at unique locations
> df <- data.frame(x = rep(c(2.9, 3.1, 4.5), c(5, 10, 4)))
> ggplot(df, aes(x)) + geom_bar()
> # cf. a histogram of the same data
> ggplot(df, aes(x)) + geom_histogram(binwidth = 0.5)
> 
> # Use `just` to control how columns are aligned with axis breaks:
> df <- data.frame(x = as.Date(c("2020-01-01", "2020-02-01")), y = 1:2)
> # Columns centered on the first day of the month
> ggplot(df, aes(x, y)) + geom_col(just = 0.5)
> # Columns begin on the first day of the month
> ggplot(df, aes(x, y)) + geom_col(just = 1)
> 
> 
> 
> cleanEx()
> nameEx("geom_bin_2d")
> ### * geom_bin_2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_bin_2d
> ### Title: Heatmap of 2d bin counts
> ### Aliases: geom_bin_2d geom_bin2d stat_bin_2d stat_bin2d
> 
> ### ** Examples
> 
> d <- ggplot(diamonds, aes(x, y)) + xlim(4, 10) + ylim(4, 10)
> d + geom_bin_2d()
Warning: Removed 478 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 5 rows containing missing values or values outside the scale range
(`geom_tile()`).
> 
> # You can control the size of the bins by specifying the number of
> # bins in each direction:
> d + geom_bin_2d(bins = 10)
Warning: Removed 478 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 6 rows containing missing values or values outside the scale range
(`geom_tile()`).
> d + geom_bin_2d(bins = 30)
Warning: Removed 478 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 5 rows containing missing values or values outside the scale range
(`geom_tile()`).
> 
> # Or by specifying the width of the bins
> d + geom_bin_2d(binwidth = c(0.1, 0.1))
Warning: Removed 478 rows containing non-finite outside the scale range
(`stat_bin2d()`).
Warning: Removed 5 rows containing missing values or values outside the scale range
(`geom_tile()`).
> 
> 
> 
> cleanEx()
> nameEx("geom_blank")
> ### * geom_blank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_blank
> ### Title: Draw nothing
> ### Aliases: geom_blank
> 
> ### ** Examples
> 
> ggplot(mtcars, aes(wt, mpg))
> # Nothing to see here!
> 
> 
> 
> cleanEx()
> nameEx("geom_boxplot")
> ### * geom_boxplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_boxplot
> ### Title: A box and whiskers plot (in the style of Tukey)
> ### Aliases: geom_boxplot stat_boxplot
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(class, hwy))
> p + geom_boxplot()
> # Orientation follows the discrete axis
> ggplot(mpg, aes(hwy, class)) + geom_boxplot()
> 
> p + geom_boxplot(notch = TRUE)
Notch went outside hinges
ℹ Do you want `notch = FALSE`?
Notch went outside hinges
ℹ Do you want `notch = FALSE`?
> p + geom_boxplot(varwidth = TRUE)
> p + geom_boxplot(fill = "white", colour = "#3366FF")
> # By default, outlier points match the colour of the box. Use
> # outlier.colour to override
> p + geom_boxplot(outlier.colour = "red", outlier.shape = 1)
> # Remove outliers when overlaying boxplot with original data points
> p + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2)
> 
> # Boxplots are automatically dodged when any aesthetic is a factor
> p + geom_boxplot(aes(colour = drv))
> 
> # You can also use boxplots with continuous x, as long as you supply
> # a grouping variable. cut_width is particularly useful
> ggplot(diamonds, aes(carat, price)) +
+   geom_boxplot()
Warning: Continuous x aesthetic
ℹ did you forget `aes(group = ...)`?
> ggplot(diamonds, aes(carat, price)) +
+   geom_boxplot(aes(group = cut_width(carat, 0.25)))
> # Adjust the transparency of outliers using outlier.alpha
> ggplot(diamonds, aes(carat, price)) +
+   geom_boxplot(aes(group = cut_width(carat, 0.25)), outlier.alpha = 0.1)
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_contour")
> ### * geom_contour
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_contour
> ### Title: 2D contours of a 3D surface
> ### Aliases: geom_contour geom_contour_filled stat_contour
> ###   stat_contour_filled
> 
> ### ** Examples
> 
> # Basic plot
> v <- ggplot(faithfuld, aes(waiting, eruptions, z = density))
> v + geom_contour()
> 
> # Or compute from raw data
> ggplot(faithful, aes(waiting, eruptions)) +
+   geom_density_2d()
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_count")
> ### * geom_count
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_count
> ### Title: Count overlapping points
> ### Aliases: geom_count stat_sum
> 
> ### ** Examples
> 
> ggplot(mpg, aes(cty, hwy)) +
+  geom_point()
> 
> ggplot(mpg, aes(cty, hwy)) +
+  geom_count()
> 
> # Best used in conjunction with scale_size_area which ensures that
> # counts of zero would be given size 0. Doesn't make much different
> # here because the smallest count is already close to 0.
> ggplot(mpg, aes(cty, hwy)) +
+  geom_count() +
+  scale_size_area()
> 
> # Display proportions instead of counts -------------------------------------
> # By default, all categorical variables in the plot form the groups.
> # Specifying geom_count without a group identifier leads to a plot which is
> # not useful:
> d <- ggplot(diamonds, aes(x = cut, y = clarity))
> d + geom_count(aes(size = after_stat(prop)))
> # To correct this problem and achieve a more desirable plot, we need
> # to specify which group the proportion is to be calculated over.
> d + geom_count(aes(size = after_stat(prop), group = 1)) +
+   scale_size_area(max_size = 10)
> 
> # Or group by x/y variables to have rows/columns sum to 1.
> d + geom_count(aes(size = after_stat(prop), group = cut)) +
+   scale_size_area(max_size = 10)
> d + geom_count(aes(size = after_stat(prop), group = clarity)) +
+   scale_size_area(max_size = 10)
> 
> 
> 
> cleanEx()
> nameEx("geom_density")
> ### * geom_density
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_density
> ### Title: Smoothed density estimates
> ### Aliases: geom_density stat_density
> 
> ### ** Examples
> 
> ggplot(diamonds, aes(carat)) +
+   geom_density()
> # Map the values to y to flip the orientation
> ggplot(diamonds, aes(y = carat)) +
+   geom_density()
> 
> ggplot(diamonds, aes(carat)) +
+   geom_density(adjust = 1/5)
> ggplot(diamonds, aes(carat)) +
+   geom_density(adjust = 5)
> 
> ggplot(diamonds, aes(depth, colour = cut)) +
+   geom_density() +
+   xlim(55, 70)
Warning: Removed 45 rows containing non-finite outside the scale range
(`stat_density()`).
> ggplot(diamonds, aes(depth, fill = cut, colour = cut)) +
+   geom_density(alpha = 0.1) +
+   xlim(55, 70)
Warning: Removed 45 rows containing non-finite outside the scale range
(`stat_density()`).
> 
> # Use `bounds` to adjust computation for known data limits
> big_diamonds <- diamonds[diamonds$carat >= 1, ]
> ggplot(big_diamonds, aes(carat)) +
+   geom_density(color = 'red') +
+   geom_density(bounds = c(1, Inf), color = 'blue')
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_density_2d")
> ### * geom_density_2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_density_2d
> ### Title: Contours of a 2D density estimate
> ### Aliases: geom_density_2d geom_density2d geom_density_2d_filled
> ###   geom_density2d_filled stat_density_2d stat_density2d
> ###   stat_density_2d_filled stat_density2d_filled
> 
> ### ** Examples
> 
> m <- ggplot(faithful, aes(x = eruptions, y = waiting)) +
+  geom_point() +
+  xlim(0.5, 6) +
+  ylim(40, 110)
> 
> # contour lines
> m + geom_density_2d()
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_dotplot")
> ### * geom_dotplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_dotplot
> ### Title: Dot plot
> ### Aliases: geom_dotplot
> 
> ### ** Examples
> 
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot()
Bin width defaults to 1/30 of the range of the data. Pick better value with
`binwidth`.
> 
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5)
> 
> # Use fixed-width bins
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(method="histodot", binwidth = 1.5)
> 
> # Some other stacking methods
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, stackdir = "center")
> 
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, stackdir = "centerwhole")
> 
> # y axis isn't really meaningful, so hide it
> ggplot(mtcars, aes(x = mpg)) + geom_dotplot(binwidth = 1.5) +
+   scale_y_continuous(NULL, breaks = NULL)
> 
> # Overlap dots vertically
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, stackratio = .7)
> 
> # Expand dot diameter
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, dotsize = 1.25)
> 
> # Change dot fill colour, stroke width
> ggplot(mtcars, aes(x = mpg)) +
+   geom_dotplot(binwidth = 1.5, fill = "white", stroke = 2)
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_errorbarh")
> ### * geom_errorbarh
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_errorbarh
> ### Title: Horizontal error bars
> ### Aliases: geom_errorbarh
> 
> ### ** Examples
> 
> df <- data.frame(
+   trt = factor(c(1, 1, 2, 2)),
+   resp = c(1, 5, 3, 4),
+   group = factor(c(1, 2, 1, 2)),
+   se = c(0.1, 0.3, 0.3, 0.2)
+ )
> 
> # Define the top and bottom of the errorbars
> 
> p <- ggplot(df, aes(resp, trt, colour = group))
> p +
+   geom_point() +
+   geom_errorbarh(aes(xmax = resp + se, xmin = resp - se))
> 
> p +
+   geom_point() +
+   geom_errorbarh(aes(xmax = resp + se, xmin = resp - se, height = .2))
> 
> 
> 
> cleanEx()
> nameEx("geom_function")
> ### * geom_function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_function
> ### Title: Draw a function as a continuous curve
> ### Aliases: geom_function stat_function
> 
> ### ** Examples
> 
> 
> # geom_function() is useful for overlaying functions
> set.seed(1492)
> ggplot(data.frame(x = rnorm(100)), aes(x)) +
+   geom_density() +
+   geom_function(fun = dnorm, colour = "red")
> 
> # To plot functions without data, specify range of x-axis
> base <-
+   ggplot() +
+   xlim(-5, 5)
> 
> base + geom_function(fun = dnorm)
> 
> base + geom_function(fun = dnorm, args = list(mean = 2, sd = .5))
> 
> # The underlying mechanics evaluate the function at discrete points
> # and connect the points with lines
> base + stat_function(fun = dnorm, geom = "point")
> 
> base + stat_function(fun = dnorm, geom = "point", n = 20)
> 
> base + stat_function(fun = dnorm, geom = "polygon", color = "blue", fill = "blue", alpha = 0.5)
> 
> base + geom_function(fun = dnorm, n = 20)
> 
> # Two functions on the same plot
> base +
+   geom_function(aes(colour = "normal"), fun = dnorm) +
+   geom_function(aes(colour = "t, df = 1"), fun = dt, args = list(df = 1))
> 
> # Using a custom anonymous function
> base + geom_function(fun = function(x) 0.5 * exp(-abs(x)))
> # or using lambda syntax:
> # base + geom_function(fun = ~ 0.5 * exp(-abs(.x)))
> # or in R4.1.0 and above:
> # base + geom_function(fun = \(x) 0.5 * exp(-abs(x)))
> # or using a custom named function:
> # f <- function(x) 0.5 * exp(-abs(x))
> # base + geom_function(fun = f)
> 
> # Using xlim to restrict the range of function
> ggplot(data.frame(x = rnorm(100)), aes(x)) +
+ geom_density() +
+ geom_function(fun = dnorm, colour = "red", xlim=c(-1, 1))
> 
> # Using xlim to widen the range of function
> ggplot(data.frame(x = rnorm(100)), aes(x)) +
+ geom_density() +
+ geom_function(fun = dnorm, colour = "red", xlim=c(-7, 7))
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_hex")
> ### * geom_hex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_hex
> ### Title: Hexagonal heatmap of 2d bin counts
> ### Aliases: geom_hex stat_bin_hex stat_binhex
> 
> ### ** Examples
> 
> d <- ggplot(diamonds, aes(carat, price))
> d + geom_hex()
> 
> 
> 
> 
> cleanEx()
> nameEx("geom_histogram")
> ### * geom_histogram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_freqpoly
> ### Title: Histograms and frequency polygons
> ### Aliases: geom_freqpoly geom_histogram stat_bin
> 
> ### ** Examples
> 
> ggplot(diamonds, aes(carat)) +
+   geom_histogram()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ggplot(diamonds, aes(carat)) +
+   geom_histogram(binwidth = 0.01)
> ggplot(diamonds, aes(carat)) +
+   geom_histogram(bins = 200)
> # Map values to y to flip the orientation
> ggplot(diamonds, aes(y = carat)) +
+   geom_histogram()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # For histograms with tick marks between each bin, use `geom_bar()` with
> # `scale_x_binned()`.
> ggplot(diamonds, aes(carat)) +
+   geom_bar() +
+   scale_x_binned()
> 
> # Rather than stacking histograms, it's easier to compare frequency
> # polygons
> ggplot(diamonds, aes(price, fill = cut)) +
+   geom_histogram(binwidth = 500)
> ggplot(diamonds, aes(price, colour = cut)) +
+   geom_freqpoly(binwidth = 500)
> 
> # To make it easier to compare distributions with very different counts,
> # put density on the y axis instead of the default count
> ggplot(diamonds, aes(price, after_stat(density), colour = cut)) +
+   geom_freqpoly(binwidth = 500)
> 
> if (require("ggplot2movies")) {
+ # Often we don't want the height of the bar to represent the
+ # count of observations, but the sum of some other variable.
+ # For example, the following plot shows the number of movies
+ # in each rating.
+ m <- ggplot(movies, aes(rating))
+ m + geom_histogram(binwidth = 0.1)
+ 
+ # If, however, we want to see the number of votes cast in each
+ # category, we need to weight by the votes variable
+ m +
+   geom_histogram(aes(weight = votes), binwidth = 0.1) +
+   ylab("votes")
+ 
+ # For transformed scales, binwidth applies to the transformed data.
+ # The bins have constant width on the transformed scale.
+ m +
+  geom_histogram() +
+  scale_x_log10()
+ m +
+   geom_histogram(binwidth = 0.05) +
+   scale_x_log10()
+ 
+ # For transformed coordinate systems, the binwidth applies to the
+ # raw data. The bins have constant width on the original scale.
+ 
+ # Using log scales does not work here, because the first
+ # bar is anchored at zero, and so when transformed becomes negative
+ # infinity. This is not a problem when transforming the scales, because
+ # no observations have 0 ratings.
+ m +
+   geom_histogram(boundary = 0) +
+   coord_trans(x = "log10")
+ # Use boundary = 0, to make sure we don't take sqrt of negative values
+ m +
+   geom_histogram(boundary = 0) +
+   coord_trans(x = "sqrt")
+ 
+ # You can also transform the y axis.  Remember that the base of the bars
+ # has value 0, so log transformations are not appropriate
+ m <- ggplot(movies, aes(x = rating))
+ m +
+   geom_histogram(binwidth = 0.5) +
+   scale_y_sqrt()
+ }
Loading required package: ggplot2movies
> 
> # You can specify a function for calculating binwidth, which is
> # particularly useful when faceting along variables with
> # different ranges because the function will be called once per facet
> ggplot(economics_long, aes(value)) +
+   facet_wrap(~variable, scales = 'free_x') +
+   geom_histogram(binwidth = function(x) 2 * IQR(x) / (length(x)^(1/3)))
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2movies’

> nameEx("geom_jitter")
> ### * geom_jitter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_jitter
> ### Title: Jittered points
> ### Aliases: geom_jitter
> 
> ### ** Examples
> 
> p <- ggplot(mpg, aes(cyl, hwy))
> p + geom_point()
> p + geom_jitter()
> 
> # Add aesthetic mappings
> p + geom_jitter(aes(colour = class))
> 
> # Use smaller width/height to emphasise categories
> ggplot(mpg, aes(cyl, hwy)) +
+   geom_jitter()
> ggplot(mpg, aes(cyl, hwy)) +
+   geom_jitter(width = 0.25)
> 
> # Use larger width/height to completely smooth away discreteness
> ggplot(mpg, aes(cty, hwy)) +
+   geom_jitter()
> ggplot(mpg, aes(cty, hwy)) +
+   geom_jitter(width = 0.5, height = 0.5)
> 
> 
> 
> cleanEx()
> nameEx("geom_linerange")
> ### * geom_linerange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_crossbar
> ### Title: Vertical intervals: lines, crossbars & errorbars
> ### Aliases: geom_crossbar geom_errorbar geom_linerange geom_pointrange
> 
> ### ** Examples
> 
> # Create a simple example dataset
> df <- data.frame(
+   trt = factor(c(1, 1, 2, 2)),
+   resp = c(1, 5, 3, 4),
+   group = factor(c(1, 2, 1, 2)),
+   upper = c(1.1, 5.3, 3.3, 4.2),
+   lower = c(0.8, 4.6, 2.4, 3.6)
+ )
> 
> p <- ggplot(df, aes(trt, resp, colour = group))
> p + geom_linerange(aes(ymin = lower, ymax = upper))
> p + geom_pointrange(aes(ymin = lower, ymax = upper))
> p + geom_crossbar(aes(ymin = lower, ymax = upper), width = 0.2)
> p + geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)
> 
> # Flip the orientation by changing mapping
> ggplot(df, aes(resp, trt, colour = group)) +
+   geom_linerange(aes(xmin = lower, xmax = upper))
> 
> # Draw lines connecting group means
> p +
+   geom_line(aes(group = group)) +
+   geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)
> 
> # If you want to dodge bars and errorbars, you need to manually
> # specify the dodge width
> p <- ggplot(df, aes(trt, resp, fill = group))
> p +
+  geom_col(position = "dodge") +
+  geom_errorbar(aes(ymin = lower, ymax = upper), position = "dodge", width = 0.25)
> 
> # Because the bars and errorbars have different widths
> # we need to specify how wide the objects we are dodging are
> dodge <- position_dodge(width=0.9)
> p +
+   geom_col(position = dodge) +
+   geom_errorbar(aes(ymin = lower, ymax = upper), position = dodge, width = 0.25)
> 
> # When using geom_errorbar() with position_dodge2(), extra padding will be
> # needed between the error bars to keep them aligned with the bars.
> p +
+ geom_col(position = "dodge2") +
+ geom_errorbar(
+   aes(ymin = lower, ymax = upper),
+   position = position_dodge2(width = 0.5, padding = 0.5)
+ )
> 
> 
> 
> cleanEx()
> nameEx("geom_map")
> ### * geom_map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geom_map
> ### Title: Polygons from a reference map
> ### Aliases: geom_map
> 
> ### ** Examples
> 
> # First, a made-up example containing a few polygons, to explain
> # how `geom_map()` works. It requires two data frames:
> # One contains the coordinates of each polygon (`positions`), and is
> # provided via the `map` argument. The other contains the
> # other the values associated with each polygon (`values`).  An id
> # variable links the two together.
> 
> ids <- factor(c("1.1", "2.1", "1.2", "2.2", "1.3", "2.3"))
> 
> values <- data.frame(
+   id = ids,
+   value = c(3, 3.1, 3.1, 3.2, 3.15, 3.5)
+ )
> 
> positions <- data.frame(
+   id = rep(ids, each = 4),
+   x = c(2, 1, 1.1, 2.2, 1, 0, 0.3, 1.1, 2.2, 1.1, 1.2, 2.5, 1.1, 0.3,
+   0.5, 1.2, 2.5, 1.2, 1.3, 2.7, 1.2, 0.5, 0.6, 1.3),
+   y = c(-0.5, 0, 1, 0.5, 0, 0.5, 1.5, 1, 0.5, 1, 2.1, 1.7, 1, 1.5,
+   2.2, 2.1, 1.7, 2.1, 3.2, 2.8, 2.1, 2.2, 3.3, 3.2)
+ )
> 
> ggplot(values) +
+   geom_map(aes(map_id = id), map = positions) +
+   expand_limits(positions)
> ggplot(values, aes(fill = value)) +
+   geom_map(aes(map_id = id), map = positions) +
+   expand_limits(positions)
> ggplot(values, aes(fill = value)) +
+   geom_map(aes(map_id = id), map = positions) +
+   expand_limits(positions) + ylim(0, 3)
> 
> # Now some examples with real maps
> if (require(maps)) {
+ 
+   crimes <- data.frame(state = tolower(rownames(USArrests)), USArrests)
+ 
+   # Equivalent to crimes %>% tidyr::pivot_longer(Murder:Rape)
+   vars <- lapply(names(crimes)[-1], function(j) {
+     data.frame(state = crimes$state, variable = j, value = crimes[[j]])
+   })
+   crimes_long <- do.call("rbind", vars)
+ 
+   states_map <- map_data("state")
+ 
+   # without geospatial coordinate system, the resulting plot
+   # looks weird
+   ggplot(crimes, aes(map_id = state)) +
+     geom_map(aes(fill = Murder), map = states_map) +
+     expand_limits(x = states_map$long, y = states_map$lat)
+ 
+   # in combination with `coord_sf()` we get an appropriate result
+   ggplot(crimes, aes(map_id = state)) +
+     geom_map(aes(fill = Murder), map = states_map) +
+     # crs = 5070 is a Conus Albers projection for North America,
+     #   see: https://epsg.io/5070
+     # default_crs = 4326 tells coord_sf() that the input map data
+     #   are in longitude-latitude format
+     coord_sf(
+       crs = 5070, default_crs = 4326,
+       xlim = c(-125, -70), ylim = c(25, 52)
+     )
+ 
+  ggplot(crimes_long, aes(map_id = state)) +
+    geom_map(aes(fill = value), map = states_map) +
+    coord_sf(
+      crs = 5070, default_crs = 4326,
+      xlim = c(-125, -70), ylim = c(25, 52)
+    ) +
+    facet_wrap(~variable)
+ }
Loading required package: maps
Error in dyn.load(file, DLLpath = DLLpath, ...) : 
  unable to load shared object '/usr/local/lib/R/site-library/units/libs/units.so':
  libudunits2.so.0: cannot open shared object file: No such file or directory
Calls: coord_sf ... asNamespace -> loadNamespace -> library.dynam -> dyn.load
Execution halted
