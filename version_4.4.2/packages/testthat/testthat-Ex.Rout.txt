
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "testthat"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('testthat')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Reporter")
> ### * Reporter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Reporter
> ### Title: Manage test reporting
> ### Aliases: Reporter
> ### Keywords: internal
> 
> ### ** Examples
> 
> path <- testthat_example("success")
> 
> test_file(path)

â•â• Testing test-success.R â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]
[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
[ FAIL 0 | WARN 0 | SKIP 1 | PASS 1 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 1 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 2 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 3 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 4 ]

â”€â”€ Warning ('test-success.R:10:3'): some tests have warnings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NaNs produced
Backtrace:
    â–†
 1. â””â”€testthat::expect_equal(log(-1), NaN) at test-success.R:10:3
 2.   â””â”€testthat::quasi_label(enquo(object), label, arg = "object")
 3.     â””â”€rlang::eval_bare(expr, quo_get_env(quo))

â”€â”€ Skipped tests (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ This test hasn't been written yet (1): 'test-success.R:6:3'


[ FAIL 0 | WARN 1 | SKIP 1 | PASS 4 ]
> # Override the default by supplying the name of a reporter
> test_file(path, reporter = "minimal")
.SW...
> 
> 
> 
> cleanEx()
> nameEx("capture_condition")
> ### * capture_condition
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capture_condition
> ### Title: Capture conditions, including messages, warnings, expectations,
> ###   and errors.
> ### Aliases: capture_condition capture_error capture_expectation
> ###   capture_message capture_warning capture_messages capture_warnings
> ### Keywords: internal
> 
> ### ** Examples
> 
> f <- function() {
+   message("First")
+   warning("Second")
+   message("Third")
+ }
> 
> capture_message(f())
<simpleMessage in message("First"): First
>
> capture_messages(f())
Warning in f() : Second
[1] "First\n" "Third\n"
> 
> capture_warning(f())
First
<simpleWarning in f(): Second>
> capture_warnings(f())
First
Third
[1] "Second"
> 
> # Condition will capture anything
> capture_condition(f())
<simpleMessage in message("First"): First
>
> 
> 
> 
> cleanEx()
> nameEx("capture_output")
> ### * capture_output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capture_output
> ### Title: Capture output to console
> ### Aliases: capture_output capture_output_lines testthat_print
> ### Keywords: internal
> 
> ### ** Examples
> 
> capture_output({
+   cat("Hi!\n")
+   cat("Bye\n")
+ })
[1] "Hi!\nBye"
> 
> capture_output_lines({
+   cat("Hi!\n")
+   cat("Bye\n")
+ })
[1] "Hi!" "Bye"
> 
> capture_output("Hi")
[1] ""
> capture_output("Hi", print = TRUE)
[1] "[1] \"Hi\""
> 
> 
> 
> cleanEx()
> nameEx("compare")
> ### * compare
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare
> ### Title: Provide human-readable comparison of two objects
> ### Aliases: compare compare.default compare.character compare.numeric
> ###   compare.POSIXt
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Character -----------------------------------------------------------------
> x <- c("abc", "def", "jih")
> compare(x, x)
Equal
> 
> y <- paste0(x, "y")
> compare(x, y)
3/3 mismatches
x[1]: "abc"
y[1]: "abcy"

x[2]: "def"
y[2]: "defy"

x[3]: "jih"
y[3]: "jihy"> 
> compare(letters, paste0(letters, "-"))
26/26 mismatches
x[1]: "a"
y[1]: "a-"

x[2]: "b"
y[2]: "b-"

x[3]: "c"
y[3]: "c-"

x[4]: "d"
y[4]: "d-"

x[5]: "e"
y[5]: "e-"> 
> x <- "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus
+  tincidunt auctor. Vestibulum ac metus bibendum, facilisis nisi non, pulvinar
+  dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
> y <- "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus
+  tincidunt auctor. Vestibulum ac metus1 bibendum, facilisis nisi non, pulvinar
+  dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
> compare(x, y)
1/1 mismatches
x[1]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
x[1]: ncidunt auctor. Vestibulum ac metus bibendum, facilisis nisi non, pulvinar
x[1]: \n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
y[1]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
y[1]: ncidunt auctor. Vestibulum ac metus1 bibendum, facilisis nisi non, pulvina
y[1]: r\n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "> compare(c(x, x), c(y, y))
2/2 mismatches
x[1]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
x[1]: ncidunt auctor. Vestibulum ac metus bibendum, facilisis nisi non, pulvinar
x[1]: \n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
y[1]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
y[1]: ncidunt auctor. Vestibulum ac metus1 bibendum, facilisis nisi non, pulvina
y[1]: r\n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "

x[2]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
x[2]: ncidunt auctor. Vestibulum ac metus bibendum, facilisis nisi non, pulvinar
x[2]: \n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
y[2]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
y[2]: ncidunt auctor. Vestibulum ac metus1 bibendum, facilisis nisi non, pulvina
y[2]: r\n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "> 
> # Numeric -------------------------------------------------------------------
> 
> x <- y <- runif(100)
> y[sample(100, 10)] <- 5
> compare(x, y)
10/100 mismatches (average diff: 4.45)
[17] 0.718 - 5 == -4.28
[21] 0.935 - 5 == -4.07
[28] 0.382 - 5 == -4.62
[31] 0.482 - 5 == -4.52
[33] 0.494 - 5 == -4.51
[45] 0.530 - 5 == -4.47
[48] 0.477 - 5 == -4.52
[73] 0.347 - 5 == -4.65
[83] 0.400 - 5 == -4.60
...> 
> x <- y <- 1:10
> x[5] <- NA
> x[6] <- 6.5
> compare(x, y)
2/10 mismatches (average diff: 0.5)
[5]  NA - 5 ==  NA
[6] 6.5 - 6 == 0.5> 
> # Compare ignores minor numeric differences in the same way
> # as all.equal.
> compare(x, x + 1e-9)
Equal
> 
> 
> 
> cleanEx()
> nameEx("comparison-expectations")
> ### * comparison-expectations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: comparison-expectations
> ### Title: Does code return a number greater/less than the expected value?
> ### Aliases: comparison-expectations expect_lt expect_lte expect_gt
> ###   expect_gte
> 
> ### ** Examples
> 
> a <- 9
> expect_lt(a, 10)
> 
> ## Not run: 
> ##D expect_lt(11, 10)
> ## End(Not run)
> 
> a <- 11
> expect_gt(a, 10)
> ## Not run: 
> ##D expect_gt(9, 10)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("context")
> ### * context
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: context
> ### Title: Describe the context of a set of tests.
> ### Aliases: context
> ### Keywords: internal
> 
> ### ** Examples
> 
> context("String processing")
Warning: `context()` was deprecated in the 3rd edition.
> context("Remote procedure calls")
Warning: `context()` was deprecated in the 3rd edition.
> 
> 
> 
> cleanEx()
> nameEx("describe")
> ### * describe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: describe
> ### Title: describe: a BDD testing language
> ### Aliases: describe it
> 
> ### ** Examples
> 
> describe("matrix()", {
+   it("can be multiplied by a scalar", {
+     m1 <- matrix(1:4, 2, 2)
+     m2 <- m1 * 2
+     expect_equal(matrix(1:4 * 2, 2, 2), m2)
+   })
+   it("can have not yet tested specs")
+ })
Test passed ðŸ˜€
Test passed ðŸŒˆ
> 
> # Nested specs:
> ## code
> addition <- function(a, b) a + b
> division <- function(a, b) a / b
> 
> ## specs
> describe("math library", {
+   describe("addition()", {
+     it("can add two numbers", {
+       expect_equal(1 + 1, addition(1, 1))
+     })
+   })
+   describe("division()", {
+     it("can divide two numbers", {
+       expect_equal(10 / 2, division(10, 2))
+     })
+     it("can handle division by 0") #not yet implemented
+   })
+ })
Test passed ðŸŽŠ
Test passed ðŸ˜€
Test passed ðŸ¥³
> 
> 
> 
> cleanEx()
> nameEx("equality-expectations")
> ### * equality-expectations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: equality-expectations
> ### Title: Does code return the expected value?
> ### Aliases: equality-expectations expect_equal expect_identical
> 
> ### ** Examples
> 
> a <- 10
> expect_equal(a, 10)
> 
> # Use expect_equal() when testing for numeric equality
> ## Not run: 
> ##D expect_identical(sqrt(2) ^ 2, 2)
> ## End(Not run)
> expect_equal(sqrt(2) ^ 2, 2)
> 
> 
> 
> cleanEx()
> nameEx("evaluate_promise")
> ### * evaluate_promise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: evaluate_promise
> ### Title: Evaluate a promise, capturing all types of output.
> ### Aliases: evaluate_promise
> ### Keywords: internal
> 
> ### ** Examples
> 
> evaluate_promise({
+   print("1")
+   message("2")
+   warning("3")
+   4
+ })
$result
[1] 4

$output
[1] "[1] \"1\""

$warnings
[1] "3"

$messages
[1] "2\n"

> 
> 
> 
> cleanEx()
> nameEx("expect_equivalent")
> ### * expect_equivalent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_equivalent
> ### Title: Is an object equal to the expected value, ignoring attributes?
> ### Aliases: expect_equivalent
> ### Keywords: internal
> 
> ### ** Examples
> 
> #' # expect_equivalent() ignores attributes
> a <- b <- 1:3
> names(b) <- letters[1:3]
> ## Not run: 
> ##D expect_equal(a, b)
> ## End(Not run)
> expect_equivalent(a, b)
Warning: `expect_equivalent()` was deprecated in the 3rd edition.
â„¹ Use expect_equal(ignore_attr = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("expect_error")
> ### * expect_error
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_error
> ### Title: Does code throw an error, warning, message, or other condition?
> ### Aliases: expect_error expect_warning expect_message expect_condition
> 
> ### ** Examples
> 
> # Errors ------------------------------------------------------------------
> f <- function() stop("My error!")
> expect_error(f())
> expect_error(f(), "My error!")
> 
> # You can use the arguments of grepl to control the matching
> expect_error(f(), "my error!", ignore.case = TRUE)
> 
> # Note that `expect_error()` returns the error object so you can test
> # its components if needed
> err <- expect_error(rlang::abort("a", n = 10))
> expect_equal(err$n, 10)
> 
> # Warnings ------------------------------------------------------------------
> f <- function(x) {
+   if (x < 0) {
+     warning("*x* is already negative")
+     return(x)
+   }
+   -x
+ }
> expect_warning(f(-1))
> expect_warning(f(-1), "already negative")
> expect_warning(f(1), NA)
> 
> # To test message and output, store results to a variable
> expect_warning(out <- f(-1), "already negative")
> expect_equal(out, -1)
> 
> # Messages ------------------------------------------------------------------
> f <- function(x) {
+   if (x < 0) {
+     message("*x* is already negative")
+     return(x)
+   }
+ 
+   -x
+ }
> expect_message(f(-1))
> expect_message(f(-1), "already negative")
> expect_message(f(1), NA)
> 
> 
> 
> cleanEx()
> nameEx("expect_invisible")
> ### * expect_invisible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_invisible
> ### Title: Does code return a visible or invisible object?
> ### Aliases: expect_invisible expect_visible
> 
> ### ** Examples
> 
> expect_invisible(x <- 10)
> expect_visible(x)
> 
> # Typically you'll assign the result of the expectation so you can
> # also check that the value is as you expect.
> greet <- function(name) {
+   message("Hi ", name)
+   invisible(name)
+ }
> out <- expect_invisible(greet("Hadley"))
Hi Hadley
> expect_equal(out, "Hadley")
> 
> 
> 
> cleanEx()
> nameEx("expect_known_output")
> ### * expect_known_output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_known_output
> ### Title: Expectations: is the output or the value equal to a known good
> ###   value?
> ### Aliases: expect_known_output expect_known_value
> ###   expect_equal_to_reference expect_known_hash
> ### Keywords: internal
> 
> ### ** Examples
> 
> tmp <- tempfile()
> 
> # The first run always succeeds
> expect_known_output(mtcars[1:10, ], tmp, print = TRUE)
Warning: `expect_known_output()` was deprecated in the 3rd edition.
â„¹ Please use `expect_snapshot_output()` instead
Warning: Creating reference output
> 
> # Subsequent runs will succeed only if the file is unchanged
> # This will succeed:
> expect_known_output(mtcars[1:10, ], tmp, print = TRUE)
Warning: `expect_known_output()` was deprecated in the 3rd edition.
â„¹ Please use `expect_snapshot_output()` instead
> 
> ## Not run: 
> ##D # This will fail
> ##D expect_known_output(mtcars[1:9, ], tmp, print = TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expect_length")
> ### * expect_length
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_length
> ### Title: Does code return a vector with the specified length?
> ### Aliases: expect_length
> 
> ### ** Examples
> 
> expect_length(1, 1)
> expect_length(1:10, 10)
> 
> ## Not run: 
> ##D expect_length(1:10, 1)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expect_match")
> ### * expect_match
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_match
> ### Title: Does a string match a regular expression?
> ### Aliases: expect_match expect_no_match
> 
> ### ** Examples
> 
> expect_match("Testing is fun", "fun")
> expect_match("Testing is fun", "f.n")
> expect_no_match("Testing is fun", "horrible")
> 
> ## Not run: 
> ##D expect_match("Testing is fun", "horrible")
> ##D 
> ##D # Zero-length inputs always fail
> ##D expect_match(character(), ".")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expect_named")
> ### * expect_named
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_named
> ### Title: Does code return a vector with (given) names?
> ### Aliases: expect_named
> 
> ### ** Examples
> 
> x <- c(a = 1, b = 2, c = 3)
> expect_named(x)
> expect_named(x, c("a", "b", "c"))
> 
> # Use options to control sensitivity
> expect_named(x, c("B", "C", "A"), ignore.order = TRUE, ignore.case = TRUE)
> 
> # Can also check for the absence of names with NULL
> z <- 1:4
> expect_named(z, NULL)
> 
> 
> 
> cleanEx()
> nameEx("expect_no_error")
> ### * expect_no_error
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_no_error
> ### Title: Does code run without error, warning, message, or other
> ###   condition?
> ### Aliases: expect_no_error expect_no_warning expect_no_message
> ###   expect_no_condition
> 
> ### ** Examples
> 
> expect_no_warning(1 + 1)
> 
> foo <- function(x) {
+   warning("This is a problem!")
+ }
> 
> # warning doesn't match so bubbles up:
> expect_no_warning(foo(), message = "bananas")
Warning in foo() : This is a problem!
> 
> # warning does match so causes a failure:
> try(expect_no_warning(foo(), message = "problem"))
Error : Expected `foo()` to run without any warnings matching pattern 'problem'.
â„¹ Actually got a <simpleWarning> with text:
  This is a problem!
> 
> 
> 
> cleanEx()
> nameEx("expect_null")
> ### * expect_null
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_null
> ### Title: Does code return 'NULL'?
> ### Aliases: expect_null
> 
> ### ** Examples
> 
> x <- NULL
> y <- 10
> 
> expect_null(x)
> show_failure(expect_null(y))
Failed expectation:
`y` is not NULL

`actual` is a double vector (10)
`expected` is NULL
> 
> 
> 
> cleanEx()
> nameEx("expect_output")
> ### * expect_output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_output
> ### Title: Does code print output to the console?
> ### Aliases: expect_output
> 
> ### ** Examples
> 
> str(mtcars)
'data.frame':	32 obs. of  11 variables:
 $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
 $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
 $ disp: num  160 160 108 258 360 ...
 $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
 $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
 $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
 $ qsec: num  16.5 17 18.6 19.4 17 ...
 $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
 $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
 $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
 $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
> expect_output(str(mtcars), "32 obs")
> expect_output(str(mtcars), "11 variables")
> 
> # You can use the arguments of grepl to control the matching
> expect_output(str(mtcars), "11 VARIABLES", ignore.case = TRUE)
> expect_output(str(mtcars), "$ mpg", fixed = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("expect_setequal")
> ### * expect_setequal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_setequal
> ### Title: Does code return a vector containing the expected values?
> ### Aliases: expect_setequal expect_mapequal expect_contains expect_in
> 
> ### ** Examples
> 
> expect_setequal(letters, rev(letters))
> show_failure(expect_setequal(letters[-1], rev(letters)))
Failed expectation:
letters[-1] (`actual`) and rev(letters) (`expected`) don't have the same values.
* Only in `expected`: "a"

> 
> x <- list(b = 2, a = 1)
> expect_mapequal(x, list(a = 1, b = 2))
> show_failure(expect_mapequal(x, list(a = 1)))
Failed expectation:
Names absent from `expected`: "b", 
> show_failure(expect_mapequal(x, list(a = 1, b = "x")))
Failed expectation:
act$val[exp_nms] (`actual`) not equal to exp$val (`expected`).

`actual$b` is a double vector (2)
`expected$b` is a character vector ('x')
> show_failure(expect_mapequal(x, list(a = 1, b = 2, c = 3)))
Failed expectation:
Names absent from `object`: "c", 
> 
> 
> 
> cleanEx()
> nameEx("expect_silent")
> ### * expect_silent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_silent
> ### Title: Does code execute silently?
> ### Aliases: expect_silent
> 
> ### ** Examples
> 
> expect_silent("123")
> 
> f <- function() {
+   message("Hi!")
+   warning("Hey!!")
+   print("OY!!!")
+ }
> ## Not run: 
> ##D expect_silent(f())
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expect_snapshot_file")
> ### * expect_snapshot_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_snapshot_file
> ### Title: Snapshot testing for whole files
> ### Aliases: expect_snapshot_file announce_snapshot_file
> ###   compare_file_binary compare_file_text
> 
> ### ** Examples
> 
> 
> # To use expect_snapshot_file() you'll typically need to start by writing
> # a helper function that creates a file from your code, returning a path
> save_png <- function(code, width = 400, height = 400) {
+   path <- tempfile(fileext = ".png")
+   png(path, width = width, height = height)
+   on.exit(dev.off())
+   code
+ 
+   path
+ }
> path <- save_png(plot(1:5))
> path
[1] "/tmp/RtmpoNRFor/file1668d19a34734.png"
> 
> ## Not run: 
> ##D expect_snapshot_file(save_png(hist(mtcars$mpg)), "plot.png")
> ## End(Not run)
> 
> # You'd then also provide a helper that skips tests where you can't
> # be sure of producing exactly the same output
> expect_snapshot_plot <- function(name, code) {
+   # Other packages might affect results
+   skip_if_not_installed("ggplot2", "2.0.0")
+   # Or maybe the output is different on some operation systems
+   skip_on_os("windows")
+   # You'll need to carefully think about and experiment with these skips
+ 
+   name <- paste0(name, ".png")
+ 
+   # Announce the file before touching `code`. This way, if `code`
+   # unexpectedly fails or skips, testthat will not auto-delete the
+   # corresponding snapshot file.
+   announce_snapshot_file(name = name)
+ 
+   path <- save_png(code)
+   expect_snapshot_file(path, name)
+ }
> 
> 
> 
> cleanEx()
> nameEx("expect_that")
> ### * expect_that
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_that
> ### Title: Expect that a condition holds.
> ### Aliases: expect_that
> ### Keywords: internal
> 
> ### ** Examples
> 
> expect_that(5 * 2, equals(10))
Warning: `expect_that()` was deprecated in the 3rd edition.
> expect_that(sqrt(2) ^ 2, equals(2))
Warning: `expect_that()` was deprecated in the 3rd edition.
> ## Not run: 
> ##D expect_that(sqrt(2) ^ 2, is_identical_to(2))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expect_vector")
> ### * expect_vector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_vector
> ### Title: Does code return a vector with the expected size and/or
> ###   prototype?
> ### Aliases: expect_vector
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("vctrs")) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ expect_vector(1:10, ptype = integer(), size = 10)
+ show_failure(expect_vector(1:10, ptype = integer(), size = 5))
+ show_failure(expect_vector(1:10, ptype = character(), size = 5))
+ ## Don't show: 
+ }) # examplesIf
> expect_vector(1:10, ptype = integer(), size = 10)
> show_failure(expect_vector(1:10, ptype = integer(), size = 5))
Failed expectation:
`1:10` must have size 5, not size 10.
> show_failure(expect_vector(1:10, ptype = character(), size = 5))
Failed expectation:
`1:10` must be a vector with type <character>.
Instead, it has type <integer>.
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("fail")
> ### * fail
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fail
> ### Title: Default expectations that always succeed or fail.
> ### Aliases: fail succeed
> 
> ### ** Examples
> 
> ## Not run: 
> ##D test_that("this test fails", fail())
> ##D test_that("this test succeeds", succeed())
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("inheritance-expectations")
> ### * inheritance-expectations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inheritance-expectations
> ### Title: Does code return an object inheriting from the expected base
> ###   type, S3 class, or S4 class?
> ### Aliases: inheritance-expectations expect_type expect_s3_class
> ###   expect_s7_class expect_s4_class
> 
> ### ** Examples
> 
> x <- data.frame(x = 1:10, y = "x", stringsAsFactors = TRUE)
> # A data frame is an S3 object with class data.frame
> expect_s3_class(x, "data.frame")
> show_failure(expect_s4_class(x, "data.frame"))
Failed expectation:
`x` is not an S4 object
> # A data frame is built from a list:
> expect_type(x, "list")
> 
> # An integer vector is an atomic vector of type "integer"
> expect_type(x$x, "integer")
> # It is not an S3 object
> show_failure(expect_s3_class(x$x, "integer"))
Failed expectation:
x$x is not an S3 object
> 
> # Above, we requested data.frame() converts strings to factors:
> show_failure(expect_type(x$y, "character"))
Failed expectation:
x$y has type 'integer', not 'character'.
> expect_s3_class(x$y, "factor")
> expect_type(x$y, "integer")
> 
> 
> 
> cleanEx()
> nameEx("local_test_context")
> ### * local_test_context
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: local_test_context
> ### Title: Locally set options for maximal test reproducibility
> ### Aliases: local_test_context local_reproducible_output
> 
> ### ** Examples
> 
> local({
+   local_test_context()
+   cat(cli::col_blue("Text will not be colored"))
+   cat(cli::symbol$ellipsis)
+   cat("\n")
+ })
Text will not be colored...
> test_that("test ellipsis", {
+   local_reproducible_output(unicode = FALSE)
+   expect_equal(cli::symbol$ellipsis, "...")
+ 
+   local_reproducible_output(unicode = TRUE)
+   expect_equal(cli::symbol$ellipsis, "\u2026")
+ })
Test passed ðŸ˜€
> 
> 
> 
> cleanEx()
> nameEx("logical-expectations")
> ### * logical-expectations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logical-expectations
> ### Title: Does code return 'TRUE' or 'FALSE'?
> ### Aliases: logical-expectations expect_true expect_false
> 
> ### ** Examples
> 
> expect_true(2 == 2)
> # Failed expectations will throw an error
> ## Not run: 
> ##D expect_true(2 != 2)
> ## End(Not run)
> expect_true(!(2 != 2))
> # or better:
> expect_false(2 != 2)
> 
> a <- 1:3
> expect_true(length(a) == 3)
> # but better to use more specific expectation, if available
> expect_equal(length(a), 3)
> 
> 
> 
> cleanEx()
> nameEx("make_expectation")
> ### * make_expectation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_expectation
> ### Title: Make an equality test.
> ### Aliases: make_expectation
> ### Keywords: internal
> 
> ### ** Examples
> 
> x <- 1:10
> make_expectation(x)
expect_equal(x, 1:10)
> 
> make_expectation(mtcars$mpg)
expect_equal(mtcars$mpg, c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 
24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, 
30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8, 
19.7, 15, 21.4))
> 
> df <- data.frame(x = 2)
> make_expectation(df)
expect_equal(df, structure(list(x = 2), class = "data.frame", row.names = c(NA, 
-1L)))
> 
> 
> 
> cleanEx()
> nameEx("quasi_label")
> ### * quasi_label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quasi_label
> ### Title: Quasi-labelling
> ### Aliases: quasi_label
> ### Keywords: internal
> 
> ### ** Examples
> 
> f <- function(i) if (i > 3) i * 9 else i * 10
> i <- 10
> 
> # This sort of expression commonly occurs inside a for loop or function
> # And the failure isn't helpful because you can't see the value of i
> # that caused the problem:
> show_failure(expect_equal(f(i), i * 10))
Failed expectation:
f(i) (`actual`) not equal to i * 10 (`expected`).

  `actual`:  90.0
`expected`: 100.0
> 
> # To overcome this issue, testthat allows you to unquote expressions using
> # !!. This causes the failure message to show the value rather than the
> # variable name
> show_failure(expect_equal(f(!!i), !!(i * 10)))
Failed expectation:
f(10) (`actual`) not equal to 100 (`expected`).

  `actual`:  90.0
`expected`: 100.0
> 
> 
> 
> cleanEx()
> nameEx("skip")
> ### * skip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: skip
> ### Title: Skip a test
> ### Aliases: skip skip_if_not skip_if skip_if_not_installed skip_if_offline
> ###   skip_on_cran skip_on_os skip_on_ci skip_on_covr skip_on_bioc
> ###   skip_if_translated
> 
> ### ** Examples
> 
> if (FALSE) skip("Some Important Requirement is not available")
> 
> test_that("skip example", {
+   expect_equal(1, 1L)    # this expectation runs
+   skip('skip')
+   expect_equal(1, 2)     # this one skipped
+   expect_equal(1, 3)     # this one is also skipped
+ })
â”€â”€ Skip: skip example â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Reason: skip

> 
> 
> 
> cleanEx()
> nameEx("teardown")
> ### * teardown
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: teardown
> ### Title: Run code before/after tests
> ### Aliases: teardown setup
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Old approach
> ##D tmp <- tempfile()
> ##D setup(writeLines("some test data", tmp))
> ##D teardown(unlink(tmp))
> ## End(Not run)
> 
> # Now recommended:
> local_test_data <- function(env = parent.frame()) {
+   tmp <- tempfile()
+   writeLines("some test data", tmp)
+   withr::defer(unlink(tmp), env)
+ 
+   tmp
+ }
> # Then call local_test_data() in your tests
> 
> 
> 
> cleanEx()
> nameEx("test_file")
> ### * test_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test_file
> ### Title: Run tests in a single file
> ### Aliases: test_file
> 
> ### ** Examples
> 
> path <- testthat_example("success")
> test_file(path)

â•â• Testing test-success.R â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]
[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
[ FAIL 0 | WARN 0 | SKIP 1 | PASS 1 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 1 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 2 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 3 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 4 ]

â”€â”€ Warning ('test-success.R:10:3'): some tests have warnings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NaNs produced
Backtrace:
    â–†
 1. â””â”€testthat::expect_equal(log(-1), NaN) at test-success.R:10:3
 2.   â””â”€testthat::quasi_label(enquo(object), label, arg = "object")
 3.     â””â”€rlang::eval_bare(expr, quo_get_env(quo))

â”€â”€ Skipped tests (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ This test hasn't been written yet (1): 'test-success.R:6:3'


[ FAIL 0 | WARN 1 | SKIP 1 | PASS 4 ]
> test_file(path, desc = "some tests have warnings")

â•â• Testing test-success.R â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]
[ FAIL 0 | WARN 1 | SKIP 0 | PASS 0 ]
[ FAIL 0 | WARN 1 | SKIP 0 | PASS 1 ]

â”€â”€ Warning ('test-success.R:10:3'): some tests have warnings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NaNs produced
Backtrace:
    â–†
 1. â””â”€testthat::expect_equal(log(-1), NaN) at test-success.R:10:3
 2.   â””â”€testthat::quasi_label(enquo(object), label, arg = "object")
 3.     â””â”€rlang::eval_bare(expr, quo_get_env(quo))

[ FAIL 0 | WARN 1 | SKIP 0 | PASS 1 ]
> test_file(path, reporter = "minimal")
.SW...
> 
> 
> 
> cleanEx()
> nameEx("test_path")
> ### * test_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test_path
> ### Title: Locate a file in the testing directory
> ### Aliases: test_path
> 
> ### ** Examples
> 
> ## Not run: 
> ##D test_path("foo.csv")
> ##D test_path("data", "foo.csv")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("test_that")
> ### * test_that
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test_that
> ### Title: Run a test
> ### Aliases: test_that
> 
> ### ** Examples
> 
> test_that("trigonometric functions match identities", {
+   expect_equal(sin(pi / 4), 1 / sqrt(2))
+   expect_equal(cos(pi / 4), 1 / sqrt(2))
+   expect_equal(tan(pi / 4), 1)
+ })
Test passed ðŸ˜€
> 
> ## Not run: 
> ##D test_that("trigonometric functions match identities", {
> ##D   expect_equal(sin(pi / 4), 1)
> ##D })
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("testthat_examples")
> ### * testthat_examples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: testthat_examples
> ### Title: Retrieve paths to built-in example test files
> ### Aliases: testthat_examples testthat_example
> ### Keywords: internal
> 
> ### ** Examples
> 
> dir(testthat_examples())
[1] "_snaps"         "test-failure.R" "test-success.R"
> testthat_example("success")
[1] "/usr/local/lib/R/site-library/testthat/examples/test-success.R"
> 
> 
> 
> cleanEx()
> nameEx("try_again")
> ### * try_again
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: try_again
> ### Title: Try evaluating an expressing multiple times until it succeeds.
> ### Aliases: try_again
> ### Keywords: internal
> 
> ### ** Examples
> 
> third_try <- local({
+   i <- 3
+   function() {
+     i <<- i - 1
+     if (i > 0) fail(paste0("i is ", i))
+   }
+ })
> try_again(3, third_try())
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.263 0.092 1.354 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
