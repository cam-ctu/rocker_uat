
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "googledrive"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('googledrive')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("as_dribble")
> ### * as_dribble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_dribble
> ### Title: Coerce to a 'dribble'
> ### Aliases: as_dribble
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # create some files for us to re-discover by name or filepath
+ alfa <- drive_create("alfa", type = "folder")
+ bravo <- drive_create("bravo", path = alfa)
+ 
+ # as_dribble() can work with file names or paths
+ as_dribble("alfa")
+ as_dribble("bravo")
+ as_dribble("alfa/bravo")
+ as_dribble(c("alfa", "alfa/bravo"))
+ 
+ # specify the file id (substitute a real file id of your own!)
+ # as_dribble(as_id("0B0Gh-SuuA2nTOGZVTXZTREgwZ2M"))
+ 
+ # Clean up
+ drive_find("alfa") %>% drive_rm()
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("as_shared_drive")
> ### * as_shared_drive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_shared_drive
> ### Title: Coerce to shared drive
> ### Aliases: as_shared_drive
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # specify the name
> ##D as_shared_drive("abc")
> ##D 
> ##D # specify the id (substitute one of your own!)
> ##D as_shared_drive(as_id("0AOPK1X2jaNckUk9PVA"))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("dribble-checks")
> ### * dribble-checks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dribble-checks
> ### Title: Check facts about a dribble
> ### Aliases: dribble-checks is_dribble no_file single_file some_files
> ###   confirm_dribble confirm_single_file confirm_some_files is_folder
> ###   is_shortcut is_folder_shortcut is_native is_parental is_mine
> ###   is_shared_drive
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ ## most of us have multiple files or folders on Google Drive
+ d <- drive_find()
+ is_dribble(d)
+ no_file(d)
+ single_file(d)
+ some_files(d)
+ 
+ # this will error
+ # confirm_single_file(d)
+ 
+ confirm_some_files(d)
+ is_folder(d)
+ is_mine(d)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_about")
> ### * drive_about
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_about
> ### Title: Get info on Drive capabilities
> ### Aliases: drive_about
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ drive_about()
+ 
+ # explore the export formats available for Drive files, by MIME type
+ about <- drive_about()
+ about[["exportFormats"]] %>%
+   purrr::map(unlist)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_auth")
> ### * drive_auth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_auth
> ### Title: Authorize googledrive
> ### Aliases: drive_auth
> 
> ### ** Examples
> 
> ## Don't show: 
> if (rlang::is_interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # load/refresh existing credentials, if available
+ # otherwise, go to browser for authentication and authorization
+ drive_auth()
+ 
+ # see user associated with current token
+ drive_user()
+ 
+ # force use of a token associated with a specific email
+ drive_auth(email = "jenny@example.com")
+ drive_user()
+ 
+ # force the OAuth web dance
+ drive_auth(email = NA)
+ 
+ # use a 'read only' scope, so it's impossible to edit or delete files
+ drive_auth(scopes = "drive.readonly")
+ 
+ # use a service account token
+ drive_auth(path = "foofy-83ee9e7c9c48.json")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_auth_configure")
> ### * drive_auth_configure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_auth_configure
> ### Title: Edit and view auth configuration
> ### Aliases: drive_auth_configure drive_api_key drive_oauth_client
> 
> ### ** Examples
> 
> # see and store the current user-configured OAuth client (probaby `NULL`)
> (original_client <- drive_oauth_client())
NULL
> 
> # see and store the current user-configured API key (probaby `NULL`)
> (original_api_key <- drive_api_key())
NULL
> 
> # the preferred way to configure your own client is via a JSON file
> # downloaded from Google Developers Console
> # this example JSON is indicative, but fake
> path_to_json <- system.file(
+   "extdata", "client_secret_installed.googleusercontent.com.json",
+   package = "gargle"
+ )
> drive_auth_configure(path = path_to_json)
> 
> # this is also obviously a fake API key
> drive_auth_configure(api_key = "the_key_I_got_for_a_google_API")
> 
> # confirm the changes
> drive_oauth_client()
<gargle_oauth_client>
name: a_project_d1c5a8066d2cbe48e8d94514dd286163
id: abc.apps.googleusercontent.com
secret: <REDACTED>
type: installed
redirect_uris: http://localhost
> drive_api_key()
[1] "the_key_I_got_for_a_google_API"
> 
> # restore original auth config
> drive_auth_configure(client = original_client, api_key = original_api_key)
> 
> 
> 
> cleanEx()
> nameEx("drive_browse")
> ### * drive_browse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_browse
> ### Title: Visit Drive file in browser
> ### Aliases: drive_browse
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token() && rlang::is_interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ drive_find(n_max = 1) %>% drive_browse()
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_cp")
> ### * drive_cp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_cp
> ### Title: Copy a Drive file
> ### Aliases: drive_cp
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Target one of the official example files
+ (src_file <- drive_example_remote("chicken.txt"))
+ 
+ # Make a "Copy of" copy in your My Drive
+ cp1 <- drive_cp(src_file)
+ 
+ # Make an explicitly named copy, in a different folder, and star it.
+ # The starring is an example of providing metadata via `...`.
+ # `starred` is not an actual argument to `drive_cp()`,
+ # it just gets passed through to the API.
+ folder <- drive_mkdir("drive-cp-folder")
+ cp2 <- drive_cp(
+   src_file,
+   path = folder,
+   name = "chicken-cp.txt",
+   starred = TRUE
+ )
+ drive_reveal(cp2, "starred")
+ 
+ # `overwrite = FALSE` errors if file already exists at target filepath
+ # THIS WILL ERROR!
+ # drive_cp(src_file, name = "Copy of chicken.txt", overwrite = FALSE)
+ 
+ # `overwrite = TRUE` moves an existing file to trash, then proceeds
+ cp3 <- drive_cp(src_file, name = "Copy of chicken.txt", overwrite = TRUE)
+ 
+ # Delete all of our copies and the new folder!
+ drive_rm(cp1, cp2, cp3, folder)
+ 
+ # Target an official example file that's a csv file
+ (csv_file <- drive_example_remote("chicken.csv"))
+ 
+ # copy AND AT THE SAME TIME convert it to a Google Sheet
+ chicken_sheet <- drive_cp(
+   csv_file,
+   name = "chicken-sheet-copy",
+   mime_type = drive_mime_type("spreadsheet")
+ )
+ # is it really a Google Sheet?
+ drive_reveal(chicken_sheet, "mime_type")$mime_type
+ 
+ # go see the new Sheet in the browser
+ # drive_browse(chicken_sheet)
+ 
+ # Clean up
+ drive_rm(chicken_sheet)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_create")
> ### * drive_create
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_create
> ### Title: Create a new blank Drive file
> ### Aliases: drive_create
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Create a blank Google Doc named 'WordStar' in
+ # your 'My Drive' root folder and star it
+ wordstar <- drive_create("WordStar", type = "document", starred = TRUE)
+ 
+ # is 'WordStar' really starred? YES
+ purrr::pluck(wordstar, "drive_resource", 1, "starred")
+ 
+ # Create a blank Google Slides presentation in
+ # the root folder, and set its description
+ execuvision <- drive_create(
+   "ExecuVision",
+   type = "presentation",
+   description = "deeply nested bullet lists FTW"
+ )
+ 
+ # Did we really set the description? YES
+ purrr::pluck(execuvision, "drive_resource", 1, "description")
+ 
+ # check out the new presentation
+ drive_browse(execuvision)
+ 
+ # Create folder 'b4xl' in the root folder,
+ # then create an empty new Google Sheet in it
+ b4xl <- drive_mkdir("b4xl")
+ drive_create("VisiCalc", path = b4xl, type = "spreadsheet")
+ 
+ # Another way to create a Google Sheet in the folder 'b4xl'
+ drive_create("b4xl/SuperCalc", type = "spreadsheet")
+ 
+ # Yet another way to create a new file in a folder,
+ # this time specifying parent `path` as a character
+ drive_create("Lotus 1-2-3", path = "b4xl", type = "spreadsheet")
+ 
+ # Did we really create those Sheets in the intended folder? YES
+ drive_ls("b4xl")
+ 
+ # `overwrite = FALSE` errors if file already exists at target filepath
+ # THIS WILL ERROR!
+ drive_create("VisiCalc", path = b4xl, overwrite = FALSE)
+ 
+ # `overwrite = TRUE` moves an existing file to trash, then proceeds
+ drive_create("VisiCalc", path = b4xl, overwrite = TRUE)
+ 
+ # Clean up
+ drive_rm(wordstar, b4xl, execuvision)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_deauth")
> ### * drive_deauth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_deauth
> ### Title: Suspend authorization
> ### Aliases: drive_deauth
> 
> ### ** Examples
> 
> ## Don't show: 
> if (rlang::is_interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ drive_deauth()
+ drive_user()
+ 
+ # in a deauth'ed state, we can still get metadata on a world-readable file
+ public_file <- drive_example_remote("chicken.csv")
+ public_file
+ # we can still download it too
+ drive_download(public_file)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_download")
> ### * drive_download
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_download
> ### Title: Download a Drive file
> ### Aliases: drive_download
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Target one of the official example files
+ (src_file <- drive_example_remote("chicken_sheet"))
+ 
+ # Download Sheet as csv, explicit type
+ downloaded_file <- drive_download(src_file, type = "csv")
+ 
+ # See local path to new file
+ downloaded_file$local_path
+ 
+ # Download as csv, type implicit in file extension
+ drive_download(src_file, path = "my_csv_file.csv")
+ 
+ # Download with default name and type (xlsx)
+ drive_download(src_file)
+ 
+ # Clean up
+ unlink(c("chicken_sheet.csv", "chicken_sheet.xlsx", "my_csv_file.csv"))
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_endpoints")
> ### * drive_endpoints
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_endpoints
> ### Title: List Drive endpoints
> ### Aliases: drive_endpoints drive_endpoint
> 
> ### ** Examples
> 
> str(head(drive_endpoints(), 3), max.level = 2)
List of 3
 $ drive.about.get                :List of 7
  ..$ id         : chr "drive.about.get"
  ..$ httpMethod : chr "GET"
  ..$ path       : 'fs_path' chr "drive/v3/about"
  ..$ scopes     : chr "drive, drive.appdata, drive.file, drive.metadata, drive.metadata.readonly, drive.photos.readonly, drive.readonly"
  ..$ description: chr "Gets information about the user, the user's Drive, and system capabilities."
  ..$ response   : chr "About"
  ..$ parameters :List of 7
 $ drive.changes.getStartPageToken:List of 7
  ..$ id         : chr "drive.changes.getStartPageToken"
  ..$ httpMethod : chr "GET"
  ..$ path       : 'fs_path' chr "drive/v3/changes/startPageToken"
  ..$ parameters :List of 11
  ..$ scopes     : chr "drive, drive.appdata, drive.file, drive.metadata, drive.metadata.readonly, drive.photos.readonly, drive.readonly"
  ..$ description: chr "Gets the starting pageToken for listing future changes."
  ..$ response   : chr "StartPageToken"
 $ drive.changes.list             :List of 9
  ..$ id                  : chr "drive.changes.list"
  ..$ httpMethod          : chr "GET"
  ..$ path                : 'fs_path' chr "drive/v3/changes"
  ..$ parameters          :List of 20
  ..$ scopes              : chr "drive, drive.appdata, drive.file, drive.metadata, drive.metadata.readonly, drive.photos.readonly, drive.readonly"
  ..$ description         : chr "Lists the changes for a user or shared drive."
  ..$ response            : chr "ChangeList"
  ..$ parameterOrder      : chr "pageToken"
  ..$ supportsSubscription: logi TRUE
> drive_endpoint("drive.files.delete")
$id
[1] "drive.files.delete"

$httpMethod
[1] "DELETE"

$path
drive/v3/files/{fileId}

$parameters
$parameters$enforceSingleParent
$parameters$enforceSingleParent$type
[1] "boolean"

$parameters$enforceSingleParent$description
[1] "Deprecated. If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item will be placed under its owner's root."

$parameters$enforceSingleParent$default
[1] "false"

$parameters$enforceSingleParent$location
[1] "query"


$parameters$fileId
$parameters$fileId$type
[1] "string"

$parameters$fileId$description
[1] "The ID of the file."

$parameters$fileId$required
[1] TRUE

$parameters$fileId$location
[1] "path"


$parameters$supportsAllDrives
$parameters$supportsAllDrives$type
[1] "boolean"

$parameters$supportsAllDrives$description
[1] "Whether the requesting application supports both My Drives and shared drives."

$parameters$supportsAllDrives$default
[1] "false"

$parameters$supportsAllDrives$location
[1] "query"


$parameters$supportsTeamDrives
$parameters$supportsTeamDrives$type
[1] "boolean"

$parameters$supportsTeamDrives$description
[1] "Deprecated use supportsAllDrives instead."

$parameters$supportsTeamDrives$default
[1] "false"

$parameters$supportsTeamDrives$location
[1] "query"


$parameters$alt
$parameters$alt$type
[1] "string"

$parameters$alt$description
[1] "Data format for the response."

$parameters$alt$default
[1] "json"

$parameters$alt$enum
[1] "json"

$parameters$alt$enumDescriptions
[1] "Responses with Content-Type of application/json"

$parameters$alt$location
[1] "query"


$parameters$fields
$parameters$fields$type
[1] "string"

$parameters$fields$description
[1] "Selector specifying which fields to include in a partial response."

$parameters$fields$location
[1] "query"


$parameters$key
$parameters$key$type
[1] "string"

$parameters$key$description
[1] "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."

$parameters$key$location
[1] "query"


$parameters$oauth_token
$parameters$oauth_token$type
[1] "string"

$parameters$oauth_token$description
[1] "OAuth 2.0 token for the current user."

$parameters$oauth_token$location
[1] "query"


$parameters$prettyPrint
$parameters$prettyPrint$type
[1] "boolean"

$parameters$prettyPrint$description
[1] "Returns response with indentations and line breaks."

$parameters$prettyPrint$default
[1] "true"

$parameters$prettyPrint$location
[1] "query"


$parameters$quotaUser
$parameters$quotaUser$type
[1] "string"

$parameters$quotaUser$description
[1] "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."

$parameters$quotaUser$location
[1] "query"


$parameters$userIp
$parameters$userIp$type
[1] "string"

$parameters$userIp$description
[1] "Deprecated. Please use quotaUser instead."

$parameters$userIp$location
[1] "query"



$scopes
[1] "drive, drive.appdata, drive.file"

$description
[1] "Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive the user must be an organizer on the parent. If the target is a folder, all descendants owned by the user are also deleted."

$parameterOrder
[1] "fileId"

> drive_endpoint(4)
$id
[1] "drive.changes.watch"

$httpMethod
[1] "POST"

$path
drive/v3/changes/watch

$parameters
$parameters$driveId
$parameters$driveId$type
[1] "string"

$parameters$driveId$description
[1] "The shared drive from which changes are returned. If specified the change IDs will be reflective of the shared drive; use the combined drive ID and change ID as an identifier."

$parameters$driveId$location
[1] "query"


$parameters$includeCorpusRemovals
$parameters$includeCorpusRemovals$type
[1] "boolean"

$parameters$includeCorpusRemovals$description
[1] "Whether changes should include the file resource if the file is still accessible by the user at the time of the request, even when a file was removed from the list of changes and there will be no further change entries for this file."

$parameters$includeCorpusRemovals$default
[1] "false"

$parameters$includeCorpusRemovals$location
[1] "query"


$parameters$includeItemsFromAllDrives
$parameters$includeItemsFromAllDrives$type
[1] "boolean"

$parameters$includeItemsFromAllDrives$description
[1] "Whether both My Drive and shared drive items should be included in results."

$parameters$includeItemsFromAllDrives$default
[1] "false"

$parameters$includeItemsFromAllDrives$location
[1] "query"


$parameters$includePermissionsForView
$parameters$includePermissionsForView$type
[1] "string"

$parameters$includePermissionsForView$description
[1] "Specifies which additional view's permissions to include in the response. Only 'published' is supported."

$parameters$includePermissionsForView$location
[1] "query"


$parameters$includeRemoved
$parameters$includeRemoved$type
[1] "boolean"

$parameters$includeRemoved$description
[1] "Whether to include changes indicating that items have been removed from the list of changes, for example by deletion or loss of access."

$parameters$includeRemoved$default
[1] "true"

$parameters$includeRemoved$location
[1] "query"


$parameters$includeTeamDriveItems
$parameters$includeTeamDriveItems$type
[1] "boolean"

$parameters$includeTeamDriveItems$description
[1] "Deprecated use includeItemsFromAllDrives instead."

$parameters$includeTeamDriveItems$default
[1] "false"

$parameters$includeTeamDriveItems$location
[1] "query"


$parameters$pageSize
$parameters$pageSize$type
[1] "integer"

$parameters$pageSize$description
[1] "The maximum number of changes to return per page."

$parameters$pageSize$default
[1] "100"

$parameters$pageSize$format
[1] "int32"

$parameters$pageSize$minimum
[1] "1"

$parameters$pageSize$maximum
[1] "1000"

$parameters$pageSize$location
[1] "query"


$parameters$pageToken
$parameters$pageToken$type
[1] "string"

$parameters$pageToken$description
[1] "The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response or to the response from the getStartPageToken method."

$parameters$pageToken$required
[1] TRUE

$parameters$pageToken$location
[1] "query"


$parameters$restrictToMyDrive
$parameters$restrictToMyDrive$type
[1] "boolean"

$parameters$restrictToMyDrive$description
[1] "Whether to restrict the results to changes inside the My Drive hierarchy. This omits changes to files such as those in the Application Data folder or shared files which have not been added to My Drive."

$parameters$restrictToMyDrive$default
[1] "false"

$parameters$restrictToMyDrive$location
[1] "query"


$parameters$spaces
$parameters$spaces$type
[1] "string"

$parameters$spaces$description
[1] "A comma-separated list of spaces to query within the user corpus. Supported values are 'drive', 'appDataFolder' and 'photos'."

$parameters$spaces$default
[1] "drive"

$parameters$spaces$location
[1] "query"


$parameters$supportsAllDrives
$parameters$supportsAllDrives$type
[1] "boolean"

$parameters$supportsAllDrives$description
[1] "Whether the requesting application supports both My Drives and shared drives."

$parameters$supportsAllDrives$default
[1] "false"

$parameters$supportsAllDrives$location
[1] "query"


$parameters$supportsTeamDrives
$parameters$supportsTeamDrives$type
[1] "boolean"

$parameters$supportsTeamDrives$description
[1] "Deprecated use supportsAllDrives instead."

$parameters$supportsTeamDrives$default
[1] "false"

$parameters$supportsTeamDrives$location
[1] "query"


$parameters$teamDriveId
$parameters$teamDriveId$type
[1] "string"

$parameters$teamDriveId$description
[1] "Deprecated use driveId instead."

$parameters$teamDriveId$location
[1] "query"


$parameters$address
$parameters$address$type
[1] "string"

$parameters$address$description
[1] "The address where notifications are delivered for this channel."

$parameters$address$location
[1] "body"


$parameters$expiration
$parameters$expiration$type
[1] "string"

$parameters$expiration$description
[1] "Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional."

$parameters$expiration$format
[1] "int64"

$parameters$expiration$location
[1] "body"


$parameters$id
$parameters$id$type
[1] "string"

$parameters$id$description
[1] "A UUID or similar unique string that identifies this channel."

$parameters$id$location
[1] "body"


$parameters$kind
$parameters$kind$type
[1] "string"

$parameters$kind$description
[1] "Identifies this as a notification channel used to watch for changes to a resource, which is \"api#channel\"."

$parameters$kind$default
[1] "api#channel"

$parameters$kind$location
[1] "body"


$parameters$params
$parameters$params$type
[1] "object"

$parameters$params$description
[1] "Additional parameters controlling delivery channel behavior. Optional."

$parameters$params$additionalProperties
$parameters$params$additionalProperties$type
[1] "string"

$parameters$params$additionalProperties$description
[1] "Declares a new parameter by name."


$parameters$params$location
[1] "body"


$parameters$payload
$parameters$payload$type
[1] "boolean"

$parameters$payload$description
[1] "A Boolean value to indicate whether payload is wanted. Optional."

$parameters$payload$location
[1] "body"


$parameters$resourceId
$parameters$resourceId$type
[1] "string"

$parameters$resourceId$description
[1] "An opaque ID that identifies the resource being watched on this channel. Stable across different API versions."

$parameters$resourceId$location
[1] "body"


$parameters$resourceUri
$parameters$resourceUri$type
[1] "string"

$parameters$resourceUri$description
[1] "A version-specific identifier for the watched resource."

$parameters$resourceUri$location
[1] "body"


$parameters$token
$parameters$token$type
[1] "string"

$parameters$token$description
[1] "An arbitrary string delivered to the target address with each notification delivered over this channel. Optional."

$parameters$token$location
[1] "body"


$parameters$type
$parameters$type$type
[1] "string"

$parameters$type$description
[1] "The type of delivery mechanism used for this channel. Valid values are \"web_hook\" (or \"webhook\"). Both values refer to a channel where Http requests are used to deliver messages."

$parameters$type$location
[1] "body"


$parameters$alt
$parameters$alt$type
[1] "string"

$parameters$alt$description
[1] "Data format for the response."

$parameters$alt$default
[1] "json"

$parameters$alt$enum
[1] "json"

$parameters$alt$enumDescriptions
[1] "Responses with Content-Type of application/json"

$parameters$alt$location
[1] "query"


$parameters$fields
$parameters$fields$type
[1] "string"

$parameters$fields$description
[1] "Selector specifying which fields to include in a partial response."

$parameters$fields$location
[1] "query"


$parameters$key
$parameters$key$type
[1] "string"

$parameters$key$description
[1] "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."

$parameters$key$location
[1] "query"


$parameters$oauth_token
$parameters$oauth_token$type
[1] "string"

$parameters$oauth_token$description
[1] "OAuth 2.0 token for the current user."

$parameters$oauth_token$location
[1] "query"


$parameters$prettyPrint
$parameters$prettyPrint$type
[1] "boolean"

$parameters$prettyPrint$description
[1] "Returns response with indentations and line breaks."

$parameters$prettyPrint$default
[1] "true"

$parameters$prettyPrint$location
[1] "query"


$parameters$quotaUser
$parameters$quotaUser$type
[1] "string"

$parameters$quotaUser$description
[1] "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."

$parameters$quotaUser$location
[1] "query"


$parameters$userIp
$parameters$userIp$type
[1] "string"

$parameters$userIp$description
[1] "Deprecated. Please use quotaUser instead."

$parameters$userIp$location
[1] "query"



$scopes
[1] "drive, drive.appdata, drive.file, drive.metadata, drive.metadata.readonly, drive.photos.readonly, drive.readonly"

$description
[1] "Subscribes to changes for a user."

$request
[1] "Channel"

$response
[1] "Channel"

$parameterOrder
[1] "pageToken"

$supportsSubscription
[1] TRUE

> 
> 
> 
> cleanEx()
> nameEx("drive_examples")
> ### * drive_examples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_examples
> ### Title: Example files
> ### Aliases: drive_examples drive_examples_local drive_examples_remote
> ###   drive_example_local drive_example_remote
> 
> ### ** Examples
> 
> drive_examples_local() %>% basename()
[1] "chicken.csv"     "chicken.jpg"     "chicken.pdf"     "chicken.txt"    
[5] "imdb_latin1.csv" "r_about.html"    "r_logo.jpg"     
> drive_examples_local("chicken") %>% basename()
[1] "chicken.csv" "chicken.jpg" "chicken.pdf" "chicken.txt"
> drive_example_local("imdb")
[1] "/usr/local/lib/R/site-library/googledrive/extdata/example_files/imdb_latin1.csv"
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ drive_examples_remote()
+ drive_examples_remote("chicken")
+ drive_example_remote("chicken_doc")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_extension")
> ### * drive_extension
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_extension
> ### Title: Lookup extension from MIME type
> ### Aliases: drive_extension
> 
> ### ** Examples
> 
> 
> ## get the extension for mime type image/jpeg
> drive_extension("image/jpeg")
[1] "jpeg"
> 
> ## it's vectorized
> drive_extension(c("text/plain", "pdf", "image/gif"))
[1] "txt" "pdf" "gif"
> 
> 
> 
> cleanEx()
> nameEx("drive_fields")
> ### * drive_fields
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_fields
> ### Title: Request partial resources
> ### Aliases: drive_fields prep_fields
> 
> ### ** Examples
> 
> # get a tibble of all fields for the Files resource + indicator of defaults
> drive_fields(expose())
# A tibble: 55 × 2
   name                         desc                                            
   <chr>                        <chr>                                           
 1 appProperties                "A collection of arbitrary key-value pairs whic…
 2 capabilities                 "Capabilities the current user has on this file…
 3 contentHints                 "Additional information about the content of th…
 4 copyRequiresWriterPermission "Whether the options to copy, print, or downloa…
 5 createdTime                  "The time at which the file was created (RFC 33…
 6 description                  "A short description of the file."              
 7 driveId                      "ID of the shared drive the file resides in. On…
 8 explicitlyTrashed            "Whether the file has been explicitly trashed, …
 9 exportLinks                  "Links for exporting Google Docs to specific fo…
10 fileExtension                "The final component of fullFileExtension. This…
# ℹ 45 more rows
> 
> # invalid fields are removed and throw warning
> drive_fields(c("name", "parents", "ownedByMe", "pancakes!"))
Warning: Omitting fields that are not recognized as part of the Files resource:
• 'pancakes!'
[1] "name"      "parents"   "ownedByMe"
> 
> # prepare fields for query
> prep_fields(c("name", "parents", "kind"))
[1] "files/name,files/parents,files/kind"
> 
> 
> 
> cleanEx()
> nameEx("drive_find")
> ### * drive_find
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_find
> ### Title: Find files on Google Drive
> ### Aliases: drive_find
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # list "My Drive" w/o regard for folder hierarchy
> ##D drive_find()
> ##D 
> ##D # filter for folders, the easy way and the hard way
> ##D drive_find(type = "folder")
> ##D drive_find(q = "mimeType = 'application/vnd.google-apps.folder'")
> ##D 
> ##D # filter for Google Sheets, the easy way and the hard way
> ##D drive_find(type = "spreadsheet")
> ##D drive_find(q = "mimeType='application/vnd.google-apps.spreadsheet'")
> ##D 
> ##D # files whose names match a regex
> ##D # the local, general, sometimes-slow-to-execute version
> ##D drive_find(pattern = "ick")
> ##D # the server-side, executes-faster version
> ##D # NOTE: works only for a pattern at the beginning of file name
> ##D drive_find(q = "name contains 'chick'")
> ##D 
> ##D # search for files located directly in your root folder
> ##D drive_find(q = "'root' in parents")
> ##D # FYI: this is equivalent to
> ##D drive_ls("~/")
> ##D 
> ##D # control page size or cap the number of files returned
> ##D drive_find(pageSize = 50)
> ##D # all params passed through `...` can be camelCase or snake_case
> ##D drive_find(page_size = 50)
> ##D drive_find(n_max = 58)
> ##D drive_find(page_size = 5, n_max = 15)
> ##D 
> ##D # various ways to specify q search clauses
> ##D # multiple q's
> ##D drive_find(
> ##D   q = "name contains 'TEST'",
> ##D   q = "modifiedTime > '2020-07-21T12:00:00'"
> ##D )
> ##D # vector q
> ##D drive_find(q = c("starred = true", "visibility = 'anyoneWithLink'"))
> ##D 
> ##D # default `trashed = FALSE` excludes files in the trash
> ##D # `trashed = TRUE` consults ONLY file in the trash
> ##D drive_find(trashed = TRUE)
> ##D # `trashed = NA` disregards trash status completely
> ##D drive_find(trashed = NA)
> ##D 
> ##D # suppress the default sorting on recency
> ##D drive_find(order_by = NULL, n_max = 5)
> ##D 
> ##D # sort on various keys
> ##D drive_find(order_by = "modifiedByMeTime", n_max = 5)
> ##D # request descending order
> ##D drive_find(order_by = "quotaBytesUsed desc", n_max = 5)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("drive_get")
> ### * drive_get
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_get
> ### Title: Get Drive files by path or id
> ### Aliases: drive_get
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # get info about your "My Drive" root folder
+ drive_get("~/")
+ # the API reserves the file id "root" for your root folder
+ drive_get(id = "root")
+ drive_get(id = "root") %>% drive_reveal("path")
+ 
+ # set up some files to get by path
+ alfalfa <- drive_mkdir("alfalfa")
+ broccoli <- drive_upload(
+   drive_example_local("chicken.txt"),
+   name = "broccoli", path = alfalfa
+ )
+ drive_get("broccoli")
+ drive_get("alfalfa/broccoli")
+ drive_get("~/alfalfa/broccoli")
+ drive_get(c("broccoli", "alfalfa/", "~/alfalfa/broccoli"))
+ 
+ # Clean up
+ drive_rm(alfalfa)
+ 
+ ## Not run: 
+ ##D # The examples below are indicative of correct syntax.
+ ##D # But note these will generally result in an error or a
+ ##D # 0-row dribble, unless you replace the inputs with paths
+ ##D # or file ids that exist in your Drive.
+ ##D 
+ ##D # multiple names
+ ##D drive_get(c("abc", "def"))
+ ##D 
+ ##D # multiple names, one of which must be a folder
+ ##D drive_get(c("abc", "def/"))
+ ##D 
+ ##D # query by file id(s)
+ ##D drive_get(id = "abcdefgeh123456789")
+ ##D drive_get(as_id("abcdefgeh123456789"))
+ ##D drive_get(id = c("abcdefgh123456789", "jklmnopq123456789"))
+ ##D 
+ ##D # apply to a browser URL for, e.g., a Google Sheet
+ ##D my_url <- "https://docs.google.com/spreadsheets/d/FILE_ID/edit#gid=SHEET_ID"
+ ##D drive_get(my_url)
+ ##D drive_get(as_id(my_url))
+ ##D drive_get(id = my_url)
+ ##D 
+ ##D # access the shared drive named "foo"
+ ##D # shared_drive params must be specified if getting by path
+ ##D foo <- shared_drive_get("foo")
+ ##D drive_get(c("this.jpg", "that-file"), shared_drive = foo)
+ ##D # shared_drive params are not necessary if getting by id
+ ##D drive_get(as_id("123456789"))
+ ##D 
+ ##D # search all shared drives and other files user has accessed
+ ##D drive_get(c("this.jpg", "that-file"), corpus = "allDrives")
+ ## End(Not run)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_has_token")
> ### * drive_has_token
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_has_token
> ### Title: Is there a token on hand?
> ### Aliases: drive_has_token
> 
> ### ** Examples
> 
> drive_has_token()
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("drive_id")
> ### * drive_id
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_id
> ### Title: 'drive_id' class
> ### Aliases: drive_id as_id
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ as_id("123abc")
+ as_id("https://docs.google.com/spreadsheets/d/qawsedrf16273849/edit#gid=12345")
+ 
+ x <- drive_find(n_max = 3)
+ as_id(x)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_link")
> ### * drive_link
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_link
> ### Title: Retrieve Drive file links
> ### Aliases: drive_link
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # get a few files into a dribble
+ three_files <- drive_find(n_max = 3)
+ 
+ # get their browser links
+ drive_link(three_files)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_ls")
> ### * drive_ls
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_ls
> ### Title: List contents of a folder or shared drive
> ### Aliases: drive_ls
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # get contents of the folder 'abc' (non-recursive)
> ##D drive_ls("abc")
> ##D 
> ##D # get contents of folder 'abc' whose names contain the letters 'def'
> ##D drive_ls(path = "abc", pattern = "def")
> ##D 
> ##D # get all Google spreadsheets in folder 'abc'
> ##D # whose names contain the letters 'def'
> ##D drive_ls(path = "abc", pattern = "def", type = "spreadsheet")
> ##D 
> ##D # get all the files below 'abc', recursively, that are starred
> ##D drive_ls(path = "abc", q = "starred = true", recursive = TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("drive_mime_type")
> ### * drive_mime_type
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_mime_type
> ### Title: Lookup MIME type
> ### Aliases: drive_mime_type
> 
> ### ** Examples
> 
> ## get the mime type for Google Spreadsheets
> drive_mime_type("spreadsheet")
[1] "application/vnd.google-apps.spreadsheet"
> 
> ## get the mime type for jpegs
> drive_mime_type("jpeg")
[1] "image/jpeg"
> 
> ## it's vectorized
> drive_mime_type(c("presentation", "pdf", "image/gif"))
[1] "application/vnd.google-apps.presentation"
[2] "application/pdf"                         
[3] "image/gif"                               
> 
> ## see the internal tibble of MIME types known to the Drive API
> drive_mime_type(expose())
# A tibble: 78 × 5
   mime_type                             ext   description    human_type default
   <chr>                                 <chr> <chr>          <chr>      <lgl>  
 1 application/epub+zip                  <NA>  <NA>           <NA>       NA     
 2 application/msword                    doc   <NA>           doc        TRUE   
 3 application/msword                    dot   <NA>           dot        FALSE  
 4 application/pdf                       pdf   <NA>           pdf        TRUE   
 5 application/rtf                       rtf   <NA>           rtf        TRUE   
 6 application/vnd.google-apps.audio     <NA>  <NA>           audio      NA     
 7 application/vnd.google-apps.document  <NA>  Google Docs    document   NA     
 8 application/vnd.google-apps.drawing   <NA>  Google Drawing drawing    NA     
 9 application/vnd.google-apps.drive-sdk <NA>  3rd party sho… drive-sdk  NA     
10 application/vnd.google-apps.file      <NA>  Google Drive … file       NA     
# ℹ 68 more rows
> 
> 
> 
> cleanEx()
> nameEx("drive_mkdir")
> ### * drive_mkdir
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_mkdir
> ### Title: Create a Drive folder
> ### Aliases: drive_mkdir
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Create folder named 'ghi', then another below named it 'jkl' and star it
+ ghi <- drive_mkdir("ghi")
+ jkl <- drive_mkdir("ghi/jkl", starred = TRUE)
+ 
+ # is 'jkl' really starred? YES
+ purrr::pluck(jkl, "drive_resource", 1, "starred")
+ 
+ # Another way to create folder 'mno' in folder 'ghi'
+ drive_mkdir("mno", path = "ghi")
+ 
+ # Yet another way to create a folder named 'pqr' in folder 'ghi',
+ # this time with parent folder stored in a dribble,
+ # and setting the new folder's description
+ pqr <- drive_mkdir("pqr", path = ghi, description = "I am a folder")
+ 
+ # Did we really set the description? YES
+ purrr::pluck(pqr, "drive_resource", 1, "description")
+ 
+ # `overwrite = FALSE` errors if something already exists at target filepath
+ # THIS WILL ERROR!
+ drive_create("name-squatter-mkdir", path = ghi)
+ drive_mkdir("name-squatter-mkdir", path = ghi, overwrite = FALSE)
+ 
+ # `overwrite = TRUE` moves the existing item to trash, then proceeds
+ drive_mkdir("name-squatter-mkdir", path = ghi, overwrite = TRUE)
+ 
+ # list everything inside 'ghi'
+ drive_ls("ghi")
+ 
+ # Clean up
+ drive_rm(ghi)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_mv")
> ### * drive_mv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_mv
> ### Title: Move a Drive file
> ### Aliases: drive_mv
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # create a file to move
+ file <- drive_example_remote("chicken.txt") %>%
+   drive_cp("chicken-mv.txt")
+ 
+ # rename it, but leave in current folder (root folder, in this case)
+ file <- drive_mv(file, "chicken-mv-renamed.txt")
+ 
+ # create a folder to move the file into
+ folder <- drive_mkdir("mv-folder")
+ 
+ # move the file and rename it again,
+ # specify destination as a dribble
+ file <- drive_mv(file, path = folder, name = "chicken-mv-re-renamed.txt")
+ 
+ # verify renamed file is now in the folder
+ drive_ls(folder)
+ 
+ # move the file back to root folder
+ file <- drive_mv(file, "~/")
+ 
+ # move it again
+ # specify destination as path with trailing slash
+ # to ensure we get a move vs. renaming it to "mv-folder"
+ file <- drive_mv(file, "mv-folder/")
+ 
+ # `overwrite = FALSE` errors if something already exists at target filepath
+ # THIS WILL ERROR!
+ drive_create("name-squatter-mv", path = "~/")
+ drive_mv(file, path = "~/", name = "name-squatter-mv", overwrite = FALSE)
+ 
+ # `overwrite = TRUE` moves the existing item to trash, then proceeds
+ drive_mv(file, path = "~/", name = "name-squatter-mv", overwrite = TRUE)
+ 
+ # Clean up
+ drive_rm(file, folder)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_publish")
> ### * drive_publish
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_publish
> ### Title: Publish native Google files
> ### Aliases: drive_publish drive_unpublish
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Create a file to publish
+ file <- drive_example_remote("chicken_sheet") %>%
+   drive_cp()
+ 
+ # Publish file
+ file <- drive_publish(file)
+ file$published
+ 
+ # Unpublish file
+ file <- drive_unpublish(file)
+ file$published
+ 
+ # Clean up
+ drive_rm(file)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_put")
> ### * drive_put
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_put
> ### Title: PUT new media into a Drive file
> ### Aliases: drive_put
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # create a local file to work with
+ local_file <- tempfile("drive_put_", fileext = ".txt")
+ writeLines(c("beginning", "middle"), local_file)
+ 
+ # PUT to a novel filepath --> drive_put() delegates to drive_upload()
+ file <- drive_put(local_file)
+ 
+ # update the local file
+ cat("end", file = local_file, sep = "\n", append = TRUE)
+ 
+ # PUT again --> drive_put() delegates to drive_update()
+ file <- drive_put(local_file)
+ 
+ # create a second file at this filepath
+ file2 <- drive_create(basename(local_file))
+ 
+ # PUT again --> ERROR
+ drive_put(local_file)
+ 
+ # Clean up
+ drive_find("drive_put_.+[.]txt") %>% drive_rm()
+ unlink(local_file)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_read_string")
> ### * drive_read_string
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_read_string
> ### Title: Read the content of a Drive file
> ### Aliases: drive_read_string drive_read_raw
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # comma-separated values --> data.frame or tibble
+ (chicken_csv <- drive_example_remote("chicken.csv"))
+ chicken_csv %>%
+   drive_read_string() %>%
+   read.csv(text = .)
+ 
+ # Google Doc --> character vector
+ (chicken_doc <- drive_example_remote("chicken_doc"))
+ chicken_doc %>%
+   # NOTE: we must specify an export MIME type
+   drive_read_string(type = "text/plain") %>%
+   strsplit(split = "(\r\n|\r|\n)") %>%
+   .[[1]]
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_rename")
> ### * drive_rename
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_rename
> ### Title: Rename a Drive file
> ### Aliases: drive_rename
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Create a file to rename
+ file <- drive_create("file-to-rename")
+ 
+ # Rename it
+ file <- drive_rename(file, name = "renamed-file")
+ 
+ # `overwrite = FALSE` errors if something already exists at target filepath
+ # THIS WILL ERROR!
+ drive_create("name-squatter-rename")
+ drive_rename(file, name = "name-squatter-rename", overwrite = FALSE)
+ 
+ # `overwrite = TRUE` moves the existing item to trash, then proceeds
+ file <- drive_rename(file, name = "name-squatter-rename", overwrite = TRUE)
+ 
+ # Clean up
+ drive_rm(file)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_reveal")
> ### * drive_reveal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_reveal
> ### Title: Add a new column of Drive file information
> ### Aliases: drive_reveal
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Get a few of your files
+ files <- drive_find(n_max = 10, trashed = NA)
+ 
+ # the "special" cases that require additional API calls and can be slow
+ drive_reveal(files, "path")
+ drive_reveal(files, "permissions")
+ drive_reveal(files, "published")
+ 
+ # a "special" case of digging info out of `drive_resource`, then processing
+ # a bit
+ drive_reveal(files, "parent")
+ 
+ # the "simple" cases of digging info out of `drive_resource`
+ drive_reveal(files, "trashed")
+ drive_reveal(files, "mime_type")
+ drive_reveal(files, "starred")
+ drive_reveal(files, "description")
+ drive_reveal(files, "version")
+ drive_reveal(files, "web_view_link")
+ drive_reveal(files, "modified_time")
+ drive_reveal(files, "created_time")
+ drive_reveal(files, "owned_by_me")
+ drive_reveal(files, "size")
+ drive_reveal(files, "quota_bytes_used")
+ 
+ # 'root' is a special file id that represents your My Drive root folder
+ drive_get(id = "root") %>%
+   drive_reveal("path")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_rm")
> ### * drive_rm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_rm
> ### Title: Delete files from Drive
> ### Aliases: drive_rm
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Target one of the official example files to copy (then remove)
+ (src_file <- drive_example_remote("chicken.txt"))
+ 
+ # Create a copy, then remove it by name
+ src_file %>%
+   drive_cp(name = "chicken-rm.txt")
+ drive_rm("chicken-rm.txt")
+ 
+ # Create several more copies
+ x1 <- src_file %>%
+   drive_cp(name = "chicken-abc.txt")
+ drive_cp(src_file, name = "chicken-def.txt")
+ x2 <- src_file %>%
+   drive_cp(name = "chicken-ghi.txt")
+ 
+ # Remove the copies all at once, specified in different ways
+ drive_rm(x1, "chicken-def.txt", as_id(x2))
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_scopes")
> ### * drive_scopes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_scopes
> ### Title: Produce scopes specific to the Drive API
> ### Aliases: drive_scopes
> 
> ### ** Examples
> 
> drive_scopes("full")
[1] "https://www.googleapis.com/auth/drive"
> drive_scopes("drive.readonly")
[1] "https://www.googleapis.com/auth/drive.readonly"
> drive_scopes()
                                                    drive 
                  "https://www.googleapis.com/auth/drive" 
                                                     full 
                  "https://www.googleapis.com/auth/drive" 
                                           drive.readonly 
         "https://www.googleapis.com/auth/drive.readonly" 
                                               drive.file 
             "https://www.googleapis.com/auth/drive.file" 
                                            drive.appdata 
          "https://www.googleapis.com/auth/drive.appdata" 
                                           drive.metadata 
         "https://www.googleapis.com/auth/drive.metadata" 
                                  drive.metadata.readonly 
"https://www.googleapis.com/auth/drive.metadata.readonly" 
                                    drive.photos.readonly 
  "https://www.googleapis.com/auth/drive.photos.readonly" 
                                            drive.scripts 
          "https://www.googleapis.com/auth/drive.scripts" 
> 
> 
> 
> cleanEx()
> nameEx("drive_share")
> ### * drive_share
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_share
> ### Title: Share Drive files
> ### Aliases: drive_share drive_share_anyone
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Create a file to share
+ file <- drive_example_remote("chicken_doc") %>%
+   drive_cp(name = "chicken-share.txt")
+ 
+ # Let a specific person comment
+ file <- file %>%
+   drive_share(
+     role = "commenter",
+     type = "user",
+     emailAddress = "susan@example.com"
+   )
+ 
+ # Let a different specific person edit and customize the email notification
+ file <- file %>%
+   drive_share(
+     role = "writer",
+     type = "user",
+     emailAddress = "carol@example.com",
+     emailMessage = "Would appreciate your feedback on this!"
+   )
+ 
+ # Let anyone read the file
+ file <- file %>%
+   drive_share(role = "reader", type = "anyone")
+ # Single-purpose wrapper function for this
+ drive_share_anyone(file)
+ 
+ # Clean up
+ drive_rm(file)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_token")
> ### * drive_token
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_token
> ### Title: Produce configured token
> ### Aliases: drive_token
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ req <- request_generate(
+   "drive.files.get",
+   list(fileId = "abc"),
+   token = drive_token()
+ )
+ req
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_trash")
> ### * drive_trash
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_trash
> ### Title: Move Drive files to or from trash
> ### Aliases: drive_trash drive_untrash
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Create a file and put it in the trash.
+ file <- drive_example_remote("chicken.txt") %>%
+   drive_cp("chicken-trash.txt")
+ drive_trash("chicken-trash.txt")
+ 
+ # Confirm it's in the trash
+ drive_find(trashed = TRUE)
+ 
+ # Remove it from the trash and confirm
+ drive_untrash("chicken-trash.txt")
+ drive_find(trashed = TRUE)
+ 
+ # Clean up
+ drive_rm("chicken-trash.txt")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_update")
> ### * drive_update
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_update
> ### Title: Update an existing Drive file
> ### Aliases: drive_update
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Create a new file, so we can update it
+ x <- drive_example_remote("chicken.csv") %>%
+   drive_cp()
+ 
+ # Update the file with new media
+ x <- x %>%
+   drive_update(drive_example_local("chicken.txt"))
+ 
+ # Update the file with new metadata.
+ # Notice here `name` is not an argument of `drive_update()`, we are passing
+ # this to the API via the `...``
+ x <- x %>%
+   drive_update(name = "CHICKENS!")
+ 
+ # Update the file with new media AND new metadata
+ x <- x %>%
+   drive_update(
+     drive_example_local("chicken.txt"),
+     name = "chicken-poem-again.txt"
+   )
+ 
+ # Clean up
+ drive_rm(x)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_upload")
> ### * drive_upload
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_upload
> ### Title: Upload into a new Drive file
> ### Aliases: drive_upload
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # upload a csv file
+ chicken_csv <- drive_example_local("chicken.csv") %>%
+   drive_upload("chicken-upload.csv")
+ 
+ # or convert it to a Google Sheet
+ chicken_sheet <- drive_example_local("chicken.csv") %>%
+   drive_upload(
+     name = "chicken-sheet-upload.csv",
+     type = "spreadsheet"
+   )
+ 
+ # check out the new Sheet!
+ drive_browse(chicken_sheet)
+ 
+ # Clean up
+ drive_find("chicken.*upload") %>% drive_rm()
+ 
+ # Upload a file and, at the same time, star it
+ chicken <- drive_example_local("chicken.jpg") %>%
+   drive_upload(starred = "true")
+ 
+ # Is is really starred? YES
+ purrr::pluck(chicken, "drive_resource", 1, "starred")
+ 
+ # Clean up
+ drive_rm(chicken)
+ 
+ # `overwrite = FALSE` errors if something already exists at target filepath
+ # THIS WILL ERROR!
+ drive_create("name-squatter-upload")
+ drive_example_local("chicken.jpg") %>%
+   drive_upload(
+     name = "name-squatter-upload",
+     overwrite = FALSE
+   )
+ 
+ # `overwrite = TRUE` moves the existing item to trash, then proceeds
+ chicken <- drive_example_local("chicken.jpg") %>%
+   drive_upload(
+     name = "name-squatter-upload",
+     overwrite = TRUE
+   )
+ 
+ # Clean up
+ drive_rm(chicken)
+ 
+ ## Not run: 
+ ##D # Upload to a shared drive:
+ ##D #   * Shared drives are only available if your account is associated with a
+ ##D #     Google Workspace
+ ##D #   * The shared drive (or shared-drive-hosted folder) MUST be captured as a
+ ##D #     dribble first and provided via `path`
+ ##D sd <- shared_drive_get("Marketing")
+ ##D drive_upload("fascinating.csv", path = sd)
+ ## End(Not run)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("drive_user")
> ### * drive_user
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drive_user
> ### Title: Get info on current user
> ### Aliases: drive_user
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ drive_user()
+ 
+ # more info is returned than is printed
+ user <- drive_user()
+ str(user)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("expose")
> ### * expose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expose
> ### Title: An expose object
> ### Aliases: expose
> ### Keywords: internal
> 
> ### ** Examples
> 
> drive_mime_type(expose())
# A tibble: 78 × 5
   mime_type                             ext   description    human_type default
   <chr>                                 <chr> <chr>          <chr>      <lgl>  
 1 application/epub+zip                  <NA>  <NA>           <NA>       NA     
 2 application/msword                    doc   <NA>           doc        TRUE   
 3 application/msword                    dot   <NA>           dot        FALSE  
 4 application/pdf                       pdf   <NA>           pdf        TRUE   
 5 application/rtf                       rtf   <NA>           rtf        TRUE   
 6 application/vnd.google-apps.audio     <NA>  <NA>           audio      NA     
 7 application/vnd.google-apps.document  <NA>  Google Docs    document   NA     
 8 application/vnd.google-apps.drawing   <NA>  Google Drawing drawing    NA     
 9 application/vnd.google-apps.drive-sdk <NA>  3rd party sho… drive-sdk  NA     
10 application/vnd.google-apps.file      <NA>  Google Drive … file       NA     
# ℹ 68 more rows
> drive_fields(expose())
# A tibble: 55 × 2
   name                         desc                                            
   <chr>                        <chr>                                           
 1 appProperties                "A collection of arbitrary key-value pairs whic…
 2 capabilities                 "Capabilities the current user has on this file…
 3 contentHints                 "Additional information about the content of th…
 4 copyRequiresWriterPermission "Whether the options to copy, print, or downloa…
 5 createdTime                  "The time at which the file was created (RFC 33…
 6 description                  "A short description of the file."              
 7 driveId                      "ID of the shared drive the file resides in. On…
 8 explicitlyTrashed            "Whether the file has been explicitly trashed, …
 9 exportLinks                  "Links for exporting Google Docs to specific fo…
10 fileExtension                "The final component of fullFileExtension. This…
# ℹ 45 more rows
> 
> 
> 
> cleanEx()
> nameEx("googledrive-configuration")
> ### * googledrive-configuration
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: googledrive-configuration
> ### Title: googledrive configuration
> ### Aliases: googledrive-configuration local_drive_quiet with_drive_quiet
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # message: "Created Drive file"
+ (x <- drive_create("drive-quiet-demo", type = "document"))
+ 
+ # message: "File updated"
+ x <- drive_update(x, starred = TRUE)
+ drive_reveal(x, "starred")
+ 
+ # suppress messages for a small amount of code
+ with_drive_quiet(
+   x <- drive_update(x, name = "drive-quiet-works")
+ )
+ x$name
+ 
+ # message: "File updated"
+ x <- drive_update(x, media = drive_example_local("chicken.txt"))
+ 
+ # suppress messages within a specific scope, e.g. function
+ unstar <- function(y) {
+   local_drive_quiet()
+   drive_update(y, starred = FALSE)
+ }
+ x <- unstar(x)
+ drive_reveal(x, "starred")
+ 
+ # Clean up
+ drive_rm(x)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("request_generate")
> ### * request_generate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: request_generate
> ### Title: Build a request for the Google Drive API
> ### Aliases: request_generate
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ req <- request_generate(
+   "drive.files.get",
+   list(fileId = "abc"),
+   token = drive_token()
+ )
+ req
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("request_make")
> ### * request_make
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: request_make
> ### Title: Make a request for the Google Drive v3 API
> ### Aliases: request_make do_request do_paginated_request
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # build a request for an endpoint that is:
> ##D #   * paginated
> ##D #   * NOT privileged in googledrive, i.e. not covered by request_generate()
> ##D # "comments" are a great example
> ##D # https://developers.google.com/drive/v3/reference/comments
> ##D #
> ##D # Practice with a target file with > 2 comments
> ##D # Note that we request 2 items (comments) per page
> ##D req <- gargle::request_build(
> ##D   path = "drive/v3/files/{fileId}/comments",
> ##D   method = "GET",
> ##D   params = list(
> ##D     fileId = "your-file-id-goes-here",
> ##D     fields = "*",
> ##D     pageSize = 2
> ##D   ),
> ##D   token = googledrive::drive_token()
> ##D )
> ##D # make the paginated request, but cap it at 1 page
> ##D # should get back exactly two comments
> ##D do_paginated_request(req, n_max = 1)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("shared_drive_create")
> ### * shared_drive_create
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shared_drive_create
> ### Title: Create a new shared drive
> ### Aliases: shared_drive_create
> 
> ### ** Examples
> 
> ## Not run: 
> ##D shared_drive_create("my-awesome-shared-drive")
> ##D 
> ##D # Clean up
> ##D shared_drive_rm("my-awesome-shared-drive")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("shared_drive_find")
> ### * shared_drive_find
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shared_drive_find
> ### Title: Find shared drives
> ### Aliases: shared_drive_find
> 
> ### ** Examples
> 
> ## Not run: 
> ##D shared_drive_find()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("shared_drive_get")
> ### * shared_drive_get
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shared_drive_get
> ### Title: Get shared drives by name or id
> ### Aliases: shared_drive_get
> 
> ### ** Examples
> 
> ## Not run: 
> ##D shared_drive_get("my-awesome-shared-drive")
> ##D shared_drive_get(c("apple", "orange", "banana"))
> ##D shared_drive_get(as_id("KCmiHLXUk9PVA-0AJNG"))
> ##D shared_drive_get(as_id("https://drive.google.com/drive/u/0/folders/KCmiHLXUk9PVA-0AJNG"))
> ##D shared_drive_get(id = "KCmiHLXUk9PVA-0AJNG")
> ##D shared_drive_get(id = "https://drive.google.com/drive/u/0/folders/KCmiHLXUk9PVA-0AJNG")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("shared_drive_rm")
> ### * shared_drive_rm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shared_drive_rm
> ### Title: Delete shared drives
> ### Aliases: shared_drive_rm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Create shared drives to remove in various ways
> ##D shared_drive_create("testdrive-01")
> ##D sd02 <- shared_drive_create("testdrive-02")
> ##D shared_drive_create("testdrive-03")
> ##D sd04 <- shared_drive_create("testdrive-04")
> ##D 
> ##D # remove by name
> ##D shared_drive_rm("testdrive-01")
> ##D # remove by id
> ##D shared_drive_rm(as_id(sd02))
> ##D # remove by URL (or, rather, id found in URL)
> ##D shared_drive_rm(as_id("https://drive.google.com/drive/u/0/folders/Q5DqUk9PVA"))
> ##D # remove by dribble
> ##D shared_drive_rm(sd04)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("shared_drive_update")
> ### * shared_drive_update
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shared_drive_update
> ### Title: Update a shared drive
> ### Aliases: shared_drive_update
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # create a shared drive
> ##D sd <- shared_drive_create("I love themes!")
> ##D 
> ##D # see the themes available to you
> ##D themes <- drive_about()$driveThemes
> ##D purrr::map_chr(themes, "id")
> ##D 
> ##D # cycle through various themes for this shared drive
> ##D sd <- shared_drive_update(sd, themeId = "bok_choy")
> ##D sd <- shared_drive_update(sd, themeId = "cocktails")
> ##D 
> ##D # Clean up
> ##D shared_drive_rm(sd)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("shortcut_create")
> ### * shortcut_create
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shortcut_create
> ### Title: Create a shortcut to a Drive file
> ### Aliases: shortcut_create
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Target one of the official example files
+ (src_file <- drive_example_remote("chicken_sheet"))
+ 
+ # Create a shortcut in the default location with the default name
+ sc1 <- shortcut_create(src_file)
+ # This shortcut could now be moved, renamed, etc.
+ 
+ # Create a shortcut in the default location with a custom name
+ sc2 <- src_file %>%
+   shortcut_create(name = "chicken_sheet_second_shortcut")
+ 
+ # Create a folder, then put a shortcut there, with default name
+ folder <- drive_mkdir("chicken_sheet_shortcut_folder")
+ sc3 <- src_file %>%
+   shortcut_create(folder)
+ 
+ # Look at all these shortcuts
+ (dat <- drive_find("chicken_sheet", type = "shortcut"))
+ 
+ # Confirm the shortcuts all target the original file
+ dat <- dat %>%
+   drive_reveal("shortcut_details")
+ purrr::map_chr(dat$shortcut_details, "targetId")
+ as_id(src_file)
+ 
+ # Clean up
+ drive_rm(sc1, sc2, sc3, folder)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("shortcut_resolve")
> ### * shortcut_resolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shortcut_resolve
> ### Title: Resolve shortcuts to their targets
> ### Aliases: shortcut_resolve
> 
> ### ** Examples
> 
> ## Don't show: 
> if (drive_has_token()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # Create a file to make a shortcut to
+ file <- drive_example_remote("chicken_sheet") %>%
+   drive_cp(name = "chicken-sheet-for-shortcut")
+ 
+ # Create a shortcut
+ sc1 <- file %>%
+   shortcut_create(name = "shortcut-1")
+ 
+ # Create a second shortcut by copying the first
+ sc1 <- sc1 %>%
+   drive_cp(name = "shortcut-2")
+ 
+ # Get the shortcuts
+ (sc_dat <- drive_find("-[12]$", type = "shortcut"))
+ 
+ # Resolve them
+ (resolved <- shortcut_resolve(sc_dat))
+ 
+ resolved$id
+ file$id
+ 
+ # Delete the target file
+ drive_rm(file)
+ 
+ # (Try to) resolve the shortcuts again
+ shortcut_resolve(sc_dat)
+ # No error, but resolution is unsuccessful due to non-existent target
+ 
+ # Clean up
+ drive_rm(sc_dat)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.539 0.052 0.591 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
