
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "openssl"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('openssl')
Linking to: OpenSSL 3.0.13 30 Jan 2024
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aes_cbc")
> ### * aes_cbc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_cbc
> ### Title: Symmetric AES encryption
> ### Aliases: aes_cbc aes_ctr_encrypt aes_ctr_decrypt aes_cbc_encrypt
> ###   aes_cbc_decrypt aes_gcm_encrypt aes_gcm_decrypt aes_keygen
> 
> ### ** Examples
> 
> # aes-256 requires 32 byte key
> passphrase <- charToRaw("This is super secret")
> key <- sha256(passphrase)
> 
> # symmetric encryption uses same key for decryption
> x <- serialize(iris, NULL)
> y <- aes_cbc_encrypt(x, key = key)
> x2 <- aes_cbc_decrypt(y, key = key)
> stopifnot(identical(x, x2))
> 
> 
> 
> cleanEx()
> nameEx("base64_encode")
> ### * base64_encode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: base64_encode
> ### Title: Encode and decode base64
> ### Aliases: base64_encode base64_decode
> 
> ### ** Examples
> 
> input <- charToRaw("foo = bar + 5")
> message <- base64_encode(input)
> output <- base64_decode(message)
> identical(output, input)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("bignum")
> ### * bignum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bignum
> ### Title: Big number arithmetic
> ### Aliases: bignum bignum_mod_exp bignum_mod_inv
> 
> ### ** Examples
> 
> # create a bignum
> x <- bignum(123L)
> y <- bignum("123456789123456789")
> z <- bignum("D41D8CD98F00B204E9800998ECF8427E", hex = TRUE)
> 
> # Basic arithmetic
> div <- z %/% y
> mod <- z %% y
> z2 <- div * y + mod
> stopifnot(z2 == z)
> stopifnot(div < z)
> 
> 
> 
> cleanEx()
> nameEx("certificates")
> ### * certificates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cert_verify
> ### Title: X509 certificates
> ### Aliases: cert_verify certificates download_ssl_cert ca_bundle
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("curve25519")
> ### * curve25519
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curve25519
> ### Title: Curve25519
> ### Aliases: curve25519 read_ed25519_key read_ed25519_pubkey
> ###   read_x25519_key read_x25519_pubkey ed25519_sign ed25519_verify
> ###   x25519_diffie_hellman
> 
> ### ** Examples
> 
> # Generate a keypair
> if(openssl_config()$x25519){
+ key <- ed25519_keygen()
+ pubkey <- as.list(key)$pubkey
+ 
+ # Sign message
+ msg <- serialize(iris, NULL)
+ sig <- ed25519_sign(msg, key)
+ 
+ # Verify the signature
+ ed25519_verify(msg, sig, pubkey)
+ 
+ # Diffie Hellman example:
+ key1 <- x25519_keygen()
+ key2 <- x25519_keygen()
+ 
+ # Both parties can derive the same secret
+ x25519_diffie_hellman(key1, key2$pubkey)
+ x25519_diffie_hellman(key2, key1$pubkey)
+ 
+ # Import/export sodium keys
+ rawkey <- sodium::sig_keygen()
+ rawpubkey <- sodium::sig_pubkey(rawkey)
+ key <- read_ed25519_key(rawkey)
+ pubkey <- read_ed25519_pubkey(rawpubkey)
+ 
+ # To get the raw key data back for use in sodium
+ as.list(key)$data
+ as.list(pubkey)$data
+ }
 [1] 53 ae d1 83 40 bf e0 91 5f 8d c6 0b 0e 71 bb d8 de a8 95 c3 3e 79 f2 db 26
[26] 4f 2f 0d 6a 44 0b 5a
> 
> 
> 
> cleanEx()
> nameEx("ec_dh")
> ### * ec_dh
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ec_dh
> ### Title: Diffie-Hellman Key Agreement
> ### Aliases: ec_dh
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Need two EC keypairs from the same curve
> ##D alice_key <- ec_keygen("P-521")
> ##D bob_key <- ec_keygen("P-521")
> ##D 
> ##D # Derive public keys
> ##D alice_pub <- as.list(alice_key)$pubkey
> ##D bob_pub <- as.list(bob_key)$pubkey
> ##D 
> ##D # Both peers can derive the (same) shared secret via each other's pubkey
> ##D ec_dh(alice_key, bob_pub)
> ##D ec_dh(bob_key, alice_pub)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("encrypt_envelope")
> ### * encrypt_envelope
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: encrypt_envelope
> ### Title: Envelope encryption
> ### Aliases: encrypt_envelope envelope decrypt_envelope
> 
> ### ** Examples
> 
> # Requires RSA key
> key <- rsa_keygen()
> pubkey <- key$pubkey
> msg <- serialize(iris, NULL)
> 
> # Encrypt
> out <- encrypt_envelope(msg, pubkey)
> str(out)
List of 3
 $ iv     : raw [1:16] de 22 72 c6 ...
 $ session: raw [1:256] 57 a6 c6 bf ...
 $ data   : raw [1:5808] 4d 8d 88 fb ...
> 
> # Decrypt
> orig <- decrypt_envelope(out$data, out$iv, out$session, key)
> stopifnot(identical(msg, orig))
> 
> 
> 
> cleanEx()
> nameEx("fingerprint")
> ### * fingerprint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fingerprint
> ### Title: OpenSSH fingerprint
> ### Aliases: fingerprint
> 
> ### ** Examples
> 
> mykey <- rsa_keygen()
> pubkey <- as.list(mykey)$pubkey
> fingerprint(mykey)
sha256 d1:f0:c8:db:67:6b:22:ab:20:d9:e4:68:14:24:fc:73:6a:50:8c:24:84:7c:6a:85:fd:d9:cd:49:d7:91:7a:66 
> fingerprint(pubkey)
sha256 d1:f0:c8:db:67:6b:22:ab:20:d9:e4:68:14:24:fc:73:6a:50:8c:24:84:7c:6a:85:fd:d9:cd:49:d7:91:7a:66 
> 
> # Some systems use other hash functions
> fingerprint(pubkey, sha1)
sha1 ad:f8:2e:10:c6:31:7d:d7:49:95:e4:fe:01:b5:e5:6f:0c:9c:37:6c 
> fingerprint(pubkey, sha256)
sha256 d1:f0:c8:db:67:6b:22:ab:20:d9:e4:68:14:24:fc:73:6a:50:8c:24:84:7c:6a:85:fd:d9:cd:49:d7:91:7a:66 
> 
> # Other key types
> fingerprint(dsa_keygen())
sha256 c0:29:ef:29:69:8d:bd:6f:8d:a0:8a:4c:41:1d:2e:60:a0:b6:36:56:0a:f5:20:87:39:72:98:10:d7:12:e5:e1 
> 
> 
> 
> cleanEx()
> nameEx("hash")
> ### * hash
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hashing
> ### Title: Vectorized hash/hmac functions
> ### Aliases: hashing sha1 hash hmac mac sha224 sha256 sha384 sha512 keccak
> ###   sha2 sha3 md4 md5 blake2b blake2s ripemd160 multihash
> 
> ### ** Examples
> 
> # Support both strings and binary
> md5(c("foo", "bar"))
[1] "acbd18db4cc2f85cedef654fccc4a4d8" "37b51d194a7513e45b56f6524f2d51f2"
> md5("foo", key = "secret")
[1] "ba19fbc606a960051b60244e9a5ed3d2"
> 
> hash <- md5(charToRaw("foo"))
> as.character(hash, sep = ":")
[1] "ac:bd:18:db:4c:c2:f8:5c:ed:ef:65:4f:cc:c4:a4:d8"
> 
> # Compare to digest
> digest::digest("foo", "md5", serialize = FALSE)
[1] "acbd18db4cc2f85cedef654fccc4a4d8"
> 
> # Other way around
> digest::digest(cars, skip = 0)
[1] "1e61f0ed3dafd2d955f05a665248f1f0"
> md5(serialize(cars, NULL))
md5 6d:b9:15:f3:4e:bc:6e:55:3d:b7:80:60:0d:54:b1:2b 
> 
> # Stream-verify from connections (including files)
> myfile <- system.file("CITATION")
> md5(file(myfile, raw = TRUE))
md5 48:9e:35:00:38:d0:47:ad:99:03:b8:c5:35:d3:ec:e7 
> md5(file(myfile, raw = TRUE), key = "secret")
md5 hmac c9:ea:8a:9e:eb:44:e7:98:7a:a3:e7:9f:db:b0:73:02 
> 
> ## Not run: 
> ##D check md5 from: http://cran.r-project.org/bin/windows/base/old/3.1.1/md5sum.txt
> ##D md5(url("http://cran.r-project.org/bin/windows/base/old/3.1.1/R-3.1.1-win.exe"))
> ## End(Not run)
> 
> # Use a salt to prevent dictionary attacks
> sha1("admin") # googleable
[1] "d033e22ae348aeb5660fc2140aec35850c4da997"
> sha1("admin", key = "random_salt_value") #not googleable
[1] "4a6e59fa5cc72c6785d9f4652664acce5d2da63f"
> 
> # Use a random salt to identify duplicates while anonymizing values
> sha256("john") # googleable
[1] "96d9632f363564cc3032521409cf22a852f2032eec099ed5967c0d000cec607a"
> sha256(c("john", "mary", "john"), key = "random_salt_value")
[1] "5540b6f6e1fa6552ea7402b4841fac08eee56b55dbe9f9180aa7bb539b284f8b"
[2] "9ea418fd421465da254bccf930db3efce304841bb5e95797903e9e721af2819f"
[3] "5540b6f6e1fa6552ea7402b4841fac08eee56b55dbe9f9180aa7bb539b284f8b"
> 
> 
> 
> cleanEx()
> nameEx("keygen")
> ### * keygen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: keygen
> ### Title: Generate Key pair
> ### Aliases: keygen rsa_keygen dsa_keygen ec_keygen x25519_keygen
> ###   ed25519_keygen
> 
> ### ** Examples
> 
> # Generate keypair
> key <- rsa_keygen()
> pubkey <- as.list(key)$pubkey
> 
> # Write/read the key with a passphrase
> write_pem(key, "id_rsa", password = "supersecret")
> read_key("id_rsa", password = "supersecret")
[2048-bit rsa private key]
md5: 3d9cc78a0ded2724e89f13911e9a30fb
sha256: 27a109bad3fbd96e5c6574afe715b4e8bb79c298d60a2898cc5d707acc82ccdf
> unlink("id_rsa")
> 
> 
> 
> cleanEx()
> nameEx("my_key")
> ### * my_key
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: my_key
> ### Title: Default key
> ### Aliases: my_key my_pubkey
> 
> ### ** Examples
> 
> # Set random RSA key as default
> key <- rsa_keygen()
> write_pem(key, tmp <- tempfile(), password = "")
> rm(key)
> Sys.setenv("USER_KEY" = tmp)
> 
> # Check the new keys
> print(my_key())
[2048-bit rsa private key]
md5: 708769088e8cbae3e99470806743aae5
sha256: cef9e69b924b7ed5e2859b547346255051cb7c13dc9db6464bb04ff07b04dac9
> print(my_pubkey())
[2048-bit rsa public key]
md5: 708769088e8cbae3e99470806743aae5
sha256: cef9e69b924b7ed5e2859b547346255051cb7c13dc9db6464bb04ff07b04dac9
> 
> 
> 
> cleanEx()
> nameEx("rand_bytes")
> ### * rand_bytes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rand_bytes
> ### Title: Generate random bytes and numbers with OpenSSL
> ### Aliases: rand_bytes rand_num
> 
> ### ** Examples
> 
> rnd <- rand_bytes(10)
> as.numeric(rnd)
 [1]  52  88 154  77 200 191  43  30  75 226
> as.character(rnd)
 [1] "34" "58" "9a" "4d" "c8" "bf" "2b" "1e" "4b" "e2"
> as.logical(rawToBits(rnd))
 [1] FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE
[13]  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE
[25]  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
[37] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE
[49]  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
[61]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE
[73] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
> 
> # bytes range from 0 to 255
> rnd <- rand_bytes(100000)
> hist(as.numeric(rnd), breaks=-1:255)
> 
> # Generate random doubles between 0 and 1
> rand_num(5)
[1] 0.08908582 0.95769462 0.39208169 0.60541207 0.06138449
> 
> # Use CDF to map [0,1] into random draws from a distribution
> x <- qnorm(rand_num(1000), mean=100, sd=15)
> hist(x)
> 
> y <- qbinom(rand_num(1000), size=10, prob=0.3)
> hist(y)
> 
> 
> 
> cleanEx()
> nameEx("read_key")
> ### * read_key
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_key
> ### Title: Parsing keys and certificates
> ### Aliases: read_key read_pubkey read_cert read_cert_bundle read_pem
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Read private key
> ##D key <- read_key("~/.ssh/id_rsa")
> ##D str(key)
> ##D 
> ##D # Read public key
> ##D pubkey <- read_pubkey("~/.ssh/id_rsa.pub")
> ##D str(pubkey)
> ##D 
> ##D # Read certificates
> ##D txt <- readLines("https://curl.haxx.se/ca/cacert.pem")
> ##D bundle <- read_cert_bundle(txt)
> ##D print(bundle)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rsa_encrypt")
> ### * rsa_encrypt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rsa_encrypt
> ### Title: Low-level RSA encryption
> ### Aliases: rsa_encrypt rsa encrypt rsa_decrypt
> 
> ### ** Examples
> 
> # Generate test keys
> key <- rsa_keygen()
> pubkey <- key$pubkey
> 
> # Encrypt data with AES
> tempkey <- rand_bytes(32)
> iv <- rand_bytes(16)
> blob <- aes_cbc_encrypt(system.file("CITATION"), tempkey, iv = iv)
> 
> # Encrypt tempkey using receivers public RSA key
> ciphertext <- rsa_encrypt(tempkey, pubkey)
> 
> # Receiver decrypts tempkey from private RSA key
> tempkey <- rsa_decrypt(ciphertext, key)
> message <- aes_cbc_decrypt(blob, tempkey, iv)
> out <- rawToChar(message)
> 
> 
> 
> cleanEx()
> nameEx("signatures")
> ### * signatures
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: signature_create
> ### Title: Signatures
> ### Aliases: signature_create signatures signature_verify ecdsa_parse
> ###   ecdsa_write
> 
> ### ** Examples
> 
> # Generate a keypair
> key <- rsa_keygen()
> pubkey <- key$pubkey
> 
> # Sign a file
> data <- system.file("DESCRIPTION")
> sig <- signature_create(data, sha256, key = key)
> stopifnot(signature_verify(data, sig, sha256, pubkey = pubkey))
> 
> # Sign raw data
> data <- serialize(iris, NULL)
> sig <- signature_create(data, sha256, key = key)
> stopifnot(signature_verify(data, sig, sha256, pubkey = pubkey))
> 
> # Sign a hash
> md <- md5(data)
> sig <- signature_create(md, hash = sha256, key = key)
> stopifnot(signature_verify(md, sig, hash = sha256, pubkey = pubkey))
> #
> # ECDSA example
> data <- serialize(iris, NULL)
> key <- ec_keygen()
> pubkey <- key$pubkey
> sig <- signature_create(data, sha256, key = key)
> stopifnot(signature_verify(data, sig, sha256, pubkey = pubkey))
> 
> # Convert signature to (r, s) parameters and then back
> params <- ecdsa_parse(sig)
> out <- ecdsa_write(params$r, params$s)
> identical(sig, out)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("ssl_ctx")
> ### * ssl_ctx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ssl_ctx
> ### Title: Hooks to manipulate the SSL context for curl requests
> ### Aliases: ssl_ctx ssl_ctx_add_cert_to_store ssl_ctx_set_verify_callback
> ###   ssl_ctx_curl_version_match
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Example 1: accept your local snakeoil https cert
> ##D mycert <- openssl::download_ssl_cert('localhost')[[1]]
> ##D 
> ##D # Setup the callback
> ##D h <- curl::new_handle(ssl_ctx_function = function(ssl_ctx){
> ##D   ssl_ctx_add_cert_to_store(ssl_ctx, mycert)
> ##D }, verbose = TRUE, forbid_reuse = TRUE)
> ##D 
> ##D # Perform the request
> ##D req <- curl::curl_fetch_memory('https://localhost', handle = h)
> ##D 
> ##D # Example 2 using a custom verify function
> ##D verify_cb <- function(cert){
> ##D   id <- cert$pubkey$fingerprint
> ##D   cat("Server cert from:", as.character(id), "\n")
> ##D   TRUE # always accept cert
> ##D }
> ##D 
> ##D h <- curl::new_handle(ssl_ctx_function = function(ssl_ctx){
> ##D   ssl_ctx_set_verify_callback(ssl_ctx, verify_cb)
> ##D }, verbose = TRUE, forbid_reuse = TRUE)
> ##D 
> ##D # Perform the request
> ##D req <- curl::curl_fetch_memory('https://localhost', handle = h)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("write_pem")
> ### * write_pem
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write_pem
> ### Title: Export key or certificate
> ### Aliases: write_pem write_der write_pkcs1 write_ssh write_openssh_pem
> 
> ### ** Examples
> 
> # Generate RSA keypair
> key <- rsa_keygen()
> pubkey <- key$pubkey
> 
> # Write to output formats
> write_ssh(pubkey)
[1] "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCrU7nKfkou2ZJXKXKDfD1wn9NO8pFbzFEhIzYs7EI4fyBQPElQdpWh6vfw6arDgH3+PAIRsMguPW/XuoyGbI4FdLP8EOFoBYtl5r+xa6V91JEeQqD2g/7KKHYH2uQP97bBi+V2QRjAuHlh/1/wH37pfBcWKBV/WIMCEW7otiKPQecCG2T9kv13rByDzxHNrD92pLFDcjFuD14R2yXyWHQQSMNeeJfb6rLEVbrgt/BMRNmZgJGcL3291r9Dsfg4tGHE2K5kp1mO7vqAr8gyODdHuoVJ8N22jL5yYR80uV46VJ/7XxoBv3avIQKZplxzkPNsKTF7Ck53QDX9da9oV8EN"
> write_pem(pubkey)
[1] "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq1O5yn5KLtmSVylyg3w9\ncJ/TTvKRW8xRISM2LOxCOH8gUDxJUHaVoer38Omqw4B9/jwCEbDILj1v17qMhmyO\nBXSz/BDhaAWLZea/sWulfdSRHkKg9oP+yih2B9rkD/e2wYvldkEYwLh5Yf9f8B9+\n6XwXFigVf1iDAhFu6LYij0HnAhtk/ZL9d6wcg88Rzaw/dqSxQ3Ixbg9eEdsl8lh0\nEEjDXniX2+qyxFW64LfwTETZmYCRnC99vda/Q7H4OLRhxNiuZKdZju76gK/IMjg3\nR7qFSfDdtoy+cmEfNLleOlSf+18aAb92ryECmaZcc5DzbCkxewpOd0A1/XWvaFfB\nDQIDAQAB\n-----END PUBLIC KEY-----\n"
> write_pem(key, password = "super secret")
[1] "-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIIFHDBOBgkqhkiG9w0BBQ0wQTApBgkqhkiG9w0BBQwwHAQIURugbYJuCngCAggA\nMAwGCCqGSIb3DQIJBQAwFAYIKoZIhvcNAwcECC8V9l4AIIqNBIIEyCrOqu+yVA17\nMwCyJ2J9JXTm2musjl3OFWu+p2xQBrJQBvFYlNYIWY7KcfF/M65AIcmWC4GdG4xp\no0DoyTYPqgFjdyf+YMJnP8aFO2SBhGtSsPvkzPIFdPohe8p8B1bYAFBrAYvTy3jN\nxjElVfJvkyQ9iT4KBqQVCW8TzI4+GxrxfHScLNMhzububj40KTEHK0UYvTWe/tNf\n9bppzyk0F0lO5wF+fKxH2uNw0i2DcHWmunY1IaZ8Dpg3N9dKrdjVM3jobSQua7kw\n7BQwYy9hsON6xOd/ZXBdWLkrRAOCx8cxvBXau/dIlyrBi4t1EVR/C4+3jqpULyl3\n4isBD72ybGSqz8Qn3wFTspbMtp153h+XWuf9UNiyz/YPXw1p8g5vwCIkCqicNRGu\nfWqK7t5+NdXfNIEkaKXd1+zs3IgwcByEkdcxLxQYXPOqCEd8gAGBdbNikVJJumbu\ntV+Is9VhH9y7A58VJ0CexZ2VC8AkUclXDqunJ7se/IG8OlYwTtotDX7xJ33zyPIf\nHs0AbK8xV+VV4ADo/W9j9uxLlttYFtMNX0Wg7HnNvJKc675Fwrr8DgNBR3ljKRlY\nFQo49GCdYgFyRXB2Y0tB+0It8827PCoIdWK2yqaLBTteN9Y0vWeShYz/hTAWBKIE\n6vcCSi2mrYqgsnAF5f/M3wsVIP4MRMrXyZt/mGyT5FpZj2OCMJx2AzZ2Q+oDP+8s\nMrDJ4c5XMnqrfPeoQ+TzALvdf6iJ9ASycZdq7U2mUMTOxFZlgmVwZ5FZFdYlym/L\nq56lxfkz7ZfuYdSb1Lqq6y6VZ3cN73hXN/ih+yfvvPb/IkS5rEiY0NaW4LD+v/fY\nBy2hyvjys3P8kEQ3H31GTJATDC7iKx6JntlZgoCCoJmeq7MwHPjdhWRQZoI23MOt\nZxNMxQQrAjXWbF8RydHhZhRGvbbxDPsadNIycZ9wAycHBVzq2P56gG+OYMX9eYEg\nXbFM7SYPIa+hTLaxbRmhy1afsmyTDUMUthZH/1h/RNM6pUbZ8mEfo9gGEVcTuWt6\nAjXzHmxqKtzRZC8nE+RiY5KLQ8kC+CWbg88s0S0avu4SLHCSBnTlShyE23EQ4t66\nuWMKOcx5jH+noBLqSfwfOwieokeSvg354ncUk1cWO+DWvyyfNjDwbalOf+AZ409p\nsJI1RvYxmovYbfkV3kxKVbY4gmm9MLeSB3sS5OdMrqGtML32SC84ln3ZR0sw14u0\n3XjmLq1iLqnqbqBLTx650brVn50qVymqNgnTVIWnTCU/bqUFjIilSV+oiks7iwxA\n9RmEGqdtxcSDk6uLiDBCA3aMBk8PbkkNO3AnWLhsV5NJbBP6h2FCL/+1myCwCkvz\nx31F52Rgyp+6aJi0t3urzSg0V8AMtIRhqHirtkS4LFzq/u7lyYdcFgYk1xd3cDlF\nrMVZt0u2R9Li3N6eILGnPNADoGUr8DbQL4QCkH4FifEcTQRmlPgLxHtMUIu5dlH8\nBekg5BVG/KawpasapKzWBSzu4ql4zmsN7z+5lVTsRbINMRXj0t31xv2Bocn+C5lE\nzema7B4gv55plPCpO1YvYlWycwFQfF+GHkBotGTAStAiZ6iE8fyrKSNVgfwt0PCJ\nmaGMSz6mATyloRGa+hFJWg==\n-----END ENCRYPTED PRIVATE KEY-----\n"
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.523 0.014 1.537 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
