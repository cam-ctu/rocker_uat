
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "stringr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('stringr')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("case")
> ### * case
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: case
> ### Title: Convert string to upper case, lower case, title case, or
> ###   sentence case
> ### Aliases: case str_to_upper str_to_lower str_to_title str_to_sentence
> 
> ### ** Examples
> 
> dog <- "The quick brown dog"
> str_to_upper(dog)
[1] "THE QUICK BROWN DOG"
> str_to_lower(dog)
[1] "the quick brown dog"
> str_to_title(dog)
[1] "The Quick Brown Dog"
> str_to_sentence("the quick brown dog")
[1] "The quick brown dog"
> 
> # Locale matters!
> str_to_upper("i") # English
[1] "I"
> str_to_upper("i", "tr") # Turkish
[1] "İ"
> 
> 
> 
> cleanEx()
> nameEx("invert_match")
> ### * invert_match
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: invert_match
> ### Title: Switch location of matches to location of non-matches
> ### Aliases: invert_match
> 
> ### ** Examples
> 
> numbers <- "1 and 2 and 4 and 456"
> num_loc <- str_locate_all(numbers, "[0-9]+")[[1]]
> str_sub(numbers, num_loc[, "start"], num_loc[, "end"])
[1] "1"   "2"   "4"   "456"
> 
> text_loc <- invert_match(num_loc)
> str_sub(numbers, text_loc[, "start"], text_loc[, "end"])
[1] ""      " and " " and " " and " ""     
> 
> 
> 
> cleanEx()
> nameEx("modifiers")
> ### * modifiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: modifiers
> ### Title: Control matching behaviour with modifier functions
> ### Aliases: modifiers fixed coll regex boundary
> 
> ### ** Examples
> 
> pattern <- "a.b"
> strings <- c("abb", "a.b")
> str_detect(strings, pattern)
[1] TRUE TRUE
> str_detect(strings, fixed(pattern))
[1] FALSE  TRUE
> str_detect(strings, coll(pattern))
[1] FALSE  TRUE
> 
> # coll() is useful for locale-aware case-insensitive matching
> i <- c("I", "\u0130", "i")
> i
[1] "I" "İ" "i"
> str_detect(i, fixed("i", TRUE))
[1]  TRUE FALSE  TRUE
> str_detect(i, coll("i", TRUE))
[1]  TRUE FALSE  TRUE
> str_detect(i, coll("i", TRUE, locale = "tr"))
[1] FALSE  TRUE  TRUE
> 
> # Word boundaries
> words <- c("These are   some words.")
> str_count(words, boundary("word"))
[1] 4
> str_split(words, " ")[[1]]
[1] "These"  "are"    ""       ""       "some"   "words."
> str_split(words, boundary("word"))[[1]]
[1] "These" "are"   "some"  "words"
> 
> # Regular expression variations
> str_extract_all("The Cat in the Hat", "[a-z]+")
[[1]]
[1] "he"  "at"  "in"  "the" "at" 

> str_extract_all("The Cat in the Hat", regex("[a-z]+", TRUE))
[[1]]
[1] "The" "Cat" "in"  "the" "Hat"

> 
> str_extract_all("a\nb\nc", "^.")
[[1]]
[1] "a"

> str_extract_all("a\nb\nc", regex("^.", multiline = TRUE))
[[1]]
[1] "a" "b" "c"

> 
> str_extract_all("a\nb\nc", "a.")
[[1]]
character(0)

> str_extract_all("a\nb\nc", regex("a.", dotall = TRUE))
[[1]]
[1] "a\n"

> 
> 
> 
> cleanEx()
> nameEx("str_c")
> ### * str_c
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_c
> ### Title: Join multiple strings into one string
> ### Aliases: str_c
> 
> ### ** Examples
> 
> str_c("Letter: ", letters)
 [1] "Letter: a" "Letter: b" "Letter: c" "Letter: d" "Letter: e" "Letter: f"
 [7] "Letter: g" "Letter: h" "Letter: i" "Letter: j" "Letter: k" "Letter: l"
[13] "Letter: m" "Letter: n" "Letter: o" "Letter: p" "Letter: q" "Letter: r"
[19] "Letter: s" "Letter: t" "Letter: u" "Letter: v" "Letter: w" "Letter: x"
[25] "Letter: y" "Letter: z"
> str_c("Letter", letters, sep = ": ")
 [1] "Letter: a" "Letter: b" "Letter: c" "Letter: d" "Letter: e" "Letter: f"
 [7] "Letter: g" "Letter: h" "Letter: i" "Letter: j" "Letter: k" "Letter: l"
[13] "Letter: m" "Letter: n" "Letter: o" "Letter: p" "Letter: q" "Letter: r"
[19] "Letter: s" "Letter: t" "Letter: u" "Letter: v" "Letter: w" "Letter: x"
[25] "Letter: y" "Letter: z"
> str_c(letters, " is for", "...")
 [1] "a is for..." "b is for..." "c is for..." "d is for..." "e is for..."
 [6] "f is for..." "g is for..." "h is for..." "i is for..." "j is for..."
[11] "k is for..." "l is for..." "m is for..." "n is for..." "o is for..."
[16] "p is for..." "q is for..." "r is for..." "s is for..." "t is for..."
[21] "u is for..." "v is for..." "w is for..." "x is for..." "y is for..."
[26] "z is for..."
> str_c(letters[-26], " comes before ", letters[-1])
 [1] "a comes before b" "b comes before c" "c comes before d" "d comes before e"
 [5] "e comes before f" "f comes before g" "g comes before h" "h comes before i"
 [9] "i comes before j" "j comes before k" "k comes before l" "l comes before m"
[13] "m comes before n" "n comes before o" "o comes before p" "p comes before q"
[17] "q comes before r" "r comes before s" "s comes before t" "t comes before u"
[21] "u comes before v" "v comes before w" "w comes before x" "x comes before y"
[25] "y comes before z"
> 
> str_c(letters, collapse = "")
[1] "abcdefghijklmnopqrstuvwxyz"
> str_c(letters, collapse = ", ")
[1] "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z"
> 
> # Differences from paste() ----------------------
> # Missing inputs give missing outputs
> str_c(c("a", NA, "b"), "-d")
[1] "a-d" NA    "b-d"
> paste0(c("a", NA, "b"), "-d")
[1] "a-d"  "NA-d" "b-d" 
> # Use str_replace_NA to display literal NAs:
> str_c(str_replace_na(c("a", NA, "b")), "-d")
[1] "a-d"  "NA-d" "b-d" 
> 
> # Uses tidyverse recycling rules
> ## Not run: str_c(1:2, 1:3) # errors
> paste0(1:2, 1:3)
[1] "11" "22" "13"
> 
> str_c("x", character())
character(0)
> paste0("x", character())
[1] "x"
> 
> 
> 
> cleanEx()
> nameEx("str_conv")
> ### * str_conv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_conv
> ### Title: Specify the encoding of a string
> ### Aliases: str_conv
> 
> ### ** Examples
> 
> # Example from encoding?stringi::stringi
> x <- rawToChar(as.raw(177))
> x
[1] "\xb1"
> str_conv(x, "ISO-8859-2") # Polish "a with ogonek"
[1] "ą"
> str_conv(x, "ISO-8859-1") # Plus-minus
[1] "±"
> 
> 
> 
> cleanEx()
> nameEx("str_count")
> ### * str_count
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_count
> ### Title: Count number of matches
> ### Aliases: str_count
> 
> ### ** Examples
> 
> fruit <- c("apple", "banana", "pear", "pineapple")
> str_count(fruit, "a")
[1] 1 3 1 1
> str_count(fruit, "p")
[1] 2 0 1 3
> str_count(fruit, "e")
[1] 1 0 1 2
> str_count(fruit, c("a", "b", "p", "p"))
[1] 1 1 1 3
> 
> str_count(c("a.", "...", ".a.a"), ".")
[1] 2 3 4
> str_count(c("a.", "...", ".a.a"), fixed("."))
[1] 1 3 2
> 
> 
> 
> cleanEx()
> nameEx("str_detect")
> ### * str_detect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_detect
> ### Title: Detect the presence/absence of a match
> ### Aliases: str_detect
> 
> ### ** Examples
> 
> fruit <- c("apple", "banana", "pear", "pineapple")
> str_detect(fruit, "a")
[1] TRUE TRUE TRUE TRUE
> str_detect(fruit, "^a")
[1]  TRUE FALSE FALSE FALSE
> str_detect(fruit, "a$")
[1] FALSE  TRUE FALSE FALSE
> str_detect(fruit, "b")
[1] FALSE  TRUE FALSE FALSE
> str_detect(fruit, "[aeiou]")
[1] TRUE TRUE TRUE TRUE
> 
> # Also vectorised over pattern
> str_detect("aecfg", letters)
 [1]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[25] FALSE FALSE
> 
> # Returns TRUE if the pattern do NOT match
> str_detect(fruit, "^p", negate = TRUE)
[1]  TRUE  TRUE FALSE FALSE
> 
> 
> 
> cleanEx()
> nameEx("str_dup")
> ### * str_dup
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_dup
> ### Title: Duplicate a string
> ### Aliases: str_dup
> 
> ### ** Examples
> 
> fruit <- c("apple", "pear", "banana")
> str_dup(fruit, 2)
[1] "appleapple"   "pearpear"     "bananabanana"
> str_dup(fruit, 1:3)
[1] "apple"              "pearpear"           "bananabananabanana"
> str_c("ba", str_dup("na", 0:5))
[1] "ba"           "bana"         "banana"       "bananana"     "banananana"  
[6] "bananananana"
> 
> 
> 
> cleanEx()
> nameEx("str_equal")
> ### * str_equal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_equal
> ### Title: Determine if two strings are equivalent
> ### Aliases: str_equal
> 
> ### ** Examples
> 
> # These two strings encode "a" with an accent in two different ways
> a1 <- "\u00e1"
> a2 <- "a\u0301"
> c(a1, a2)
[1] "á" "á"
> 
> a1 == a2
[1] FALSE
> str_equal(a1, a2)
[1] TRUE
> 
> # ohm and omega use different code points but should always be treated
> # as equal
> ohm <- "\u2126"
> omega <- "\u03A9"
> c(ohm, omega)
[1] "Ω" "Ω"
> 
> ohm == omega
[1] FALSE
> str_equal(ohm, omega)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("str_escape")
> ### * str_escape
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_escape
> ### Title: Escape regular expression metacharacters
> ### Aliases: str_escape
> 
> ### ** Examples
> 
> str_detect(c("a", "."), ".")
[1] TRUE TRUE
> str_detect(c("a", "."), str_escape("."))
[1] FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("str_extract")
> ### * str_extract
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_extract
> ### Title: Extract the complete match
> ### Aliases: str_extract str_extract_all
> 
> ### ** Examples
> 
> shopping_list <- c("apples x4", "bag of flour", "bag of sugar", "milk x2")
> str_extract(shopping_list, "\\d")
[1] "4" NA  NA  "2"
> str_extract(shopping_list, "[a-z]+")
[1] "apples" "bag"    "bag"    "milk"  
> str_extract(shopping_list, "[a-z]{1,4}")
[1] "appl" "bag"  "bag"  "milk"
> str_extract(shopping_list, "\\b[a-z]{1,4}\\b")
[1] NA     "bag"  "bag"  "milk"
> 
> str_extract(shopping_list, "([a-z]+) of ([a-z]+)")
[1] NA             "bag of flour" "bag of sugar" NA            
> str_extract(shopping_list, "([a-z]+) of ([a-z]+)", group = 1)
[1] NA    "bag" "bag" NA   
> str_extract(shopping_list, "([a-z]+) of ([a-z]+)", group = 2)
[1] NA      "flour" "sugar" NA     
> 
> # Extract all matches
> str_extract_all(shopping_list, "[a-z]+")
[[1]]
[1] "apples" "x"     

[[2]]
[1] "bag"   "of"    "flour"

[[3]]
[1] "bag"   "of"    "sugar"

[[4]]
[1] "milk" "x"   

> str_extract_all(shopping_list, "\\b[a-z]+\\b")
[[1]]
[1] "apples"

[[2]]
[1] "bag"   "of"    "flour"

[[3]]
[1] "bag"   "of"    "sugar"

[[4]]
[1] "milk"

> str_extract_all(shopping_list, "\\d")
[[1]]
[1] "4"

[[2]]
character(0)

[[3]]
character(0)

[[4]]
[1] "2"

> 
> # Simplify results into character matrix
> str_extract_all(shopping_list, "\\b[a-z]+\\b", simplify = TRUE)
     [,1]     [,2] [,3]   
[1,] "apples" ""   ""     
[2,] "bag"    "of" "flour"
[3,] "bag"    "of" "sugar"
[4,] "milk"   ""   ""     
> str_extract_all(shopping_list, "\\d", simplify = TRUE)
     [,1]
[1,] "4" 
[2,] ""  
[3,] ""  
[4,] "2" 
> 
> # Extract all words
> str_extract_all("This is, suprisingly, a sentence.", boundary("word"))
[[1]]
[1] "This"        "is"          "suprisingly" "a"           "sentence"   

> 
> 
> 
> cleanEx()
> nameEx("str_flatten")
> ### * str_flatten
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_flatten
> ### Title: Flatten a string
> ### Aliases: str_flatten str_flatten_comma
> 
> ### ** Examples
> 
> str_flatten(letters)
[1] "abcdefghijklmnopqrstuvwxyz"
> str_flatten(letters, "-")
[1] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z"
> 
> str_flatten(letters[1:3], ", ")
[1] "a, b, c"
> 
> # Use last to customise the last component
> str_flatten(letters[1:3], ", ", " and ")
[1] "a, b and c"
> 
> # this almost works if you want an Oxford (aka serial) comma
> str_flatten(letters[1:3], ", ", ", and ")
[1] "a, b, and c"
> 
> # but it will always add a comma, even when not necessary
> str_flatten(letters[1:2], ", ", ", and ")
[1] "a, and b"
> 
> # str_flatten_comma knows how to handle the Oxford comma
> str_flatten_comma(letters[1:3], ", and ")
[1] "a, b, and c"
> str_flatten_comma(letters[1:2], ", and ")
[1] "a and b"
> 
> 
> 
> cleanEx()
> nameEx("str_glue")
> ### * str_glue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_glue
> ### Title: Interpolation with glue
> ### Aliases: str_glue str_glue_data
> 
> ### ** Examples
> 
> name <- "Fred"
> age <- 50
> anniversary <- as.Date("1991-10-12")
> str_glue(
+   "My name is {name}, ",
+   "my age next year is {age + 1}, ",
+   "and my anniversary is {format(anniversary, '%A, %B %d, %Y')}."
+ )
My name is Fred, my age next year is 51, and my anniversary is Saturday, October 12, 1991.
> 
> # single braces can be inserted by doubling them
> str_glue("My name is {name}, not {{name}}.")
My name is Fred, not {name}.
> 
> # You can also used named arguments
> str_glue(
+   "My name is {name}, ",
+   "and my age next year is {age + 1}.",
+   name = "Joe",
+   age = 40
+ )
My name is Joe, and my age next year is 41.
> 
> # `str_glue_data()` is useful in data pipelines
> mtcars %>% str_glue_data("{rownames(.)} has {hp} hp")
Mazda RX4 has 110 hp
Mazda RX4 Wag has 110 hp
Datsun 710 has 93 hp
Hornet 4 Drive has 110 hp
Hornet Sportabout has 175 hp
Valiant has 105 hp
Duster 360 has 245 hp
Merc 240D has 62 hp
Merc 230 has 95 hp
Merc 280 has 123 hp
Merc 280C has 123 hp
Merc 450SE has 180 hp
Merc 450SL has 180 hp
Merc 450SLC has 180 hp
Cadillac Fleetwood has 205 hp
Lincoln Continental has 215 hp
Chrysler Imperial has 230 hp
Fiat 128 has 66 hp
Honda Civic has 52 hp
Toyota Corolla has 65 hp
Toyota Corona has 97 hp
Dodge Challenger has 150 hp
AMC Javelin has 150 hp
Camaro Z28 has 245 hp
Pontiac Firebird has 175 hp
Fiat X1-9 has 66 hp
Porsche 914-2 has 91 hp
Lotus Europa has 113 hp
Ford Pantera L has 264 hp
Ferrari Dino has 175 hp
Maserati Bora has 335 hp
Volvo 142E has 109 hp
> 
> 
> 
> cleanEx()
> nameEx("str_interp")
> ### * str_interp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_interp
> ### Title: String interpolation
> ### Aliases: str_interp
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> # Using values from the environment, and some formats
> user_name <- "smbache"
> amount <- 6.656
> account <- 1337
> str_interp("User ${user_name} (account $[08d]{account}) has $$[.2f]{amount}.")
[1] "User smbache (account 00001337) has $6.66."
> 
> # Nested brace pairs work inside expressions too, and any braces can be
> # placed outside the expressions.
> str_interp("Works with } nested { braces too: $[.2f]{{{2 + 2}*{amount}}}")
[1] "Works with } nested { braces too: 26.62"
> 
> # Values can also come from a list
> str_interp(
+   "One value, ${value1}, and then another, ${value2*2}.",
+   list(value1 = 10, value2 = 20)
+ )
[1] "One value, 10, and then another, 40."
> 
> # Or a data frame
> str_interp(
+   "Values are $[.2f]{max(Sepal.Width)} and $[.2f]{min(Sepal.Width)}.",
+   iris
+ )
[1] "Values are 4.40 and 2.00."
> 
> # Use a vector when the string is long:
> max_char <- 80
> str_interp(c(
+   "This particular line is so long that it is hard to write ",
+   "without breaking the ${max_char}-char barrier!"
+ ))
[1] "This particular line is so long that it is hard to write without breaking the 80-char barrier!"
> 
> 
> 
> cleanEx()
> nameEx("str_length")
> ### * str_length
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_length
> ### Title: Compute the length/width
> ### Aliases: str_length str_width
> 
> ### ** Examples
> 
> str_length(letters)
 [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
> str_length(NA)
[1] NA
> str_length(factor("abc"))
[1] 3
> str_length(c("i", "like", "programming", NA))
[1]  1  4 11 NA
> 
> # Some characters, like emoji and Chinese characters (hanzi), are square
> # which means they take up the width of two Latin characters
> x <- c("\u6c49\u5b57", "\U0001f60a")
> str_view(x)
[1] │ 汉字
[2] │ 😊
> str_width(x)
[1] 4 2
> str_length(x)
[1] 2 1
> 
> # There are two ways of representing a u with an umlaut
> u <- c("\u00fc", "u\u0308")
> # They have the same width
> str_width(u)
[1] 1 1
> # But a different length
> str_length(u)
[1] 1 2
> # Because the second element is made up of a u + an accent
> str_sub(u, 1, 1)
[1] "ü" "u"
> 
> 
> 
> cleanEx()
> nameEx("str_like")
> ### * str_like
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_like
> ### Title: Detect a pattern in the same way as 'SQL"s 'LIKE' operator
> ### Aliases: str_like
> 
> ### ** Examples
> 
> fruit <- c("apple", "banana", "pear", "pineapple")
> str_like(fruit, "app")
[1] FALSE FALSE FALSE FALSE
> str_like(fruit, "app%")
[1]  TRUE FALSE FALSE FALSE
> str_like(fruit, "ba_ana")
[1] FALSE  TRUE FALSE FALSE
> str_like(fruit, "%APPLE")
[1]  TRUE FALSE FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("str_locate")
> ### * str_locate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_locate
> ### Title: Find location of match
> ### Aliases: str_locate str_locate_all
> 
> ### ** Examples
> 
> fruit <- c("apple", "banana", "pear", "pineapple")
> str_locate(fruit, "$")
     start end
[1,]     6   5
[2,]     7   6
[3,]     5   4
[4,]    10   9
> str_locate(fruit, "a")
     start end
[1,]     1   1
[2,]     2   2
[3,]     3   3
[4,]     5   5
> str_locate(fruit, "e")
     start end
[1,]     5   5
[2,]    NA  NA
[3,]     2   2
[4,]     4   4
> str_locate(fruit, c("a", "b", "p", "p"))
     start end
[1,]     1   1
[2,]     1   1
[3,]     1   1
[4,]     1   1
> 
> str_locate_all(fruit, "a")
[[1]]
     start end
[1,]     1   1

[[2]]
     start end
[1,]     2   2
[2,]     4   4
[3,]     6   6

[[3]]
     start end
[1,]     3   3

[[4]]
     start end
[1,]     5   5

> str_locate_all(fruit, "e")
[[1]]
     start end
[1,]     5   5

[[2]]
     start end

[[3]]
     start end
[1,]     2   2

[[4]]
     start end
[1,]     4   4
[2,]     9   9

> str_locate_all(fruit, c("a", "b", "p", "p"))
[[1]]
     start end
[1,]     1   1

[[2]]
     start end
[1,]     1   1

[[3]]
     start end
[1,]     1   1

[[4]]
     start end
[1,]     1   1
[2,]     6   6
[3,]     7   7

> 
> # Find location of every character
> str_locate_all(fruit, "")
[[1]]
     start end
[1,]     1   1
[2,]     2   2
[3,]     3   3
[4,]     4   4
[5,]     5   5

[[2]]
     start end
[1,]     1   1
[2,]     2   2
[3,]     3   3
[4,]     4   4
[5,]     5   5
[6,]     6   6

[[3]]
     start end
[1,]     1   1
[2,]     2   2
[3,]     3   3
[4,]     4   4

[[4]]
      start end
 [1,]     1   1
 [2,]     2   2
 [3,]     3   3
 [4,]     4   4
 [5,]     5   5
 [6,]     6   6
 [7,]     7   7
 [8,]     8   8
 [9,]     9   9

> 
> 
> 
> cleanEx()
> nameEx("str_match")
> ### * str_match
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_match
> ### Title: Extract components (capturing groups) from a match
> ### Aliases: str_match str_match_all
> 
> ### ** Examples
> 
> strings <- c(" 219 733 8965", "329-293-8753 ", "banana", "595 794 7569",
+   "387 287 6718", "apple", "233.398.9187  ", "482 952 3315",
+   "239 923 8115 and 842 566 4692", "Work: 579-499-7527", "$1000",
+   "Home: 543.355.3679")
> phone <- "([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"
> 
> str_extract(strings, phone)
 [1] "219 733 8965" "329-293-8753" NA             "595 794 7569" "387 287 6718"
 [6] NA             "233.398.9187" "482 952 3315" "239 923 8115" "579-499-7527"
[11] NA             "543.355.3679"
> str_match(strings, phone)
      [,1]           [,2]  [,3]  [,4]  
 [1,] "219 733 8965" "219" "733" "8965"
 [2,] "329-293-8753" "329" "293" "8753"
 [3,] NA             NA    NA    NA    
 [4,] "595 794 7569" "595" "794" "7569"
 [5,] "387 287 6718" "387" "287" "6718"
 [6,] NA             NA    NA    NA    
 [7,] "233.398.9187" "233" "398" "9187"
 [8,] "482 952 3315" "482" "952" "3315"
 [9,] "239 923 8115" "239" "923" "8115"
[10,] "579-499-7527" "579" "499" "7527"
[11,] NA             NA    NA    NA    
[12,] "543.355.3679" "543" "355" "3679"
> 
> # Extract/match all
> str_extract_all(strings, phone)
[[1]]
[1] "219 733 8965"

[[2]]
[1] "329-293-8753"

[[3]]
character(0)

[[4]]
[1] "595 794 7569"

[[5]]
[1] "387 287 6718"

[[6]]
character(0)

[[7]]
[1] "233.398.9187"

[[8]]
[1] "482 952 3315"

[[9]]
[1] "239 923 8115" "842 566 4692"

[[10]]
[1] "579-499-7527"

[[11]]
character(0)

[[12]]
[1] "543.355.3679"

> str_match_all(strings, phone)
[[1]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "219 733 8965" "219" "733" "8965"

[[2]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "329-293-8753" "329" "293" "8753"

[[3]]
     [,1] [,2] [,3] [,4]

[[4]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "595 794 7569" "595" "794" "7569"

[[5]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "387 287 6718" "387" "287" "6718"

[[6]]
     [,1] [,2] [,3] [,4]

[[7]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "233.398.9187" "233" "398" "9187"

[[8]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "482 952 3315" "482" "952" "3315"

[[9]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "239 923 8115" "239" "923" "8115"
[2,] "842 566 4692" "842" "566" "4692"

[[10]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "579-499-7527" "579" "499" "7527"

[[11]]
     [,1] [,2] [,3] [,4]

[[12]]
     [,1]           [,2]  [,3]  [,4]  
[1,] "543.355.3679" "543" "355" "3679"

> 
> # You can also name the groups to make further manipulation easier
> phone <- "(?<area>[2-9][0-9]{2})[- .](?<phone>[0-9]{3}[- .][0-9]{4})"
> str_match(strings, phone)
                     area  phone     
 [1,] "219 733 8965" "219" "733 8965"
 [2,] "329-293-8753" "329" "293-8753"
 [3,] NA             NA    NA        
 [4,] "595 794 7569" "595" "794 7569"
 [5,] "387 287 6718" "387" "287 6718"
 [6,] NA             NA    NA        
 [7,] "233.398.9187" "233" "398.9187"
 [8,] "482 952 3315" "482" "952 3315"
 [9,] "239 923 8115" "239" "923 8115"
[10,] "579-499-7527" "579" "499-7527"
[11,] NA             NA    NA        
[12,] "543.355.3679" "543" "355.3679"
> 
> x <- c("<a> <b>", "<a> <>", "<a>", "", NA)
> str_match(x, "<(.*?)> <(.*?)>")
     [,1]      [,2] [,3]
[1,] "<a> <b>" "a"  "b" 
[2,] "<a> <>"  "a"  ""  
[3,] NA        NA   NA  
[4,] NA        NA   NA  
[5,] NA        NA   NA  
> str_match_all(x, "<(.*?)>")
[[1]]
     [,1]  [,2]
[1,] "<a>" "a" 
[2,] "<b>" "b" 

[[2]]
     [,1]  [,2]
[1,] "<a>" "a" 
[2,] "<>"  ""  

[[3]]
     [,1]  [,2]
[1,] "<a>" "a" 

[[4]]
     [,1] [,2]

[[5]]
     [,1] [,2]
[1,] NA   NA  

> 
> str_extract(x, "<.*?>")
[1] "<a>" "<a>" "<a>" NA    NA   
> str_extract_all(x, "<.*?>")
[[1]]
[1] "<a>" "<b>"

[[2]]
[1] "<a>" "<>" 

[[3]]
[1] "<a>"

[[4]]
character(0)

[[5]]
[1] NA

> 
> 
> 
> cleanEx()
> nameEx("str_order")
> ### * str_order
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_order
> ### Title: Order, rank, or sort a character vector
> ### Aliases: str_order str_rank str_sort
> 
> ### ** Examples
> 
> x <- c("apple", "car", "happy", "char")
> str_sort(x)
[1] "apple" "car"   "char"  "happy"
> 
> str_order(x)
[1] 1 2 4 3
> x[str_order(x)]
[1] "apple" "car"   "char"  "happy"
> 
> str_rank(x)
[1] 1 2 4 3
> 
> # In Czech, ch is a digraph that sorts after h
> str_sort(x, locale = "cs")
[1] "apple" "car"   "happy" "char" 
> 
> # Use numeric = TRUE to sort numbers in strings
> x <- c("100a10", "100a5", "2b", "2a")
> str_sort(x)
[1] "100a10" "100a5"  "2a"     "2b"    
> str_sort(x, numeric = TRUE)
[1] "2a"     "2b"     "100a5"  "100a10"
> 
> 
> 
> cleanEx()
> nameEx("str_pad")
> ### * str_pad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_pad
> ### Title: Pad a string to minimum width
> ### Aliases: str_pad
> 
> ### ** Examples
> 
> rbind(
+   str_pad("hadley", 30, "left"),
+   str_pad("hadley", 30, "right"),
+   str_pad("hadley", 30, "both")
+ )
     [,1]                            
[1,] "                        hadley"
[2,] "hadley                        "
[3,] "            hadley            "
> 
> # All arguments are vectorised except side
> str_pad(c("a", "abc", "abcdef"), 10)
[1] "         a" "       abc" "    abcdef"
> str_pad("a", c(5, 10, 20))
[1] "    a"                "         a"           "                   a"
> str_pad("a", 10, pad = c("-", "_", " "))
[1] "---------a" "_________a" "         a"
> 
> # Longer strings are returned unchanged
> str_pad("hadley", 3)
[1] "hadley"
> 
> 
> 
> cleanEx()
> nameEx("str_remove")
> ### * str_remove
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_remove
> ### Title: Remove matched patterns
> ### Aliases: str_remove str_remove_all
> 
> ### ** Examples
> 
> fruits <- c("one apple", "two pears", "three bananas")
> str_remove(fruits, "[aeiou]")
[1] "ne apple"     "tw pears"     "thre bananas"
> str_remove_all(fruits, "[aeiou]")
[1] "n ppl"    "tw prs"   "thr bnns"
> 
> 
> 
> cleanEx()
> nameEx("str_replace")
> ### * str_replace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_replace
> ### Title: Replace matches with new text
> ### Aliases: str_replace str_replace_all
> 
> ### ** Examples
> 
> fruits <- c("one apple", "two pears", "three bananas")
> str_replace(fruits, "[aeiou]", "-")
[1] "-ne apple"     "tw- pears"     "thr-e bananas"
> str_replace_all(fruits, "[aeiou]", "-")
[1] "-n- -ppl-"     "tw- p--rs"     "thr-- b-n-n-s"
> str_replace_all(fruits, "[aeiou]", toupper)
[1] "OnE ApplE"     "twO pEArs"     "thrEE bAnAnAs"
> str_replace_all(fruits, "b", NA_character_)
[1] "one apple" "two pears" NA         
> 
> str_replace(fruits, "([aeiou])", "")
[1] "ne apple"     "tw pears"     "thre bananas"
> str_replace(fruits, "([aeiou])", "\\1\\1")
[1] "oone apple"     "twoo pears"     "threee bananas"
> 
> # Note that str_replace() is vectorised along text, pattern, and replacement
> str_replace(fruits, "[aeiou]", c("1", "2", "3"))
[1] "1ne apple"     "tw2 pears"     "thr3e bananas"
> str_replace(fruits, c("a", "e", "i"), "-")
[1] "one -pple"     "two p-ars"     "three bananas"
> 
> # If you want to apply multiple patterns and replacements to the same
> # string, pass a named vector to pattern.
> fruits %>%
+   str_c(collapse = "---") %>%
+   str_replace_all(c("one" = "1", "two" = "2", "three" = "3"))
[1] "1 apple---2 pears---3 bananas"
> 
> # Use a function for more sophisticated replacement. This example
> # replaces colour names with their hex values.
> colours <- str_c("\\b", colors(), "\\b", collapse="|")
> col2hex <- function(col) {
+   rgb <- col2rgb(col)
+   rgb(rgb["red", ], rgb["green", ], rgb["blue", ], max = 255)
+ }
> 
> x <- c(
+   "Roses are red, violets are blue",
+   "My favourite colour is green"
+ )
> str_replace_all(x, colours, col2hex)
[1] "Roses are #FF0000, violets are #0000FF"
[2] "My favourite colour is #00FF00"        
> 
> 
> 
> cleanEx()
> nameEx("str_replace_na")
> ### * str_replace_na
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_replace_na
> ### Title: Turn NA into "NA"
> ### Aliases: str_replace_na
> 
> ### ** Examples
> 
> str_replace_na(c(NA, "abc", "def"))
[1] "NA"  "abc" "def"
> 
> 
> 
> cleanEx()
> nameEx("str_split")
> ### * str_split
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_split
> ### Title: Split up a string into pieces
> ### Aliases: str_split str_split_1 str_split_fixed str_split_i
> 
> ### ** Examples
> 
> fruits <- c(
+   "apples and oranges and pears and bananas",
+   "pineapples and mangos and guavas"
+ )
> 
> str_split(fruits, " and ")
[[1]]
[1] "apples"  "oranges" "pears"   "bananas"

[[2]]
[1] "pineapples" "mangos"     "guavas"    

> str_split(fruits, " and ", simplify = TRUE)
     [,1]         [,2]      [,3]     [,4]     
[1,] "apples"     "oranges" "pears"  "bananas"
[2,] "pineapples" "mangos"  "guavas" ""       
> 
> # If you want to split a single string, use `str_split_1`
> str_split_1(fruits[[1]], " and ")
[1] "apples"  "oranges" "pears"   "bananas"
> 
> # Specify n to restrict the number of possible matches
> str_split(fruits, " and ", n = 3)
[[1]]
[1] "apples"            "oranges"           "pears and bananas"

[[2]]
[1] "pineapples" "mangos"     "guavas"    

> str_split(fruits, " and ", n = 2)
[[1]]
[1] "apples"                        "oranges and pears and bananas"

[[2]]
[1] "pineapples"        "mangos and guavas"

> # If n greater than number of pieces, no padding occurs
> str_split(fruits, " and ", n = 5)
[[1]]
[1] "apples"  "oranges" "pears"   "bananas"

[[2]]
[1] "pineapples" "mangos"     "guavas"    

> 
> # Use fixed to return a character matrix
> str_split_fixed(fruits, " and ", 3)
     [,1]         [,2]      [,3]               
[1,] "apples"     "oranges" "pears and bananas"
[2,] "pineapples" "mangos"  "guavas"           
> str_split_fixed(fruits, " and ", 4)
     [,1]         [,2]      [,3]     [,4]     
[1,] "apples"     "oranges" "pears"  "bananas"
[2,] "pineapples" "mangos"  "guavas" ""       
> 
> # str_split_i extracts only a single piece from a string
> str_split_i(fruits, " and ", 1)
[1] "apples"     "pineapples"
> str_split_i(fruits, " and ", 4)
[1] "bananas" NA       
> # use a negative number to select from the end
> str_split_i(fruits, " and ", -1)
[1] "bananas" "guavas" 
> 
> 
> 
> cleanEx()
> nameEx("str_starts")
> ### * str_starts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_starts
> ### Title: Detect the presence/absence of a match at the start/end
> ### Aliases: str_starts str_ends
> 
> ### ** Examples
> 
> fruit <- c("apple", "banana", "pear", "pineapple")
> str_starts(fruit, "p")
[1] FALSE FALSE  TRUE  TRUE
> str_starts(fruit, "p", negate = TRUE)
[1]  TRUE  TRUE FALSE FALSE
> str_ends(fruit, "e")
[1]  TRUE FALSE FALSE  TRUE
> str_ends(fruit, "e", negate = TRUE)
[1] FALSE  TRUE  TRUE FALSE
> 
> 
> 
> cleanEx()
> nameEx("str_sub")
> ### * str_sub
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_sub
> ### Title: Get and set substrings using their positions
> ### Aliases: str_sub str_sub<- str_sub_all
> 
> ### ** Examples
> 
> hw <- "Hadley Wickham"
> 
> str_sub(hw, 1, 6)
[1] "Hadley"
> str_sub(hw, end = 6)
[1] "Hadley"
> str_sub(hw, 8, 14)
[1] "Wickham"
> str_sub(hw, 8)
[1] "Wickham"
> 
> # Negative indices index from end of string
> str_sub(hw, -1)
[1] "m"
> str_sub(hw, -7)
[1] "Wickham"
> str_sub(hw, end = -7)
[1] "Hadley W"
> 
> # str_sub() is vectorised by both string and position
> str_sub(hw, c(1, 8), c(6, 14))
[1] "Hadley"  "Wickham"
> 
> # if you want to extract multiple positions from multiple strings,
> # use str_sub_all()
> x <- c("abcde", "ghifgh")
> str_sub(x, c(1, 2), c(2, 4))
[1] "ab"  "hif"
> str_sub_all(x, start = c(1, 2), end = c(2, 4))
[[1]]
[1] "ab"  "bcd"

[[2]]
[1] "gh"  "hif"

> 
> # Alternatively, you can pass in a two column matrix, as in the
> # output from str_locate_all
> pos <- str_locate_all(hw, "[aeio]")[[1]]
> pos
     start end
[1,]     2   2
[2,]     5   5
[3,]     9   9
[4,]    13  13
> str_sub(hw, pos)
[1] "a" "e" "i" "a"
> 
> # You can also use `str_sub()` to modify strings:
> x <- "BBCDEF"
> str_sub(x, 1, 1) <- "A"; x
[1] "ABCDEF"
> str_sub(x, -1, -1) <- "K"; x
[1] "ABCDEK"
> str_sub(x, -2, -2) <- "GHIJ"; x
[1] "ABCDGHIJK"
> str_sub(x, 2, -2) <- ""; x
[1] "AK"
> 
> 
> 
> cleanEx()
> nameEx("str_subset")
> ### * str_subset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_subset
> ### Title: Find matching elements
> ### Aliases: str_subset
> 
> ### ** Examples
> 
> fruit <- c("apple", "banana", "pear", "pineapple")
> str_subset(fruit, "a")
[1] "apple"     "banana"    "pear"      "pineapple"
> 
> str_subset(fruit, "^a")
[1] "apple"
> str_subset(fruit, "a$")
[1] "banana"
> str_subset(fruit, "b")
[1] "banana"
> str_subset(fruit, "[aeiou]")
[1] "apple"     "banana"    "pear"      "pineapple"
> 
> # Elements that don't match
> str_subset(fruit, "^p", negate = TRUE)
[1] "apple"  "banana"
> 
> # Missings never match
> str_subset(c("a", NA, "b"), ".")
[1] "a" "b"
> 
> 
> 
> cleanEx()
> nameEx("str_trim")
> ### * str_trim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_trim
> ### Title: Remove whitespace
> ### Aliases: str_trim str_squish
> 
> ### ** Examples
> 
> str_trim("  String with trailing and leading white space\t")
[1] "String with trailing and leading white space"
> str_trim("\n\nString with trailing and leading white space\n\n")
[1] "String with trailing and leading white space"
> 
> str_squish("  String with trailing,  middle, and leading white space\t")
[1] "String with trailing, middle, and leading white space"
> str_squish("\n\nString with excess,  trailing and leading white   space\n\n")
[1] "String with excess, trailing and leading white space"
> 
> 
> 
> cleanEx()
> nameEx("str_trunc")
> ### * str_trunc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_trunc
> ### Title: Truncate a string to maximum width
> ### Aliases: str_trunc
> 
> ### ** Examples
> 
> x <- "This string is moderately long"
> rbind(
+   str_trunc(x, 20, "right"),
+   str_trunc(x, 20, "left"),
+   str_trunc(x, 20, "center")
+ )
     [,1]                  
[1,] "This string is mo..."
[2,] "...s moderately long"
[3,] "This stri...ely long"
> 
> 
> 
> cleanEx()
> nameEx("str_unique")
> ### * str_unique
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_unique
> ### Title: Remove duplicated strings
> ### Aliases: str_unique
> 
> ### ** Examples
> 
> str_unique(c("a", "b", "c", "b", "a"))
[1] "a" "b" "c"
> 
> str_unique(c("a", "b", "c", "B", "A"))
[1] "a" "b" "c" "B" "A"
> str_unique(c("a", "b", "c", "B", "A"), ignore_case = TRUE)
[1] "a" "b" "c"
> 
> # Use ... to pass additional arguments to stri_unique()
> str_unique(c("motley", "mötley", "pinguino", "pingüino"))
[1] "motley"   "mötley"   "pinguino" "pingüino"
> str_unique(c("motley", "mötley", "pinguino", "pingüino"), strength = 1)
[1] "motley"   "pinguino"
> 
> 
> 
> cleanEx()
> nameEx("str_view")
> ### * str_view
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_view
> ### Title: View strings and matches
> ### Aliases: str_view str_view_all
> 
> ### ** Examples
> 
> # Show special characters
> str_view(c("\"\\", "\\\\\\", "fgh", NA, "NA"))
[1] │ "\
[2] │ \\\
[3] │ fgh
[4] │ NA
[5] │ NA
> 
> # A non-breaking space looks like a regular space:
> nbsp <- "Hi\u00A0you"
> nbsp
[1] "Hi you"
> # But it doesn't behave like one:
> str_detect(nbsp, " ")
[1] FALSE
> # So str_view() brings it to your attention with a blue background
> str_view(nbsp)
[1] │ Hi{\u00a0}you
> 
> # You can also use escapes to see all non-ASCII characters
> str_view(nbsp, use_escapes = TRUE)
[1] │ Hi\u00a0you
> 
> # Supply a pattern to see where it matches
> str_view(c("abc", "def", "fghi"), "[aeiou]")
[1] │ <a>bc
[2] │ d<e>f
[3] │ fgh<i>
> str_view(c("abc", "def", "fghi"), "^")
[1] │ <>abc
[2] │ <>def
[3] │ <>fghi
> str_view(c("abc", "def", "fghi"), "..")
[1] │ <ab>c
[2] │ <de>f
[3] │ <fg><hi>
> 
> # By default, only matching strings will be shown
> str_view(c("abc", "def", "fghi"), "e")
[2] │ d<e>f
> # but you can show all:
> str_view(c("abc", "def", "fghi"), "e", match = NA)
[1] │ abc
[2] │ d<e>f
[3] │ fghi
> # or just those that don't match:
> str_view(c("abc", "def", "fghi"), "e", match = FALSE)
[1] │ abc
[3] │ fghi
> 
> 
> 
> cleanEx()
> nameEx("str_which")
> ### * str_which
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_which
> ### Title: Find matching indices
> ### Aliases: str_which
> 
> ### ** Examples
> 
> fruit <- c("apple", "banana", "pear", "pineapple")
> str_which(fruit, "a")
[1] 1 2 3 4
> 
> # Elements that don't match
> str_which(fruit, "^p", negate = TRUE)
[1] 1 2
> 
> # Missings never match
> str_which(c("a", NA, "b"), ".")
[1] 1 3
> 
> 
> 
> cleanEx()
> nameEx("str_wrap")
> ### * str_wrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_wrap
> ### Title: Wrap words into nicely formatted paragraphs
> ### Aliases: str_wrap
> 
> ### ** Examples
> 
> thanks_path <- file.path(R.home("doc"), "THANKS")
> thanks <- str_c(readLines(thanks_path), collapse = "\n")
> thanks <- word(thanks, 1, 3, fixed("\n\n"))
> cat(str_wrap(thanks), "\n")
R would not be what it is today without the invaluable help of these people
outside of the (former and current) R Core team, who contributed by donating
code, bug fixes and documentation: Valerio Aimale, Suharto Anggono, Thomas
Baier, Gabe Becker, Henrik Bengtsson, Roger Bivand, Ben Bolker, David Brahm,
G"oran Brostr"om, Patrick Burns, Vince Carey, Saikat DebRoy, Matt Dowle, Brian
D'Urso, Lyndon Drake, Dirk Eddelbuettel, Claus Ekstrom, Sebastian Fischmeister,
John Fox, Paul Gilbert, Yu Gong, Gabor Grothendieck, Frank E Harrell Jr, Peter
M. Haverty, Torsten Hothorn, Robert King, Kjetil Kjernsmo, Roger Koenker,
Philippe Lambert, Jan de Leeuw, Jim Lindsey, Patrick Lindsey, Catherine Loader,
Gordon Maclean, Arni Magnusson, John Maindonald, David Meyer, Ei-ji Nakama,
Jens Oehlschl"agel, Steve Oncley, Richard O'Keefe, Hubert Palme, Roger D. Peng,
Jose' C. Pinheiro, Tony Plate, Anthony Rossini, Jonathan Rougier, Petr Savicky,
Guenther Sawitzki, Marc Schwartz, Arun Srinivasan, Detlef Steuer, Bill Simpson,
Gordon Smyth, Adrian Trapletti, Terry Therneau, Rolf Turner, Bill Venables,
Gregory R. Warnes, Andreas Weingessel, Morten Welinder, James Wettenhall, Simon
Wood, and Achim Zeileis. Others have written code that has been adopted by R and
is acknowledged in the code files, including 
> cat(str_wrap(thanks, width = 40), "\n")
R would not be what it is today without
the invaluable help of these people
outside of the (former and current) R
Core team, who contributed by donating
code, bug fixes and documentation:
Valerio Aimale, Suharto Anggono, Thomas
Baier, Gabe Becker, Henrik Bengtsson,
Roger Bivand, Ben Bolker, David Brahm,
G"oran Brostr"om, Patrick Burns, Vince
Carey, Saikat DebRoy, Matt Dowle,
Brian D'Urso, Lyndon Drake, Dirk
Eddelbuettel, Claus Ekstrom, Sebastian
Fischmeister, John Fox, Paul Gilbert,
Yu Gong, Gabor Grothendieck, Frank E
Harrell Jr, Peter M. Haverty, Torsten
Hothorn, Robert King, Kjetil Kjernsmo,
Roger Koenker, Philippe Lambert, Jan
de Leeuw, Jim Lindsey, Patrick Lindsey,
Catherine Loader, Gordon Maclean,
Arni Magnusson, John Maindonald,
David Meyer, Ei-ji Nakama, Jens
Oehlschl"agel, Steve Oncley, Richard
O'Keefe, Hubert Palme, Roger D. Peng,
Jose' C. Pinheiro, Tony Plate, Anthony
Rossini, Jonathan Rougier, Petr Savicky,
Guenther Sawitzki, Marc Schwartz, Arun
Srinivasan, Detlef Steuer, Bill Simpson,
Gordon Smyth, Adrian Trapletti, Terry
Therneau, Rolf Turner, Bill Venables,
Gregory R. Warnes, Andreas Weingessel,
Morten Welinder, James Wettenhall, Simon
Wood, and Achim Zeileis. Others have
written code that has been adopted by R
and is acknowledged in the code files,
including 
> cat(str_wrap(thanks, width = 60, indent = 2), "\n")
  R would not be what it is today without the invaluable
help of these people outside of the (former and current)
R Core team, who contributed by donating code, bug fixes
and documentation: Valerio Aimale, Suharto Anggono, Thomas
Baier, Gabe Becker, Henrik Bengtsson, Roger Bivand, Ben
Bolker, David Brahm, G"oran Brostr"om, Patrick Burns,
Vince Carey, Saikat DebRoy, Matt Dowle, Brian D'Urso,
Lyndon Drake, Dirk Eddelbuettel, Claus Ekstrom, Sebastian
Fischmeister, John Fox, Paul Gilbert, Yu Gong, Gabor
Grothendieck, Frank E Harrell Jr, Peter M. Haverty,
Torsten Hothorn, Robert King, Kjetil Kjernsmo, Roger
Koenker, Philippe Lambert, Jan de Leeuw, Jim Lindsey,
Patrick Lindsey, Catherine Loader, Gordon Maclean, Arni
Magnusson, John Maindonald, David Meyer, Ei-ji Nakama,
Jens Oehlschl"agel, Steve Oncley, Richard O'Keefe, Hubert
Palme, Roger D. Peng, Jose' C. Pinheiro, Tony Plate, Anthony
Rossini, Jonathan Rougier, Petr Savicky, Guenther Sawitzki,
Marc Schwartz, Arun Srinivasan, Detlef Steuer, Bill Simpson,
Gordon Smyth, Adrian Trapletti, Terry Therneau, Rolf Turner,
Bill Venables, Gregory R. Warnes, Andreas Weingessel, Morten
Welinder, James Wettenhall, Simon Wood, and Achim Zeileis.
Others have written code that has been adopted by R and is
acknowledged in the code files, including 
> cat(str_wrap(thanks, width = 60, exdent = 2), "\n")
R would not be what it is today without the invaluable help
  of these people outside of the (former and current) R
  Core team, who contributed by donating code, bug fixes
  and documentation: Valerio Aimale, Suharto Anggono, Thomas
  Baier, Gabe Becker, Henrik Bengtsson, Roger Bivand, Ben
  Bolker, David Brahm, G"oran Brostr"om, Patrick Burns,
  Vince Carey, Saikat DebRoy, Matt Dowle, Brian D'Urso,
  Lyndon Drake, Dirk Eddelbuettel, Claus Ekstrom, Sebastian
  Fischmeister, John Fox, Paul Gilbert, Yu Gong, Gabor
  Grothendieck, Frank E Harrell Jr, Peter M. Haverty,
  Torsten Hothorn, Robert King, Kjetil Kjernsmo, Roger
  Koenker, Philippe Lambert, Jan de Leeuw, Jim Lindsey,
  Patrick Lindsey, Catherine Loader, Gordon Maclean, Arni
  Magnusson, John Maindonald, David Meyer, Ei-ji Nakama,
  Jens Oehlschl"agel, Steve Oncley, Richard O'Keefe, Hubert
  Palme, Roger D. Peng, Jose' C. Pinheiro, Tony Plate,
  Anthony Rossini, Jonathan Rougier, Petr Savicky, Guenther
  Sawitzki, Marc Schwartz, Arun Srinivasan, Detlef Steuer,
  Bill Simpson, Gordon Smyth, Adrian Trapletti, Terry
  Therneau, Rolf Turner, Bill Venables, Gregory R. Warnes,
  Andreas Weingessel, Morten Welinder, James Wettenhall,
  Simon Wood, and Achim Zeileis. Others have written code
  that has been adopted by R and is acknowledged in the code
  files, including 
> cat(str_wrap(thanks, width = 0, exdent = 2), "\n")
R
  would
  not
  be
  what
  it
  is
  today
  without
  the
  invaluable
  help
  of
  these
  people
  outside
  of
  the
  (former
  and
  current)
  R
  Core
  team,
  who
  contributed
  by
  donating
  code,
  bug
  fixes
  and
  documentation:
  Valerio
  Aimale,
  Suharto
  Anggono,
  Thomas
  Baier,
  Gabe
  Becker,
  Henrik
  Bengtsson,
  Roger
  Bivand,
  Ben
  Bolker,
  David
  Brahm,
  G"oran
  Brostr"om,
  Patrick
  Burns,
  Vince
  Carey,
  Saikat
  DebRoy,
  Matt
  Dowle,
  Brian
  D'Urso,
  Lyndon
  Drake,
  Dirk
  Eddelbuettel,
  Claus
  Ekstrom,
  Sebastian
  Fischmeister,
  John
  Fox,
  Paul
  Gilbert,
  Yu
  Gong,
  Gabor
  Grothendieck,
  Frank
  E
  Harrell
  Jr,
  Peter
  M.
  Haverty,
  Torsten
  Hothorn,
  Robert
  King,
  Kjetil
  Kjernsmo,
  Roger
  Koenker,
  Philippe
  Lambert,
  Jan
  de
  Leeuw,
  Jim
  Lindsey,
  Patrick
  Lindsey,
  Catherine
  Loader,
  Gordon
  Maclean,
  Arni
  Magnusson,
  John
  Maindonald,
  David
  Meyer,
  Ei-ji
  Nakama,
  Jens
  Oehlschl"agel,
  Steve
  Oncley,
  Richard
  O'Keefe,
  Hubert
  Palme,
  Roger
  D.
  Peng,
  Jose'
  C.
  Pinheiro,
  Tony
  Plate,
  Anthony
  Rossini,
  Jonathan
  Rougier,
  Petr
  Savicky,
  Guenther
  Sawitzki,
  Marc
  Schwartz,
  Arun
  Srinivasan,
  Detlef
  Steuer,
  Bill
  Simpson,
  Gordon
  Smyth,
  Adrian
  Trapletti,
  Terry
  Therneau,
  Rolf
  Turner,
  Bill
  Venables,
  Gregory
  R.
  Warnes,
  Andreas
  Weingessel,
  Morten
  Welinder,
  James
  Wettenhall,
  Simon
  Wood,
  and
  Achim
  Zeileis.
  Others
  have
  written
  code
  that
  has
  been
  adopted
  by
  R
  and
  is
  acknowledged
  in
  the
  code
  files,
  including 
> 
> 
> 
> cleanEx()
> nameEx("stringr-data")
> ### * stringr-data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stringr-data
> ### Title: Sample character vectors for practicing string manipulations
> ### Aliases: stringr-data sentences fruit words
> ### Keywords: datasets
> 
> ### ** Examples
> 
> length(sentences)
[1] 720
> sentences[1:5]
[1] "The birch canoe slid on the smooth planks." 
[2] "Glue the sheet to the dark blue background."
[3] "It's easy to tell the depth of a well."     
[4] "These days a chicken leg is a rare dish."   
[5] "Rice is often served in round bowls."       
> 
> length(fruit)
[1] 80
> fruit[1:5]
[1] "apple"       "apricot"     "avocado"     "banana"      "bell pepper"
> 
> length(words)
[1] 980
> words[1:5]
[1] "a"        "able"     "about"    "absolute" "accept"  
> 
> 
> 
> cleanEx()
> nameEx("word")
> ### * word
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: word
> ### Title: Extract words from a sentence
> ### Aliases: word
> 
> ### ** Examples
> 
> sentences <- c("Jane saw a cat", "Jane sat down")
> word(sentences, 1)
[1] "Jane" "Jane"
> word(sentences, 2)
[1] "saw" "sat"
> word(sentences, -1)
[1] "cat"  "down"
> word(sentences, 2, -1)
[1] "saw a cat" "sat down" 
> 
> # Also vectorised over start and end
> word(sentences[1], 1:3, -1)
[1] "Jane saw a cat" "saw a cat"      "a cat"         
> word(sentences[1], 1, 1:4)
[1] "Jane"           "Jane saw"       "Jane saw a"     "Jane saw a cat"
> 
> # Can define words by other separators
> str <- 'abc.def..123.4568.999'
> word(str, 1, sep = fixed('..'))
[1] "abc.def"
> word(str, 2, sep = fixed('..'))
[1] "123.4568.999"
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.263 0.017 0.279 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
