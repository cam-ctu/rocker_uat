
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "evaluate"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('evaluate')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("evaluate")
> ### * evaluate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: evaluate
> ### Title: Evaluate input and return all details of evaluation
> ### Aliases: evaluate
> 
> ### ** Examples
> 
> evaluate(c(
+   "1 + 1",
+   "2 + 2"
+ ))
<evaluation>
Source code: 
  1 + 1
Text output: 
  [1] 2
Source code: 
  2 + 2
Text output: 
  [1] 4
> 
> # Not that's there's a difference in output between putting multiple
> # expressions on one line vs spreading them across multiple lines
> evaluate("1;2;3")
<evaluation>
Source code: 
  1;2;3
Text output: 
  [1] 1
Text output: 
  [1] 2
Text output: 
  [1] 3
> evaluate(c("1", "2", "3"))
<evaluation>
Source code: 
  1
Text output: 
  [1] 1
Source code: 
  2
Text output: 
  [1] 2
Source code: 
  3
Text output: 
  [1] 3
> 
> # This also affects how errors propagate, matching the behaviour
> # of the R console
> evaluate("1;stop(2);3")
<evaluation>
Source code: 
  1;stop(2);3
Text output: 
  [1] 1
Condition: 
  Error:
  2
> evaluate(c("1", "stop(2)", "3"))
<evaluation>
Source code: 
  1
Text output: 
  [1] 1
Source code: 
  stop(2)
Condition: 
  Error:
  2
Source code: 
  3
Text output: 
  [1] 3
> 
> 
> 
> cleanEx()
> nameEx("inject_funs")
> ### * inject_funs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inject_funs
> ### Title: Inject functions into the environment of 'evaluate()'
> ### Aliases: inject_funs
> ### Keywords: internal
> 
> ### ** Examples
> 
> library(evaluate)
> # normally you cannot capture the output of system
> evaluate("system('R --version')")
R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under the terms of the
GNU General Public License versions 2 or 3.
For more information about these matters see
https://www.gnu.org/licenses/.

<evaluation>
Source code: 
  system('R --version')
> 
> # replace the system() function
> old <- inject_funs(system = function(...) {
+   cat(base::system(..., intern = TRUE), sep = "\n")
+ })
> 
> evaluate("system('R --version')")
<evaluation>
Source code: 
  system('R --version')
Text output: 
  R version 4.4.2 (2024-10-31) -- "Pile of Leaves"
  Copyright (C) 2024 The R Foundation for Statistical Computing
  Platform: x86_64-pc-linux-gnu
  
  R is free software and comes with ABSOLUTELY NO WARRANTY.
  You are welcome to redistribute it under the terms of the
  GNU General Public License versions 2 or 3.
  For more information about these matters see
  https://www.gnu.org/licenses/.
  
> 
> # restore previously injected functions
> inject_funs(old)
> 
> 
> 
> cleanEx()
> nameEx("parse_all")
> ### * parse_all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_all
> ### Title: Parse, retaining comments
> ### Aliases: parse_all
> 
> ### ** Examples
> 
> # Each of these inputs are single line, but generate different numbers of
> # expressions
> source <- c(
+   "# a comment",
+   "x",
+   "x;y",
+   "x;y;z"
+ )
> parsed <- parse_all(source)
> lengths(parsed$expr)
[1] 0 1 2 3
> str(parsed$expr)
List of 4
 $ :  expression()
 $ :  expression(x)
 $ :  expression(x, y)
 $ :  expression(x, y, z)
> 
> # Each of these inputs are a single expression, but span different numbers
> # of lines
> source <- c(
+   "function() {}",
+   "function() {",
+   "  # Hello!",
+   "}",
+   "function() {",
+   "  # Hello!",
+   "  # Goodbye!",
+   "}"
+ )
> parsed <- parse_all(source)
> lengths(parsed$expr)
[1] 1 1 1
> parsed$src
[1] "function() {}\n"                            
[2] "function() {\n  # Hello!\n}\n"              
[3] "function() {\n  # Hello!\n  # Goodbye!\n}\n"
> 
> 
> 
> cleanEx()
> nameEx("replay")
> ### * replay
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: replay
> ### Title: Replay a list of evaluated results
> ### Aliases: replay
> 
> ### ** Examples
> 
> f1 <- function() {
+   cat("1\n")
+   print("2")
+   warning("3")
+   print("4")
+   message("5")
+   stop("6")
+ }
> replay(evaluate("f1()"))
> f1()
1
[1] "2"
Warning in f1():
3
[1] "4"
5
Error in f1():
6
> 
> f2 <- function() {
+   message("Hello")
+   plot(1:10)
+   message("Goodbye")
+ }
> replay(evaluate("f2()"))
> f2()
Hello
Goodbye
> 
> 
> 
> cleanEx()
> nameEx("set_hooks")
> ### * set_hooks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_hooks
> ### Title: Set and remove hooks
> ### Aliases: set_hooks remove_hooks
> ### Keywords: internal
> 
> ### ** Examples
> 
> new1 <- list(before.plot.new = function() print("Plotted!"))
> new2 <- list(before.plot.new = function() print("Plotted Again!"))
> set_hooks(new1)
> set_hooks(new2)
> plot(1)
[1] "Plotted!"
[1] "Plotted Again!"
> remove_hooks(new1)
> plot(1)
[1] "Plotted Again!"
> remove_hooks(new2)
> plot(1)
> 
> 
> 
> cleanEx()
> nameEx("trim_intermediate_plots")
> ### * trim_intermediate_plots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trim_intermediate_plots
> ### Title: Trim away intermediate plots
> ### Aliases: trim_intermediate_plots
> 
> ### ** Examples
> 
> ev <- evaluate(c(
+   "plot(1:3)",
+   "text(1, 1, 'x')",
+   "text(1, 1, 'y')"
+ ))
> 
> # All intermediate plots are captured
> ev
<evaluation>
Source code: 
  plot(1:3)
Plot [9]:
  <base> C_plot_new()
  <base> palette2()
  <base> C_mtext()
  <base> C_plot_window()
  <base> C_plotXY()
  <base> C_axis()
  <base> C_axis()
  <base> C_box()
  <base> C_title()
Source code: 
  text(1, 1, 'x')
Plot [10]:
  <base> C_plot_new()
  <base> palette2()
  <base> C_mtext()
  <base> C_plot_window()
  <base> C_plotXY()
  <base> C_axis()
  <base> C_axis()
  <base> C_box()
  <base> C_title()
  <base> C_text()
Source code: 
  text(1, 1, 'y')
Plot [11]:
  <base> C_plot_new()
  <base> palette2()
  <base> C_mtext()
  <base> C_plot_window()
  <base> C_plotXY()
  <base> C_axis()
  <base> C_axis()
  <base> C_box()
  <base> C_title()
  <base> C_text()
  <base> C_text()
> # Only the final plot is shown
> trim_intermediate_plots(ev)
<evaluation>
Source code: 
  plot(1:3)
Source code: 
  text(1, 1, 'x')
Source code: 
  text(1, 1, 'y')
Plot [11]:
  <base> C_plot_new()
  <base> palette2()
  <base> C_mtext()
  <base> C_plot_window()
  <base> C_plotXY()
  <base> C_axis()
  <base> C_axis()
  <base> C_box()
  <base> C_title()
  <base> C_text()
  <base> C_text()
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.112 0.013 0.147 0.013 0.013 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
