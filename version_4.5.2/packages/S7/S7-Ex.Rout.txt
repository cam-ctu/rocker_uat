
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "S7"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('S7')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("S4_register")
> ### * S4_register
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: S4_register
> ### Title: Register an S7 class with S4
> ### Aliases: S4_register
> 
> ### ** Examples
> 
> methods::setGeneric("S4_generic", function(x) {
+   standardGeneric("S4_generic")
+ })
[1] "S4_generic"
> 
> Foo <- new_class("Foo")
> S4_register(Foo)
> method(S4_generic, Foo) <- function(x) "Hello"
> 
> S4_generic(Foo())
[1] "Hello"
> 
> 
> 
> cleanEx()
> nameEx("S7_class")
> ### * S7_class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: S7_class
> ### Title: Retrieve the S7 class of an object
> ### Aliases: S7_class
> 
> ### ** Examples
> 
> Foo <- new_class("Foo")
> S7_class(Foo())
<Foo> class
@ parent     : <S7_object>
@ constructor: function() {...}
@ validator  : <NULL>
@ properties :
> 
> 
> 
> cleanEx()
> nameEx("S7_data")
> ### * S7_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: S7_data
> ### Title: Get/set underlying "base" data
> ### Aliases: S7_data S7_data<-
> 
> ### ** Examples
> 
> Text <- new_class("Text", parent = class_character)
> y <- Text(c(foo = "bar"))
> y
<Text> Named chr "bar"
 - attr(*, "names")= chr "foo"
> S7_data(y)
  foo 
"bar" 
> 
> S7_data(y) <- c("a", "b")
> y
<Text> Named chr [1:2] "a" "b"
 - attr(*, "names")= chr [1:2] "foo" NA
> 
> 
> 
> cleanEx()
> nameEx("S7_inherits")
> ### * S7_inherits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: S7_inherits
> ### Title: Does this object inherit from an S7 class?
> ### Aliases: S7_inherits check_is_S7
> 
> ### ** Examples
> 
> Foo1 <- new_class("Foo1")
> Foo2 <- new_class("Foo2")
> 
> S7_inherits(Foo1(), Foo1)
[1] TRUE
> check_is_S7(Foo1())
> check_is_S7(Foo1(), Foo1)
> 
> S7_inherits(Foo1(), Foo2)
[1] FALSE
> try(check_is_S7(Foo1(), Foo2))
Error : `Foo1()` must be a <Foo2>, not a <Foo1>
> 
> if (getRversion() >= "4.3.0")
+   inherits(Foo1(), Foo1)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("S7_object")
> ### * S7_object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: S7_object
> ### Title: Base S7 class
> ### Aliases: S7_object
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> S7_object
<S7_object> class
@ parent     : <NULL>
@ constructor: function() {...}
@ validator  : function(self) {...}
@ properties :
> 
> 
> 
> cleanEx()
> nameEx("as_class")
> ### * as_class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_class
> ### Title: Standard class specifications
> ### Aliases: as_class
> ### Keywords: internal
> 
> ### ** Examples
> 
> as_class(class_logical)
<S7_base_class>: <logical>
> as_class(new_S3_class("factor"))
<S7_S3_class>: S3<factor>
> 
> 
> 
> cleanEx()
> nameEx("base_classes")
> ### * base_classes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: base_classes
> ### Title: S7 wrappers for base types
> ### Aliases: base_classes class_logical class_integer class_double
> ###   class_complex class_character class_raw class_list class_expression
> ###   class_name class_call class_function class_environment class_numeric
> ###   class_atomic class_vector class_language
> ### Keywords: datasets
> 
> ### ** Examples
> 
> 
> class_integer
<S7_base_class>: <integer>
> class_numeric
<S7_union>: <integer> or <double>
> class_factor
<S7_S3_class>: S3<factor>
> 
> 
> 
> cleanEx()
> nameEx("class_any")
> ### * class_any
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: class_any
> ### Title: Dispatch on any class
> ### Aliases: class_any
> ### Keywords: datasets
> 
> ### ** Examples
> 
> foo <- new_generic("foo", "x")
> method(foo, class_numeric) <- function(x) "number"
> method(foo, class_any) <- function(x) "fallback"
> 
> foo(1)
[1] "number"
> foo("x")
[1] "fallback"
> 
> 
> 
> cleanEx()
> nameEx("class_missing")
> ### * class_missing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: class_missing
> ### Title: Dispatch on a missing argument
> ### Aliases: class_missing
> ### Keywords: datasets
> 
> ### ** Examples
> 
> foo <- new_generic("foo", "x")
> method(foo, class_numeric) <- function(x) "number"
> method(foo, class_missing) <- function(x) "missing"
> method(foo, class_any) <- function(x) "fallback"
> 
> foo(1)
[1] "number"
> foo()
[1] "missing"
> foo("")
[1] "fallback"
> 
> 
> 
> cleanEx()
> nameEx("convert")
> ### * convert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convert
> ### Title: Convert an object from one type to another
> ### Aliases: convert
> 
> ### ** Examples
> 
> Foo1 <- new_class("Foo1", properties = list(x = class_integer))
> Foo2 <- new_class("Foo2", Foo1, properties = list(y = class_double))
> 
> # Downcasting: S7 provides a default implementation for coercing an object
> # to one of its parent classes:
> convert(Foo2(x = 1L, y = 2), to = Foo1)
<Foo1>
 @ x: int 1
> 
> # Upcasting: S7 also provides a default implementation for coercing an object
> # to one of its child classes:
> convert(Foo1(x = 1L), to = Foo2)
<Foo2>
 @ x: int 1
 @ y: num(0) 
> convert(Foo1(x = 1L), to = Foo2, y = 2.5)  # Set new property
<Foo2>
 @ x: int 1
 @ y: num 2.5
> convert(Foo1(x = 1L), to = Foo2, x = 2L, y = 2.5)  # Override existing and set new
<Foo2>
 @ x: int 2
 @ y: num 2.5
> 
> # For all other cases, you'll need to provide your own.
> try(convert(Foo1(x = 1L), to = class_integer))
Error : Can't find method for generic `convert()` with dispatch classes:
- from: <Foo1>
- to  : <integer>

> 
> method(convert, list(Foo1, class_integer)) <- function(from, to) {
+   from@x
+ }
> convert(Foo1(x = 1L), to = class_integer)
[1] 1
> 
> # Note that conversion does not respect inheritance so if we define a
> # convert method for integer to foo1
> method(convert, list(class_integer, Foo1)) <- function(from, to) {
+   Foo1(x = from)
+ }
> convert(1L, to = Foo1)
<Foo1>
 @ x: int 1
> 
> # Converting to Foo2 will still error
> try(convert(1L, to = Foo2))
Error : Can't find method for generic `convert()` with dispatch classes:
- from: <integer>
- to  : <Foo2>

> # This is probably not surprising because foo2 also needs some value
> # for `@y`, but it definitely makes dispatch for convert() special
> 
> 
> 
> cleanEx()
> nameEx("method-set")
> ### * method-set
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: method<-
> ### Title: Register an S7 method for a generic
> ### Aliases: method<-
> 
> ### ** Examples
> 
> # Create a generic
> bizarro <- new_generic("bizarro", "x")
> # Register some methods
> method(bizarro, class_numeric) <- function(x) rev(x)
> method(bizarro, new_S3_class("data.frame")) <- function(x) {
+   x[] <- lapply(x, bizarro)
+   rev(x)
+ }
> 
> # Using a generic calls the methods automatically
> bizarro(head(mtcars))
                  carb gear am vs  qsec    wt drat  hp disp cyl  mpg
Mazda RX4            1    3  0  1 20.22 3.460 2.76 105  225   6 18.1
Mazda RX4 Wag        2    3  0  0 17.02 3.440 3.15 175  360   8 18.7
Datsun 710           1    3  0  1 19.44 3.215 3.08 110  258   6 21.4
Hornet 4 Drive       1    4  1  1 18.61 2.320 3.85  93  108   4 22.8
Hornet Sportabout    4    4  1  0 17.02 2.875 3.90 110  160   6 21.0
Valiant              4    4  1  0 16.46 2.620 3.90 110  160   6 21.0
> 
> 
> 
> cleanEx()
> nameEx("method")
> ### * method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: method
> ### Title: Find a method for an S7 generic
> ### Aliases: method
> 
> ### ** Examples
> 
> # Create a generic and register some methods
> bizarro <- new_generic("bizarro", "x")
> method(bizarro, class_numeric) <- function(x) rev(x)
> method(bizarro, class_factor) <- function(x) {
+   levels(x) <- rev(levels(x))
+   x
+ }
> 
> # Printing the generic shows the registered method
> bizarro
<S7_generic> bizarro(x, ...) with 3 methods:
1: method(bizarro, class_integer)
2: method(bizarro, class_double)
3: method(bizarro, new_S3_class("factor"))
> 
> # And you can use method() to inspect specific implementations
> method(bizarro, class = class_integer)
<S7_method> method(bizarro, class_integer)
function (x) 
rev(x)
> method(bizarro, object = 1)
<S7_method> method(bizarro, class_double)
function (x) 
rev(x)
> method(bizarro, class = class_factor)
<S7_method> method(bizarro, new_S3_class("factor"))
function (x) 
{
    levels(x) <- rev(levels(x))
    x
}
> 
> # errors if method not found
> try(method(bizarro, class = class_data.frame))
Error : Can't find method for `bizarro(S3<data.frame>)`.
> try(method(bizarro, object = "x"))
Error : Can't find method for `bizarro(<character>)`.
> 
> 
> 
> cleanEx()
> nameEx("method_explain")
> ### * method_explain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: method_explain
> ### Title: Explain method dispatch
> ### Aliases: method_explain
> 
> ### ** Examples
> 
> Foo1 <- new_class("Foo1")
> Foo2 <- new_class("Foo2", Foo1)
> 
> add <- new_generic("add", c("x", "y"))
> method(add, list(Foo2, Foo1)) <- function(x, y) c(2, 1)
> method(add, list(Foo1, Foo1)) <- function(x, y) c(1, 1)
> 
> method_explain(add, list(Foo2, Foo2))
   add([Foo2], [Foo2])
-> add([Foo2], [Foo1])
   add([Foo2], [S7_object])
   add([Foo2], [ANY])
   add([Foo1], [Foo2])
*  add([Foo1], [Foo1])
   add([Foo1], [S7_object])
   add([Foo1], [ANY])
   add([S7_object], [Foo2])
   add([S7_object], [Foo1])
   add([S7_object], [S7_object])
   add([S7_object], [ANY])
   add([ANY], [Foo2])
   add([ANY], [Foo1])
   add([ANY], [S7_object])
   add([ANY], [ANY])
> 
> 
> 
> cleanEx()
> nameEx("methods_register")
> ### * methods_register
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods_register
> ### Title: Register methods in a package
> ### Aliases: methods_register
> 
> ### ** Examples
> 
> .onLoad <- function(...) {
+   S7::methods_register()
+ }
> 
> 
> 
> cleanEx()
> nameEx("new_S3_class")
> ### * new_S3_class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_S3_class
> ### Title: Declare an S3 class
> ### Aliases: new_S3_class
> 
> ### ** Examples
> 
> # No checking, just used for dispatch
> Date <- new_S3_class("Date")
> 
> my_generic <- new_generic("my_generic", "x")
> method(my_generic, Date) <- function(x) "This is a date"
> 
> my_generic(Sys.Date())
[1] "This is a date"
> 
> 
> 
> cleanEx()
> nameEx("new_class")
> ### * new_class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_class
> ### Title: Define a new S7 class
> ### Aliases: new_class new_object
> 
> ### ** Examples
> 
> # Create an class that represents a range using a numeric start and end
> Range <- new_class("Range",
+   properties = list(
+     start = class_numeric,
+     end = class_numeric
+   )
+ )
> r <- Range(start = 10, end = 20)
> r
<Range>
 @ start: num 10
 @ end  : num 20
> # get and set properties with @
> r@start
[1] 10
> r@end <- 40
> r@end
[1] 40
> 
> # S7 automatically ensures that properties are of the declared types:
> try(Range(start = "hello", end = 20))
Error : <Range> object properties are invalid:
- @start must be <integer> or <double>, not <character>
> 
> # But we might also want to use a validator to ensure that start and end
> # are length 1, and that start is < end
> Range <- new_class("Range",
+   properties = list(
+     start = class_numeric,
+     end = class_numeric
+   ),
+   validator = function(self) {
+     if (length(self@start) != 1) {
+       "@start must be a single number"
+     } else if (length(self@end) != 1) {
+       "@end must be a single number"
+     } else if (self@end < self@start) {
+       "@end must be great than or equal to @start"
+     }
+   }
+ )
> try(Range(start = c(10, 15), end = 20))
Error : <Range> object is invalid:
- @start must be a single number
> try(Range(start = 20, end = 10))
Error : <Range> object is invalid:
- @end must be great than or equal to @start
> 
> r <- Range(start = 10, end = 20)
> try(r@start <- 25)
Error : <Range> object is invalid:
- @end must be great than or equal to @start
> 
> 
> 
> cleanEx()
> nameEx("new_external_generic")
> ### * new_external_generic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_external_generic
> ### Title: Generics in other packages
> ### Aliases: new_external_generic
> 
> ### ** Examples
> 
> MyClass <- new_class("MyClass")
> 
> your_generic <- new_external_generic("stats", "median", "x")
> method(your_generic, MyClass) <- function(x) "Hi!"
> 
> 
> 
> cleanEx()
> nameEx("new_generic")
> ### * new_generic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_generic
> ### Title: Define a new generic
> ### Aliases: new_generic S7_dispatch
> 
> ### ** Examples
> 
> # A simple generic with methods for some base types and S3 classes
> type_of <- new_generic("type_of", dispatch_args = "x")
> method(type_of, class_character) <- function(x, ...) "A character vector"
> method(type_of, new_S3_class("data.frame")) <- function(x, ...) "A data frame"
> method(type_of, class_function) <- function(x, ...) "A function"
> 
> type_of(mtcars)
[1] "A data frame"
> type_of(letters)
[1] "A character vector"
> type_of(mean)
[1] "A function"
> 
> # If you want to require that methods implement additional arguments,
> # you can use a custom function:
> mean2 <- new_generic("mean2", "x", function(x, ..., na.rm = FALSE) {
+    S7_dispatch()
+ })
> 
> method(mean2, class_numeric) <- function(x, ..., na.rm = FALSE) {
+   if (na.rm) {
+     x <- x[!is.na(x)]
+   }
+   sum(x) / length(x)
+ }
> 
> # You'll be warned if you forget the argument:
> method(mean2, class_character) <- function(x, ...) {
+   stop("Not supported")
+ }
Warning: mean2(<character>) doesn't have argument `na.rm`
> 
> 
> 
> cleanEx()
> nameEx("new_property")
> ### * new_property
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_property
> ### Title: Define a new property
> ### Aliases: new_property
> 
> ### ** Examples
> 
> # Simple properties store data inside an object
> Pizza <- new_class("Pizza", properties = list(
+   slices = new_property(class_numeric, default = 10)
+ ))
> my_pizza <- Pizza(slices = 6)
> my_pizza@slices
[1] 6
> my_pizza@slices <- 5
> my_pizza@slices
[1] 5
> 
> your_pizza <- Pizza()
> your_pizza@slices
[1] 10
> 
> # Dynamic properties can compute on demand
> Clock <- new_class("Clock", properties = list(
+   now = new_property(getter = function(self) Sys.time())
+ ))
> my_clock <- Clock()
> my_clock@now; Sys.sleep(1)
[1] "2026-01-29 08:58:48 UTC"
> my_clock@now
[1] "2026-01-29 08:58:49 UTC"
> # This property is read only, because there is a 'getter' but not a 'setter'
> try(my_clock@now <- 10)
Error : Can't set read-only property <Clock>@now
> 
> # Because the property is dynamic, it is not included as an
> # argument to the default constructor
> try(Clock(now = 10))
Error in Clock(now = 10) : unused argument (now = 10)
> args(Clock)
function () 
NULL
> 
> 
> 
> cleanEx()
> nameEx("new_union")
> ### * new_union
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_union
> ### Title: Define a class union
> ### Aliases: new_union
> 
> ### ** Examples
> 
> logical_or_character <- new_union(class_logical, class_character)
> logical_or_character
<S7_union>: <logical> or <character>
> # or with shortcut syntax
> logical_or_character <- class_logical | class_character
> 
> Foo <- new_class("Foo", properties = list(x = logical_or_character))
> Foo(x = TRUE)
<Foo>
 @ x: logi TRUE
> Foo(x = letters[1:5])
<Foo>
 @ x: chr [1:5] "a" "b" "c" "d" "e"
> try(Foo(1:3))
Error : <Foo> object properties are invalid:
- @x must be <logical> or <character>, not <integer>
> 
> bar <- new_generic("bar", "x")
> # Use built-in union
> method(bar, class_atomic) <- function(x) "Hi!"
> bar
<S7_generic> bar(x, ...) with 6 methods:
1: method(bar, class_integer)
2: method(bar, class_complex)
3: method(bar, class_double)
4: method(bar, class_character)
5: method(bar, class_logical)
6: method(bar, class_raw)
> bar(TRUE)
[1] "Hi!"
> bar(letters)
[1] "Hi!"
> try(bar(NULL))
Error : Can't find method for `bar(<NULL>)`.
> 
> 
> 
> cleanEx()
> nameEx("prop")
> ### * prop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prop
> ### Title: Get/set a property
> ### Aliases: prop @ prop<- @.S7_object
> 
> ### ** Examples
> 
> Horse <- new_class("Horse", properties = list(
+   name = class_character,
+   colour = class_character,
+   height = class_numeric
+ ))
> lexington <- Horse(colour = "bay", height = 15, name = "Lex")
> lexington@colour
[1] "bay"
> prop(lexington, "colour")
[1] "bay"
> 
> lexington@height <- 14
> prop(lexington, "height") <- 15
> 
> 
> 
> cleanEx()
> nameEx("prop_names")
> ### * prop_names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prop_names
> ### Title: Property introspection
> ### Aliases: prop_names prop_exists
> 
> ### ** Examples
> 
> Foo <- new_class("Foo", properties = list(a = class_character, b = class_integer))
> f <- Foo()
> 
> prop_names(f)
[1] "a" "b"
> prop_exists(f, "a")
[1] TRUE
> prop_exists(f, "c")
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("props")
> ### * props
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: props
> ### Title: Get/set multiple properties
> ### Aliases: props props<- set_props
> 
> ### ** Examples
> 
> Horse <- new_class("Horse", properties = list(
+   name = class_character,
+   colour = class_character,
+   height = class_numeric
+ ))
> lexington <- Horse(colour = "bay", height = 15, name = "Lex")
> 
> props(lexington)
$name
[1] "Lex"

$colour
[1] "bay"

$height
[1] 15

> props(lexington) <- list(height = 14, name = "Lexington")
> lexington
<Horse>
 @ name  : chr "Lexington"
 @ colour: chr "bay"
 @ height: num 14
> 
> 
> 
> cleanEx()
> nameEx("super")
> ### * super
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: super
> ### Title: Force method dispatch to use a superclass
> ### Aliases: super
> 
> ### ** Examples
> 
> Foo1 <- new_class("Foo1", properties = list(x = class_numeric, y = class_numeric))
> Foo2 <- new_class("Foo2", Foo1, properties = list(z = class_numeric))
> 
> total <- new_generic("total", "x")
> method(total, Foo1) <- function(x) x@x + x@y
> 
> # This won't work because it'll be stuck in an infinite loop:
> method(total, Foo2) <- function(x) total(x) + x@z
> 
> # We could write
> method(total, Foo2) <- function(x) x@x + x@y + x@z
Overwriting method total(<Foo2>)
> # but then we'd need to remember to update it if the implementation
> # for total(<Foo1>) ever changed.
> 
> # So instead we use `super()` to call the method for the parent class:
> method(total, Foo2) <- function(x) total(super(x, to = Foo1)) + x@z
Overwriting method total(<Foo2>)
> total(Foo2(1, 2, 3))
[1] 6
> 
> # To see the difference between convert() and super() we need a
> # method that calls another generic
> 
> bar1 <- new_generic("bar1", "x")
> method(bar1, Foo1) <- function(x) 1
> method(bar1, Foo2) <- function(x) 2
> 
> bar2 <- new_generic("bar2", "x")
> method(bar2, Foo1) <- function(x) c(1, bar1(x))
> method(bar2, Foo2) <- function(x) c(2, bar1(x))
> 
> obj <- Foo2(1, 2, 3)
> bar2(obj)
[1] 2 2
> # convert() affects every generic:
> bar2(convert(obj, to = Foo1))
[1] 1 1
> # super() only affects the _next_ call to a generic:
> bar2(super(obj, to = Foo1))
[1] 1 2
> 
> 
> 
> cleanEx()
> nameEx("validate")
> ### * validate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: validate
> ### Title: Validate an S7 object
> ### Aliases: validate valid_eventually valid_implicitly
> 
> ### ** Examples
> 
> # A range class might validate that the start is less than the end
> Range <- new_class("Range",
+   properties = list(start = class_double, end = class_double),
+   validator = function(self) {
+     if (self@start >= self@end) "start must be smaller than end"
+   }
+ )
> # You can't construct an invalid object:
> try(Range(1, 1))
Error : <Range> object is invalid:
- start must be smaller than end
> 
> # And you can't create an invalid object with @<-
> r <- Range(1, 2)
> try(r@end <- 1)
Error : <Range> object is invalid:
- start must be smaller than end
> 
> # But what if you want to move a range to the right?
> rightwards <- function(r, x) {
+   r@start <- r@start + x
+   r@end <- r@end + x
+   r
+ }
> # This function doesn't work because it creates a temporarily invalid state
> try(rightwards(r, 10))
Error : <Range> object is invalid:
- start must be smaller than end
> 
> # This is the perfect use case for valid_eventually():
> rightwards <- function(r, x) {
+   valid_eventually(r, function(object) {
+     object@start <- object@start + x
+     object@end <- object@end + x
+     object
+   })
+ }
> rightwards(r, 10)
<Range>
 @ start: num 11
 @ end  : num 12
> 
> # Alternatively, you can set multiple properties at once using props<-,
> # which validates once at the end
> rightwards <- function(r, x) {
+   props(r) <- list(start = r@start + x, end = r@end + x)
+   r
+ }
> rightwards(r, 20)
<Range>
 @ start: num 21
 @ end  : num 22
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.159 0.008 1.168 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
