
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "testthat"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('testthat')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Reporter")
> ### * Reporter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Reporter
> ### Title: Manage test reporting
> ### Aliases: Reporter
> ### Keywords: internal
> 
> ### ** Examples
> 
> path <- testthat_example("success")
> 
> test_file(path)

â•â• Testing test-success.R â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]
[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
[ FAIL 0 | WARN 0 | SKIP 1 | PASS 1 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 1 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 2 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 3 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 4 ]

â”€â”€ Warning ('test-success.R:10:3'): some tests have warnings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NaNs produced
Backtrace:
    â–†
 1. â””â”€testthat::expect_equal(log(-1), NaN) at test-success.R:10:3
 2.   â””â”€testthat::quasi_label(enquo(object), label)
 3.     â””â”€rlang::eval_bare(expr, quo_get_env(quo))

â”€â”€ Skipped tests (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ This test hasn't been written yet (1): 'test-success.R:6:3'


[ FAIL 0 | WARN 1 | SKIP 1 | PASS 4 ]
> # Override the default by supplying the name of a reporter
> test_file(path, reporter = "minimal")
.SW...
> 
> 
> 
> cleanEx()
> nameEx("capture_condition")
> ### * capture_condition
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capture_condition
> ### Title: Capture conditions, including messages, warnings, expectations,
> ###   and errors.
> ### Aliases: capture_condition capture_error capture_expectation
> ###   capture_message capture_warning capture_messages capture_warnings
> ### Keywords: internal
> 
> ### ** Examples
> 
> f <- function() {
+   message("First")
+   warning("Second")
+   message("Third")
+ }
> 
> capture_message(f())
<simpleMessage in message("First"): First
>
> capture_messages(f())
Warning in f() : Second
[1] "First\n" "Third\n"
> 
> capture_warning(f())
First
<simpleWarning in f(): Second>
> capture_warnings(f())
First
Third
[1] "Second"
> 
> # Condition will capture anything
> capture_condition(f())
<simpleMessage in message("First"): First
>
> 
> 
> 
> cleanEx()
> nameEx("capture_output")
> ### * capture_output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capture_output
> ### Title: Capture output to console
> ### Aliases: capture_output capture_output_lines testthat_print
> ### Keywords: internal
> 
> ### ** Examples
> 
> capture_output({
+   cat("Hi!\n")
+   cat("Bye\n")
+ })
[1] "Hi!\nBye"
> 
> capture_output_lines({
+   cat("Hi!\n")
+   cat("Bye\n")
+ })
[1] "Hi!" "Bye"
> 
> capture_output("Hi")
[1] ""
> capture_output("Hi", print = TRUE)
[1] "[1] \"Hi\""
> 
> 
> 
> cleanEx()
> nameEx("compare")
> ### * compare
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare
> ### Title: Provide human-readable comparison of two objects
> ### Aliases: compare compare.default compare.character compare.numeric
> ###   compare.POSIXt
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Character -----------------------------------------------------------------
> x <- c("abc", "def", "jih")
> compare(x, x)
Equal
> 
> y <- paste0(x, "y")
> compare(x, y)
3/3 mismatches
x[1]: "abc"
y[1]: "abcy"

x[2]: "def"
y[2]: "defy"

x[3]: "jih"
y[3]: "jihy"> 
> compare(letters, paste0(letters, "-"))
26/26 mismatches
x[1]: "a"
y[1]: "a-"

x[2]: "b"
y[2]: "b-"

x[3]: "c"
y[3]: "c-"

x[4]: "d"
y[4]: "d-"

x[5]: "e"
y[5]: "e-"> 
> x <- "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus
+  tincidunt auctor. Vestibulum ac metus bibendum, facilisis nisi non, pulvinar
+  dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
> y <- "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus
+  tincidunt auctor. Vestibulum ac metus1 bibendum, facilisis nisi non, pulvinar
+  dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
> compare(x, y)
1/1 mismatches
x[1]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
x[1]: ncidunt auctor. Vestibulum ac metus bibendum, facilisis nisi non, pulvinar
x[1]: \n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
y[1]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
y[1]: ncidunt auctor. Vestibulum ac metus1 bibendum, facilisis nisi non, pulvina
y[1]: r\n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "> compare(c(x, x), c(y, y))
2/2 mismatches
x[1]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
x[1]: ncidunt auctor. Vestibulum ac metus bibendum, facilisis nisi non, pulvinar
x[1]: \n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
y[1]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
y[1]: ncidunt auctor. Vestibulum ac metus1 bibendum, facilisis nisi non, pulvina
y[1]: r\n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "

x[2]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
x[2]: ncidunt auctor. Vestibulum ac metus bibendum, facilisis nisi non, pulvinar
x[2]: \n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "
y[2]: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis cursus\n ti
y[2]: ncidunt auctor. Vestibulum ac metus1 bibendum, facilisis nisi non, pulvina
y[2]: r\n dolor. Donec pretium iaculis nulla, ut interdum sapien ultricies a. "> 
> # Numeric -------------------------------------------------------------------
> 
> x <- y <- runif(100)
> y[sample(100, 10)] <- 5
> compare(x, y)
10/100 mismatches (average diff: 4.45)
[17] 0.718 - 5 == -4.28
[21] 0.935 - 5 == -4.07
[28] 0.382 - 5 == -4.62
[31] 0.482 - 5 == -4.52
[33] 0.494 - 5 == -4.51
[45] 0.530 - 5 == -4.47
[48] 0.477 - 5 == -4.52
[73] 0.347 - 5 == -4.65
[83] 0.400 - 5 == -4.60
...> 
> x <- y <- 1:10
> x[5] <- NA
> x[6] <- 6.5
> compare(x, y)
2/10 mismatches (average diff: 0.5)
[5]  NA - 5 ==  NA
[6] 6.5 - 6 == 0.5> 
> # Compare ignores minor numeric differences in the same way
> # as all.equal.
> compare(x, x + 1e-9)
Equal
> 
> 
> 
> cleanEx()
> nameEx("comparison-expectations")
> ### * comparison-expectations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: comparison-expectations
> ### Title: Do you expect a value bigger or smaller than this?
> ### Aliases: comparison-expectations expect_lt expect_lte expect_gt
> ###   expect_gte
> 
> ### ** Examples
> 
> a <- 9
> expect_lt(a, 10)
> 
> ## Not run: 
> ##D expect_lt(11, 10)
> ## End(Not run)
> 
> a <- 11
> expect_gt(a, 10)
> ## Not run: 
> ##D expect_gt(9, 10)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("context")
> ### * context
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: context
> ### Title: Describe the context of a set of tests.
> ### Aliases: context
> ### Keywords: internal
> 
> ### ** Examples
> 
> context("String processing")
Warning: `context()` was deprecated in the 3rd edition.
> context("Remote procedure calls")
Warning: `context()` was deprecated in the 3rd edition.
> 
> 
> 
> cleanEx()
> nameEx("describe")
> ### * describe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: describe
> ### Title: describe: a BDD testing language
> ### Aliases: describe it
> ### Keywords: internal
> 
> ### ** Examples
> 
> describe("matrix()", {
+   it("can be multiplied by a scalar", {
+     m1 <- matrix(1:4, 2, 2)
+     m2 <- m1 * 2
+     expect_equal(matrix(1:4 * 2, 2, 2), m2)
+   })
+   it("can have not yet tested specs")
+ })
â”€â”€ Skip: matrix() / can have not yet tested specs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Reason: empty test
Test passed with 1 success ðŸ˜€.
> 
> # Nested specs:
> ## code
> addition <- function(a, b) a + b
> division <- function(a, b) a / b
> 
> ## specs
> describe("math library", {
+   describe("addition()", {
+     it("can add two numbers", {
+       expect_equal(1 + 1, addition(1, 1))
+     })
+   })
+   describe("division()", {
+     it("can divide two numbers", {
+       expect_equal(10 / 2, division(10, 2))
+     })
+     it("can handle division by 0") #not yet implemented
+   })
+ })
â”€â”€ Skip: math library / division() / can handle division by 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Reason: empty test
Test passed with 2 successes ðŸŒˆ.
> 
> 
> 
> cleanEx()
> nameEx("equality-expectations")
> ### * equality-expectations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: equality-expectations
> ### Title: Do you expect this value?
> ### Aliases: equality-expectations expect_equal expect_identical
> 
> ### ** Examples
> 
> a <- 10
> expect_equal(a, 10)
> 
> # Use expect_equal() when testing for numeric equality
> ## Not run: 
> ##D expect_identical(sqrt(2) ^ 2, 2)
> ## End(Not run)
> expect_equal(sqrt(2) ^ 2, 2)
> 
> 
> 
> cleanEx()
> nameEx("evaluate_promise")
> ### * evaluate_promise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: evaluate_promise
> ### Title: Evaluate a promise, capturing all types of output.
> ### Aliases: evaluate_promise
> ### Keywords: internal
> 
> ### ** Examples
> 
> evaluate_promise({
+   print("1")
+   message("2")
+   warning("3")
+   4
+ })
$result
[1] 4

$output
[1] "[1] \"1\""

$warnings
[1] "3"

$messages
[1] "2\n"

> 
> 
> 
> cleanEx()
> nameEx("expect_all_equal")
> ### * expect_all_equal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_all_equal
> ### Title: Do you expect every value in a vector to have this value?
> ### Aliases: expect_all_equal expect_all_true expect_all_false
> 
> ### ** Examples
> 
> x1 <- c(1, 1, 1, 1, 1, 1)
> expect_all_equal(x1, 1)
> 
> x2 <- c(1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2)
> show_failure(expect_all_equal(x2, 1))
Failed expectation:
Expected every element of `x2` to equal 1.
Differences:
  `actual[1:7]`: 1.0 1.0 1.0 2.0 1.0 1.0 1.0
`expected[1:7]`: 1.0 1.0 1.0 1.0 1.0 1.0 1.0

  `actual[9:12]`: 1.0 1.0 1.0 2.0
`expected[9:12]`: 1.0 1.0 1.0 1.0

> 
> # expect_all_true() and expect_all_false() are helpers for common cases
> set.seed(1016)
> show_failure(expect_all_true(rpois(100, 10) < 20))
Failed expectation:
Expected every element of `rpois(100, 10) < 20` to equal TRUE.
Differences:
`actual[58:64]`:   TRUE TRUE TRUE FALSE TRUE TRUE TRUE
`expected[58:64]`: TRUE TRUE TRUE TRUE  TRUE TRUE TRUE

`actual[91:97]`:   TRUE TRUE TRUE FALSE TRUE TRUE TRUE
`expected[91:97]`: TRUE TRUE TRUE TRUE  TRUE TRUE TRUE

> show_failure(expect_all_false(rpois(100, 10) > 20))
Failed expectation:
Expected every element of `rpois(100, 10) > 20` to equal FALSE.
Differences:
`actual[38:44]`:   FALSE FALSE FALSE TRUE  FALSE FALSE FALSE
`expected[38:44]`: FALSE FALSE FALSE FALSE FALSE FALSE FALSE

> 
> 
> 
> cleanEx()
> nameEx("expect_equivalent")
> ### * expect_equivalent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_equivalent
> ### Title: Is an object equal to the expected value, ignoring attributes?
> ### Aliases: expect_equivalent
> ### Keywords: internal
> 
> ### ** Examples
> 
> #' # expect_equivalent() ignores attributes
> a <- b <- 1:3
> names(b) <- letters[1:3]
> ## Not run: 
> ##D expect_equal(a, b)
> ## End(Not run)
> expect_equivalent(a, b)
Warning: `expect_equivalent()` was deprecated in the 3rd edition.
â„¹ Use expect_equal(ignore_attr = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("expect_error")
> ### * expect_error
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_error
> ### Title: Do you expect an error, warning, message, or other condition?
> ### Aliases: expect_error expect_warning expect_message expect_condition
> 
> ### ** Examples
> 
> # Errors ------------------------------------------------------------------
> f <- function() stop("My error!")
> expect_error(f())
> expect_error(f(), "My error!")
> 
> # You can use the arguments of grepl to control the matching
> expect_error(f(), "my error!", ignore.case = TRUE)
> 
> # Note that `expect_error()` returns the error object so you can test
> # its components if needed
> err <- expect_error(rlang::abort("a", n = 10))
> expect_equal(err$n, 10)
> 
> # Warnings ------------------------------------------------------------------
> f <- function(x) {
+   if (x < 0) {
+     warning("*x* is already negative")
+     return(x)
+   }
+   -x
+ }
> expect_warning(f(-1))
> expect_warning(f(-1), "already negative")
> expect_warning(f(1), NA)
> 
> # To test message and output, store results to a variable
> expect_warning(out <- f(-1), "already negative")
> expect_equal(out, -1)
> 
> # Messages ------------------------------------------------------------------
> f <- function(x) {
+   if (x < 0) {
+     message("*x* is already negative")
+     return(x)
+   }
+ 
+   -x
+ }
> expect_message(f(-1))
> expect_message(f(-1), "already negative")
> expect_message(f(1), NA)
> 
> 
> 
> cleanEx()
> nameEx("expect_invisible")
> ### * expect_invisible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_invisible
> ### Title: Do you expect the result to be (in)visible?
> ### Aliases: expect_invisible expect_visible
> 
> ### ** Examples
> 
> expect_invisible(x <- 10)
> expect_visible(x)
> 
> # Typically you'll assign the result of the expectation so you can
> # also check that the value is as you expect.
> greet <- function(name) {
+   message("Hi ", name)
+   invisible(name)
+ }
> out <- expect_invisible(greet("Hadley"))
Hi Hadley
> expect_equal(out, "Hadley")
> 
> 
> 
> cleanEx()
> nameEx("expect_known_output")
> ### * expect_known_output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_known_output
> ### Title: Do you expect the results/output to equal a known value?
> ### Aliases: expect_known_output expect_known_value
> ###   expect_equal_to_reference expect_known_hash
> ### Keywords: internal
> 
> ### ** Examples
> 
> tmp <- tempfile()
> 
> # The first run always succeeds
> expect_known_output(mtcars[1:10, ], tmp, print = TRUE)
Warning: `expect_known_output()` was deprecated in the 3rd edition.
â„¹ Please use `expect_snapshot_output()` instead
Warning: Creating reference output.
> 
> # Subsequent runs will succeed only if the file is unchanged
> # This will succeed:
> expect_known_output(mtcars[1:10, ], tmp, print = TRUE)
Warning: `expect_known_output()` was deprecated in the 3rd edition.
â„¹ Please use `expect_snapshot_output()` instead
> 
> ## Not run: 
> ##D # This will fail
> ##D expect_known_output(mtcars[1:9, ], tmp, print = TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expect_length")
> ### * expect_length
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_length
> ### Title: Do you expect an object with this length or shape?
> ### Aliases: expect_length expect_shape
> 
> ### ** Examples
> 
> expect_length(1, 1)
> expect_length(1:10, 10)
> show_failure(expect_length(1:10, 1))
Failed expectation:
Expected `1:10` to have length 1.
Actual length: 10.
> 
> x <- matrix(1:9, nrow = 3)
> expect_shape(x, nrow = 3)
> show_failure(expect_shape(x, nrow = 4))
Failed expectation:
Expected `x` to have 4 rows.
Actual rows: 3.
> expect_shape(x, ncol = 3)
> show_failure(expect_shape(x, ncol = 4))
Failed expectation:
Expected `x` to have 4 columns.
Actual columns: 3.
> expect_shape(x, dim = c(3, 3))
> show_failure(expect_shape(x, dim = c(3, 4, 5)))
Failed expectation:
Expected `x` to have 3 dimensions.
Actual dimensions: 2.
> 
> 
> 
> cleanEx()
> nameEx("expect_match")
> ### * expect_match
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_match
> ### Title: Do you expect a string to match this pattern?
> ### Aliases: expect_match expect_no_match
> 
> ### ** Examples
> 
> expect_match("Testing is fun", "fun")
> expect_match("Testing is fun", "f.n")
> expect_no_match("Testing is fun", "horrible")
> 
> show_failure(expect_match("Testing is fun", "horrible"))
Failed expectation:
Expected "Testing is fun" to match regexp "horrible".
Actual text:
âœ– â”‚ Testing is fun
> show_failure(expect_match("Testing is fun", "horrible", fixed = TRUE))
Failed expectation:
Expected "Testing is fun" to match string "horrible".
Actual text:
âœ– â”‚ Testing is fun
> 
> # Zero-length inputs always fail
> show_failure(expect_match(character(), "."))
Failed expectation:
Expected `character()` to have at least one element.
> 
> 
> 
> cleanEx()
> nameEx("expect_named")
> ### * expect_named
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_named
> ### Title: Do you expect a vector with (these) names?
> ### Aliases: expect_named
> 
> ### ** Examples
> 
> x <- c(a = 1, b = 2, c = 3)
> expect_named(x)
> expect_named(x, c("a", "b", "c"))
> 
> # Use options to control sensitivity
> expect_named(x, c("B", "C", "A"), ignore.order = TRUE, ignore.case = TRUE)
> 
> # Can also check for the absence of names with NULL
> z <- 1:4
> expect_named(z, NULL)
> 
> 
> 
> cleanEx()
> nameEx("expect_no_error")
> ### * expect_no_error
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_no_error
> ### Title: Do you expect the absence of errors, warnings, messages, or
> ###   other conditions?
> ### Aliases: expect_no_error expect_no_warning expect_no_message
> ###   expect_no_condition
> 
> ### ** Examples
> 
> expect_no_warning(1 + 1)
> 
> foo <- function(x) {
+   warning("This is a problem!")
+ }
> 
> # warning doesn't match so bubbles up:
> expect_no_warning(foo(), message = "bananas")
Warning in foo() : This is a problem!
> 
> # warning does match so causes a failure:
> try(expect_no_warning(foo(), message = "problem"))
Error : Expected `foo()` not to throw any warnings matching pattern 'problem'.
Actually got a <simpleWarning> with message:
  This is a problem!
> 
> 
> 
> cleanEx()
> nameEx("expect_null")
> ### * expect_null
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_null
> ### Title: Do you expect 'NULL'?
> ### Aliases: expect_null
> 
> ### ** Examples
> 
> x <- NULL
> y <- 10
> 
> expect_null(x)
> show_failure(expect_null(y))
Failed expectation:
Expected `y` to be NULL.
Differences:
`actual` is a double vector (10)
`expected` is NULL

> 
> 
> 
> cleanEx()
> nameEx("expect_output")
> ### * expect_output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_output
> ### Title: Do you expect printed output to match this pattern?
> ### Aliases: expect_output
> 
> ### ** Examples
> 
> str(mtcars)
'data.frame':	32 obs. of  11 variables:
 $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
 $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
 $ disp: num  160 160 108 258 360 ...
 $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
 $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
 $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
 $ qsec: num  16.5 17 18.6 19.4 17 ...
 $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
 $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
 $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
 $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
> expect_output(str(mtcars), "32 obs")
> expect_output(str(mtcars), "11 variables")
> 
> # You can use the arguments of grepl to control the matching
> expect_output(str(mtcars), "11 VARIABLES", ignore.case = TRUE)
> expect_output(str(mtcars), "$ mpg", fixed = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("expect_setequal")
> ### * expect_setequal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_setequal
> ### Title: Do you expect a vector containing these values?
> ### Aliases: expect_setequal expect_mapequal expect_contains expect_in
> ###   expect_disjoint
> 
> ### ** Examples
> 
> expect_setequal(letters, rev(letters))
> show_failure(expect_setequal(letters[-1], rev(letters)))
Failed expectation:
Expected `letters[-1]` to have the same values as `rev(letters)`.
Actual: "b", "c", "d", "e", "f", "g", "h", "i", "j", ...
Expected: "z", "y", "x", "w", "v", "u", "t", "s", "r", ...
Absent: "a"
> 
> x <- list(b = 2, a = 1)
> expect_mapequal(x, list(a = 1, b = 2))
> show_failure(expect_mapequal(x, list(a = 1)))
Failed expectation:
Expected `x` to have the same names as `list(a = 1)`.
Actual: "b", "a"
Expected: "a"
Needs: "b"
> show_failure(expect_mapequal(x, list(a = 1, b = "x")))
Failed expectation:
Expected `x` to contain the same values as `list(a = 1, b = "x")`.
Differences:
`actual$b` is a double vector (2)
`expected$b` is a character vector ('x')

> show_failure(expect_mapequal(x, list(a = 1, b = 2, c = 3)))
Failed expectation:
Expected `x` to have the same names as `list(a = 1, b = 2, c = 3)`.
Actual: "b", "a"
Expected: "a", "b", "c"
Absent: "c"
> 
> 
> 
> cleanEx()
> nameEx("expect_silent")
> ### * expect_silent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_silent
> ### Title: Do you expect code to execute silently?
> ### Aliases: expect_silent
> 
> ### ** Examples
> 
> expect_silent("123")
> 
> f <- function() {
+   message("Hi!")
+   warning("Hey!!")
+   print("OY!!!")
+ }
> ## Not run: 
> ##D expect_silent(f())
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expect_snapshot_file")
> ### * expect_snapshot_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_snapshot_file
> ### Title: Do you expect this code to create the same file as last time?
> ### Aliases: expect_snapshot_file announce_snapshot_file
> ###   compare_file_binary compare_file_text
> 
> ### ** Examples
> 
> 
> # To use expect_snapshot_file() you'll typically need to start by writing
> # a helper function that creates a file from your code, returning a path
> save_png <- function(code, width = 400, height = 400) {
+   path <- tempfile(fileext = ".png")
+   png(path, width = width, height = height)
+   on.exit(dev.off())
+   code
+ 
+   path
+ }
> path <- save_png(plot(1:5))
> path
[1] "/tmp/RtmpZoWdTB/file201565ce0a623.png"
> 
> ## Not run: 
> ##D expect_snapshot_file(save_png(hist(mtcars$mpg)), "plot.png")
> ## End(Not run)
> 
> # You'd then also provide a helper that skips tests where you can't
> # be sure of producing exactly the same output.
> expect_snapshot_plot <- function(name, code) {
+   # Announce the file before touching skips or running `code`. This way,
+   # if the skips are active, testthat will not auto-delete the corresponding
+   # snapshot file.
+   name <- paste0(name, ".png")
+   announce_snapshot_file(name = name)
+ 
+   # Other packages might affect results
+   skip_if_not_installed("ggplot2", "2.0.0")
+   # Or maybe the output is different on some operating systems
+   skip_on_os("windows")
+   # You'll need to carefully think about and experiment with these skips
+ 
+   path <- save_png(code)
+   expect_snapshot_file(path, name)
+ }
> 
> 
> 
> cleanEx()
> nameEx("expect_that")
> ### * expect_that
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_that
> ### Title: Expect that a condition holds.
> ### Aliases: expect_that
> ### Keywords: internal
> 
> ### ** Examples
> 
> expect_that(5 * 2, equals(10))
Warning: `expect_that()` was deprecated in the 3rd edition.
> expect_that(sqrt(2) ^ 2, equals(2))
Warning: `expect_that()` was deprecated in the 3rd edition.
> ## Not run: 
> ##D expect_that(sqrt(2) ^ 2, is_identical_to(2))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expect_vector")
> ### * expect_vector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_vector
> ### Title: Do you expect a vector with this size and/or prototype?
> ### Aliases: expect_vector
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("vctrs")) withAutoprint({ # examplesIf
+ ## End(Don't show)
+ expect_vector(1:10, ptype = integer(), size = 10)
+ show_failure(expect_vector(1:10, ptype = integer(), size = 5))
+ show_failure(expect_vector(1:10, ptype = character(), size = 5))
+ ## Don't show: 
+ }) # examplesIf
> expect_vector(1:10, ptype = integer(), size = 10)
> show_failure(expect_vector(1:10, ptype = integer(), size = 5))
Failed expectation:
`1:10` must have size 5, not size 10.
> show_failure(expect_vector(1:10, ptype = character(), size = 5))
Failed expectation:
`1:10` must be a vector with type <character>.
Instead, it has type <integer>.
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("extract_test")
> ### * extract_test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extract_test
> ### Title: Extract a reprex from a failed expectation
> ### Aliases: extract_test
> 
> ### ** Examples
> 
> # If you see a test failure like this:
> # -- Failure (test-extract.R:46:3): errors if can't find test -------------
> # Expected FALSE to be TRUE.
> # Differences:
> # `actual`:   FALSE
> # `expected`: TRUE
> 
> # You can run this:
> ## Not run: extract_test("test-extract.R:46:3")
> # to see just the code needed to reproduce the failure
> 
> 
> 
> cleanEx()
> nameEx("fail")
> ### * fail
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fail
> ### Title: Declare that an expectation either passes or fails
> ### Aliases: fail pass
> 
> ### ** Examples
> 
> expect_length <- function(object, n) {
+   act <- quasi_label(rlang::enquo(object), arg = "object")
+ 
+   act_n <- length(act$val)
+   if (act_n != n) {
+     fail(sprintf("%s has length %i, not length %i.", act$lab, act_n, n))
+   } else {
+     pass()
+   }
+ 
+   invisible(act$val)
+ }
> 
> 
> 
> cleanEx()
> nameEx("inheritance-expectations")
> ### * inheritance-expectations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inheritance-expectations
> ### Title: Do you expect an S3/S4/R6/S7 object that inherits from this
> ###   class?
> ### Aliases: inheritance-expectations expect_type expect_s3_class
> ###   expect_s4_class expect_r6_class expect_s7_class
> 
> ### ** Examples
> 
> x <- data.frame(x = 1:10, y = "x", stringsAsFactors = TRUE)
> # A data frame is an S3 object with class data.frame
> expect_s3_class(x, "data.frame")
> show_failure(expect_s4_class(x, "data.frame"))
Failed expectation:
Expected `x` to be an S4 object.
Actual OO type: S3.
> # A data frame is built from a list:
> expect_type(x, "list")
> 
> f <- factor(c("a", "b", "c"))
> o <- ordered(f)
> 
> # Using multiple class names tests if the object inherits from any of them
> expect_s3_class(f, c("ordered", "factor"))
> # Use exact = TRUE to test for exact match
> show_failure(expect_s3_class(f, c("ordered", "factor"), exact = TRUE))
Failed expectation:
Expected `f` to have class "ordered"/"factor".
Actual class: "factor".
> expect_s3_class(o, c("ordered", "factor"), exact = TRUE)
> 
> # An integer vector is an atomic vector of type "integer"
> expect_type(x$x, "integer")
> # It is not an S3 object
> show_failure(expect_s3_class(x$x, "integer"))
Failed expectation:
Expected `x$x` to be an S3 object.
Actual OO type: none.
> 
> # Above, we requested data.frame() converts strings to factors:
> show_failure(expect_type(x$y, "character"))
Failed expectation:
Expected `x$y` to have type "character".
Actual type: "integer"
> expect_s3_class(x$y, "factor")
> expect_type(x$y, "integer")
> 
> 
> 
> cleanEx()
> nameEx("local_mocked_s3_method")
> ### * local_mocked_s3_method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: local_mocked_s3_method
> ### Title: Mock S3 and S4 methods
> ### Aliases: local_mocked_s3_method local_mocked_s4_method
> 
> ### ** Examples
> 
> x <- as.POSIXlt(Sys.time())
> local({
+   local_mocked_s3_method("length", "POSIXlt", function(x) 42)
+   length(x)
+ })
[1] 42
> 
> length(x)
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("local_test_context")
> ### * local_test_context
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: local_test_context
> ### Title: Temporarily set options for maximum reproducibility
> ### Aliases: local_test_context local_reproducible_output
> 
> ### ** Examples
> 
> local({
+   local_test_context()
+   cat(cli::col_blue("Text will not be colored"))
+   cat(cli::symbol$ellipsis)
+   cat("\n")
+ })
Text will not be colored...
> test_that("test ellipsis", {
+   local_reproducible_output(unicode = FALSE)
+   expect_equal(cli::symbol$ellipsis, "...")
+ 
+   local_reproducible_output(unicode = TRUE)
+   expect_equal(cli::symbol$ellipsis, "\u2026")
+ })
Test passed with 2 successes ðŸ˜€.
> 
> 
> 
> cleanEx()
> nameEx("logical-expectations")
> ### * logical-expectations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logical-expectations
> ### Title: Do you expect 'TRUE' or 'FALSE'?
> ### Aliases: logical-expectations expect_true expect_false
> 
> ### ** Examples
> 
> expect_true(2 == 2)
> # Failed expectations will throw an error
> show_failure(expect_true(2 != 2))
Failed expectation:
Expected `2 != 2` to be TRUE.
Differences:
`actual`:   FALSE
`expected`: TRUE 

> 
> # where possible, use more specific expectations, to get more informative
> # error messages
> a <- 1:4
> show_failure(expect_true(length(a) == 3))
Failed expectation:
Expected `length(a) == 3` to be TRUE.
Differences:
`actual`:   FALSE
`expected`: TRUE 

> show_failure(expect_equal(length(a), 3))
Failed expectation:
Expected `length(a)` to equal 3.
Differences:
  `actual`: 4.0
`expected`: 3.0

> 
> x <- c(TRUE, TRUE, FALSE, TRUE)
> show_failure(expect_true(all(x)))
Failed expectation:
Expected `all(x)` to be TRUE.
Differences:
`actual`:   FALSE
`expected`: TRUE 

> show_failure(expect_all_true(x))
Failed expectation:
Expected every element of `x` to equal TRUE.
Differences:
`actual`:   TRUE TRUE FALSE TRUE
`expected`: TRUE TRUE TRUE  TRUE

> 
> 
> 
> cleanEx()
> nameEx("make_expectation")
> ### * make_expectation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_expectation
> ### Title: Make an equality test.
> ### Aliases: make_expectation
> ### Keywords: internal
> 
> ### ** Examples
> 
> x <- 1:10
> make_expectation(x)
expect_equal(x, 1:10)
> 
> make_expectation(mtcars$mpg)
expect_equal(mtcars$mpg, c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 
24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, 
30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8, 
19.7, 15, 21.4))
> 
> df <- data.frame(x = 2)
> make_expectation(df)
expect_equal(df, structure(list(x = 2), class = "data.frame", row.names = c(NA, 
-1L)))
> 
> 
> 
> cleanEx()
> nameEx("mock_output_sequence")
> ### * mock_output_sequence
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mock_output_sequence
> ### Title: Mock a sequence of output from a function
> ### Aliases: mock_output_sequence
> 
> ### ** Examples
> 
> # inside local_mocked_bindings()
> ## Not run: 
> ##D local_mocked_bindings(readline = mock_output_sequence("3", "This is a note", "n"))
> ## End(Not run)
> # for understanding
> mocked_sequence <- mock_output_sequence("3", "This is a note", "n")
> mocked_sequence()
[1] "3"
> mocked_sequence()
[1] "This is a note"
> mocked_sequence()
[1] "n"
> try(mocked_sequence())
Error in mocked_sequence() : Can't find value for 4th iteration.
â„¹ `...` has only 3 values.
â„¹ You can set `recycle` to `TRUE`.
> recycled_mocked_sequence <- mock_output_sequence(
+   "3", "This is a note", "n",
+   recycle = TRUE
+ )
> recycled_mocked_sequence()
[1] "3"
> recycled_mocked_sequence()
[1] "This is a note"
> recycled_mocked_sequence()
[1] "n"
> recycled_mocked_sequence()
[1] "3"
> 
> 
> 
> cleanEx()
> nameEx("quasi_label")
> ### * quasi_label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quasi_label
> ### Title: Quasi-labelling
> ### Aliases: quasi_label
> ### Keywords: internal
> 
> ### ** Examples
> 
> f <- function(i) if (i > 3) i * 9 else i * 10
> i <- 10
> 
> # This sort of expression commonly occurs inside a for loop or function
> # And the failure isn't helpful because you can't see the value of i
> # that caused the problem:
> show_failure(expect_equal(f(i), i * 10))
Failed expectation:
Expected `f(i)` to equal `i * 10`.
Differences:
  `actual`:  90.0
`expected`: 100.0

> 
> # To overcome this issue, testthat allows you to unquote expressions using
> # !!. This causes the failure message to show the value rather than the
> # variable name
> show_failure(expect_equal(f(!!i), !!(i * 10)))
Failed expectation:
Expected `f(10)` to equal 100.
Differences:
  `actual`:  90.0
`expected`: 100.0

> 
> 
> 
> cleanEx()
> nameEx("skip")
> ### * skip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: skip
> ### Title: Skip a test for various reasons
> ### Aliases: skip skip_if_not skip_if skip_if_not_installed skip_unless_r
> ###   skip_if_offline skip_on_cran local_on_cran skip_on_os skip_on_ci
> ###   skip_on_covr skip_on_bioc skip_if_translated
> 
> ### ** Examples
> 
> if (FALSE) skip("Some Important Requirement is not available")
> 
> test_that("skip example", {
+   expect_equal(1, 1L)    # this expectation runs
+   skip('skip')
+   expect_equal(1, 2)     # this one skipped
+   expect_equal(1, 3)     # this one is also skipped
+ })
â”€â”€ Skip: skip example â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Reason: skip
Test passed with 1 success ðŸ˜€.
> 
> 
> 
> cleanEx()
> nameEx("teardown")
> ### * teardown
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: teardown
> ### Title: Run code before/after tests
> ### Aliases: teardown setup
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Old approach
> ##D tmp <- tempfile()
> ##D setup(writeLines("some test data", tmp))
> ##D teardown(unlink(tmp))
> ## End(Not run)
> 
> # Now recommended:
> local_test_data <- function(env = parent.frame()) {
+   tmp <- tempfile()
+   writeLines("some test data", tmp)
+   withr::defer(unlink(tmp), env)
+ 
+   tmp
+ }
> # Then call local_test_data() in your tests
> 
> 
> 
> cleanEx()
> nameEx("test_file")
> ### * test_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test_file
> ### Title: Run tests in a single file
> ### Aliases: test_file
> 
> ### ** Examples
> 
> path <- testthat_example("success")
> test_file(path)

â•â• Testing test-success.R â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]
[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
[ FAIL 0 | WARN 0 | SKIP 1 | PASS 1 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 1 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 2 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 3 ]
[ FAIL 0 | WARN 1 | SKIP 1 | PASS 4 ]

â”€â”€ Warning ('test-success.R:10:3'): some tests have warnings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NaNs produced
Backtrace:
    â–†
 1. â””â”€testthat::expect_equal(log(-1), NaN) at test-success.R:10:3
 2.   â””â”€testthat::quasi_label(enquo(object), label)
 3.     â””â”€rlang::eval_bare(expr, quo_get_env(quo))

â”€â”€ Skipped tests (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ This test hasn't been written yet (1): 'test-success.R:6:3'


[ FAIL 0 | WARN 1 | SKIP 1 | PASS 4 ]
> test_file(path, desc = "some tests have warnings")

â•â• Testing test-success.R â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]
[ FAIL 0 | WARN 1 | SKIP 0 | PASS 0 ]
[ FAIL 0 | WARN 1 | SKIP 0 | PASS 1 ]

â”€â”€ Warning ('test-success.R:10:3'): some tests have warnings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NaNs produced
Backtrace:
    â–†
 1. â””â”€testthat::expect_equal(log(-1), NaN) at test-success.R:10:3
 2.   â””â”€testthat::quasi_label(enquo(object), label)
 3.     â””â”€rlang::eval_bare(expr, quo_get_env(quo))

[ FAIL 0 | WARN 1 | SKIP 0 | PASS 1 ]
> test_file(path, reporter = "minimal")
.SW...
> 
> 
> 
> cleanEx()
> nameEx("test_path")
> ### * test_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test_path
> ### Title: Locate a file in the testing directory
> ### Aliases: test_path
> 
> ### ** Examples
> 
> ## Not run: 
> ##D test_path("foo.csv")
> ##D test_path("data", "foo.csv")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("test_that")
> ### * test_that
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test_that
> ### Title: Run a test
> ### Aliases: test_that
> 
> ### ** Examples
> 
> test_that("trigonometric functions match identities", {
+   expect_equal(sin(pi / 4), 1 / sqrt(2))
+   expect_equal(cos(pi / 4), 1 / sqrt(2))
+   expect_equal(tan(pi / 4), 1)
+ })
Test passed with 3 successes ðŸ˜€.
> 
> ## Not run: 
> ##D test_that("trigonometric functions match identities", {
> ##D   expect_equal(sin(pi / 4), 1)
> ##D })
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("testthat_examples")
> ### * testthat_examples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: testthat_examples
> ### Title: Retrieve paths to built-in example test files
> ### Aliases: testthat_examples testthat_example
> ### Keywords: internal
> 
> ### ** Examples
> 
> dir(testthat_examples())
[1] "_snaps"         "test-failure.R" "test-success.R"
> testthat_example("success")
[1] "/usr/local/lib/R/site-library/testthat/examples/test-success.R"
> 
> 
> 
> cleanEx()
> nameEx("try_again")
> ### * try_again
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: try_again
> ### Title: Evaluate an expectation multiple times until it succeeds
> ### Aliases: try_again
> 
> ### ** Examples
> 
> usually_return_1 <- function(i) {
+   if (runif(1) < 0.1) 0 else 1
+ }
> 
> ## Not run: 
> ##D # 10% chance of failure:
> ##D expect_equal(usually_return_1(), 1)
> ##D 
> ##D # 1% chance of failure:
> ##D try_again(1, expect_equal(usually_return_1(), 1))
> ##D 
> ##D # 0.1% chance of failure:
> ##D try_again(2, expect_equal(usually_return_1(), 1))
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.654 0.08 1.737 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
