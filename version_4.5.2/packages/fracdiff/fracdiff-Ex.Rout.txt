
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "fracdiff"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('fracdiff')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("confint.fracdiff")
> ### * confint.fracdiff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.fracdiff
> ### Title: Confidence Intervals for Fracdiff Model Parameters
> ### Aliases: confint.fracdiff
> ### Keywords: models
> 
> ### ** Examples
> 
> set.seed(101)
> ts2 <- fracdiff.sim(5000, ar = .2, ma = -.4, d = .3)
> mFD <- fracdiff( ts2$series, nar = length(ts2$ar), nma = length(ts2$ma))
> coef(mFD)
         d         ar         ma 
 0.3051313  0.1911422 -0.3685095 
> confint(mFD)
        2.5 %     97.5 %
d   0.2746788  0.3355839
ar  0.1228136  0.2594707
ma -0.4195143 -0.3175048
> 
> 
> 
> cleanEx()
> nameEx("diffseries")
> ### * diffseries
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diffseries
> ### Title: Fractionally Differenciate Data
> ### Aliases: diffseries
> ### Keywords: ts
> 
> ### ** Examples
> 
> memory.long <- fracdiff.sim(80, d = 0.3)
> str(mGPH <- fdGPH(memory.long$series))
List of 3
 $ d     : num 0.0109
 $ sd.as : num 0.347
 $ sd.reg: num 0.365
> r <- diffseries(memory.long$series, d = mGPH$d)
> #acf(r) # shouldn't show structure - ideally
> 
> 
> 
> cleanEx()
> nameEx("fd-methods")
> ### * fd-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fracdiff-methods
> ### Title: Many Methods for "fracdiff" Objects
> ### Aliases: coef.fracdiff logLik.fracdiff print.fracdiff fitted.fracdiff
> ###   residuals.fracdiff vcov.fracdiff summary.fracdiff
> ###   print.summary.fracdiff
> ### Keywords: print models
> 
> ### ** Examples
> 
> set.seed(7)
> ts4 <- fracdiff.sim(10000, ar = c(0.6, -.05, -0.2), ma = -0.4, d = 0.2)
> modFD <- fracdiff( ts4$series, nar = length(ts4$ar), nma = length(ts4$ma))
Warning: unable to compute correlation matrix; maybe change 'h'
> ## -> warning (singular Hessian) %% FIXME ???
> coef(modFD) # the estimated parameters
          d         ar1         ar2         ar3          ma 
 0.18574785  0.60448721 -0.02589436 -0.21820311 -0.41066512 
> vcov(modFD)
                d           ar1           ar2           ar3           ma1
d    3.948926e-06 -5.861285e-07 -1.543319e-07 -1.320697e-06  2.842259e-06
ar1 -5.861285e-07 -2.612427e-06 -2.661677e-05  2.804338e-05 -2.883319e-05
ar2 -1.543319e-07 -2.661677e-05  1.222974e-04  8.663898e-06  6.348246e-05
ar3 -1.320697e-06  2.804338e-05  8.663898e-06 -1.066487e-05  4.522663e-06
ma1  2.842259e-06 -2.883319e-05  6.348246e-05  4.522663e-06  1.007082e-04
> smFD <- summary(modFD)
> smFD

Call:
  fracdiff(x = ts4$series, nar = length(ts4$ar), nma = length(ts4$ma)) 

*** Warning during (fdcov) fit: unable to compute correlation matrix; maybe change 'h'

Coefficients:
    Estimate
d      0.186
ar1    0.604
ar2   -0.026
ar3   -0.218
ma    -0.411
sigma[eps] = 1.006018 
[d.tol = 0.0001221, M = 100, h = 0.0001501]
Log likelihood: -1.425e+04 ==> AIC = 28510.24 [6 deg.freedom]
> coef(smFD) # gives the whole table
       Estimate
d    0.18574785
ar1  0.60448721
ar2 -0.02589436
ar3 -0.21820311
ma  -0.41066512
> AIC(modFD) # AIC works because of the logLik() method
[1] 28510.24
> stopifnot(exprs = {
+ 
+ })
> 
> 
> 
> cleanEx()
> nameEx("fdGPH")
> ### * fdGPH
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fdGPH
> ### Title: Geweke and Porter-Hudak Estimator for ARFIMA(p,d,q)
> ### Aliases: fdGPH
> ### Keywords: ts
> 
> ### ** Examples
> 
> memory.long <- fracdiff.sim(1500, d = 0.3)
> fdGPH(memory.long$series)
$d
[1] 0.2225123

$sd.as
[1] 0.1212815

$sd.reg
[1] 0.07931661

> 
> 
> 
> cleanEx()
> nameEx("fdSperio")
> ### * fdSperio
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fdSperio
> ### Title: Sperio Estimate for 'd' in ARFIMA(p,d,q)
> ### Aliases: fdSperio
> ### Keywords: ts
> 
> ### ** Examples
> 
> memory.long <- fracdiff.sim(1500, d = 0.3)
> spm <- fdSperio(memory.long$series)
> str(spm, digits=6)
List of 3
 $ d     : num 0.189757
 $ sd.as : num 0.048145
 $ sd.reg: num 0.0319748
> 
> 
> 
> cleanEx()
> nameEx("fracdiff")
> ### * fracdiff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fracdiff
> ### Title: ML Estimates for Fractionally-Differenced ARIMA (p,d,q) models
> ### Aliases: fracdiff
> ### Keywords: ts
> 
> ### ** Examples
> 
> ts.test <- fracdiff.sim( 5000, ar = .2, ma = -.4, d = .3)
> fd. <- fracdiff( ts.test$series,
+                  nar = length(ts.test$ar), nma = length(ts.test$ma))
> fd.

Call:
  fracdiff(x = ts.test$series, nar = length(ts.test$ar), nma = length(ts.test$ma)) 

Coefficients:
         d         ar         ma 
 0.2901102  0.2095184 -0.4063822 
sigma[eps] = 1.027184 
a list with components:
 [1] "log.likelihood"  "n"               "msg"             "d"              
 [5] "ar"              "ma"              "covariance.dpq"  "fnormMin"       
 [9] "sigma"           "stderror.dpq"    "correlation.dpq" "h"              
[13] "d.tol"           "M"               "hessian.dpq"     "length.w"       
[17] "residuals"       "fitted"          "call"           
> ## Confidence intervals
> confint(fd.)
        2.5 %     97.5 %
d   0.2575096  0.3227108
ar  0.1427570  0.2762798
ma -0.4540280 -0.3587365
> 
> ## with iteration output
> fd2 <- fracdiff(ts.test$series, nar = 1, nma = 1, trace = 1)
dopt() debugging: dinit = 0 ==> xx = 0.190983, fx = pqopt(x[], xx) = 7237.46; min_fnorm = 72.7451
                 it. |           uu |    pqopt(uu) |      delta |
 .. DBG dopt() [ 2]:|     0.309017 |      7229.25 | 1.909830e-01 |
 .. DBG dopt() [ 3]:|     0.381966 |      7236.61 | 1.180340e-01 |
 .. DBG dopt() [ 4]:|      0.28896 |      7228.93 | 9.797742e-02 |
 .. DBG dopt() [ 5]:|     0.290217 |      7228.93 | 1.880041e-02 |
 .. DBG dopt() [ 6]:|      0.29011 |      7228.93 | 1.149754e-03 |
 .. DBG dopt() [ 7]:|     0.290069 |      7228.93 | 1.064085e-04 |
 .. DBG dopt() [ 8]:|     0.290151 |      7228.93 | 4.070933e-05 |
> all.equal(fd., fd2)
[1] "Component “call”: target, current do not match when deparsed"
> 
> 
> 
> cleanEx()
> nameEx("fracdiff.sim")
> ### * fracdiff.sim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fracdiff.sim
> ### Title: Simulate fractional ARIMA Time Series
> ### Aliases: fracdiff.sim
> ### Keywords: ts
> 
> ### ** Examples
> 
> ## Pretty (too) short to "see" the long memory
> fracdiff.sim(100, ar = .2, ma = .4, d = .3)
$series
  [1]  0.23881111 -0.77058664  1.56944453  0.46955593 -0.65866704  0.56022603
  [7]  0.85633192  0.75999222 -0.07255621  1.70478585  0.72601126 -0.26854347
 [13] -1.95074069  1.14336954  0.07771185  0.09074226  1.05358810  1.02797912
 [19]  0.87902437  1.25612190  1.19750080  0.54560747 -1.54212813  0.83600496
 [25]  0.20241969  0.07599861 -1.26409645 -0.42760580  0.42172169  1.41041045
 [31]  0.09498683  0.57956243  0.17870265 -1.16027485 -0.34690184 -0.37167933
 [37] -0.07708237  1.08597823  0.87228625  0.02794560 -0.07612007  0.84521057
 [43]  0.76814146 -0.43174739 -0.53052875  0.46220226  0.89671644  0.08873311
 [49]  1.06826642  0.67098987 -0.31114482  0.56790988 -0.88135265  1.55332601
 [55]  2.24205552  0.08227386 -0.64678862  0.84516271  0.17664792  2.68040789
 [61]  0.46998021  1.17262546  0.56067850 -0.24056761  0.58644768 -1.41504901
 [67]  1.65153451  0.47986235  2.50314512  1.02168014 -0.13577999  1.09144770
 [73] -0.41997327 -0.86549643  0.53439485 -0.18334757  0.20916555  0.28550067
 [79] -0.36913337 -0.40530841 -0.02448992  1.28144130 -1.29475686  0.67357076
 [85]  0.48351171  1.24807387 -0.00811021  0.63228443  0.56244719 -0.23205392
 [91]  1.45339503  1.51957061  1.16184551  2.10370810  1.21237933 -0.60158236
 [97] -0.06402830 -0.80757723 -0.20958069 -0.41743316

$ar
[1] 0.2

$ma
[1] 0.4

$d
[1] 0.3

$mu
[1] 0

$n.start
[1] 6

> 
> ## longer with "extreme" ar:
> r <- fracdiff.sim(n=1500, ar=-0.9, d= 0.3)
> plot(as.ts(r$series))
> 
> ## Show that  MA  coefficients meaning is inverted
> ## compared to   stats :: arima :
> 
> AR <- 0.7
> MA <- -0.5
> n.st <- 2
> 
> AR <- c(0.7, -0.1)
> MA <- c(-0.5, 0.4)
> n <- 512 ; sd <- 0.1
> n.st <- 10
> 
> set.seed(101)
> Y1 <- arima.sim(list(ar = AR, ma = MA), n = n, n.start = n.st, sd = sd)
> plot(Y1)
> 
> # For our fracdiff, reverse the MA sign:
> set.seed(101)
> Y2 <- fracdiff.sim(n = n, ar = AR, ma = - MA, d = 0,
+                    n.start = n.st, sd = sd)$series
> lines(Y2, col=adjustcolor("red", 0.5))
> ## .. no, you don't need glasses ;-)  Y2 is Y1 shifted slightly
> 
> ##' rotate left by k (k < 0: rotate right)
> rot <- function(x, k) {
+   stopifnot(k == round(k))
+   n <- length(x)
+   if(k <- k %% n) x[c((k+1):n, 1:k)] else x
+ }
> k <- n.st - 2
> Y2.s <- rot(Y2, k)
> head.matrix(cbind(Y1, Y2.s))
               Y1         Y2.s
[1,]  0.105653840  0.105986817
[2,] -0.043723547 -0.043557047
[3,]  0.162403833  0.162487085
[4,] -0.131808486 -0.131766860
[5,] -0.001723455 -0.001702642
[6,] -0.054197985 -0.054187579
> plot(Y1, Y2.s); i <- (n-k+1):n
> text(Y1[i], Y2.s[i], i, adj = c(0,0)-.1, col=2)
> 
> ## With  backComp = FALSE,  get *the same* as arima.sim():
> set.seed(101)
> Y2. <- fracdiff.sim(n = n, ar = AR, ma = - MA, d = 0,
+                     n.start = n.st, sd = sd, backComp = FALSE)$series
> stopifnot( all.equal( c(Y1), Y2., tolerance= 1e-15))
> 
> 
> 
> cleanEx()
> nameEx("fracdiff.var")
> ### * fracdiff.var
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fracdiff.var
> ### Title: Recompute Covariance Estimate for fracdiff
> ### Aliases: fracdiff.var
> ### Keywords: ts
> 
> ### ** Examples
> 
> ## Generate a fractionally-differenced ARIMA(1,d,1) model :
> ts.test <- fracdiff.sim(10000, ar = .2, ma = .4, d = .3)
> ## estimate the parameters in an ARIMA(1,d,1) model for the simulated series
> fd.out <- fracdiff(ts.test$ser, nar= 1, nma = 1)
> 
> ## Modify the covariance estimate by changing the finite-difference interval
> (fd.o2 <- fracdiff.var(ts.test$series, fd.out, h = .0001))

Call:
  fracdiff(x = ts.test$ser, nar = 1, nma = 1) 

Coefficients:
        d        ar        ma 
0.2575488 0.1330638 0.2784551 
sigma[eps] = 1.012156 
a list with components:
 [1] "log.likelihood"  "n"               "msg"             "d"              
 [5] "ar"              "ma"              "covariance.dpq"  "fnormMin"       
 [9] "sigma"           "stderror.dpq"    "correlation.dpq" "h"              
[13] "d.tol"           "M"               "hessian.dpq"     "length.w"       
[17] "residuals"       "fitted"          "call"           
> ## looks identical as  print(fd.out),
> ## however these (e.g.) differ :
> vcov(fd.out)
               d          ar1         ma1
d   0.0003744325 0.0009935117 0.001378376
ar1 0.0009935117 0.0068239670 0.007716957
ma1 0.0013783759 0.0077169570 0.009104002
> vcov(fd.o2)
               d         ar1          ma1
d   0.0002518780 0.000668328 0.0009272233
ar1 0.0006683280 0.005961131 0.0065198777
ma1 0.0009272233 0.006519878 0.0074432007
> 
> ## A case, were the default variance is *clearly* way too small:
> set.seed(1); fdc <- fracdiff(X <- fracdiff.sim(n=100,d=0.25)$series)
> fdc

Call:
  fracdiff(x = X <- fracdiff.sim(n = 100, d = 0.25)$series) 

Coefficients:
        d 
0.1140946 
sigma[eps] = 0.8891445 
a list with components:
 [1] "log.likelihood"  "n"               "msg"             "d"              
 [5] "ar"              "ma"              "covariance.dpq"  "fnormMin"       
 [9] "sigma"           "stderror.dpq"    "correlation.dpq" "h"              
[13] "d.tol"           "M"               "hessian.dpq"     "length.w"       
[17] "residuals"       "fitted"          "call"           
> # Confidence intervals just based on asymp.normal approx. and std.errors:
> confint(fdc) # ridiculously too narrow
      2.5 %    97.5 %
d 0.1140919 0.1140973
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.525 0.034 0.558 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
