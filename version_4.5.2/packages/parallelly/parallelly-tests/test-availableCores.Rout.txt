
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #! /usr/bin/env Rscript
> ## This runs testme test script inst/testme/test-availableCores.R
> ## Don't edit - it was autogenerated by inst/testme/deploy.R
> parallelly:::testme("availableCores")
Test ‘availableCores’ ...

> library(parallelly)

> message("*** availableCores() ...")
*** availableCores() ...

> n <- parallel::detectCores()

> message(sprintf("detectCores() = %d", n))
detectCores() = 4

> stopifnot(length(n) == 1, is.numeric(n))

> n <- availableCores()

> message(sprintf("availableCores() = %d", n))
availableCores() = 2

> stopifnot(length(n) == 1, is.integer(n), n >= 1)

> n0 <- n

> n <- availableCores(omit = 1)

> stopifnot(length(n) == 1, is.integer(n), n >= 1, n == 
+     max(1, n0 - 1))

> n <- availableCores(max = 1)

> stopifnot(length(n) == 1, is.integer(n), n == 1)

> print(availableCores(which = "min"))
mc.cores 
       2 

> print(availableCores(which = "max"))
system 
     4 

> ns <- availableCores(na.rm = FALSE, which = "all")

> stopifnot(length(ns) >= 1, is.integer(ns), all(is.na(ns) | 
+     ns >= 0))

> n <- availableCores(methods = "system")

> print(n)
system 
     4 

> stopifnot(length(n) == 1, is.integer(n), n >= 1)

> opts <- options(mc.cores = availableConnections())

> n <- availableCores(constraints = "connections", method = "mc.cores")

> print(n)
connections 
        125 

> stopifnot(length(n) == 1, is.integer(n), n >= 1)

> n0 <- n

> n <- availableCores(constraints = "connections-1", 
+     method = "mc.cores")

> print(n)
connections-1 
          124 

> stopifnot(length(n) == 1, is.integer(n), n >= 1, n == 
+     n0 - 1)

> n <- availableCores(constraints = "connections-2", 
+     method = "mc.cores")

> print(n)
connections-2 
          123 

> stopifnot(length(n) == 1, is.integer(n), n >= 1, n == 
+     n0 - 2)

> n <- availableCores(method = "connections")

> print(n)
connections 
        125 

> stopifnot(length(n) == 1, is.integer(n), n >= 1, n == 
+     n0)

> n <- availableCores(method = "connections-1")

> print(n)
connections-1 
          124 

> stopifnot(length(n) == 1, is.integer(n), n >= 1, n == 
+     n0 - 1)

> n <- availableCores(method = "connections-2")

> print(n)
connections-2 
          123 

> stopifnot(length(n) == 1, is.integer(n), n >= 1, n == 
+     n0 - 2)

> options(opts)

> n <- availableCores(constraints = "multicore")

> print(n)
mc.cores 
       2 

> stopifnot(length(n) == 1, is.integer(n), n >= 1)

> opts <- options(mc.cores = 0)

> n <- availableCores(method = "mc.cores")

> print(n)
mc.cores 
       1 

> stopifnot(length(n) == 1, is.integer(n), n == 1)

> n <- availableCores(method = "mc.cores+1")

> print(n)
mc.cores+1 
         1 

> stopifnot(length(n) == 1, is.integer(n), n == 1)

> options(opts)

> print(availableCores(methods = "PBS"))
current 
      1 

> print(availableCores(methods = "SGE"))
current 
      1 

> print(availableCores(methods = "Slurm"))
current 
      1 

> print(availableCores(methods = "LSF"))
current 
      1 

> print(availableCores(methods = c("width", "FOO_BAR_ENV"), 
+     na.rm = FALSE, which = "all"))
      width FOO_BAR_ENV 
         80          NA 

> Sys.setenv(FOO_BAR_ENV = "0")

> res <- try(availableCores(methods = "FOO_BAR_ENV"), 
+     silent = TRUE)

> stopifnot(inherits(res, "try-error"))

> ncores0 <- 42

> message("*** LSF ...")
*** LSF ...

> message(" - LSB_DJOB_NUMPROC")
 - LSB_DJOB_NUMPROC

> Sys.setenv(LSB_DJOB_NUMPROC = as.character(ncores0))

> env <- environment(parallelly:::availableCoresLSF)

> env$n <- NULL

> ncores <- availableCores(methods = "LSF")

> print(ncores)
LSF 
 42 

> stopifnot(ncores == ncores0)

> message("*** LSF ... done")
*** LSF ... done

> message("*** PJM (Fujitsu Technical Computing Suite) ...")
*** PJM (Fujitsu Technical Computing Suite) ...

> message(" - PJM_VNODE_CORE")
 - PJM_VNODE_CORE

> Sys.setenv(PJM_VNODE_CORE = as.character(ncores0))

> env <- environment(parallelly:::availableCoresPJM)

> env$n <- NULL

> ncores <- availableCores(methods = "PJM")

> print(ncores)
PJM 
 42 

> stopifnot(ncores == ncores0)

> Sys.unsetenv("PJM_VNODE_CORE")

> message(" - PJM_PROC_BY_NODE")
 - PJM_PROC_BY_NODE

> Sys.setenv(PJM_PROC_BY_NODE = as.character(ncores0))

> env <- environment(parallelly:::availableCoresPJM)

> env$n <- NULL

> ncores <- availableCores(methods = "PJM")

> print(ncores)
PJM 
 42 

> stopifnot(ncores == ncores0)

> Sys.unsetenv("PJM_PROC_BY_NODE")

> message("*** PJM (Fujitsu Technical Computing Suite) ... done")
*** PJM (Fujitsu Technical Computing Suite) ... done

> message("*** Internal detectCores() ...")
*** Internal detectCores() ...

> env <- environment(parallelly:::detectCores)

> env$cache <- list(NULL, NULL)

> options(parallelly.availableCores.system = 2)

> n <- detectCores()

> print(n)
[1] 2

> stopifnot(is.integer(n), is.finite(n), n >= 1, n == 
+     2)

> options(parallelly.availableCores.system = NULL)

> env <- environment(parallelly:::detectCores)

> env$cache <- list(NULL, NULL)

> n <- detectCores()

> print(n)
[1] 4

> stopifnot(is.integer(n), is.finite(n), n >= 1)

> message("*** Internal detectCores() ... DONE")
*** Internal detectCores() ... DONE

> message("*** Slurm multi-node scenarios ...")
*** Slurm multi-node scenarios ...

> env <- environment(parallelly:::availableCoresSlurm)

> Sys.unsetenv("SLURM_CPUS_PER_TASK")

> Sys.setenv(SLURM_JOB_NUM_NODES = "1", SLURM_CPUS_ON_NODE = "8")

> env$n <- NULL

> ncores <- availableCores(methods = "Slurm")

> print(ncores)
Slurm 
    8 

> stopifnot(ncores == 8)

> Sys.unsetenv("SLURM_CPUS_PER_TASK")

> Sys.unsetenv("SLURM_JOB_NUM_NODES")

> Sys.setenv(SLURM_NNODES = "1", SLURM_CPUS_ON_NODE = "16")

> env$n <- NULL

> ncores <- availableCores(methods = "Slurm")

> print(ncores)
Slurm 
   16 

> stopifnot(ncores == 16)

> Sys.unsetenv("SLURM_CPUS_PER_TASK")

> Sys.setenv(SLURM_JOB_NUM_NODES = "2", SLURM_TASKS_PER_NODE = "5,2")

> env$n <- NULL

> ncores <- availableCores(methods = "Slurm")

> print(ncores)
Slurm 
    5 

> stopifnot(ncores == 5)

> Sys.unsetenv("SLURM_CPUS_PER_TASK")

> Sys.setenv(SLURM_JOB_NUM_NODES = "5", SLURM_TASKS_PER_NODE = "2(x2),1(x3)")

> env$n <- NULL

> ncores <- availableCores(methods = "Slurm")

> print(ncores)
Slurm 
    2 

> stopifnot(ncores == 2)

> Sys.unsetenv(c("SLURM_CPUS_PER_TASK", "SLURM_JOB_NUM_NODES", 
+     "SLURM_NNODES", "SLURM_CPUS_ON_NODE", "SLURM_TASKS_PER_NODE"))

> env$n <- NULL

> message("*** Slurm multi-node scenarios ... done")
*** Slurm multi-node scenarios ... done

> message("*** PBS NCPUS fallback ...")
*** PBS NCPUS fallback ...

> env <- environment(parallelly:::availableCoresPBS)

> Sys.unsetenv("PBS_NUM_PPN")

> Sys.setenv(NCPUS = "16")

> env$n <- NULL

> ncores <- availableCores(methods = "PBS")

> print(ncores)
PBS 
 16 

> stopifnot(ncores == 16)

> Sys.unsetenv("NCPUS")

> env$n <- NULL

> message("*** PBS NCPUS fallback ... done")
*** PBS NCPUS fallback ... done

> message("*** BiocParallel method ...")
*** BiocParallel method ...

> Sys.setenv(BIOCPARALLEL_WORKER_NUMBER = "4")

> ncores <- availableCores(methods = "BiocParallel")

> print(ncores)
BiocParallel 
           4 

> stopifnot(ncores == 4)

> Sys.unsetenv("BIOCPARALLEL_WORKER_NUMBER")

> message("*** BiocParallel method ... done")
*** BiocParallel method ... done

> message("*** Bioconductor build machine ...")
*** Bioconductor build machine ...

> Sys.setenv(IS_BIOC_BUILD_MACHINE = "TRUE")

> ncores <- availableCores(methods = "Bioconductor")

> print(ncores)
Bioconductor 
           4 

> stopifnot(ncores == 4)

> Sys.unsetenv("IS_BIOC_BUILD_MACHINE")

> Sys.setenv(BBS_HOME = "TRUE")

> ncores <- availableCores(methods = "Bioconductor")

> print(ncores)
Bioconductor 
           4 

> stopifnot(ncores == 4)

> Sys.unsetenv("BBS_HOME")

> message("*** Bioconductor build machine ... done")
*** Bioconductor build machine ... done

> message("*** Custom function method ...")
*** Custom function method ...

> opts <- options(parallelly.availableCores.custom = function() 3)

> ncores <- availableCores(methods = "custom")

> print(ncores)
custom 
     3 

> stopifnot(ncores == 3)

> options(opts)

> opts <- options(parallelly.availableCores.custom = function() NA)

> ncores <- availableCores(methods = c("system", "custom"), 
+     which = "all", na.rm = FALSE)

> print(ncores)
system custom 
     4     NA 

> stopifnot("custom" %in% names(ncores), is.na(ncores["custom"]))

> options(opts)

> opts <- options(parallelly.availableCores.custom = function() {
+     availableCores(methods = "system") - 1
+ })

> ncores <- availableCores(methods = "custom")

> print(ncores)
custom 
     3 

> stopifnot(ncores >= 1)

> options(opts)

> opts <- options(parallelly.availableCores.custom = function() c(1, 
+     2))

> res <- tryCatch(availableCores(methods = "custom"), 
+     error = identity)

> stopifnot(inherits(res, "error"))

> options(opts)

> opts <- options(parallelly.availableCores.custom = "not a function")

> ncores <- availableCores(methods = c("system", "custom"), 
+     which = "all")

> print(ncores)
system 
     4 

> stopifnot(!("custom" %in% names(ncores)))

> options(opts)

> message("*** Custom function method ... done")
*** Custom function method ... done

> message("*** Fallback method ...")
*** Fallback method ...

> opts <- options(parallelly.availableCores.fallback = 2)

> ncores <- availableCores(methods = "fallback")

> print(ncores)
fallback 
       2 

> stopifnot(ncores == 2)

> options(opts)

> opts <- options(parallelly.availableCores.fallback = 2)

> ncores <- availableCores(methods = c("system", "fallback"))

> print(ncores)
fallback 
       2 

> stopifnot(ncores >= 1)

> options(opts)

> message("*** Fallback method ... done")
*** Fallback method ... done

> message("*** parallelly.availableCores.min validation ...")
*** parallelly.availableCores.min validation ...

> opts <- options(parallelly.availableCores.min = "two")

> res <- tryCatch(availableCores(), error = identity)

> stopifnot(inherits(res, "error"))

> options(opts)

> opts <- options(parallelly.availableCores.min = 0)

> res <- tryCatch(availableCores(), error = identity)

> stopifnot(inherits(res, "error"))

> options(opts)

> opts <- options(parallelly.availableCores.min = Inf)

> res <- tryCatch(availableCores(), error = identity)

> stopifnot(inherits(res, "error"))

> options(opts)

> opts <- options(parallelly.availableCores.min = parallel::detectCores() + 
+     1)

> res <- tryCatch(availableCores(), error = identity)

> stopifnot(inherits(res, "error"))

> options(opts)

> opts <- options(parallelly.availableCores.min = c(1, 
+     2))

> res <- tryCatch(availableCores(), error = identity)

> stopifnot(inherits(res, "error"))

> options(opts)

> message("*** parallelly.availableCores.min validation ... done")
*** parallelly.availableCores.min validation ... done

> message("*** Input validation edge cases ...")
*** Input validation edge cases ...

> res <- tryCatch(availableCores(default = 0), error = identity)

> stopifnot(inherits(res, "error"))

> res <- tryCatch(availableCores(default = Inf), error = identity)

> stopifnot(inherits(res, "error"))

> res <- tryCatch(availableCores(omit = -1), error = identity)

> stopifnot(inherits(res, "error"))

> res <- tryCatch(availableCores(omit = Inf), error = identity)

> stopifnot(inherits(res, "error"))

> res <- tryCatch(availableCores(max = 0), error = identity)

> stopifnot(inherits(res, "error"))

> res <- tryCatch(availableCores(max = NA), error = identity)

> stopifnot(inherits(res, "error"))

> res <- tryCatch(availableCores(constraints = c("multicore", 
+     NA)), error = identity)

> stopifnot(inherits(res, "error"))

> message("*** Input validation edge cases ... done")
*** Input validation edge cases ... done

> message("*** checkNumberOfLocalWorkers() ...")
*** checkNumberOfLocalWorkers() ...

> checkNumberOfLocalWorkers <- parallelly:::checkNumberOfLocalWorkers

> result <- tryCatch({
+     checkNumberOfLocalWorkers(I(1000))
+     TRUE
+ }, warning = function(w) FALSE, error = function(e) FALSE)

> stopifnot(result)

> opts <- options(parallelly.maxWorkers.localhost = c(1, 
+     3))

> ncores <- availableCores()

> if (ncores >= 1) {
+     workers <- ncores + 1
+     res <- tryCatch({
+         checkNumberOfLocalWorkers(workers)
+         "none"
+     }, warnin .... [TRUNCATED] 
  workers=3, ncores=2 -> warning

> if (ncores >= 1) {
+     workers <- ncores * 4
+     res <- tryCatch({
+         checkNumberOfLocalWorkers(workers)
+         "none"
+     }, warnin .... [TRUNCATED] 
  workers=8, ncores=2 -> error

> options(opts)

> opts <- options(parallelly.maxWorkers.localhost = numeric(0))

> result <- tryCatch({
+     checkNumberOfLocalWorkers(1000)
+     TRUE
+ }, warning = function(w) FALSE, error = function(e) FALSE)

> stopifnot(result)

> options(opts)

> message("*** checkNumberOfLocalWorkers() ... done")
*** checkNumberOfLocalWorkers() ... done

> message("*** detectCoresHint() ...")
*** detectCoresHint() ...

> detectCoresHint <- parallelly:::detectCoresHint

> sysCores <- parallel::detectCores()

> hint <- detectCoresHint(sysCores)

> message(sprintf("  detectCoresHint(%d): %s", sysCores, 
+     hint))
  detectCoresHint(4): By the way, was parallel::detectCores() used, because the number of workers (4) equals detectCores()? If so, please use parallelly::availableCores() instead

> stopifnot(!is.null(hint), grepl("detectCores", hint))

> hint <- detectCoresHint(sysCores - 1)

> message(sprintf("  detectCoresHint(%d): %s", sysCores - 
+     1, hint))
  detectCoresHint(3): By the way, was parallel::detectCores() used, because the number of workers (3) equals detectCores() - 1? If so, please use parallelly::availableCores() instead

> stopifnot(!is.null(hint), grepl("detectCores", hint), 
+     grepl("- 1", hint))

> hint <- detectCoresHint(sysCores - 2)

> message(sprintf("  detectCoresHint(%d): %s", sysCores - 
+     2, hint))
  detectCoresHint(2): By the way, was parallel::detectCores() used, because the number of workers (2) equals detectCores() - 2? If so, please use parallelly::availableCores() instead

> stopifnot(!is.null(hint), grepl("detectCores", hint), 
+     grepl("- 2", hint))

> hint <- detectCoresHint(1)

> message(sprintf("  detectCoresHint(1): %s", if (is.null(hint)) "NULL" else hint))
  detectCoresHint(1): NULL

> if (sysCores > 3) {
+     stopifnot(is.null(hint))
+ }

> message("*** detectCoresHint() ... done")
*** detectCoresHint() ... done

> message("*** logical parameter ...")
*** logical parameter ...

> n_logical <- availableCores(methods = "system", logical = TRUE)

> print(n_logical)
system 
     4 

> stopifnot(is.integer(n_logical), n_logical >= 1)

> n_physical <- availableCores(methods = "system", logical = FALSE)

> print(n_physical)
system 
     4 

> stopifnot(is.integer(n_physical), n_physical >= 1)

> stopifnot(n_physical <= n_logical)

> message("*** logical parameter ... done")
*** logical parameter ... done

> message("*** connections-N delta tests ...")
*** connections-N delta tests ...

> n_conn <- freeConnections()

> message(sprintf("  freeConnections() = %d", n_conn))
  freeConnections() = 125

> n0 <- availableCores(methods = "connections")

> print(n0)
connections 
        125 

> stopifnot(n0 >= 1)

> n5 <- availableCores(methods = "connections-5")

> print(n5)
connections-5 
          120 

> stopifnot(n5 >= 1)

> if (n0 > 5) {
+     stopifnot(n5 == n0 - 5)
+ }

> n_large <- availableCores(methods = "connections-1000")

> print(n_large)
connections-1000 
               1 

> stopifnot(n_large >= 1)

> message("*** connections-N delta tests ... done")
*** connections-N delta tests ... done

> message("*** na.rm = FALSE with missing values ...")
*** na.rm = FALSE with missing values ...

> ns <- availableCores(methods = c("system", "nonexistent_method_xyz123"), 
+     na.rm = FALSE, which = "all")

> print(ns)
                   system nonexistent_method_xyz123 
                        4                        NA 

> stopifnot("nonexistent_method_xyz123" %in% names(ns))

> stopifnot(is.na(ns["nonexistent_method_xyz123"]))

> message("*** na.rm = FALSE with missing values ... done")
*** na.rm = FALSE with missing values ... done

> message("*** SGE method ...")
*** SGE method ...

> env <- environment(parallelly:::availableCoresSGE)

> Sys.setenv(NSLOTS = "24")

> env$n <- NULL

> ncores <- availableCores(methods = "SGE")

> print(ncores)
SGE 
 24 

> stopifnot(ncores == 24)

> Sys.unsetenv("NSLOTS")

> env$n <- NULL

> message("*** SGE method ... done")
*** SGE method ... done

> message("*** _R_CHECK_LIMIT_CORES_ method ...")
*** _R_CHECK_LIMIT_CORES_ method ...

> Sys.setenv(`_R_CHECK_LIMIT_CORES_` = "TRUE")

> ncores <- availableCores(methods = "_R_CHECK_LIMIT_CORES_")

> print(ncores)
_R_CHECK_LIMIT_CORES_ 
                    2 

> stopifnot(ncores == 2)

> Sys.setenv(`_R_CHECK_LIMIT_CORES_` = "warn")

> ncores <- availableCores(methods = "_R_CHECK_LIMIT_CORES_")

> print(ncores)
_R_CHECK_LIMIT_CORES_ 
                    2 

> stopifnot(ncores == 2)

> Sys.setenv(`_R_CHECK_LIMIT_CORES_` = "false")

> ncores <- availableCores(methods = "_R_CHECK_LIMIT_CORES_", 
+     na.rm = FALSE)

> print(ncores)
_R_CHECK_LIMIT_CORES_ 
                   NA 

> stopifnot(is.na(ncores))

> Sys.unsetenv("_R_CHECK_LIMIT_CORES_")

> message("*** _R_CHECK_LIMIT_CORES_ method ... done")
*** _R_CHECK_LIMIT_CORES_ method ... done

> message("*** nproc method ...")
*** nproc method ...

> has_nproc <- nzchar(Sys.which("nproc"))

> message(sprintf("  - nproc available: %s", has_nproc))
  - nproc available: TRUE

> if (has_nproc) {
+     env <- environment(parallelly:::getNproc)
+     env$res <- NULL
+     ncores <- availableCores(methods = "nproc")
+     print .... [TRUNCATED] 
nproc 
    4 
  - Testing OMP variable handling
  - getNproc() with OMP vars set: 4

> message("*** nproc method ... done")
*** nproc method ... done

> message("*** /proc/self/status method ...")
*** /proc/self/status method ...

> if (file.exists("/proc/self/status")) {
+     ncores <- availableCores(methods = "/proc/self/status")
+     print(ncores)
+     stopifnot(length(nco .... [TRUNCATED] 
/proc/self/status 
                4 

> message("*** /proc/self/status method ... done")
*** /proc/self/status method ... done

> message("*** availableCores() ... DONE")
*** availableCores() ... DONE
Test time: user.self=0.1s, sys.self=0.006s, elapsed=0.2s, user.child=0.01s, sys.child=0.03s
Test ‘availableCores’ ... success
> 
