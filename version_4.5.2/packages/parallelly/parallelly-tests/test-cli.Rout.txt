
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #! /usr/bin/env Rscript
> ## This runs testme test script inst/testme/test-cli.R
> ## Don't edit - it was autogenerated by inst/testme/deploy.R
> parallelly:::testme("cli")
Test ‘cli’ ...

> message("*** CLI ...")
*** CLI ...

> cmdargs <- character(0)

> print(cmdargs)
character(0)

> args <- parallelly:::parse_cmd_args(cmdargs = cmdargs)

> utils::str(args)
 list()

> cmdargs <- c("--int=0", "--int=42", "--num=3.14", 
+     "--logical=TRUE", "--name=abc", "--expr=1+2")

> print(cmdargs)
[1] "--int=0"        "--int=42"       "--num=3.14"     "--logical=TRUE"
[5] "--name=abc"     "--expr=1+2"    

> patterns <- list("--(int)=([[:digit:]]+)", "--(num)=([[:digit:].]+)", 
+     "--(logical)=(TRUE|FALSE)", "--(name)=(.*)", "--(expr)=(.*)")

> str(patterns)
List of 5
 $ : chr "--(int)=([[:digit:]]+)"
 $ : chr "--(num)=([[:digit:].]+)"
 $ : chr "--(logical)=(TRUE|FALSE)"
 $ : chr "--(name)=(.*)"
 $ : chr "--(expr)=(.*)"

> args <- tryCatch(parallelly:::parse_cmd_args(patterns = patterns, 
+     cmdargs = cmdargs), error = identity)

> utils::str(args)
List of 5
 $ int    : 'cmd_arg' chr "42"
 $ num    : 'cmd_arg' chr "3.14"
 $ logical: 'cmd_arg' chr "TRUE"
 $ name   : 'cmd_arg' chr "abc"
 $ expr   : 'cmd_arg' chr "1+2"

> stopifnot(args[["int"]] == "42", args[["num"]] == 
+     "3.14", args[["logical"]] == "TRUE", args[["name"]] == "abc", 
+     args[["expr"]] == "1+2 ..." ... [TRUNCATED] 

> cmdargs <- c("--int=0", "--int=42", "--num=3.14", 
+     "--logical=TRUE", "--name=abc", "--expr=1+2")

> print(cmdargs)
[1] "--int=0"        "--int=42"       "--num=3.14"     "--logical=TRUE"
[5] "--name=abc"     "--expr=1+2"    

> patterns <- list(parallelly:::cli_arg_integer("int"), 
+     parallelly:::cli_arg_numeric("num"), parallelly:::cli_arg_logical("logical"), 
+     pa .... [TRUNCATED] 

> str(patterns)
List of 5
 $ : chr "--(int)=((|[+]|[-])([[:digit:]]+))"
  ..- attr(*, "type")= chr "integer"
 $ : chr "--(num)=((|[+]|[-])([[:digit:].]+|Inf))"
  ..- attr(*, "type")= chr "numeric"
 $ : chr "--(logical)=(TRUE|FALSE|NA)"
  ..- attr(*, "type")= chr "logical"
 $ : chr "--(name)=(.*)"
  ..- attr(*, "type")= chr "character"
 $ : chr "--(expr)=(.*)"
  ..- attr(*, "type")= chr "expr"

> args <- tryCatch(parallelly:::parse_cmd_args(patterns = patterns, 
+     cmdargs = cmdargs), error = identity)

> utils::str(args)
List of 5
 $ int    : 'cmd_arg' int 42
 $ num    : 'cmd_arg' num 3.14
 $ logical: 'cmd_arg' logi TRUE
 $ name   : 'cmd_arg' chr "abc"
 $ expr   : 'cmd_arg' num 3

> stopifnot(is.integer(args[["int"]]), args[["int"]] == 
+     42, is.numeric(args[["num"]]), args[["num"]] == 3.14, is.logical(args[["logical"]]), 
+ .... [TRUNCATED] 

> cmdargs <- c("--int=42", "--num=3.14", "--logical=TRUE", 
+     "--name=abc")

> print(cmdargs)
[1] "--int=42"       "--num=3.14"     "--logical=TRUE" "--name=abc"    

> args <- tryCatch(parallelly:::parse_cmd_args(cmdargs = cmdargs), 
+     error = identity)

> stopifnot(inherits(args, "error"))

> print(parallelly::availableCores, call = FALSE)
function (constraints = NULL, methods = getOption2("parallelly.availableCores.methods", 
    c("system", "/proc/self/status", "cgroups.cpuset", "cgroups.cpuquota", 
        "cgroups2.cpu.max", "nproc", "mc.cores", "BiocParallel", 
        "_R_CHECK_LIMIT_CORES_", "Bioconductor", "LSF", "PJM", 
        "PBS", "SGE", "Slurm", "fallback", "custom")), na.rm = TRUE, 
    logical = getOption2("parallelly.availableCores.logical", 
        TRUE), default = c(current = 1L), which = c("min", "max", 
        "all"), omit = getOption2("parallelly.availableCores.omit", 
        0L), max = getOption2("parallelly.availableCores.max", 
        Inf)) 
{
    stop_if_not(is.null(constraints) || is.character(constraints), 
        !anyNA(constraints))
    pattern_connections <- "^connections(|-[[:digit:]]+)$"
    idxs <- grep(pattern_connections, constraints)
    if (length(idxs) > 0) {
        methods <- unique(c(methods, constraints[idxs]))
    }
    which <- match.arg(which, choices = c("min", "max", "all"))
    stop_if_not(length(default) == 1, is.finite(default), default >= 
        1L)
    stop_if_not(length(omit) == 1L, is.numeric(omit), is.finite(omit), 
        omit >= 0L)
    omit <- as.integer(omit)
    stop_if_not(length(max) == 1L, is.numeric(max), !is.na(max), 
        max >= 1L)
    ncores <- rep(NA_integer_, times = length(methods))
    names(ncores) <- methods
    for (kk in seq_along(methods)) {
        method <- methods[kk]
        if (method == "Slurm") {
            n <- availableCoresSlurm()
        }
        else if (method == "PBS") {
            n <- availableCoresPBS()
        }
        else if (method == "SGE") {
            n <- availableCoresSGE()
        }
        else if (method == "LSF") {
            n <- availableCoresLSF()
        }
        else if (method == "PJM") {
            n <- availableCoresPJM()
        }
        else if (method == "mc.cores") {
            n <- getopt_int("mc.cores")
            if (!is.na(n) && n == 0) 
                n <- 1L
        }
        else if (method == "mc.cores+1") {
            n <- getopt_int("mc.cores") + 1L
        }
        else if (grepl(pattern_connections, method)) {
            n <- freeConnections()
            if (!is.na(n)) {
                delta <- sub(pattern_connections, "\\1", method)
                if (nzchar(delta) && nzchar(omit)) {
                  delta <- as.integer(delta)
                  n <- max(0L, n + delta)
                }
                if (n <= 0L) 
                  n <- 1L
            }
        }
        else if (method == "BiocParallel") {
            n <- getenv_int("BIOCPARALLEL_WORKER_NUMBER")
        }
        else if (method == "_R_CHECK_LIMIT_CORES_") {
            chk <- tolower(Sys.getenv("_R_CHECK_LIMIT_CORES_", 
                ""))
            chk <- (nzchar(chk) && (chk != "false"))
            n <- if (chk) 
                2L
            else NA_integer_
        }
        else if (method == "Bioconductor") {
            n <- NA_integer_
            use <- Sys.getenv("IS_BIOC_BUILD_MACHINE", NA_character_)
            if (isTRUE(as.logical(use))) 
                n <- min(n, 4L, na.rm = TRUE)
            if (is.na(n)) {
                use <- Sys.getenv("BBS_HOME", NA_character_)
                if (isTRUE(as.logical(use))) 
                  n <- min(n, 4L, na.rm = TRUE)
            }
        }
        else if (method == "system") {
            n <- detectCores(logical = logical)
        }
        else if (method == "/proc/self/status") {
            pathname <- "/proc/self/status"
            if (file_test("-f", pathname)) {
                bfr <- readLines(pathname, warn = FALSE)
                bfr <- grep("^Cpus_allowed_list:", bfr, value = TRUE)
                if (length(bfr) == 1) {
                  bfr <- sub("^Cpus_allowed_list:\t", "", bfr)
                  if (nzchar(bfr)) {
                    bfr <- slurm_expand_nodelist(sprintf("[%s]", 
                      bfr))
                    n <- length(bfr)
                  }
                }
            }
        }
        else if (method == "cgroups.cpuset") {
            n <- length(getCGroups1CpuSet())
            if (n == 0L) 
                n <- NA_integer_
        }
        else if (method == "cgroups.cpuquota") {
            n <- getCGroups1CpuQuota()
            if (is.na(n)) {
                n <- NA_integer_
            }
            else {
                n <- as.integer(floor(n + 0.5))
                if (n == 0L) 
                  n <- 1L
            }
        }
        else if (method == "cgroups2.cpu.max") {
            n <- getCGroups2CpuMax()
            if (is.na(n)) {
                n <- NA_integer_
            }
            else {
                n <- as.integer(floor(n + 0.5))
                if (n == 0L) 
                  n <- 1L
            }
        }
        else if (method == "nproc") {
            n <- getNproc()
        }
        else if (method == "fallback") {
            n <- getOption2("parallelly.availableCores.fallback", 
                NA_integer_)
            n <- as.integer(n)
        }
        else if (method == "custom") {
            fcn <- getOption2("parallelly.availableCores.custom", 
                NULL)
            if (!is.function(fcn)) 
                next
            n <- local({
                oopts <- options(parallelly.availableCores.custom = NULL)
                on.exit(options(oopts))
                fcn()
            })
            if (length(n) != 1L) {
                stop("Function specified by option 'parallelly.availableCores.custom' does not a single value")
            }
            n <- as.integer(n)
        }
        else {
            n <- getopt_int(method)
            if (is.na(n)) 
                n <- getenv_int(method)
        }
        ncores[kk] <- n
    }
    ncoresT <- ncores[!is.na(ncores)]
    ncoresT <- ncoresT[ncoresT <= 0]
    if (length(ncoresT) > 0) {
        msg <- sprintf("Detected invalid (zero or less) core settings: %s", 
            paste(paste0(sQuote(names(ncoresT)), " = ", ncoresT), 
                collapse = ", "))
        stop(msg)
    }
    if (na.rm) {
        ncores <- ncores[!is.na(ncores)]
    }
    if (length(ncores) == 0) 
        ncores <- default
    if (length(ncores) >= 2 && (which %in% c("min", "max"))) {
        idx_fallback <- which(names(ncores) == "fallback")
        if (length(idx_fallback) == 1) {
            special <- c("system", "/proc/self/status", "cgroups.cpuset", 
                "cgroups.cpuquota", "cgroups2.cpu.max", "nproc")
            special <- c(special, grep(pattern_connections, constraints, 
                value = TRUE))
            others <- setdiff(names(ncores), c("fallback", special))
            use_fallback <- (length(others) == 0L)
            if (use_fallback && any(ncores[special] < ncores["system"], 
                na.rm = TRUE)) {
                use_fallback <- FALSE
            }
            if (use_fallback) {
                ncores <- ncores[idx_fallback]
            }
            else {
                ncores <- ncores[-idx_fallback]
            }
        }
        if (which == "min") {
            ncores <- ncores[which.min(ncores)]
        }
        else if (which == "max") {
            ncores <- ncores[which.max(ncores)]
        }
    }
    if (length(constraints) > 0L) {
        if ("multicore" %in% constraints) {
            if (!supportsMulticore()) 
                ncores[] <- 1L
        }
    }
    min <- getOption2("parallelly.availableCores.min", 1L)
    if (length(min) != 1L || !is.numeric(min)) {
        stop(sprintf("Option %s is not numeric: %s", sQuote("parallelly.availableCores.min"), 
            mode(min)))
    }
    else if (!is.finite(min) || min < 1L) {
        stop(sprintf("Option %s must be an integer greater than one: %d", 
            sQuote("parallelly.availableCores.min"), min))
    }
    else if (min > detectCores(logical = logical)) {
        stop(sprintf("Option %s must not be greater than the number cores on the system: %d > %d", 
            sQuote("parallelly.availableCores.min"), min, detectCores(logical = logical)))
    }
    else {
        idxs <- which(ncores < min)
        ncores[idxs] <- as.integer(floor(min))
        names(ncores)[idxs] <- paste(names(ncores)[idxs], "*", 
            sep = "")
    }
    if (omit > 0L) {
        ncores <- ncores - omit
        ncores[ncores < 1L] <- 1L
    }
    if (is.finite(max)) {
        ncores <- min(max, ncores, na.rm = TRUE)
        ncores <- as.integer(ncores)
    }
    stop_if_not(all(ncores >= 1L, na.rm = TRUE))
    ncores
}
<bytecode: 0x55cdfa15e148>
<environment: namespace:parallelly>
attr(,"class")
[1] "cli_fcn"  "function"
attr(,"cli_fcn_patterns")
attr(,"cli_fcn_patterns")[[1]]
[1] "--(constraints)=(.*)"
attr(,"type")
[1] "character"

attr(,"cli_fcn_patterns")[[2]]
[1] "--(methods)=(.*)"
attr(,"type")
[1] "character"

attr(,"cli_fcn_patterns")[[3]]
[1] "--(na.rm)=(TRUE|FALSE|NA)"
attr(,"type")
[1] "logical"

attr(,"cli_fcn_patterns")[[4]]
[1] "--(logical)=(TRUE|FALSE|NA)"
attr(,"type")
[1] "logical"

attr(,"cli_fcn_patterns")[[5]]
[1] "--(default)=(.*)"
attr(,"type")
[1] "character"

attr(,"cli_fcn_patterns")[[6]]
[1] "--(which)=(.*)"
attr(,"type")
[1] "character"

attr(,"cli_fcn_patterns")[[7]]
[1] "--(omit)=((|[+]|[-])([[:digit:]]+))"
attr(,"type")
[1] "integer"

attr(,"cli_fcn_patterns")[[8]]
[1] "--(max)=((|[+]|[-])([[:digit:].]+|Inf))"
attr(,"type")
[1] "numeric"

attr(,"cli_fcn_output")
function (x) 
{
    if (is.list(x) || is.data.frame(x)) {
        print(x)
    }
    else if (is.null(names(x))) {
        x <- paste(x, collapse = " ")
        cat(x, "\n", sep = "")
    }
    else {
        x <- as.list(x)
        x <- as.data.frame(x, check.names = FALSE)
        print(x, row.names = FALSE)
    }
}
<environment: 0x55cdfa0aef70>

> options(future.p2p.tests.cmdargs = character(0))

> print(parallelly::availableCores, call = TRUE)
 mc.cores
        2
NULL

> options(future.p2p.tests.cmdargs = c("--max=4"))

> print(parallelly::availableCores, call = TRUE)
2
NULL

> fcn <- function(abc = 0, def = 0) {
+     abc <- as.integer(abc)
+     def <- as.numeric(def)
+     if (abc == 0) {
+         data.frame(abc = abc,  .... [TRUNCATED] 

> parallelly:::cli_fcn(fcn) <- list(parallelly:::cli_arg_integer("abc"), 
+     parallelly:::cli_arg_numeric("def"))

> output <- parallelly:::cli_fcn_output(fcn)

> print(output)
function (x) 
{
    if (is.list(x) || is.data.frame(x)) {
        print(x)
    }
    else if (is.null(names(x))) {
        x <- paste(x, collapse = " ")
        cat(x, "\n", sep = "")
    }
    else {
        x <- as.list(x)
        x <- as.data.frame(x, check.names = FALSE)
        print(x, row.names = FALSE)
    }
}
<bytecode: 0x55cdf82b3e18>
<environment: 0x55cdf82b5238>

> output(42)
42

> output(list(42))
[[1]]
[1] 42


> output(list(abc = 42))
$abc
[1] 42


> output(c(abc = 42))
 abc
  42

> options(future.p2p.tests.cmdargs = character(0))

> void <- print(fcn)
  abc def
1   0   0

> options(future.p2p.tests.cmdargs = c("--abc=0", "--def=3.14"))

> void <- print(fcn)
  abc  def
1   0 3.14

> options(future.p2p.tests.cmdargs = c("--abc=-1", "--def=3.14"))

> void <- print(fcn)
$abc
[1] -1

$def
[1] 3.14


> options(future.p2p.tests.cmdargs = c("--abc=+1", "--def=3.14"))

> void <- print(fcn)
[[1]]
[1] 1

[[2]]
[1] 3.14


> parallelly:::cli_fcn_output(fcn) <- utils::str

> options(future.p2p.tests.cmdargs = c("--abc=+1", "--def=3.14"))

> void <- print(fcn)
List of 2
 $ : int 1
 $ : num 3.14

> parallelly:::cli_fcn(fcn) <- list(structure(parallelly:::cli_arg_integer("abc"), 
+     type = "unknown"))

> void <- tryCatch(print(fcn), error = identity)

> print(void)
<simpleError in parse_cmd_args(patterns = patterns): Unknown cli_arg type: ‘unknown’>

> stopifnot(inherits(void, "error"))

> options(future.p2p.tests.cmdargs = NULL)

> res <- tryCatch(parallelly:::cli_prune(), error = identity)

> print(res)
<simpleError in assign(name, fcn, envir = ns, inherits = FALSE): cannot change value of locked binding for 'availableCores'>

> stopifnot(inherits(res, "error"))

> message("*** CLI ... DONE")
*** CLI ... DONE
Test time: user.self=0.08s, sys.self=0.004s, elapsed=0.09s, user.child=0s, sys.child=0.003s
Test ‘cli’ ... success
> 
