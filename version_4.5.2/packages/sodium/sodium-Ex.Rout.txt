
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "sodium"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('sodium')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("diffie")
> ### * diffie
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Diffie-Hellman
> ### Title: Diffie-Hellman
> ### Aliases: Diffie-Hellman diffie_hellman diffie
> 
> ### ** Examples
> 
> # Bob generates keypair
> bob_key <- keygen()
> bob_pubkey <- pubkey(bob_key)
> 
> # Alice generates keypair
> alice_key <- keygen()
> alice_pubkey <- pubkey(alice_key)
> 
> # After Bob and Alice exchange pubkey they can both derive the secret
> alice_secret <- diffie_hellman(alice_key, bob_pubkey)
> bob_secret <- diffie_hellman(bob_key, alice_pubkey)
> stopifnot(identical(alice_secret, bob_secret))
> 
> 
> 
> cleanEx()
> nameEx("hash")
> ### * hash
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Hash functions
> ### Title: Hash Functions
> ### Aliases: 'Hash functions' hash hashing scrypt argon2 shorthash sha512
> ###   sha256
> 
> ### ** Examples
> 
> # Basic hashing
> msg <- serialize(iris, NULL)
> hash(msg)
 [1] 9d 91 1d ee cc 46 8e ea c1 2c fc c0 ff 68 df e7 03 71 c3 e5 2c 0c 26 93 2e
[26] 8f b3 07 f3 c3 99 11
> sha256(msg)
 [1] 93 0e 7f 33 02 45 62 12 41 c3 f8 30 91 f1 e4 0b 46 3d ec dc ce 26 5f 3c 1a
[26] 31 2c 0a f2 89 10 e6
> sha512(msg)
 [1] 4d 28 23 9e 23 b2 b0 0a 27 5b 1f 83 7a 0a 41 7c fb 44 61 9e e9 00 cb e2 7a
[26] 17 b1 77 48 ae 7e c5 b6 36 39 2d fa f6 b5 df 97 43 2f 62 3d 0e ab cf 5d 21
[51] 59 43 2d bb ff aa 63 aa 44 84 0a 1c f5 c6
> scrypt(msg)
 [1] a5 8f b5 1c 10 63 1f e1 f9 42 12 4b 8d e3 4e 41 40 02 78 bf 59 4e 60 00 d0
[26] ae 68 80 67 38 7d 1d
> 
> # Generate keys from passphrase
> passphrase <- charToRaw("This is super secret")
> key <- hash(passphrase)
> shortkey <- hash(passphrase, size = 16)
> longkey <- hash(passphrase, size = 64)
> 
> # HMAC (hashing with key)
> hash(msg, key = key)
 [1] f5 1f 67 0f f8 e8 34 e0 1b 63 ee 4a d4 51 ba 5c 13 52 7d 22 0b 52 db d5 19
[26] 50 67 e8 c5 d9 56 dc
> shorthash(msg, shortkey)
[1] f8 7b fc 0f 9d 03 2f 9a
> sha256(msg, key = key)
 [1] 45 c2 8f 53 9c e1 85 ee 0c 1d 9a f3 99 f3 38 9b ba a3 84 63 5c 58 0c d4 ca
[26] 86 f3 fd 91 01 bf 06
> sha512(msg, key = longkey)
 [1] 7f e0 7a 62 c2 3d 26 3c f6 75 59 21 14 f5 f7 5e 79 e9 e8 e2 3f 79 7e 61 f4
[26] 15 af fd 9e 82 a8 c7 86 fa 53 7b d8 b1 94 e7 c9 01 15 3c c0 f9 60 e9 3a 49
[51] d1 6e b2 9b 02 82 95 c0 91 fc 64 cc dd da
> 
> 
> 
> cleanEx()
> nameEx("helpers")
> ### * helpers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sodium utilities
> ### Title: Sodium Utilities
> ### Aliases: 'Sodium utilities' bin2hex helpers hex2bin random
> 
> ### ** Examples
> 
> # Convert raw to hex string and back
> test <- charToRaw("test 123")
> x <- bin2hex(test)
> y <- hex2bin(x)
> stopifnot(identical(test, y))
> stopifnot(identical(x, paste(test, collapse = "")))
> 
> # Parse text with characters
> x2 <- paste(test, collapse = ":")
> y2 <- hex2bin(x2, ignore = ":")
> stopifnot(identical(test, y2))
> 
> 
> 
> cleanEx()
> nameEx("keygen")
> ### * keygen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Key generation
> ### Title: Keypair Generation
> ### Aliases: 'Key generation' keygen pubkey
> 
> ### ** Examples
> 
> # Create keypair
> key <- keygen()
> pub <- pubkey(key)
> 
> # Basic encryption
> msg <- serialize(iris, NULL)
> ciphertext <- simple_encrypt(msg, pub)
> out <- simple_decrypt(ciphertext, key)
> stopifnot(identical(msg, out))
> 
> 
> 
> cleanEx()
> nameEx("messaging")
> ### * messaging
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Authenticated encryption
> ### Title: Authenticated Encryption
> ### Aliases: 'Authenticated encryption' auth_encrypt auth_decrypt
> 
> ### ** Examples
> 
> # Bob's keypair:
> bob_key <- keygen()
> bob_pubkey <- pubkey(bob_key)
> 
> # Alice's keypair:
> alice_key <- keygen()
> alice_pubkey <- pubkey(alice_key)
> 
> # Bob sends encrypted message for Alice:
> msg <- charToRaw("TTIP is evil")
> ciphertext <- auth_encrypt(msg, bob_key, alice_pubkey)
> 
> # Alice verifies and decrypts with her key
> out <- auth_decrypt(ciphertext, alice_key, bob_pubkey)
> stopifnot(identical(out, msg))
> 
> # Alice sends encrypted message for Bob
> msg <- charToRaw("Let's protest")
> ciphertext <- auth_encrypt(msg, alice_key, bob_pubkey)
> 
> # Bob verifies and decrypts with his key
> out <- auth_decrypt(ciphertext, bob_key, alice_pubkey)
> stopifnot(identical(out, msg))
> 
> 
> 
> cleanEx()
> nameEx("password")
> ### * password
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Password storage
> ### Title: Password Storage
> ### Aliases: 'Password storage' password_store password password_verify
> 
> ### ** Examples
> 
> # Example password
> password <- "I like cookies"
> 
> # Hash is what you store in the database
> hash <- password_store(password)
> 
> # To verify the password when the user logs in
> stopifnot(password_verify(hash, password))
> 
> 
> 
> cleanEx()
> nameEx("sig")
> ### * sig
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Signatures
> ### Title: Create and Verify Signatures
> ### Aliases: Signatures sig_sign sig sig_verify sig_keygen sig_pubkey
> 
> ### ** Examples
> 
> # Generate keypair
> key <- sig_keygen()
> pubkey <- sig_pubkey(key)
> 
> # Create signature
> msg <- serialize(iris, NULL)
> sig <- sig_sign(msg, key)
> sig_verify(msg, sig, pubkey)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("simple")
> ### * simple
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Simple encryption
> ### Title: Anonymous Public-key Encryption (Sealed Box)
> ### Aliases: 'Simple encryption' simple_encrypt simple_decrypt
> 
> ### ** Examples
> 
> # Generate keypair
> key <- keygen()
> pub <- pubkey(key)
> 
> # Encrypt message with pubkey
> msg <- serialize(iris, NULL)
> ciphertext <- simple_encrypt(msg, pub)
> 
> # Decrypt message with private key
> out <- simple_decrypt(ciphertext, key)
> stopifnot(identical(out, msg))
> 
> 
> 
> cleanEx()
> nameEx("stream")
> ### * stream
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Stream ciphers
> ### Title: Stream Ciphers
> ### Aliases: 'Stream ciphers' chacha20 stream xchacha20 salsa20 xsalsa20
> 
> ### ** Examples
> 
> # Very basic encryption
> myfile <- file.path(R.home(), "COPYING")
> message <- readBin(myfile, raw(), file.info(myfile)$size)
> passwd <- charToRaw("My secret passphrase")
> 
> # Encrypt:
> key <- hash(passwd)
> nonce8 <- random(8)
> stream <- chacha20(length(message), key, nonce8)
> ciphertext <- base::xor(stream, message)
> 
> # Decrypt:
> stream <- chacha20(length(ciphertext), key, nonce8)
> out <- base::xor(ciphertext, stream)
> stopifnot(identical(out, message))
> 
> # Other stream ciphers
> stream <- salsa20(10000, key, nonce8)
> stream <- xsalsa20(10000, key, random(24))
> stream <- xchacha20(10000, key, random(24))
> 
> 
> 
> 
> cleanEx()
> nameEx("symmetric")
> ### * symmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Symmetric encryption
> ### Title: Symmetric Encryption and Tagging
> ### Aliases: 'Symmetric encryption' data_encrypt data_decrypt data_tag
> 
> ### ** Examples
> 
> # 256-bit key
> key <- sha256(charToRaw("This is a secret passphrase"))
> msg <- serialize(iris, NULL)
> 
> # Encrypts with random nonce
> cipher <- data_encrypt(msg, key)
> orig <- data_decrypt(cipher, key)
> stopifnot(identical(msg, orig))
> 
> # Tag the message with your key (HMAC)
> tag <- data_tag(msg, key)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.145 0.012 0.156 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
