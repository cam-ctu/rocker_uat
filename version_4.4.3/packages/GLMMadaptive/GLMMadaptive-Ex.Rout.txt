
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "GLMMadaptive"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('GLMMadaptive')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("continuation_ratio")
> ### * continuation_ratio
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Continuation Ratio Set-Up
> ### Title: Functions to Set-Up Data for a Continuation Ratio Mixed Model
> ### Aliases: cr_setup cr_marg_probs
> 
> ### ** Examples
> 
> n <- 300 # number of subjects
> K <- 8 # number of measurements per subject
> t_max <- 15 # maximum follow-up time
> 
> # we constuct a data frame with the design: 
> # everyone has a baseline measurment, and then measurements at random follow-up times
> DF <- data.frame(id = rep(seq_len(n), each = K),
+                  time = c(replicate(n, c(0, sort(runif(K - 1, 0, t_max))))),
+                  sex = rep(gl(2, n/2, labels = c("male", "female")), each = K))
> 
> # design matrices for the fixed and random effects
> X <- model.matrix(~ sex * time, data = DF)[, -1]
> Z <- model.matrix(~ 1, data = DF)
> 
> thrs <- c(-1.5, 0, 0.9) # thresholds for the different ordinal categories
> betas <- c(-0.25, 0.24, -0.05) # fixed effects coefficients
> D11 <- 0.48 # variance of random intercepts
> D22 <- 0.1 # variance of random slopes
> 
> # we simulate random effects
> b <- cbind(rnorm(n, sd = sqrt(D11)), rnorm(n, sd = sqrt(D22)))[, 1, drop = FALSE]
> # linear predictor
> eta_y <- drop(X %*% betas + rowSums(Z * b[DF$id, , drop = FALSE]))
> # linear predictor for each category
> eta_y <- outer(eta_y, thrs, "+")
> # marginal probabilities per category
> mprobs <- cr_marg_probs(eta_y)
> # we simulate ordinal longitudinal data
> DF$y <- unname(apply(mprobs, 1, sample, x = ncol(mprobs), size = 1, replace = TRUE))
> 
> # If you want to simulate from the backward formulation of the CR model, you need to
> # change `eta_y <- outer(eta_y, thrs, "+")` to `eta_y <- outer(eta_y, rev(thrs), "+")`,
> # and `mprobs <- cr_marg_probs(eta_y)` to `mprobs <- cr_marg_probs(eta_y, "backward")`
> 
> #################################################
> 
> # prepare the data
> # If you want to fit the CR model under the backward formulation, you need to change
> # `cr_vals <- cr_setup(DF$y)` to `cr_vals <- cr_setup(DF$y, "backward")`
> cr_vals <- cr_setup(DF$y)
> cr_data <- DF[cr_vals$subs, ]
> cr_data$y_new <- cr_vals$y
> cr_data$cohort <- cr_vals$cohort
> 
> # fit the model
> fm <- mixed_model(y_new ~ cohort + sex * time, random = ~ 1 | id, 
+                   data = cr_data, family = binomial())
> 
> summary(fm)

Call:
mixed_model(fixed = y_new ~ cohort + sex * time, random = ~1 | 
    id, data = cr_data, family = binomial())

Data Descriptives:
Number of Observations: 4206
Number of Groups: 300 

Model:
 family: binomial
 link: logit 

Fit statistics:
   log.Lik      AIC      BIC
 -2443.011 4900.023 4925.949

Random effects covariance matrix:
               StdDev
(Intercept) 0.6501884

Fixed effects:
               Estimate Std.Err  z-value   p-value
(Intercept)     -1.7028  0.1137 -14.9777   < 1e-04
cohorty>=2       1.5557  0.0897  17.3382   < 1e-04
cohorty>=3       2.3256  0.1341  17.3454   < 1e-04
sexfemale       -0.0289  0.1357  -0.2134 0.8310248
time             0.2515  0.0136  18.4946   < 1e-04
sexfemale:time  -0.0548  0.0167  -3.2827 0.0010281

Integration:
method: adaptive Gauss-Hermite quadrature rule
quadrature points: 11

Optimization:
method: EM
converged: TRUE 
> 
> 
> 
> cleanEx()
> nameEx("effectPlotData")
> ### * effectPlotData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: effectPlotData
> ### Title: Predicted Values for Effects Plots
> ### Aliases: effectPlotData effectPlotData.MixMod
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("extra_fams")
> ### * extra_fams
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extra Family Objects
> ### Title: Family functions for Student's-t, Beta, Zero-Inflated and Hurdle
> ###   Poisson and Negative Binomial, Hurdle Log-Normal, Hurdle Beta, Gamma,
> ###   and Censored Normal Mixed Models
> ### Aliases: students.t beta.fam beta.binomial zi.poisson zi.binomial
> ###   zi.negative.binomial hurdle.poisson hurdle.negative.binomial
> ###   hurdle.lognormal hurdle.beta.fam unit.lindley Gamma.fam
> ###   censored.normal
> 
> ### ** Examples
> 
> # simulate some data from a negative binomial model
> set.seed(102)
> dd <- expand.grid(f1 = factor(1:3), f2 = LETTERS[1:2], g = 1:30, rep = 1:15,
+                   KEEP.OUT.ATTRS = FALSE)
> mu <- 5*(-4 + with(dd, as.integer(f1) + 4 * as.numeric(f2)))
> dd$y <- rnbinom(nrow(dd), mu = mu, size = 0.5)
> 
> # Fit a zero-inflated Poisson model, with only fixed effects in the 
> # zero-inflated part
> fm1 <- mixed_model(fixed = y ~ f1 * f2, random = ~ 1 | g, data = dd, 
+                   family = zi.poisson(), zi_fixed = ~ 1)
> 
> summary(fm1)

Call:
mixed_model(fixed = y ~ f1 * f2, random = ~1 | g, data = dd, 
    family = zi.poisson(), zi_fixed = ~1)

Data Descriptives:
Number of Observations: 2700
Number of Groups: 30 

Model:
 family: zero-inflated poisson
 link: log 

Fit statistics:
   log.Lik      AIC      BIC
 -38656.66 77329.32 77340.53

Random effects covariance matrix:
               StdDev
(Intercept) 0.1206881

Fixed effects:
            Estimate Std.Err  z-value p-value
(Intercept)   2.0369  0.0301  67.7765 < 1e-04
f12           0.5228  0.0253  20.6624 < 1e-04
f13           0.9018  0.0239  37.7840 < 1e-04
f2B           1.3992  0.0224  62.5730 < 1e-04
f12:f2B      -0.3802  0.0282 -13.4937 < 1e-04
f13:f2B      -0.6665  0.0268 -24.9152 < 1e-04

Zero-part coefficients:
            Estimate Std.Err  z-value p-value
(Intercept)  -1.4413  0.0489 -29.4463 < 1e-04

Integration:
method: adaptive Gauss-Hermite quadrature rule
quadrature points: 11

Optimization:
method: hybrid EM and quasi-Newton
converged: TRUE 
> 
> 
> 
> 
> cleanEx()
> nameEx("marginal_coefs")
> ### * marginal_coefs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marginal_coefs
> ### Title: Marginal Coefficients from Generalized Linear Mixed Models
> ### Aliases: marginal_coefs marginal_coefs.MixMod
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("methods")
> ### * methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MixMod Methods
> ### Title: Various Methods for Standard Generics
> ### Aliases: methods.MixMod coef coef.MixMod fixef fixef.MixMod ranef
> ###   ranef.MixMod confint confint.MixMod anova anova.MixMod fitted
> ###   fitted.MixMod residuals residuals.MixMod predict predict.MixMod
> ###   simulate simulate.MixMod terms terms.MixMod formula formula.MixMod
> ###   model.matrix model.matrix.MixMod model.frame model.frame.MixMod nobs
> ###   nobs.MixMod VIF VIF.MixMod cooks.distance cooks.distance.MixMod
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("mixed_model")
> ### * mixed_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mixed_model
> ### Title: Generalized Linear Mixed Effects Models
> ### Aliases: mixed_model
> 
> ### ** Examples
> 
> # simulate some data
> set.seed(123L)
> n <- 200
> K <- 15
> t.max <- 25
> 
> betas <- c(-2.13, -0.25, 0.24, -0.05)
> D <- matrix(0, 2, 2)
> D[1:2, 1:2] <- c(0.48, -0.08, -0.08, 0.18)
> 
> times <- c(replicate(n, c(0, sort(runif(K-1, 0, t.max)))))
> group <- sample(rep(0:1, each = n/2))
> DF <- data.frame(year = times, group = factor(rep(group, each = K)))
> X <- model.matrix(~ group * year, data = DF)
> Z <- model.matrix(~ year, data = DF)
> 
> b <- cbind(rnorm(n, sd = sqrt(D[1, 1])), rnorm(n, sd = sqrt(D[2, 2])))
> id <- rep(1:n, each = K)
> eta.y <- as.vector(X %*% betas + rowSums(Z * b[id, ]))
> DF$y <- rbinom(n * K, 1, plogis(eta.y))
> DF$id <- factor(id)
> 
> ################################################
> 
> fm1 <- mixed_model(fixed = y ~ year * group, random = ~ 1 | id, data = DF,
+                    family = binomial())
> 
> # fixed effects
> fixef(fm1)
(Intercept)        year      group1 year:group1 
-2.51135823  0.23304276 -0.88784195 -0.05174851 
> 
> # random effects
> head(ranef(fm1))
  (Intercept)
1   0.2428149
2   2.1943191
3   1.2898486
4  -1.2667384
5  -0.7294567
6   3.1614903
> 
> # detailed output
> summary(fm1)

Call:
mixed_model(fixed = y ~ year * group, random = ~1 | id, data = DF, 
    family = binomial())

Data Descriptives:
Number of Observations: 3000
Number of Groups: 200 

Model:
 family: binomial
 link: logit 

Fit statistics:
   log.Lik      AIC      BIC
 -1225.973 2461.947 2478.438

Random effects covariance matrix:
              StdDev
(Intercept) 2.851543

Fixed effects:
            Estimate Std.Err z-value   p-value
(Intercept)  -2.5114  0.3430 -7.3216   < 1e-04
year          0.2330  0.0155 15.0812   < 1e-04
group1       -0.8878  0.4816 -1.8437 0.0652272
year:group1  -0.0517  0.0195 -2.6534 0.0079694

Integration:
method: adaptive Gauss-Hermite quadrature rule
quadrature points: 11

Optimization:
method: hybrid EM and quasi-Newton
converged: TRUE 
> 
> # fitted values for the 'mean subject', i.e., with
> # random effects values equal to 0
> head(fitted(fm1, type = "mean_subject"))
         1          2          3          4          5          6 
0.03232047 0.03944053 0.10950605 0.17572685 0.20676636 0.20921567 
> 
> # fitted values for the conditioning on the estimated random effects
> head(fitted(fm1, type = "subject_specific"))
         1          2          3          4          5          6 
0.04084042 0.04974091 0.13552321 0.21370151 0.24941898 0.25221291 
> 
> ##############
> 
> 
> 
> cleanEx()
> nameEx("negative_binomial")
> ### * negative_binomial
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: negative.binomial
> ### Title: Family function for Negative Binomial Mixed Models
> ### Aliases: negative.binomial
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("scoring_rules")
> ### * scoring_rules
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scoring_rules
> ### Title: Proper Scoring Rules for Categorical Data
> ### Aliases: scoring_rules
> 
> ### ** Examples
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  8.598 13.796 6.787 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
