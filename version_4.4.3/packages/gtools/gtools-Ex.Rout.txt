
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "gtools"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('gtools')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ASCIIfy")
> ### * ASCIIfy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ASCIIfy
> ### Title: Convert Characters to ASCII
> ### Aliases: ASCIIfy
> ### Keywords: character utilites
> 
> ### ** Examples
> 
> cities <- c("S\u00e3o Paulo", "Reykjav\u00edk")
> print(cities)
[1] "São Paulo" "Reykjavík"
> ASCIIfy(cities, 1)
[1] "S\\xe3o Paulo" "Reykjav\\xedk"
> ASCIIfy(cities, 2)
[1] "S\\u00e3o Paulo" "Reykjav\\u00edk"
> 
> athens <- "\u0391\u03b8\u03ae\u03bd\u03b1"
> print(athens)
[1] "Αθήνα"
> ASCIIfy(athens)
[1] "\\u0391\\u03b8\\u03ae\\u03bd\\u03b1"
> 
> 
> 
> 
> cleanEx()
> nameEx("asc")
> ### * asc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asc
> ### Title: Convert between characters and ASCII codes
> ### Aliases: asc chr
> ### Keywords: character programming
> 
> ### ** Examples
> 
> 
> ## ascii codes for lowercase letters
> asc(letters)
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t 
 97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 
  u   v   w   x   y   z 
117 118 119 120 121 122 
> 
> ## uppercase letters from ascii codes
> chr(65:90)
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
[20] "T" "U" "V" "W" "X" "Y" "Z"
> 
> ## works on muti-character strings
> (tmp <- asc("hello!"))
     hello!
[1,]    104
[2,]    101
[3,]    108
[4,]    108
[5,]    111
[6,]     33
> chr(tmp)
[1] "h" "e" "l" "l" "o" "!"
> 
> ## Use 'simplify=FALSE' to return the result as a list
> (tmp <- asc("hello!", simplify = FALSE))
$`hello!`
[1] 104 101 108 108 111  33

> chr(tmp)
  hello! 
"hello!" 
> 
> ## When simplify=FALSE the results can be...
> asc(c("a", "e", "i", "o", "u", "y")) # a vector
  a   e   i   o   u   y 
 97 101 105 111 117 121 
> asc(c("ae", "io", "uy")) # or a matrix
      ae  io  uy
[1,]  97 105 117
[2,] 101 111 121
> 
> ## When simplify=TRUE the results are always a list...
> asc(c("a", "e", "i", "o", "u", "y"), simplify = FALSE)
$a
[1] 97

$e
[1] 101

$i
[1] 105

$o
[1] 111

$u
[1] 117

$y
[1] 121

> asc(c("ae", "io", "uy"), simplify = FALSE)
$ae
[1]  97 101

$io
[1] 105 111

$uy
[1] 117 121

> 
> 
> 
> cleanEx()
> nameEx("ask")
> ### * ask
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ask
> ### Title: Display a prompt and collect the user's response
> ### Aliases: ask
> ### Keywords: IO
> 
> ### ** Examples
> 
> 
> 
> # use default prompt
> ask()
Press <RETURN> to continue: 
[1] ""
> silly <- function() {
+   age <- ask("How old aroe you? ")
+   age <- as.numeric(age)
+   cat("In 10 years you will be", age + 10, "years old!\n")
+ }
> 
> 
> 
> cleanEx()
> nameEx("badDend")
> ### * badDend
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: badDend
> ### Title: Dataset That Crashes Base:::Plot.Dendogram with 'Node Stack
> ###   Overflow'
> ### Aliases: badDend
> ### Keywords: datasets
> 
> ### ** Examples
> 
> 
> data(badDend)
> 
> 
> 
> cleanEx()
> nameEx("baseOf")
> ### * baseOf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: baseOf
> ### Title: Transform an integer to an array of base-n digits
> ### Aliases: baseOf
> ### Keywords: base
> 
> ### ** Examples
> 
> 
> # decimal representation
> baseOf(123)
100  10   0 
  1   2   3 
> 
> # binary representation
> baseOf(123, base = 2)
64 32 16  8  4  2  0 
 1  1  1  1  0  1  1 
> 
> # octal representation
> baseOf(123, base = 8)
64  8  0 
 1  7  3 
> 
> # hexadecimal representation
> baseOf(123, base = 16)
16  0 
 7 11 
> 
> # hexadecimal with more typical letter-notation
> c(0:9, LETTERS)[baseOf(123, 16)]
[1] "6" "A"
> 
> # hexadecimal again, now showing a single string
> paste(c(0:9, LETTERS)[baseOf(123, 16)], collapse = "")
[1] "6A"
> 
> # decimal representation but filling leading zeroes
> baseOf(123, len = 5)
10000  1000   100    10     0 
    0     0     1     2     3 
> 
> # and converting that back
> sum(2^(4:0) * baseOf(123, len = 5))
[1] 11
> 
> # hashing and a tabular venn diagram derived from it
> m <- matrix(sample(c(FALSE, TRUE), replace = TRUE, size = 300), ncol = 4)
> colnames(m) <- c("strong", "colorful", "nice", "humorous")
> names(dimnames(m)) <- c("samples", "features")
> head(m)
       features
samples strong colorful  nice humorous
   [1,]  FALSE     TRUE  TRUE    FALSE
   [2,]   TRUE     TRUE FALSE     TRUE
   [3,]  FALSE    FALSE FALSE    FALSE
   [4,]  FALSE    FALSE FALSE    FALSE
   [5,]   TRUE     TRUE FALSE     TRUE
   [6,]  FALSE     TRUE  TRUE    FALSE
> 
> m.val <- apply(m, 1, function(X) {
+   return(sum(2^((ncol(m) - 1):0) * X))
+ })
> m.val.rle <- rle(sort(m.val))
> m.counts <- cbind(
+   baseOf(m.val.rle$value, base = 2, len = ncol(m)),
+   m.val.rle$lengths
+ )
> colnames(m.counts) <- c(colnames(m), "num")
> rownames(m.counts) <- apply(m.counts[, 1:ncol(m)], 1, paste, collapse = "")
> m.counts[1 == m.counts[, "nice"] & 1 == m.counts[, "humorous"], , drop = FALSE]
     strong colorful nice humorous num
0011      0        0    1        1   7
0111      0        1    1        1   1
1011      1        0    1        1   2
1111      1        1    1        1   9
> m.counts[, "num", drop = TRUE]
0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 
   5    7    3    7    3    4    6    1    4    4    6    2    4    8    2    9 
> 
> 
> 
> cleanEx()
> nameEx("binsearch")
> ### * binsearch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: binsearch
> ### Title: Binary Search
> ### Aliases: binsearch
> ### Keywords: optimize programming
> 
> ### ** Examples
> 
> 
> 
> ### Toy examples
> 
> # search for x=10
> binsearch(function(x) x - 10, range = c(0, 20))
$call
binsearch(fun = function(x) x - 10, range = c(0, 20))

$numiter
[1] 1

$flag
[1] "Found"

$where
[1] 10

$value
[1] 0

> 
> # search for x=10.1
> binsearch(function(x) x - 10.1, range = c(0, 20))
$call
binsearch(fun = function(x) x - 10.1, range = c(0, 20))

$numiter
[1] 5

$flag
[1] "Between Elements"

$where
[1] 10 11

$value
[1] -0.1  0.9

> 
> ### Classical toy example
> 
> # binary search for the index of 'M' among the sorted letters
> fun <- function(X) {
+   ifelse(LETTERS[X] > "M", 1,
+     ifelse(LETTERS[X] < "M", -1, 0)
+   )
+ }
> 
> binsearch(fun, range = 1:26)
$call
binsearch(fun = fun, range = 1:26)

$numiter
[1] 5

$flag
[1] "Found"

$where
[1] 13

$value
[1] 0

> # returns $where=13
> LETTERS[13]
[1] "M"
> 
> ### Substantive example, from genetics
> ## Not run: 
> ##D library(genetics)
> ##D # Determine the necessary sample size to detect all alleles with
> ##D # frequency 0.07 or greater with probability 0.95.
> ##D power.fun <- function(N) 1 - gregorius(N = N, freq = 0.07)$missprob
> ##D 
> ##D binsearch(power.fun, range = c(0, 100), target = 0.95)
> ##D 
> ##D # equivalent to
> ##D gregorius(freq = 0.07, missprob = 0.05)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("capwords")
> ### * capwords
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capwords
> ### Title: Capitalize Words for Titles
> ### Aliases: capwords
> ### Keywords: character utilites
> 
> ### ** Examples
> 
> 
> capwords("a function to capitalize words in a title")
[1] "A Function to Capitalize Words in a Title"
> capwords("a function to capitalize words in a title", AP = FALSE)
[1] "A Function To Capitalize Words In A Title"
> 
> capwords("testing the iProduct for defects")
[1] "Testing the IProduct for Defects"
> capwords("testing the iProduct for defects", strict = TRUE)
[1] "Testing the Iproduct for Defects"
> capwords("testing the iProduct for defects", onlyfirst = TRUE)
[1] "Testing the iProduct for defects"
> capwords("testing the iProduct for defects", preserveMixed = TRUE)
[1] "Testing the iProduct for Defects"
> 
> capwords("title_using_underscores_as_separators", sep = "_")
[1] "Title_Using_Underscores_As_Separators"
> 
> 
> 
> cleanEx()
> nameEx("checkRVersion")
> ### * checkRVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkRVersion
> ### Title: Check if a newer version of R is available
> ### Aliases: checkRVersion
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> try(
+    ver <- checkRVersion()
+ )
A newer version of R is now available: 4.5.1
> print(ver)
[1] ‘4.5.1’
> 
> 
> 
> cleanEx()
> nameEx("combinations")
> ### * combinations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: combinations
> ### Title: Enumerate the Combinations or Permutations of the Elements of a
> ###   Vector
> ### Aliases: combinations permutations
> ### Keywords: manip
> 
> ### ** Examples
> 
> 
> combinations(3,2,letters[1:3])
     [,1] [,2]
[1,] "a"  "b" 
[2,] "a"  "c" 
[3,] "b"  "c" 
> combinations(3,2,letters[1:3],repeats=TRUE)
     [,1] [,2]
[1,] "a"  "a" 
[2,] "a"  "b" 
[3,] "a"  "c" 
[4,] "b"  "b" 
[5,] "b"  "c" 
[6,] "c"  "c" 
> 
> permutations(3,2,letters[1:3])
     [,1] [,2]
[1,] "a"  "b" 
[2,] "a"  "c" 
[3,] "b"  "a" 
[4,] "b"  "c" 
[5,] "c"  "a" 
[6,] "c"  "b" 
> permutations(3,2,letters[1:3],repeats=TRUE)
      [,1] [,2]
 [1,] "a"  "a" 
 [2,] "a"  "b" 
 [3,] "a"  "c" 
 [4,] "b"  "a" 
 [5,] "b"  "b" 
 [6,] "b"  "c" 
 [7,] "c"  "a" 
 [8,] "c"  "b" 
 [9,] "c"  "c" 
> 
> ## Not run: 
> ##D # To use large 'n', you need to change the default recusion limit
> ##D options(expressions=1e5)
> ##D cmat <- combinations(300,2)
> ##D dim(cmat) # 44850 by 2 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("defmacro")
> ### * defmacro
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: defmacro
> ### Title: Define a macro
> ### Aliases: defmacro strmacro
> ### Keywords: ## Code from programming
> 
> ### ** Examples
> 
> 
> ####
> # macro for replacing a specified missing value indicator with NA
> # within a dataframe
> ###
> setNA <- defmacro(df, var, values,
+   expr = {
+     df$var[df$var %in% values] <- NA
+   }
+ )
> 
> # create example data using 999 as a missing value indicator
> d <- data.frame(
+   Grp = c("Trt", "Ctl", "Ctl", "Trt", "Ctl", "Ctl", "Trt", "Ctl", "Trt", "Ctl"),
+   V1 = c(1, 2, 3, 4, 5, 6, 999, 8, 9, 10),
+   V2 = c(1, 1, 1, 1, 1, 2, 999, 2, 999, 999),
+   stringsAsFactors = TRUE
+ )
> d
   Grp  V1  V2
1  Trt   1   1
2  Ctl   2   1
3  Ctl   3   1
4  Trt   4   1
5  Ctl   5   1
6  Ctl   6   2
7  Trt 999 999
8  Ctl   8   2
9  Trt   9 999
10 Ctl  10 999
> 
> # Try it out
> setNA(d, V1, 999)
> setNA(d, V2, 999)
> d
   Grp V1 V2
1  Trt  1  1
2  Ctl  2  1
3  Ctl  3  1
4  Trt  4  1
5  Ctl  5  1
6  Ctl  6  2
7  Trt NA NA
8  Ctl  8  2
9  Trt  9 NA
10 Ctl 10 NA
> 
> 
> ###
> # Expression macro
> ###
> plot.d <- defmacro(df, var, DOTS,
+   col = "red", title = "", expr =
+     plot(df$var ~ df$Grp, type = "b", col = col, main = title, ...)
+ )
> 
> plot.d(d, V1)
> plot.d(d, V1, col = "blue")
> plot.d(d, V1, lwd = 4) # use optional 'DOTS' argument
> 
> ###
> # String macro (note the quoted text in the calls below)
> #
> # This style of macro can be useful when you are reading
> # function arguments from a text file
> ###
> plot.s <- strmacro(DF, VAR,
+   COL = "'red'", TITLE = "''", DOTS = "", expr =
+     plot(DF$VAR ~ DF$Grp, type = "b", col = COL, main = TITLE, DOTS)
+ )
> 
> plot.s("d", "V1")
> plot.s(DF = "d", VAR = "V1", COL = '"blue"')
> plot.s("d", "V1", DOTS = "lwd=4") # use optional 'DOTS' argument
> 
> 
> 
> #######
> # Create a macro that defines new functions
> ######
> plot.sf <- defmacro(
+   type = "b", col = "black",
+   title = deparse(substitute(x)), DOTS, expr =
+     function(x, y) plot(x, y, type = type, col = col, main = title, ...)
+ )
> 
> plot.red <- plot.sf(col = "red", title = "Red is more Fun!")
> plot.blue <- plot.sf(col = "blue", title = "Blue is Best!", lty = 2)
> 
> plot.red(1:100, rnorm(100))
> plot.blue(1:100, rnorm(100))
> 
> 
> 
> cleanEx()
> nameEx("dirichlet")
> ### * dirichlet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dirichlet
> ### Title: Functions for the Dirichlet Distribution
> ### Aliases: dirichlet rdirichlet ddirichlet
> ### Keywords: distribution
> 
> ### ** Examples
> 
> 
> 
> x <- rdirichlet(20, c(1, 1, 1))
> 
> ddirichlet(x, c(1, 1, 1))
 [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
> 
> 
> 
> cleanEx()
> nameEx("foldchange")
> ### * foldchange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: foldchange
> ### Title: Compute fold-change or convert between log-ratio and
> ###   fold-change.
> ### Aliases: foldchange logratio2foldchange foldchange2logratio
> ### Keywords: math
> 
> ### ** Examples
> 
> 
> 
> a <- 1:21
> b <- 21:1
> 
> f <- foldchange(a, b)
> 
> cbind(a, b, f)
       a  b          f
 [1,]  1 21 -21.000000
 [2,]  2 20 -10.000000
 [3,]  3 19  -6.333333
 [4,]  4 18  -4.500000
 [5,]  5 17  -3.400000
 [6,]  6 16  -2.666667
 [7,]  7 15  -2.142857
 [8,]  8 14  -1.750000
 [9,]  9 13  -1.444444
[10,] 10 12  -1.200000
[11,] 11 11   1.000000
[12,] 12 10   1.200000
[13,] 13  9   1.444444
[14,] 14  8   1.750000
[15,] 15  7   2.142857
[16,] 16  6   2.666667
[17,] 17  5   3.400000
[18,] 18  4   4.500000
[19,] 19  3   6.333333
[20,] 20  2  10.000000
[21,] 21  1  21.000000
> 
> 
> 
> cleanEx()
> nameEx("getDependencies")
> ### * getDependencies
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getDependencies
> ### Title: Get package dependencies
> ### Aliases: getDependencies
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D ## A locally installed package
> ##D #' getDependencies("MASS", installed = TRUE, available = FALSE)
> ##D 
> ##D ## A package on CRAN
> ##D getDependencies("gregmisc", installed = FALSE, available = TRUE)
> ##D 
> ##D 
> ##D ## Show base and recommended dependencies
> ##D getDependencies("MASS", available = FALSE, base = TRUE, recommended = TRUE)
> ##D 
> ##D ## Download the set of packages necessary to support a local package
> ##D deps <- getDependencies("MyLocalPackage", available = FALSE)
> ##D download.packages(deps, destdir = "./R_Packages")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("invalid")
> ### * invalid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: invalid
> ### Title: Test if a value is missing, empty, contains only NA or NULL
> ###   values, or is a try-error.
> ### Aliases: invalid
> ### Keywords: programming
> 
> ### ** Examples
> 
> 
> 
> invalid(NA)
[1] TRUE
> invalid()
[1] TRUE
> invalid(c(NA, NA, NULL, NA))
[1] TRUE
> 
> invalid(list(a = 1, b = NULL))
[1] FALSE
> 
> x <- try(log("A"))
Error in log("A") : non-numeric argument to mathematical function
> invalid(x)
[1] TRUE
> 
> # example use in a function
> myplot <- function(x, y) {
+   if (invalid(y)) {
+     y <- x
+     x <- 1:length(y)
+   }
+   plot(x, y)
+ }
> myplot(1:10)
> myplot(1:10, NA)
> 
> 
> 
> cleanEx()
> nameEx("keywords")
> ### * keywords
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: keywords
> ### Title: List valid keywords for R man pages
> ### Aliases: keywords
> ### Keywords: documentation
> 
> ### ** Examples
> 
> 
> ## Show all valid R keywords
> ## Not run: 
> ##D keywords()
> ##D 
> ##D ## Show keywords associated with the 'merge' function
> ##D keywords(merge)
> ##D keywords("merge")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lastAdd")
> ### * lastAdd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lastAdd
> ### Title: Non-destructively construct a .Last function to be executed when
> ###   R exits.
> ### Aliases: lastAdd
> ### Keywords: programming
> 
> ### ** Examples
> 
> 
> 
> ## Print a couple of cute messages when R exits.
> helloWorld <- function() cat("\nHello World!\n")
> byeWorld <- function() cat("\nGoodbye World!\n")
> 
> .Last <- lastAdd(byeWorld)
> .Last <- lastAdd(helloWorld)
> ## Don't show: 
> .Last()

Hello World!

Goodbye World!
> ## End(Don't show)
> ## Not run: 
> ##D q("no")
> ##D 
> ##D ## Should yield:
> ##D ##
> ##D ##   Save workspace image? [y/n/c]: n
> ##D ##
> ##D ##   Hello World!
> ##D ##
> ##D ##   Goodbye World!
> ##D ##
> ##D ##   Process R finished at Tue Nov 22 10:28:55 2005
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loadedPackages")
> ### * loadedPackages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loadedPackages
> ### Title: Provide Name, Version, and Path of Loaded Package Namespaces
> ### Aliases: loadedPackages
> ### Keywords: package
> 
> ### ** Examples
> 
> 
> loadedPackages()
               Name Version                                 Path SearchPath
gtools       gtools   3.9.5 /usr/local/lib/R/site-library/gtools          1
stats         stats   4.4.3       /usr/local/lib/R/library/stats          2
graphics   graphics   4.4.3    /usr/local/lib/R/library/graphics          3
grDevices grDevices   4.4.3   /usr/local/lib/R/library/grDevices          4
utils         utils   4.4.3       /usr/local/lib/R/library/utils          5
datasets   datasets   4.4.3    /usr/local/lib/R/library/datasets          6
methods     methods   4.4.3     /usr/local/lib/R/library/methods          7
base           base   4.4.3        /usr/local/lib/R/library/base          8
compiler   compiler   4.4.3    /usr/local/lib/R/library/compiler          -
tools         tools   4.4.3       /usr/local/lib/R/library/tools          -
> 
> 
> 
> cleanEx()
> nameEx("logit")
> ### * logit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logit
> ### Title: Generalized logit and inverse logit function
> ### Aliases: logit inv.logit
> ### Keywords: math
> 
> ### ** Examples
> 
> 
> 
> x <- seq(0, 10, by = 0.25)
> xt <- logit(x, min = 0, max = 10)
> cbind(x, xt)
          x         xt
 [1,]  0.00       -Inf
 [2,]  0.25 -3.6635616
 [3,]  0.50 -2.9444390
 [4,]  0.75 -2.5123056
 [5,]  1.00 -2.1972246
 [6,]  1.25 -1.9459101
 [7,]  1.50 -1.7346011
 [8,]  1.75 -1.5505974
 [9,]  2.00 -1.3862944
[10,]  2.25 -1.2367626
[11,]  2.50 -1.0986123
[12,]  2.75 -0.9694006
[13,]  3.00 -0.8472979
[14,]  3.25 -0.7308875
[15,]  3.50 -0.6190392
[16,]  3.75 -0.5108256
[17,]  4.00 -0.4054651
[18,]  4.25 -0.3022809
[19,]  4.50 -0.2006707
[20,]  4.75 -0.1000835
[21,]  5.00  0.0000000
[22,]  5.25  0.1000835
[23,]  5.50  0.2006707
[24,]  5.75  0.3022809
[25,]  6.00  0.4054651
[26,]  6.25  0.5108256
[27,]  6.50  0.6190392
[28,]  6.75  0.7308875
[29,]  7.00  0.8472979
[30,]  7.25  0.9694006
[31,]  7.50  1.0986123
[32,]  7.75  1.2367626
[33,]  8.00  1.3862944
[34,]  8.25  1.5505974
[35,]  8.50  1.7346011
[36,]  8.75  1.9459101
[37,]  9.00  2.1972246
[38,]  9.25  2.5123056
[39,]  9.50  2.9444390
[40,]  9.75  3.6635616
[41,] 10.00        Inf
> 
> y <- inv.logit(xt, min = 0, max = 10)
> cbind(x, xt, y)
          x         xt     y
 [1,]  0.00       -Inf  0.00
 [2,]  0.25 -3.6635616  0.25
 [3,]  0.50 -2.9444390  0.50
 [4,]  0.75 -2.5123056  0.75
 [5,]  1.00 -2.1972246  1.00
 [6,]  1.25 -1.9459101  1.25
 [7,]  1.50 -1.7346011  1.50
 [8,]  1.75 -1.5505974  1.75
 [9,]  2.00 -1.3862944  2.00
[10,]  2.25 -1.2367626  2.25
[11,]  2.50 -1.0986123  2.50
[12,]  2.75 -0.9694006  2.75
[13,]  3.00 -0.8472979  3.00
[14,]  3.25 -0.7308875  3.25
[15,]  3.50 -0.6190392  3.50
[16,]  3.75 -0.5108256  3.75
[17,]  4.00 -0.4054651  4.00
[18,]  4.25 -0.3022809  4.25
[19,]  4.50 -0.2006707  4.50
[20,]  4.75 -0.1000835  4.75
[21,]  5.00  0.0000000  5.00
[22,]  5.25  0.1000835  5.25
[23,]  5.50  0.2006707  5.50
[24,]  5.75  0.3022809  5.75
[25,]  6.00  0.4054651  6.00
[26,]  6.25  0.5108256  6.25
[27,]  6.50  0.6190392  6.50
[28,]  6.75  0.7308875  6.75
[29,]  7.00  0.8472979  7.00
[30,]  7.25  0.9694006  7.25
[31,]  7.50  1.0986123  7.50
[32,]  7.75  1.2367626  7.75
[33,]  8.00  1.3862944  8.00
[34,]  8.25  1.5505974  8.25
[35,]  8.50  1.7346011  8.50
[36,]  8.75  1.9459101  8.75
[37,]  9.00  2.1972246  9.00
[38,]  9.25  2.5123056  9.25
[39,]  9.50  2.9444390  9.50
[40,]  9.75  3.6635616  9.75
[41,] 10.00        Inf 10.00
> 
> 
> 
> cleanEx()
> nameEx("mixedsort")
> ### * mixedsort
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mixedsort
> ### Title: Order or Sort strings with embedded numbers so that the numbers
> ###   are in the correct order
> ### Aliases: mixedsort mixedorder
> ### Keywords: manip univar
> 
> ### ** Examples
> 
> 
> ## compound & dose labels
> Treatment <- c(
+   "Control", "Aspirin 10mg/day", "Aspirin 50mg/day",
+   "Aspirin 100mg/day", "Acetomycin 100mg/day",
+   "Acetomycin 1000mg/day"
+ )
> 
> ## ordinary sort puts the dosages in the wrong order
> sort(Treatment)
[1] "Acetomycin 1000mg/day" "Acetomycin 100mg/day"  "Aspirin 100mg/day"    
[4] "Aspirin 10mg/day"      "Aspirin 50mg/day"      "Control"              
> 
> ## but mixedsort does the 'right' thing
> mixedsort(Treatment)
[1] "Acetomycin 100mg/day"  "Acetomycin 1000mg/day" "Aspirin 10mg/day"     
[4] "Aspirin 50mg/day"      "Aspirin 100mg/day"     "Control"              
> 
> ## Here is a more complex example
> x <- rev(c(
+   "AA 0.50 ml", "AA 1.5 ml", "AA 500 ml", "AA 1500 ml",
+   "EXP 1", "AA 1e3 ml", "A A A", "1 2 3 A", "NA", NA, "1e2",
+   "", "-", "1A", "1 A", "100", "100A", "Inf"
+ ))
> 
> mixedorder(x)
 [1]  7 11  4  5  3  8  2  1  6 12 18 17 16 13 15 14 10  9
> 
> mixedsort(x) # Notice that plain numbers, including 'Inf' show up
 [1] ""           "1 2 3 A"    "1 A"        "1A"         "100"       
 [6] "1e2"        "100A"       "Inf"        "-"          "A A A"     
[11] "AA 0.50 ml" "AA 1.5 ml"  "AA 500 ml"  "AA 1e3 ml"  "AA 1500 ml"
[16] "EXP 1"      "NA"         NA          
> # before strings, NAs at the end, and blanks at the
> # beginning .
> 
> 
> mixedsort(x, na.last = TRUE) # default
 [1] ""           "1 2 3 A"    "1 A"        "1A"         "100"       
 [6] "1e2"        "100A"       "Inf"        "-"          "A A A"     
[11] "AA 0.50 ml" "AA 1.5 ml"  "AA 500 ml"  "AA 1e3 ml"  "AA 1500 ml"
[16] "EXP 1"      "NA"         NA          
> mixedsort(x, na.last = FALSE) # push NAs to the front
 [1] NA           ""           "1 2 3 A"    "1 A"        "1A"        
 [6] "100"        "1e2"        "100A"       "Inf"        "-"         
[11] "A A A"      "AA 0.50 ml" "AA 1.5 ml"  "AA 500 ml"  "AA 1e3 ml" 
[16] "AA 1500 ml" "EXP 1"      "NA"        
> 
> 
> mixedsort(x, blank.last = FALSE) # default
 [1] ""           "1 2 3 A"    "1 A"        "1A"         "100"       
 [6] "1e2"        "100A"       "Inf"        "-"          "A A A"     
[11] "AA 0.50 ml" "AA 1.5 ml"  "AA 500 ml"  "AA 1e3 ml"  "AA 1500 ml"
[16] "EXP 1"      "NA"         NA          
> mixedsort(x, blank.last = TRUE) # push blanks to the end
 [1] "1 2 3 A"    "1 A"        "1A"         "100"        "1e2"       
 [6] "100A"       "Inf"        "-"          "A A A"      "AA 0.50 ml"
[11] "AA 1.5 ml"  "AA 500 ml"  "AA 1e3 ml"  "AA 1500 ml" "EXP 1"     
[16] "NA"         ""           NA          
> 
> mixedsort(x, decreasing = FALSE) # default
 [1] ""           "1 2 3 A"    "1 A"        "1A"         "100"       
 [6] "1e2"        "100A"       "Inf"        "-"          "A A A"     
[11] "AA 0.50 ml" "AA 1.5 ml"  "AA 500 ml"  "AA 1e3 ml"  "AA 1500 ml"
[16] "EXP 1"      "NA"         NA          
> mixedsort(x, decreasing = TRUE) # reverse sort order
 [1] NA           "NA"         "EXP 1"      "AA 1500 ml" "AA 1e3 ml" 
 [6] "AA 500 ml"  "AA 1.5 ml"  "AA 0.50 ml" "A A A"      "-"         
[11] "Inf"        "100A"       "1e2"        "100"        "1A"        
[16] "1 A"        "1 2 3 A"    ""          
> 
> ## Roman numerals
> chapters <- c(
+   "V. Non Sequiturs", "II. More Nonsense",
+   "I. Nonsense", "IV. Nonesensical Citations",
+   "III. Utter Nonsense"
+ )
> mixedsort(chapters, numeric.type = "roman")
[1] "I. Nonsense"                "II. More Nonsense"         
[3] "III. Utter Nonsense"        "IV. Nonesensical Citations"
[5] "V. Non Sequiturs"          
> 
> ## Lower-case Roman numerals
> vals <- c(
+   "xix", "xii", "mcv", "iii", "iv", "dcclxxii", "cdxcii",
+   "dcxcviii", "dcvi", "cci"
+ )
> (ordered <- mixedsort(vals, numeric.type = "roman", roman.case = "lower"))
 [1] "iii"      "iv"       "xii"      "xix"      "cci"      "cdxcii"  
 [7] "dcvi"     "dcxcviii" "dcclxxii" "mcv"     
> roman2int(ordered)
     III       IV      XII      XIX      CCI   CDXCII     DCVI DCXCVIII 
       3        4       12       19      201      492      606      698 
DCCLXXII      MCV 
     772     1105 
> 
> ## Control scientific notation for number matching:
> vals <- c("3E1", "2E3", "4e0")
> 
> mixedsort(vals) # With scientfic notation
[1] "4e0" "3E1" "2E3"
> mixedsort(vals, scientific = FALSE) # Without scientfic notation
[1] "2E3" "3E1" "4e0"
> 
> 
> 
> cleanEx()
> nameEx("na.replace")
> ### * na.replace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: na.replace
> ### Title: Replace Missing Values
> ### Aliases: na.replace
> ### Keywords: manip
> 
> ### ** Examples
> 
> 
> x <- c(1, 2, 3, NA, 6, 7, 8, NA, NA)
> 
> # Replace with a specified value
> na.replace(x, "999")
[1] "1"   "2"   "3"   "999" "6"   "7"   "8"   "999" "999"
> 
> # Replace with the calculated median
> na.replace(x, median, na.rm = TRUE)
[1] 1.0 2.0 3.0 4.5 6.0 7.0 8.0 4.5 4.5
> 
> 
> 
> cleanEx()
> nameEx("oddeven")
> ### * oddeven
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: oddeven
> ### Title: Detect odd/even integers
> ### Aliases: oddeven odd even
> ### Keywords: arith
> 
> ### ** Examples
> 
> 
> 
> odd(4)
[1] FALSE
> even(4)
[1] TRUE
> 
> odd(1:10)
 [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
> even(1:10)
 [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("permute")
> ### * permute
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: permute
> ### Title: Randomly Permute the Elements of a Vector
> ### Aliases: permute
> ### Keywords: distribution
> 
> ### ** Examples
> 
> 
> x <- 1:10
> permute(x)
 [1]  9  4  7  1  2  5  3 10  6  8
> 
> 
> 
> cleanEx()
> nameEx("quantcut")
> ### * quantcut
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quantcut
> ### Title: Create a Factor Variable Using the Quantiles of a Continuous
> ###   Variable
> ### Aliases: quantcut
> ### Keywords: manip
> 
> ### ** Examples
> 
> 
> 
> ## create example data
> # testonly{
> set.seed(1234)
> # }
> x <- rnorm(1000)
> 
> ## cut into quartiles
> quartiles <- quantcut(x)
> table(quartiles)
quartiles
   [-3.4,-0.673] (-0.673,-0.0398]  (-0.0398,0.616]      (0.616,3.2] 
             250              250              250              250 
> 
> ## cut into deciles
> deciles.1 <- quantcut(x, 10)
> table(deciles.1)
deciles.1
    [-3.4,-1.21]   (-1.21,-0.849]  (-0.849,-0.538]  (-0.538,-0.285] 
             100              100              100              100 
(-0.285,-0.0398]  (-0.0398,0.193]    (0.193,0.466]    (0.466,0.761] 
             100              100              100              100 
    (0.761,1.33]       (1.33,3.2] 
             100              100 
> # or equivalently
> deciles.2 <- quantcut(x, seq(0, 1, by = 0.1))
> 
> # testonly{
> stopifnot(identical(deciles.1, deciles.2))
> # }
> 
> ## show handling of 'tied' quantiles.
> x <- round(x) # discretize to create ties
> stem(x) # display the ties

  The decimal point is at the |

  -3 | 0000000000000
  -2 | 
  -2 | 000000000000000000000000000000000000000000000000
  -1 | 
  -1 | 00000000000000000000000000000000000000000000000000000000000000000000+181
  -0 | 
  -0 | 
   0 | 00000000000000000000000000000000000000000000000000000000000000000000+310
   0 | 
   1 | 00000000000000000000000000000000000000000000000000000000000000000000+140
   1 | 
   2 | 000000000000000000000000000000000000000000000000000000000000000
   2 | 
   3 | 00000

> deciles <- quantcut(x, 10)
> 
> table(deciles) # note that there are only 5 groups (not 10)
deciles
[-3,-1)      -1       0       1   (1,3] 
     61     261     390     220      68 
> # due to duplicates
> 
> 
> 
> cleanEx()
> nameEx("roman2int")
> ### * roman2int
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: roman2int
> ### Title: Convert Roman Numerals to Integers
> ### Aliases: roman2int
> ### Keywords: arith
> 
> ### ** Examples
> 
> 
> roman2int(c("I", "V", "X", "C", "L", "D", "M"))
   I    V    X    C    L    D    M 
   1    5   10  100   50  500 1000 
> 
> # works regardless of case
> roman2int("MMXVI")
MMXVI 
 2016 
> roman2int("mmxvi")
MMXVI 
 2016 
> 
> # works beyond R's limit of 3899
> val.3899 <- "MMMDCCCXCIX"
> val.3900 <- "MMMCM"
> val.4000 <- "MMMM"
> as.numeric(as.roman(val.3899))
[1] 3899
> as.numeric(as.roman(val.3900))
[1] 3900
> as.numeric(as.roman(val.4000))
[1] 4000
> 
> roman2int(val.3899)
MMMDCCCXCIX 
       3899 
> roman2int(val.3900)
MMMCM 
 3900 
> roman2int(val.4000)
MMMM 
4000 
> 
> 
> 
> cleanEx()
> nameEx("running")
> ### * running
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: running
> ### Title: Apply a Function Over Adjacent Subsets of a Vector
> ### Aliases: running
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> 
> # show effect of pad
> running(1:20, width = 5)
  1:5   2:6   3:7   4:8   5:9  6:10  7:11  8:12  9:13 10:14 11:15 12:16 13:17 
    3     4     5     6     7     8     9    10    11    12    13    14    15 
14:18 15:19 16:20 
   16    17    18 
> running(1:20, width = 5, pad = TRUE)
  1:1   1:2   1:3   1:4   1:5   2:6   3:7   4:8   5:9  6:10  7:11  8:12  9:13 
   NA    NA    NA    NA     3     4     5     6     7     8     9    10    11 
10:14 11:15 12:16 13:17 14:18 15:19 16:20 
   12    13    14    15    16    17    18 
> 
> # show effect of align
> running(1:20, width = 5, align = "left", pad = TRUE)
  1:5   2:6   3:7   4:8   5:9  6:10  7:11  8:12  9:13 10:14 11:15 12:16 13:17 
    3     4     5     6     7     8     9    10    11    12    13    14    15 
14:18 15:19 16:20 17:20 18:20 19:20 20:20 
   16    17    18    NA    NA    NA    NA 
> running(1:20, width = 5, align = "center", pad = TRUE)
  1:1   1:2   1:3   1:4   1:5   2:6   3:7   4:8   5:9  6:10  7:11  8:12  9:13 
   NA    NA    NA    NA     3     4     5     6     7     8     9    10    11 
10:14 11:15 12:16 13:17 14:18 15:19 16:20 17:20 18:20 19:20 20:20 
   12    13    14    15    16    17    18    NA    NA    NA    NA 
> running(1:20, width = 5, align = "right", pad = TRUE)
  1:1   1:2   1:3   1:4   1:5   2:6   3:7   4:8   5:9  6:10  7:11  8:12  9:13 
   NA    NA    NA    NA     3     4     5     6     7     8     9    10    11 
10:14 11:15 12:16 13:17 14:18 15:19 16:20 
   12    13    14    15    16    17    18 
> 
> # show effect of simplify
> running(1:20, width = 5, fun = function(x) x) # matrix
     1:5 2:6 3:7 4:8 5:9 6:10 7:11 8:12 9:13 10:14 11:15 12:16 13:17 14:18
[1,]   1   2   3   4   5    6    7    8    9    10    11    12    13    14
[2,]   2   3   4   5   6    7    8    9   10    11    12    13    14    15
[3,]   3   4   5   6   7    8    9   10   11    12    13    14    15    16
[4,]   4   5   6   7   8    9   10   11   12    13    14    15    16    17
[5,]   5   6   7   8   9   10   11   12   13    14    15    16    17    18
     15:19 16:20
[1,]    15    16
[2,]    16    17
[3,]    17    18
[4,]    18    19
[5,]    19    20
> running(1:20, width = 5, fun = function(x) x, simplify = FALSE) # list
$`1:5`
[1] 1 2 3 4 5

$`2:6`
[1] 2 3 4 5 6

$`3:7`
[1] 3 4 5 6 7

$`4:8`
[1] 4 5 6 7 8

$`5:9`
[1] 5 6 7 8 9

$`6:10`
[1]  6  7  8  9 10

$`7:11`
[1]  7  8  9 10 11

$`8:12`
[1]  8  9 10 11 12

$`9:13`
[1]  9 10 11 12 13

$`10:14`
[1] 10 11 12 13 14

$`11:15`
[1] 11 12 13 14 15

$`12:16`
[1] 12 13 14 15 16

$`13:17`
[1] 13 14 15 16 17

$`14:18`
[1] 14 15 16 17 18

$`15:19`
[1] 15 16 17 18 19

$`16:20`
[1] 16 17 18 19 20

> 
> # show effect of by
> running(1:20, width = 5) # normal
  1:5   2:6   3:7   4:8   5:9  6:10  7:11  8:12  9:13 10:14 11:15 12:16 13:17 
    3     4     5     6     7     8     9    10    11    12    13    14    15 
14:18 15:19 16:20 
   16    17    18 
> running(1:20, width = 5, by = 5) # non-overlapping
  1:5  6:10 11:15 16:20 
    3     8    13    18 
> running(1:20, width = 5, by = 2) # starting every 2nd
  1:5   3:7   5:9  7:11  9:13 11:15 13:17 15:19 
    3     5     7     9    11    13    15    17 
> 
> 
> # Use 'pad' to ensure correct length of vector, also show the effect
> # of allow.fewer.
> par(mfrow = c(2, 1))
> plot(1:20, running(1:20, width = 5, allow.fewer = FALSE, pad = TRUE), type = "b")
> plot(1:20, running(1:20, width = 5, allow.fewer = TRUE, pad = TRUE), type = "b")
> par(mfrow = c(1, 1))
> 
> # plot running mean and central 2 standard deviation range
> # estimated by *last* 40 observations
> dat <- rnorm(500, sd = 1 + (1:500) / 500)
> plot(dat)
> sdfun <- function(x, sign = 1) mean(x) + sign * sqrt(var(x))
> lines(running(dat, width = 51, pad = TRUE, fun = mean), col = "blue")
> lines(running(dat, width = 51, pad = TRUE, fun = sdfun, sign = -1), col = "red")
> lines(running(dat, width = 51, pad = TRUE, fun = sdfun, sign = 1), col = "red")
> 
> 
> # plot running correlation estimated by last 40 observations (red)
> # against the true local correlation (blue)
> sd.Y <- seq(0, 1, length = 500)
> 
> X <- rnorm(500, sd = 1)
> Y <- rnorm(500, sd = sd.Y)
> 
> plot(running(X, X + Y, width = 20, fun = cor, pad = TRUE), col = "red", type = "s")
> 
> r <- 1 / sqrt(1 + sd.Y^2) # true cor of (X,X+Y)
> lines(r, type = "l", col = "blue")
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("scat")
> ### * scat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scat
> ### Title: Display debugging text
> ### Aliases: scat
> ### Keywords: print
> 
> ### ** Examples
> 
> 
> options(DEBUG = NULL) # makee sure DEBUG isn't set
> scat("Not displayed")
> 
> options(DEBUG = TRUE)
> scat("This will be displayed immediately (even in R BATCH output \n")
### This will be displayed immediately (even in R BATCH output 
 ###
> scat("files), provided options()$DEBUG is TRUE.")
### files), provided options()$DEBUG is TRUE. ###
> 
> 
> 
> cleanEx()
> nameEx("script_file")
> ### * script_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: script_file
> ### Title: Determine the directory or full path to the currently executing
> ###   script
> ### Aliases: script_file script_path
> 
> ### ** Examples
> 
> 
> getwd()
[1] "/__w/rocker_uat/rocker_uat/packages/gtools"
> commandArgs(trailingOnly = FALSE)
[1] "/usr/local/lib/R/bin/exec/R" "--no-save"                  
[3] "--no-restore"                "-f"                         
[5] "gtools-Ex.R"                 "--restore"                  
[7] "--save"                      "--no-readline"              
[9] "--vanilla"                  
> 
> script_file("warning")
[1] "/__w/rocker_uat/rocker_uat/packages/gtools/gtools-Ex.R"
> script_path("warning")
[1] "/__w/rocker_uat/rocker_uat/packages/gtools"
> 
> 
> 
> cleanEx()
> nameEx("setTCPNoDelay")
> ### * setTCPNoDelay
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setTCPNoDelay
> ### Title: Modify the TCP_NODELAY ('de-Nagle') flag for socket objects
> ### Aliases: setTCPNoDelay
> ### Keywords: misc programming utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D host <- "www.r-project.org"
> ##D socket <- make.socket(host, 80)
> ##D print(socket)
> ##D setTCPNoDelay(socket, TRUE)
> ##D 
> ##D write.socket(socket, "GET /\n\n")
> ##D write.socket(socket, "A")
> ##D write.socket(socket, "B\n")
> ##D while ((str <- read.socket(socket)) > "") {
> ##D   cat(str)
> ##D }
> ##D close.socket(socket)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("smartbind")
> ### * smartbind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smartbind
> ### Title: Efficient rbind of data frames, even if the column names don't
> ###   match
> ### Aliases: smartbind
> ### Keywords: manip
> 
> ### ** Examples
> 
> 
> 
> df1 <- data.frame(A = 1:10, B = LETTERS[1:10], C = rnorm(10))
> df2 <- data.frame(A = 11:20, D = rnorm(10), E = letters[1:10])
> 
> # rbind would fail
> ## Not run: 
> ##D rbind(df1, df2)
> ##D # Error in match.names(clabs, names(xi)) : names do not match previous
> ##D # names:
> ##D # 	D, E
> ## End(Not run)
> # but smartbind combines them, appropriately creating NA entries
> smartbind(df1, df2)
      A    B          C           D    E
1:1   1    A -0.6264538          NA <NA>
1:2   2    B  0.1836433          NA <NA>
1:3   3    C -0.8356286          NA <NA>
1:4   4    D  1.5952808          NA <NA>
1:5   5    E  0.3295078          NA <NA>
1:6   6    F -0.8204684          NA <NA>
1:7   7    G  0.4874291          NA <NA>
1:8   8    H  0.7383247          NA <NA>
1:9   9    I  0.5757814          NA <NA>
1:10 10    J -0.3053884          NA <NA>
2:1  11 <NA>         NA  1.51178117    a
2:2  12 <NA>         NA  0.38984324    b
2:3  13 <NA>         NA -0.62124058    c
2:4  14 <NA>         NA -2.21469989    d
2:5  15 <NA>         NA  1.12493092    e
2:6  16 <NA>         NA -0.04493361    f
2:7  17 <NA>         NA -0.01619026    g
2:8  18 <NA>         NA  0.94383621    h
2:9  19 <NA>         NA  0.82122120    i
2:10 20 <NA>         NA  0.59390132    j
> 
> # specify fill=0 to put 0 into the missing row entries
> smartbind(df1, df2, fill = 0)
      A B          C           D E
1:1   1 A -0.6264538  0.00000000 0
1:2   2 B  0.1836433  0.00000000 0
1:3   3 C -0.8356286  0.00000000 0
1:4   4 D  1.5952808  0.00000000 0
1:5   5 E  0.3295078  0.00000000 0
1:6   6 F -0.8204684  0.00000000 0
1:7   7 G  0.4874291  0.00000000 0
1:8   8 H  0.7383247  0.00000000 0
1:9   9 I  0.5757814  0.00000000 0
1:10 10 J -0.3053884  0.00000000 0
2:1  11 0  0.0000000  1.51178117 a
2:2  12 0  0.0000000  0.38984324 b
2:3  13 0  0.0000000 -0.62124058 c
2:4  14 0  0.0000000 -2.21469989 d
2:5  15 0  0.0000000  1.12493092 e
2:6  16 0  0.0000000 -0.04493361 f
2:7  17 0  0.0000000 -0.01619026 g
2:8  18 0  0.0000000  0.94383621 h
2:9  19 0  0.0000000  0.82122120 i
2:10 20 0  0.0000000  0.59390132 j
> ## Don't show: 
> n <- 10 # number of data frames to create
> s <- 10 # number of rows in each data frame
> 
> # create a bunch of column names
> names <- LETTERS[2:5]
> 
> # create a list 'Z' containing 'n' data frames, each with 3 columns
> # and 's' rows.  The first column is always named 'A', but the other
> # two have a names randomly selected from 'names'
> 
> Z <- list()
> for (i in 1:n)
+ {
+   X <- data.frame(
+     A = sample(letters, s, replace = TRUE),
+     B = letters[1:s],
+     C = rnorm(s)
+   )
+   colnames(X) <- c("A", sample(names, 2, replace = FALSE))
+   Z[[i]] <- X
+ }
> 
> # Error in match.names(clabs, names(xi)) : names do not match
> # previous names: E
> 
> # But smartbind will 'do the right thing'
> df <- do.call("smartbind", Z)
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'B'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'B'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'E'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'B'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'B'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'D'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'C'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'D'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'E'. Converting column to class 'character'.
Warning in smartbind(list(A = c("j", "f", "o", "t", "t", "z", "l", "y",  :
  Column class mismatch for 'D'. Converting column to class 'character'.
> df
      A                    C                   B                  E
1:1   j                    a    1.08576936214569               <NA>
1:2   f                    b   -0.69095383969683               <NA>
1:3   o                    c   -1.28459935387219               <NA>
1:4   t                    d   0.046726172188352               <NA>
1:5   t                    e  -0.235706556439501               <NA>
1:6   z                    f  -0.542888255010254               <NA>
1:7   l                    g  -0.433310317456782               <NA>
1:8   y                    h  -0.649471646796233               <NA>
1:9   w                    i   0.726750747385451               <NA>
1:10  f                    j     1.1519117540872               <NA>
2:1   s                 <NA>                   a  0.696963375404737
2:2   s                 <NA>                   b  0.556663198673657
2:3   h                 <NA>                   c  -0.68875569454952
2:4   f                 <NA>                   d  -0.70749515696212
2:5   w                 <NA>                   e   0.36458196213683
2:6   l                 <NA>                   f  0.768532924515416
2:7   f                 <NA>                   g -0.112346212150228
2:8   h                 <NA>                   h  0.881107726454215
2:9   g                 <NA>                   i  0.398105880367068
2:10  k                 <NA>                   j -0.612026393250771
3:1   f                    a   -1.26361438497058               <NA>
3:2   q                    b   0.358728895971352               <NA>
3:3   i                    c -0.0110454784656636               <NA>
3:4   g                    d  -0.940649162618608               <NA>
3:5   w                    e  -0.115825322156954               <NA>
3:6   s                    f  -0.814968708869917               <NA>
3:7   v                    g   0.242263480859686               <NA>
3:8   r                    h    -1.4250983947325               <NA>
3:9   z                    i    0.36594112304922               <NA>
3:10  p                    j   0.248412648872596               <NA>
4:1   l                 <NA>  -0.443291873218433                  a
4:2   g                 <NA> 0.00110535163162413                  b
4:3   x                 <NA>  0.0743413241516641                  c
4:4   u                 <NA>  -0.589520946188072                  d
4:5   v                 <NA>  -0.568668732818502                  e
4:6   h                 <NA>  -0.135178615123832                  f
4:7   a                 <NA>     1.1780869965732                  g
4:8   s                 <NA>   -1.52356680042976                  h
4:9   z                 <NA>   0.593946187628422                  i
4:10  c                 <NA>   0.332950371213518                  j
5:1   i                 <NA>   0.700213649514998               <NA>
5:2   r                 <NA>    1.58683345454085               <NA>
5:3   x                 <NA>   0.558486425565304               <NA>
5:4   v                 <NA>   -1.27659220845804               <NA>
5:5   q                 <NA>  -0.573265414236886               <NA>
5:6   r                 <NA>   -1.22461261489836               <NA>
5:7   w                 <NA>  -0.473400636439312               <NA>
5:8   o                 <NA>  -0.620366677224124               <NA>
5:9   g                 <NA>  0.0421158731442352               <NA>
5:10  o                 <NA>  -0.910921648552446               <NA>
6:1   b                    a                <NA>               <NA>
6:2   k                    b                <NA>               <NA>
6:3   c                    c                <NA>               <NA>
6:4   c                    d                <NA>               <NA>
6:5   n                    e                <NA>               <NA>
6:6   s                    f                <NA>               <NA>
6:7   m                    g                <NA>               <NA>
6:8   k                    h                <NA>               <NA>
6:9   p                    i                <NA>               <NA>
6:10  h                    j                <NA>               <NA>
7:1   b    -1.23290119957126                   a               <NA>
7:2   a -0.00372353379218051                   b               <NA>
7:3   c     1.51167228281089                   c               <NA>
7:4   x   -0.475698284429534                   d               <NA>
7:5   i    0.797916437531079                   e               <NA>
7:6   f   -0.974002561112527                   f               <NA>
7:7   q    0.689372697765473                   g               <NA>
7:8   t   -0.955839103276798                   h               <NA>
7:9   e     -1.2317070584141                   i               <NA>
7:10  i   -0.956891881325619                   j               <NA>
8:1   f                 <NA>                   a               <NA>
8:2   r                 <NA>                   b               <NA>
8:3   p                 <NA>                   c               <NA>
8:4   b                 <NA>                   d               <NA>
8:5   h                 <NA>                   e               <NA>
8:6   n                 <NA>                   f               <NA>
8:7   d                 <NA>                   g               <NA>
8:8   z                 <NA>                   h               <NA>
8:9   h                 <NA>                   i               <NA>
8:10  u                 <NA>                   j               <NA>
9:1   m                 <NA>                   a  0.713240520112821
9:2   i                 <NA>                   b -0.542881937111931
9:3   y                 <NA>                   c  0.885778373900932
9:4   g                 <NA>                   d -0.348594684510753
9:5   y                 <NA>                   e  -1.00805457816954
9:6   n                 <NA>                   f    1.8831825423826
9:7   e                 <NA>                   g -0.928971079201175
9:8   g                 <NA>                   h -0.294196453606913
9:9   t                 <NA>                   i -0.614950270796355
9:10  t                 <NA>                   j -0.947075791741019
10:1  v                 <NA>                <NA>                  a
10:2  y                 <NA>                <NA>                  b
10:3  x                 <NA>                <NA>                  c
10:4  e                 <NA>                <NA>                  d
10:5  l                 <NA>                <NA>                  e
10:6  o                 <NA>                <NA>                  f
10:7  n                 <NA>                <NA>                  g
10:8  o                 <NA>                <NA>                  h
10:9  q                 <NA>                <NA>                  i
10:10 o                 <NA>                <NA>                  j
                        D
1:1                  <NA>
1:2                  <NA>
1:3                  <NA>
1:4                  <NA>
1:5                  <NA>
1:6                  <NA>
1:7                  <NA>
1:8                  <NA>
1:9                  <NA>
1:10                 <NA>
2:1                  <NA>
2:2                  <NA>
2:3                  <NA>
2:4                  <NA>
2:5                  <NA>
2:6                  <NA>
2:7                  <NA>
2:8                  <NA>
2:9                  <NA>
2:10                 <NA>
3:1                  <NA>
3:2                  <NA>
3:3                  <NA>
3:4                  <NA>
3:5                  <NA>
3:6                  <NA>
3:7                  <NA>
3:8                  <NA>
3:9                  <NA>
3:10                 <NA>
4:1                  <NA>
4:2                  <NA>
4:3                  <NA>
4:4                  <NA>
4:5                  <NA>
4:6                  <NA>
4:7                  <NA>
4:8                  <NA>
4:9                  <NA>
4:10                 <NA>
5:1                     a
5:2                     b
5:3                     c
5:4                     d
5:5                     e
5:6                     f
5:7                     g
5:8                     h
5:9                     i
5:10                    j
6:1    -0.412519887482398
6:2     -0.97228683550556
6:3    0.0253828675878054
6:4    0.0274753358468055
6:5     -1.68018272239593
6:6      1.05375086302862
6:7     -1.11959910457218
6:8     0.335617209968815
6:9     0.494795767113158
6:10    0.138052708711737
7:1                  <NA>
7:2                  <NA>
7:3                  <NA>
7:4                  <NA>
7:5                  <NA>
7:6                  <NA>
7:7                  <NA>
7:8                  <NA>
7:9                  <NA>
7:10                 <NA>
8:1     -1.11972006112698
8:2    -0.448174236603396
8:3      0.47173637445323
8:4     -1.18049068288428
8:5      1.47025699708299
8:6     -1.31142059162488
8:7   -0.0965249227629818
8:8      2.36971990795134
8:9     0.890626476437422
8:10   -0.252183161390947
9:1                  <NA>
9:2                  <NA>
9:3                  <NA>
9:4                  <NA>
9:5                  <NA>
9:6                  <NA>
9:7                  <NA>
9:8                  <NA>
9:9                  <NA>
9:10                 <NA>
10:1   -0.430879529604084
10:2   -0.592225372961588
10:3    0.981116159906615
10:4    0.532409356670506
10:5  -0.0904561242409946
10:6     0.15649049169609
10:7   -0.737311690839969
10:8    -0.20134120587218
10:9     1.10217659507369
10:10 -0.0167482561518744
> 
> # Equivalent call:
> df <- smartbind(list = Z)
Warning in smartbind(list = Z) :
  Column class mismatch for 'B'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'B'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'E'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'B'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'B'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'D'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'C'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'D'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'E'. Converting column to class 'character'.
Warning in smartbind(list = Z) :
  Column class mismatch for 'D'. Converting column to class 'character'.
> ## End(Don't show)
> 
> 
> 
> 
> cleanEx()
> nameEx("stars.pval")
> ### * stars.pval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stars.pval
> ### Title: Generate significance stars from p-values
> ### Aliases: stars.pval
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> p.val <- c(0.0004, 0.0015, 0.013, 0.044, 0.067, 0.24)
> stars.pval(p.val)
[1] "***" "**"  "*"   "*"   "."   " "  
attr(,"legend")
[1] "0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"
> 
> 
> 
> cleanEx()
> nameEx("stat_mode")
> ### * stat_mode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat_mode
> ### Title: Most frequently occurring value
> ### Aliases: stat_mode
> 
> ### ** Examples
> 
> 
> # Character vector
> chr_vec <- c("a", "d", "d", "h", "h", NA, NA) # Multiple modes
> stat_mode(x = chr_vec)
[1] "d" "h"
> stat_mode(x = chr_vec, na.rm = FALSE)
[1] "d" "h" NA 
> stat_mode(x = chr_vec, na.rm = FALSE, ties = "first")
[1] "d"
> stat_mode(x = chr_vec, na.rm = FALSE, ties = "last")
[1] NA
> 
> # - # Numeric vector
> # See that it keeps the original vector type
> num_vec <- c(2, 3, 3, 4, 4, NA, NA)
> stat_mode(x = num_vec)
[1] 3 4
> stat_mode(x = num_vec, na.rm = FALSE)
[1]  3  4 NA
> stat_mode(x = num_vec, na.rm = FALSE, ties = "first")
[1] 3
> stat_mode(x = num_vec, na.rm = FALSE, ties = "last")
[1] NA
> 
> # The default option is ties="all" but it is very easy for the user to control
> # the ties without changing this parameter.
> # Select always just one mode, being that the first mode
> stat_mode(x = num_vec)[1]
[1] 3
> 
> # Select the first and the second stat_mode
> stat_mode(x = num_vec)[c(1, 2)]
[1] 3 4
> 
> # Logical Vectors
> stat_mode(x = c(TRUE, TRUE))
[1] TRUE
> stat_mode(x = c(FALSE, FALSE, TRUE, TRUE))
[1] FALSE  TRUE
> 
> # - # Single element cases
> stat_mode(x = c(NA_real_))
[1] NA
> stat_mode(x = 2)
[1] 2
> stat_mode(x = NA)
[1] NA
> stat_mode(x = c("a"))
[1] "a"
> 
> # Not allowing multiple stat_mode, returning NA if that happens
> stat_mode(x = c(1, 1, 2, 2), multiple_modes = FALSE) # multiple stat_mode
[1] 1 2
> stat_mode(x = c(1, 1), multiple_modes = FALSE) # single mode
[1] 1
> 
> # Empty vector cases
> # The ties of any empty vector will be itself (an empty vector of the same type)
> stat_mode(x = double())
[1] NA
> stat_mode(x = complex())
[1] NA
> stat_mode(x = vector("numeric"))
[1] NA
> stat_mode(x = vector("character"))
[1] NA
> 
> 
> 
> cleanEx()
> nameEx("unByteCode")
> ### * unByteCode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unByteCode
> ### Title: Convert a byte-code function to an interpreted-code function
> ### Aliases: unByteCode unByteCodeAssign assignEdgewise
> ### Keywords: programming utilites
> 
> ### ** Examples
> 
> 
> data(badDend)
> dist2 <- function(x) as.dist(1 - cor(t(x), method = "pearson"))
> hclust1 <- function(x) hclust(x, method = "single")
> 
> distance <- dist2(badDend)
> cluster <- hclust1(distance)
> 
> dend <- as.dendrogram(cluster)
> ## Not run: 
> ##D ## In R 2.3.0 and earlier crashes with a node stack overflow error
> ##D plot(dend)
> ##D ## Error in xy.coords(x, y, recycle = TRUE) : node stack overflow
> ## End(Not run)
> 
> ## convert stats:::plotNode from byte-code to interpreted-code
> ## (no longer available unless assignEdgewise is defined by the user)
> ## unByteCodeAssign(stats:::plotNode)
> ## illustrated in https://stackoverflow.com/questions/16559250/error-in-heatmap-2-gplots
> 
> # increase recursion limit
> options("expressions" = 5e4)
> 
> # now the function does not crash
> plot(dend)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.441 0.051 3.322 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
