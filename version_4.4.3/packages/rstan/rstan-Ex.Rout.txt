
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "rstan"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('rstan')
Loading required package: StanHeaders

rstan version 2.32.7 (Stan version 2.32.2)

For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores()).
To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
For within-chain threading using `reduce_sum()` or `map_rect()` Stan functions,
change `threads_per_chain` option:
rstan_options(threads_per_chain = 1)

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Rhat")
> ### * Rhat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rhat
> ### Title: Convergence and efficiency diagnostics for Markov Chains
> ### Aliases: Rhat ess_bulk ess_tail
> 
> ### ** Examples
> 
> # pretend these draws came from five actual Markov Chins
> sims <- matrix(rnorm(500), nrow = 100, ncol = 5)
> Rhat(sims)
[1] 0.9983181
> ess_bulk(sims)
[1] 549.3665
> ess_tail(sims)
[1] 526.0091
> 
> 
> 
> cleanEx()
> nameEx("check_hmc_diagnostics")
> ### * check_hmc_diagnostics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: check_hmc_diagnostics
> ### Title: Check HMC diagnostics after sampling
> ### Aliases: check_hmc_diagnostics check_divergences check_treedepth
> ###   check_energy get_divergent_iterations get_max_treedepth_iterations
> ###   get_num_leapfrog_per_iteration get_num_divergent
> ###   get_num_max_treedepth get_bfmi get_low_bfmi_chains
> 
> ### ** Examples
> 
> ## Not run: 
> ##D schools <- stan_demo("eight_schools")
> ##D check_hmc_diagnostics(schools)
> ##D check_divergences(schools)
> ##D check_treedepth(schools)
> ##D check_energy(schools)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expose_stan_functions")
> ### * expose_stan_functions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expose_stan_functions
> ### Title: Expose user-defined Stan functions to R for testing and
> ###   simulation
> ### Aliases: expose_stan_functions get_stream get_rng
> 
> ### ** Examples
> 
> ## Not run: 
> ##D model_code <-
> ##D   '
> ##D   functions {
> ##D     real standard_normal_rng() {
> ##D       return normal_rng(0,1);
> ##D    }
> ##D   }
> ##D '
> ##D expose_stan_functions(stanc(model_code = model_code))
> ##D standard_normal_rng()
> ##D PRNG <- get_rng(seed = 3)
> ##D o <- get_stream()
> ##D standard_normal_rng(PRNG, o)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("extract_sparse_parts")
> ### * extract_sparse_parts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extract_sparse_parts
> ### Title: Extract the compressed representation of a sparse matrix
> ### Aliases: extract_sparse_parts
> 
> ### ** Examples
> 
>   A <- rbind(
+     c(19L, 27L,  0L,  0L),
+     c( 0L,  0L,  0L,  0L),
+     c( 0L,  0L,  0L, 52L),
+     c(81L,  0L, 95L, 33L)
+   )
>   str(extract_sparse_parts(A))
Loading required namespace: Matrix
List of 3
 $ w: num [1:6] 19 27 52 81 95 33
 $ v: int [1:6] 1 2 4 1 3 4
 $ u: int [1:5] 1 3 3 4 7
> 
> 
> 
> cleanEx()
> nameEx("lookup")
> ### * lookup
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lookup
> ### Title: Look up the Stan function that corresponds to a R function or
> ###   name.
> ### Aliases: lookup
> 
> ### ** Examples
> 
> lookup(dnorm)      # Stan equivalents for the normal PDF (in log form)
          StanFunction
415 normal_id_glm_lpdf
418         normal_log
419        normal_lpdf
553    std_normal_lpdf
                                                                       Arguments
415 (real, matrix, real, vector, T);(vector, row_vector, vector, vector, vector)
418                                     (real, real, T);(vector, vector, vector)
419                                     (real, real, T);(vector, vector, vector)
553                                                                 (T);(vector)
    ReturnType
415     T;real
418     T;real
419     T;real
553     T;real
> lookup("foo")      # fails
[1] "no matching Stan functions"
> lookup("Student")  # succeeds even though there is no such R function
                     StanFunction
374 multi_student_t_cholesky_lpdf
375  multi_student_t_cholesky_rng
376           multi_student_t_log
377          multi_student_t_lpdf
378           multi_student_t_rng
557            student_t_ccdf_log
558                 student_t_cdf
559             student_t_cdf_log
560               student_t_lccdf
561                student_t_lcdf
562                 student_t_log
563                student_t_lpdf
564                 student_t_rng
                                                    Arguments
374                            (vector, real, vector, matrix)
375 (real, vector, matrix);(real, array[] row_vector, matrix)
376                            (vector, real, vector, matrix)
377                            (vector, real, vector, matrix)
378 (real, vector, matrix);(real, array[] row_vector, matrix)
557    (real, real, real, T);(vector, vector, vector, vector)
558    (real, real, real, T);(vector, vector, vector, vector)
559    (real, real, real, T);(vector, vector, vector, vector)
560    (real, real, real, T);(vector, vector, vector, vector)
561    (real, real, real, T);(vector, vector, vector, vector)
562    (real, real, real, T);(vector, vector, vector, vector)
563    (real, real, real, T);(vector, vector, vector, vector)
564                             (int, int, T);(int, int, int)
               ReturnType
374                  real
375 vector;array[] vector
376                  real
377                  real
378 vector;array[] vector
557                T;real
558                T;real
559                T;real
560                T;real
561                T;real
562                T;real
563                T;real
564                T;real
> lookup("^poisson") # every Stan function that starts with poisson
            StanFunction
459     poisson_ccdf_log
460          poisson_cdf
461      poisson_cdf_log
462        poisson_lccdf
463         poisson_lcdf
464          poisson_log
465 poisson_log_glm_lpmf
466      poisson_log_log
467     poisson_log_lpmf
468      poisson_log_rng
469         poisson_lpmf
470          poisson_rng
                                                    Arguments ReturnType
459                                    (int, T);(int, vector)     T;real
460                                    (int, T);(int, vector)     T;real
461                                    (int, T);(int, vector)     T;real
462                                    (int, T);(int, vector)     T;real
463                                    (int, T);(int, vector)     T;real
464                                    (int, T);(int, vector)     T;real
465 (int, matrix, real, vector);(int, matrix, vector, vector)  real;real
466                                    (int, T);(int, vector)     T;real
467                                    (int, T);(int, vector)     T;real
468                                                (T);(real)      T;int
469                                    (int, T);(int, vector)     T;real
470                                                (T);(real)      T;int
> 
> 
> 
> cleanEx()
> nameEx("makeconf_path")
> ### * makeconf_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeconf_path
> ### Title: Obtain the full path of file 'Makeconf'
> ### Aliases: makeconf_path
> ### Keywords: rstan
> 
> ### ** Examples
> 
> makeconf_path() 
[1] "/usr/local/lib/R/etc/Makeconf"
> 
> 
> 
> cleanEx()
> nameEx("monitor")
> ### * monitor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: monitor
> ### Title: Compute summaries of MCMC draws and monitor convergence
> ### Aliases: monitor print.simsummary [.simsummary
> 
> ### ** Examples
> 
> csvfiles <- dir(system.file('misc', package = 'rstan'),
+                 pattern = 'rstan_doc_ex_[0-9].csv', full.names = TRUE)
> fit <- read_stan_csv(csvfiles)
> # The following is just for the purpose of giving an example
> # since print can be used for a stanfit object.
> monitor(extract(fit, permuted = FALSE, inc_warmup = TRUE))
Inference for the input samples (4 chains: each with iter = 200; warmup = 100):

          Q5   Q50   Q95  Mean  SD  Rhat Bulk_ESS Tail_ESS
mu      -0.3   0.1   0.4   0.1 0.2  1.01      348      229
sigma    0.9   1.1   1.5   1.2 0.2  1.01      227      178
z[1,1]  -1.6   0.0   1.4   0.0 0.9  1.01      308      301
z[2,1]  -1.4   0.1   1.7   0.1 1.0  1.01      329      246
z[3,1]  -1.9  -0.1   1.7  -0.1 1.1  1.00      455      294
z[1,2]  -1.7   0.0   1.5   0.0 1.0  1.01      278      138
z[2,2]  -1.5   0.1   1.5   0.0 0.9  1.01      438      251
z[3,2]  -1.6   0.1   1.9   0.1 1.0  1.02      344      124
alpha    0.0   0.4   1.6   0.5 0.5  1.01      354      116
lp__   -21.5 -17.2 -14.6 -17.5 2.3  1.03      117      208

For each parameter, Bulk_ESS and Tail_ESS are crude measures of 
effective sample size for bulk and tail quantities respectively (an ESS > 100 
per chain is considered good), and Rhat is the potential scale reduction 
factor on rank normalized split chains (at convergence, Rhat <= 1.05).
> 
> 
> 
> cleanEx()
> nameEx("nlist")
> ### * nlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nlist
> ### Title: Created named lists
> ### Aliases: nlist
> ### Keywords: rstan
> 
> ### ** Examples
> 
> # All variables already defined
> x <- 1
> y <- 2
> nlist(x, y)
$x
[1] 1

$y
[1] 2

> 
> # Define some variables in the call and take the rest from the environment
> nlist(x, y, z = 3)
$x
[1] 1

$y
[1] 2

$z
[1] 3

> 
> 
> 
> cleanEx()
> nameEx("read_rdump")
> ### * read_rdump
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_rdump
> ### Title: Read data in an R dump file to a list
> ### Aliases: read_rdump
> ### Keywords: rstan
> 
> ### ** Examples
> 
> x <- 1; y <- 1:10; z <- array(1:10, dim = c(2,5)) 
> stan_rdump(ls(pattern = '^[xyz]'), file.path(tempdir(), "xyz.Rdump"))
> l <- read_rdump(file.path(tempdir(), 'xyz.Rdump'))
> print(l)
$x
[1] 1

$y
 [1]  1  2  3  4  5  6  7  8  9 10

$z
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

> unlink(file.path(tempdir(), "xyz.Rdump"))
> 
> 
> 
> cleanEx()
> nameEx("rstan")
> ### * rstan
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rstan-package
> ### Title: RStan - the R interface to Stan
> ### Aliases: rstan-package rstan
> ### Keywords: rstan package
> 
> ### ** Examples
> ## Not run: 
> ##D 
> ##D stanmodelcode <- "
> ##D data {
> ##D   int<lower=0> N;
> ##D   array[N] real y;
> ##D }
> ##D 
> ##D parameters {
> ##D   real mu;
> ##D }
> ##D 
> ##D model {
> ##D   target += normal_lpdf(mu | 0, 10);
> ##D   target += normal_lpdf(y  | mu, 1);
> ##D }
> ##D "
> ##D 
> ##D y <- rnorm(20)
> ##D dat <- list(N = 20, y = y);
> ##D fit <- stan(model_code = stanmodelcode, model_name = "example",
> ##D             data = dat, iter = 2012, chains = 3, verbose = TRUE,
> ##D             sample_file = file.path(tempdir(), 'norm.csv'))
> ##D print(fit)
> ##D 
> ##D # extract samples
> ##D e <- extract(fit, permuted = FALSE) # return a list of arrays
> ##D str(e)
> ##D 
> ##D arr <- as.array(fit) # return an array
> ##D str(arr)
> ##D 
> ##D mat <- as.matrix(fit) # return a matrix
> ##D str(mat)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("sbc")
> ### * sbc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sbc
> ### Title: Simulation Based Calibration (sbc)
> ### Aliases: sbc print.sbc plot.sbc
> 
> ### ** Examples
> 
> scode <- "
+ data {
+   int<lower = 1> N;
+   real<lower = 0> a;
+   real<lower = 0> b;
+ }
+ transformed data { // these adhere to the conventions above
+   real pi_ = beta_rng(a, b);
+   int y = binomial_rng(N, pi_);
+ }
+ parameters {
+   real<lower = 0, upper = 1> pi;
+ }
+ model {
+   target += beta_lpdf(pi | a, b);
+   target += binomial_lpmf(y | N, pi);
+ }
+ generated quantities { // these adhere to the conventions above
+   int y_ = y;
+   vector[1] pars_;
+   int ranks_[1] = {pi > pi_};
+   vector[N] log_lik;
+   pars_[1] = pi_;
+   for (n in 1:y) log_lik[n] = bernoulli_lpmf(1 | pi);
+   for (n in (y + 1):N) log_lik[n] = bernoulli_lpmf(0 | pi);
+ }
+ "
> 
> 
> 
> cleanEx()
> nameEx("sflist2stanfit")
> ### * sflist2stanfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sflist2stanfit
> ### Title: Merge a list of stanfit objects into one
> ### Aliases: sflist2stanfit
> 
> ### ** Examples
> ## Not run: 
> ##D library(rstan)
> ##D scode <- "
> ##D data {
> ##D   int<lower=1> N;
> ##D } 
> ##D parameters {
> ##D   array[N] real y1;
> ##D   array[N] real y2; 
> ##D } 
> ##D model {
> ##D   y1 ~ normal(0, 1);
> ##D   y2 ~ double_exponential(0, 2);
> ##D } 
> ##D "
> ##D seed <- 123 # or any other integer 
> ##D foo_data <- list(N = 2)
> ##D foo <- stan(model_code = scode, data = foo_data, chains = 1, iter = 1)
> ##D f1 <- stan(fit = foo, data = foo_data, chains = 1, seed = seed, chain_id = 1) 
> ##D f2 <- stan(fit = foo, data = foo_data, chains = 2, seed = seed, chain_id = 2:3) 
> ##D f12 <- sflist2stanfit(list(f1, f2)) 
> ##D 
> ##D ## parallel stan call for unix-like OS
> ##D library(parallel)
> ##D 
> ##D if (.Platform$OS.type == "unix") {
> ##D sflist1 <- 
> ##D   mclapply(1:4, mc.cores = 2, 
> ##D            function(i) stan(fit = foo, data = foo_data, seed = seed, 
> ##D 	                    chains = 1, chain_id = i, refresh = -1))
> ##D f3 <- sflist2stanfit(sflist1)
> ##D }
> ##D if (.Platform$OS.type == "windows") { # also works on non-Windows
> ##D CL <- makeCluster(2)
> ##D clusterExport(cl = CL, c("foo_data", "foo", "seed")) 
> ##D sflist1 <- parLapply(CL, 1:4, fun = function(cid) {  
> ##D   require(rstan)
> ##D   stan(fit = foo, data = foo_data, chains = 1, 
> ##D        iter = 2000, seed = seed, chain_id = cid)
> ##D })
> ##D 
> ##D fit <- sflist2stanfit(sflist1)
> ##D print(fit)
> ##D stopCluster(CL)
> ##D } # end example for Windows 
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("stan")
> ### * stan
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan
> ### Title: Fit a model with Stan
> ### Aliases: stan
> ### Keywords: rstan
> 
> ### ** Examples
> ## Not run: 
> ##D #### example 1
> ##D library(rstan)
> ##D scode <- "
> ##D parameters {
> ##D   array[2] real y;
> ##D }
> ##D model {
> ##D   y[1] ~ normal(0, 1);
> ##D   y[2] ~ double_exponential(0, 2);
> ##D }
> ##D "
> ##D fit1 <- stan(model_code = scode, iter = 10, verbose = FALSE)
> ##D print(fit1)
> ##D fit2 <- stan(fit = fit1, iter = 10000, verbose = FALSE)
> ##D 
> ##D ## using as.array on the stanfit object to get samples
> ##D a2 <- as.array(fit2)
> ##D 
> ##D ## extract samples as a list of arrays
> ##D e2 <- extract(fit2, permuted = FALSE)
> ##D 
> ##D #### example 2
> ##D #### the result of this package is included in the package
> ##D 
> ##D excode <- '
> ##D   transformed data {
> ##D     array[20] real y;
> ##D     y[1] = 0.5796;  y[2] = 0.2276;   y[3]  = -0.2959;
> ##D     y[4] = -0.3742; y[5] = 0.3885;   y[6]  = -2.1585;
> ##D     y[7] = 0.7111;  y[8] = 1.4424;   y[9]  = 2.5430;
> ##D     y[10] = 0.3746; y[11] = 0.4773;  y[12] = 0.1803;
> ##D     y[13] = 0.5215; y[14] = -1.6044; y[15] = -0.6703;
> ##D     y[16] = 0.9459; y[17] = -0.382;  y[18] = 0.7619;
> ##D     y[19] = 0.1006; y[20] = -1.7461;
> ##D   }
> ##D   parameters {
> ##D     real mu;
> ##D     real<lower=0, upper=10> sigma;
> ##D     vector[2] z[3];
> ##D     real<lower=0> alpha;
> ##D   }
> ##D   model {
> ##D     y ~ normal(mu, sigma);
> ##D     for (i in 1:3)
> ##D       z[i] ~ normal(0, 1);
> ##D     alpha ~ exponential(2);
> ##D   }
> ##D '
> ##D 
> ##D exfit <- stan(model_code = excode, save_dso = FALSE, iter = 500)
> ##D print(exfit)
> ##D plot(exfit)
> ## End(Not run)
> ## Not run: 
> ##D ## examples of specify argument `init` for function stan
> ##D 
> ##D ## define a function to generate initial values that can
> ##D ## be fed to function stan's argument `init`
> ##D # function form 1 without arguments
> ##D initf1 <- function() {
> ##D   list(mu = 1, sigma = 4, z = array(rnorm(6), dim = c(3,2)), alpha = 1)
> ##D }
> ##D # function form 2 with an argument named `chain_id`
> ##D initf2 <- function(chain_id = 1) {
> ##D   # cat("chain_id =", chain_id, "\n")
> ##D   list(mu = 1, sigma = 4, z = array(rnorm(6), dim = c(3,2)), alpha = chain_id)
> ##D }
> ##D 
> ##D # generate a list of lists to specify initial values
> ##D n_chains <- 4
> ##D init_ll <- lapply(1:n_chains, function(id) initf2(chain_id = id))
> ##D 
> ##D exfit0 <- stan(model_code = excode, init = initf1)
> ##D stan(fit = exfit0, init = initf2)
> ##D stan(fit = exfit0, init = init_ll, chains = n_chains)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("stan_csv")
> ### * stan_csv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_stan_csv
> ### Title: Read CSV files of samples generated by (R)Stan into a 'stanfit'
> ###   object
> ### Aliases: read_stan_csv
> 
> ### ** Examples
> 
> csvfiles <- dir(system.file('misc', package = 'rstan'),
+                 pattern = 'rstan_doc_ex_[0-9].csv', full.names = TRUE)
> fit <- read_stan_csv(csvfiles)
> 
> 
> 
> cleanEx()
> nameEx("stan_demo")
> ### * stan_demo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_demo
> ### Title: Demonstrate examples included in Stan
> ### Aliases: stan_demo
> 
> ### ** Examples
> 
>   ## Not run: 
> ##D      dogsfit <- stan_demo("dogs") # run the dogs model
> ##D      fit1 <- stan_demo(1) # run model_names[1]
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_model")
> ### * stan_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_model
> ### Title: Construct a Stan model
> ### Aliases: stan_model
> ### Keywords: rstan
> 
> ### ** Examples
> ## Not run: 
> ##D stancode <- 'data {real y_mean;} parameters {real y;} model {y ~ normal(y_mean,1);}'
> ##D mod <- stan_model(model_code = stancode, verbose = TRUE)
> ##D fit <- sampling(mod, data = list(y_mean = 0))
> ##D fit2 <- sampling(mod, data = list(y_mean = 5))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("stan_plot")
> ### * stan_plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Plots
> ### Title: ggplot2 for RStan
> ### Aliases: stan_plot stan_trace stan_dens stan_hist stan_scat stan_ac
> ###   quietgg
> 
> ### ** Examples
> 
> ## Not run: 
> ##D example("read_stan_csv")
> ##D stan_plot(fit)
> ##D stan_trace(fit)
> ##D 
> ##D library(gridExtra)
> ##D fit <- stan_demo("eight_schools")
> ##D 
> ##D stan_plot(fit)
> ##D stan_plot(fit, point_est = "mean", show_density = TRUE, fill_color = "maroon")
> ##D 
> ##D 
> ##D # histograms
> ##D stan_hist(fit)
> ##D # suppress ggplot2 messages about default bindwidth
> ##D quietgg(stan_hist(fit))
> ##D quietgg(h <- stan_hist(fit, pars = "theta", binwidth = 5)) 
> ##D 
> ##D # juxtapose histograms of tau and unconstrained tau 
> ##D tau <- stan_hist(fit, pars = "tau")
> ##D tau_unc <- stan_hist(fit, pars = "tau", unconstrain = TRUE) + 
> ##D             xlab("tau unconstrained")
> ##D grid.arrange(tau, tau_unc)
> ##D 
> ##D # kernel density estimates
> ##D stan_dens(fit)
> ##D (dens <- stan_dens(fit, fill = "skyblue", ))
> ##D dens <- dens + ggtitle("Kernel Density Estimates\n") + xlab("")
> ##D dens
> ##D 
> ##D (dens_sep <- stan_dens(fit, separate_chains = TRUE, alpha = 0.3))
> ##D dens_sep + scale_fill_manual(values = c("red", "blue", "green", "black"))
> ##D (dens_sep_stack <- stan_dens(fit, pars = "theta", alpha = 0.5,
> ##D                              separate_chains = TRUE, position = "stack"))
> ##D 
> ##D # traceplot
> ##D trace <- stan_trace(fit)
> ##D trace +
> ##D   scale_color_manual(values = c("red", "blue", "green", "black"))
> ##D trace +
> ##D   scale_color_brewer(type = "div") +
> ##D   theme(legend.position = "none")
> ##D 
> ##D facet_style <- theme(strip.background = ggplot2::element_rect(fill = "white"),
> ##D                      strip.text = ggplot2::element_text(size = 13, color = "black"))
> ##D (trace <- trace + facet_style)
> ##D 
> ##D # scatterplot
> ##D (mu_vs_tau <- stan_scat(fit, pars = c("mu", "tau"), color = "blue", size = 4))
> ##D mu_vs_tau + 
> ##D   ggplot2::coord_flip() + 
> ##D   theme(panel.background = ggplot2::element_rect(fill = "black"))
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_plot_diagnostics")
> ### * stan_plot_diagnostics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Diagnostic plots
> ### Title: RStan Diagnostic plots
> ### Aliases: stan_diag stan_par stan_rhat stan_ess stan_mcse
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- stan_demo("eight_schools")
> ##D 
> ##D stan_diag(fit, info = 'sample') # shows three plots together
> ##D samp_info <- stan_diag(fit, info = 'sample') # saves the three plots in a list
> ##D samp_info[[3]] # access just the third plot
> ##D 
> ##D stan_diag(fit, info = 'sample', chain = 1) # overlay chain 1
> ##D 
> ##D stan_par(fit, par = "mu")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_plot_options")
> ### * stan_plot_options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rstan_gg_options
> ### Title: Set default appearance options
> ### Aliases: rstan_gg_options rstan_ggtheme_options
> 
> ### ** Examples
> 
> rstan_ggtheme_options(panel.background = ggplot2::element_rect(fill = "gray"),
+                       legend.position = "top")
> rstan_gg_options(fill = "skyblue", color = "skyblue4", pt_color = "red")
> 
> 
> 
> cleanEx()
> nameEx("stan_rdump")
> ### * stan_rdump
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_rdump
> ### Title: Dump the data for a Stan model to R dump file in the limited
> ###   format that Stan can read.
> ### Aliases: stan_rdump
> ### Keywords: rstan
> 
> ### ** Examples
> 
> # set variables in global environment
> a <- 17.5
> b <- c(1,2,3)
> # write variables a and b to file ab.data.R in temporary directory
> stan_rdump(c('a','b'), file.path(tempdir(), "ab.data.R"))
> unlink(file.path(tempdir(), "ab.data.R"))
> 
> x <- 1; y <- 1:10; z <- array(1:10, dim = c(2,5)) 
> stan_rdump(ls(pattern = '^[xyz]'), file.path(tempdir(), "xyz.Rdump"))
> cat(paste(readLines(file.path(tempdir(), "xyz.Rdump")), collapse = '\n'), '\n')
x <- 1
y <- 
c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
z <- 
structure(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
.Dim = c(2, 5)) 
> unlink(file.path(tempdir(), "xyz.Rdump"))
> 
> 
> 
> cleanEx()
> nameEx("stan_version")
> ### * stan_version
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_version
> ### Title: Obtain the version of Stan
> ### Aliases: stan_version
> ### Keywords: rstan
> 
> ### ** Examples
> 
>   stan_version() 
[1] "2.32.2"
> 
> 
> 
> cleanEx()
> nameEx("stanc")
> ### * stanc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stanc
> ### Title: Translate Stan model specification to C++ code
> ### Aliases: stanc stanc_builder
> 
> ### ** Examples
> 
> stanmodelcode <- "
+ data {
+   int<lower=0> N;
+   array[N] real y;
+ }
+ 
+ parameters {
+   real mu;
+ }
+ 
+ model {
+   mu ~ normal(0, 10);
+   y ~ normal(mu, 1);
+ }
+ "
> 
> r <- stanc(model_code = stanmodelcode, model_name = "normal1")
> str(r)
List of 5
 $ status       : logi TRUE
 $ model_cppname: chr "model1687264be4e54_normal1"
 $ cppcode      : chr "#ifndef USE_STANC3\n#define USE_STANC3\n#endif\n// Code generated by stanc v2.32.2\n#include <stan/model/model_"| __truncated__
 $ model_name   : chr "normal1"
 $ model_code   : chr "data {\n  int<lower=0> N;\n  array[N] real y;\n}\nparameters {\n  real mu;\n}\nmodel {\n  mu ~ normal(0, 10);\n"| __truncated__
  ..- attr(*, "model_name2")= chr "file16872603edfbb"
> 
> 
> 
> cleanEx()
> nameEx("stanfit-class")
> ### * stanfit-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stanfit-class
> ### Title: Class 'stanfit': fitted Stan model
> ### Aliases: stanfit-class stanfit show,stanfit-method get_cppo_mode
> ###   get_cppo_mode,stanfit-method get_stancode get_stancode,stanfit-method
> ###   get_stanmodel get_stanmodel,stanfit-method get_seed
> ###   get_seed,stanfit-method get_seeds get_seeds,stanfit-method get_inits
> ###   get_inits,stanfit-method get_posterior_mean
> ###   get_posterior_mean,stanfit-method get_elapsed_time
> ###   get_elapsed_time,stanfit-method get_logposterior
> ###   get_logposterior,stanfit-method get_adaptation_info
> ###   get_adaptation_info,stanfit-method get_sampler_params
> ###   get_sampler_params,stanfit,logical-method
> ### Keywords: classes
> 
> ### ** Examples
> ## Not run: 
> ##D showClass("stanfit")
> ##D ecode <- '
> ##D   parameters {
> ##D     array[2] real<lower=0> y;
> ##D   } 
> ##D   model {
> ##D     y ~ exponential(1);
> ##D   }
> ##D '
> ##D fit <- stan(model_code = ecode, iter = 10, chains = 1)
> ##D fit2 <- stan(fit = fit)
> ##D print(fit2)
> ##D plot(fit2)
> ##D traceplot(fit2)
> ##D ainfo <- get_adaptation_info(fit2)
> ##D cat(ainfo[[1]])
> ##D seed <- get_seed(fit2)
> ##D sp <- get_sampler_params(fit2)
> ##D sp2 <- get_sampler_params(fit2, inc_warmup = FALSE)
> ##D head(sp[[1]])
> ##D 
> ##D lp <- log_prob(fit, c(1, 2))
> ##D grad <- grad_log_prob(fit, c(1, 2))
> ##D lp2 <- attr(grad, "log_prob") # should be the same as "lp"
> ##D 
> ##D # get the number of parameters on the unconstrained space
> ##D n <- get_num_upars(fit)
> ##D 
> ##D # parameters on the positive real line (constrained space) 
> ##D y1 <- list(y = rep(1, 2)) 
> ##D 
> ##D uy <- unconstrain_pars(fit, y1) 
> ##D ## uy should be c(0, 0) since here the log transformation is used
> ##D y1star <- constrain_pars(fit, uy)
> ##D 
> ##D print(y1)
> ##D print(y1star) # y1start should equal to y1 
> ## End(Not run)
> 
> # Create a stanfit object from reading CSV files of samples (saved in rstan
> # package) generated by funtion stan for demonstration purpose from model as follows. 
> # 
> excode <- '
+   transformed data {
+     array[20] real y;
+     y[1] <- 0.5796;  y[2]  <- 0.2276;   y[3] <- -0.2959; 
+     y[4] <- -0.3742; y[5]  <- 0.3885;   y[6] <- -2.1585;
+     y[7] <- 0.7111;  y[8]  <- 1.4424;   y[9] <- 2.5430; 
+     y[10] <- 0.3746; y[11] <- 0.4773;   y[12] <- 0.1803; 
+     y[13] <- 0.5215; y[14] <- -1.6044;  y[15] <- -0.6703; 
+     y[16] <- 0.9459; y[17] <- -0.382;   y[18] <- 0.7619;
+     y[19] <- 0.1006; y[20] <- -1.7461;
+   }
+   parameters {
+     real mu;
+     real<lower=0, upper=10> sigma;
+     vector[2] z[3];
+     real<lower=0> alpha;
+   } 
+   model {
+     y ~ normal(mu, sigma);
+     for (i in 1:3) 
+       z[i] ~ normal(0, 1);
+     alpha ~ exponential(2);
+   } 
+ '
> 
> # exfit <- stan(model_code = excode, save_dso = FALSE, iter = 200, 
> #               sample_file = "rstan_doc_ex.csv")
> # 
> 
> exfit <- read_stan_csv(dir(system.file('misc', package = 'rstan'),
+                        pattern='rstan_doc_ex_[[:digit:]].csv',
+                        full.names = TRUE))
> 
> print(exfit)
Inference for Stan model: rstan_doc_ex.
4 chains, each with iter=200; warmup=100; thin=1; 
post-warmup draws per chain=100, total post-warmup draws=400.

         mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat
mu       0.09    0.01 0.23  -0.38  -0.05   0.11   0.25   0.56   338 1.00
sigma    1.16    0.02 0.21   0.86   1.02   1.14   1.28   1.74   186 1.00
z[1,1]   0.00    0.05 0.92  -1.81  -0.65  -0.01   0.71   1.59   285 1.01
z[1,2]   0.01    0.06 1.03  -2.04  -0.66   0.05   0.67   1.99   270 1.00
z[2,1]   0.10    0.05 0.98  -1.71  -0.55   0.08   0.76   1.98   342 1.00
z[2,2]   0.04    0.05 0.95  -1.85  -0.68   0.07   0.72   1.73   394 1.00
z[3,1]  -0.06    0.05 1.07  -2.08  -0.81  -0.11   0.68   1.93   453 1.00
z[3,2]   0.12    0.06 1.04  -1.74  -0.51   0.08   0.77   2.16   310 1.00
alpha    0.53    0.03 0.53   0.01   0.18   0.39   0.69   2.07   426 0.99
lp__   -17.47    0.20 2.26 -23.33 -18.68 -17.21 -15.76 -14.29   124 1.02

Samples were drawn using NUTS(diag_e) at Mon Apr 14 08:39:02 AM 2025.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).
> ## Not run: 
> ##D plot(exfit)
> ## End(Not run)
> 
> adaptinfo <- get_adaptation_info(exfit)
> inits <- get_inits(exfit) # empty
> inits <- get_inits(exfit, iter = 101)
> seed <- get_seed(exfit)
> sp <- get_sampler_params(exfit)
> ml <- As.mcmc.list(exfit)
> cat(get_stancode(exfit))
> 
> 
> 
> cleanEx()
> nameEx("stanfit-method-extract")
> ### * stanfit-method-extract
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extract
> ### Title: Extract samples from a fitted Stan model
> ### Aliases: extract extract,stanfit-method
> ### Keywords: methods
> 
> ### ** Examples
> ## Not run: 
> ##D ex_model_code <- '
> ##D   parameters {
> ##D     array[2, 3] real alpha;
> ##D     array[2] real beta; 
> ##D   } 
> ##D   model {
> ##D     for (i in 1:2) for (j in 1:3) 
> ##D       alpha[i, j] ~ normal(0, 1); 
> ##D     for (i in 1:2) 
> ##D       beta ~ normal(0, 2); 
> ##D   } 
> ##D '
> ##D 
> ##D ## fit the model 
> ##D fit <- stan(model_code = ex_model_code, chains = 4) 
> ##D 
> ##D ## extract alpha and beta with 'permuted = TRUE' 
> ##D fit_ss <- extract(fit, permuted = TRUE) # fit_ss is a list 
> ##D ## list fit_ss should have elements with name 'alpha', 'beta', 'lp__'
> ##D alpha <- fit_ss$alpha  
> ##D beta <- fit_ss$beta 
> ##D ## or extract alpha by just specifying pars = 'alpha' 
> ##D alpha2 <- extract(fit, pars = 'alpha', permuted = TRUE)$alpha 
> ##D print(identical(alpha, alpha2)) 
> ##D 
> ##D ## or extract alpha by excluding beta and lp__
> ##D alpha3 <- extract(fit, pars = c('beta', 'lp__'), 
> ##D                   permuted = TRUE, include = FALSE)$alpha
> ##D print(identical(alpha, alpha3))
> ##D 
> ##D ## get the samples for alpha[1,1] and beta[2] 
> ##D alpha_11 <- alpha[, 1, 1] 
> ##D beta_2 <- beta[, 2] 
> ##D 
> ##D ## extract samples with 'permuted = FALSE' 
> ##D fit_ss2 <- extract(fit, permuted = FALSE) # fit_ss2 is an array  
> ##D 
> ##D ## the dimensions of fit_ss2 should be  
> ##D ## "# of iterations * # of chains * # of parameters"
> ##D dim(fit_ss2) 
> ##D 
> ##D ## since the third dimension of `fit_ss2` indicates 
> ##D ## parameters, the names should be 
> ##D ##  alpha[1,1], alpha[2,1], alpha[1,2], alpha[2,2], 
> ##D ##  alpha[1,3], alpha[2,3], beta[1], beta[2], and lp__ 
> ##D ## `lp__` (the log-posterior) is always included 
> ##D ## in the samples.  
> ##D dimnames(fit_ss2) 
> ## End(Not run)
> 
> # Create a stanfit object from reading CSV files of samples (saved in rstan
> # package) generated by funtion stan for demonstration purpose from model as follows. 
> # 
> excode <- '
+   transformed data {
+     array[20] real y;
+     y[1] <- 0.5796;  y[2]  <- 0.2276;   y[3] <- -0.2959; 
+     y[4] <- -0.3742; y[5]  <- 0.3885;   y[6] <- -2.1585;
+     y[7] <- 0.7111;  y[8]  <- 1.4424;   y[9] <- 2.5430; 
+     y[10] <- 0.3746; y[11] <- 0.4773;   y[12] <- 0.1803; 
+     y[13] <- 0.5215; y[14] <- -1.6044;  y[15] <- -0.6703; 
+     y[16] <- 0.9459; y[17] <- -0.382;   y[18] <- 0.7619;
+     y[19] <- 0.1006; y[20] <- -1.7461;
+   }
+   parameters {
+     real mu;
+     real<lower=0, upper=10> sigma;
+     vector[2] z[3];
+     real<lower=0> alpha;
+   } 
+   model {
+     y ~ normal(mu, sigma);
+     for (i in 1:3) 
+       z[i] ~ normal(0, 1);
+     alpha ~ exponential(2);
+   } 
+ '
> # exfit <- stan(model_code = excode, save_dso = FALSE, iter = 200, 
> #               sample_file = "rstan_doc_ex.csv")
> # 
> exfit <- read_stan_csv(dir(system.file('misc', package = 'rstan'),
+                        pattern='rstan_doc_ex_[[:digit:]].csv',
+                        full.names = TRUE))
> 
> ee1 <- extract(exfit, permuted = TRUE)
> print(names(ee1))
[1] "mu"    "sigma" "z"     "alpha" "lp__" 
> 
> for (name in names(ee1)) {
+   cat(name, "\n")
+   print(dim(ee1[[name]]))
+ }
mu 
[1] 400
sigma 
[1] 400
z 
[1] 400   3   2
alpha 
[1] 400
lp__ 
[1] 400
> 
> ee2 <- extract(exfit, permuted = FALSE)
> print(dim(ee2))
[1] 100   4  10
> print(dimnames(ee2))
$iterations
NULL

$chains
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$parameters
 [1] "mu"     "sigma"  "z[1,1]" "z[2,1]" "z[3,1]" "z[1,2]" "z[2,2]" "z[3,2]"
 [9] "alpha"  "lp__"  

> 
> 
> 
> cleanEx()
> nameEx("stanfit-method-logprob")
> ### * stanfit-method-logprob
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: log_prob-methods
> ### Title: 'log_prob' and 'grad_log_prob' functions
> ### Aliases: log_prob log_prob,stanfit-method grad_log_prob
> ###   grad_log_prob,stanfit-method constrain_pars
> ###   constrain_pars,stanfit-method unconstrain_pars
> ###   unconstrain_pars,stanfit-method get_num_upars
> ###   get_num_upars,stanfit-method
> 
> ### ** Examples
> ## Not run: 
> ##D # see the examples in the help for stanfit as well
> ##D # do a simple optimization problem 
> ##D opcode <- "
> ##D parameters {
> ##D   real y;
> ##D }
> ##D model {
> ##D   target += log(square(y - 5) + 1);
> ##D }
> ##D "
> ##D opfit <- stan(model_code = opcode, chains = 0)
> ##D tfun <- function(y) log_prob(opfit, y)
> ##D tgrfun <- function(y) grad_log_prob(opfit, y)
> ##D or <- optim(1, tfun, tgrfun, method = 'BFGS')
> ##D print(or)
> ##D 
> ##D # return the gradient as an attribute
> ##D tfun2 <- function(y) { 
> ##D   g <- grad_log_prob(opfit, y) 
> ##D   lp <- attr(g, "log_prob")
> ##D   attr(lp, "gradient") <- g
> ##D   lp
> ##D } 
> ##D 
> ##D or2 <- nlm(tfun2, 10)
> ##D or2 
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("stanfit-method-loo")
> ### * stanfit-method-loo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo.stanfit
> ### Title: Approximate leave-one-out cross-validation
> ### Aliases: loo.stanfit loo,stanfit-method loo
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Generate a dataset from N(0,1)
> ##D N <- 100
> ##D y <- rnorm(N, 0, 1)
> ##D 
> ##D # Suppose we have three models for y:
> ##D #  1) y ~ N(-1, sigma)
> ##D #  2) y ~ N(0.5, sigma)
> ##D #  3) y ~ N(0.6,sigma)
> ##D #
> ##D stan_code <- "
> ##D data {
> ##D   int N;
> ##D   vector[N] y;
> ##D   real mu_fixed;
> ##D }
> ##D   parameters {
> ##D   real<lower=0> sigma;
> ##D }
> ##D model {
> ##D   sigma ~ exponential(1);
> ##D   y ~ normal(mu_fixed, sigma);
> ##D }
> ##D generated quantities {
> ##D   vector[N] log_lik;
> ##D   for (n in 1:N) log_lik[n] = normal_lpdf(y[n]| mu_fixed, sigma);
> ##D }"
> ##D 
> ##D mod <- stan_model(model_code = stan_code)
> ##D fit1 <- sampling(mod, data=list(N=N, y=y, mu_fixed=-1))
> ##D fit2 <- sampling(mod, data=list(N=N, y=y, mu_fixed=0.5))
> ##D fit3 <- sampling(mod, data=list(N=N, y=y, mu_fixed=0.6))
> ##D 
> ##D # use the loo method for stanfit objects
> ##D loo1 <- loo(fit1, pars = "log_lik")
> ##D print(loo1)
> ##D 
> ##D # which is equivalent to
> ##D LL <- as.array(fit1, pars = "log_lik")
> ##D r_eff <- loo::relative_eff(exp(LL))
> ##D loo1b <- loo::loo.array(LL, r_eff = r_eff)
> ##D print(loo1b)
> ##D 
> ##D # compute loo for the other models
> ##D loo2 <- loo(fit2)
> ##D loo3 <- loo(fit3)
> ##D 
> ##D # stacking weights
> ##D wts <- loo::loo_model_weights(list(loo1, loo2, loo3), method = "stacking")
> ##D print(wts)
> ##D 
> ##D # use the moment matching for loo with a stanfit object
> ##D loo_mm <- loo(fit1, pars = "log_lik", moment_match = TRUE)
> ##D print(loo_mm)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stanfit-method-pairs")
> ### * stanfit-method-pairs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairs.stanfit
> ### Title: Create a matrix of output plots from a 'stanfit' object
> ### Aliases: pairs.stanfit
> 
> ### ** Examples
> 
> example(read_stan_csv)

rd_st_> csvfiles <- dir(system.file('misc', package = 'rstan'),
rd_st_+                 pattern = 'rstan_doc_ex_[0-9].csv', full.names = TRUE)

rd_st_> fit <- read_stan_csv(csvfiles)
> pairs(fit, pars = c("mu", "sigma", "alpha", "lp__"), log = TRUE, las = 1)
Warning in par(usr) : argument 1 does not name a graphical parameter
Warning in par(usr) : argument 1 does not name a graphical parameter
Warning in par(usr) : argument 1 does not name a graphical parameter
Warning in par(usr) : argument 1 does not name a graphical parameter
> # sigma and alpha will have logarithmic axes
> 
> 
> 
> cleanEx()
> nameEx("stanfit-method-plot")
> ### * stanfit-method-plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot-methods
> ### Title: Plots for stanfit objects
> ### Aliases: plot,stanfit-method plot,stanfit,missing-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(rstan)
> ##D fit <- stan_demo("eight_schools")
> ##D plot(fit)
> ##D plot(fit, show_density = TRUE, ci_level = 0.5, fill_color = "purple")
> ##D plot(fit, plotfun = "hist", pars = "theta", include = FALSE)
> ##D plot(fit, plotfun = "trace", pars = c("mu", "tau"), inc_warmup = TRUE)
> ##D plot(fit, plotfun = "rhat") + ggtitle("Example of adding title to plot")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stanfit-method-summary")
> ### * stanfit-method-summary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary-methods
> ### Title: Summary method for stanfit objects
> ### Aliases: summary,stanfit-method
> ### Keywords: methods
> 
> ### ** Examples
> ## Not run: 
> ##D ecode <- '
> ##D   parameters {
> ##D     array[2] real<lower=0> y;
> ##D   } 
> ##D   model {
> ##D     y ~ exponential(1);
> ##D   }
> ##D '
> ##D fit <- stan(model_code = ecode)
> ##D s <- summary(fit, probs = c(0.1, 0.9))
> ##D s$summary  # all chaines merged
> ##D s$c_summary  # individual chains
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stanfit-method-traceplot")
> ### * stanfit-method-traceplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: traceplot
> ### Title: Markov chain traceplots
> ### Aliases: traceplot traceplot,stanfit-method
> ### Keywords: methods
> 
> ### ** Examples
> ## Not run: 
> ##D # Create a stanfit object from reading CSV files of samples (saved in rstan
> ##D # package) generated by funtion stan for demonstration purpose from model as follows. 
> ##D # 
> ##D excode <- '
> ##D   transformed data {
> ##D     array[20] real y;
> ##D     y[1] <- 0.5796;  y[2]  <- 0.2276;   y[3] <- -0.2959; 
> ##D     y[4] <- -0.3742; y[5]  <- 0.3885;   y[6] <- -2.1585;
> ##D     y[7] <- 0.7111;  y[8]  <- 1.4424;   y[9] <- 2.5430; 
> ##D     y[10] <- 0.3746; y[11] <- 0.4773;   y[12] <- 0.1803; 
> ##D     y[13] <- 0.5215; y[14] <- -1.6044;  y[15] <- -0.6703; 
> ##D     y[16] <- 0.9459; y[17] <- -0.382;   y[18] <- 0.7619;
> ##D     y[19] <- 0.1006; y[20] <- -1.7461;
> ##D   }
> ##D   parameters {
> ##D     real mu;
> ##D     real<lower=0, upper=10> sigma;
> ##D     vector[2] z[3];
> ##D     real<lower=0> alpha;
> ##D   } 
> ##D   model {
> ##D     y ~ normal(mu, sigma);
> ##D     for (i in 1:3) 
> ##D       z[i] ~ normal(0, 1);
> ##D     alpha ~ exponential(2);
> ##D   } 
> ##D '
> ##D # exfit <- stan(model_code = excode, save_dso = FALSE, iter = 200, 
> ##D #               sample_file = "rstan_doc_ex.csv")
> ##D # 
> ##D exfit <- read_stan_csv(dir(system.file('misc', package = 'rstan'),
> ##D                        pattern='rstan_doc_ex_[[:digit:]].csv',
> ##D                        full.names = TRUE))
> ##D 
> ##D print(exfit)
> ##D traceplot(exfit)
> ##D traceplot(exfit, size = 0.25)
> ##D traceplot(exfit, pars = "sigma", inc_warmup = TRUE)
> ##D 
> ##D trace <- traceplot(exfit, pars = c("z[1,1]", "z[3,1]"))
> ##D trace + scale_color_discrete() + theme(legend.position = "top")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stanfit2array-method")
> ### * stanfit2array-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.array
> ### Title: Create array, matrix, or data.frame objects from samples in a
> ###   'stanfit' object
> ### Aliases: is.array.stanfit as.array.stanfit as.matrix.stanfit
> ###   as.data.frame.stanfit dim.stanfit dimnames.stanfit names.stanfit
> ###   names<-.stanfit
> 
> ### ** Examples
> ## Not run: 
> ##D ex_model_code <- '
> ##D   parameters {
> ##D     array[2, 3] real alpha;
> ##D     array[2] real beta; 
> ##D   } 
> ##D   model {
> ##D     for (i in 1:2) for (j in 1:3) 
> ##D       alpha[i, j] ~ normal(0, 1); 
> ##D     for (i in 1:2) 
> ##D       beta[i] ~ normal(0, 2); 
> ##D     # beta ~ normal(0, 2) // vectorized version
> ##D   } 
> ##D '
> ##D 
> ##D ## fit the model 
> ##D fit <- stan(model_code = ex_model_code, chains = 4) 
> ##D 
> ##D dim(fit)
> ##D dimnames(fit)
> ##D is.array(fit) 
> ##D a <- as.array(fit)
> ##D m <- as.matrix(fit)
> ##D d <- as.data.frame(fit)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("stanmodel-class")
> ### * stanmodel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stanmodel-class
> ### Title: Class representing model compiled from C++
> ### Aliases: stanmodel-class get_cppcode get_cxxflags
> ###   get_cppcode,stanmodel-method get_cxxflags,stanmodel-method
> ###   get_stancode,stanmodel-method show,stanmodel-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("stanmodel")
Class "stanmodel" [package "rstan"]

Slots:
                                                                       
Name:    model_name   model_code    model_cpp mk_cppmodule          dso
Class:    character    character         list     function       cxxdso
> 
> 
> 
> cleanEx()
> nameEx("stanmodel-method-gqs")
> ### * stanmodel-method-gqs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gqs
> ### Title: Draw samples of generated quantities from a Stan model
> ### Aliases: gqs gqs,stanmodel-method
> 
> ### ** Examples
> ## Not run: 
> ##D m <- stan_model(model_code = 'parameters {real y;} model {y ~ normal(0,1);}')
> ##D f <- sampling(m, iter = 300)
> ##D mc <-
> ##D '
> ##D parameters {real y;}
> ##D generated quantities {real y_rep = normal_rng(y, 1);}
> ##D '
> ##D m2 <- stan_model(model_code = mc)
> ##D f2 <- gqs(m2, draws = as.matrix(f))
> ##D f2
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("stanmodel-method-optimizing")
> ### * stanmodel-method-optimizing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optimizing
> ### Title: Obtain a point estimate by maximizing the joint posterior
> ### Aliases: optimizing optimizing,stanmodel-method
> 
> ### ** Examples
> ## Not run: 
> ##D m <- stan_model(model_code = 'parameters {real y;} model {y ~ normal(0,1);}')
> ##D f <- optimizing(m, hessian = TRUE)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("stanmodel-method-sampling")
> ### * stanmodel-method-sampling
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sampling
> ### Title: Draw samples from a Stan model
> ### Aliases: sampling sampling,stanmodel-method
> 
> ### ** Examples
> ## Not run: 
> ##D m <- stan_model(model_code = 'parameters {real y;} model {y ~ normal(0,1);}')
> ##D f <- sampling(m, iter = 100)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("stanmodel-method-vb")
> ### * stanmodel-method-vb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vb
> ### Title: Run Stan's variational algorithm for approximate posterior
> ###   sampling
> ### Aliases: vb vb,stanmodel-method
> 
> ### ** Examples
> ## Not run: 
> ##D m <- stan_model(model_code = 'parameters {real y;} model {y ~ normal(0,1);}')
> ##D f <- vb(m)
> ## End(Not run)
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  2.768 0.172 2.608 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
