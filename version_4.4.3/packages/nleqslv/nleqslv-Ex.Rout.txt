
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "nleqslv"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('nleqslv')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("nleqslv")
> ### * nleqslv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nleqslv
> ### Title: Solving systems of nonlinear equations with Broyden or Newton
> ### Aliases: nleqslv
> ### Keywords: nonlinear optimize
> 
> ### ** Examples
> 
> # Dennis Schnabel example 6.5.1 page 149
> dslnex <- function(x) {
+     y <- numeric(2)
+     y[1] <- x[1]^2 + x[2]^2 - 2
+     y[2] <- exp(x[1]-1) + x[2]^3 - 2
+     y
+ }
> 
> jacdsln <- function(x) {
+     n <- length(x)
+     Df <- matrix(numeric(n*n),n,n)
+     Df[1,1] <- 2*x[1]
+     Df[1,2] <- 2*x[2]
+     Df[2,1] <- exp(x[1]-1)
+     Df[2,2] <- 3*x[2]^2
+ 
+     Df
+ }
> 
> BADjacdsln <- function(x) {
+     n <- length(x)
+     Df <- matrix(numeric(n*n),n,n)
+     Df[1,1] <- 4*x[1]
+     Df[1,2] <- 2*x[2]
+     Df[2,1] <- exp(x[1]-1)
+     Df[2,2] <- 5*x[2]^2
+ 
+     Df
+ }
> 
> xstart <- c(2,0.5)
> fstart <- dslnex(xstart)
> xstart
[1] 2.0 0.5
> fstart
[1] 2.2500000 0.8432818
> 
> # a solution is c(1,1)
> 
> nleqslv(xstart, dslnex, control=list(btol=.01))
$x
[1] 1 1

$fvec
[1] 1.499778e-09 2.056389e-09

$termcd
[1] 1

$message
[1] "Function criterion near zero"

$scalex
[1] 1 1

$nfcnt
[1] 12

$njcnt
[1] 1

$iter
[1] 10

> 
> # Cauchy start
> nleqslv(xstart, dslnex, control=list(trace=1,btol=.01,delta="cauchy"))
  Algorithm parameters
  --------------------
  Method: Broyden  Global strategy: double dogleg (initial trust region = -1)
  Maximum stepsize = 1.79769e+308
  Scaling: fixed
  ftol = 1e-08 xtol = 1e-08 btol = 0.01 cndtol = 1e-12

  Iteration report
  ----------------
  Iter         Jac     Lambda      Eta     Dlt0     Dltn         Fnorm   Largest |f|
     0                                                    2.886812e+00  2.250000e+00
     1  N(9.6e-03) C            0.9544   0.4671   0.9343* 1.699715e-01  5.421673e-01
     1             W   0.0833   0.9544   0.9343   0.4671  1.699715e-01  5.421673e-01
     2  B(1.1e-02) W   0.1154   0.4851   0.4671   0.4671  1.277667e-01  5.043571e-01
     3  B(7.3e-02) W   0.7879   0.7289   0.4671   0.0759  5.067893e-01  7.973542e-01
     3             C            0.7289   0.0759   0.1519  5.440250e-02  2.726084e-01
     4  B(8.3e-02) W   0.5307   0.3271   0.1519   0.3037  3.576547e-02  2.657553e-01
     5  B(1.8e-01) N            0.6674   0.2191   0.4383  6.566182e-03  8.555110e-02
     6  B(1.8e-01) N            0.9801   0.0376   0.0752  4.921645e-04  3.094104e-02
     7  B(1.9e-01) N            0.7981   0.0157   0.0313  4.960629e-06  2.826064e-03
     8  B(1.6e-01) N            0.3942   0.0029   0.0058  1.545503e-08  1.757498e-04
     9  B(1.5e-01) N            0.6536   0.0001   0.0003  2.968676e-11  5.983765e-06
    10  B(1.5e-01) N            0.4730   0.0000   0.0000  4.741792e-14  2.198380e-07
    11  B(1.5e-01) N            0.9787   0.0000   0.0000  6.451792e-19  8.118586e-10
$x
[1] 1 1

$fvec
[1]  8.118586e-10 -7.945087e-10

$termcd
[1] 1

$message
[1] "Function criterion near zero"

$scalex
[1] 1 1

$nfcnt
[1] 13

$njcnt
[1] 1

$iter
[1] 11

> 
> # Newton start
> nleqslv(xstart, dslnex, control=list(trace=1,btol=.01,delta="newton"))
  Algorithm parameters
  --------------------
  Method: Broyden  Global strategy: double dogleg (initial trust region = -2)
  Maximum stepsize = 1.79769e+308
  Scaling: fixed
  ftol = 1e-08 xtol = 1e-08 btol = 0.01 cndtol = 1e-12

  Iteration report
  ----------------
  Iter         Jac     Lambda      Eta     Dlt0     Dltn         Fnorm   Largest |f|
     0                                                    2.886812e+00  2.250000e+00
     1  N(9.6e-03) N            0.9544  10.1874   1.0187  5.787362e+05  1.070841e+03
     1             W   0.0932   0.9544   1.0187   1.0187  1.862204e+00  1.387696e+00
     2  B(1.9e-01) N            0.9658   0.6119   1.2239  1.003362e-01  4.468549e-01
     3  B(2.1e-01) N            0.6470   0.2521   0.5042  1.763418e-02  1.819978e-01
     4  B(1.3e-01) N            0.3486   0.2617   0.0598  5.952083e-02  3.020657e-01
     4             W   0.6248   0.3486   0.0598   0.1196  6.625459e-03  8.319100e-02
     5  B(1.5e-01) N            0.4212   0.1186   0.1186  3.368227e-03  5.868436e-02
     6  B(1.4e-01) N            0.9955   0.0177   0.0354  9.352918e-05  1.350724e-02
     7  B(1.8e-01) N            0.7560   0.0073   0.0146  9.330438e-06  3.933436e-03
     8  B(1.5e-01) N            0.8799   0.0020   0.0041  1.458619e-09  3.825434e-05
     9  B(1.5e-01) N            0.9969   0.0000   0.0000  1.640555e-13  4.501888e-07
    10  B(1.5e-01) N            0.9979   0.0000   0.0000  3.239034e-18  2.056389e-09
$x
[1] 1 1

$fvec
[1] 1.499778e-09 2.056389e-09

$termcd
[1] 1

$message
[1] "Function criterion near zero"

$scalex
[1] 1 1

$nfcnt
[1] 12

$njcnt
[1] 1

$iter
[1] 10

> 
> # final Broyden approximation of Jacobian (quite good)
> z <- nleqslv(xstart, dslnex, jacobian=TRUE,control=list(btol=.01))
> z$x
[1] 1 1
> z$jac
          [,1]     [,2]
[1,] 1.9818090 2.005414
[2,] 0.9750673 3.007420
> jacdsln(z$x)
     [,1] [,2]
[1,]    2    2
[2,]    1    3
> 
> # different initial start; not a very good final approximation
> xstart <- c(0.5,2)
> z <- nleqslv(xstart, dslnex, jacobian=TRUE,control=list(btol=.01))
> z$x
[1] 1 1
> z$jac
         [,1]     [,2]
[1,] 2.197044 2.182400
[2,] 3.210320 5.046055
> jacdsln(z$x)
     [,1] [,2]
[1,]    2    2
[2,]    1    3
> 
> ## Not run: 
> ##D # no global strategy but limit stepsize
> ##D # but look carefully: a different solution is found
> ##D nleqslv(xstart, dslnex, method="Newton", global="none", control=list(trace=1,stepmax=5))
> ##D 
> ##D # but if the stepsize is limited even more the c(1,1) solution is found
> ##D nleqslv(xstart, dslnex, method="Newton", global="none", control=list(trace=1,stepmax=2))
> ##D 
> ##D # Broyden also finds the c(1,1) solution when the stepsize is limited
> ##D nleqslv(xstart, dslnex, jacdsln, method="Broyden", global="none", control=list(trace=1,stepmax=2))
> ## End(Not run)
> 
> # example with a singular jacobian in the initial guess
> f <- function(x) {
+     y <- numeric(3)
+     y[1] <- x[1] + x[2] - x[1]*x[2] - 2
+     y[2] <- x[1] + x[3] - x[1]*x[3] - 3
+     y[3] <- x[2] + x[3] - 4
+     return(y)
+ }
> 
> Jac <- function(x) {
+     J <- matrix(0,nrow=3,ncol=3)
+     J[,1] <- c(1-x[2],1-x[3],0)
+     J[,2] <- c(1-x[1],0,1)
+     J[,3] <- c(0,1-x[1],1)
+     J
+ }
> 
> # exact solution
> xsol <- c(-.5, 5/3 , 7/3)
> xsol
[1] -0.500000  1.666667  2.333333
> 
> xstart <- c(1,2,3)
> J <- Jac(xstart)
> J
     [,1] [,2] [,3]
[1,]   -1    0    0
[2,]   -2    0    0
[3,]    0    1    1
> rcond(J)
[1] 0
> 
> z <- nleqslv(xstart,f,Jac, method="Newton",control=list(trace=1,allowSingular=TRUE))
  Algorithm parameters
  --------------------
  Method: Newton  Global strategy: double dogleg (initial trust region = -2)
  Maximum stepsize = 1.79769e+308
  Scaling: fixed
  ftol = 1e-08 xtol = 1e-08 btol = 0.001 cndtol = 1e-12

  Iteration report
  ----------------
  Iter         Jac     Lambda      Eta     Dlt0     Dltn         Fnorm   Largest |f|
     0                                                    3.000000e+00  2.000000e+00
     1  N(0.0e+00) N            0.9535   1.2247   2.4495  2.500000e-01  5.000000e-01
     2  N(2.0e-01) N            0.8000   0.6124   1.2247  1.562500e-02  1.250000e-01
     3  N(2.6e-01) N            0.9660   0.1179   0.2357  2.999644e-28  1.731948e-14
> all.equal(z$x,xsol)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("print.testnslv")
> ### * print.testnslv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.test.nleqslv
> ### Title: Printing the result of 'testnslv'
> ### Aliases: print print.test.nleqslv
> ### Keywords: print
> 
> ### ** Examples
> 
> dslnex <- function(x) {
+     y <- numeric(2)
+     y[1] <- x[1]^2 + x[2]^2 - 2
+     y[2] <- exp(x[1]-1) + x[2]^3 - 2
+     y
+ }
> xstart <- c(1.5,0.5)
> fstart <- dslnex(xstart)
> z <- testnslv(xstart,dslnex)
> print(z)
Call:
testnslv(x = xstart, fn = dslnex)

Results:
    Method Global termcd Fcnt Jcnt Iter Message     Fnorm
1   Newton  cline      1    8    6    6   Fcrit 1.744e-28
2   Newton  qline      1    8    6    6   Fcrit 1.744e-28
3   Newton  gline      1   12    6    6   Fcrit 6.364e-20
4   Newton pwldog      1    8    6    6   Fcrit 2.629e-23
5   Newton dbldog      1    8    6    6   Fcrit 1.713e-26
6   Newton   hook      1    8    6    6   Fcrit 3.753e-24
7   Newton   none      1    7    7    7   Fcrit 8.470e-21
8  Broyden  cline      1   12    1   10   Fcrit 5.315e-19
9  Broyden  qline      1   12    1   10   Fcrit 5.315e-19
10 Broyden  gline      1   19    1   10   Fcrit 3.919e-17
11 Broyden pwldog      1   13    1   11   Fcrit 4.620e-21
12 Broyden dbldog      1   13    1   11   Fcrit 1.041e-21
13 Broyden   hook      1   13    1   10   Fcrit 1.548e-17
14 Broyden   none      1   13    1   13   Fcrit 8.286e-18
> 
> 
> 
> cleanEx()
> nameEx("searchzeros")
> ### * searchzeros
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: searchZeros
> ### Title: Solve a nonlinear equation system with multiple roots from
> ###   multiple initial estimates
> ### Aliases: searchZeros
> ### Keywords: nonlinear optimize
> 
> ### ** Examples
> 
> # Dennis Schnabel example 6.5.1 page 149 (two solutions)
> set.seed(123)
> dslnex <- function(x) {
+     y <- numeric(2)
+     y[1] <- x[1]^2 + x[2]^2 - 2
+     y[2] <- exp(x[1]-1) + x[2]^3 - 2
+     y
+ }
> xstart <- matrix(runif(50, min=-2, max=2),ncol=2)
> ans <- searchZeros(xstart,dslnex, method="Broyden",global="dbldog")
> ans
$x
           [,1]     [,2]
[1,] -0.7137474 1.220887
[2,]  1.0000000 1.000000

$xfnorm
[1] 1.180429e-20 1.799850e-22

$fnorm
 [1] 1.180429e-20 8.445681e-20 1.844667e-21 1.799850e-22 4.360827e-20
 [6] 4.822898e-19 5.154040e-18 4.267196e-21 8.063623e-18 2.137277e-21
[11] 5.381588e-19 5.259512e-23 1.742763e-18

$idxcvg
 [1]  1  3  6  7  8  9 10 12 15 17 18 19 25

$idxxtol
integer(0)

$idxnocvg
 [1]  2  4  5 11 13 14 16 20 21 22 23 24

$idxfatal
integer(0)

$xstart
           [,1]      [,2]
[1,] -0.8496899 0.8341219
[2,]  0.1124220 1.6091962

$cvgstart
            [,1]       [,2]
 [1,] -0.8496899  0.8341219
 [2,] -0.3640923  0.3765681
 [3,] -1.8177740  1.8520969
 [4,]  0.1124220  1.6091962
 [5,]  1.5696762  0.7628211
 [6,]  0.2057401  1.1818697
 [7,] -0.1735411 -1.9015453
 [8,] -0.1866634  1.0338382
 [9,] -1.5883013 -1.0734969
[10,] -1.0156491 -0.3418147
[11,] -1.8317619 -0.3451027
[12,] -0.6883171 -0.5246182
[13,]  0.6228232  1.4313109

> 
> # more complicated example
> # R. Baker Kearfott, Some tests of Generalized Bisection,
> # ACM Transactions on Methematical Software, Vol. 13, No. 3, 1987, pp 197-220
> 
> # A high-degree polynomial system (section 4.3 Problem 12)
> # There are 12 real roots (and 126 complex roots to this system!)
> 
> hdp <- function(x) {
+     f <- numeric(length(x))
+     f[1] <- 5 * x[1]^9 - 6 * x[1]^5 * x[2]^2 + x[1] * x[2]^4 + 2 * x[1] * x[3]
+     f[2] <- -2 * x[1]^6 * x[2] + 2 * x[1]^2 * x[2]^3 + 2 * x[2] * x[3]
+     f[3] <- x[1]^2 + x[2]^2 - 0.265625
+     f
+ }
> 
> 
> N <- 40 # at least to find all 12 roots
> set.seed(123)
> xstart <- matrix(runif(3*N,min=-1,max=1), N, 3)  # N initial guesses, each of length 3
> ans <- searchZeros(xstart,hdp, method="Broyden",global="dbldog")
> ans$x
               [,1]          [,2]          [,3]
 [1,] -5.153882e-01  1.399731e-09 -1.244560e-02
 [2,] -4.669800e-01 -2.180703e-01 -2.288440e-10
 [3,] -4.669801e-01  2.180702e-01  7.797307e-10
 [4,] -2.798547e-01 -4.327890e-01 -1.418919e-02
 [5,] -2.798547e-01  4.327890e-01 -1.418919e-02
 [6,] -1.689587e-08 -5.153882e-01 -1.484649e-10
 [7,]  3.838786e-09  5.153882e-01 -3.274405e-11
 [8,]  2.798547e-01 -4.327890e-01 -1.418919e-02
 [9,]  2.798547e-01  4.327890e-01 -1.418919e-02
[10,]  4.669800e-01 -2.180703e-01 -2.864444e-10
[11,]  4.669800e-01  2.180704e-01  6.597637e-10
[12,]  5.153882e-01 -3.239028e-09 -1.244560e-02
> 
> 
> 
> cleanEx()
> nameEx("testnslv")
> ### * testnslv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: testnslv
> ### Title: Test different methods for solving with 'nleqslv'
> ### Aliases: testnslv
> ### Keywords: nonlinear optimize
> 
> ### ** Examples
> 
> dslnex <- function(x) {
+     y <- numeric(2)
+     y[1] <- x[1]^2 + x[2]^2 - 2
+     y[2] <- exp(x[1]-1) + x[2]^3 - 2
+     y
+ }
> xstart <- c(0.5,0.5)
> fstart <- dslnex(xstart)
> testnslv(xstart,dslnex)
Call:
testnslv(x = xstart, fn = dslnex)

Results:
    Method Global termcd Fcnt Jcnt Iter Message     Fnorm
1   Newton  cline      1    7    6    6   Fcrit 8.550e-23
2   Newton  qline      1    7    6    6   Fcrit 8.550e-23
3   Newton  gline      1    9    5    5   Fcrit 1.501e-20
4   Newton pwldog      1    7    6    6   Fcrit 4.536e-27
5   Newton dbldog      1    7    6    6   Fcrit 4.536e-27
6   Newton   hook      1    7    6    6   Fcrit 2.450e-23
7   Newton   none      1    8    8    8   Fcrit 6.085e-25
8  Broyden  cline      1   12    1    9   Fcrit 4.297e-17
9  Broyden  qline      1   12    1    9   Fcrit 4.297e-17
10 Broyden  gline      1   14    1   10   Fcrit 4.960e-21
11 Broyden pwldog      1   12    1   10   Fcrit 5.156e-21
12 Broyden dbldog      1   12    1   10   Fcrit 3.958e-20
13 Broyden   hook      1   12    1   10   Fcrit 1.127e-19
14 Broyden   none      1   13    1   13   Fcrit 1.783e-22
> # this will encounter an error
> xstart <- c(2.0,0.5)
> fstart <- dslnex(xstart)
> testnslv(xstart,dslnex)
Error (method=Newton global=none): non-finite value(s) detected in jacobian (row=2,col=1)
Call:
testnslv(x = xstart, fn = dslnex)

Results:
    Method Global termcd Fcnt Jcnt Iter Message     Fnorm
1   Newton  cline      1   11    7    7   Fcrit 4.991e-19
2   Newton  qline      1   10    7    7   Fcrit 2.809e-20
3   Newton  gline      1   17    7    7   Fcrit 6.311e-29
4   Newton pwldog      1    6    5    5   Fcrit 1.543e-18
5   Newton dbldog      1    6    5    5   Fcrit 1.790e-18
6   Newton   hook      1   11    7    7   Fcrit 3.819e-26
7   Newton   none     NA   NA   NA   NA   ERROR        NA
8  Broyden  cline      1   17    1   11   Fcrit 2.900e-18
9  Broyden  qline      1   18    1   13   Fcrit 1.404e-17
10 Broyden  gline      1   25    1   11   Fcrit 4.798e-19
11 Broyden pwldog      1   12    1   10   Fcrit 6.230e-18
12 Broyden dbldog      1   12    1   10   Fcrit 3.239e-18
13 Broyden   hook      1   16    1   12   Fcrit 5.719e-23
14 Broyden   none      4   20    1   20 Maxiter 1.846e-01
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.119 0.007 0.127 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
