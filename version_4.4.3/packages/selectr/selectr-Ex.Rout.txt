
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "selectr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('selectr')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("css_to_xpath")
> ### * css_to_xpath
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: css_to_xpath
> ### Title: Translate a CSS selector to an equivalent XPath expression.
> ### Aliases: css_to_xpath
> 
> ### ** Examples
> 
>   css_to_xpath(".testclass")
[1] "descendant-or-self::*[(@class and contains(concat(' ', normalize-space(@class), ' '), ' testclass '))]"
>   css_to_xpath("#testid", prefix = "")
[1] "*[(@id = 'testid')]"
>   css_to_xpath("#testid .testclass")
[1] "descendant-or-self::*[(@id = 'testid')]/descendant::*[(@class and contains(concat(' ', normalize-space(@class), ' '), ' testclass '))]"
>   css_to_xpath(":checked", translator = "html")
[1] "descendant-or-self::*[((@selected and name(.) = 'option') or (@checked and (name(.) = 'input' or name(.) = 'command')and (@type = 'checkbox' or @type = 'radio')))]"
> 
> 
> 
> cleanEx()
> nameEx("querySelectorAll")
> ### * querySelectorAll
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: querySelectorAll
> ### Title: Find nodes that match a group of CSS selectors in an XML tree.
> ### Aliases: querySelector querySelectorAll querySelectorNS
> ###   querySelectorAllNS
> 
> ### ** Examples
> 
>   hasXML <- require(XML)
Loading required package: XML
>   hasxml2 <- require(xml2)
Loading required package: xml2
> 
>   if (!hasXML && !hasxml2)
+     return() # can't demo without XML or xml2 packages present
> 
>   parseFn <- if (hasXML) xmlParse else read_xml
>   # Demo for working with the XML package (if present, otherwise xml2)
>   exdoc <- parseFn('<a><b class="aclass"/><c id="anid"/></a>')
>   querySelector(exdoc, "#anid")   # Returns the matching node
<c id="anid"/> 
>   querySelector(exdoc, ".aclass") # Returns the matching node
<b class="aclass"/> 
>   querySelector(exdoc, "b, c")    # First match from grouped selection
<b class="aclass"/> 
>   querySelectorAll(exdoc, "b, c") # Grouped selection
[[1]]
<b class="aclass"/> 

[[2]]
<c id="anid"/> 

attr(,"class")
[1] "XMLNodeSet"
>   querySelectorAll(exdoc, "b")    # A list of length one
[[1]]
<b class="aclass"/> 

attr(,"class")
[1] "XMLNodeSet"
>   querySelector(exdoc, "d")       # No match
NULL
>   querySelectorAll(exdoc, "d")    # No match
list()
attr(,"class")
[1] "XMLNodeSet"
> 
>   # Read in a document where two namespaces are being set:
>   # SVG and MathML
>   svgdoc <- parseFn(system.file("demos/svg-mathml.svg",
+                                 package = "selectr"))
>   # Search for <script/> elements in the SVG namespace
>   querySelectorNS(svgdoc, "svg|script",
+                   c(svg = "http://www.w3.org/2000/svg"))
<script type="application/ecmascript" xlink:href="test2.svg.coords.js"/> 
>   querySelectorAllNS(svgdoc, "svg|script",
+                      c(svg = "http://www.w3.org/2000/svg"))
[[1]]
<script type="application/ecmascript" xlink:href="test2.svg.coords.js"/> 

[[2]]
<script type="application/ecmascript" xlink:href="test2.svg.convert.js"/> 

attr(,"class")
[1] "XMLNodeSet"
>   # MathML content is *within* SVG content,
>   # search for <mtext> elements within the MathML namespace
>   querySelectorNS(svgdoc, "math|mtext",
+                   c(math = "http://www.w3.org/1998/Math/MathML"))
<mtext mathvariant="sans-serif">a</mtext> 
>   querySelectorAllNS(svgdoc, "math|mtext",
+                      c(math = "http://www.w3.org/1998/Math/MathML"))
[[1]]
<mtext mathvariant="sans-serif">a</mtext> 

[[2]]
<mtext mathvariant="sans-serif">b</mtext> 

attr(,"class")
[1] "XMLNodeSet"
>   # Search for *both* SVG and MathML content
>   querySelectorAllNS(svgdoc, "svg|script, math|mo",
+                      c(svg = "http://www.w3.org/2000/svg",
+                        math = "http://www.w3.org/1998/Math/MathML"))
[[1]]
<mo>+</mo> 

[[2]]
<script type="application/ecmascript" xlink:href="test2.svg.coords.js"/> 

[[3]]
<script type="application/ecmascript" xlink:href="test2.svg.convert.js"/> 

attr(,"class")
[1] "XMLNodeSet"
> 
>   if (!hasXML)
+     return() # already demo'd xml2
> 
>   # Demo for working with the xml2 package
>   exdoc <- read_xml('<a><b class="aclass"/><c id="anid"/></a>')
>   querySelector(exdoc, "#anid")   # Returns the matching node
{xml_node}
<c id="anid">
>   querySelector(exdoc, ".aclass") # Returns the matching node
{xml_node}
<b class="aclass">
>   querySelector(exdoc, "b, c")    # First match from grouped selection
{xml_node}
<b class="aclass">
>   querySelectorAll(exdoc, "b, c") # Grouped selection
{xml_nodeset (2)}
[1] <b class="aclass"/>
[2] <c id="anid"/>
>   querySelectorAll(exdoc, "b")    # A list of length one
{xml_nodeset (1)}
[1] <b class="aclass"/>
>   querySelector(exdoc, "d")       # No match
NULL
>   querySelectorAll(exdoc, "d")    # No match
{xml_nodeset (0)}
> 
>   # Read in a document where two namespaces are being set:
>   # SVG and MathML
>   svgdoc <- read_xml(system.file("demos/svg-mathml.svg",
+                                  package = "selectr"))
>   # Search for <script/> elements in the SVG namespace
>   querySelectorNS(svgdoc, "svg|script",
+                   c(svg = "http://www.w3.org/2000/svg"))
{xml_node}
<script type="application/ecmascript" href="test2.svg.coords.js">
>   querySelectorAllNS(svgdoc, "svg|script",
+                      c(svg = "http://www.w3.org/2000/svg"))
{xml_nodeset (2)}
[1] <script type="application/ecmascript" xlink:href="test2.svg.coords.js"/>
[2] <script type="application/ecmascript" xlink:href="test2.svg.convert.js"/>
>   # MathML content is *within* SVG content,
>   # search for <mtext> elements within the MathML namespace
>   querySelectorNS(svgdoc, "math|mtext",
+                   c(math = "http://www.w3.org/1998/Math/MathML"))
{xml_node}
<mtext mathvariant="sans-serif">
>   querySelectorAllNS(svgdoc, "math|mtext",
+                      c(math = "http://www.w3.org/1998/Math/MathML"))
{xml_nodeset (2)}
[1] <mtext mathvariant="sans-serif">a</mtext>
[2] <mtext mathvariant="sans-serif">b</mtext>
>   # Search for *both* SVG and MathML content
>   querySelectorAllNS(svgdoc, "svg|script, math|mo",
+                      c(svg = "http://www.w3.org/2000/svg",
+                        math = "http://www.w3.org/1998/Math/MathML"))
{xml_nodeset (3)}
[1] <mo>+</mo>
[2] <script type="application/ecmascript" xlink:href="test2.svg.coords.js"/>
[3] <script type="application/ecmascript" xlink:href="test2.svg.convert.js"/>
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:xml2’, ‘package:XML’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.424 0.032 0.457 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
