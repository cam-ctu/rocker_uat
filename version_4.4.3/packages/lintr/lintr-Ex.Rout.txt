
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "lintr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('lintr')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("T_and_F_symbol_linter")
> ### * T_and_F_symbol_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: T_and_F_symbol_linter
> ### Title: 'T' and 'F' symbol linter
> ### Aliases: T_and_F_symbol_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x <- T; y <- F",
+   linters = T_and_F_symbol_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[T_and_F_symbol_linter] Use TRUE instead of the symbol T.
::warning file=<text>,line=1,col=15::file=<text>,line=1,col=15,[T_and_F_symbol_linter] Use FALSE instead of the symbol F.
> 
> lint(
+   text = "T = 1.2; F = 2.4",
+   linters = T_and_F_symbol_linter()
+ )
::warning file=<text>,line=1,col=2::file=<text>,line=1,col=2,[T_and_F_symbol_linter] Don't use T as a variable name, as it can break code relying on T being TRUE.
::warning file=<text>,line=1,col=11::file=<text>,line=1,col=11,[T_and_F_symbol_linter] Don't use F as a variable name, as it can break code relying on F being FALSE.
> 
> # okay
> lint(
+   text = "x <- c(TRUE, FALSE)",
+   linters = T_and_F_symbol_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "t = 1.2; f = 2.4",
+   linters = T_and_F_symbol_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("absolute_path_linter")
> ### * absolute_path_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: absolute_path_linter
> ### Title: Absolute path linter
> ### Aliases: absolute_path_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'R"--[/blah/file.txt]--"',
+   linters = absolute_path_linter()
+ )
::warning file=<text>,line=1,col=2::file=<text>,line=1,col=2,[absolute_path_linter] Do not use absolute paths.
> 
> # okay
> lint(
+   text = 'R"(./blah)"',
+   linters = absolute_path_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("all_linters")
> ### * all_linters
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all_linters
> ### Title: Create a linter configuration based on all available linters
> ### Aliases: all_linters
> 
> ### ** Examples
> 
> names(all_linters())
  [1] "absolute_path_linter"             "any_duplicated_linter"           
  [3] "any_is_na_linter"                 "assignment_linter"               
  [5] "backport_linter"                  "boolean_arithmetic_linter"       
  [7] "brace_linter"                     "class_equals_linter"             
  [9] "commas_linter"                    "commented_code_linter"           
 [11] "comparison_negation_linter"       "condition_call_linter"           
 [13] "condition_message_linter"         "conjunct_test_linter"            
 [15] "consecutive_assertion_linter"     "consecutive_mutate_linter"       
 [17] "cyclocomp_linter"                 "duplicate_argument_linter"       
 [19] "empty_assignment_linter"          "equals_na_linter"                
 [21] "expect_comparison_linter"         "expect_identical_linter"         
 [23] "expect_length_linter"             "expect_named_linter"             
 [25] "expect_not_linter"                "expect_null_linter"              
 [27] "expect_s3_class_linter"           "expect_s4_class_linter"          
 [29] "expect_true_false_linter"         "expect_type_linter"              
 [31] "fixed_regex_linter"               "for_loop_index_linter"           
 [33] "function_argument_linter"         "function_left_parentheses_linter"
 [35] "function_return_linter"           "if_not_else_linter"              
 [37] "if_switch_linter"                 "ifelse_censor_linter"            
 [39] "implicit_assignment_linter"       "implicit_integer_linter"         
 [41] "indentation_linter"               "infix_spaces_linter"             
 [43] "inner_combine_linter"             "is_numeric_linter"               
 [45] "keyword_quote_linter"             "length_levels_linter"            
 [47] "length_test_linter"               "lengths_linter"                  
 [49] "library_call_linter"              "line_length_linter"              
 [51] "list_comparison_linter"           "literal_coercion_linter"         
 [53] "matrix_apply_linter"              "missing_argument_linter"         
 [55] "missing_package_linter"           "namespace_linter"                
 [57] "nested_ifelse_linter"             "nested_pipe_linter"              
 [59] "nonportable_path_linter"          "nrow_subset_linter"              
 [61] "numeric_leading_zero_linter"      "nzchar_linter"                   
 [63] "object_length_linter"             "object_name_linter"              
 [65] "object_overwrite_linter"          "object_usage_linter"             
 [67] "one_call_pipe_linter"             "outer_negation_linter"           
 [69] "package_hooks_linter"             "paren_body_linter"               
 [71] "paste_linter"                     "pipe_call_linter"                
 [73] "pipe_consistency_linter"          "pipe_continuation_linter"        
 [75] "pipe_return_linter"               "print_linter"                    
 [77] "quotes_linter"                    "redundant_equals_linter"         
 [79] "redundant_ifelse_linter"          "regex_subset_linter"             
 [81] "rep_len_linter"                   "repeat_linter"                   
 [83] "return_linter"                    "routine_registration_linter"     
 [85] "sample_int_linter"                "scalar_in_linter"                
 [87] "semicolon_linter"                 "seq_linter"                      
 [89] "sort_linter"                      "spaces_inside_linter"            
 [91] "spaces_left_parentheses_linter"   "sprintf_linter"                  
 [93] "stopifnot_all_linter"             "string_boundary_linter"          
 [95] "strings_as_factors_linter"        "system_file_linter"              
 [97] "T_and_F_symbol_linter"            "terminal_close_linter"           
 [99] "todo_comment_linter"              "trailing_blank_lines_linter"     
[101] "trailing_whitespace_linter"       "undesirable_function_linter"     
[103] "undesirable_operator_linter"      "unnecessary_concatenation_linter"
[105] "unnecessary_lambda_linter"        "unnecessary_nesting_linter"      
[107] "unnecessary_placeholder_linter"   "unreachable_code_linter"         
[109] "unused_import_linter"             "vector_logic_linter"             
[111] "which_grepl_linter"               "whitespace_linter"               
[113] "yoda_test_linter"                
> 
> 
> 
> 
> cleanEx()
> nameEx("any_duplicated_linter")
> ### * any_duplicated_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: any_duplicated_linter
> ### Title: Require usage of 'anyDuplicated(x) > 0' over
> ###   'any(duplicated(x))'
> ### Aliases: any_duplicated_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "any(duplicated(x), na.rm = TRUE)",
+   linters = any_duplicated_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[any_duplicated_linter] anyDuplicated(x, ...) > 0 is better than any(duplicated(x), ...).
> 
> lint(
+   text = "length(unique(x)) == length(x)",
+   linters = any_duplicated_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[any_duplicated_linter] anyDuplicated(x) == 0L is better than length(unique(x)) == length(x).
> 
> # okay
> lint(
+   text = "anyDuplicated(x)",
+   linters = any_duplicated_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "anyDuplicated(x) == 0L",
+   linters = any_duplicated_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("any_is_na_linter")
> ### * any_is_na_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: any_is_na_linter
> ### Title: Require usage of 'anyNA(x)' over 'any(is.na(x))'
> ### Aliases: any_is_na_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "any(is.na(x), na.rm = TRUE)",
+   linters = any_is_na_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[any_is_na_linter] anyNA(x) is better than any(is.na(x)).
> 
> lint(
+   text = "any(is.na(foo(x)))",
+   linters = any_is_na_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[any_is_na_linter] anyNA(x) is better than any(is.na(x)).
> 
> # okay
> lint(
+   text = "anyNA(x)",
+   linters = any_is_na_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "anyNA(foo(x))",
+   linters = any_is_na_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "any(!is.na(x), na.rm = TRUE)",
+   linters = any_is_na_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("assignment_linter")
> ### * assignment_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: assignment_linter
> ### Title: Assignment linter
> ### Aliases: assignment_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x = mean(x)",
+   linters = assignment_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[assignment_linter] Use one of <-, <<- for assignment, not =.
> 
> code_lines <- "1 -> x\n2 ->> y"
> writeLines(code_lines)
1 -> x
2 ->> y
> lint(
+   text = code_lines,
+   linters = assignment_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[assignment_linter] Use one of <-, <<- for assignment, not ->.
::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,[assignment_linter] Use one of <-, <<- for assignment, not ->>.
> 
> lint(
+   text = "x %<>% as.character()",
+   linters = assignment_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[assignment_linter] Avoid the assignment pipe %<>%; prefer pipes and assignment in separate steps.
> 
> lint(
+   text = "x <- 1",
+   linters = assignment_linter(operator = "=")
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[assignment_linter] Use = for assignment, not <-.
> 
> # okay
> lint(
+   text = "x <- mean(x)",
+   linters = assignment_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "x <- 1\ny <<- 2"
> writeLines(code_lines)
x <- 1
y <<- 2
> lint(
+   text = code_lines,
+   linters = assignment_linter()
+ )
ℹ No lints found.
> 
> # customizing using arguments
> code_lines <- "1 -> x\n2 ->> y"
> writeLines(code_lines)
1 -> x
2 ->> y
> lint(
+   text = code_lines,
+   linters = assignment_linter(allow_right_assign = TRUE)
+ )
Warning: Argument allow_right_assign was deprecated in lintr version 3.2.0. Use "->" in operator instead.
ℹ No lints found.
> 
> lint(
+   text = "x <<- 1",
+   linters = assignment_linter(allow_cascading_assign = FALSE)
+ )
Warning: Argument allow_cascading_assign was deprecated in lintr version 3.2.0. Use "<<-" and/or "->>" in operator instead.
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[assignment_linter] Replace <<- by assigning to a specific environment (with assign() or <-) to avoid hard-to-predict behavior.
> 
> writeLines("foo(bar = \n 1)")
foo(bar = 
 1)
> lint(
+   text = "foo(bar = \n 1)",
+   linters = assignment_linter(allow_trailing = FALSE)
+ )
::warning file=<text>,line=1,col=9::file=<text>,line=1,col=9,[assignment_linter] Assignment = should not be trailing at the end of a line.
> 
> lint(
+   text = "x %<>% as.character()",
+   linters = assignment_linter(allow_pipe_assign = TRUE)
+ )
Warning: Argument allow_pipe_assign was deprecated in lintr version 3.2.0. Use "%<>%" in operator instead.
ℹ No lints found.
> 
> lint(
+   text = "x = 1",
+   linters = assignment_linter(operator = "=")
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("available_linters")
> ### * available_linters
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: available_linters
> ### Title: Get Linter metadata from a package
> ### Aliases: available_linters available_tags
> 
> ### ** Examples
> 
> lintr_linters <- available_linters()
> 
> # If the package doesn't exist or isn't installed, an empty data frame will be returned
> available_linters("does-not-exist")
[1] linter  package tags   
<0 rows> (or 0-length row.names)
> 
> lintr_linters2 <- available_linters(c("lintr", "does-not-exist"))
> identical(lintr_linters, lintr_linters2)
[1] TRUE
> available_tags()
 [1] "best_practices"      "common_mistakes"     "configurable"       
 [4] "consistency"         "correctness"         "default"            
 [7] "deprecated"          "efficiency"          "executing"          
[10] "package_development" "pkg_testthat"        "readability"        
[13] "regex"               "robustness"          "style"              
[16] "tidy_design"        
> 
> 
> 
> cleanEx()
> nameEx("backport_linter")
> ### * backport_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backport_linter
> ### Title: Backport linter
> ### Aliases: backport_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "trimws(x)",
+   linters = backport_linter("3.0.0")
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[backport_linter] trimws (R 3.2.0) is not available for dependency R >= 3.0.0.
> 
> lint(
+   text = "str2lang(x)",
+   linters = backport_linter("3.2.0")
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[backport_linter] str2lang (R 3.6.0) is not available for dependency R >= 3.2.0.
> 
> # okay
> lint(
+   text = "trimws(x)",
+   linters = backport_linter("3.6.0")
+ )
ℹ No lints found.
> 
> lint(
+   text = "str2lang(x)",
+   linters = backport_linter("4.0.0")
+ )
ℹ No lints found.
> 
> lint(
+   text = "str2lang(x)",
+   linters = backport_linter("3.2.0", except = "str2lang")
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("boolean_arithmetic_linter")
> ### * boolean_arithmetic_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boolean_arithmetic_linter
> ### Title: Require usage of boolean operators over equivalent arithmetic
> ### Aliases: boolean_arithmetic_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "length(which(x == y)) == 0L",
+   linters = boolean_arithmetic_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[boolean_arithmetic_linter] Use any() to express logical aggregations. For example, replace length(which(x == y)) == 0 with !any(x == y).
> 
> lint(
+   text = "sum(grepl(pattern, x)) == 0",
+   linters = boolean_arithmetic_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[boolean_arithmetic_linter] Use any() to express logical aggregations. For example, replace length(which(x == y)) == 0 with !any(x == y).
> 
> # okay
> lint(
+   text = "!any(x == y)",
+   linters = boolean_arithmetic_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "!any(grepl(pattern, x))",
+   linters = boolean_arithmetic_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("brace_linter")
> ### * brace_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brace_linter
> ### Title: Brace linter
> ### Aliases: brace_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "f <- function() { 1 }",
+   linters = brace_linter()
+ )
::warning file=<text>,line=1,col=17::file=<text>,line=1,col=17,[brace_linter] Opening curly braces should never go on their own line and should always be followed by a new line.
::warning file=<text>,line=1,col=21::file=<text>,line=1,col=21,[brace_linter] Closing curly-braces should always be on their own line, unless they are followed by an else.
> 
> writeLines("if (TRUE) {\n return(1) }")
if (TRUE) {
 return(1) }
> lint(
+   text = "if (TRUE) {\n return(1) }",
+   linters = brace_linter()
+ )
::warning file=<text>,line=2,col=12::file=<text>,line=2,col=12,[brace_linter] Closing curly-braces should always be on their own line, unless they are followed by an else.
> 
> # okay
> writeLines("f <- function() {\n  1\n}")
f <- function() {
  1
}
> lint(
+   text = "f <- function() {\n  1\n}",
+   linters = brace_linter()
+ )
ℹ No lints found.
> 
> writeLines("if (TRUE) { \n return(1) \n}")
if (TRUE) { 
 return(1) 
}
> lint(
+   text = "if (TRUE) { \n return(1) \n}",
+   linters = brace_linter()
+ )
ℹ No lints found.
> 
> # customizing using arguments
> writeLines("if (TRUE) { return(1) }")
if (TRUE) { return(1) }
> lint(
+   text = "if (TRUE) { return(1) }",
+   linters = brace_linter(allow_single_line = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> cleanEx()
> nameEx("class_equals_linter")
> ### * class_equals_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: class_equals_linter
> ### Title: Block comparison of class with '=='
> ### Aliases: class_equals_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'is_lm <- class(x) == "lm"',
+   linters = class_equals_linter()
+ )
::warning file=<text>,line=1,col=10::file=<text>,line=1,col=10,[class_equals_linter] Use inherits(x, 'class-name'), is.<class> for S3 classes, or is(x, 'S4Class') for S4 classes, instead of comparing class(x) with ==.
> 
> lint(
+   text = 'if ("lm" %in% class(x)) is_lm <- TRUE',
+   linters = class_equals_linter()
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[class_equals_linter] Use inherits(x, 'class-name'), is.<class> for S3 classes, or is(x, 'S4Class') for S4 classes, instead of comparing class(x) with %in%.
> 
> # okay
> lint(
+   text = 'is_lm <- inherits(x, "lm")',
+   linters = class_equals_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'if (inherits(x, "lm")) is_lm <- TRUE',
+   linters = class_equals_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("commas_linter")
> ### * commas_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: commas_linter
> ### Title: Commas linter
> ### Aliases: commas_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "switch(op , x = foo, y = bar)",
+   linters = commas_linter()
+ )
::warning file=<text>,line=1,col=10::file=<text>,line=1,col=10,[commas_linter] Remove spaces before a comma.
> 
> lint(
+   text = "mean(x,trim = 0.2,na.rm = TRUE)",
+   linters = commas_linter()
+ )
::warning file=<text>,line=1,col=8::file=<text>,line=1,col=8,[commas_linter] Put a space after a comma.
::warning file=<text>,line=1,col=19::file=<text>,line=1,col=19,[commas_linter] Put a space after a comma.
> 
> lint(
+   text = "x[ ,, drop=TRUE]",
+   linters = commas_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[commas_linter] Remove spaces before a comma.
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[commas_linter] Put a space after a comma.
> 
> lint(
+   text = "x[1,]",
+   linters = commas_linter()
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[commas_linter] Put a space after a comma.
> 
> # okay
> lint(
+   text = "switch(op, x = foo, y = bar)",
+   linters = commas_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "switch(op, x = , y = bar)",
+   linters = commas_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "mean(x, trim = 0.2, na.rm = TRUE)",
+   linters = commas_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "a[1, , 2, , 3]",
+   linters = commas_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x[1,]",
+   linters = commas_linter(allow_trailing = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("commented_code_linter")
> ### * commented_code_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: commented_code_linter
> ### Title: Commented code linter
> ### Aliases: commented_code_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "# x <- 1",
+   linters = commented_code_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[commented_code_linter] Remove commented code.
> 
> lint(
+   text = "x <- f() # g()",
+   linters = commented_code_linter()
+ )
::warning file=<text>,line=1,col=12::file=<text>,line=1,col=12,[commented_code_linter] Remove commented code.
> 
> lint(
+   text = "x + y # + z[1, 2]",
+   linters = commented_code_linter()
+ )
::warning file=<text>,line=1,col=9::file=<text>,line=1,col=9,[commented_code_linter] Remove commented code.
> 
> # okay
> lint(
+   text = "x <- 1; x <- f(); x + y",
+   linters = commented_code_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "#' x <- 1",
+   linters = commented_code_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("comparison_negation_linter")
> ### * comparison_negation_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: comparison_negation_linter
> ### Title: Block usages like !(x == y) where a direct relational operator
> ###   is appropriate
> ### Aliases: comparison_negation_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "!x == 2",
+   linters = comparison_negation_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[comparison_negation_linter] Use x != y, not !(x == y).
> 
> lint(
+   text = "!(x > 2)",
+   linters = comparison_negation_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[comparison_negation_linter] Use x <= y, not !(x > y).
> 
> # okay
> lint(
+   text = "!(x == 2 & y > 2)",
+   linters = comparison_negation_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "!(x & y)",
+   linters = comparison_negation_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x != 2",
+   linters = comparison_negation_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("condition_call_linter")
> ### * condition_call_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: condition_call_linter
> ### Title: Recommend usage of 'call. = FALSE' in conditions
> ### Aliases: condition_call_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "stop('test')",
+   linters = condition_call_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[condition_call_linter] Use stop(., call. = FALSE) not to display the call in an error message.
> 
> lint(
+   text = "stop('test', call. = TRUE)",
+   linters = condition_call_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[condition_call_linter] Use stop(., call. = FALSE) not to display the call in an error message.
> 
> lint(
+   text = "stop('test', call. = FALSE)",
+   linters = condition_call_linter(display_call = TRUE)
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[condition_call_linter] Use stop(.) to display the call in an error message.
> 
> lint(
+   text = "stop('this is a', 'test', call. = FALSE)",
+   linters = condition_call_linter(display_call = TRUE)
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[condition_call_linter] Use stop(.) to display the call in an error message.
> 
> # okay
> lint(
+   text = "stop('test', call. = FALSE)",
+   linters = condition_call_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "stop('this is a', 'test', call. = FALSE)",
+   linters = condition_call_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "stop('test', call. = TRUE)",
+   linters = condition_call_linter(display_call = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("condition_message_linter")
> ### * condition_message_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: condition_message_linter
> ### Title: Block usage of 'paste()' and 'paste0()' with messaging functions
> ###   using '...'
> ### Aliases: condition_message_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'stop(paste("a string", "another"))',
+   linters = condition_message_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[condition_message_linter] Don't use paste to build stop strings. Instead use the fact that these functions build condition message strings from their input (using "" as a separator). For translatable strings, prefer using gettextf().
> 
> lint(
+   text = 'warning(paste0("a string", " another"))',
+   linters = condition_message_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[condition_message_linter] Don't use paste0 to build warning strings. Instead use the fact that these functions build condition message strings from their input (using "" as a separator). For translatable strings, prefer using gettextf().
> 
> # okay
> lint(
+   text = 'stop("a string", " another")',
+   linters = condition_message_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'warning("a string", " another")',
+   linters = condition_message_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'warning(paste("a string", "another", sep = "-"))',
+   linters = condition_message_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("conjunct_test_linter")
> ### * conjunct_test_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conjunct_test_linter
> ### Title: Force '&&' conditions to be written separately where appropriate
> ### Aliases: conjunct_test_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "expect_true(x && y)",
+   linters = conjunct_test_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[conjunct_test_linter] Write multiple expectations like expect_true(A) and expect_true(B) instead of expect_true(A && B). The latter will produce better error messages in the case of failure.
> 
> lint(
+   text = "expect_false(x || (y && z))",
+   linters = conjunct_test_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[conjunct_test_linter] Write multiple expectations like expect_false(A) and expect_false(B) instead of expect_false(A || B). The latter will produce better error messages in the case of failure.
> 
> lint(
+   text = "stopifnot('x must be a logical scalar' = length(x) == 1 && is.logical(x) && !is.na(x))",
+   linters = conjunct_test_linter(allow_named_stopifnot = FALSE)
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[conjunct_test_linter] Write multiple conditions like stopifnot(A, B) instead of stopifnot(A && B). The latter will produce better error messages in the case of failure.
> 
> lint(
+   text = "dplyr::filter(mtcars, mpg > 20 & vs == 0)",
+   linters = conjunct_test_linter()
+ )
::warning file=<text>,line=1,col=23::file=<text>,line=1,col=23,[conjunct_test_linter] Use dplyr::filter(DF, A, B) instead of dplyr::filter(DF, A & B).
> 
> lint(
+   text = "filter(mtcars, mpg > 20 & vs == 0)",
+   linters = conjunct_test_linter()
+ )
::warning file=<text>,line=1,col=16::file=<text>,line=1,col=16,[conjunct_test_linter] Use dplyr::filter(DF, A, B) instead of dplyr::filter(DF, A & B).
> 
> # okay
> lint(
+   text = "expect_true(x || (y && z))",
+   linters = conjunct_test_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'stopifnot("x must be a logical scalar" = length(x) == 1 && is.logical(x) && !is.na(x))',
+   linters = conjunct_test_linter(allow_named_stopifnot = TRUE)
+ )
ℹ No lints found.
> 
> lint(
+   text = "dplyr::filter(mtcars, mpg > 20 & vs == 0)",
+   linters = conjunct_test_linter(allow_filter = "always")
+ )
ℹ No lints found.
> 
> lint(
+   text = "filter(mtcars, mpg > 20 & vs == 0)",
+   linters = conjunct_test_linter(allow_filter = "not_dplyr")
+ )
ℹ No lints found.
> 
> lint(
+   text = "stats::filter(mtcars$cyl, mtcars$mpg > 20 & mtcars$vs == 0)",
+   linters = conjunct_test_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("consecutive_assertion_linter")
> ### * consecutive_assertion_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: consecutive_assertion_linter
> ### Title: Force consecutive calls to assertions into just one when
> ###   possible
> ### Aliases: consecutive_assertion_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "stopifnot(x); stopifnot(y)",
+   linters = consecutive_assertion_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[consecutive_assertion_linter] Unify consecutive calls to stopifnot().
> 
> lint(
+   text = "assert_that(x); assert_that(y)",
+   linters = consecutive_assertion_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[consecutive_assertion_linter] Unify consecutive calls to assert_that().
> 
> # okay
> lint(
+   text = "stopifnot(x, y)",
+   linters = consecutive_assertion_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'assert_that(x, msg = "Bad x!"); assert_that(y)',
+   linters = consecutive_assertion_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("consecutive_mutate_linter")
> ### * consecutive_mutate_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: consecutive_mutate_linter
> ### Title: Require consecutive calls to mutate() to be combined when
> ###   possible
> ### Aliases: consecutive_mutate_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x %>% mutate(a = 1) %>% mutate(b = 2)",
+   linters = consecutive_mutate_linter()
+ )
::warning file=<text>,line=1,col=25::file=<text>,line=1,col=25,[consecutive_mutate_linter] Unify consecutive calls to mutate().
> 
> # okay
> lint(
+   text = "x %>% mutate(a = 1, b = 2)",
+   linters = consecutive_mutate_linter()
+ )
ℹ No lints found.
> 
> code <- "library(dbplyr)\nx %>% mutate(a = 1) %>% mutate(a = a + 1)"
> writeLines(code)
library(dbplyr)
x %>% mutate(a = 1) %>% mutate(a = a + 1)
> lint(
+   text = code,
+   linters = consecutive_mutate_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("cyclocomp_linter")
> ### * cyclocomp_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cyclocomp_linter
> ### Title: Cyclomatic complexity linter
> ### Aliases: cyclocomp_linter
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("cyclocomp", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # will produce lints
+ lint(
+   text = "if (TRUE) 1 else 2",
+   linters = cyclocomp_linter(complexity_limit = 1L)
+ )
+ 
+ # okay
+ lint(
+   text = "if (TRUE) 1 else 2",
+   linters = cyclocomp_linter(complexity_limit = 2L)
+ )
+ ## Don't show: 
+ }) # examplesIf
> lint(text = "if (TRUE) 1 else 2", linters = cyclocomp_linter(complexity_limit = 1L))
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[cyclocomp_linter] Reduce the cyclomatic complexity of this function from 2 to at most 1.
> lint(text = "if (TRUE) 1 else 2", linters = cyclocomp_linter(complexity_limit = 2L))
ℹ No lints found.
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("default_settings")
> ### * default_settings
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default_settings
> ### Title: Default lintr settings
> ### Aliases: default_settings settings config lintr-config lintr-settings
> ###   .lintr
> ### Keywords: datasets
> 
> ### ** Examples
> 
> # available settings
> names(default_settings)
 [1] "linters"            "encoding"           "exclude"           
 [4] "exclude_next"       "exclude_start"      "exclude_end"       
 [7] "exclude_linter"     "exclude_linter_sep" "exclusions"        
[10] "cache_directory"    "comment_token"      "error_on_lint"     
> 
> # linters included by default
> names(default_settings$linters)
 [1] "assignment_linter"                "brace_linter"                    
 [3] "commas_linter"                    "commented_code_linter"           
 [5] "equals_na_linter"                 "function_left_parentheses_linter"
 [7] "indentation_linter"               "infix_spaces_linter"             
 [9] "line_length_linter"               "object_length_linter"            
[11] "object_name_linter"               "object_usage_linter"             
[13] "paren_body_linter"                "pipe_continuation_linter"        
[15] "quotes_linter"                    "return_linter"                   
[17] "semicolon_linter"                 "seq_linter"                      
[19] "spaces_inside_linter"             "spaces_left_parentheses_linter"  
[21] "T_and_F_symbol_linter"            "trailing_blank_lines_linter"     
[23] "trailing_whitespace_linter"       "vector_logic_linter"             
[25] "whitespace_linter"               
> 
> # default values for a few of the other settings
> default_settings[c(
+   "encoding",
+   "exclude",
+   "exclude_start",
+   "exclude_end",
+   "exclude_linter",
+   "exclude_linter_sep",
+   "exclusions",
+   "error_on_lint"
+ )]
$encoding
[1] "UTF-8"

$exclude
#[[:space:]]*nolint

$exclude_start
#[[:space:]]*nolint start

$exclude_end
#[[:space:]]*nolint end

$exclude_linter
^[[:space:]]*:[[:space:]]*(?<linters>(?:(?:[^,.])+[[:space:]]*,[[:space:]]*)*(?:[^,.])+)\.

$exclude_linter_sep
[[:space:]]*,[[:space:]]*

$exclusions
list()

$error_on_lint
[1] FALSE

> 
> 
> 
> 
> cleanEx()
> nameEx("duplicate_argument_linter")
> ### * duplicate_argument_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: duplicate_argument_linter
> ### Title: Duplicate argument linter
> ### Aliases: duplicate_argument_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "list(x = 1, x = 2)",
+   linters = duplicate_argument_linter()
+ )
::warning file=<text>,line=1,col=13::file=<text>,line=1,col=13,[duplicate_argument_linter] Avoid duplicate arguments in function calls.
> 
> lint(
+   text = "fun(arg = 1, arg = 2)",
+   linters = duplicate_argument_linter()
+ )
::warning file=<text>,line=1,col=14::file=<text>,line=1,col=14,[duplicate_argument_linter] Avoid duplicate arguments in function calls.
> 
> # okay
> lint(
+   text = "list(x = 1, x = 2)",
+   linters = duplicate_argument_linter(except = "list")
+ )
ℹ No lints found.
> 
> lint(
+   text = "df %>% dplyr::mutate(x = a + b, x = x + d)",
+   linters = duplicate_argument_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("empty_assignment_linter")
> ### * empty_assignment_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: empty_assignment_linter
> ### Title: Block assignment of '{}'
> ### Aliases: empty_assignment_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x <- {}",
+   linters = empty_assignment_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[empty_assignment_linter] Assign NULL explicitly or, whenever possible, allocate the empty object with the right type and size.
> 
> writeLines("x = {\n}")
x = {
}
> lint(
+   text = "x = {\n}",
+   linters = empty_assignment_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[empty_assignment_linter] Assign NULL explicitly or, whenever possible, allocate the empty object with the right type and size.
> 
> # okay
> lint(
+   text = "x <- { 3 + 4 }",
+   linters = empty_assignment_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x <- NULL",
+   linters = empty_assignment_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("equals_na_linter")
> ### * equals_na_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: equals_na_linter
> ### Title: Equality check with NA linter
> ### Aliases: equals_na_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x == NA",
+   linters = equals_na_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[equals_na_linter] Use is.na() instead of x == NA
> 
> lint(
+   text = "x != NA",
+   linters = equals_na_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[equals_na_linter] Use is.na() instead of x != NA
> 
> lint(
+   text = "x %in% NA",
+   linters = equals_na_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[equals_na_linter] Use is.na() instead of x %in% NA
> 
> # okay
> lint(
+   text = "is.na(x)",
+   linters = equals_na_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "!is.na(x)",
+   linters = equals_na_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_comparison_linter")
> ### * expect_comparison_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_comparison_linter
> ### Title: Require usage of 'expect_gt(x, y)' over 'expect_true(x > y)'
> ###   (and similar)
> ### Aliases: expect_comparison_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "expect_true(x > y)",
+   linters = expect_comparison_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_comparison_linter] expect_gt(x, y) is better than expect_true(x > y).
> 
> lint(
+   text = "expect_true(x <= y)",
+   linters = expect_comparison_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_comparison_linter] expect_lte(x, y) is better than expect_true(x <= y).
> 
> lint(
+   text = "expect_true(x == (y == 2))",
+   linters = expect_comparison_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_comparison_linter] expect_identical(x, y) is better than expect_true(x == y).
> 
> # okay
> lint(
+   text = "expect_gt(x, y)",
+   linters = expect_comparison_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "expect_lte(x, y)",
+   linters = expect_comparison_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "expect_identical(x, y == 2)",
+   linters = expect_comparison_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "expect_true(x < y | x > y^2)",
+   linters = expect_comparison_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_identical_linter")
> ### * expect_identical_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_identical_linter
> ### Title: Require usage of 'expect_identical(x, y)' where appropriate
> ### Aliases: expect_identical_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "expect_equal(x, y)",
+   linters = expect_identical_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_identical_linter] Use expect_identical(x, y) by default; resort to expect_equal() only when needed, e.g. when setting ignore_attr= or tolerance=.
> 
> lint(
+   text = "expect_true(identical(x, y))",
+   linters = expect_identical_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_identical_linter] Use expect_identical(x, y) by default; resort to expect_equal() only when needed, e.g. when setting ignore_attr= or tolerance=.
> 
> # okay
> lint(
+   text = "expect_identical(x, y)",
+   linters = expect_identical_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "expect_equal(x, y, check.attributes = FALSE)",
+   linters = expect_identical_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "expect_equal(x, y, tolerance = 1e-6)",
+   linters = expect_identical_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_length_linter")
> ### * expect_length_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_length_linter
> ### Title: Require usage of 'expect_length(x, n)' over
> ###   'expect_equal(length(x), n)'
> ### Aliases: expect_length_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "expect_equal(length(x), 2L)",
+   linters = expect_length_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_length_linter] expect_length(x, n) is better than expect_equal(length(x), n)
> 
> # okay
> lint(
+   text = "expect_length(x, 2L)",
+   linters = expect_length_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_lint")
> ### * expect_lint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_lint
> ### Title: Lint expectation
> ### Aliases: expect_lint expect_no_lint
> 
> ### ** Examples
> 
> # no expected lint
> expect_no_lint("a", trailing_blank_lines_linter())
> 
> # one expected lint
> expect_lint("a\n", "trailing blank", trailing_blank_lines_linter())
> expect_lint("a\n", list(message = "trailing blank", line_number = 2), trailing_blank_lines_linter())
> 
> # several expected lints
> expect_lint("a\n\n", list("trailing blank", "trailing blank"), trailing_blank_lines_linter())
> expect_lint(
+   "a\n\n",
+   list(
+     list(message = "trailing blank", line_number = 2),
+     list(message = "trailing blank", line_number = 3)
+   ),
+   trailing_blank_lines_linter()
+ )
> 
> 
> 
> cleanEx()
> nameEx("expect_named_linter")
> ### * expect_named_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_named_linter
> ### Title: Require usage of 'expect_named(x, n)' over
> ###   'expect_equal(names(x), n)'
> ### Aliases: expect_named_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'expect_equal(names(x), "a")',
+   linters = expect_named_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_named_linter] expect_named(x, n) is better than expect_equal(names(x), n)
> 
> # okay
> lint(
+   text = 'expect_named(x, "a")',
+   linters = expect_named_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'expect_equal(colnames(x), "a")',
+   linters = expect_named_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'expect_equal(dimnames(x), "a")',
+   linters = expect_named_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_not_linter")
> ### * expect_not_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_not_linter
> ### Title: Require usage of 'expect_false(x)' over 'expect_true(!x)'
> ### Aliases: expect_not_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "expect_true(!x)",
+   linters = expect_not_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_not_linter] expect_false(x) is better than expect_true(!x), and vice versa.
> 
> # okay
> lint(
+   text = "expect_false(x)",
+   linters = expect_not_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_null_linter")
> ### * expect_null_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_null_linter
> ### Title: Require usage of 'expect_null' for checking 'NULL'
> ### Aliases: expect_null_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "expect_equal(x, NULL)",
+   linters = expect_null_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_null_linter] expect_null(x) is better than expect_equal(x, NULL)
> 
> lint(
+   text = "expect_identical(x, NULL)",
+   linters = expect_null_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_null_linter] expect_null(x) is better than expect_identical(x, NULL)
> 
> lint(
+   text = "expect_true(is.null(x))",
+   linters = expect_null_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_null_linter] expect_null(x) is better than expect_true(is.null(x))
> 
> 
> # okay
> lint(
+   text = "expect_null(x)",
+   linters = expect_null_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_s3_class_linter")
> ### * expect_s3_class_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_s3_class_linter
> ### Title: Require usage of 'expect_s3_class()'
> ### Aliases: expect_s3_class_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'expect_equal(class(x), "data.frame")',
+   linters = expect_s3_class_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_s3_class_linter] expect_s3_class(x, k) is better than expect_equal(class(x), k). Note also expect_s4_class() available for testing S4 objects.
> 
> lint(
+   text = 'expect_equal(class(x), "numeric")',
+   linters = expect_s3_class_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_s3_class_linter] expect_s3_class(x, k) is better than expect_equal(class(x), k). Note also expect_s4_class() available for testing S4 objects.
> 
> # okay
> lint(
+   text = 'expect_s3_class(x, "data.frame")',
+   linters = expect_s3_class_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'expect_type(x, "double")',
+   linters = expect_s3_class_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_s4_class_linter")
> ### * expect_s4_class_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_s4_class_linter
> ### Title: Require usage of 'expect_s4_class(x, k)' over 'expect_true(is(x,
> ###   k))'
> ### Aliases: expect_s4_class_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'expect_true(is(x, "Matrix"))',
+   linters = expect_s4_class_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_s4_class_linter] expect_s4_class(x, k) is better than expect_true(is(x, k)). Note also expect_s3_class() available for testing S3 objects.
> 
> # okay
> lint(
+   text = 'expect_s4_class(x, "Matrix")',
+   linters = expect_s4_class_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_true_false_linter")
> ### * expect_true_false_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_true_false_linter
> ### Title: Require usage of 'expect_true(x)' over 'expect_equal(x, TRUE)'
> ### Aliases: expect_true_false_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "expect_equal(x, TRUE)",
+   linters = expect_true_false_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_true_false_linter] expect_true(x) is better than expect_equal(x, TRUE)
> 
> lint(
+   text = "expect_equal(x, FALSE)",
+   linters = expect_true_false_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_true_false_linter] expect_false(x) is better than expect_equal(x, FALSE)
> 
> # okay
> lint(
+   text = "expect_true(x)",
+   linters = expect_true_false_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "expect_false(x)",
+   linters = expect_true_false_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("expect_type_linter")
> ### * expect_type_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expect_type_linter
> ### Title: Require usage of 'expect_type(x, type)' over
> ###   'expect_equal(typeof(x), type)'
> ### Aliases: expect_type_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'expect_equal(typeof(x), "double")',
+   linters = expect_type_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_type_linter] expect_type(x, t) is better than expect_equal(typeof(x), t)
> 
> lint(
+   text = 'expect_identical(typeof(x), "double")',
+   linters = expect_type_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[expect_type_linter] expect_type(x, t) is better than expect_identical(typeof(x), t)
> 
> # okay
> lint(
+   text = 'expect_type(x, "double")',
+   linters = expect_type_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("fixed_regex_linter")
> ### * fixed_regex_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fixed_regex_linter
> ### Title: Require usage of 'fixed=TRUE' in regular expressions where
> ###   appropriate
> ### Aliases: fixed_regex_linter
> 
> ### ** Examples
> 
> # will produce lints
> code_lines <- 'gsub("\\\\.", "", x)'
> writeLines(code_lines)
gsub("\\.", "", x)
> lint(
+   text = code_lines,
+   linters = fixed_regex_linter()
+ )
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[fixed_regex_linter] Use "." with fixed = TRUE here. This regular expression is static, i.e., its matches can be expressed as a fixed substring expression, which is faster to compute.
> 
> lint(
+   text = 'grepl("a[*]b", x)',
+   linters = fixed_regex_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[fixed_regex_linter] Use "a*b" with fixed = TRUE here. This regular expression is static, i.e., its matches can be expressed as a fixed substring expression, which is faster to compute.
> 
> lint(
+   text = 'grepl("a[*]b", x)',
+   linters = fixed_regex_linter(allow_unescaped = TRUE)
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[fixed_regex_linter] Use "a*b" with fixed = TRUE here. This regular expression is static, i.e., its matches can be expressed as a fixed substring expression, which is faster to compute.
> 
> code_lines <- 'stringr::str_subset(x, "\\\\$")'
> writeLines(code_lines)
stringr::str_subset(x, "\\$")
> lint(
+   text = code_lines,
+   linters = fixed_regex_linter()
+ )
::warning file=<text>,line=1,col=24::file=<text>,line=1,col=24,[fixed_regex_linter] Use stringr::fixed("$") as the pattern here. This regular expression is static, i.e., its matches can be expressed as a fixed substring expression, which is faster to compute.
> 
> lint(
+   text = 'grepl("Munich", address)',
+   linters = fixed_regex_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[fixed_regex_linter] Use "Munich" with fixed = TRUE here. This regular expression is static, i.e., its matches can be expressed as a fixed substring expression, which is faster to compute.
> 
> # okay
> code_lines <- 'gsub("\\\\.", "", x, fixed = TRUE)'
> writeLines(code_lines)
gsub("\\.", "", x, fixed = TRUE)
> lint(
+   text = code_lines,
+   linters = fixed_regex_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'grepl("a*b", x, fixed = TRUE)',
+   linters = fixed_regex_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'stringr::str_subset(x, stringr::fixed("$"))',
+   linters = fixed_regex_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'grepl("Munich", address, fixed = TRUE)',
+   linters = fixed_regex_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'grepl("Munich", address)',
+   linters = fixed_regex_linter(allow_unescaped = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("for_loop_index_linter")
> ### * for_loop_index_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: for_loop_index_linter
> ### Title: Block usage of for loops directly overwriting the indexing
> ###   variable
> ### Aliases: for_loop_index_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "for (x in x) { TRUE }",
+   linters = for_loop_index_linter()
+ )
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[for_loop_index_linter] Don't re-use any sequence symbols as the index symbol in a for loop.
> 
> lint(
+   text = "for (x in foo(x, y)) { TRUE }",
+   linters = for_loop_index_linter()
+ )
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[for_loop_index_linter] Don't re-use any sequence symbols as the index symbol in a for loop.
> 
> # okay
> lint(
+   text = "for (xi in x) { TRUE }",
+   linters = for_loop_index_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "for (col in DF$col) { TRUE }",
+   linters = for_loop_index_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("function_argument_linter")
> ### * function_argument_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: function_argument_linter
> ### Title: Function argument linter
> ### Aliases: function_argument_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "function(y = 1, z = 2, x) {}",
+   linters = function_argument_linter()
+ )
::warning file=<text>,line=1,col=24::file=<text>,line=1,col=24,[function_argument_linter] Arguments without defaults should come before arguments with defaults.
> 
> lint(
+   text = "function(x, y, z = 1, ..., w) {}",
+   linters = function_argument_linter()
+ )
::warning file=<text>,line=1,col=28::file=<text>,line=1,col=28,[function_argument_linter] Arguments without defaults should come before arguments with defaults.
> 
> # okay
> lint(
+   text = "function(x, y = 1, z = 2) {}",
+   linters = function_argument_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "function(x, y, w, z = 1, ...) {}",
+   linters = function_argument_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "function(y = 1, z = 2, x = NULL) {}",
+   linters = function_argument_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "function(x, y, z = 1, ..., w = NULL) {}",
+   linters = function_argument_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("function_left_parentheses_linter")
> ### * function_left_parentheses_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: function_left_parentheses_linter
> ### Title: Function left parentheses linter
> ### Aliases: function_left_parentheses_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "mean (x)",
+   linters = function_left_parentheses_linter()
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[function_left_parentheses_linter] Remove spaces before the left parenthesis in a function call.
> 
> lint(
+   text = "stats::sd(c (x, y, z))",
+   linters = function_left_parentheses_linter()
+ )
::warning file=<text>,line=1,col=12::file=<text>,line=1,col=12,[function_left_parentheses_linter] Remove spaces before the left parenthesis in a function call.
> 
> # okay
> lint(
+   text = "mean(x)",
+   linters = function_left_parentheses_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "stats::sd(c(x, y, z))",
+   linters = function_left_parentheses_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "foo <- function(x) (x + 1)",
+   linters = function_left_parentheses_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("function_return_linter")
> ### * function_return_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: function_return_linter
> ### Title: Lint common mistakes/style issues cropping up from return
> ###   statements
> ### Aliases: function_return_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "foo <- function(x) return(y <- x + 1)",
+   linters = function_return_linter()
+ )
::warning file=<text>,line=1,col=27::file=<text>,line=1,col=27,[function_return_linter] Move the assignment outside of the return() clause, or skip assignment altogether.
> 
> lint(
+   text = "foo <- function(x) return(x <<- x + 1)",
+   linters = function_return_linter()
+ )
::warning file=<text>,line=1,col=27::file=<text>,line=1,col=27,[function_return_linter] Move the assignment outside of the return() clause, or skip assignment altogether.
> 
> writeLines("e <- new.env() \nfoo <- function(x) return(e$val <- x + 1)")
e <- new.env() 
foo <- function(x) return(e$val <- x + 1)
> lint(
+   text = "e <- new.env() \nfoo <- function(x) return(e$val <- x + 1)",
+   linters = function_return_linter()
+ )
::warning file=<text>,line=2,col=27::file=<text>,line=2,col=27,[function_return_linter] Move the assignment outside of the return() clause, or skip assignment altogether.
> 
> # okay
> lint(
+   text = "foo <- function(x) return(x + 1)",
+   linters = function_return_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "
+ foo <- function(x) {
+   x <<- x + 1
+   return(x)
+ }
+ "
> lint(
+   text = code_lines,
+   linters = function_return_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "
+ e <- new.env()
+ foo <- function(x) {
+   e$val <- x + 1
+   return(e$val)
+ }
+ "
> writeLines(code_lines)

e <- new.env()
foo <- function(x) {
  e$val <- x + 1
  return(e$val)
}

> lint(
+   text = code_lines,
+   linters = function_return_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("get_r_string")
> ### * get_r_string
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_r_string
> ### Title: Extract text from 'STR_CONST' nodes
> ### Aliases: get_r_string
> 
> ### ** Examples
> 
> tmp <- tempfile()
> writeLines("c('a', 'b')", tmp)
> expr_as_xml <- get_source_expressions(tmp)$expressions[[1L]]$xml_parsed_content
> writeLines(as.character(expr_as_xml))
<?xml version="1.0" encoding="UTF-8"?>
<exprlist>
  <expr line1="1" col1="1" line2="1" col2="11" start="13" end="23">
    <expr line1="1" col1="1" line2="1" col2="1" start="13" end="13">
      <SYMBOL_FUNCTION_CALL line1="1" col1="1" line2="1" col2="1" start="13" end="13">c</SYMBOL_FUNCTION_CALL>
    </expr>
    <OP-LEFT-PAREN line1="1" col1="2" line2="1" col2="2" start="14" end="14">(</OP-LEFT-PAREN>
    <expr line1="1" col1="3" line2="1" col2="5" start="15" end="17">
      <STR_CONST line1="1" col1="3" line2="1" col2="5" start="15" end="17">'a'</STR_CONST>
    </expr>
    <OP-COMMA line1="1" col1="6" line2="1" col2="6" start="18" end="18">,</OP-COMMA>
    <expr line1="1" col1="8" line2="1" col2="10" start="20" end="22">
      <STR_CONST line1="1" col1="8" line2="1" col2="10" start="20" end="22">'b'</STR_CONST>
    </expr>
    <OP-RIGHT-PAREN line1="1" col1="11" line2="1" col2="11" start="23" end="23">)</OP-RIGHT-PAREN>
  </expr>
</exprlist>

> get_r_string(expr_as_xml, "expr[2]")
[1] "a"
> get_r_string(expr_as_xml, "expr[3]")
[1] "b"
> unlink(tmp)
> 
> # more importantly, extract raw strings correctly
> tmp_raw <- tempfile()
> writeLines("c(R'(a\\b)', R'--[a\\\"\'\"\\b]--')", tmp_raw)
> expr_as_xml_raw <- get_source_expressions(tmp_raw)$expressions[[1L]]$xml_parsed_content
> writeLines(as.character(expr_as_xml_raw))
<?xml version="1.0" encoding="UTF-8"?>
<exprlist>
  <expr line1="1" col1="1" line2="1" col2="29" start="31" end="59">
    <expr line1="1" col1="1" line2="1" col2="1" start="31" end="31">
      <SYMBOL_FUNCTION_CALL line1="1" col1="1" line2="1" col2="1" start="31" end="31">c</SYMBOL_FUNCTION_CALL>
    </expr>
    <OP-LEFT-PAREN line1="1" col1="2" line2="1" col2="2" start="32" end="32">(</OP-LEFT-PAREN>
    <expr line1="1" col1="3" line2="1" col2="10" start="33" end="40">
      <STR_CONST line1="1" col1="3" line2="1" col2="10" start="33" end="40">R'(a\b)'</STR_CONST>
    </expr>
    <OP-COMMA line1="1" col1="11" line2="1" col2="11" start="41" end="41">,</OP-COMMA>
    <expr line1="1" col1="13" line2="1" col2="28" start="43" end="58">
      <STR_CONST line1="1" col1="13" line2="1" col2="28" start="43" end="58">R'--[a\"'"\b]--'</STR_CONST>
    </expr>
    <OP-RIGHT-PAREN line1="1" col1="29" line2="1" col2="29" start="59" end="59">)</OP-RIGHT-PAREN>
  </expr>
</exprlist>

> get_r_string(expr_as_xml_raw, "expr[2]")
[1] "a\\b"
> get_r_string(expr_as_xml_raw, "expr[3]")
[1] "a\\\"'\"\\b"
> unlink(tmp_raw)
> 
> 
> 
> 
> cleanEx()
> nameEx("get_source_expressions")
> ### * get_source_expressions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_source_expressions
> ### Title: Parsed sourced file from a filename
> ### Aliases: get_source_expressions
> 
> ### ** Examples
> 
> tmp <- tempfile()
> writeLines(c("x <- 1", "y <- x + 1"), tmp)
> get_source_expressions(tmp)
$expressions
$expressions[[1]]
$expressions[[1]]$filename
[1] "/tmp/RtmpqZbCrY/file16f105d6f0504"

$expressions[[1]]$line
[1] 1

$expressions[[1]]$column
[1] 1

$expressions[[1]]$lines
       1 
"x <- 1" 

$expressions[[1]]$parsed_content
  line1 col1 line2 col2 id parent       token terminal text
7     1    1     1    6  7      0        expr    FALSE     
1     1    1     1    1  1      3      SYMBOL     TRUE    x
3     1    1     1    1  3      7        expr    FALSE     
2     1    3     1    4  2      7 LEFT_ASSIGN     TRUE   <-
4     1    6     1    6  4      5   NUM_CONST     TRUE    1
5     1    6     1    6  5      7        expr    FALSE     

$expressions[[1]]$xml_parsed_content
{xml_document}
<exprlist>
[1] <expr line1="1" col1="1" line2="1" col2="6" start="12" end="17">\n  <expr ...

$expressions[[1]]$xml_find_function_calls
function (function_names, keep_names = FALSE) 
{
    if (is.null(function_names)) {
        res <- function_call_cache
    }
    else {
        res <- function_call_cache[names(function_call_cache) %in% 
            function_names]
    }
    if (keep_names) 
        res
    else unname(res)
}
<bytecode: 0x55ba2a5d7908>
<environment: 0x55ba2ca0b8e0>

$expressions[[1]]$content
[1] "x <- 1"


$expressions[[2]]
$expressions[[2]]$filename
[1] "/tmp/RtmpqZbCrY/file16f105d6f0504"

$expressions[[2]]$line
[1] 2

$expressions[[2]]$column
[1] 1

$expressions[[2]]$lines
           2 
"y <- x + 1" 

$expressions[[2]]$parsed_content
   line1 col1 line2 col2 id parent       token terminal text
20     2    1     2   10 20      0        expr    FALSE     
10     2    1     2    1 10     12      SYMBOL     TRUE    y
12     2    1     2    1 12     20        expr    FALSE     
11     2    3     2    4 11     20 LEFT_ASSIGN     TRUE   <-
19     2    6     2   10 19     20        expr    FALSE     
13     2    6     2    6 13     15      SYMBOL     TRUE    x
15     2    6     2    6 15     19        expr    FALSE     
14     2    8     2    8 14     19         '+'     TRUE    +
16     2   10     2   10 16     17   NUM_CONST     TRUE    1
17     2   10     2   10 17     19        expr    FALSE     

$expressions[[2]]$xml_parsed_content
{xml_document}
<exprlist>
[1] <expr line1="2" col1="1" line2="2" col2="10" start="23" end="32">\n  <exp ...

$expressions[[2]]$xml_find_function_calls
function (function_names, keep_names = FALSE) 
{
    if (is.null(function_names)) {
        res <- function_call_cache
    }
    else {
        res <- function_call_cache[names(function_call_cache) %in% 
            function_names]
    }
    if (keep_names) 
        res
    else unname(res)
}
<bytecode: 0x55ba2a5d7908>
<environment: 0x55ba2ca142b8>

$expressions[[2]]$content
[1] "y <- x + 1"


$expressions[[3]]
$expressions[[3]]$filename
[1] "/tmp/RtmpqZbCrY/file16f105d6f0504"

$expressions[[3]]$file_lines
           1            2 
    "x <- 1" "y <- x + 1" 
attr(,"terminal_newline")
[1] TRUE

$expressions[[3]]$content
           1            2 
    "x <- 1" "y <- x + 1" 
attr(,"terminal_newline")
[1] TRUE

$expressions[[3]]$full_parsed_content
   line1 col1 line2 col2 id parent       token terminal text
7      1    1     1    6  7      0        expr    FALSE     
1      1    1     1    1  1      3      SYMBOL     TRUE    x
3      1    1     1    1  3      7        expr    FALSE     
2      1    3     1    4  2      7 LEFT_ASSIGN     TRUE   <-
4      1    6     1    6  4      5   NUM_CONST     TRUE    1
5      1    6     1    6  5      7        expr    FALSE     
20     2    1     2   10 20      0        expr    FALSE     
10     2    1     2    1 10     12      SYMBOL     TRUE    y
12     2    1     2    1 12     20        expr    FALSE     
11     2    3     2    4 11     20 LEFT_ASSIGN     TRUE   <-
19     2    6     2   10 19     20        expr    FALSE     
13     2    6     2    6 13     15      SYMBOL     TRUE    x
15     2    6     2    6 15     19        expr    FALSE     
14     2    8     2    8 14     19         '+'     TRUE    +
16     2   10     2   10 16     17   NUM_CONST     TRUE    1
17     2   10     2   10 17     19        expr    FALSE     

$expressions[[3]]$full_xml_parsed_content
{xml_document}
<exprlist>
[1] <expr line1="1" col1="1" line2="1" col2="6" start="12" end="17">\n  <expr ...
[2] <expr line1="2" col1="1" line2="2" col2="10" start="23" end="32">\n  <exp ...

$expressions[[3]]$xml_find_function_calls
function (function_names, keep_names = FALSE) 
{
    if (is.null(function_names)) {
        res <- function_call_cache
    }
    else {
        res <- function_call_cache[names(function_call_cache) %in% 
            function_names]
    }
    if (keep_names) 
        res
    else unname(res)
}
<bytecode: 0x55ba2a5d7908>
<environment: 0x55ba2ca1a750>

$expressions[[3]]$terminal_newline
[1] TRUE



$error
NULL

$lines
           1            2 
    "x <- 1" "y <- x + 1" 
attr(,"terminal_newline")
[1] TRUE

> unlink(tmp)
> 
> 
> 
> cleanEx()
> nameEx("ids_with_token")
> ### * ids_with_token
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ids_with_token
> ### Title: Get parsed IDs by token
> ### Aliases: ids_with_token with_id
> 
> ### ** Examples
> 
> tmp <- tempfile()
> writeLines(c("x <- 1", "y <- x + 1"), tmp)
> source_exprs <- get_source_expressions(tmp)
> ids_with_token(source_exprs$expressions[[1L]], value = "SYMBOL")
[1] 2
> with_id(source_exprs$expressions[[1L]], 2L)
  line1 col1 line2 col2 id parent  token terminal text
1     1    1     1    1  1      3 SYMBOL     TRUE    x
> unlink(tmp)
> 
> 
> 
> 
> cleanEx()
> nameEx("if_not_else_linter")
> ### * if_not_else_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: if_not_else_linter
> ### Title: Block statements like if (!A) x else y
> ### Aliases: if_not_else_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "if (!A) x else y",
+   linters = if_not_else_linter()
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[if_not_else_linter] Prefer `if (A) x else y` to the less-readable `if (!A) y else x` in a simple if/else statement.
> 
> lint(
+   text = "if (!A) x else if (!B) y else z",
+   linters = if_not_else_linter()
+ )
::warning file=<text>,line=1,col=20::file=<text>,line=1,col=20,[if_not_else_linter] Prefer `if (A) x else y` to the less-readable `if (!A) y else x` in a simple if/else statement.
> 
> lint(
+   text = "ifelse(!is_treatment, x, y)",
+   linters = if_not_else_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[if_not_else_linter] Prefer `ifelse(A, x, y)` to the less-readable `ifelse(!A, y, x)`.
> 
> lint(
+   text = "if (!is.null(x)) x else 2",
+   linters = if_not_else_linter(exceptions = character())
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[if_not_else_linter] Prefer `if (A) x else y` to the less-readable `if (!A) y else x` in a simple if/else statement.
> 
> # okay
> lint(
+   text = "if (A) x else y",
+   linters = if_not_else_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "if (!A) x else if (B) z else y",
+   linters = if_not_else_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "ifelse(is_treatment, y, x)",
+   linters = if_not_else_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "if (!is.null(x)) x else 2",
+   linters = if_not_else_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("if_switch_linter")
> ### * if_switch_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: if_switch_linter
> ### Title: Require usage of switch() over repeated if/else blocks
> ### Aliases: if_switch_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "if (x == 'a') 1 else if (x == 'b') 2 else 3",
+   linters = if_switch_linter()
+ )
ℹ No lints found.
> 
> code <- paste(
+   "if (x == 'a') {",
+   "  1",
+   "} else if (x == 'b') {",
+   "  2",
+   "} else if (x == 'c') {",
+   "  y <- x",
+   "  z <- sqrt(match(y, letters))",
+   "  z",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
if (x == 'a') {
  1
} else if (x == 'b') {
  2
} else if (x == 'c') {
  y <- x
  z <- sqrt(match(y, letters))
  z
}
> lint(
+   text = code,
+   linters = if_switch_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[if_switch_linter] Prefer switch() statements over repeated if/else equality tests, e.g., switch(x, a = 1, b = 2) over if (x == "a") 1 else if (x == "b") 2.
> 
> code <- paste(
+   "if (x == 'a') {",
+   "  1",
+   "} else if (x == 'b') {",
+   "  2",
+   "} else if (x == 'c') {",
+   "  y <- x",
+   "  z <- sqrt(",
+   "    match(y, letters)",
+   "  )",
+   "  z",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
if (x == 'a') {
  1
} else if (x == 'b') {
  2
} else if (x == 'c') {
  y <- x
  z <- sqrt(
    match(y, letters)
  )
  z
}
> lint(
+   text = code,
+   linters = if_switch_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[if_switch_linter] Prefer switch() statements over repeated if/else equality tests, e.g., switch(x, a = 1, b = 2) over if (x == "a") 1 else if (x == "b") 2.
> 
> code <- paste(
+   "switch(x,",
+   "  a = {",
+   "    1",
+   "    2",
+   "    3",
+   "  },",
+   "  b = {",
+   "    1",
+   "    2",
+   "  }",
+   ")",
+   sep = "\n"
+ )
> writeLines(code)
switch(x,
  a = {
    1
    2
    3
  },
  b = {
    1
    2
  }
)
> lint(
+   text = code,
+   linters = if_switch_linter(max_branch_lines = 2L)
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[if_switch_linter] Prefer repeated if/else statements over overly-complicated switch() statements.
> 
> # okay
> lint(
+   text = "switch(x, a = 1, b = 2, 3)",
+   linters = if_switch_linter()
+ )
ℹ No lints found.
> 
> # switch() version not as clear
> lint(
+   text = "if (x == 'a') 1 else if (x == 'b' & y == 2) 2 else 3",
+   linters = if_switch_linter()
+ )
ℹ No lints found.
> 
> code <- paste(
+   "if (x == 'a') {",
+   "  1",
+   "} else if (x == 'b') {",
+   "  2",
+   "} else if (x == 'c') {",
+   "  y <- x",
+   "  z <- sqrt(match(y, letters))",
+   "  z",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
if (x == 'a') {
  1
} else if (x == 'b') {
  2
} else if (x == 'c') {
  y <- x
  z <- sqrt(match(y, letters))
  z
}
> lint(
+   text = code,
+   linters = if_switch_linter(max_branch_lines = 2L)
+ )
ℹ No lints found.
> 
> code <- paste(
+   "if (x == 'a') {",
+   "  1",
+   "} else if (x == 'b') {",
+   "  2",
+   "} else if (x == 'c') {",
+   "  y <- x",
+   "  z <- sqrt(",
+   "    match(y, letters)",
+   "  )",
+   "  z",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
if (x == 'a') {
  1
} else if (x == 'b') {
  2
} else if (x == 'c') {
  y <- x
  z <- sqrt(
    match(y, letters)
  )
  z
}
> lint(
+   text = code,
+   linters = if_switch_linter(max_branch_expressions = 2L)
+ )
ℹ No lints found.
> 
> code <- paste(
+   "switch(x,",
+   "  a = {",
+   "    1",
+   "    2",
+   "    3",
+   "  },",
+   "  b = {",
+   "    1",
+   "    2",
+   "  }",
+   ")",
+   sep = "\n"
+ )
> writeLines(code)
switch(x,
  a = {
    1
    2
    3
  },
  b = {
    1
    2
  }
)
> lint(
+   text = code,
+   linters = if_switch_linter(max_branch_lines = 3L)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("ifelse_censor_linter")
> ### * ifelse_censor_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ifelse_censor_linter
> ### Title: Block usage of 'ifelse()' where 'pmin()' or 'pmax()' is more
> ###   appropriate
> ### Aliases: ifelse_censor_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "ifelse(5:1 < pi, 5:1, pi)",
+   linters = ifelse_censor_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[ifelse_censor_linter] pmin(x, y) is preferable to ifelse(x < y, x, y).
> 
> lint(
+   text = "ifelse(x > 0, x, 0)",
+   linters = ifelse_censor_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[ifelse_censor_linter] pmax(x, y) is preferable to ifelse(x > y, x, y).
> 
> # okay
> lint(
+   text = "pmin(5:1, pi)",
+   linters = ifelse_censor_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "pmax(x, 0)",
+   linters = ifelse_censor_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("implicit_assignment_linter")
> ### * implicit_assignment_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: implicit_assignment_linter
> ### Title: Avoid implicit assignment in function calls
> ### Aliases: implicit_assignment_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "if (x <- 1L) TRUE",
+   linters = implicit_assignment_linter()
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[implicit_assignment_linter] Avoid implicit assignments in function calls. For example, instead of `if (x <- 1L) { ... }`, write `x <- 1L; if (x) { ... }`.
> 
> lint(
+   text = "mean(x <- 1:4)",
+   linters = implicit_assignment_linter()
+ )
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[implicit_assignment_linter] Avoid implicit assignments in function calls. For example, instead of `if (x <- 1L) { ... }`, write `x <- 1L; if (x) { ... }`.
> 
> # okay
> lines <- "x <- 1L\nif (x) TRUE"
> writeLines(lines)
x <- 1L
if (x) TRUE
> lint(
+   text = lines,
+   linters = implicit_assignment_linter()
+ )
ℹ No lints found.
> 
> lines <- "x <- 1:4\nmean(x)"
> writeLines(lines)
x <- 1:4
mean(x)
> lint(
+   text = lines,
+   linters = implicit_assignment_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "A && (B <- foo(A))",
+   linters = implicit_assignment_linter(allow_lazy = TRUE)
+ )
ℹ No lints found.
> 
> lines <- c(
+   "if (any(idx <- x < 0)) {",
+   "  stop('negative elements: ', toString(which(idx)))",
+   "}"
+ )
> writeLines(lines)
if (any(idx <- x < 0)) {
  stop('negative elements: ', toString(which(idx)))
}
> lint(
+   text = lines,
+   linters = implicit_assignment_linter(allow_scoped = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("implicit_integer_linter")
> ### * implicit_integer_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: implicit_integer_linter
> ### Title: Implicit integer linter
> ### Aliases: implicit_integer_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x <- 1",
+   linters = implicit_integer_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[implicit_integer_linter] Use 1L or 1.0 to avoid implicit integers.
> 
> lint(
+   text = "x[2]",
+   linters = implicit_integer_linter()
+ )
::warning file=<text>,line=1,col=4::file=<text>,line=1,col=4,[implicit_integer_linter] Use 2L or 2.0 to avoid implicit integers.
> 
> lint(
+   text = "1:10",
+   linters = implicit_integer_linter()
+ )
::warning file=<text>,line=1,col=2::file=<text>,line=1,col=2,[implicit_integer_linter] Use 1L or 1.0 to avoid implicit integers.
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[implicit_integer_linter] Use 10L or 10.0 to avoid implicit integers.
> 
> # okay
> lint(
+   text = "x <- 1.0",
+   linters = implicit_integer_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x <- 1L",
+   linters = implicit_integer_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x[2L]",
+   linters = implicit_integer_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "1:10",
+   linters = implicit_integer_linter(allow_colon = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("indentation_linter")
> ### * indentation_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: indentation_linter
> ### Title: Check that indentation is consistent
> ### Aliases: indentation_linter
> 
> ### ** Examples
> 
> # will produce lints
> code_lines <- "if (TRUE) {\n1 + 1\n}"
> writeLines(code_lines)
if (TRUE) {
1 + 1
}
> lint(
+   text = code_lines,
+   linters = indentation_linter()
+ )
::warning file=<text>,line=2,col=0::file=<text>,line=2,col=0,[indentation_linter] Indentation should be 2 spaces but is 0 spaces.
> 
> code_lines <- "if (TRUE) {\n    1 + 1\n}"
> writeLines(code_lines)
if (TRUE) {
    1 + 1
}
> lint(
+   text = code_lines,
+   linters = indentation_linter()
+ )
::warning file=<text>,line=2,col=4::file=<text>,line=2,col=4,[indentation_linter] Indentation should be 2 spaces but is 4 spaces.
> 
> code_lines <- "map(x, f,\n  additional_arg = 42\n)"
> writeLines(code_lines)
map(x, f,
  additional_arg = 42
)
> lint(
+   text = code_lines,
+   linters = indentation_linter(hanging_indent_style = "always")
+ )
::warning file=<text>,line=2,col=2::file=<text>,line=2,col=2,[indentation_linter] Hanging indent should be 4 spaces but is 2 spaces.
> 
> code_lines <- "map(x, f,\n    additional_arg = 42)"
> writeLines(code_lines)
map(x, f,
    additional_arg = 42)
> lint(
+   text = code_lines,
+   linters = indentation_linter(hanging_indent_style = "never")
+ )
::warning file=<text>,line=2,col=4::file=<text>,line=2,col=4,[indentation_linter] Indentation should be 2 spaces but is 4 spaces.
> 
> # okay
> code_lines <- "map(x, f,\n  additional_arg = 42\n)"
> writeLines(code_lines)
map(x, f,
  additional_arg = 42
)
> lint(
+   text = code_lines,
+   linters = indentation_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "if (TRUE) {\n    1 + 1\n}"
> writeLines(code_lines)
if (TRUE) {
    1 + 1
}
> lint(
+   text = code_lines,
+   linters = indentation_linter(indent = 4)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("infix_spaces_linter")
> ### * infix_spaces_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: infix_spaces_linter
> ### Title: Infix spaces linter
> ### Aliases: infix_spaces_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x<-1L",
+   linters = infix_spaces_linter()
+ )
::warning file=<text>,line=1,col=2::file=<text>,line=1,col=2,[infix_spaces_linter] Put spaces around all infix operators.
> 
> lint(
+   text = "1:4 %>%sum()",
+   linters = infix_spaces_linter()
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[infix_spaces_linter] Put spaces around all infix operators.
> 
> # okay
> lint(
+   text = "x <- 1L",
+   linters = infix_spaces_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "1:4 %>% sum()",
+   linters = infix_spaces_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "
+ ab     <- 1L
+ abcdef <- 2L
+ "
> writeLines(code_lines)

ab     <- 1L
abcdef <- 2L

> lint(
+   text = code_lines,
+   linters = infix_spaces_linter(allow_multiple_spaces = TRUE)
+ )
ℹ No lints found.
> 
> lint(
+   text = "a||b",
+   linters = infix_spaces_linter(exclude_operators = "||")
+ )
ℹ No lints found.
> 
> lint(
+   text = "sum(1:10, na.rm=TRUE)",
+   linters = infix_spaces_linter(exclude_operators = "EQ_SUB")
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("inner_combine_linter")
> ### * inner_combine_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inner_combine_linter
> ### Title: Require 'c()' to be applied before relatively expensive
> ###   vectorized functions
> ### Aliases: inner_combine_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "c(log10(x), log10(y), log10(z))",
+   linters = inner_combine_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[inner_combine_linter] Combine inputs to vectorized functions first to take full advantage of vectorization, e.g., log10(c(x, y)) only runs the more expensive log10() once as compared to c(log10(x), log10(y)).
> 
> # okay
> lint(
+   text = "log10(c(x, y, z))",
+   linters = inner_combine_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "c(log(x, base = 10), log10(x, base = 2))",
+   linters = inner_combine_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("is_lint_level")
> ### * is_lint_level
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_lint_level
> ### Title: Is this an expression- or a file-level source object?
> ### Aliases: is_lint_level
> 
> ### ** Examples
> 
> tmp <- tempfile()
> writeLines(c("x <- 1", "y <- x + 1"), tmp)
> source_exprs <- get_source_expressions(tmp)
> is_lint_level(source_exprs$expressions[[1L]], level = "expression")
[1] TRUE
> is_lint_level(source_exprs$expressions[[1L]], level = "file")
[1] FALSE
> is_lint_level(source_exprs$expressions[[3L]], level = "expression")
[1] FALSE
> is_lint_level(source_exprs$expressions[[3L]], level = "file")
[1] TRUE
> unlink(tmp)
> 
> 
> 
> 
> cleanEx()
> nameEx("is_numeric_linter")
> ### * is_numeric_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_numeric_linter
> ### Title: Redirect 'is.numeric(x) || is.integer(x)' to just use
> ###   'is.numeric(x)'
> ### Aliases: is_numeric_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "is.numeric(y) || is.integer(y)",
+   linters = is_numeric_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[is_numeric_linter] Use `is.numeric(x)` instead of the equivalent `is.numeric(x) || is.integer(x)`. Use is.double(x) to test for objects stored as 64-bit floating point.
> 
> lint(
+   text = 'class(z) %in% c("numeric", "integer")',
+   linters = is_numeric_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[is_numeric_linter] Use is.numeric(x) instead of class(x) %in% c("integer", "numeric"). Use is.double(x) to test for objects stored as 64-bit floating point.
> 
> # okay
> lint(
+   text = "is.numeric(y) || is.factor(y)",
+   linters = is_numeric_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'class(z) %in% c("numeric", "integer", "factor")',
+   linters = is_numeric_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("keyword_quote_linter")
> ### * keyword_quote_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: keyword_quote_linter
> ### Title: Block unnecessary quoting in calls
> ### Aliases: keyword_quote_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'data.frame("a" = 1)',
+   linters = keyword_quote_linter()
+ )
::warning file=<text>,line=1,col=12::file=<text>,line=1,col=12,[keyword_quote_linter] Only quote named arguments to functions if necessary, i.e., if the name is not a valid R symbol (see ?make.names).
> 
> lint(
+   text = "data.frame(`a` = 1)",
+   linters = keyword_quote_linter()
+ )
::warning file=<text>,line=1,col=12::file=<text>,line=1,col=12,[keyword_quote_linter] Only quote named arguments to functions if necessary, i.e., if the name is not a valid R symbol (see ?make.names).
> 
> lint(
+   text = 'my_list$"key"',
+   linters = keyword_quote_linter()
+ )
::warning file=<text>,line=1,col=9::file=<text>,line=1,col=9,[keyword_quote_linter] Only quote targets of extraction with $ if necessary, i.e., if the name is not a valid R symbol (see ?make.names). Use backticks to create non-syntactic names, or use [[ to extract by string.
> 
> lint(
+   text = 's4obj@"key"',
+   linters = keyword_quote_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[keyword_quote_linter] Only quote targets of extraction with @ if necessary, i.e., if the name is not a valid R symbol (see ?make.names). Use backticks to create non-syntactic names, or use slot() to extract by string.
> 
> # okay
> lint(
+   text = "data.frame(`a b` = 1)",
+   linters = keyword_quote_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "my_list$`a b`",
+   linters = keyword_quote_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("length_levels_linter")
> ### * length_levels_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: length_levels_linter
> ### Title: Require usage of nlevels over length(levels(.))
> ### Aliases: length_levels_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "length(levels(x))",
+   linters = length_levels_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[length_levels_linter] nlevels(x) is better than length(levels(x)).
> 
> # okay
> lint(
+   text = "length(c(levels(x), levels(y)))",
+   linters = length_levels_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("length_test_linter")
> ### * length_test_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: length_test_linter
> ### Title: Check for a common mistake where length is applied in the wrong
> ###   place
> ### Aliases: length_test_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "length(x == 0)",
+   linters = length_test_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[length_test_linter] Checking the length of a logical vector is likely a mistake. Did you mean `length(x) == 0`?
> 
> # okay
> lint(
+   text = "length(x) > 0",
+   linters = length_test_linter()
+ )
ℹ No lints found.
> 
> 
> 
> cleanEx()
> nameEx("lengths_linter")
> ### * lengths_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lengths_linter
> ### Title: Require usage of 'lengths()' where possible
> ### Aliases: lengths_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "sapply(x, length)",
+   linters = lengths_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[lengths_linter] Use lengths() to find the length of each element in a list.
> 
> lint(
+   text = "vapply(x, length, integer(1L))",
+   linters = lengths_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[lengths_linter] Use lengths() to find the length of each element in a list.
> 
> lint(
+   text = "purrr::map_int(x, length)",
+   linters = lengths_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[lengths_linter] Use lengths() to find the length of each element in a list.
> 
> # okay
> lint(
+   text = "lengths(x)",
+   linters = lengths_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("library_call_linter")
> ### * library_call_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: library_call_linter
> ### Title: Library call linter
> ### Aliases: library_call_linter
> 
> ### ** Examples
> 
> # will produce lints
> 
> code <- "library(dplyr)\nprint('test')\nlibrary(tidyr)"
> writeLines(code)
library(dplyr)
print('test')
library(tidyr)
> lint(
+   text = code,
+   linters = library_call_linter()
+ )
::warning file=<text>,line=3,col=1::file=<text>,line=3,col=1,[library_call_linter] Move all library calls to the top of the script.
> 
> lint(
+   text = "library('dplyr', character.only = TRUE)",
+   linters = library_call_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[library_call_linter] Use symbols in library calls to avoid the need for 'character.only'.
> 
> code <- paste(
+   "pkg <- c('dplyr', 'tibble')",
+   "sapply(pkg, library, character.only = TRUE)",
+   sep = "\n"
+ )
> writeLines(code)
pkg <- c('dplyr', 'tibble')
sapply(pkg, library, character.only = TRUE)
> lint(
+   text = code,
+   linters = library_call_linter()
+ )
::warning file=<text>,line=2,col=1::file=<text>,line=2,col=1,[library_call_linter] Call library() directly, not vectorized with sapply().
> 
> code <- "suppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))"
> writeLines(code)
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
> lint(
+   text = code,
+   linters = library_call_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[library_call_linter] Unify consecutive calls to suppressMessages(). You can do so by writing all of the calls in one braced expression like suppressMessages({...}).
> 
> # okay
> code <- "library(dplyr)\nprint('test')"
> writeLines(code)
library(dplyr)
print('test')
> lint(
+   text = code,
+   linters = library_call_linter()
+ )
ℹ No lints found.
> 
> code <- "# comment\nlibrary(dplyr)"
> lint(
+   text = code,
+   linters = library_call_linter()
+ )
ℹ No lints found.
> 
> code <- paste(
+   "foo <- function(pkg) {",
+   "  sapply(pkg, library, character.only = TRUE)",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
foo <- function(pkg) {
  sapply(pkg, library, character.only = TRUE)
}
> lint(
+   text = code,
+   linters = library_call_linter()
+ )
ℹ No lints found.
> 
> code <- "suppressMessages({\n  library(dplyr)\n  library(tidyr)\n})"
> writeLines(code)
suppressMessages({
  library(dplyr)
  library(tidyr)
})
> lint(
+   text = code,
+   linters = library_call_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("line_length_linter")
> ### * line_length_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: line_length_linter
> ### Title: Line length linter
> ### Aliases: line_length_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = strrep("x", 23L),
+   linters = line_length_linter(length = 20L)
+ )
::warning file=<text>,line=1,col=21::file=<text>,line=1,col=21,[line_length_linter] Lines should not be more than 20 characters. This line is 23 characters.
> 
> # okay
> lint(
+   text = strrep("x", 21L),
+   linters = line_length_linter(length = 40L)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("lint")
> ### * lint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lint
> ### Title: Lint a file, directory, or package
> ### Aliases: lint lint_dir lint_package
> 
> ### ** Examples
> 
> # linting inline-code
> lint("a = 123\n")
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[assignment_linter] Use one of <-, <<- for assignment, not =.
> lint(text = "a = 123")
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[assignment_linter] Use one of <-, <<- for assignment, not =.
> 
> # linting a file
> f <- tempfile()
> writeLines("a=1", f)
> lint(f)
::warning file=/tmp/RtmpqZbCrY/file16f101e168e63,line=1,col=2::file=/tmp/RtmpqZbCrY/file16f101e168e63,line=1,col=2,[assignment_linter] Use one of <-, <<- for assignment, not =.
::warning file=/tmp/RtmpqZbCrY/file16f101e168e63,line=1,col=2::file=/tmp/RtmpqZbCrY/file16f101e168e63,line=1,col=2,[infix_spaces_linter] Put spaces around all infix operators.
> unlink(f)
> 
> if (FALSE) {
+   lint_dir()
+ 
+   lint_dir(
+     linters = list(semicolon_linter()),
+     exclusions = list(
+       "inst/doc/creating_linters.R" = 1,
+       "inst/example/bad.R",
+       "renv"
+     )
+   )
+ }
> if (FALSE) {
+   lint_package()
+ 
+   lint_package(
+     linters = linters_with_defaults(semicolon_linter = semicolon_linter()),
+     exclusions = list("inst/doc/creating_linters.R" = 1, "inst/example/bad.R")
+   )
+ }
> 
> 
> 
> cleanEx()
> nameEx("linters_with_defaults")
> ### * linters_with_defaults
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linters_with_defaults
> ### Title: Create a linter configuration based on defaults
> ### Aliases: linters_with_defaults
> 
> ### ** Examples
> 
> # When using interactively you will usually pass the result onto `lint` or `lint_package()`
> f <- tempfile()
> writeLines("my_slightly_long_variable_name <- 2.3", f)
> lint(f, linters = linters_with_defaults(line_length_linter = line_length_linter(120L)))
ℹ No lints found.
> unlink(f)
> 
> # the default linter list with a different line length cutoff
> my_linters <- linters_with_defaults(line_length_linter = line_length_linter(120L))
> 
> # omit the argument name if you are just using different arguments
> my_linters <- linters_with_defaults(defaults = my_linters, object_name_linter("camelCase"))
> 
> # remove assignment checks (with NULL), add absolute path checks
> my_linters <- linters_with_defaults(
+   defaults = my_linters,
+   assignment_linter = NULL,
+   absolute_path_linter()
+ )
> 
> # checking the included linters
> names(my_linters)
 [1] "absolute_path_linter"             "brace_linter"                    
 [3] "commas_linter"                    "commented_code_linter"           
 [5] "equals_na_linter"                 "function_left_parentheses_linter"
 [7] "indentation_linter"               "infix_spaces_linter"             
 [9] "line_length_linter"               "object_length_linter"            
[11] "object_name_linter"               "object_usage_linter"             
[13] "paren_body_linter"                "pipe_continuation_linter"        
[15] "quotes_linter"                    "return_linter"                   
[17] "semicolon_linter"                 "seq_linter"                      
[19] "spaces_inside_linter"             "spaces_left_parentheses_linter"  
[21] "T_and_F_symbol_linter"            "trailing_blank_lines_linter"     
[23] "trailing_whitespace_linter"       "vector_logic_linter"             
[25] "whitespace_linter"               
> 
> 
> 
> 
> cleanEx()
> nameEx("linters_with_tags")
> ### * linters_with_tags
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linters_with_tags
> ### Title: Create a tag-based linter configuration
> ### Aliases: linters_with_tags
> 
> ### ** Examples
> 
> # `linters_with_defaults()` and `linters_with_tags("default")` are the same:
> all.equal(linters_with_defaults(), linters_with_tags("default"))
[1] TRUE
> 
> # Get all linters useful for package development
> linters <- linters_with_tags(tags = c("package_development", "style"))
> names(linters)
 [1] "assignment_linter"                "backport_linter"                 
 [3] "brace_linter"                     "commas_linter"                   
 [5] "commented_code_linter"            "condition_call_linter"           
 [7] "conjunct_test_linter"             "consecutive_assertion_linter"    
 [9] "cyclocomp_linter"                 "expect_comparison_linter"        
[11] "expect_identical_linter"          "expect_length_linter"            
[13] "expect_named_linter"              "expect_not_linter"               
[15] "expect_null_linter"               "expect_s3_class_linter"          
[17] "expect_s4_class_linter"           "expect_true_false_linter"        
[19] "expect_type_linter"               "function_argument_linter"        
[21] "function_left_parentheses_linter" "implicit_assignment_linter"      
[23] "implicit_integer_linter"          "indentation_linter"              
[25] "infix_spaces_linter"              "keyword_quote_linter"            
[27] "library_call_linter"              "line_length_linter"              
[29] "numeric_leading_zero_linter"      "object_length_linter"            
[31] "object_name_linter"               "object_usage_linter"             
[33] "one_call_pipe_linter"             "package_hooks_linter"            
[35] "paren_body_linter"                "pipe_call_linter"                
[37] "pipe_consistency_linter"          "pipe_continuation_linter"        
[39] "quotes_linter"                    "repeat_linter"                   
[41] "return_linter"                    "semicolon_linter"                
[43] "spaces_inside_linter"             "spaces_left_parentheses_linter"  
[45] "T_and_F_symbol_linter"            "todo_comment_linter"             
[47] "trailing_blank_lines_linter"      "trailing_whitespace_linter"      
[49] "undesirable_function_linter"      "undesirable_operator_linter"     
[51] "unnecessary_concatenation_linter" "whitespace_linter"               
[53] "yoda_test_linter"                
> 
> # Get all linters tagged as "default" from lintr and mypkg
> if (FALSE) {
+   linters_with_tags("default", packages = c("lintr", "mypkg"))
+ }
> 
> 
> 
> cleanEx()
> nameEx("list_comparison_linter")
> ### * list_comparison_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: list_comparison_linter
> ### Title: Block usage of comparison operators with known-list() functions
> ###   like lapply
> ### Aliases: list_comparison_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "lapply(x, sum) > 10",
+   linters = list_comparison_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[list_comparison_linter] The output of lapply(), a list(), is being coerced for comparison by `>`. Instead, use a mapper that generates a vector with the correct type directly, for example vapply(x, FUN, character(1L)) if the output is a string.
> 
> # okay
> lint(
+   text = "unlist(lapply(x, sum)) > 10",
+   linters = list_comparison_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("literal_coercion_linter")
> ### * literal_coercion_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: literal_coercion_linter
> ### Title: Require usage of correctly-typed literals over literal coercions
> ### Aliases: literal_coercion_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "int(1)",
+   linters = literal_coercion_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[literal_coercion_linter] Use 1L instead of int(1), i.e., use literals directly where possible, instead of coercion.
> 
> lint(
+   text = "as.character(NA)",
+   linters = literal_coercion_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[literal_coercion_linter] Use NA_character_ instead of as.character(NA), i.e., use literals directly where possible, instead of coercion.
> 
> lint(
+   text = "rlang::lgl(1L)",
+   linters = literal_coercion_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[literal_coercion_linter] Use TRUE instead of rlang::lgl(1L), i.e., use literals directly where possible, instead of coercion.
> 
> # okay
> lint(
+   text = "1L",
+   linters = literal_coercion_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "NA_character_",
+   linters = literal_coercion_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "TRUE",
+   linters = literal_coercion_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("make_linter_from_xpath")
> ### * make_linter_from_xpath
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_linter_from_xpath
> ### Title: Create a linter from an XPath
> ### Aliases: make_linter_from_xpath make_linter_from_function_xpath
> 
> ### ** Examples
> 
> number_linter <- make_linter_from_xpath("//NUM_CONST", "This is a number.")
> lint(text = "1 + 2", linters = number_linter())
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[number_linter] This is a number.
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[number_linter] This is a number.
> 
> 
> 
> cleanEx()
> nameEx("matrix_apply_linter")
> ### * matrix_apply_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matrix_apply_linter
> ### Title: Require usage of 'colSums(x)' or 'rowSums(x)' over 'apply(x, .,
> ###   sum)'
> ### Aliases: matrix_apply_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "apply(x, 1, sum)",
+   linters = matrix_apply_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[matrix_apply_linter] Use rowSums(x) rather than apply(x, 1, sum)
> 
> lint(
+   text = "apply(x, 2, sum)",
+   linters = matrix_apply_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[matrix_apply_linter] Use rowSums(colSums(x)) or colSums(x) if x has 2 dimensions rather than apply(x, 2, sum)
> 
> lint(
+   text = "apply(x, 2, sum, na.rm = TRUE)",
+   linters = matrix_apply_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[matrix_apply_linter] Use rowSums(colSums(x, na.rm = TRUE)) or colSums(x, na.rm = TRUE) if x has 2 dimensions rather than apply(x, 2, sum, na.rm = TRUE)
> 
> lint(
+   text = "apply(x, 2:4, sum)",
+   linters = matrix_apply_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[matrix_apply_linter] Use rowSums(colSums(x), dims = 3) or colSums(x) if x has 4 dimensions rather than apply(x, 2:4, sum)
> 
> 
> 
> 
> cleanEx()
> nameEx("missing_argument_linter")
> ### * missing_argument_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: missing_argument_linter
> ### Title: Missing argument linter
> ### Aliases: missing_argument_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'tibble(x = "a", )',
+   linters = missing_argument_linter()
+ )
::warning file=<text>,line=1,col=17::file=<text>,line=1,col=17,[missing_argument_linter] Missing argument 2 in function call.
> 
> # okay
> lint(
+   text = 'tibble(x = "a")',
+   linters = missing_argument_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'tibble(x = "a", )',
+   linters = missing_argument_linter(except = "tibble")
+ )
ℹ No lints found.
> 
> lint(
+   text = 'tibble(x = "a", )',
+   linters = missing_argument_linter(allow_trailing = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("missing_package_linter")
> ### * missing_package_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: missing_package_linter
> ### Title: Missing package linter
> ### Aliases: missing_package_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "library(xyzxyz)",
+   linters = missing_package_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[missing_package_linter] Package 'xyzxyz' is not installed.
> 
> # okay
> lint(
+   text = "library(stats)",
+   linters = missing_package_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("modify_defaults")
> ### * modify_defaults
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: modify_defaults
> ### Title: Modify lintr defaults
> ### Aliases: modify_defaults
> 
> ### ** Examples
> 
> # custom list of undesirable functions:
> #    remove `sapply` (using `NULL`)
> #    add `cat` (with an accompanying message),
> #    add `print` (unnamed, i.e. with no accompanying message)
> #    add `source` (as taken from `all_undesirable_functions`)
> my_undesirable_functions <- modify_defaults(
+   defaults = default_undesirable_functions,
+   sapply = NULL, "cat" = "No cat allowed", "print", all_undesirable_functions[["source"]]
+ )
> 
> # list names of functions specified as undesirable
> names(my_undesirable_functions)
 [1] ".libPaths"     "attach"        "browser"       "cat"          
 [5] "debug"         "debugcall"     "debugonce"     "detach"       
 [9] "library"       "mapply"        "options"       "par"          
[13] "print"         "require"       "setwd"         "sink"         
[17] "source"        "structure"     "Sys.setenv"    "Sys.setlocale"
[21] "trace"         "undebug"       "untrace"      
> 
> 
> 
> cleanEx()
> nameEx("namespace_linter")
> ### * namespace_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: namespace_linter
> ### Title: Namespace linter
> ### Aliases: namespace_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "xyzxyz::sd(c(1, 2, 3))",
+   linters = namespace_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[namespace_linter] Package 'xyzxyz' is not installed.
> 
> lint(
+   text = "stats::ssd(c(1, 2, 3))",
+   linters = namespace_linter()
+ )
::warning file=<text>,line=1,col=8::file=<text>,line=1,col=8,[namespace_linter] 'ssd' is not exported from {stats}.
> 
> # okay
> lint(
+   text = "stats::sd(c(1, 2, 3))",
+   linters = namespace_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "stats::ssd(c(1, 2, 3))",
+   linters = namespace_linter(check_exports = FALSE)
+ )
ℹ No lints found.
> 
> lint(
+   text = "stats:::ssd(c(1, 2, 3))",
+   linters = namespace_linter(check_nonexports = FALSE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("nested_ifelse_linter")
> ### * nested_ifelse_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nested_ifelse_linter
> ### Title: Block usage of nested 'ifelse()' calls
> ### Aliases: nested_ifelse_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'ifelse(x == "a", 1L, ifelse(x == "b", 2L, 3L))',
+   linters = nested_ifelse_linter()
+ )
::warning file=<text>,line=1,col=22::file=<text>,line=1,col=22,[nested_ifelse_linter] Don't use nested ifelse() calls; instead, try (1) data.table::fcase; (2) dplyr::case_when; or (3) using a lookup table.
> 
> # okay
> lint(
+   text = 'dplyr::case_when(x == "a" ~ 1L, x == "b" ~ 2L, TRUE ~ 3L)',
+   linters = nested_ifelse_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'data.table::fcase(x == "a", 1L, x == "b", 2L, default = 3L)',
+   linters = nested_ifelse_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("nested_pipe_linter")
> ### * nested_pipe_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nested_pipe_linter
> ### Title: Block usage of pipes nested inside other calls
> ### Aliases: nested_pipe_linter
> 
> ### ** Examples
> 
> # will produce lints
> code <- "df1 %>%\n  inner_join(df2 %>%\n    select(a, b)\n  )"
> writeLines(code)
df1 %>%
  inner_join(df2 %>%
    select(a, b)
  )
> lint(
+   text = code,
+   linters = nested_pipe_linter()
+ )
::warning file=<text>,line=2,col=14::file=<text>,line=2,col=14,[nested_pipe_linter] Don't nest pipes inside other calls.
> 
> lint(
+   text = "df1 %>% inner_join(df2 %>% select(a, b))",
+   linters = nested_pipe_linter(allow_inline = FALSE)
+ )
::warning file=<text>,line=1,col=20::file=<text>,line=1,col=20,[nested_pipe_linter] Don't nest pipes inside other calls.
> 
> lint(
+   text = "tryCatch(x %>% filter(grp == 'a'), error = identity)",
+   linters = nested_pipe_linter(allow_outer_calls = character())
+ )
ℹ No lints found.
> 
> # okay
> lint(
+   text = "df1 %>% inner_join(df2 %>% select(a, b))",
+   linters = nested_pipe_linter()
+ )
ℹ No lints found.
> 
> code <- "df1 %>%\n  inner_join(df2 %>%\n    select(a, b)\n  )"
> writeLines(code)
df1 %>%
  inner_join(df2 %>%
    select(a, b)
  )
> lint(
+   text = code,
+   linters = nested_pipe_linter(allow_outer_calls = "inner_join")
+ )
ℹ No lints found.
> 
> lint(
+   text = "tryCatch(x %>% filter(grp == 'a'), error = identity)",
+   linters = nested_pipe_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("nonportable_path_linter")
> ### * nonportable_path_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nonportable_path_linter
> ### Title: Non-portable path linter
> ### Aliases: nonportable_path_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "'abcdefg/hijklmnop/qrst/uv/wxyz'",
+   linters = nonportable_path_linter()
+ )
::warning file=<text>,line=1,col=2::file=<text>,line=1,col=2,[nonportable_path_linter] Use file.path() to construct portable file paths.
> 
> # okay
> lint(
+   text = "file.path('abcdefg', 'hijklmnop', 'qrst', 'uv', 'wxyz')",
+   linters = nonportable_path_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("nrow_subset_linter")
> ### * nrow_subset_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nrow_subset_linter
> ### Title: Block usage of 'nrow(subset(x, .))'
> ### Aliases: nrow_subset_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "nrow(subset(x, is_treatment))",
+   linters = nrow_subset_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[nrow_subset_linter] Use arithmetic to count the number of rows satisfying a condition, rather than fully subsetting the data.frame and counting the resulting rows. For example, replace nrow(subset(x, is_treatment)) with sum(x$is_treatment). NB: use na.rm = TRUE if `is_treatment` has missing values.
> 
> lint(
+   text = "nrow(filter(x, is_treatment))",
+   linters = nrow_subset_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[nrow_subset_linter] Use arithmetic to count the number of rows satisfying a condition, rather than fully subsetting the data.frame and counting the resulting rows. For example, replace nrow(subset(x, is_treatment)) with sum(x$is_treatment). NB: use na.rm = TRUE if `is_treatment` has missing values.
> 
> lint(
+   text = "x %>% filter(x, is_treatment) %>% nrow()",
+   linters = nrow_subset_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[nrow_subset_linter] Use arithmetic to count the number of rows satisfying a condition, rather than fully subsetting the data.frame and counting the resulting rows. For example, replace nrow(subset(x, is_treatment)) with sum(x$is_treatment). NB: use na.rm = TRUE if `is_treatment` has missing values.
> 
> # okay
> lint(
+   text = "with(x, sum(is_treatment, na.rm = TRUE))",
+   linters = nrow_subset_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("numeric_leading_zero_linter")
> ### * numeric_leading_zero_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numeric_leading_zero_linter
> ### Title: Require usage of a leading zero in all fractional numerics
> ### Aliases: numeric_leading_zero_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x <- .1",
+   linters = numeric_leading_zero_linter()
+ )
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[numeric_leading_zero_linter] Include the leading zero for fractional numeric constants.
> 
> lint(
+   text = "x <- -.1",
+   linters = numeric_leading_zero_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[numeric_leading_zero_linter] Include the leading zero for fractional numeric constants.
> 
> # okay
> lint(
+   text = "x <- 0.1",
+   linters = numeric_leading_zero_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x <- -0.1",
+   linters = numeric_leading_zero_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("nzchar_linter")
> ### * nzchar_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nzchar_linter
> ### Title: Require usage of nzchar where appropriate
> ### Aliases: nzchar_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x[x == '']",
+   linters = nzchar_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[nzchar_linter] Use !nzchar(x) instead of x == "". Note that unlike nzchar(), EQ coerces to character, so you'll have to use as.character() if x is a factor. Whenever missing data is possible, please take care to use nzchar(., keepNA = TRUE); nzchar(NA) is TRUE by default.
> 
> lint(
+   text = "x[nchar(x) > 0]",
+   linters = nzchar_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[nzchar_linter] Use nzchar(x) instead of nchar(x) > 0. Whenever missing data is possible, please take care to use nzchar(., keepNA = TRUE); nzchar(NA) is TRUE by default.
> 
> # okay
> lint(
+   text = "x[!nzchar(x, keepNA = TRUE)]",
+   linters = nzchar_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x[nzchar(x, keepNA = TRUE)]",
+   linters = nzchar_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("object_length_linter")
> ### * object_length_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: object_length_linter
> ### Title: Object length linter
> ### Aliases: object_length_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "very_very_long_variable_name <- 1L",
+   linters = object_length_linter(length = 10L)
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[object_length_linter] Variable and function names should not be longer than 10 characters.
> 
> # okay
> lint(
+   text = "very_very_long_variable_name <- 1L",
+   linters = object_length_linter(length = 30L)
+ )
ℹ No lints found.
> 
> lint(
+   text = "var <- 1L",
+   linters = object_length_linter(length = 10L)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("object_name_linter")
> ### * object_name_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: object_name_linter
> ### Title: Object name linter
> ### Aliases: object_name_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "my_var <- 1L",
+   linters = object_name_linter(styles = "CamelCase")
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[object_name_linter] Variable and function name style should match CamelCase.
> 
> lint(
+   text = "xYz <- 1L",
+   linters = object_name_linter(styles = c("UPPERCASE", "lowercase"))
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[object_name_linter] Variable and function name style should match UPPERCASE or lowercase.
> 
> lint(
+   text = "MyVar <- 1L",
+   linters = object_name_linter(styles = "dotted.case")
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[object_name_linter] Variable and function name style should match dotted.case.
> 
> lint(
+   text = "asd <- 1L",
+   linters = object_name_linter(regexes = c(my_style = "F$", "f$"))
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[object_name_linter] Variable and function name style should match my_style or /f$/.
> 
> # okay
> lint(
+   text = "my_var <- 1L",
+   linters = object_name_linter(styles = "snake_case")
+ )
ℹ No lints found.
> 
> lint(
+   text = "xyz <- 1L",
+   linters = object_name_linter(styles = "lowercase")
+ )
ℹ No lints found.
> 
> lint(
+   text = "my.var <- 1L; myvar <- 2L",
+   linters = object_name_linter(styles = c("dotted.case", "lowercase"))
+ )
ℹ No lints found.
> 
> lint(
+   text = "asdf <- 1L; asdF <- 1L",
+   linters = object_name_linter(regexes = c(my_style = "F$", "f$"))
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("object_overwrite_linter")
> ### * object_overwrite_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: object_overwrite_linter
> ### Title: Block assigning any variables whose name clashes with a 'base' R
> ###   function
> ### Aliases: object_overwrite_linter
> 
> ### ** Examples
> 
> # will produce lints
> code <- "function(x) {\n  data <- x\n  data\n}"
> writeLines(code)
function(x) {
  data <- x
  data
}
> lint(
+   text = code,
+   linters = object_overwrite_linter()
+ )
::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,[object_overwrite_linter] 'data' is an exported object from package 'utils'. Avoid re-using such symbols.
> 
> code <- "function(x) {\n  lint <- 'fun'\n  lint\n}"
> writeLines(code)
function(x) {
  lint <- 'fun'
  lint
}
> lint(
+   text = code,
+   linters = object_overwrite_linter(packages = "lintr")
+ )
::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,[object_overwrite_linter] 'lint' is an exported object from package 'lintr'. Avoid re-using such symbols.
> 
> # okay
> code <- "function(x) {\n  data('mtcars')\n}"
> writeLines(code)
function(x) {
  data('mtcars')
}
> lint(
+   text = code,
+   linters = object_overwrite_linter()
+ )
ℹ No lints found.
> 
> code <- "function(x) {\n  data <- x\n  data\n}"
> writeLines(code)
function(x) {
  data <- x
  data
}
> lint(
+   text = code,
+   linters = object_overwrite_linter(packages = "base")
+ )
ℹ No lints found.
> 
> # names in function signatures are ignored
> lint(
+   text = "function(data) data <- subset(data, x > 0)",
+   linters = object_overwrite_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("object_usage_linter")
> ### * object_usage_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: object_usage_linter
> ### Title: Object usage linter
> ### Aliases: object_usage_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "foo <- function() { x <- 1 }",
+   linters = object_usage_linter()
+ )
::warning file=<text>,line=1,col=21::file=<text>,line=1,col=21,[object_usage_linter] local variable 'x' assigned but may not be used
> 
> # okay
> lint(
+   text = "foo <- function(x) { x <- 1 }",
+   linters = object_usage_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "foo <- function() { x <- 1; return(x) }",
+   linters = object_usage_linter()
+ )
ℹ No lints found.
> 
> 
> 
> cleanEx()
> nameEx("one_call_pipe_linter")
> ### * one_call_pipe_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: one_call_pipe_linter
> ### Title: Block single-call magrittr pipes
> ### Aliases: one_call_pipe_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "(1:10) %>% sum()",
+   linters = one_call_pipe_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[one_call_pipe_linter] Avoid pipe %>% for expressions with only a single call.
> 
> lint(
+   text = "DT %>% .[grp == 'a', sum(v)]",
+   linters = one_call_pipe_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[one_call_pipe_linter] Avoid pipe %>% for expressions with only a single call.
> 
> # okay
> lint(
+   text = "rowSums(x) %>% mean()",
+   linters = one_call_pipe_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "DT[src == 'a', .N, by = grp] %>% .[N > 10]",
+   linters = one_call_pipe_linter()
+ )
ℹ No lints found.
> 
> # assignment pipe is exempted
> lint(
+   text = "DF %<>% mutate(a = 2)",
+   linters = one_call_pipe_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("outer_negation_linter")
> ### * outer_negation_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: outer_negation_linter
> ### Title: Require usage of '!any(x)' over 'all(!x)', '!all(x)' over
> ###   'any(!x)'
> ### Aliases: outer_negation_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "all(!x)",
+   linters = outer_negation_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[outer_negation_linter] !any(x) is better than all(!x). The former applies negation only once after aggregation instead of many times for each element of x.
> 
> lint(
+   text = "any(!x)",
+   linters = outer_negation_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[outer_negation_linter] !all(x) is better than any(!x). The former applies negation only once after aggregation instead of many times for each element of x.
> 
> # okay
> lint(
+   text = "!any(x)",
+   linters = outer_negation_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "!all(x)",
+   linters = outer_negation_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("package_hooks_linter")
> ### * package_hooks_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: package_hooks_linter
> ### Title: Package hooks linter
> ### Aliases: package_hooks_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = ".onLoad <- function(lib, ...) { }",
+   linters = package_hooks_linter()
+ )
::warning file=<text>,line=1,col=12::file=<text>,line=1,col=12,[package_hooks_linter] .onLoad() should take two arguments, with the first starting with 'lib' and the second starting with 'pkg'.
> 
> lint(
+   text = ".onAttach <- function(lib, pkg) { require(foo) }",
+   linters = package_hooks_linter()
+ )
::warning file=<text>,line=1,col=35::file=<text>,line=1,col=35,[package_hooks_linter] Don't alter the search() path in .onAttach() by calling require().
> 
> lint(
+   text = ".onDetach <- function(pkg) { }",
+   linters = package_hooks_linter()
+ )
::warning file=<text>,line=1,col=14::file=<text>,line=1,col=14,[package_hooks_linter] .onDetach() should take one argument starting with 'lib'.
> 
> # okay
> lint(
+   text = ".onLoad <- function(lib, pkg) { }",
+   linters = package_hooks_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = '.onAttach <- function(lib, pkg) { loadNamespace("foo") }',
+   linters = package_hooks_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = ".onDetach <- function(lib) { }",
+   linters = package_hooks_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("paren_body_linter")
> ### * paren_body_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: paren_body_linter
> ### Title: Parenthesis before body linter
> ### Aliases: paren_body_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "function(x)x + 1",
+   linters = paren_body_linter()
+ )
::warning file=<text>,line=1,col=12::file=<text>,line=1,col=12,[paren_body_linter] Put a space between a right parenthesis and a body expression.
> 
> # okay
> lint(
+   text = "function(x) x + 1",
+   linters = paren_body_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("paste_linter")
> ### * paste_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: paste_linter
> ### Title: Raise lints for several common poor usages of 'paste()'
> ### Aliases: paste_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'paste("a", "b", sep = "")',
+   linters = paste_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[paste_linter] paste0(...) is better than paste(..., sep = "").
> 
> lint(
+   text = 'paste(c("a", "b"), collapse = ", ")',
+   linters = paste_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[paste_linter] toString(.) is more expressive than paste(., collapse = ", "). Note also glue::glue_collapse() and and::and() for constructing human-readable / translation-friendly lists
> 
> lint(
+   text = 'paste0(c("a", "b"), sep = " ")',
+   linters = paste_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[paste_linter] sep= is not a formal argument to paste0(); did you mean to use paste(), or collapse=?
> 
> lint(
+   text = 'paste0(rep("*", 10L), collapse = "")',
+   linters = paste_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[paste_linter] strrep(x, times) is better than paste0(rep(x, times), collapse = "").
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[paste_linter] Use paste(), not paste0(), to collapse a character vector when sep= is not used.
> 
> lint(
+   text = 'paste0("http://site.com/", path)',
+   linters = paste_linter(allow_file_path = "never")
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[paste_linter] Construct file paths with file.path(...) instead of paste0(x, "/", y, "/", z). Note that paste() converts empty inputs to "", whereas file.path() leaves it empty.
> 
> lint(
+   text = 'paste0(x, collapse = "")',
+   linters = paste_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[paste_linter] Use paste(), not paste0(), to collapse a character vector when sep= is not used.
> 
> # okay
> lint(
+   text = 'paste0("a", "b")',
+   linters = paste_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'paste("a", "b", sep = "")',
+   linters = paste_linter(allow_empty_sep = TRUE)
+ )
ℹ No lints found.
> 
> lint(
+   text = 'toString(c("a", "b"))',
+   linters = paste_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'paste(c("a", "b"), collapse = ", ")',
+   linters = paste_linter(allow_to_string = TRUE)
+ )
ℹ No lints found.
> 
> lint(
+   text = 'paste(c("a", "b"))',
+   linters = paste_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'strrep("*", 10L)',
+   linters = paste_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'paste0(year, "/", month, "/", day)',
+   linters = paste_linter(allow_file_path = "always")
+ )
ℹ No lints found.
> 
> lint(
+   text = 'paste0("http://site.com/", path)',
+   linters = paste_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'paste(x, collapse = "")',
+   linters = paste_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("pipe_call_linter")
> ### * pipe_call_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pipe_call_linter
> ### Title: Pipe call linter
> ### Aliases: pipe_call_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "1:3 %>% mean %>% as.character",
+   linters = pipe_call_linter()
+ )
::warning file=<text>,line=1,col=9::file=<text>,line=1,col=9,[pipe_call_linter] Use explicit calls in magrittr pipes, i.e., `a %>% foo` should be `a %>% foo()`.
::warning file=<text>,line=1,col=18::file=<text>,line=1,col=18,[pipe_call_linter] Use explicit calls in magrittr pipes, i.e., `a %>% foo` should be `a %>% foo()`.
> 
> # okay
> lint(
+   text = "1:3 %>% mean() %>% as.character()",
+   linters = pipe_call_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("pipe_consistency_linter")
> ### * pipe_consistency_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pipe_consistency_linter
> ### Title: Pipe consistency linter
> ### Aliases: pipe_consistency_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "1:3 |> mean() %>% as.character()",
+   linters = pipe_consistency_linter()
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[pipe_consistency_linter] Stick to one pipe operator; found 1 instances of %>% and 1 instances of |>.
::warning file=<text>,line=1,col=15::file=<text>,line=1,col=15,[pipe_consistency_linter] Stick to one pipe operator; found 1 instances of %>% and 1 instances of |>.
> 
> lint(
+   text = "1:3 %>% mean() %>% as.character()",
+   linters = pipe_consistency_linter("|>")
+ )
::warning file=<text>,line=1,col=5::file=<text>,line=1,col=5,[pipe_consistency_linter] Use the |> pipe operator instead of the %>% pipe operator.
::warning file=<text>,line=1,col=16::file=<text>,line=1,col=16,[pipe_consistency_linter] Use the |> pipe operator instead of the %>% pipe operator.
> 
> # okay
> lint(
+   text = "1:3 %>% mean() %>% as.character()",
+   linters = pipe_consistency_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "1:3 |> mean() |> as.character()",
+   linters = pipe_consistency_linter()
+ )
ℹ No lints found.
> 
> 
> 
> cleanEx()
> nameEx("pipe_continuation_linter")
> ### * pipe_continuation_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pipe_continuation_linter
> ### Title: Pipe continuation linter
> ### Aliases: pipe_continuation_linter
> 
> ### ** Examples
> 
> # will produce lints
> code_lines <- "1:3 %>%\n mean() %>% as.character()"
> writeLines(code_lines)
1:3 %>%
 mean() %>% as.character()
> lint(
+   text = code_lines,
+   linters = pipe_continuation_linter()
+ )
::warning file=<text>,line=2,col=9::file=<text>,line=2,col=9,[pipe_continuation_linter] Put a space before `%>%` and a new line after it, unless the full pipeline fits on one line.
> 
> code_lines <- "1:3 |> mean() |>\n as.character()"
> writeLines(code_lines)
1:3 |> mean() |>
 as.character()
> lint(
+   text = code_lines,
+   linters = pipe_continuation_linter()
+ )
::warning file=<text>,line=1,col=15::file=<text>,line=1,col=15,[pipe_continuation_linter] Put a space before `|>` and a new line after it, unless the full pipeline fits on one line.
> 
> # okay
> lint(
+   text = "1:3 %>% mean() %>% as.character()",
+   linters = pipe_continuation_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "1:3 %>%\n mean() %>%\n as.character()"
> writeLines(code_lines)
1:3 %>%
 mean() %>%
 as.character()
> lint(
+   text = code_lines,
+   linters = pipe_continuation_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "1:3 |> mean() |> as.character()",
+   linters = pipe_continuation_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "1:3 |>\n mean() |>\n as.character()"
> writeLines(code_lines)
1:3 |>
 mean() |>
 as.character()
> lint(
+   text = code_lines,
+   linters = pipe_continuation_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("pipe_return_linter")
> ### * pipe_return_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pipe_return_linter
> ### Title: Block usage of return() in magrittr pipelines
> ### Aliases: pipe_return_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "function(x) x %>% return()",
+   linters = pipe_return_linter()
+ )
::warning file=<text>,line=1,col=19::file=<text>,line=1,col=19,[pipe_return_linter] Avoid return() as the final step of a magrittr pipeline.  Instead, assign the output of the pipeline to a well-named object and return that.
> 
> # okay
> code <- "function(x) {\n  y <- sum(x)\n  return(y)\n}"
> writeLines(code)
function(x) {
  y <- sum(x)
  return(y)
}
> lint(
+   text = code,
+   linters = pipe_return_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("print_linter")
> ### * print_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print_linter
> ### Title: Block usage of print() for logging
> ### Aliases: print_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "print('a')",
+   linters = print_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[print_linter] Use cat() instead of print() logging messages. Use message() in cases calling for a signalled condition.
> 
> lint(
+   text = "print(paste(x, 'y'))",
+   linters = print_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[print_linter] Use cat() instead of print() logging messages. Use message() in cases calling for a signalled condition.
> 
> # okay
> lint(
+   text = "print(x)",
+   linters = print_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("quotes_linter")
> ### * quotes_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quotes_linter
> ### Title: Character string quote linter
> ### Aliases: quotes_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "c('a', 'b')",
+   linters = quotes_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[quotes_linter] Only use double-quotes.
::warning file=<text>,line=1,col=8::file=<text>,line=1,col=8,[quotes_linter] Only use double-quotes.
> 
> # okay
> lint(
+   text = 'c("a", "b")',
+   linters = quotes_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "paste0(x, '\"this is fine\"')"
> writeLines(code_lines)
paste0(x, '"this is fine"')
> lint(
+   text = code_lines,
+   linters = quotes_linter()
+ )
ℹ No lints found.
> 
> # okay
> lint(
+   text = "c('a', 'b')",
+   linters = quotes_linter(delimiter = "'")
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("redundant_equals_linter")
> ### * redundant_equals_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: redundant_equals_linter
> ### Title: Block usage of '==', '!=' on logical vectors
> ### Aliases: redundant_equals_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "if (any(x == TRUE)) 1",
+   linters = redundant_equals_linter()
+ )
::warning file=<text>,line=1,col=9::file=<text>,line=1,col=9,[redundant_equals_linter] Using == on a logical vector is redundant. Well-named logical vectors can be used directly in filtering. For data.table's `i` argument, wrap the column name in (), like `DT[(is_treatment)]`.
> 
> lint(
+   text = "if (any(x != FALSE)) 0",
+   linters = redundant_equals_linter()
+ )
::warning file=<text>,line=1,col=9::file=<text>,line=1,col=9,[redundant_equals_linter] Using != on a logical vector is redundant. Well-named logical vectors can be used directly in filtering. For data.table's `i` argument, wrap the column name in (), like `DT[(is_treatment)]`.
> 
> lint(
+   text = "dt[is_tall == FALSE, y]",
+   linters = redundant_equals_linter()
+ )
::warning file=<text>,line=1,col=4::file=<text>,line=1,col=4,[redundant_equals_linter] Using == on a logical vector is redundant. Well-named logical vectors can be used directly in filtering. For data.table's `i` argument, wrap the column name in (), like `DT[(is_treatment)]`.
> 
> # okay
> lint(
+   text = "if (any(x)) 1",
+   linters = redundant_equals_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "if (!all(x)) 0",
+   linters = redundant_equals_linter()
+ )
ℹ No lints found.
> 
> # in `{data.table}` semantics, `dt[x]` is a join, `dt[(x)]` is a subset
> lint(
+   text = "dt[(!is_tall), y]",
+   linters = redundant_equals_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("redundant_ifelse_linter")
> ### * redundant_ifelse_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: redundant_ifelse_linter
> ### Title: Prevent 'ifelse()' from being used to produce 'TRUE'/'FALSE' or
> ###   '1'/'0'
> ### Aliases: redundant_ifelse_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "ifelse(x >= 2.5, TRUE, FALSE)",
+   linters = redundant_ifelse_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[redundant_ifelse_linter] Just use the logical condition (or its negation) directly instead of calling ifelse(x, TRUE, FALSE)
> 
> lint(
+   text = "ifelse(x < 2.5, 1L, 0L)",
+   linters = redundant_ifelse_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[redundant_ifelse_linter] Prefer as.integer(x) to ifelse(x, 1L, 0L) if really needed.
> 
> # okay
> lint(
+   text = "x >= 2.5",
+   linters = redundant_ifelse_linter()
+ )
ℹ No lints found.
> 
> # Note that this is just to show the strict equivalent of the example above;
> # converting to integer is often unnecessary and the logical vector itself
> # should suffice.
> lint(
+   text = "as.integer(x < 2.5)",
+   linters = redundant_ifelse_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "ifelse(x < 2.5, 1L, 0L)",
+   linters = redundant_ifelse_linter(allow10 = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("regex_subset_linter")
> ### * regex_subset_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: regex_subset_linter
> ### Title: Require usage of direct methods for subsetting strings via regex
> ### Aliases: regex_subset_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x[grep(pattern, x)]",
+   linters = regex_subset_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[regex_subset_linter] Prefer grep(pattern, x, ..., value = TRUE) over x[grep(pattern, x, ...)] and x[grepl(pattern, x, ...)].
> 
> lint(
+   text = "x[stringr::str_which(x, pattern)]",
+   linters = regex_subset_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[regex_subset_linter] Prefer stringr::str_subset(x, pattern) over x[str_detect(x, pattern)] and x[str_which(x, pattern)].
> 
> # okay
> lint(
+   text = "grep(pattern, x, value = TRUE)",
+   linters = regex_subset_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "stringr::str_subset(x, pattern)",
+   linters = regex_subset_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("rep_len_linter")
> ### * rep_len_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rep_len_linter
> ### Title: Require usage of rep_len(x, n) over rep(x, length.out = n)
> ### Aliases: rep_len_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "rep(1:3, length.out = 10)",
+   linters = rep_len_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[rep_len_linter] Use rep_len(x, n) instead of rep(x, length.out = n).
> 
> # okay
> lint(
+   text = "rep_len(1:3, 10)",
+   linters = rep_len_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "rep(1:3, each = 2L, length.out = 10L)",
+   linters = rep_len_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("repeat_linter")
> ### * repeat_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: repeat_linter
> ### Title: Repeat linter
> ### Aliases: repeat_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "while (TRUE) { }",
+   linters = repeat_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[repeat_linter] Use 'repeat' instead of 'while (TRUE)' for infinite loops.
> 
> 
> # okay
> lint(
+   text = "repeat { }",
+   linters = repeat_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("return_linter")
> ### * return_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: return_linter
> ### Title: Return linter
> ### Aliases: return_linter
> 
> ### ** Examples
> 
> # will produce lints
> code <- "function(x) {\n  return(x + 1)\n}"
> writeLines(code)
function(x) {
  return(x + 1)
}
> lint(
+   text = code,
+   linters = return_linter()
+ )
::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,[return_linter] Use implicit return behavior; explicit return() is not needed.
> 
> code <- "function(x) {\n  x + 1\n}"
> writeLines(code)
function(x) {
  x + 1
}
> lint(
+   text = code,
+   linters = return_linter(return_style = "explicit")
+ )
::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,[return_linter] All functions must have an explicit return().
> 
> code <- "function(x) {\n  if (x > 0) 2\n}"
> writeLines(code)
function(x) {
  if (x > 0) 2
}
> lint(
+   text = code,
+   linters = return_linter(allow_implicit_else = FALSE)
+ )
::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,[return_linter] All functions with terminal if statements must have a corresponding terminal else clause.
> 
> # okay
> code <- "function(x) {\n  x + 1\n}"
> writeLines(code)
function(x) {
  x + 1
}
> lint(
+   text = code,
+   linters = return_linter()
+ )
ℹ No lints found.
> 
> code <- "function(x) {\n  return(x + 1)\n}"
> writeLines(code)
function(x) {
  return(x + 1)
}
> lint(
+   text = code,
+   linters = return_linter(return_style = "explicit")
+ )
ℹ No lints found.
> 
> code <- "function(x) {\n  if (x > 0) 2 else NULL\n}"
> writeLines(code)
function(x) {
  if (x > 0) 2 else NULL
}
> lint(
+   text = code,
+   linters = return_linter(allow_implicit_else = FALSE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("routine_registration_linter")
> ### * routine_registration_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: routine_registration_linter
> ### Title: Identify unregistered native routines
> ### Aliases: routine_registration_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = '.Call("cpp_routine", PACKAGE = "mypkg")',
+   linters = routine_registration_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[routine_registration_linter] Register your native code routines with useDynLib and R_registerRoutines().
> 
> lint(
+   text = '.Fortran("f_routine", PACKAGE = "mypkg")',
+   linters = routine_registration_linter()
+ )
::warning file=<text>,line=1,col=10::file=<text>,line=1,col=10,[routine_registration_linter] Register your native code routines with useDynLib and R_registerRoutines().
> 
> # okay
> lint(
+   text = ".Call(cpp_routine)",
+   linters = routine_registration_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = ".Fortran(f_routine)",
+   linters = routine_registration_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("sample_int_linter")
> ### * sample_int_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sample_int_linter
> ### Title: Require usage of sample.int(n, m, ...) over sample(1:n, m, ...)
> ### Aliases: sample_int_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "sample(1:10, 2)",
+   linters = sample_int_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[sample_int_linter] sample.int(n, m, ...) is preferable to sample(1:n, m, ...).
> 
> lint(
+   text = "sample(seq(4), 2)",
+   linters = sample_int_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[sample_int_linter] sample.int(n, m, ...) is preferable to sample(seq(n), m, ...).
> 
> lint(
+   text = "sample(seq_len(8), 2)",
+   linters = sample_int_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[sample_int_linter] sample.int(n, m, ...) is preferable to sample(seq_len(n), m, ...).
> 
> # okay
> lint(
+   text = "sample(seq(1, 5, by = 2), 2)",
+   linters = sample_int_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "sample(letters, 2)",
+   linters = sample_int_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("scalar_in_linter")
> ### * scalar_in_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scalar_in_linter
> ### Title: Block usage like x %in% "a"
> ### Aliases: scalar_in_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x %in% 1L",
+   linters = scalar_in_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[scalar_in_linter] Use comparison operators (e.g. ==, !=, etc.) to match length-1 scalars instead of %in%. Note that comparison operators preserve NA where %in% does not.
> 
> lint(
+   text = "x %chin% 'a'",
+   linters = scalar_in_linter(in_operators = "%chin%")
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[scalar_in_linter] Use comparison operators (e.g. ==, !=, etc.) to match length-1 scalars instead of %chin%. Note that comparison operators preserve NA where %chin% does not.
> 
> # okay
> lint(
+   text = "x %in% 1:10",
+   linters = scalar_in_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("semicolon_linter")
> ### * semicolon_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: semicolon_linter
> ### Title: Semicolon linter
> ### Aliases: semicolon_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "a <- 1;",
+   linters = semicolon_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[semicolon_linter] Remove trailing semicolons.
> 
> lint(
+   text = "a <- 1; b <- 1",
+   linters = semicolon_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[semicolon_linter] Replace compound semicolons by a newline.
> 
> lint(
+   text = "function() { a <- 1; b <- 1 }",
+   linters = semicolon_linter()
+ )
::warning file=<text>,line=1,col=20::file=<text>,line=1,col=20,[semicolon_linter] Replace compound semicolons by a newline.
> 
> # okay
> lint(
+   text = "a <- 1",
+   linters = semicolon_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "a <- 1;",
+   linters = semicolon_linter(allow_trailing = TRUE)
+ )
ℹ No lints found.
> 
> code_lines <- "a <- 1\nb <- 1"
> writeLines(code_lines)
a <- 1
b <- 1
> lint(
+   text = code_lines,
+   linters = semicolon_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "a <- 1; b <- 1",
+   linters = semicolon_linter(allow_compound = TRUE)
+ )
ℹ No lints found.
> 
> code_lines <- "function() { \n  a <- 1\n  b <- 1\n}"
> writeLines(code_lines)
function() { 
  a <- 1
  b <- 1
}
> lint(
+   text = code_lines,
+   linters = semicolon_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("seq_linter")
> ### * seq_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: seq_linter
> ### Title: Sequence linter
> ### Aliases: seq_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "seq(length(x))",
+   linters = seq_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[seq_linter] Use seq_along(...) instead of seq(length(...)), which is likely to be wrong in the empty edge case.
> 
> lint(
+   text = "1:nrow(x)",
+   linters = seq_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[seq_linter] Use seq_len(nrow(...)) instead of 1:nrow(...), which is likely to be wrong in the empty edge case.
> 
> lint(
+   text = "dplyr::mutate(x, .id = 1:n())",
+   linters = seq_linter()
+ )
::warning file=<text>,line=1,col=24::file=<text>,line=1,col=24,[seq_linter] Use seq_len(n()) instead of 1:n(), which is likely to be wrong in the empty edge case.
> 
> # okay
> lint(
+   text = "seq_along(x)",
+   linters = seq_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "seq_len(nrow(x))",
+   linters = seq_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "dplyr::mutate(x, .id = seq_len(n()))",
+   linters = seq_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("sort_linter")
> ### * sort_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sort_linter
> ### Title: Check for common mistakes around sorting vectors
> ### Aliases: sort_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x[order(x)]",
+   linters = sort_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[sort_linter] sort(x, na.last = TRUE) is better than x[order(x)]. Note that it's always preferable to save the output of order() for the same variable as a local variable than to re-compute it.
> 
> lint(
+   text = "x[order(x, decreasing = TRUE)]",
+   linters = sort_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[sort_linter] sort(x, decreasing = TRUE, na.last = TRUE) is better than x[order(x, decreasing = TRUE)]. Note that it's always preferable to save the output of order() for the same variable as a local variable than to re-compute it.
> 
> lint(
+   text = "sort(x) == x",
+   linters = sort_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[sort_linter] Use !is.unsorted(x) to test the sortedness of a vector.
> 
> # okay
> lint(
+   text = "x[sample(order(x))]",
+   linters = sort_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "y[order(x)]",
+   linters = sort_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "sort(x, decreasing = TRUE) == x",
+   linters = sort_linter()
+ )
ℹ No lints found.
> 
> # If you are sorting several objects based on the order of one of them, such
> # as:
> x <- sample(1:26)
> y <- letters
> newx <- x[order(x)]
> newy <- y[order(x)]
> # This will be flagged by the linter. However, in this very specific case,
> # it would be clearer and more efficient to run order() once and assign it
> # to an object, rather than mix and match order() and sort()
> index <- order(x)
> newx <- x[index]
> newy <- y[index]
> 
> 
> 
> 
> cleanEx()
> nameEx("spaces_inside_linter")
> ### * spaces_inside_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spaces_inside_linter
> ### Title: Spaces inside linter
> ### Aliases: spaces_inside_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "c( TRUE, FALSE )",
+   linters = spaces_inside_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[spaces_inside_linter] Do not place spaces after parentheses.
::warning file=<text>,line=1,col=15::file=<text>,line=1,col=15,[spaces_inside_linter] Do not place spaces before parentheses.
> 
> lint(
+   text = "x[ 1L ]",
+   linters = spaces_inside_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[spaces_inside_linter] Do not place spaces after square brackets.
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[spaces_inside_linter] Do not place spaces before square brackets.
> 
> # okay
> lint(
+   text = "c(TRUE, FALSE)",
+   linters = spaces_inside_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x[1L]",
+   linters = spaces_inside_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("spaces_left_parentheses_linter")
> ### * spaces_left_parentheses_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spaces_left_parentheses_linter
> ### Title: Spaces before parentheses linter
> ### Aliases: spaces_left_parentheses_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "if(TRUE) x else y",
+   linters = spaces_left_parentheses_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[spaces_left_parentheses_linter] Place a space before left parenthesis, except in a function call.
> 
> # okay
> lint(
+   text = "if (TRUE) x else y",
+   linters = spaces_left_parentheses_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("sprintf_linter")
> ### * sprintf_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sprintf_linter
> ### Title: Require correct 'sprintf()' calls
> ### Aliases: sprintf_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'sprintf("hello %s %s %d", x, y)',
+   linters = sprintf_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[sprintf_linter] too few arguments
> 
> # okay
> lint(
+   text = 'sprintf("hello %s %s %d", x, y, z)',
+   linters = sprintf_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'sprintf("hello %s %s %d", x, y, ...)',
+   linters = sprintf_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("stopifnot_all_linter")
> ### * stopifnot_all_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stopifnot_all_linter
> ### Title: Block usage of all() within stopifnot()
> ### Aliases: stopifnot_all_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "stopifnot(all(x > 0))",
+   linters = stopifnot_all_linter()
+ )
::warning file=<text>,line=1,col=11::file=<text>,line=1,col=11,[stopifnot_all_linter] Use stopifnot(x) instead of stopifnot(all(x)). stopifnot(x) runs all() 'under the hood' and provides a better error message in case of failure.
> 
> lint(
+   text = "stopifnot(y > 3, all(x < 0))",
+   linters = stopifnot_all_linter()
+ )
::warning file=<text>,line=1,col=18::file=<text>,line=1,col=18,[stopifnot_all_linter] Use stopifnot(x) instead of stopifnot(all(x)). stopifnot(x) runs all() 'under the hood' and provides a better error message in case of failure.
> 
> # okay
> lint(
+   text = "stopifnot(is.null(x) || all(x > 0))",
+   linters = stopifnot_all_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "assert_that(all(x > 0))",
+   linters = stopifnot_all_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("string_boundary_linter")
> ### * string_boundary_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: string_boundary_linter
> ### Title: Require usage of 'startsWith()' and 'endsWith()' over
> ###   'grepl()'/'substr()' versions
> ### Aliases: string_boundary_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'grepl("^a", x)',
+   linters = string_boundary_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[string_boundary_linter] Use !is.na(x) & startsWith(x, string) to detect a fixed initial substring, or, if missingness is not a concern, just startsWith(). Doing so is more readable and more efficient.
> 
> lint(
+   text = 'grepl("z$", x)',
+   linters = string_boundary_linter()
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[string_boundary_linter] Use !is.na(x) & endsWith(x, string) to detect a fixed terminal substring, or, if missingness is not a concern, just endsWith(). Doing so is more readable and more efficient.
> 
> # okay
> lint(
+   text = 'startsWith(x, "a")',
+   linters = string_boundary_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'endsWith(x, "z")',
+   linters = string_boundary_linter()
+ )
ℹ No lints found.
> 
> # If missing values are present, the suggested alternative wouldn't be strictly
> # equivalent, so this linter can also be turned off in such cases.
> lint(
+   text = 'grepl("z$", x)',
+   linters = string_boundary_linter(allow_grepl = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("strings_as_factors_linter")
> ### * strings_as_factors_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strings_as_factors_linter
> ### Title: Identify cases where 'stringsAsFactors' should be supplied
> ###   explicitly
> ### Aliases: strings_as_factors_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'data.frame(x = "a")',
+   linters = strings_as_factors_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[strings_as_factors_linter] Supply an explicit value for stringsAsFactors for this code to work before and after R version 4.0.
> 
> # okay
> lint(
+   text = 'data.frame(x = "a", stringsAsFactors = TRUE)',
+   linters = strings_as_factors_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'data.frame(x = "a", stringsAsFactors = FALSE)',
+   linters = strings_as_factors_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "data.frame(x = 1.2)",
+   linters = strings_as_factors_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("system_file_linter")
> ### * system_file_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: system_file_linter
> ### Title: Block usage of 'file.path()' with 'system.file()'
> ### Aliases: system_file_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = 'system.file(file.path("path", "to", "data"), package = "foo")',
+   linters = system_file_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[system_file_linter] Use the `...` argument of system.file() to expand paths, e.g. system.file("data", "model.csv", package = "myrf") instead of system.file(file.path("data", "model.csv"), package = "myrf")
> 
> lint(
+   text = 'file.path(system.file(package = "foo"), "path", "to", "data")',
+   linters = system_file_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[system_file_linter] Use the `...` argument of system.file() to expand paths, e.g. system.file("data", "model.csv", package = "myrf") instead of file.path(system.file(package = "myrf"), "data", "model.csv")
> 
> # okay
> lint(
+   text = 'system.file("path", "to", "data", package = "foo")',
+   linters = system_file_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("terminal_close_linter")
> ### * terminal_close_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: terminal_close_linter
> ### Title: Prohibit close() from terminating a function definition
> ### Aliases: terminal_close_linter
> 
> ### ** Examples
> 
> # will produce lints
> code <- paste(
+   "f <- function(fl) {",
+   "  conn <- file(fl, open = 'r')",
+   "  readLines(conn)",
+   "  close(conn)",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
f <- function(fl) {
  conn <- file(fl, open = 'r')
  readLines(conn)
  close(conn)
}
> lint(
+   text = code,
+   linters = terminal_close_linter()
+ )
::warning file=<text>,line=4,col=3::file=<text>,line=4,col=3,[terminal_close_linter] Use on.exit(close(x)) to close connections instead of running it as the last call in a function.
> 
> # okay
> code <- paste(
+   "f <- function(fl) {",
+   "  conn <- file(fl, open = 'r')",
+   "  on.exit(close(conn))",
+   "  readLines(conn)",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
f <- function(fl) {
  conn <- file(fl, open = 'r')
  on.exit(close(conn))
  readLines(conn)
}
> lint(
+   text = code,
+   linters = terminal_close_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("todo_comment_linter")
> ### * todo_comment_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: todo_comment_linter
> ### Title: TODO comment linter
> ### Aliases: todo_comment_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x + y # TOODOO",
+   linters = todo_comment_linter(todo = "toodoo")
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[todo_comment_linter] Remove TODO comments.
> 
> lint(
+   text = "pi <- 1.0 # FIIXMEE",
+   linters = todo_comment_linter(todo = "fiixmee")
+ )
::warning file=<text>,line=1,col=11::file=<text>,line=1,col=11,[todo_comment_linter] Remove TODO comments.
> 
> lint(
+   text = "x <- TRUE # TOODOO(#1234): Fix this hack.",
+   linters = todo_comment_linter()
+ )
ℹ No lints found.
> 
> # okay
> lint(
+   text = "x + y # my informative comment",
+   linters = todo_comment_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "pi <- 3.14",
+   linters = todo_comment_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x <- TRUE",
+   linters = todo_comment_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x <- TRUE # TODO(#1234): Fix this hack.",
+   linters = todo_comment_linter(except_regex = "TODO\\(#[0-9]+\\):")
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("trailing_blank_lines_linter")
> ### * trailing_blank_lines_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trailing_blank_lines_linter
> ### Title: Trailing blank lines linter
> ### Aliases: trailing_blank_lines_linter
> 
> ### ** Examples
> 
> # will produce lints
> f <- tempfile()
> cat("x <- 1\n\n", file = f)
> writeLines(readChar(f, file.size(f)))
x <- 1


> lint(
+   filename = f,
+   linters = trailing_blank_lines_linter()
+ )
::warning file=/tmp/RtmpqZbCrY/file16f104c28b706,line=2,col=1::file=/tmp/RtmpqZbCrY/file16f104c28b706,line=2,col=1,[trailing_blank_lines_linter] Remove trailing blank lines.
> unlink(f)
> 
> # okay
> cat("x <- 1\n", file = f)
> writeLines(readChar(f, file.size(f)))
x <- 1

> lint(
+   filename = f,
+   linters = trailing_blank_lines_linter()
+ )
ℹ No lints found.
> unlink(f)
> 
> 
> 
> 
> cleanEx()
> nameEx("trailing_whitespace_linter")
> ### * trailing_whitespace_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trailing_whitespace_linter
> ### Title: Trailing whitespace linter
> ### Aliases: trailing_whitespace_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x <- 1.2  ",
+   linters = trailing_whitespace_linter()
+ )
::warning file=<text>,line=1,col=9::file=<text>,line=1,col=9,[trailing_whitespace_linter] Remove trailing whitespace.
> 
> code_lines <- "a <- TRUE\n \nb <- FALSE"
> writeLines(code_lines)
a <- TRUE
 
b <- FALSE
> lint(
+   text = code_lines,
+   linters = trailing_whitespace_linter()
+ )
::warning file=<text>,line=2,col=1::file=<text>,line=2,col=1,[trailing_whitespace_linter] Remove trailing whitespace.
> 
> # okay
> lint(
+   text = "x <- 1.2",
+   linters = trailing_whitespace_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x <- 1.2  # comment about this assignment",
+   linters = trailing_whitespace_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "a <- TRUE\n \nb <- FALSE"
> writeLines(code_lines)
a <- TRUE
 
b <- FALSE
> lint(
+   text = code_lines,
+   linters = trailing_whitespace_linter(allow_empty_lines = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("undesirable_function_linter")
> ### * undesirable_function_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: undesirable_function_linter
> ### Title: Undesirable function linter
> ### Aliases: undesirable_function_linter
> 
> ### ** Examples
> 
> # defaults for which functions are considered undesirable
> names(default_undesirable_functions)
 [1] ".libPaths"     "attach"        "browser"       "debug"        
 [5] "debugcall"     "debugonce"     "detach"        "library"      
 [9] "mapply"        "options"       "par"           "require"      
[13] "sapply"        "setwd"         "sink"          "source"       
[17] "structure"     "Sys.setenv"    "Sys.setlocale" "trace"        
[21] "undebug"       "untrace"      
> 
> # will produce lints
> lint(
+   text = "sapply(x, mean)",
+   linters = undesirable_function_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[undesirable_function_linter] Avoid undesirable function "sapply". As an alternative, use vapply() with an appropriate `FUN.VALUE=` argument to obtain type-stable simplification.
> 
> lint(
+   text = "log10(x)",
+   linters = undesirable_function_linter(fun = c("log10" = NA))
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[undesirable_function_linter] Avoid undesirable function "log10".
> 
> lint(
+   text = "log10(x)",
+   linters = undesirable_function_linter(fun = c("log10" = "use log()"))
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[undesirable_function_linter] Avoid undesirable function "log10". As an alternative, use log().
> 
> lint(
+   text = 'dir <- "path/to/a/directory"',
+   linters = undesirable_function_linter(fun = c("dir" = NA))
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[undesirable_function_linter] Avoid undesirable function "dir".
> 
> # okay
> lint(
+   text = "vapply(x, mean, FUN.VALUE = numeric(1))",
+   linters = undesirable_function_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "log(x, base = 10)",
+   linters = undesirable_function_linter(fun = c("log10" = "use log()"))
+ )
ℹ No lints found.
> 
> lint(
+   text = 'dir <- "path/to/a/directory"',
+   linters = undesirable_function_linter(fun = c("dir" = NA), symbol_is_undesirable = FALSE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("undesirable_operator_linter")
> ### * undesirable_operator_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: undesirable_operator_linter
> ### Title: Undesirable operator linter
> ### Aliases: undesirable_operator_linter
> 
> ### ** Examples
> 
> # defaults for which functions are considered undesirable
> names(default_undesirable_operators)
[1] "->>" ":::" "<<-"
> 
> # will produce lints
> lint(
+   text = "a <<- log(10)",
+   linters = undesirable_operator_linter()
+ )
::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,[undesirable_operator_linter] Avoid undesirable operator `<<-`. It assigns outside the current environment in a way that can be hard to reason about. Prefer fully-encapsulated functions wherever possible, or, if necessary, assign to a specific environment with assign(). Recall that you can create an environment at the desired scope with new.env().
> 
> lint(
+   text = "mtcars$wt",
+   linters = undesirable_operator_linter(op = c("$" = "As an alternative, use the `[[` accessor."))
+ )
::warning file=<text>,line=1,col=7::file=<text>,line=1,col=7,[undesirable_operator_linter] Avoid undesirable operator `$`. As an alternative, use the `[[` accessor.
> 
> # okay
> lint(
+   text = "a <- log(10)",
+   linters = undesirable_operator_linter()
+ )
ℹ No lints found.
> lint(
+   text = 'mtcars[["wt"]]',
+   linters = undesirable_operator_linter(op = c("$" = NA))
+ )
ℹ No lints found.
> 
> lint(
+   text = 'mtcars[["wt"]]',
+   linters = undesirable_operator_linter(op = c("$" = "As an alternative, use the `[[` accessor."))
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("unnecessary_concatenation_linter")
> ### * unnecessary_concatenation_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unnecessary_concatenation_linter
> ### Title: Unneeded concatenation linter
> ### Aliases: unnecessary_concatenation_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x <- c()",
+   linters = unnecessary_concatenation_linter()
+ )
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[unnecessary_concatenation_linter] Replace unnecessary c() by NULL or, whenever possible, vector() seeded with the correct type and/or length.
> 
> lint(
+   text = "x <- c(TRUE)",
+   linters = unnecessary_concatenation_linter()
+ )
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[unnecessary_concatenation_linter] Remove unnecessary c() of a constant.
> 
> lint(
+   text = "x <- c(1.5 + 2.5)",
+   linters = unnecessary_concatenation_linter(allow_single_expression = FALSE)
+ )
::warning file=<text>,line=1,col=6::file=<text>,line=1,col=6,[unnecessary_concatenation_linter] Remove unnecessary c() of a constant expression. Replace with as.vector() if c() is used to strip attributes, e.g. in converting an array to a vector.
> 
> # okay
> lint(
+   text = "x <- NULL",
+   linters = unnecessary_concatenation_linter()
+ )
ℹ No lints found.
> 
> # In case the intent here was to seed a vector of known size
> lint(
+   text = "x <- integer(4L)",
+   linters = unnecessary_concatenation_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x <- TRUE",
+   linters = unnecessary_concatenation_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x <- c(1.5 + 2.5)",
+   linters = unnecessary_concatenation_linter(allow_single_expression = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("unnecessary_lambda_linter")
> ### * unnecessary_lambda_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unnecessary_lambda_linter
> ### Title: Block usage of anonymous functions in iteration functions when
> ###   unnecessary
> ### Aliases: unnecessary_lambda_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "lapply(list(1:3, 2:4), function(xi) sum(xi))",
+   linters = unnecessary_lambda_linter()
+ )
::warning file=<text>,line=1,col=24::file=<text>,line=1,col=24,[unnecessary_lambda_linter] Pass sum directly as a symbol to lapply() instead of wrapping it in an unnecessary anonymous function. For example, prefer lapply(DF, sum) to lapply(DF, function(x) sum(x)).
> 
> lint(
+   text = "sapply(x, function(xi) xi == 2)",
+   linters = unnecessary_lambda_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "sapply(x, function(xi) sum(xi) > 0)",
+   linters = unnecessary_lambda_linter()
+ )
::warning file=<text>,line=1,col=24::file=<text>,line=1,col=24,[unnecessary_lambda_linter] Compare to a constant after calling sapply() to get the full benefits of vectorization. Prefer sapply(x, foo) == 2 over sapply(x, function(xi) foo(xi) == 2, logical(1L)).
> 
> # okay
> lint(
+   text = "lapply(list(1:3, 2:4), sum)",
+   linters = unnecessary_lambda_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'lapply(x, function(xi) grep("ptn", xi))',
+   linters = unnecessary_lambda_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "lapply(x, function(xi) data.frame(col = xi))",
+   linters = unnecessary_lambda_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "sapply(x, function(xi) xi == 2)",
+   linters = unnecessary_lambda_linter(allow_comparison = TRUE)
+ )
ℹ No lints found.
> 
> lint(
+   text = "sapply(x, function(xi) sum(xi) > 0)",
+   linters = unnecessary_lambda_linter(allow_comparison = TRUE)
+ )
ℹ No lints found.
> 
> lint(
+   text = "sapply(x, function(xi) sum(abs(xi)) > 10)",
+   linters = unnecessary_lambda_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "sapply(x, sum) > 0",
+   linters = unnecessary_lambda_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("unnecessary_nesting_linter")
> ### * unnecessary_nesting_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unnecessary_nesting_linter
> ### Title: Block instances of unnecessary nesting
> ### Aliases: unnecessary_nesting_linter
> 
> ### ** Examples
> 
> # will produce lints
> code <- "if (A) {\n  stop('A is bad!')\n} else {\n  do_good()\n}"
> writeLines(code)
if (A) {
  stop('A is bad!')
} else {
  do_good()
}
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[unnecessary_nesting_linter] Reduce the nesting of this if/else statement by unnesting the portion without an exit clause (i.e., stop(), return(), abort(), quit(), q()).
> 
> code <- "tryCatch(\n  {\n    foo()\n  },\n  error = identity\n)"
> writeLines(code)
tryCatch(
  {
    foo()
  },
  error = identity
)
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
ℹ No lints found.
> 
> code <- "expect_warning(\n  {\n    x <- foo()\n  },\n  'warned'\n)"
> writeLines(code)
expect_warning(
  {
    x <- foo()
  },
  'warned'
)
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter(allow_assignment = FALSE)
+ )
::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,[unnecessary_nesting_linter] Reduce the nesting of this statement by removing the braces {}.
> 
> code <- "if (x) { \n  if (y) { \n   return(1L) \n  } \n}"
> writeLines(code)
if (x) { 
  if (y) { 
   return(1L) 
  } 
}
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,[unnecessary_nesting_linter] Don't use nested `if` statements, where a single `if` with the combined conditional expression will do. For example, instead of `if (x) { if (y) { ... }}`, use `if (x && y) { ... }`.
> 
> lint(
+   text = "my_quote({x})",
+   linters = unnecessary_nesting_linter()
+ )
ℹ No lints found.
> 
> code <- paste(
+   "if (A) {",
+   "  stop('A is bad because a.')",
+   "} else {",
+   "  warning('!A requires caution.')",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
if (A) {
  stop('A is bad because a.')
} else {
  warning('!A requires caution.')
}
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[unnecessary_nesting_linter] Reduce the nesting of this if/else statement by unnesting the portion without an exit clause (i.e., stop(), return(), abort(), quit(), q()).
> 
> # okay
> code <- "if (A) {\n  stop('A is bad because a.')\n} else {\n  stop('!A is bad too.')\n}"
> writeLines(code)
if (A) {
  stop('A is bad because a.')
} else {
  stop('!A is bad too.')
}
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
ℹ No lints found.
> 
> code <- "capture.output({\n  foo()\n})"
> writeLines(code)
capture.output({
  foo()
})
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
ℹ No lints found.
> 
> code <- "expect_warning(\n  {\n    x <- foo()\n  },\n  'warned'\n)"
> writeLines(code)
expect_warning(
  {
    x <- foo()
  },
  'warned'
)
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
ℹ No lints found.
> 
> code <- "if (x && y) { \n  return(1L) \n}"
> writeLines(code)
if (x && y) { 
  return(1L) 
}
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
ℹ No lints found.
> 
> code <- "if (x) { \n  y <- x + 1L\n  if (y) { \n   return(1L) \n  } \n}"
> writeLines(code)
if (x) { 
  y <- x + 1L
  if (y) { 
   return(1L) 
  } 
}
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "my_quote({x})",
+   linters = unnecessary_nesting_linter(allow_functions = "my_quote")
+ )
ℹ No lints found.
> 
> code <- paste(
+   "if (A) {",
+   "  stop('A is bad because a.')",
+   "} else {",
+   "  warning('!A requires caution.')",
+   "}",
+   sep = "\n"
+ )
> writeLines(code)
if (A) {
  stop('A is bad because a.')
} else {
  warning('!A requires caution.')
}
> lint(
+   text = code,
+   linters = unnecessary_nesting_linter(branch_exit_calls = c("stop", "warning"))
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("unnecessary_placeholder_linter")
> ### * unnecessary_placeholder_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unnecessary_placeholder_linter
> ### Title: Block usage of pipeline placeholders if unnecessary
> ### Aliases: unnecessary_placeholder_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "x %>% sum(., na.rm = TRUE)",
+   linters = unnecessary_placeholder_linter()
+ )
::warning file=<text>,line=1,col=11::file=<text>,line=1,col=11,[unnecessary_placeholder_linter] Don't use the placeholder (`.`) when it's not needed, i.e., when it's only used as the first positional argument in a pipeline step.
> 
> # okay
> lint(
+   text = "x %>% sum(na.rm = TRUE)",
+   linters = unnecessary_placeholder_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x %>% lm(data = ., y ~ z)",
+   linters = unnecessary_placeholder_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "x %>% outer(., .)",
+   linters = unnecessary_placeholder_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("unreachable_code_linter")
> ### * unreachable_code_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unreachable_code_linter
> ### Title: Block unreachable code and comments following return statements
> ### Aliases: unreachable_code_linter
> 
> ### ** Examples
> 
> # will produce lints
> code_lines <- "f <- function() {\n  return(1 + 1)\n  2 + 2\n}"
> writeLines(code_lines)
f <- function() {
  return(1 + 1)
  2 + 2
}
> lint(
+   text = code_lines,
+   linters = unreachable_code_linter()
+ )
::warning file=<text>,line=3,col=3::file=<text>,line=3,col=3,[unreachable_code_linter] Remove code and comments coming after return() or stop().
> 
> code_lines <- "if (FALSE) {\n 2 + 2\n}"
> writeLines(code_lines)
if (FALSE) {
 2 + 2
}
> lint(
+   text = code_lines,
+   linters = unreachable_code_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[unreachable_code_linter] Remove code inside a conditional loop with a deterministically false condition.
> 
> code_lines <- "while (FALSE) {\n 2 + 2\n}"
> writeLines(code_lines)
while (FALSE) {
 2 + 2
}
> lint(
+   text = code_lines,
+   linters = unreachable_code_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[unreachable_code_linter] Remove code inside a conditional loop with a deterministically false condition.
> 
> code_lines <- "f <- function() {\n  return(1)\n  # end skip\n}"
> writeLines(code_lines)
f <- function() {
  return(1)
  # end skip
}
> lint(
+   text = code_lines,
+   linters = unreachable_code_linter()
+ )
::warning file=<text>,line=3,col=3::file=<text>,line=3,col=3,[unreachable_code_linter] Remove code and comments coming after return() or stop().
> 
> # okay
> code_lines <- "f <- function() {\n  return(1 + 1)\n}"
> writeLines(code_lines)
f <- function() {
  return(1 + 1)
}
> lint(
+   text = code_lines,
+   linters = unreachable_code_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "if (foo) {\n 2 + 2\n}"
> writeLines(code_lines)
if (foo) {
 2 + 2
}
> lint(
+   text = code_lines,
+   linters = unreachable_code_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "while (foo) {\n 2 + 2\n}"
> writeLines(code_lines)
while (foo) {
 2 + 2
}
> lint(
+   text = code_lines,
+   linters = unreachable_code_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "f <- function() {\n  return(1)\n  # end skip\n}"
> writeLines(code_lines)
f <- function() {
  return(1)
  # end skip
}
> lint(
+   text = code_lines,
+   linters = unreachable_code_linter(allow_comment_regex = "# end skip")
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("unused_import_linter")
> ### * unused_import_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unused_import_linter
> ### Title: Check that imported packages are actually used
> ### Aliases: unused_import_linter
> 
> ### ** Examples
> 
> # will produce lints
> code_lines <- "library(dplyr)\n1 + 1"
> writeLines(code_lines)
library(dplyr)
1 + 1
> lint(
+   text = code_lines,
+   linters = unused_import_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[unused_import_linter] Package 'dplyr' is attached but never used.
> 
> code_lines <- "library(dplyr)\ndplyr::tibble(a = 1)"
> writeLines(code_lines)
library(dplyr)
dplyr::tibble(a = 1)
> lint(
+   text = code_lines,
+   linters = unused_import_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[unused_import_linter] Don't attach package 'dplyr', which is only used by namespace. Check that it is installed using loadNamespace() instead.
> 
> # okay
> code_lines <- "library(dplyr)\ntibble(a = 1)"
> writeLines(code_lines)
library(dplyr)
tibble(a = 1)
> lint(
+   text = code_lines,
+   linters = unused_import_linter()
+ )
ℹ No lints found.
> 
> code_lines <- "library(dplyr)\ndplyr::tibble(a = 1)"
> writeLines(code_lines)
library(dplyr)
dplyr::tibble(a = 1)
> lint(
+   text = code_lines,
+   linters = unused_import_linter(allow_ns_usage = TRUE)
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("use_lintr")
> ### * use_lintr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: use_lintr
> ### Title: Use lintr in your project
> ### Aliases: use_lintr
> 
> ### ** Examples
> 
> if (FALSE) {
+   # use the default set of linters
+   lintr::use_lintr()
+   # or try all linters
+   lintr::use_lintr(type = "full")
+ 
+   # then
+   lintr::lint_dir()
+ }
> 
> 
> 
> cleanEx()
> nameEx("vector_logic_linter")
> ### * vector_logic_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vector_logic_linter
> ### Title: Enforce usage of scalar logical operators in conditional
> ###   statements
> ### Aliases: vector_logic_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "if (TRUE & FALSE) 1",
+   linters = vector_logic_linter()
+ )
::warning file=<text>,line=1,col=10::file=<text>,line=1,col=10,[vector_logic_linter] Use `&&` in conditional expressions.
> 
> lint(
+   text = "if (TRUE && (TRUE | FALSE)) 4",
+   linters = vector_logic_linter()
+ )
::warning file=<text>,line=1,col=19::file=<text>,line=1,col=19,[vector_logic_linter] Use `||` in conditional expressions.
> 
> lint(
+   text = "filter(x, A && B)",
+   linters = vector_logic_linter()
+ )
::warning file=<text>,line=1,col=13::file=<text>,line=1,col=13,[vector_logic_linter] Use `&` in subsetting expressions.
> 
> # okay
> lint(
+   text = "if (TRUE && FALSE) 1",
+   linters = vector_logic_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "if (TRUE && (TRUE || FALSE)) 4",
+   linters = vector_logic_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = "filter(x, A & B)",
+   linters = vector_logic_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("which_grepl_linter")
> ### * which_grepl_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: which_grepl_linter
> ### Title: Require usage of grep over which(grepl(.))
> ### Aliases: which_grepl_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "which(grepl('^a', x))",
+   linters = which_grepl_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[which_grepl_linter] grep(pattern, x) is better than which(grepl(pattern, x)).
> 
> # okay
> lint(
+   text = "which(grepl('^a', x) | grepl('^b', x))",
+   linters = which_grepl_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("whitespace_linter")
> ### * whitespace_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: whitespace_linter
> ### Title: Whitespace linter
> ### Aliases: whitespace_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "\tx",
+   linters = whitespace_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[whitespace_linter] Use spaces to indent, not tabs.
> 
> # okay
> lint(
+   text = "  x",
+   linters = whitespace_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> cleanEx()
> nameEx("xp_call_name")
> ### * xp_call_name
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xp_call_name
> ### Title: Get the name of the function matched by an XPath
> ### Aliases: xp_call_name
> 
> ### ** Examples
> 
> xml_from_code <- function(str) {
+   xml2::read_xml(xmlparsedata::xml_parse_data(parse(text = str, keep.source = TRUE)))
+ }
> xml <- xml_from_code("sum(1:10)")
> xp_call_name(xml, depth = 2L)
[1] "sum"
> 
> xp_call_name(xml2::xml_find_first(xml, "expr"))
[1] "sum"
> 
> xml <- xml_from_code(c("sum(1:10)", "sd(1:10)"))
> xp_call_name(xml, depth = 2L, condition = "text() = 'sum'")
[1] "sum"
> 
> 
> 
> 
> cleanEx()
> nameEx("yoda_test_linter")
> ### * yoda_test_linter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yoda_test_linter
> ### Title: Block obvious "yoda tests"
> ### Aliases: yoda_test_linter
> 
> ### ** Examples
> 
> # will produce lints
> lint(
+   text = "expect_equal(2, x)",
+   linters = yoda_test_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[yoda_test_linter] Compare objects in tests in the order 'actual', 'expected', not the reverse. For example, do expect_equal(foo(x), 2L) instead of expect_equal(2L, foo(x)).
> 
> lint(
+   text = 'expect_identical("a", x)',
+   linters = yoda_test_linter()
+ )
::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,[yoda_test_linter] Compare objects in tests in the order 'actual', 'expected', not the reverse. For example, do expect_identical(foo(x), 2L) instead of expect_identical(2L, foo(x)).
> 
> # okay
> lint(
+   text = "expect_equal(x, 2)",
+   linters = yoda_test_linter()
+ )
ℹ No lints found.
> 
> lint(
+   text = 'expect_identical(x, "a")',
+   linters = yoda_test_linter()
+ )
ℹ No lints found.
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  5.113 0.311 5.426 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
