
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:58:42.564] plan(): Setting new future strategy stack:
[10:58:42.565] List of future strategies:
[10:58:42.565] 1. sequential:
[10:58:42.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.565]    - tweaked: FALSE
[10:58:42.565]    - call: future::plan("sequential")
[10:58:42.578] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[10:58:42.636] plan(): Setting new future strategy stack:
[10:58:42.636] List of future strategies:
[10:58:42.636] 1. sequential:
[10:58:42.636]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.636]    - tweaked: FALSE
[10:58:42.636]    - call: plan(strategy)
[10:58:42.648] plan(): nbrOfWorkers() = 1
[10:58:42.648] future_by_internal() ...
[10:58:42.648] future_lapply() ...
[10:58:42.652] Number of chunks: 1
[10:58:42.652] getGlobalsAndPackagesXApply() ...
[10:58:42.652]  - future.globals: TRUE
[10:58:42.652] getGlobalsAndPackages() ...
[10:58:42.653] Searching for globals...
[10:58:42.654] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:42.655] Searching for globals ... DONE
[10:58:42.655] Resolving globals: FALSE
[10:58:42.655] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:42.656] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:42.656] - globals: [1] ‘FUN’
[10:58:42.656] 
[10:58:42.656] getGlobalsAndPackages() ... DONE
[10:58:42.656]  - globals found/used: [n=1] ‘FUN’
[10:58:42.656]  - needed namespaces: [n=0] 
[10:58:42.656] Finding globals ... DONE
[10:58:42.656]  - use_args: TRUE
[10:58:42.657]  - Getting '...' globals ...
[10:58:42.657] resolve() on list ...
[10:58:42.657]  recursive: 0
[10:58:42.658]  length: 1
[10:58:42.658]  elements: ‘...’
[10:58:42.658]  length: 0 (resolved future 1)
[10:58:42.658] resolve() on list ... DONE
[10:58:42.658]    - '...' content: [n=0] 
[10:58:42.658] List of 1
[10:58:42.658]  $ ...: list()
[10:58:42.658]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.658]  - attr(*, "where")=List of 1
[10:58:42.658]   ..$ ...:<environment: 0x55974bde6000> 
[10:58:42.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.658]  - attr(*, "resolved")= logi TRUE
[10:58:42.658]  - attr(*, "total_size")= num NA
[10:58:42.662]  - Getting '...' globals ... DONE
[10:58:42.662] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:42.662] List of 2
[10:58:42.662]  $ ...future.FUN:function (object, ...)  
[10:58:42.662]  $ ...          : list()
[10:58:42.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.662]  - attr(*, "where")=List of 2
[10:58:42.662]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.662]   ..$ ...          :<environment: 0x55974bde6000> 
[10:58:42.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.662]  - attr(*, "resolved")= logi FALSE
[10:58:42.662]  - attr(*, "total_size")= num 15670
[10:58:42.664] Packages to be attached in all futures: [n=0] 
[10:58:42.665] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.665] Number of futures (= number of chunks): 1
[10:58:42.665] Launching 1 futures (chunks) ...
[10:58:42.665] Chunk #1 of 1 ...
[10:58:42.665]  - Finding globals in 'X' for chunk #1 ...
[10:58:42.665] getGlobalsAndPackages() ...
[10:58:42.665] Searching for globals...
[10:58:42.666] 
[10:58:42.666] Searching for globals ... DONE
[10:58:42.666] - globals: [0] <none>
[10:58:42.666] getGlobalsAndPackages() ... DONE
[10:58:42.666]    + additional globals found: [n=0] 
[10:58:42.666]    + additional namespaces needed: [n=0] 
[10:58:42.666]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:42.666]  - seeds: <none>
[10:58:42.667]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.667] getGlobalsAndPackages() ...
[10:58:42.667] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.667] Resolving globals: FALSE
[10:58:42.667] Tweak future expression to call with '...' arguments ...
[10:58:42.667] {
[10:58:42.667]     do.call(function(...) {
[10:58:42.667]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.667]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.667]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.667]             on.exit(options(oopts), add = TRUE)
[10:58:42.667]         }
[10:58:42.667]         {
[10:58:42.667]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.667]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.667]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.667]             })
[10:58:42.667]         }
[10:58:42.667]     }, args = future.call.arguments)
[10:58:42.667] }
[10:58:42.667] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.668] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.668] 
[10:58:42.668] getGlobalsAndPackages() ... DONE
[10:58:42.669] run() for ‘Future’ ...
[10:58:42.669] - state: ‘created’
[10:58:42.669] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:42.669] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.671] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:42.671]   - Field: ‘label’
[10:58:42.671]   - Field: ‘local’
[10:58:42.671]   - Field: ‘owner’
[10:58:42.672]   - Field: ‘envir’
[10:58:42.672]   - Field: ‘packages’
[10:58:42.672]   - Field: ‘gc’
[10:58:42.672]   - Field: ‘conditions’
[10:58:42.672]   - Field: ‘expr’
[10:58:42.672]   - Field: ‘uuid’
[10:58:42.672]   - Field: ‘seed’
[10:58:42.672]   - Field: ‘version’
[10:58:42.672]   - Field: ‘result’
[10:58:42.672]   - Field: ‘asynchronous’
[10:58:42.672]   - Field: ‘calls’
[10:58:42.672]   - Field: ‘globals’
[10:58:42.673]   - Field: ‘stdout’
[10:58:42.673]   - Field: ‘earlySignal’
[10:58:42.673]   - Field: ‘lazy’
[10:58:42.673]   - Field: ‘state’
[10:58:42.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:42.673] - Launch lazy future ...
[10:58:42.674] Packages needed by the future expression (n = 0): <none>
[10:58:42.674] Packages needed by future strategies (n = 0): <none>
[10:58:42.674] {
[10:58:42.674]     {
[10:58:42.674]         {
[10:58:42.674]             ...future.startTime <- base::Sys.time()
[10:58:42.674]             {
[10:58:42.674]                 {
[10:58:42.674]                   {
[10:58:42.674]                     base::local({
[10:58:42.674]                       has_future <- base::requireNamespace("future", 
[10:58:42.674]                         quietly = TRUE)
[10:58:42.674]                       if (has_future) {
[10:58:42.674]                         ns <- base::getNamespace("future")
[10:58:42.674]                         version <- ns[[".package"]][["version"]]
[10:58:42.674]                         if (is.null(version)) 
[10:58:42.674]                           version <- utils::packageVersion("future")
[10:58:42.674]                       }
[10:58:42.674]                       else {
[10:58:42.674]                         version <- NULL
[10:58:42.674]                       }
[10:58:42.674]                       if (!has_future || version < "1.8.0") {
[10:58:42.674]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.674]                           "", base::R.version$version.string), 
[10:58:42.674]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:42.674]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.674]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.674]                             "release", "version")], collapse = " "), 
[10:58:42.674]                           hostname = base::Sys.info()[["nodename"]])
[10:58:42.674]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.674]                           info)
[10:58:42.674]                         info <- base::paste(info, collapse = "; ")
[10:58:42.674]                         if (!has_future) {
[10:58:42.674]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.674]                             info)
[10:58:42.674]                         }
[10:58:42.674]                         else {
[10:58:42.674]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.674]                             info, version)
[10:58:42.674]                         }
[10:58:42.674]                         base::stop(msg)
[10:58:42.674]                       }
[10:58:42.674]                     })
[10:58:42.674]                   }
[10:58:42.674]                   ...future.strategy.old <- future::plan("list")
[10:58:42.674]                   options(future.plan = NULL)
[10:58:42.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.674]                 }
[10:58:42.674]                 ...future.workdir <- getwd()
[10:58:42.674]             }
[10:58:42.674]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.674]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.674]         }
[10:58:42.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:42.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.674]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.674]             base::names(...future.oldOptions))
[10:58:42.674]     }
[10:58:42.674]     if (FALSE) {
[10:58:42.674]     }
[10:58:42.674]     else {
[10:58:42.674]         if (TRUE) {
[10:58:42.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.674]                 open = "w")
[10:58:42.674]         }
[10:58:42.674]         else {
[10:58:42.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.674]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.674]         }
[10:58:42.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.674]             base::sink(type = "output", split = FALSE)
[10:58:42.674]             base::close(...future.stdout)
[10:58:42.674]         }, add = TRUE)
[10:58:42.674]     }
[10:58:42.674]     ...future.frame <- base::sys.nframe()
[10:58:42.674]     ...future.conditions <- base::list()
[10:58:42.674]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.674]     if (FALSE) {
[10:58:42.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.674]     }
[10:58:42.674]     ...future.result <- base::tryCatch({
[10:58:42.674]         base::withCallingHandlers({
[10:58:42.674]             ...future.value <- base::withVisible(base::local({
[10:58:42.674]                 do.call(function(...) {
[10:58:42.674]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.674]                   if (!identical(...future.globals.maxSize.org, 
[10:58:42.674]                     ...future.globals.maxSize)) {
[10:58:42.674]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.674]                     on.exit(options(oopts), add = TRUE)
[10:58:42.674]                   }
[10:58:42.674]                   {
[10:58:42.674]                     lapply(seq_along(...future.elements_ii), 
[10:58:42.674]                       FUN = function(jj) {
[10:58:42.674]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.674]                         ...future.FUN(...future.X_jj, ...)
[10:58:42.674]                       })
[10:58:42.674]                   }
[10:58:42.674]                 }, args = future.call.arguments)
[10:58:42.674]             }))
[10:58:42.674]             future::FutureResult(value = ...future.value$value, 
[10:58:42.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.674]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.674]                     ...future.globalenv.names))
[10:58:42.674]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.674]         }, condition = base::local({
[10:58:42.674]             c <- base::c
[10:58:42.674]             inherits <- base::inherits
[10:58:42.674]             invokeRestart <- base::invokeRestart
[10:58:42.674]             length <- base::length
[10:58:42.674]             list <- base::list
[10:58:42.674]             seq.int <- base::seq.int
[10:58:42.674]             signalCondition <- base::signalCondition
[10:58:42.674]             sys.calls <- base::sys.calls
[10:58:42.674]             `[[` <- base::`[[`
[10:58:42.674]             `+` <- base::`+`
[10:58:42.674]             `<<-` <- base::`<<-`
[10:58:42.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.674]                   3L)]
[10:58:42.674]             }
[10:58:42.674]             function(cond) {
[10:58:42.674]                 is_error <- inherits(cond, "error")
[10:58:42.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.674]                   NULL)
[10:58:42.674]                 if (is_error) {
[10:58:42.674]                   sessionInformation <- function() {
[10:58:42.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.674]                       search = base::search(), system = base::Sys.info())
[10:58:42.674]                   }
[10:58:42.674]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.674]                     cond$call), session = sessionInformation(), 
[10:58:42.674]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.674]                   signalCondition(cond)
[10:58:42.674]                 }
[10:58:42.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.674]                 "immediateCondition"))) {
[10:58:42.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.674]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.674]                   if (TRUE && !signal) {
[10:58:42.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.674]                     {
[10:58:42.674]                       inherits <- base::inherits
[10:58:42.674]                       invokeRestart <- base::invokeRestart
[10:58:42.674]                       is.null <- base::is.null
[10:58:42.674]                       muffled <- FALSE
[10:58:42.674]                       if (inherits(cond, "message")) {
[10:58:42.674]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.674]                         if (muffled) 
[10:58:42.674]                           invokeRestart("muffleMessage")
[10:58:42.674]                       }
[10:58:42.674]                       else if (inherits(cond, "warning")) {
[10:58:42.674]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.674]                         if (muffled) 
[10:58:42.674]                           invokeRestart("muffleWarning")
[10:58:42.674]                       }
[10:58:42.674]                       else if (inherits(cond, "condition")) {
[10:58:42.674]                         if (!is.null(pattern)) {
[10:58:42.674]                           computeRestarts <- base::computeRestarts
[10:58:42.674]                           grepl <- base::grepl
[10:58:42.674]                           restarts <- computeRestarts(cond)
[10:58:42.674]                           for (restart in restarts) {
[10:58:42.674]                             name <- restart$name
[10:58:42.674]                             if (is.null(name)) 
[10:58:42.674]                               next
[10:58:42.674]                             if (!grepl(pattern, name)) 
[10:58:42.674]                               next
[10:58:42.674]                             invokeRestart(restart)
[10:58:42.674]                             muffled <- TRUE
[10:58:42.674]                             break
[10:58:42.674]                           }
[10:58:42.674]                         }
[10:58:42.674]                       }
[10:58:42.674]                       invisible(muffled)
[10:58:42.674]                     }
[10:58:42.674]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.674]                   }
[10:58:42.674]                 }
[10:58:42.674]                 else {
[10:58:42.674]                   if (TRUE) {
[10:58:42.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.674]                     {
[10:58:42.674]                       inherits <- base::inherits
[10:58:42.674]                       invokeRestart <- base::invokeRestart
[10:58:42.674]                       is.null <- base::is.null
[10:58:42.674]                       muffled <- FALSE
[10:58:42.674]                       if (inherits(cond, "message")) {
[10:58:42.674]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.674]                         if (muffled) 
[10:58:42.674]                           invokeRestart("muffleMessage")
[10:58:42.674]                       }
[10:58:42.674]                       else if (inherits(cond, "warning")) {
[10:58:42.674]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.674]                         if (muffled) 
[10:58:42.674]                           invokeRestart("muffleWarning")
[10:58:42.674]                       }
[10:58:42.674]                       else if (inherits(cond, "condition")) {
[10:58:42.674]                         if (!is.null(pattern)) {
[10:58:42.674]                           computeRestarts <- base::computeRestarts
[10:58:42.674]                           grepl <- base::grepl
[10:58:42.674]                           restarts <- computeRestarts(cond)
[10:58:42.674]                           for (restart in restarts) {
[10:58:42.674]                             name <- restart$name
[10:58:42.674]                             if (is.null(name)) 
[10:58:42.674]                               next
[10:58:42.674]                             if (!grepl(pattern, name)) 
[10:58:42.674]                               next
[10:58:42.674]                             invokeRestart(restart)
[10:58:42.674]                             muffled <- TRUE
[10:58:42.674]                             break
[10:58:42.674]                           }
[10:58:42.674]                         }
[10:58:42.674]                       }
[10:58:42.674]                       invisible(muffled)
[10:58:42.674]                     }
[10:58:42.674]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.674]                   }
[10:58:42.674]                 }
[10:58:42.674]             }
[10:58:42.674]         }))
[10:58:42.674]     }, error = function(ex) {
[10:58:42.674]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.674]                 ...future.rng), started = ...future.startTime, 
[10:58:42.674]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.674]             version = "1.8"), class = "FutureResult")
[10:58:42.674]     }, finally = {
[10:58:42.674]         if (!identical(...future.workdir, getwd())) 
[10:58:42.674]             setwd(...future.workdir)
[10:58:42.674]         {
[10:58:42.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.674]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.674]             }
[10:58:42.674]             base::options(...future.oldOptions)
[10:58:42.674]             if (.Platform$OS.type == "windows") {
[10:58:42.674]                 old_names <- names(...future.oldEnvVars)
[10:58:42.674]                 envs <- base::Sys.getenv()
[10:58:42.674]                 names <- names(envs)
[10:58:42.674]                 common <- intersect(names, old_names)
[10:58:42.674]                 added <- setdiff(names, old_names)
[10:58:42.674]                 removed <- setdiff(old_names, names)
[10:58:42.674]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.674]                   envs[common]]
[10:58:42.674]                 NAMES <- toupper(changed)
[10:58:42.674]                 args <- list()
[10:58:42.674]                 for (kk in seq_along(NAMES)) {
[10:58:42.674]                   name <- changed[[kk]]
[10:58:42.674]                   NAME <- NAMES[[kk]]
[10:58:42.674]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.674]                     next
[10:58:42.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.674]                 }
[10:58:42.674]                 NAMES <- toupper(added)
[10:58:42.674]                 for (kk in seq_along(NAMES)) {
[10:58:42.674]                   name <- added[[kk]]
[10:58:42.674]                   NAME <- NAMES[[kk]]
[10:58:42.674]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.674]                     next
[10:58:42.674]                   args[[name]] <- ""
[10:58:42.674]                 }
[10:58:42.674]                 NAMES <- toupper(removed)
[10:58:42.674]                 for (kk in seq_along(NAMES)) {
[10:58:42.674]                   name <- removed[[kk]]
[10:58:42.674]                   NAME <- NAMES[[kk]]
[10:58:42.674]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.674]                     next
[10:58:42.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.674]                 }
[10:58:42.674]                 if (length(args) > 0) 
[10:58:42.674]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.674]             }
[10:58:42.674]             else {
[10:58:42.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.674]             }
[10:58:42.674]             {
[10:58:42.674]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.674]                   0L) {
[10:58:42.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.674]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.674]                   base::options(opts)
[10:58:42.674]                 }
[10:58:42.674]                 {
[10:58:42.674]                   {
[10:58:42.674]                     NULL
[10:58:42.674]                     RNGkind("Mersenne-Twister")
[10:58:42.674]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:42.674]                       inherits = FALSE)
[10:58:42.674]                   }
[10:58:42.674]                   options(future.plan = NULL)
[10:58:42.674]                   if (is.na(NA_character_)) 
[10:58:42.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.674]                     .init = FALSE)
[10:58:42.674]                 }
[10:58:42.674]             }
[10:58:42.674]         }
[10:58:42.674]     })
[10:58:42.674]     if (TRUE) {
[10:58:42.674]         base::sink(type = "output", split = FALSE)
[10:58:42.674]         if (TRUE) {
[10:58:42.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.674]         }
[10:58:42.674]         else {
[10:58:42.674]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.674]         }
[10:58:42.674]         base::close(...future.stdout)
[10:58:42.674]         ...future.stdout <- NULL
[10:58:42.674]     }
[10:58:42.674]     ...future.result$conditions <- ...future.conditions
[10:58:42.674]     ...future.result$finished <- base::Sys.time()
[10:58:42.674]     ...future.result
[10:58:42.674] }
[10:58:42.676] assign_globals() ...
[10:58:42.677] List of 5
[10:58:42.677]  $ ...future.FUN            :function (object, ...)  
[10:58:42.677]  $ future.call.arguments    : list()
[10:58:42.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.677]  $ ...future.elements_ii    :List of 3
[10:58:42.677]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:42.677]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:42.677]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.677]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:42.677]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:42.677]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.677]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:42.677]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:42.677]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.677]  $ ...future.seeds_ii       : NULL
[10:58:42.677]  $ ...future.globals.maxSize: NULL
[10:58:42.677]  - attr(*, "where")=List of 5
[10:58:42.677]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:42.677]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:42.677]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:42.677]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:42.677]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:42.677]  - attr(*, "resolved")= logi FALSE
[10:58:42.677]  - attr(*, "total_size")= num 15670
[10:58:42.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.677]  - attr(*, "already-done")= logi TRUE
[10:58:42.684] - copied ‘...future.FUN’ to environment
[10:58:42.684] - copied ‘future.call.arguments’ to environment
[10:58:42.684] - copied ‘...future.elements_ii’ to environment
[10:58:42.684] - copied ‘...future.seeds_ii’ to environment
[10:58:42.684] - copied ‘...future.globals.maxSize’ to environment
[10:58:42.685] assign_globals() ... done
[10:58:42.685] plan(): Setting new future strategy stack:
[10:58:42.685] List of future strategies:
[10:58:42.685] 1. sequential:
[10:58:42.685]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.685]    - tweaked: FALSE
[10:58:42.685]    - call: NULL
[10:58:42.685] plan(): nbrOfWorkers() = 1
[10:58:42.688] plan(): Setting new future strategy stack:
[10:58:42.688] List of future strategies:
[10:58:42.688] 1. sequential:
[10:58:42.688]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.688]    - tweaked: FALSE
[10:58:42.688]    - call: plan(strategy)
[10:58:42.688] plan(): nbrOfWorkers() = 1
[10:58:42.688] SequentialFuture started (and completed)
[10:58:42.689] - Launch lazy future ... done
[10:58:42.689] run() for ‘SequentialFuture’ ... done
[10:58:42.689] Created future:
[10:58:42.689] SequentialFuture:
[10:58:42.689] Label: ‘future_by-1’
[10:58:42.689] Expression:
[10:58:42.689] {
[10:58:42.689]     do.call(function(...) {
[10:58:42.689]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.689]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.689]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.689]             on.exit(options(oopts), add = TRUE)
[10:58:42.689]         }
[10:58:42.689]         {
[10:58:42.689]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.689]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.689]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.689]             })
[10:58:42.689]         }
[10:58:42.689]     }, args = future.call.arguments)
[10:58:42.689] }
[10:58:42.689] Lazy evaluation: FALSE
[10:58:42.689] Asynchronous evaluation: FALSE
[10:58:42.689] Local evaluation: TRUE
[10:58:42.689] Environment: R_GlobalEnv
[10:58:42.689] Capture standard output: TRUE
[10:58:42.689] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.689] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:42.689] Packages: <none>
[10:58:42.689] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.689] Resolved: TRUE
[10:58:42.689] Value: 1.16 KiB of class ‘list’
[10:58:42.689] Early signaling: FALSE
[10:58:42.689] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:42.689] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.690] Chunk #1 of 1 ... DONE
[10:58:42.690] Launching 1 futures (chunks) ... DONE
[10:58:42.691] Resolving 1 futures (chunks) ...
[10:58:42.691] resolve() on list ...
[10:58:42.691]  recursive: 0
[10:58:42.691]  length: 1
[10:58:42.691] 
[10:58:42.691] resolved() for ‘SequentialFuture’ ...
[10:58:42.691] - state: ‘finished’
[10:58:42.691] - run: TRUE
[10:58:42.691] - result: ‘FutureResult’
[10:58:42.691] resolved() for ‘SequentialFuture’ ... done
[10:58:42.692] Future #1
[10:58:42.692] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:42.692] - nx: 1
[10:58:42.692] - relay: TRUE
[10:58:42.692] - stdout: TRUE
[10:58:42.692] - signal: TRUE
[10:58:42.692] - resignal: FALSE
[10:58:42.692] - force: TRUE
[10:58:42.692] - relayed: [n=1] FALSE
[10:58:42.693] - queued futures: [n=1] FALSE
[10:58:42.693]  - until=1
[10:58:42.693]  - relaying element #1
[10:58:42.693] - relayed: [n=1] TRUE
[10:58:42.693] - queued futures: [n=1] TRUE
[10:58:42.693] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:42.693]  length: 0 (resolved future 1)
[10:58:42.693] Relaying remaining futures
[10:58:42.693] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.694] - nx: 1
[10:58:42.694] - relay: TRUE
[10:58:42.694] - stdout: TRUE
[10:58:42.694] - signal: TRUE
[10:58:42.694] - resignal: FALSE
[10:58:42.694] - force: TRUE
[10:58:42.694] - relayed: [n=1] TRUE
[10:58:42.694] - queued futures: [n=1] TRUE
 - flush all
[10:58:42.694] - relayed: [n=1] TRUE
[10:58:42.694] - queued futures: [n=1] TRUE
[10:58:42.694] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.695] resolve() on list ... DONE
[10:58:42.695]  - Number of value chunks collected: 1
[10:58:42.695] Resolving 1 futures (chunks) ... DONE
[10:58:42.695] Reducing values from 1 chunks ...
[10:58:42.695]  - Number of values collected after concatenation: 3
[10:58:42.695]  - Number of values expected: 3
[10:58:42.695] Reducing values from 1 chunks ... DONE
[10:58:42.695] future_lapply() ... DONE
[10:58:42.695] future_by_internal() ... DONE
[10:58:42.698] future_by_internal() ...
[10:58:42.698] future_lapply() ...
[10:58:42.699] Number of chunks: 1
[10:58:42.699] getGlobalsAndPackagesXApply() ...
[10:58:42.699]  - future.globals: TRUE
[10:58:42.699] getGlobalsAndPackages() ...
[10:58:42.699] Searching for globals...
[10:58:42.700] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:42.700] Searching for globals ... DONE
[10:58:42.700] Resolving globals: FALSE
[10:58:42.701] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:42.701] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:42.701] - globals: [1] ‘FUN’
[10:58:42.701] 
[10:58:42.701] getGlobalsAndPackages() ... DONE
[10:58:42.701]  - globals found/used: [n=1] ‘FUN’
[10:58:42.701]  - needed namespaces: [n=0] 
[10:58:42.701] Finding globals ... DONE
[10:58:42.702]  - use_args: TRUE
[10:58:42.702]  - Getting '...' globals ...
[10:58:42.702] resolve() on list ...
[10:58:42.702]  recursive: 0
[10:58:42.702]  length: 1
[10:58:42.702]  elements: ‘...’
[10:58:42.702]  length: 0 (resolved future 1)
[10:58:42.702] resolve() on list ... DONE
[10:58:42.702]    - '...' content: [n=1] ‘digits’
[10:58:42.703] List of 1
[10:58:42.703]  $ ...:List of 1
[10:58:42.703]   ..$ digits: int 2
[10:58:42.703]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.703]  - attr(*, "where")=List of 1
[10:58:42.703]   ..$ ...:<environment: 0x55974cfe1940> 
[10:58:42.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.703]  - attr(*, "resolved")= logi TRUE
[10:58:42.703]  - attr(*, "total_size")= num NA
[10:58:42.705]  - Getting '...' globals ... DONE
[10:58:42.706] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:42.706] List of 2
[10:58:42.706]  $ ...future.FUN:function (object, ...)  
[10:58:42.706]  $ ...          :List of 1
[10:58:42.706]   ..$ digits: int 2
[10:58:42.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.706]  - attr(*, "where")=List of 2
[10:58:42.706]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.706]   ..$ ...          :<environment: 0x55974cfe1940> 
[10:58:42.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.706]  - attr(*, "resolved")= logi FALSE
[10:58:42.706]  - attr(*, "total_size")= num 13284
[10:58:42.709] Packages to be attached in all futures: [n=0] 
[10:58:42.709] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.709] Number of futures (= number of chunks): 1
[10:58:42.709] Launching 1 futures (chunks) ...
[10:58:42.709] Chunk #1 of 1 ...
[10:58:42.709]  - Finding globals in 'X' for chunk #1 ...
[10:58:42.709] getGlobalsAndPackages() ...
[10:58:42.710] Searching for globals...
[10:58:42.710] 
[10:58:42.710] Searching for globals ... DONE
[10:58:42.710] - globals: [0] <none>
[10:58:42.710] getGlobalsAndPackages() ... DONE
[10:58:42.710]    + additional globals found: [n=0] 
[10:58:42.710]    + additional namespaces needed: [n=0] 
[10:58:42.710]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:42.710]  - seeds: <none>
[10:58:42.710]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.711] getGlobalsAndPackages() ...
[10:58:42.711] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.711] Resolving globals: FALSE
[10:58:42.711] Tweak future expression to call with '...' arguments ...
[10:58:42.711] {
[10:58:42.711]     do.call(function(...) {
[10:58:42.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.711]             on.exit(options(oopts), add = TRUE)
[10:58:42.711]         }
[10:58:42.711]         {
[10:58:42.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.711]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.711]             })
[10:58:42.711]         }
[10:58:42.711]     }, args = future.call.arguments)
[10:58:42.711] }
[10:58:42.711] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.712] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.712] 
[10:58:42.712] getGlobalsAndPackages() ... DONE
[10:58:42.712] run() for ‘Future’ ...
[10:58:42.712] - state: ‘created’
[10:58:42.712] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:42.713] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:42.713]   - Field: ‘label’
[10:58:42.713]   - Field: ‘local’
[10:58:42.713]   - Field: ‘owner’
[10:58:42.713]   - Field: ‘envir’
[10:58:42.713]   - Field: ‘packages’
[10:58:42.713]   - Field: ‘gc’
[10:58:42.713]   - Field: ‘conditions’
[10:58:42.713]   - Field: ‘expr’
[10:58:42.714]   - Field: ‘uuid’
[10:58:42.714]   - Field: ‘seed’
[10:58:42.714]   - Field: ‘version’
[10:58:42.714]   - Field: ‘result’
[10:58:42.714]   - Field: ‘asynchronous’
[10:58:42.714]   - Field: ‘calls’
[10:58:42.714]   - Field: ‘globals’
[10:58:42.714]   - Field: ‘stdout’
[10:58:42.714]   - Field: ‘earlySignal’
[10:58:42.714]   - Field: ‘lazy’
[10:58:42.714]   - Field: ‘state’
[10:58:42.714] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:42.715] - Launch lazy future ...
[10:58:42.715] Packages needed by the future expression (n = 0): <none>
[10:58:42.715] Packages needed by future strategies (n = 0): <none>
[10:58:42.715] {
[10:58:42.715]     {
[10:58:42.715]         {
[10:58:42.715]             ...future.startTime <- base::Sys.time()
[10:58:42.715]             {
[10:58:42.715]                 {
[10:58:42.715]                   {
[10:58:42.715]                     base::local({
[10:58:42.715]                       has_future <- base::requireNamespace("future", 
[10:58:42.715]                         quietly = TRUE)
[10:58:42.715]                       if (has_future) {
[10:58:42.715]                         ns <- base::getNamespace("future")
[10:58:42.715]                         version <- ns[[".package"]][["version"]]
[10:58:42.715]                         if (is.null(version)) 
[10:58:42.715]                           version <- utils::packageVersion("future")
[10:58:42.715]                       }
[10:58:42.715]                       else {
[10:58:42.715]                         version <- NULL
[10:58:42.715]                       }
[10:58:42.715]                       if (!has_future || version < "1.8.0") {
[10:58:42.715]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.715]                           "", base::R.version$version.string), 
[10:58:42.715]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:42.715]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.715]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.715]                             "release", "version")], collapse = " "), 
[10:58:42.715]                           hostname = base::Sys.info()[["nodename"]])
[10:58:42.715]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.715]                           info)
[10:58:42.715]                         info <- base::paste(info, collapse = "; ")
[10:58:42.715]                         if (!has_future) {
[10:58:42.715]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.715]                             info)
[10:58:42.715]                         }
[10:58:42.715]                         else {
[10:58:42.715]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.715]                             info, version)
[10:58:42.715]                         }
[10:58:42.715]                         base::stop(msg)
[10:58:42.715]                       }
[10:58:42.715]                     })
[10:58:42.715]                   }
[10:58:42.715]                   ...future.strategy.old <- future::plan("list")
[10:58:42.715]                   options(future.plan = NULL)
[10:58:42.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.715]                 }
[10:58:42.715]                 ...future.workdir <- getwd()
[10:58:42.715]             }
[10:58:42.715]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.715]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.715]         }
[10:58:42.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:42.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.715]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.715]             base::names(...future.oldOptions))
[10:58:42.715]     }
[10:58:42.715]     if (FALSE) {
[10:58:42.715]     }
[10:58:42.715]     else {
[10:58:42.715]         if (TRUE) {
[10:58:42.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.715]                 open = "w")
[10:58:42.715]         }
[10:58:42.715]         else {
[10:58:42.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.715]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.715]         }
[10:58:42.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.715]             base::sink(type = "output", split = FALSE)
[10:58:42.715]             base::close(...future.stdout)
[10:58:42.715]         }, add = TRUE)
[10:58:42.715]     }
[10:58:42.715]     ...future.frame <- base::sys.nframe()
[10:58:42.715]     ...future.conditions <- base::list()
[10:58:42.715]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.715]     if (FALSE) {
[10:58:42.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.715]     }
[10:58:42.715]     ...future.result <- base::tryCatch({
[10:58:42.715]         base::withCallingHandlers({
[10:58:42.715]             ...future.value <- base::withVisible(base::local({
[10:58:42.715]                 do.call(function(...) {
[10:58:42.715]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.715]                   if (!identical(...future.globals.maxSize.org, 
[10:58:42.715]                     ...future.globals.maxSize)) {
[10:58:42.715]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.715]                     on.exit(options(oopts), add = TRUE)
[10:58:42.715]                   }
[10:58:42.715]                   {
[10:58:42.715]                     lapply(seq_along(...future.elements_ii), 
[10:58:42.715]                       FUN = function(jj) {
[10:58:42.715]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.715]                         ...future.FUN(...future.X_jj, ...)
[10:58:42.715]                       })
[10:58:42.715]                   }
[10:58:42.715]                 }, args = future.call.arguments)
[10:58:42.715]             }))
[10:58:42.715]             future::FutureResult(value = ...future.value$value, 
[10:58:42.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.715]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.715]                     ...future.globalenv.names))
[10:58:42.715]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.715]         }, condition = base::local({
[10:58:42.715]             c <- base::c
[10:58:42.715]             inherits <- base::inherits
[10:58:42.715]             invokeRestart <- base::invokeRestart
[10:58:42.715]             length <- base::length
[10:58:42.715]             list <- base::list
[10:58:42.715]             seq.int <- base::seq.int
[10:58:42.715]             signalCondition <- base::signalCondition
[10:58:42.715]             sys.calls <- base::sys.calls
[10:58:42.715]             `[[` <- base::`[[`
[10:58:42.715]             `+` <- base::`+`
[10:58:42.715]             `<<-` <- base::`<<-`
[10:58:42.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.715]                   3L)]
[10:58:42.715]             }
[10:58:42.715]             function(cond) {
[10:58:42.715]                 is_error <- inherits(cond, "error")
[10:58:42.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.715]                   NULL)
[10:58:42.715]                 if (is_error) {
[10:58:42.715]                   sessionInformation <- function() {
[10:58:42.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.715]                       search = base::search(), system = base::Sys.info())
[10:58:42.715]                   }
[10:58:42.715]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.715]                     cond$call), session = sessionInformation(), 
[10:58:42.715]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.715]                   signalCondition(cond)
[10:58:42.715]                 }
[10:58:42.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.715]                 "immediateCondition"))) {
[10:58:42.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.715]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.715]                   if (TRUE && !signal) {
[10:58:42.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.715]                     {
[10:58:42.715]                       inherits <- base::inherits
[10:58:42.715]                       invokeRestart <- base::invokeRestart
[10:58:42.715]                       is.null <- base::is.null
[10:58:42.715]                       muffled <- FALSE
[10:58:42.715]                       if (inherits(cond, "message")) {
[10:58:42.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.715]                         if (muffled) 
[10:58:42.715]                           invokeRestart("muffleMessage")
[10:58:42.715]                       }
[10:58:42.715]                       else if (inherits(cond, "warning")) {
[10:58:42.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.715]                         if (muffled) 
[10:58:42.715]                           invokeRestart("muffleWarning")
[10:58:42.715]                       }
[10:58:42.715]                       else if (inherits(cond, "condition")) {
[10:58:42.715]                         if (!is.null(pattern)) {
[10:58:42.715]                           computeRestarts <- base::computeRestarts
[10:58:42.715]                           grepl <- base::grepl
[10:58:42.715]                           restarts <- computeRestarts(cond)
[10:58:42.715]                           for (restart in restarts) {
[10:58:42.715]                             name <- restart$name
[10:58:42.715]                             if (is.null(name)) 
[10:58:42.715]                               next
[10:58:42.715]                             if (!grepl(pattern, name)) 
[10:58:42.715]                               next
[10:58:42.715]                             invokeRestart(restart)
[10:58:42.715]                             muffled <- TRUE
[10:58:42.715]                             break
[10:58:42.715]                           }
[10:58:42.715]                         }
[10:58:42.715]                       }
[10:58:42.715]                       invisible(muffled)
[10:58:42.715]                     }
[10:58:42.715]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.715]                   }
[10:58:42.715]                 }
[10:58:42.715]                 else {
[10:58:42.715]                   if (TRUE) {
[10:58:42.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.715]                     {
[10:58:42.715]                       inherits <- base::inherits
[10:58:42.715]                       invokeRestart <- base::invokeRestart
[10:58:42.715]                       is.null <- base::is.null
[10:58:42.715]                       muffled <- FALSE
[10:58:42.715]                       if (inherits(cond, "message")) {
[10:58:42.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.715]                         if (muffled) 
[10:58:42.715]                           invokeRestart("muffleMessage")
[10:58:42.715]                       }
[10:58:42.715]                       else if (inherits(cond, "warning")) {
[10:58:42.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.715]                         if (muffled) 
[10:58:42.715]                           invokeRestart("muffleWarning")
[10:58:42.715]                       }
[10:58:42.715]                       else if (inherits(cond, "condition")) {
[10:58:42.715]                         if (!is.null(pattern)) {
[10:58:42.715]                           computeRestarts <- base::computeRestarts
[10:58:42.715]                           grepl <- base::grepl
[10:58:42.715]                           restarts <- computeRestarts(cond)
[10:58:42.715]                           for (restart in restarts) {
[10:58:42.715]                             name <- restart$name
[10:58:42.715]                             if (is.null(name)) 
[10:58:42.715]                               next
[10:58:42.715]                             if (!grepl(pattern, name)) 
[10:58:42.715]                               next
[10:58:42.715]                             invokeRestart(restart)
[10:58:42.715]                             muffled <- TRUE
[10:58:42.715]                             break
[10:58:42.715]                           }
[10:58:42.715]                         }
[10:58:42.715]                       }
[10:58:42.715]                       invisible(muffled)
[10:58:42.715]                     }
[10:58:42.715]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.715]                   }
[10:58:42.715]                 }
[10:58:42.715]             }
[10:58:42.715]         }))
[10:58:42.715]     }, error = function(ex) {
[10:58:42.715]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.715]                 ...future.rng), started = ...future.startTime, 
[10:58:42.715]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.715]             version = "1.8"), class = "FutureResult")
[10:58:42.715]     }, finally = {
[10:58:42.715]         if (!identical(...future.workdir, getwd())) 
[10:58:42.715]             setwd(...future.workdir)
[10:58:42.715]         {
[10:58:42.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.715]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.715]             }
[10:58:42.715]             base::options(...future.oldOptions)
[10:58:42.715]             if (.Platform$OS.type == "windows") {
[10:58:42.715]                 old_names <- names(...future.oldEnvVars)
[10:58:42.715]                 envs <- base::Sys.getenv()
[10:58:42.715]                 names <- names(envs)
[10:58:42.715]                 common <- intersect(names, old_names)
[10:58:42.715]                 added <- setdiff(names, old_names)
[10:58:42.715]                 removed <- setdiff(old_names, names)
[10:58:42.715]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.715]                   envs[common]]
[10:58:42.715]                 NAMES <- toupper(changed)
[10:58:42.715]                 args <- list()
[10:58:42.715]                 for (kk in seq_along(NAMES)) {
[10:58:42.715]                   name <- changed[[kk]]
[10:58:42.715]                   NAME <- NAMES[[kk]]
[10:58:42.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.715]                     next
[10:58:42.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.715]                 }
[10:58:42.715]                 NAMES <- toupper(added)
[10:58:42.715]                 for (kk in seq_along(NAMES)) {
[10:58:42.715]                   name <- added[[kk]]
[10:58:42.715]                   NAME <- NAMES[[kk]]
[10:58:42.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.715]                     next
[10:58:42.715]                   args[[name]] <- ""
[10:58:42.715]                 }
[10:58:42.715]                 NAMES <- toupper(removed)
[10:58:42.715]                 for (kk in seq_along(NAMES)) {
[10:58:42.715]                   name <- removed[[kk]]
[10:58:42.715]                   NAME <- NAMES[[kk]]
[10:58:42.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.715]                     next
[10:58:42.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.715]                 }
[10:58:42.715]                 if (length(args) > 0) 
[10:58:42.715]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.715]             }
[10:58:42.715]             else {
[10:58:42.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.715]             }
[10:58:42.715]             {
[10:58:42.715]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.715]                   0L) {
[10:58:42.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.715]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.715]                   base::options(opts)
[10:58:42.715]                 }
[10:58:42.715]                 {
[10:58:42.715]                   {
[10:58:42.715]                     NULL
[10:58:42.715]                     RNGkind("Mersenne-Twister")
[10:58:42.715]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:42.715]                       inherits = FALSE)
[10:58:42.715]                   }
[10:58:42.715]                   options(future.plan = NULL)
[10:58:42.715]                   if (is.na(NA_character_)) 
[10:58:42.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.715]                     .init = FALSE)
[10:58:42.715]                 }
[10:58:42.715]             }
[10:58:42.715]         }
[10:58:42.715]     })
[10:58:42.715]     if (TRUE) {
[10:58:42.715]         base::sink(type = "output", split = FALSE)
[10:58:42.715]         if (TRUE) {
[10:58:42.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.715]         }
[10:58:42.715]         else {
[10:58:42.715]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.715]         }
[10:58:42.715]         base::close(...future.stdout)
[10:58:42.715]         ...future.stdout <- NULL
[10:58:42.715]     }
[10:58:42.715]     ...future.result$conditions <- ...future.conditions
[10:58:42.715]     ...future.result$finished <- base::Sys.time()
[10:58:42.715]     ...future.result
[10:58:42.715] }
[10:58:42.717] assign_globals() ...
[10:58:42.717] List of 5
[10:58:42.717]  $ ...future.FUN            :function (object, ...)  
[10:58:42.717]  $ future.call.arguments    :List of 1
[10:58:42.717]   ..$ digits: int 2
[10:58:42.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.717]  $ ...future.elements_ii    :List of 6
[10:58:42.717]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:58:42.717]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:58:42.717]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:58:42.717]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:58:42.717]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:58:42.717]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:58:42.717]  $ ...future.seeds_ii       : NULL
[10:58:42.717]  $ ...future.globals.maxSize: NULL
[10:58:42.717]  - attr(*, "where")=List of 5
[10:58:42.717]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:42.717]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:42.717]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:42.717]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:42.717]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:42.717]  - attr(*, "resolved")= logi FALSE
[10:58:42.717]  - attr(*, "total_size")= num 13284
[10:58:42.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.717]  - attr(*, "already-done")= logi TRUE
[10:58:42.725] - copied ‘...future.FUN’ to environment
[10:58:42.725] - copied ‘future.call.arguments’ to environment
[10:58:42.725] - copied ‘...future.elements_ii’ to environment
[10:58:42.726] - copied ‘...future.seeds_ii’ to environment
[10:58:42.726] - copied ‘...future.globals.maxSize’ to environment
[10:58:42.726] assign_globals() ... done
[10:58:42.726] plan(): Setting new future strategy stack:
[10:58:42.726] List of future strategies:
[10:58:42.726] 1. sequential:
[10:58:42.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.726]    - tweaked: FALSE
[10:58:42.726]    - call: NULL
[10:58:42.727] plan(): nbrOfWorkers() = 1
[10:58:42.728] plan(): Setting new future strategy stack:
[10:58:42.728] List of future strategies:
[10:58:42.728] 1. sequential:
[10:58:42.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.728]    - tweaked: FALSE
[10:58:42.728]    - call: plan(strategy)
[10:58:42.729] plan(): nbrOfWorkers() = 1
[10:58:42.729] SequentialFuture started (and completed)
[10:58:42.729] - Launch lazy future ... done
[10:58:42.729] run() for ‘SequentialFuture’ ... done
[10:58:42.729] Created future:
[10:58:42.729] SequentialFuture:
[10:58:42.729] Label: ‘future_by-1’
[10:58:42.729] Expression:
[10:58:42.729] {
[10:58:42.729]     do.call(function(...) {
[10:58:42.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.729]             on.exit(options(oopts), add = TRUE)
[10:58:42.729]         }
[10:58:42.729]         {
[10:58:42.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.729]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.729]             })
[10:58:42.729]         }
[10:58:42.729]     }, args = future.call.arguments)
[10:58:42.729] }
[10:58:42.729] Lazy evaluation: FALSE
[10:58:42.729] Asynchronous evaluation: FALSE
[10:58:42.729] Local evaluation: TRUE
[10:58:42.729] Environment: R_GlobalEnv
[10:58:42.729] Capture standard output: TRUE
[10:58:42.729] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.729] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:42.729] Packages: <none>
[10:58:42.729] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.729] Resolved: TRUE
[10:58:42.729] Value: 1.27 KiB of class ‘list’
[10:58:42.729] Early signaling: FALSE
[10:58:42.729] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:42.729] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.730] Chunk #1 of 1 ... DONE
[10:58:42.730] Launching 1 futures (chunks) ... DONE
[10:58:42.730] Resolving 1 futures (chunks) ...
[10:58:42.730] resolve() on list ...
[10:58:42.730]  recursive: 0
[10:58:42.730]  length: 1
[10:58:42.730] 
[10:58:42.731] resolved() for ‘SequentialFuture’ ...
[10:58:42.731] - state: ‘finished’
[10:58:42.731] - run: TRUE
[10:58:42.731] - result: ‘FutureResult’
[10:58:42.731] resolved() for ‘SequentialFuture’ ... done
[10:58:42.731] Future #1
[10:58:42.731] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:42.731] - nx: 1
[10:58:42.731] - relay: TRUE
[10:58:42.731] - stdout: TRUE
[10:58:42.731] - signal: TRUE
[10:58:42.732] - resignal: FALSE
[10:58:42.732] - force: TRUE
[10:58:42.732] - relayed: [n=1] FALSE
[10:58:42.732] - queued futures: [n=1] FALSE
[10:58:42.732]  - until=1
[10:58:42.732]  - relaying element #1
[10:58:42.732] - relayed: [n=1] TRUE
[10:58:42.732] - queued futures: [n=1] TRUE
[10:58:42.732] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:42.732]  length: 0 (resolved future 1)
[10:58:42.733] Relaying remaining futures
[10:58:42.733] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.733] - nx: 1
[10:58:42.733] - relay: TRUE
[10:58:42.733] - stdout: TRUE
[10:58:42.733] - signal: TRUE
[10:58:42.733] - resignal: FALSE
[10:58:42.733] - force: TRUE
[10:58:42.733] - relayed: [n=1] TRUE
[10:58:42.733] - queued futures: [n=1] TRUE
 - flush all
[10:58:42.733] - relayed: [n=1] TRUE
[10:58:42.733] - queued futures: [n=1] TRUE
[10:58:42.733] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.734] resolve() on list ... DONE
[10:58:42.734]  - Number of value chunks collected: 1
[10:58:42.734] Resolving 1 futures (chunks) ... DONE
[10:58:42.734] Reducing values from 1 chunks ...
[10:58:42.734]  - Number of values collected after concatenation: 6
[10:58:42.734]  - Number of values expected: 6
[10:58:42.734] Reducing values from 1 chunks ... DONE
[10:58:42.734] future_lapply() ... DONE
[10:58:42.734] future_by_internal() ... DONE
[10:58:42.737] future_by_internal() ...
[10:58:42.738] future_lapply() ...
[10:58:42.739] Number of chunks: 1
[10:58:42.739] getGlobalsAndPackagesXApply() ...
[10:58:42.739]  - future.globals: TRUE
[10:58:42.739] getGlobalsAndPackages() ...
[10:58:42.739] Searching for globals...
[10:58:42.742] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:42.742] Searching for globals ... DONE
[10:58:42.742] Resolving globals: FALSE
[10:58:42.742] The total size of the 1 globals is 762 bytes (762 bytes)
[10:58:42.743] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:58:42.743] - globals: [1] ‘FUN’
[10:58:42.743] - packages: [1] ‘stats’
[10:58:42.743] getGlobalsAndPackages() ... DONE
[10:58:42.743]  - globals found/used: [n=1] ‘FUN’
[10:58:42.743]  - needed namespaces: [n=1] ‘stats’
[10:58:42.743] Finding globals ... DONE
[10:58:42.744]  - use_args: TRUE
[10:58:42.744]  - Getting '...' globals ...
[10:58:42.744] resolve() on list ...
[10:58:42.744]  recursive: 0
[10:58:42.744]  length: 1
[10:58:42.744]  elements: ‘...’
[10:58:42.744]  length: 0 (resolved future 1)
[10:58:42.744] resolve() on list ... DONE
[10:58:42.744]    - '...' content: [n=1] ‘singular.ok’
[10:58:42.745] List of 1
[10:58:42.745]  $ ...:List of 1
[10:58:42.745]   ..$ singular.ok: logi FALSE
[10:58:42.745]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.745]  - attr(*, "where")=List of 1
[10:58:42.745]   ..$ ...:<environment: 0x55974def3868> 
[10:58:42.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.745]  - attr(*, "resolved")= logi TRUE
[10:58:42.745]  - attr(*, "total_size")= num NA
[10:58:42.747]  - Getting '...' globals ... DONE
[10:58:42.748] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:42.748] List of 2
[10:58:42.748]  $ ...future.FUN:function (x, ...)  
[10:58:42.748]  $ ...          :List of 1
[10:58:42.748]   ..$ singular.ok: logi FALSE
[10:58:42.748]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.748]  - attr(*, "where")=List of 2
[10:58:42.748]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.748]   ..$ ...          :<environment: 0x55974def3868> 
[10:58:42.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.748]  - attr(*, "resolved")= logi FALSE
[10:58:42.748]  - attr(*, "total_size")= num 19977
[10:58:42.751] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:42.751] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.751] Number of futures (= number of chunks): 1
[10:58:42.751] Launching 1 futures (chunks) ...
[10:58:42.751] Chunk #1 of 1 ...
[10:58:42.751]  - Finding globals in 'X' for chunk #1 ...
[10:58:42.751] getGlobalsAndPackages() ...
[10:58:42.751] Searching for globals...
[10:58:42.752] 
[10:58:42.752] Searching for globals ... DONE
[10:58:42.752] - globals: [0] <none>
[10:58:42.752] getGlobalsAndPackages() ... DONE
[10:58:42.752]    + additional globals found: [n=0] 
[10:58:42.752]    + additional namespaces needed: [n=0] 
[10:58:42.752]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:42.753]  - seeds: <none>
[10:58:42.753]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.753] getGlobalsAndPackages() ...
[10:58:42.753] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.753] Resolving globals: FALSE
[10:58:42.753] Tweak future expression to call with '...' arguments ...
[10:58:42.753] {
[10:58:42.753]     do.call(function(...) {
[10:58:42.753]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.753]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.753]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.753]             on.exit(options(oopts), add = TRUE)
[10:58:42.753]         }
[10:58:42.753]         {
[10:58:42.753]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.753]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.753]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.753]             })
[10:58:42.753]         }
[10:58:42.753]     }, args = future.call.arguments)
[10:58:42.753] }
[10:58:42.753] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.754] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.754] 
[10:58:42.754] getGlobalsAndPackages() ... DONE
[10:58:42.754] run() for ‘Future’ ...
[10:58:42.754] - state: ‘created’
[10:58:42.754] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:42.755] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:42.755]   - Field: ‘label’
[10:58:42.755]   - Field: ‘local’
[10:58:42.755]   - Field: ‘owner’
[10:58:42.755]   - Field: ‘envir’
[10:58:42.755]   - Field: ‘packages’
[10:58:42.755]   - Field: ‘gc’
[10:58:42.755]   - Field: ‘conditions’
[10:58:42.755]   - Field: ‘expr’
[10:58:42.756]   - Field: ‘uuid’
[10:58:42.756]   - Field: ‘seed’
[10:58:42.756]   - Field: ‘version’
[10:58:42.756]   - Field: ‘result’
[10:58:42.756]   - Field: ‘asynchronous’
[10:58:42.756]   - Field: ‘calls’
[10:58:42.756]   - Field: ‘globals’
[10:58:42.756]   - Field: ‘stdout’
[10:58:42.756]   - Field: ‘earlySignal’
[10:58:42.756]   - Field: ‘lazy’
[10:58:42.756]   - Field: ‘state’
[10:58:42.756] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:42.757] - Launch lazy future ...
[10:58:42.757] Packages needed by the future expression (n = 1): ‘stats’
[10:58:42.757] Packages needed by future strategies (n = 0): <none>
[10:58:42.757] {
[10:58:42.757]     {
[10:58:42.757]         {
[10:58:42.757]             ...future.startTime <- base::Sys.time()
[10:58:42.757]             {
[10:58:42.757]                 {
[10:58:42.757]                   {
[10:58:42.757]                     {
[10:58:42.757]                       base::local({
[10:58:42.757]                         has_future <- base::requireNamespace("future", 
[10:58:42.757]                           quietly = TRUE)
[10:58:42.757]                         if (has_future) {
[10:58:42.757]                           ns <- base::getNamespace("future")
[10:58:42.757]                           version <- ns[[".package"]][["version"]]
[10:58:42.757]                           if (is.null(version)) 
[10:58:42.757]                             version <- utils::packageVersion("future")
[10:58:42.757]                         }
[10:58:42.757]                         else {
[10:58:42.757]                           version <- NULL
[10:58:42.757]                         }
[10:58:42.757]                         if (!has_future || version < "1.8.0") {
[10:58:42.757]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.757]                             "", base::R.version$version.string), 
[10:58:42.757]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:42.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.757]                               "release", "version")], collapse = " "), 
[10:58:42.757]                             hostname = base::Sys.info()[["nodename"]])
[10:58:42.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.757]                             info)
[10:58:42.757]                           info <- base::paste(info, collapse = "; ")
[10:58:42.757]                           if (!has_future) {
[10:58:42.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.757]                               info)
[10:58:42.757]                           }
[10:58:42.757]                           else {
[10:58:42.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.757]                               info, version)
[10:58:42.757]                           }
[10:58:42.757]                           base::stop(msg)
[10:58:42.757]                         }
[10:58:42.757]                       })
[10:58:42.757]                     }
[10:58:42.757]                     base::local({
[10:58:42.757]                       for (pkg in "stats") {
[10:58:42.757]                         base::loadNamespace(pkg)
[10:58:42.757]                         base::library(pkg, character.only = TRUE)
[10:58:42.757]                       }
[10:58:42.757]                     })
[10:58:42.757]                   }
[10:58:42.757]                   ...future.strategy.old <- future::plan("list")
[10:58:42.757]                   options(future.plan = NULL)
[10:58:42.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.757]                 }
[10:58:42.757]                 ...future.workdir <- getwd()
[10:58:42.757]             }
[10:58:42.757]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.757]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.757]         }
[10:58:42.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:42.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.757]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.757]             base::names(...future.oldOptions))
[10:58:42.757]     }
[10:58:42.757]     if (FALSE) {
[10:58:42.757]     }
[10:58:42.757]     else {
[10:58:42.757]         if (TRUE) {
[10:58:42.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.757]                 open = "w")
[10:58:42.757]         }
[10:58:42.757]         else {
[10:58:42.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.757]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.757]         }
[10:58:42.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.757]             base::sink(type = "output", split = FALSE)
[10:58:42.757]             base::close(...future.stdout)
[10:58:42.757]         }, add = TRUE)
[10:58:42.757]     }
[10:58:42.757]     ...future.frame <- base::sys.nframe()
[10:58:42.757]     ...future.conditions <- base::list()
[10:58:42.757]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.757]     if (FALSE) {
[10:58:42.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.757]     }
[10:58:42.757]     ...future.result <- base::tryCatch({
[10:58:42.757]         base::withCallingHandlers({
[10:58:42.757]             ...future.value <- base::withVisible(base::local({
[10:58:42.757]                 do.call(function(...) {
[10:58:42.757]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.757]                   if (!identical(...future.globals.maxSize.org, 
[10:58:42.757]                     ...future.globals.maxSize)) {
[10:58:42.757]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.757]                     on.exit(options(oopts), add = TRUE)
[10:58:42.757]                   }
[10:58:42.757]                   {
[10:58:42.757]                     lapply(seq_along(...future.elements_ii), 
[10:58:42.757]                       FUN = function(jj) {
[10:58:42.757]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.757]                         ...future.FUN(...future.X_jj, ...)
[10:58:42.757]                       })
[10:58:42.757]                   }
[10:58:42.757]                 }, args = future.call.arguments)
[10:58:42.757]             }))
[10:58:42.757]             future::FutureResult(value = ...future.value$value, 
[10:58:42.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.757]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.757]                     ...future.globalenv.names))
[10:58:42.757]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.757]         }, condition = base::local({
[10:58:42.757]             c <- base::c
[10:58:42.757]             inherits <- base::inherits
[10:58:42.757]             invokeRestart <- base::invokeRestart
[10:58:42.757]             length <- base::length
[10:58:42.757]             list <- base::list
[10:58:42.757]             seq.int <- base::seq.int
[10:58:42.757]             signalCondition <- base::signalCondition
[10:58:42.757]             sys.calls <- base::sys.calls
[10:58:42.757]             `[[` <- base::`[[`
[10:58:42.757]             `+` <- base::`+`
[10:58:42.757]             `<<-` <- base::`<<-`
[10:58:42.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.757]                   3L)]
[10:58:42.757]             }
[10:58:42.757]             function(cond) {
[10:58:42.757]                 is_error <- inherits(cond, "error")
[10:58:42.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.757]                   NULL)
[10:58:42.757]                 if (is_error) {
[10:58:42.757]                   sessionInformation <- function() {
[10:58:42.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.757]                       search = base::search(), system = base::Sys.info())
[10:58:42.757]                   }
[10:58:42.757]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.757]                     cond$call), session = sessionInformation(), 
[10:58:42.757]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.757]                   signalCondition(cond)
[10:58:42.757]                 }
[10:58:42.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.757]                 "immediateCondition"))) {
[10:58:42.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.757]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.757]                   if (TRUE && !signal) {
[10:58:42.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.757]                     {
[10:58:42.757]                       inherits <- base::inherits
[10:58:42.757]                       invokeRestart <- base::invokeRestart
[10:58:42.757]                       is.null <- base::is.null
[10:58:42.757]                       muffled <- FALSE
[10:58:42.757]                       if (inherits(cond, "message")) {
[10:58:42.757]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.757]                         if (muffled) 
[10:58:42.757]                           invokeRestart("muffleMessage")
[10:58:42.757]                       }
[10:58:42.757]                       else if (inherits(cond, "warning")) {
[10:58:42.757]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.757]                         if (muffled) 
[10:58:42.757]                           invokeRestart("muffleWarning")
[10:58:42.757]                       }
[10:58:42.757]                       else if (inherits(cond, "condition")) {
[10:58:42.757]                         if (!is.null(pattern)) {
[10:58:42.757]                           computeRestarts <- base::computeRestarts
[10:58:42.757]                           grepl <- base::grepl
[10:58:42.757]                           restarts <- computeRestarts(cond)
[10:58:42.757]                           for (restart in restarts) {
[10:58:42.757]                             name <- restart$name
[10:58:42.757]                             if (is.null(name)) 
[10:58:42.757]                               next
[10:58:42.757]                             if (!grepl(pattern, name)) 
[10:58:42.757]                               next
[10:58:42.757]                             invokeRestart(restart)
[10:58:42.757]                             muffled <- TRUE
[10:58:42.757]                             break
[10:58:42.757]                           }
[10:58:42.757]                         }
[10:58:42.757]                       }
[10:58:42.757]                       invisible(muffled)
[10:58:42.757]                     }
[10:58:42.757]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.757]                   }
[10:58:42.757]                 }
[10:58:42.757]                 else {
[10:58:42.757]                   if (TRUE) {
[10:58:42.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.757]                     {
[10:58:42.757]                       inherits <- base::inherits
[10:58:42.757]                       invokeRestart <- base::invokeRestart
[10:58:42.757]                       is.null <- base::is.null
[10:58:42.757]                       muffled <- FALSE
[10:58:42.757]                       if (inherits(cond, "message")) {
[10:58:42.757]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.757]                         if (muffled) 
[10:58:42.757]                           invokeRestart("muffleMessage")
[10:58:42.757]                       }
[10:58:42.757]                       else if (inherits(cond, "warning")) {
[10:58:42.757]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.757]                         if (muffled) 
[10:58:42.757]                           invokeRestart("muffleWarning")
[10:58:42.757]                       }
[10:58:42.757]                       else if (inherits(cond, "condition")) {
[10:58:42.757]                         if (!is.null(pattern)) {
[10:58:42.757]                           computeRestarts <- base::computeRestarts
[10:58:42.757]                           grepl <- base::grepl
[10:58:42.757]                           restarts <- computeRestarts(cond)
[10:58:42.757]                           for (restart in restarts) {
[10:58:42.757]                             name <- restart$name
[10:58:42.757]                             if (is.null(name)) 
[10:58:42.757]                               next
[10:58:42.757]                             if (!grepl(pattern, name)) 
[10:58:42.757]                               next
[10:58:42.757]                             invokeRestart(restart)
[10:58:42.757]                             muffled <- TRUE
[10:58:42.757]                             break
[10:58:42.757]                           }
[10:58:42.757]                         }
[10:58:42.757]                       }
[10:58:42.757]                       invisible(muffled)
[10:58:42.757]                     }
[10:58:42.757]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.757]                   }
[10:58:42.757]                 }
[10:58:42.757]             }
[10:58:42.757]         }))
[10:58:42.757]     }, error = function(ex) {
[10:58:42.757]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.757]                 ...future.rng), started = ...future.startTime, 
[10:58:42.757]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.757]             version = "1.8"), class = "FutureResult")
[10:58:42.757]     }, finally = {
[10:58:42.757]         if (!identical(...future.workdir, getwd())) 
[10:58:42.757]             setwd(...future.workdir)
[10:58:42.757]         {
[10:58:42.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.757]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.757]             }
[10:58:42.757]             base::options(...future.oldOptions)
[10:58:42.757]             if (.Platform$OS.type == "windows") {
[10:58:42.757]                 old_names <- names(...future.oldEnvVars)
[10:58:42.757]                 envs <- base::Sys.getenv()
[10:58:42.757]                 names <- names(envs)
[10:58:42.757]                 common <- intersect(names, old_names)
[10:58:42.757]                 added <- setdiff(names, old_names)
[10:58:42.757]                 removed <- setdiff(old_names, names)
[10:58:42.757]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.757]                   envs[common]]
[10:58:42.757]                 NAMES <- toupper(changed)
[10:58:42.757]                 args <- list()
[10:58:42.757]                 for (kk in seq_along(NAMES)) {
[10:58:42.757]                   name <- changed[[kk]]
[10:58:42.757]                   NAME <- NAMES[[kk]]
[10:58:42.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.757]                     next
[10:58:42.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.757]                 }
[10:58:42.757]                 NAMES <- toupper(added)
[10:58:42.757]                 for (kk in seq_along(NAMES)) {
[10:58:42.757]                   name <- added[[kk]]
[10:58:42.757]                   NAME <- NAMES[[kk]]
[10:58:42.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.757]                     next
[10:58:42.757]                   args[[name]] <- ""
[10:58:42.757]                 }
[10:58:42.757]                 NAMES <- toupper(removed)
[10:58:42.757]                 for (kk in seq_along(NAMES)) {
[10:58:42.757]                   name <- removed[[kk]]
[10:58:42.757]                   NAME <- NAMES[[kk]]
[10:58:42.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.757]                     next
[10:58:42.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.757]                 }
[10:58:42.757]                 if (length(args) > 0) 
[10:58:42.757]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.757]             }
[10:58:42.757]             else {
[10:58:42.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.757]             }
[10:58:42.757]             {
[10:58:42.757]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.757]                   0L) {
[10:58:42.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.757]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.757]                   base::options(opts)
[10:58:42.757]                 }
[10:58:42.757]                 {
[10:58:42.757]                   {
[10:58:42.757]                     NULL
[10:58:42.757]                     RNGkind("Mersenne-Twister")
[10:58:42.757]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:42.757]                       inherits = FALSE)
[10:58:42.757]                   }
[10:58:42.757]                   options(future.plan = NULL)
[10:58:42.757]                   if (is.na(NA_character_)) 
[10:58:42.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.757]                     .init = FALSE)
[10:58:42.757]                 }
[10:58:42.757]             }
[10:58:42.757]         }
[10:58:42.757]     })
[10:58:42.757]     if (TRUE) {
[10:58:42.757]         base::sink(type = "output", split = FALSE)
[10:58:42.757]         if (TRUE) {
[10:58:42.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.757]         }
[10:58:42.757]         else {
[10:58:42.757]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.757]         }
[10:58:42.757]         base::close(...future.stdout)
[10:58:42.757]         ...future.stdout <- NULL
[10:58:42.757]     }
[10:58:42.757]     ...future.result$conditions <- ...future.conditions
[10:58:42.757]     ...future.result$finished <- base::Sys.time()
[10:58:42.757]     ...future.result
[10:58:42.757] }
[10:58:42.759] assign_globals() ...
[10:58:42.759] List of 5
[10:58:42.759]  $ ...future.FUN            :function (x, ...)  
[10:58:42.759]  $ future.call.arguments    :List of 1
[10:58:42.759]   ..$ singular.ok: logi FALSE
[10:58:42.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.759]  $ ...future.elements_ii    :List of 3
[10:58:42.759]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.759]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:42.759]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.759]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:42.759]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.759]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:42.759]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.759]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:42.759]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.759]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:42.759]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.759]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:42.759]  $ ...future.seeds_ii       : NULL
[10:58:42.759]  $ ...future.globals.maxSize: NULL
[10:58:42.759]  - attr(*, "where")=List of 5
[10:58:42.759]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:42.759]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:42.759]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:42.759]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:42.759]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:42.759]  - attr(*, "resolved")= logi FALSE
[10:58:42.759]  - attr(*, "total_size")= num 19977
[10:58:42.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.759]  - attr(*, "already-done")= logi TRUE
[10:58:42.769] - reassign environment for ‘...future.FUN’
[10:58:42.769] - copied ‘...future.FUN’ to environment
[10:58:42.770] - copied ‘future.call.arguments’ to environment
[10:58:42.770] - copied ‘...future.elements_ii’ to environment
[10:58:42.770] - copied ‘...future.seeds_ii’ to environment
[10:58:42.770] - copied ‘...future.globals.maxSize’ to environment
[10:58:42.770] assign_globals() ... done
[10:58:42.770] plan(): Setting new future strategy stack:
[10:58:42.770] List of future strategies:
[10:58:42.770] 1. sequential:
[10:58:42.770]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.770]    - tweaked: FALSE
[10:58:42.770]    - call: NULL
[10:58:42.771] plan(): nbrOfWorkers() = 1
[10:58:42.774] plan(): Setting new future strategy stack:
[10:58:42.774] List of future strategies:
[10:58:42.774] 1. sequential:
[10:58:42.774]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.774]    - tweaked: FALSE
[10:58:42.774]    - call: plan(strategy)
[10:58:42.774] plan(): nbrOfWorkers() = 1
[10:58:42.774] SequentialFuture started (and completed)
[10:58:42.774] - Launch lazy future ... done
[10:58:42.774] run() for ‘SequentialFuture’ ... done
[10:58:42.775] Created future:
[10:58:42.775] SequentialFuture:
[10:58:42.775] Label: ‘future_by-1’
[10:58:42.775] Expression:
[10:58:42.775] {
[10:58:42.775]     do.call(function(...) {
[10:58:42.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.775]             on.exit(options(oopts), add = TRUE)
[10:58:42.775]         }
[10:58:42.775]         {
[10:58:42.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.775]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.775]             })
[10:58:42.775]         }
[10:58:42.775]     }, args = future.call.arguments)
[10:58:42.775] }
[10:58:42.775] Lazy evaluation: FALSE
[10:58:42.775] Asynchronous evaluation: FALSE
[10:58:42.775] Local evaluation: TRUE
[10:58:42.775] Environment: R_GlobalEnv
[10:58:42.775] Capture standard output: TRUE
[10:58:42.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.775] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:42.775] Packages: 1 packages (‘stats’)
[10:58:42.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.775] Resolved: TRUE
[10:58:42.775] Value: 77.05 KiB of class ‘list’
[10:58:42.775] Early signaling: FALSE
[10:58:42.775] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:42.775] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.776] Chunk #1 of 1 ... DONE
[10:58:42.776] Launching 1 futures (chunks) ... DONE
[10:58:42.776] Resolving 1 futures (chunks) ...
[10:58:42.776] resolve() on list ...
[10:58:42.776]  recursive: 0
[10:58:42.776]  length: 1
[10:58:42.776] 
[10:58:42.777] resolved() for ‘SequentialFuture’ ...
[10:58:42.777] - state: ‘finished’
[10:58:42.777] - run: TRUE
[10:58:42.777] - result: ‘FutureResult’
[10:58:42.777] resolved() for ‘SequentialFuture’ ... done
[10:58:42.777] Future #1
[10:58:42.777] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:42.777] - nx: 1
[10:58:42.777] - relay: TRUE
[10:58:42.777] - stdout: TRUE
[10:58:42.777] - signal: TRUE
[10:58:42.778] - resignal: FALSE
[10:58:42.778] - force: TRUE
[10:58:42.778] - relayed: [n=1] FALSE
[10:58:42.778] - queued futures: [n=1] FALSE
[10:58:42.778]  - until=1
[10:58:42.778]  - relaying element #1
[10:58:42.778] - relayed: [n=1] TRUE
[10:58:42.778] - queued futures: [n=1] TRUE
[10:58:42.778] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:42.778]  length: 0 (resolved future 1)
[10:58:42.779] Relaying remaining futures
[10:58:42.779] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.779] - nx: 1
[10:58:42.779] - relay: TRUE
[10:58:42.779] - stdout: TRUE
[10:58:42.779] - signal: TRUE
[10:58:42.779] - resignal: FALSE
[10:58:42.779] - force: TRUE
[10:58:42.779] - relayed: [n=1] TRUE
[10:58:42.779] - queued futures: [n=1] TRUE
 - flush all
[10:58:42.779] - relayed: [n=1] TRUE
[10:58:42.779] - queued futures: [n=1] TRUE
[10:58:42.780] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.780] resolve() on list ... DONE
[10:58:42.780]  - Number of value chunks collected: 1
[10:58:42.780] Resolving 1 futures (chunks) ... DONE
[10:58:42.780] Reducing values from 1 chunks ...
[10:58:42.780]  - Number of values collected after concatenation: 3
[10:58:42.780]  - Number of values expected: 3
[10:58:42.780] Reducing values from 1 chunks ... DONE
[10:58:42.780] future_lapply() ... DONE
[10:58:42.780] future_by_internal() ... DONE
[10:58:42.786] future_by_internal() ...
[10:58:42.786] future_lapply() ...
[10:58:42.787] Number of chunks: 1
[10:58:42.787] getGlobalsAndPackagesXApply() ...
[10:58:42.787]  - future.globals: TRUE
[10:58:42.787] getGlobalsAndPackages() ...
[10:58:42.787] Searching for globals...
[10:58:42.789] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:42.789] Searching for globals ... DONE
[10:58:42.789] Resolving globals: FALSE
[10:58:42.790] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:58:42.790] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:58:42.790] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:42.790] - packages: [1] ‘stats’
[10:58:42.790] getGlobalsAndPackages() ... DONE
[10:58:42.790]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:42.791]  - needed namespaces: [n=1] ‘stats’
[10:58:42.791] Finding globals ... DONE
[10:58:42.791]  - use_args: TRUE
[10:58:42.791]  - Getting '...' globals ...
[10:58:42.791] resolve() on list ...
[10:58:42.791]  recursive: 0
[10:58:42.791]  length: 1
[10:58:42.791]  elements: ‘...’
[10:58:42.792]  length: 0 (resolved future 1)
[10:58:42.792] resolve() on list ... DONE
[10:58:42.792]    - '...' content: [n=0] 
[10:58:42.792] List of 1
[10:58:42.792]  $ ...: list()
[10:58:42.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.792]  - attr(*, "where")=List of 1
[10:58:42.792]   ..$ ...:<environment: 0x55974c3ec080> 
[10:58:42.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.792]  - attr(*, "resolved")= logi TRUE
[10:58:42.792]  - attr(*, "total_size")= num NA
[10:58:42.794]  - Getting '...' globals ... DONE
[10:58:42.794] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:58:42.794] List of 4
[10:58:42.794]  $ ...future.FUN:function (x)  
[10:58:42.794]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:42.794]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:42.794]  $ ...          : list()
[10:58:42.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.794]  - attr(*, "where")=List of 4
[10:58:42.794]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.794]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:58:42.794]   ..$ wool         :<environment: R_EmptyEnv> 
[10:58:42.794]   ..$ ...          :<environment: 0x55974c3ec080> 
[10:58:42.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.794]  - attr(*, "resolved")= logi FALSE
[10:58:42.794]  - attr(*, "total_size")= num 18867
[10:58:42.798] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:42.798] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.798] Number of futures (= number of chunks): 1
[10:58:42.798] Launching 1 futures (chunks) ...
[10:58:42.799] Chunk #1 of 1 ...
[10:58:42.799]  - Finding globals in 'X' for chunk #1 ...
[10:58:42.799] getGlobalsAndPackages() ...
[10:58:42.799] Searching for globals...
[10:58:42.799] 
[10:58:42.799] Searching for globals ... DONE
[10:58:42.799] - globals: [0] <none>
[10:58:42.800] getGlobalsAndPackages() ... DONE
[10:58:42.800]    + additional globals found: [n=0] 
[10:58:42.800]    + additional namespaces needed: [n=0] 
[10:58:42.800]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:42.800]  - seeds: <none>
[10:58:42.800]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.800] getGlobalsAndPackages() ...
[10:58:42.800] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.800] Resolving globals: FALSE
[10:58:42.800] Tweak future expression to call with '...' arguments ...
[10:58:42.801] {
[10:58:42.801]     do.call(function(...) {
[10:58:42.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.801]             on.exit(options(oopts), add = TRUE)
[10:58:42.801]         }
[10:58:42.801]         {
[10:58:42.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.801]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.801]             })
[10:58:42.801]         }
[10:58:42.801]     }, args = future.call.arguments)
[10:58:42.801] }
[10:58:42.801] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.801] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.801] 
[10:58:42.801] getGlobalsAndPackages() ... DONE
[10:58:42.802] run() for ‘Future’ ...
[10:58:42.802] - state: ‘created’
[10:58:42.802] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:42.802] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:42.802]   - Field: ‘label’
[10:58:42.802]   - Field: ‘local’
[10:58:42.802]   - Field: ‘owner’
[10:58:42.803]   - Field: ‘envir’
[10:58:42.803]   - Field: ‘packages’
[10:58:42.804]   - Field: ‘gc’
[10:58:42.804]   - Field: ‘conditions’
[10:58:42.804]   - Field: ‘expr’
[10:58:42.804]   - Field: ‘uuid’
[10:58:42.805]   - Field: ‘seed’
[10:58:42.805]   - Field: ‘version’
[10:58:42.805]   - Field: ‘result’
[10:58:42.805]   - Field: ‘asynchronous’
[10:58:42.805]   - Field: ‘calls’
[10:58:42.805]   - Field: ‘globals’
[10:58:42.805]   - Field: ‘stdout’
[10:58:42.805]   - Field: ‘earlySignal’
[10:58:42.805]   - Field: ‘lazy’
[10:58:42.805]   - Field: ‘state’
[10:58:42.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:42.805] - Launch lazy future ...
[10:58:42.806] Packages needed by the future expression (n = 1): ‘stats’
[10:58:42.806] Packages needed by future strategies (n = 0): <none>
[10:58:42.806] {
[10:58:42.806]     {
[10:58:42.806]         {
[10:58:42.806]             ...future.startTime <- base::Sys.time()
[10:58:42.806]             {
[10:58:42.806]                 {
[10:58:42.806]                   {
[10:58:42.806]                     {
[10:58:42.806]                       base::local({
[10:58:42.806]                         has_future <- base::requireNamespace("future", 
[10:58:42.806]                           quietly = TRUE)
[10:58:42.806]                         if (has_future) {
[10:58:42.806]                           ns <- base::getNamespace("future")
[10:58:42.806]                           version <- ns[[".package"]][["version"]]
[10:58:42.806]                           if (is.null(version)) 
[10:58:42.806]                             version <- utils::packageVersion("future")
[10:58:42.806]                         }
[10:58:42.806]                         else {
[10:58:42.806]                           version <- NULL
[10:58:42.806]                         }
[10:58:42.806]                         if (!has_future || version < "1.8.0") {
[10:58:42.806]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.806]                             "", base::R.version$version.string), 
[10:58:42.806]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:42.806]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.806]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.806]                               "release", "version")], collapse = " "), 
[10:58:42.806]                             hostname = base::Sys.info()[["nodename"]])
[10:58:42.806]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.806]                             info)
[10:58:42.806]                           info <- base::paste(info, collapse = "; ")
[10:58:42.806]                           if (!has_future) {
[10:58:42.806]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.806]                               info)
[10:58:42.806]                           }
[10:58:42.806]                           else {
[10:58:42.806]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.806]                               info, version)
[10:58:42.806]                           }
[10:58:42.806]                           base::stop(msg)
[10:58:42.806]                         }
[10:58:42.806]                       })
[10:58:42.806]                     }
[10:58:42.806]                     base::local({
[10:58:42.806]                       for (pkg in "stats") {
[10:58:42.806]                         base::loadNamespace(pkg)
[10:58:42.806]                         base::library(pkg, character.only = TRUE)
[10:58:42.806]                       }
[10:58:42.806]                     })
[10:58:42.806]                   }
[10:58:42.806]                   ...future.strategy.old <- future::plan("list")
[10:58:42.806]                   options(future.plan = NULL)
[10:58:42.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.806]                 }
[10:58:42.806]                 ...future.workdir <- getwd()
[10:58:42.806]             }
[10:58:42.806]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.806]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.806]         }
[10:58:42.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.806]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:42.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.806]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.806]             base::names(...future.oldOptions))
[10:58:42.806]     }
[10:58:42.806]     if (FALSE) {
[10:58:42.806]     }
[10:58:42.806]     else {
[10:58:42.806]         if (TRUE) {
[10:58:42.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.806]                 open = "w")
[10:58:42.806]         }
[10:58:42.806]         else {
[10:58:42.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.806]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.806]         }
[10:58:42.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.806]             base::sink(type = "output", split = FALSE)
[10:58:42.806]             base::close(...future.stdout)
[10:58:42.806]         }, add = TRUE)
[10:58:42.806]     }
[10:58:42.806]     ...future.frame <- base::sys.nframe()
[10:58:42.806]     ...future.conditions <- base::list()
[10:58:42.806]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.806]     if (FALSE) {
[10:58:42.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.806]     }
[10:58:42.806]     ...future.result <- base::tryCatch({
[10:58:42.806]         base::withCallingHandlers({
[10:58:42.806]             ...future.value <- base::withVisible(base::local({
[10:58:42.806]                 do.call(function(...) {
[10:58:42.806]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.806]                   if (!identical(...future.globals.maxSize.org, 
[10:58:42.806]                     ...future.globals.maxSize)) {
[10:58:42.806]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.806]                     on.exit(options(oopts), add = TRUE)
[10:58:42.806]                   }
[10:58:42.806]                   {
[10:58:42.806]                     lapply(seq_along(...future.elements_ii), 
[10:58:42.806]                       FUN = function(jj) {
[10:58:42.806]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.806]                         ...future.FUN(...future.X_jj, ...)
[10:58:42.806]                       })
[10:58:42.806]                   }
[10:58:42.806]                 }, args = future.call.arguments)
[10:58:42.806]             }))
[10:58:42.806]             future::FutureResult(value = ...future.value$value, 
[10:58:42.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.806]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.806]                     ...future.globalenv.names))
[10:58:42.806]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.806]         }, condition = base::local({
[10:58:42.806]             c <- base::c
[10:58:42.806]             inherits <- base::inherits
[10:58:42.806]             invokeRestart <- base::invokeRestart
[10:58:42.806]             length <- base::length
[10:58:42.806]             list <- base::list
[10:58:42.806]             seq.int <- base::seq.int
[10:58:42.806]             signalCondition <- base::signalCondition
[10:58:42.806]             sys.calls <- base::sys.calls
[10:58:42.806]             `[[` <- base::`[[`
[10:58:42.806]             `+` <- base::`+`
[10:58:42.806]             `<<-` <- base::`<<-`
[10:58:42.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.806]                   3L)]
[10:58:42.806]             }
[10:58:42.806]             function(cond) {
[10:58:42.806]                 is_error <- inherits(cond, "error")
[10:58:42.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.806]                   NULL)
[10:58:42.806]                 if (is_error) {
[10:58:42.806]                   sessionInformation <- function() {
[10:58:42.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.806]                       search = base::search(), system = base::Sys.info())
[10:58:42.806]                   }
[10:58:42.806]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.806]                     cond$call), session = sessionInformation(), 
[10:58:42.806]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.806]                   signalCondition(cond)
[10:58:42.806]                 }
[10:58:42.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.806]                 "immediateCondition"))) {
[10:58:42.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.806]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.806]                   if (TRUE && !signal) {
[10:58:42.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.806]                     {
[10:58:42.806]                       inherits <- base::inherits
[10:58:42.806]                       invokeRestart <- base::invokeRestart
[10:58:42.806]                       is.null <- base::is.null
[10:58:42.806]                       muffled <- FALSE
[10:58:42.806]                       if (inherits(cond, "message")) {
[10:58:42.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.806]                         if (muffled) 
[10:58:42.806]                           invokeRestart("muffleMessage")
[10:58:42.806]                       }
[10:58:42.806]                       else if (inherits(cond, "warning")) {
[10:58:42.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.806]                         if (muffled) 
[10:58:42.806]                           invokeRestart("muffleWarning")
[10:58:42.806]                       }
[10:58:42.806]                       else if (inherits(cond, "condition")) {
[10:58:42.806]                         if (!is.null(pattern)) {
[10:58:42.806]                           computeRestarts <- base::computeRestarts
[10:58:42.806]                           grepl <- base::grepl
[10:58:42.806]                           restarts <- computeRestarts(cond)
[10:58:42.806]                           for (restart in restarts) {
[10:58:42.806]                             name <- restart$name
[10:58:42.806]                             if (is.null(name)) 
[10:58:42.806]                               next
[10:58:42.806]                             if (!grepl(pattern, name)) 
[10:58:42.806]                               next
[10:58:42.806]                             invokeRestart(restart)
[10:58:42.806]                             muffled <- TRUE
[10:58:42.806]                             break
[10:58:42.806]                           }
[10:58:42.806]                         }
[10:58:42.806]                       }
[10:58:42.806]                       invisible(muffled)
[10:58:42.806]                     }
[10:58:42.806]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.806]                   }
[10:58:42.806]                 }
[10:58:42.806]                 else {
[10:58:42.806]                   if (TRUE) {
[10:58:42.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.806]                     {
[10:58:42.806]                       inherits <- base::inherits
[10:58:42.806]                       invokeRestart <- base::invokeRestart
[10:58:42.806]                       is.null <- base::is.null
[10:58:42.806]                       muffled <- FALSE
[10:58:42.806]                       if (inherits(cond, "message")) {
[10:58:42.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.806]                         if (muffled) 
[10:58:42.806]                           invokeRestart("muffleMessage")
[10:58:42.806]                       }
[10:58:42.806]                       else if (inherits(cond, "warning")) {
[10:58:42.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.806]                         if (muffled) 
[10:58:42.806]                           invokeRestart("muffleWarning")
[10:58:42.806]                       }
[10:58:42.806]                       else if (inherits(cond, "condition")) {
[10:58:42.806]                         if (!is.null(pattern)) {
[10:58:42.806]                           computeRestarts <- base::computeRestarts
[10:58:42.806]                           grepl <- base::grepl
[10:58:42.806]                           restarts <- computeRestarts(cond)
[10:58:42.806]                           for (restart in restarts) {
[10:58:42.806]                             name <- restart$name
[10:58:42.806]                             if (is.null(name)) 
[10:58:42.806]                               next
[10:58:42.806]                             if (!grepl(pattern, name)) 
[10:58:42.806]                               next
[10:58:42.806]                             invokeRestart(restart)
[10:58:42.806]                             muffled <- TRUE
[10:58:42.806]                             break
[10:58:42.806]                           }
[10:58:42.806]                         }
[10:58:42.806]                       }
[10:58:42.806]                       invisible(muffled)
[10:58:42.806]                     }
[10:58:42.806]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.806]                   }
[10:58:42.806]                 }
[10:58:42.806]             }
[10:58:42.806]         }))
[10:58:42.806]     }, error = function(ex) {
[10:58:42.806]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.806]                 ...future.rng), started = ...future.startTime, 
[10:58:42.806]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.806]             version = "1.8"), class = "FutureResult")
[10:58:42.806]     }, finally = {
[10:58:42.806]         if (!identical(...future.workdir, getwd())) 
[10:58:42.806]             setwd(...future.workdir)
[10:58:42.806]         {
[10:58:42.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.806]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.806]             }
[10:58:42.806]             base::options(...future.oldOptions)
[10:58:42.806]             if (.Platform$OS.type == "windows") {
[10:58:42.806]                 old_names <- names(...future.oldEnvVars)
[10:58:42.806]                 envs <- base::Sys.getenv()
[10:58:42.806]                 names <- names(envs)
[10:58:42.806]                 common <- intersect(names, old_names)
[10:58:42.806]                 added <- setdiff(names, old_names)
[10:58:42.806]                 removed <- setdiff(old_names, names)
[10:58:42.806]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.806]                   envs[common]]
[10:58:42.806]                 NAMES <- toupper(changed)
[10:58:42.806]                 args <- list()
[10:58:42.806]                 for (kk in seq_along(NAMES)) {
[10:58:42.806]                   name <- changed[[kk]]
[10:58:42.806]                   NAME <- NAMES[[kk]]
[10:58:42.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.806]                     next
[10:58:42.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.806]                 }
[10:58:42.806]                 NAMES <- toupper(added)
[10:58:42.806]                 for (kk in seq_along(NAMES)) {
[10:58:42.806]                   name <- added[[kk]]
[10:58:42.806]                   NAME <- NAMES[[kk]]
[10:58:42.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.806]                     next
[10:58:42.806]                   args[[name]] <- ""
[10:58:42.806]                 }
[10:58:42.806]                 NAMES <- toupper(removed)
[10:58:42.806]                 for (kk in seq_along(NAMES)) {
[10:58:42.806]                   name <- removed[[kk]]
[10:58:42.806]                   NAME <- NAMES[[kk]]
[10:58:42.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.806]                     next
[10:58:42.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.806]                 }
[10:58:42.806]                 if (length(args) > 0) 
[10:58:42.806]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.806]             }
[10:58:42.806]             else {
[10:58:42.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.806]             }
[10:58:42.806]             {
[10:58:42.806]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.806]                   0L) {
[10:58:42.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.806]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.806]                   base::options(opts)
[10:58:42.806]                 }
[10:58:42.806]                 {
[10:58:42.806]                   {
[10:58:42.806]                     NULL
[10:58:42.806]                     RNGkind("Mersenne-Twister")
[10:58:42.806]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:42.806]                       inherits = FALSE)
[10:58:42.806]                   }
[10:58:42.806]                   options(future.plan = NULL)
[10:58:42.806]                   if (is.na(NA_character_)) 
[10:58:42.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.806]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.806]                     .init = FALSE)
[10:58:42.806]                 }
[10:58:42.806]             }
[10:58:42.806]         }
[10:58:42.806]     })
[10:58:42.806]     if (TRUE) {
[10:58:42.806]         base::sink(type = "output", split = FALSE)
[10:58:42.806]         if (TRUE) {
[10:58:42.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.806]         }
[10:58:42.806]         else {
[10:58:42.806]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.806]         }
[10:58:42.806]         base::close(...future.stdout)
[10:58:42.806]         ...future.stdout <- NULL
[10:58:42.806]     }
[10:58:42.806]     ...future.result$conditions <- ...future.conditions
[10:58:42.806]     ...future.result$finished <- base::Sys.time()
[10:58:42.806]     ...future.result
[10:58:42.806] }
[10:58:42.808] assign_globals() ...
[10:58:42.808] List of 7
[10:58:42.808]  $ ...future.FUN            :function (x)  
[10:58:42.808]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:42.808]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:42.808]  $ future.call.arguments    : list()
[10:58:42.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.808]  $ ...future.elements_ii    :List of 3
[10:58:42.808]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.808]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:42.808]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.808]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:42.808]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.808]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:42.808]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.808]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:42.808]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.808]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:42.808]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.808]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:42.808]  $ ...future.seeds_ii       : NULL
[10:58:42.808]  $ ...future.globals.maxSize: NULL
[10:58:42.808]  - attr(*, "where")=List of 7
[10:58:42.808]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:42.808]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:58:42.808]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:58:42.808]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:42.808]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:42.808]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:42.808]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:42.808]  - attr(*, "resolved")= logi FALSE
[10:58:42.808]  - attr(*, "total_size")= num 18867
[10:58:42.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.808]  - attr(*, "already-done")= logi TRUE
[10:58:42.818] - reassign environment for ‘...future.FUN’
[10:58:42.818] - copied ‘...future.FUN’ to environment
[10:58:42.818] - copied ‘breaks’ to environment
[10:58:42.818] - copied ‘wool’ to environment
[10:58:42.818] - copied ‘future.call.arguments’ to environment
[10:58:42.818] - copied ‘...future.elements_ii’ to environment
[10:58:42.818] - copied ‘...future.seeds_ii’ to environment
[10:58:42.818] - copied ‘...future.globals.maxSize’ to environment
[10:58:42.818] assign_globals() ... done
[10:58:42.819] plan(): Setting new future strategy stack:
[10:58:42.819] List of future strategies:
[10:58:42.819] 1. sequential:
[10:58:42.819]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.819]    - tweaked: FALSE
[10:58:42.819]    - call: NULL
[10:58:42.819] plan(): nbrOfWorkers() = 1
[10:58:42.822] plan(): Setting new future strategy stack:
[10:58:42.822] List of future strategies:
[10:58:42.822] 1. sequential:
[10:58:42.822]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.822]    - tweaked: FALSE
[10:58:42.822]    - call: plan(strategy)
[10:58:42.822] plan(): nbrOfWorkers() = 1
[10:58:42.823] SequentialFuture started (and completed)
[10:58:42.823] - Launch lazy future ... done
[10:58:42.823] run() for ‘SequentialFuture’ ... done
[10:58:42.823] Created future:
[10:58:42.823] SequentialFuture:
[10:58:42.823] Label: ‘future_by-1’
[10:58:42.823] Expression:
[10:58:42.823] {
[10:58:42.823]     do.call(function(...) {
[10:58:42.823]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.823]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.823]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.823]             on.exit(options(oopts), add = TRUE)
[10:58:42.823]         }
[10:58:42.823]         {
[10:58:42.823]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.823]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.823]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.823]             })
[10:58:42.823]         }
[10:58:42.823]     }, args = future.call.arguments)
[10:58:42.823] }
[10:58:42.823] Lazy evaluation: FALSE
[10:58:42.823] Asynchronous evaluation: FALSE
[10:58:42.823] Local evaluation: TRUE
[10:58:42.823] Environment: 0x55974c639060
[10:58:42.823] Capture standard output: TRUE
[10:58:42.823] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.823] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[10:58:42.823] Packages: 1 packages (‘stats’)
[10:58:42.823] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.823] Resolved: TRUE
[10:58:42.823] Value: 78.42 KiB of class ‘list’
[10:58:42.823] Early signaling: FALSE
[10:58:42.823] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:42.823] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.824] Chunk #1 of 1 ... DONE
[10:58:42.824] Launching 1 futures (chunks) ... DONE
[10:58:42.825] Resolving 1 futures (chunks) ...
[10:58:42.825] resolve() on list ...
[10:58:42.825]  recursive: 0
[10:58:42.825]  length: 1
[10:58:42.826] 
[10:58:42.826] resolved() for ‘SequentialFuture’ ...
[10:58:42.827] - state: ‘finished’
[10:58:42.827] - run: TRUE
[10:58:42.827] - result: ‘FutureResult’
[10:58:42.827] resolved() for ‘SequentialFuture’ ... done
[10:58:42.827] Future #1
[10:58:42.827] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:42.827] - nx: 1
[10:58:42.827] - relay: TRUE
[10:58:42.827] - stdout: TRUE
[10:58:42.827] - signal: TRUE
[10:58:42.828] - resignal: FALSE
[10:58:42.828] - force: TRUE
[10:58:42.828] - relayed: [n=1] FALSE
[10:58:42.828] - queued futures: [n=1] FALSE
[10:58:42.828]  - until=1
[10:58:42.828]  - relaying element #1
[10:58:42.828] - relayed: [n=1] TRUE
[10:58:42.828] - queued futures: [n=1] TRUE
[10:58:42.828] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:42.828]  length: 0 (resolved future 1)
[10:58:42.829] Relaying remaining futures
[10:58:42.829] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.829] - nx: 1
[10:58:42.829] - relay: TRUE
[10:58:42.829] - stdout: TRUE
[10:58:42.829] - signal: TRUE
[10:58:42.829] - resignal: FALSE
[10:58:42.829] - force: TRUE
[10:58:42.829] - relayed: [n=1] TRUE
[10:58:42.829] - queued futures: [n=1] TRUE
 - flush all
[10:58:42.829] - relayed: [n=1] TRUE
[10:58:42.829] - queued futures: [n=1] TRUE
[10:58:42.830] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.830] resolve() on list ... DONE
[10:58:42.830]  - Number of value chunks collected: 1
[10:58:42.830] Resolving 1 futures (chunks) ... DONE
[10:58:42.830] Reducing values from 1 chunks ...
[10:58:42.830]  - Number of values collected after concatenation: 3
[10:58:42.830]  - Number of values expected: 3
[10:58:42.830] Reducing values from 1 chunks ... DONE
[10:58:42.830] future_lapply() ... DONE
[10:58:42.830] future_by_internal() ... DONE
[10:58:42.831] future_by_internal() ...
[10:58:42.831] future_lapply() ...
[10:58:42.832] Number of chunks: 1
[10:58:42.832] getGlobalsAndPackagesXApply() ...
[10:58:42.832]  - future.globals: TRUE
[10:58:42.832] getGlobalsAndPackages() ...
[10:58:42.832] Searching for globals...
[10:58:42.833] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:42.833] Searching for globals ... DONE
[10:58:42.833] Resolving globals: FALSE
[10:58:42.833] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:42.834] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:42.834] - globals: [1] ‘FUN’
[10:58:42.834] 
[10:58:42.834] getGlobalsAndPackages() ... DONE
[10:58:42.834]  - globals found/used: [n=1] ‘FUN’
[10:58:42.834]  - needed namespaces: [n=0] 
[10:58:42.834] Finding globals ... DONE
[10:58:42.834]  - use_args: TRUE
[10:58:42.835]  - Getting '...' globals ...
[10:58:42.835] resolve() on list ...
[10:58:42.835]  recursive: 0
[10:58:42.835]  length: 1
[10:58:42.835]  elements: ‘...’
[10:58:42.835]  length: 0 (resolved future 1)
[10:58:42.835] resolve() on list ... DONE
[10:58:42.835]    - '...' content: [n=0] 
[10:58:42.835] List of 1
[10:58:42.835]  $ ...: list()
[10:58:42.835]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.835]  - attr(*, "where")=List of 1
[10:58:42.835]   ..$ ...:<environment: 0x55974b802a98> 
[10:58:42.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.835]  - attr(*, "resolved")= logi TRUE
[10:58:42.835]  - attr(*, "total_size")= num NA
[10:58:42.838]  - Getting '...' globals ... DONE
[10:58:42.838] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:42.838] List of 2
[10:58:42.838]  $ ...future.FUN:function (object, ...)  
[10:58:42.838]  $ ...          : list()
[10:58:42.838]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.838]  - attr(*, "where")=List of 2
[10:58:42.838]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.838]   ..$ ...          :<environment: 0x55974b802a98> 
[10:58:42.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.838]  - attr(*, "resolved")= logi FALSE
[10:58:42.838]  - attr(*, "total_size")= num 18709
[10:58:42.841] Packages to be attached in all futures: [n=0] 
[10:58:42.841] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.841] Number of futures (= number of chunks): 1
[10:58:42.841] Launching 1 futures (chunks) ...
[10:58:42.841] Chunk #1 of 1 ...
[10:58:42.841]  - Finding globals in 'X' for chunk #1 ...
[10:58:42.841] getGlobalsAndPackages() ...
[10:58:42.841] Searching for globals...
[10:58:42.842] 
[10:58:42.842] Searching for globals ... DONE
[10:58:42.842] - globals: [0] <none>
[10:58:42.842] getGlobalsAndPackages() ... DONE
[10:58:42.842]    + additional globals found: [n=0] 
[10:58:42.842]    + additional namespaces needed: [n=0] 
[10:58:42.842]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:42.842]  - seeds: <none>
[10:58:42.843]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.843] getGlobalsAndPackages() ...
[10:58:42.843] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.843] Resolving globals: FALSE
[10:58:42.843] Tweak future expression to call with '...' arguments ...
[10:58:42.843] {
[10:58:42.843]     do.call(function(...) {
[10:58:42.843]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.843]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.843]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.843]             on.exit(options(oopts), add = TRUE)
[10:58:42.843]         }
[10:58:42.843]         {
[10:58:42.843]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.843]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.843]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.843]             })
[10:58:42.843]         }
[10:58:42.843]     }, args = future.call.arguments)
[10:58:42.843] }
[10:58:42.843] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.844] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.844] 
[10:58:42.844] getGlobalsAndPackages() ... DONE
[10:58:42.844] run() for ‘Future’ ...
[10:58:42.844] - state: ‘created’
[10:58:42.844] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:42.845] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:42.845]   - Field: ‘label’
[10:58:42.845]   - Field: ‘local’
[10:58:42.845]   - Field: ‘owner’
[10:58:42.845]   - Field: ‘envir’
[10:58:42.845]   - Field: ‘packages’
[10:58:42.847]   - Field: ‘gc’
[10:58:42.847]   - Field: ‘conditions’
[10:58:42.847]   - Field: ‘expr’
[10:58:42.847]   - Field: ‘uuid’
[10:58:42.847]   - Field: ‘seed’
[10:58:42.847]   - Field: ‘version’
[10:58:42.847]   - Field: ‘result’
[10:58:42.847]   - Field: ‘asynchronous’
[10:58:42.847]   - Field: ‘calls’
[10:58:42.848]   - Field: ‘globals’
[10:58:42.848]   - Field: ‘stdout’
[10:58:42.848]   - Field: ‘earlySignal’
[10:58:42.848]   - Field: ‘lazy’
[10:58:42.848]   - Field: ‘state’
[10:58:42.848] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:42.848] - Launch lazy future ...
[10:58:42.848] Packages needed by the future expression (n = 0): <none>
[10:58:42.848] Packages needed by future strategies (n = 0): <none>
[10:58:42.849] {
[10:58:42.849]     {
[10:58:42.849]         {
[10:58:42.849]             ...future.startTime <- base::Sys.time()
[10:58:42.849]             {
[10:58:42.849]                 {
[10:58:42.849]                   {
[10:58:42.849]                     base::local({
[10:58:42.849]                       has_future <- base::requireNamespace("future", 
[10:58:42.849]                         quietly = TRUE)
[10:58:42.849]                       if (has_future) {
[10:58:42.849]                         ns <- base::getNamespace("future")
[10:58:42.849]                         version <- ns[[".package"]][["version"]]
[10:58:42.849]                         if (is.null(version)) 
[10:58:42.849]                           version <- utils::packageVersion("future")
[10:58:42.849]                       }
[10:58:42.849]                       else {
[10:58:42.849]                         version <- NULL
[10:58:42.849]                       }
[10:58:42.849]                       if (!has_future || version < "1.8.0") {
[10:58:42.849]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.849]                           "", base::R.version$version.string), 
[10:58:42.849]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:42.849]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.849]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.849]                             "release", "version")], collapse = " "), 
[10:58:42.849]                           hostname = base::Sys.info()[["nodename"]])
[10:58:42.849]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.849]                           info)
[10:58:42.849]                         info <- base::paste(info, collapse = "; ")
[10:58:42.849]                         if (!has_future) {
[10:58:42.849]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.849]                             info)
[10:58:42.849]                         }
[10:58:42.849]                         else {
[10:58:42.849]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.849]                             info, version)
[10:58:42.849]                         }
[10:58:42.849]                         base::stop(msg)
[10:58:42.849]                       }
[10:58:42.849]                     })
[10:58:42.849]                   }
[10:58:42.849]                   ...future.strategy.old <- future::plan("list")
[10:58:42.849]                   options(future.plan = NULL)
[10:58:42.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.849]                 }
[10:58:42.849]                 ...future.workdir <- getwd()
[10:58:42.849]             }
[10:58:42.849]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.849]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.849]         }
[10:58:42.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:42.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.849]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.849]             base::names(...future.oldOptions))
[10:58:42.849]     }
[10:58:42.849]     if (FALSE) {
[10:58:42.849]     }
[10:58:42.849]     else {
[10:58:42.849]         if (TRUE) {
[10:58:42.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.849]                 open = "w")
[10:58:42.849]         }
[10:58:42.849]         else {
[10:58:42.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.849]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.849]         }
[10:58:42.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.849]             base::sink(type = "output", split = FALSE)
[10:58:42.849]             base::close(...future.stdout)
[10:58:42.849]         }, add = TRUE)
[10:58:42.849]     }
[10:58:42.849]     ...future.frame <- base::sys.nframe()
[10:58:42.849]     ...future.conditions <- base::list()
[10:58:42.849]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.849]     if (FALSE) {
[10:58:42.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.849]     }
[10:58:42.849]     ...future.result <- base::tryCatch({
[10:58:42.849]         base::withCallingHandlers({
[10:58:42.849]             ...future.value <- base::withVisible(base::local({
[10:58:42.849]                 do.call(function(...) {
[10:58:42.849]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.849]                   if (!identical(...future.globals.maxSize.org, 
[10:58:42.849]                     ...future.globals.maxSize)) {
[10:58:42.849]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.849]                     on.exit(options(oopts), add = TRUE)
[10:58:42.849]                   }
[10:58:42.849]                   {
[10:58:42.849]                     lapply(seq_along(...future.elements_ii), 
[10:58:42.849]                       FUN = function(jj) {
[10:58:42.849]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.849]                         ...future.FUN(...future.X_jj, ...)
[10:58:42.849]                       })
[10:58:42.849]                   }
[10:58:42.849]                 }, args = future.call.arguments)
[10:58:42.849]             }))
[10:58:42.849]             future::FutureResult(value = ...future.value$value, 
[10:58:42.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.849]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.849]                     ...future.globalenv.names))
[10:58:42.849]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.849]         }, condition = base::local({
[10:58:42.849]             c <- base::c
[10:58:42.849]             inherits <- base::inherits
[10:58:42.849]             invokeRestart <- base::invokeRestart
[10:58:42.849]             length <- base::length
[10:58:42.849]             list <- base::list
[10:58:42.849]             seq.int <- base::seq.int
[10:58:42.849]             signalCondition <- base::signalCondition
[10:58:42.849]             sys.calls <- base::sys.calls
[10:58:42.849]             `[[` <- base::`[[`
[10:58:42.849]             `+` <- base::`+`
[10:58:42.849]             `<<-` <- base::`<<-`
[10:58:42.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.849]                   3L)]
[10:58:42.849]             }
[10:58:42.849]             function(cond) {
[10:58:42.849]                 is_error <- inherits(cond, "error")
[10:58:42.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.849]                   NULL)
[10:58:42.849]                 if (is_error) {
[10:58:42.849]                   sessionInformation <- function() {
[10:58:42.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.849]                       search = base::search(), system = base::Sys.info())
[10:58:42.849]                   }
[10:58:42.849]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.849]                     cond$call), session = sessionInformation(), 
[10:58:42.849]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.849]                   signalCondition(cond)
[10:58:42.849]                 }
[10:58:42.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.849]                 "immediateCondition"))) {
[10:58:42.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.849]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.849]                   if (TRUE && !signal) {
[10:58:42.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.849]                     {
[10:58:42.849]                       inherits <- base::inherits
[10:58:42.849]                       invokeRestart <- base::invokeRestart
[10:58:42.849]                       is.null <- base::is.null
[10:58:42.849]                       muffled <- FALSE
[10:58:42.849]                       if (inherits(cond, "message")) {
[10:58:42.849]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.849]                         if (muffled) 
[10:58:42.849]                           invokeRestart("muffleMessage")
[10:58:42.849]                       }
[10:58:42.849]                       else if (inherits(cond, "warning")) {
[10:58:42.849]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.849]                         if (muffled) 
[10:58:42.849]                           invokeRestart("muffleWarning")
[10:58:42.849]                       }
[10:58:42.849]                       else if (inherits(cond, "condition")) {
[10:58:42.849]                         if (!is.null(pattern)) {
[10:58:42.849]                           computeRestarts <- base::computeRestarts
[10:58:42.849]                           grepl <- base::grepl
[10:58:42.849]                           restarts <- computeRestarts(cond)
[10:58:42.849]                           for (restart in restarts) {
[10:58:42.849]                             name <- restart$name
[10:58:42.849]                             if (is.null(name)) 
[10:58:42.849]                               next
[10:58:42.849]                             if (!grepl(pattern, name)) 
[10:58:42.849]                               next
[10:58:42.849]                             invokeRestart(restart)
[10:58:42.849]                             muffled <- TRUE
[10:58:42.849]                             break
[10:58:42.849]                           }
[10:58:42.849]                         }
[10:58:42.849]                       }
[10:58:42.849]                       invisible(muffled)
[10:58:42.849]                     }
[10:58:42.849]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.849]                   }
[10:58:42.849]                 }
[10:58:42.849]                 else {
[10:58:42.849]                   if (TRUE) {
[10:58:42.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.849]                     {
[10:58:42.849]                       inherits <- base::inherits
[10:58:42.849]                       invokeRestart <- base::invokeRestart
[10:58:42.849]                       is.null <- base::is.null
[10:58:42.849]                       muffled <- FALSE
[10:58:42.849]                       if (inherits(cond, "message")) {
[10:58:42.849]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.849]                         if (muffled) 
[10:58:42.849]                           invokeRestart("muffleMessage")
[10:58:42.849]                       }
[10:58:42.849]                       else if (inherits(cond, "warning")) {
[10:58:42.849]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.849]                         if (muffled) 
[10:58:42.849]                           invokeRestart("muffleWarning")
[10:58:42.849]                       }
[10:58:42.849]                       else if (inherits(cond, "condition")) {
[10:58:42.849]                         if (!is.null(pattern)) {
[10:58:42.849]                           computeRestarts <- base::computeRestarts
[10:58:42.849]                           grepl <- base::grepl
[10:58:42.849]                           restarts <- computeRestarts(cond)
[10:58:42.849]                           for (restart in restarts) {
[10:58:42.849]                             name <- restart$name
[10:58:42.849]                             if (is.null(name)) 
[10:58:42.849]                               next
[10:58:42.849]                             if (!grepl(pattern, name)) 
[10:58:42.849]                               next
[10:58:42.849]                             invokeRestart(restart)
[10:58:42.849]                             muffled <- TRUE
[10:58:42.849]                             break
[10:58:42.849]                           }
[10:58:42.849]                         }
[10:58:42.849]                       }
[10:58:42.849]                       invisible(muffled)
[10:58:42.849]                     }
[10:58:42.849]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.849]                   }
[10:58:42.849]                 }
[10:58:42.849]             }
[10:58:42.849]         }))
[10:58:42.849]     }, error = function(ex) {
[10:58:42.849]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.849]                 ...future.rng), started = ...future.startTime, 
[10:58:42.849]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.849]             version = "1.8"), class = "FutureResult")
[10:58:42.849]     }, finally = {
[10:58:42.849]         if (!identical(...future.workdir, getwd())) 
[10:58:42.849]             setwd(...future.workdir)
[10:58:42.849]         {
[10:58:42.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.849]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.849]             }
[10:58:42.849]             base::options(...future.oldOptions)
[10:58:42.849]             if (.Platform$OS.type == "windows") {
[10:58:42.849]                 old_names <- names(...future.oldEnvVars)
[10:58:42.849]                 envs <- base::Sys.getenv()
[10:58:42.849]                 names <- names(envs)
[10:58:42.849]                 common <- intersect(names, old_names)
[10:58:42.849]                 added <- setdiff(names, old_names)
[10:58:42.849]                 removed <- setdiff(old_names, names)
[10:58:42.849]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.849]                   envs[common]]
[10:58:42.849]                 NAMES <- toupper(changed)
[10:58:42.849]                 args <- list()
[10:58:42.849]                 for (kk in seq_along(NAMES)) {
[10:58:42.849]                   name <- changed[[kk]]
[10:58:42.849]                   NAME <- NAMES[[kk]]
[10:58:42.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.849]                     next
[10:58:42.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.849]                 }
[10:58:42.849]                 NAMES <- toupper(added)
[10:58:42.849]                 for (kk in seq_along(NAMES)) {
[10:58:42.849]                   name <- added[[kk]]
[10:58:42.849]                   NAME <- NAMES[[kk]]
[10:58:42.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.849]                     next
[10:58:42.849]                   args[[name]] <- ""
[10:58:42.849]                 }
[10:58:42.849]                 NAMES <- toupper(removed)
[10:58:42.849]                 for (kk in seq_along(NAMES)) {
[10:58:42.849]                   name <- removed[[kk]]
[10:58:42.849]                   NAME <- NAMES[[kk]]
[10:58:42.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.849]                     next
[10:58:42.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.849]                 }
[10:58:42.849]                 if (length(args) > 0) 
[10:58:42.849]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.849]             }
[10:58:42.849]             else {
[10:58:42.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.849]             }
[10:58:42.849]             {
[10:58:42.849]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.849]                   0L) {
[10:58:42.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.849]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.849]                   base::options(opts)
[10:58:42.849]                 }
[10:58:42.849]                 {
[10:58:42.849]                   {
[10:58:42.849]                     NULL
[10:58:42.849]                     RNGkind("Mersenne-Twister")
[10:58:42.849]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:42.849]                       inherits = FALSE)
[10:58:42.849]                   }
[10:58:42.849]                   options(future.plan = NULL)
[10:58:42.849]                   if (is.na(NA_character_)) 
[10:58:42.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.849]                     .init = FALSE)
[10:58:42.849]                 }
[10:58:42.849]             }
[10:58:42.849]         }
[10:58:42.849]     })
[10:58:42.849]     if (TRUE) {
[10:58:42.849]         base::sink(type = "output", split = FALSE)
[10:58:42.849]         if (TRUE) {
[10:58:42.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.849]         }
[10:58:42.849]         else {
[10:58:42.849]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.849]         }
[10:58:42.849]         base::close(...future.stdout)
[10:58:42.849]         ...future.stdout <- NULL
[10:58:42.849]     }
[10:58:42.849]     ...future.result$conditions <- ...future.conditions
[10:58:42.849]     ...future.result$finished <- base::Sys.time()
[10:58:42.849]     ...future.result
[10:58:42.849] }
[10:58:42.850] assign_globals() ...
[10:58:42.851] List of 5
[10:58:42.851]  $ ...future.FUN            :function (object, ...)  
[10:58:42.851]  $ future.call.arguments    : list()
[10:58:42.851]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.851]  $ ...future.elements_ii    :List of 3
[10:58:42.851]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.851]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:42.851]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.851]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:42.851]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.851]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:42.851]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.851]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:42.851]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.851]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:42.851]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.851]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:42.851]  $ ...future.seeds_ii       : NULL
[10:58:42.851]  $ ...future.globals.maxSize: NULL
[10:58:42.851]  - attr(*, "where")=List of 5
[10:58:42.851]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:42.851]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:42.851]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:42.851]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:42.851]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:42.851]  - attr(*, "resolved")= logi FALSE
[10:58:42.851]  - attr(*, "total_size")= num 18709
[10:58:42.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.851]  - attr(*, "already-done")= logi TRUE
[10:58:42.859] - copied ‘...future.FUN’ to environment
[10:58:42.859] - copied ‘future.call.arguments’ to environment
[10:58:42.859] - copied ‘...future.elements_ii’ to environment
[10:58:42.859] - copied ‘...future.seeds_ii’ to environment
[10:58:42.859] - copied ‘...future.globals.maxSize’ to environment
[10:58:42.859] assign_globals() ... done
[10:58:42.860] plan(): Setting new future strategy stack:
[10:58:42.860] List of future strategies:
[10:58:42.860] 1. sequential:
[10:58:42.860]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.860]    - tweaked: FALSE
[10:58:42.860]    - call: NULL
[10:58:42.860] plan(): nbrOfWorkers() = 1
[10:58:42.862] plan(): Setting new future strategy stack:
[10:58:42.862] List of future strategies:
[10:58:42.862] 1. sequential:
[10:58:42.862]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.862]    - tweaked: FALSE
[10:58:42.862]    - call: plan(strategy)
[10:58:42.863] plan(): nbrOfWorkers() = 1
[10:58:42.863] SequentialFuture started (and completed)
[10:58:42.863] - Launch lazy future ... done
[10:58:42.863] run() for ‘SequentialFuture’ ... done
[10:58:42.863] Created future:
[10:58:42.864] SequentialFuture:
[10:58:42.864] Label: ‘future_by-1’
[10:58:42.864] Expression:
[10:58:42.864] {
[10:58:42.864]     do.call(function(...) {
[10:58:42.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.864]             on.exit(options(oopts), add = TRUE)
[10:58:42.864]         }
[10:58:42.864]         {
[10:58:42.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.864]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.864]             })
[10:58:42.864]         }
[10:58:42.864]     }, args = future.call.arguments)
[10:58:42.864] }
[10:58:42.864] Lazy evaluation: FALSE
[10:58:42.864] Asynchronous evaluation: FALSE
[10:58:42.864] Local evaluation: TRUE
[10:58:42.864] Environment: 0x55974b8ce898
[10:58:42.864] Capture standard output: TRUE
[10:58:42.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.864] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:42.864] Packages: <none>
[10:58:42.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.864] Resolved: TRUE
[10:58:42.864] Value: 1.39 KiB of class ‘list’
[10:58:42.864] Early signaling: FALSE
[10:58:42.864] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:42.864] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.864] Chunk #1 of 1 ... DONE
[10:58:42.865] Launching 1 futures (chunks) ... DONE
[10:58:42.865] Resolving 1 futures (chunks) ...
[10:58:42.865] resolve() on list ...
[10:58:42.865]  recursive: 0
[10:58:42.865]  length: 1
[10:58:42.865] 
[10:58:42.865] resolved() for ‘SequentialFuture’ ...
[10:58:42.865] - state: ‘finished’
[10:58:42.865] - run: TRUE
[10:58:42.865] - result: ‘FutureResult’
[10:58:42.865] resolved() for ‘SequentialFuture’ ... done
[10:58:42.866] Future #1
[10:58:42.866] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:42.866] - nx: 1
[10:58:42.866] - relay: TRUE
[10:58:42.866] - stdout: TRUE
[10:58:42.866] - signal: TRUE
[10:58:42.866] - resignal: FALSE
[10:58:42.866] - force: TRUE
[10:58:42.866] - relayed: [n=1] FALSE
[10:58:42.866] - queued futures: [n=1] FALSE
[10:58:42.866]  - until=1
[10:58:42.866]  - relaying element #1
[10:58:42.867] - relayed: [n=1] TRUE
[10:58:42.867] - queued futures: [n=1] TRUE
[10:58:42.867] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:42.867]  length: 0 (resolved future 1)
[10:58:42.867] Relaying remaining futures
[10:58:42.867] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.869] - nx: 1
[10:58:42.869] - relay: TRUE
[10:58:42.869] - stdout: TRUE
[10:58:42.869] - signal: TRUE
[10:58:42.869] - resignal: FALSE
[10:58:42.869] - force: TRUE
[10:58:42.869] - relayed: [n=1] TRUE
[10:58:42.869] - queued futures: [n=1] TRUE
 - flush all
[10:58:42.869] - relayed: [n=1] TRUE
[10:58:42.869] - queued futures: [n=1] TRUE
[10:58:42.870] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.870] resolve() on list ... DONE
[10:58:42.870]  - Number of value chunks collected: 1
[10:58:42.870] Resolving 1 futures (chunks) ... DONE
[10:58:42.870] Reducing values from 1 chunks ...
[10:58:42.870]  - Number of values collected after concatenation: 3
[10:58:42.870]  - Number of values expected: 3
[10:58:42.870] Reducing values from 1 chunks ... DONE
[10:58:42.870] future_lapply() ... DONE
[10:58:42.870] future_by_internal() ... DONE
[10:58:42.872] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:58:42.873] future_lapply() ...
[10:58:42.873] Number of chunks: 1
[10:58:42.874] getGlobalsAndPackagesXApply() ...
[10:58:42.874]  - future.globals: TRUE
[10:58:42.874] getGlobalsAndPackages() ...
[10:58:42.874] Searching for globals...
[10:58:42.875] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:42.875] Searching for globals ... DONE
[10:58:42.875] Resolving globals: FALSE
[10:58:42.875] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:42.876] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:42.876] - globals: [1] ‘FUN’
[10:58:42.876] 
[10:58:42.876] getGlobalsAndPackages() ... DONE
[10:58:42.876]  - globals found/used: [n=1] ‘FUN’
[10:58:42.876]  - needed namespaces: [n=0] 
[10:58:42.876] Finding globals ... DONE
[10:58:42.876]  - use_args: TRUE
[10:58:42.876]  - Getting '...' globals ...
[10:58:42.877] resolve() on list ...
[10:58:42.877]  recursive: 0
[10:58:42.877]  length: 1
[10:58:42.877]  elements: ‘...’
[10:58:42.877]  length: 0 (resolved future 1)
[10:58:42.877] resolve() on list ... DONE
[10:58:42.877]    - '...' content: [n=0] 
[10:58:42.877] List of 1
[10:58:42.877]  $ ...: list()
[10:58:42.877]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.877]  - attr(*, "where")=List of 1
[10:58:42.877]   ..$ ...:<environment: 0x55974b8b0300> 
[10:58:42.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.877]  - attr(*, "resolved")= logi TRUE
[10:58:42.877]  - attr(*, "total_size")= num NA
[10:58:42.880]  - Getting '...' globals ... DONE
[10:58:42.880] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:42.880] List of 2
[10:58:42.880]  $ ...future.FUN:function (object, ...)  
[10:58:42.880]  $ ...          : list()
[10:58:42.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.880]  - attr(*, "where")=List of 2
[10:58:42.880]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.880]   ..$ ...          :<environment: 0x55974b8b0300> 
[10:58:42.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.880]  - attr(*, "resolved")= logi FALSE
[10:58:42.880]  - attr(*, "total_size")= num 18647
[10:58:42.883] Packages to be attached in all futures: [n=0] 
[10:58:42.883] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.883] Number of futures (= number of chunks): 1
[10:58:42.883] Launching 1 futures (chunks) ...
[10:58:42.883] Chunk #1 of 1 ...
[10:58:42.883]  - Finding globals in 'X' for chunk #1 ...
[10:58:42.883] getGlobalsAndPackages() ...
[10:58:42.883] Searching for globals...
[10:58:42.884] 
[10:58:42.884] Searching for globals ... DONE
[10:58:42.884] - globals: [0] <none>
[10:58:42.884] getGlobalsAndPackages() ... DONE
[10:58:42.884]    + additional globals found: [n=0] 
[10:58:42.884]    + additional namespaces needed: [n=0] 
[10:58:42.884]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:42.885]  - seeds: <none>
[10:58:42.885]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.885] getGlobalsAndPackages() ...
[10:58:42.885] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.885] Resolving globals: FALSE
[10:58:42.885] Tweak future expression to call with '...' arguments ...
[10:58:42.885] {
[10:58:42.885]     do.call(function(...) {
[10:58:42.885]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.885]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.885]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.885]             on.exit(options(oopts), add = TRUE)
[10:58:42.885]         }
[10:58:42.885]         {
[10:58:42.885]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.885]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.885]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.885]             })
[10:58:42.885]         }
[10:58:42.885]     }, args = future.call.arguments)
[10:58:42.885] }
[10:58:42.885] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.886] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.886] 
[10:58:42.886] getGlobalsAndPackages() ... DONE
[10:58:42.886] run() for ‘Future’ ...
[10:58:42.886] - state: ‘created’
[10:58:42.886] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:42.887] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:42.887]   - Field: ‘label’
[10:58:42.887]   - Field: ‘local’
[10:58:42.887]   - Field: ‘owner’
[10:58:42.887]   - Field: ‘envir’
[10:58:42.887]   - Field: ‘packages’
[10:58:42.887]   - Field: ‘gc’
[10:58:42.889]   - Field: ‘conditions’
[10:58:42.889]   - Field: ‘expr’
[10:58:42.889]   - Field: ‘uuid’
[10:58:42.889]   - Field: ‘seed’
[10:58:42.889]   - Field: ‘version’
[10:58:42.889]   - Field: ‘result’
[10:58:42.889]   - Field: ‘asynchronous’
[10:58:42.890]   - Field: ‘calls’
[10:58:42.890]   - Field: ‘globals’
[10:58:42.890]   - Field: ‘stdout’
[10:58:42.890]   - Field: ‘earlySignal’
[10:58:42.890]   - Field: ‘lazy’
[10:58:42.890]   - Field: ‘state’
[10:58:42.890] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:42.890] - Launch lazy future ...
[10:58:42.890] Packages needed by the future expression (n = 0): <none>
[10:58:42.890] Packages needed by future strategies (n = 0): <none>
[10:58:42.891] {
[10:58:42.891]     {
[10:58:42.891]         {
[10:58:42.891]             ...future.startTime <- base::Sys.time()
[10:58:42.891]             {
[10:58:42.891]                 {
[10:58:42.891]                   {
[10:58:42.891]                     base::local({
[10:58:42.891]                       has_future <- base::requireNamespace("future", 
[10:58:42.891]                         quietly = TRUE)
[10:58:42.891]                       if (has_future) {
[10:58:42.891]                         ns <- base::getNamespace("future")
[10:58:42.891]                         version <- ns[[".package"]][["version"]]
[10:58:42.891]                         if (is.null(version)) 
[10:58:42.891]                           version <- utils::packageVersion("future")
[10:58:42.891]                       }
[10:58:42.891]                       else {
[10:58:42.891]                         version <- NULL
[10:58:42.891]                       }
[10:58:42.891]                       if (!has_future || version < "1.8.0") {
[10:58:42.891]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.891]                           "", base::R.version$version.string), 
[10:58:42.891]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:42.891]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.891]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.891]                             "release", "version")], collapse = " "), 
[10:58:42.891]                           hostname = base::Sys.info()[["nodename"]])
[10:58:42.891]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.891]                           info)
[10:58:42.891]                         info <- base::paste(info, collapse = "; ")
[10:58:42.891]                         if (!has_future) {
[10:58:42.891]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.891]                             info)
[10:58:42.891]                         }
[10:58:42.891]                         else {
[10:58:42.891]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.891]                             info, version)
[10:58:42.891]                         }
[10:58:42.891]                         base::stop(msg)
[10:58:42.891]                       }
[10:58:42.891]                     })
[10:58:42.891]                   }
[10:58:42.891]                   ...future.strategy.old <- future::plan("list")
[10:58:42.891]                   options(future.plan = NULL)
[10:58:42.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.891]                 }
[10:58:42.891]                 ...future.workdir <- getwd()
[10:58:42.891]             }
[10:58:42.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.891]         }
[10:58:42.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:42.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.891]             base::names(...future.oldOptions))
[10:58:42.891]     }
[10:58:42.891]     if (FALSE) {
[10:58:42.891]     }
[10:58:42.891]     else {
[10:58:42.891]         if (TRUE) {
[10:58:42.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.891]                 open = "w")
[10:58:42.891]         }
[10:58:42.891]         else {
[10:58:42.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.891]         }
[10:58:42.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.891]             base::sink(type = "output", split = FALSE)
[10:58:42.891]             base::close(...future.stdout)
[10:58:42.891]         }, add = TRUE)
[10:58:42.891]     }
[10:58:42.891]     ...future.frame <- base::sys.nframe()
[10:58:42.891]     ...future.conditions <- base::list()
[10:58:42.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.891]     if (FALSE) {
[10:58:42.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.891]     }
[10:58:42.891]     ...future.result <- base::tryCatch({
[10:58:42.891]         base::withCallingHandlers({
[10:58:42.891]             ...future.value <- base::withVisible(base::local({
[10:58:42.891]                 do.call(function(...) {
[10:58:42.891]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.891]                   if (!identical(...future.globals.maxSize.org, 
[10:58:42.891]                     ...future.globals.maxSize)) {
[10:58:42.891]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.891]                     on.exit(options(oopts), add = TRUE)
[10:58:42.891]                   }
[10:58:42.891]                   {
[10:58:42.891]                     lapply(seq_along(...future.elements_ii), 
[10:58:42.891]                       FUN = function(jj) {
[10:58:42.891]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.891]                         ...future.FUN(...future.X_jj, ...)
[10:58:42.891]                       })
[10:58:42.891]                   }
[10:58:42.891]                 }, args = future.call.arguments)
[10:58:42.891]             }))
[10:58:42.891]             future::FutureResult(value = ...future.value$value, 
[10:58:42.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.891]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.891]                     ...future.globalenv.names))
[10:58:42.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.891]         }, condition = base::local({
[10:58:42.891]             c <- base::c
[10:58:42.891]             inherits <- base::inherits
[10:58:42.891]             invokeRestart <- base::invokeRestart
[10:58:42.891]             length <- base::length
[10:58:42.891]             list <- base::list
[10:58:42.891]             seq.int <- base::seq.int
[10:58:42.891]             signalCondition <- base::signalCondition
[10:58:42.891]             sys.calls <- base::sys.calls
[10:58:42.891]             `[[` <- base::`[[`
[10:58:42.891]             `+` <- base::`+`
[10:58:42.891]             `<<-` <- base::`<<-`
[10:58:42.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.891]                   3L)]
[10:58:42.891]             }
[10:58:42.891]             function(cond) {
[10:58:42.891]                 is_error <- inherits(cond, "error")
[10:58:42.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.891]                   NULL)
[10:58:42.891]                 if (is_error) {
[10:58:42.891]                   sessionInformation <- function() {
[10:58:42.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.891]                       search = base::search(), system = base::Sys.info())
[10:58:42.891]                   }
[10:58:42.891]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.891]                     cond$call), session = sessionInformation(), 
[10:58:42.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.891]                   signalCondition(cond)
[10:58:42.891]                 }
[10:58:42.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.891]                 "immediateCondition"))) {
[10:58:42.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.891]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.891]                   if (TRUE && !signal) {
[10:58:42.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.891]                     {
[10:58:42.891]                       inherits <- base::inherits
[10:58:42.891]                       invokeRestart <- base::invokeRestart
[10:58:42.891]                       is.null <- base::is.null
[10:58:42.891]                       muffled <- FALSE
[10:58:42.891]                       if (inherits(cond, "message")) {
[10:58:42.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.891]                         if (muffled) 
[10:58:42.891]                           invokeRestart("muffleMessage")
[10:58:42.891]                       }
[10:58:42.891]                       else if (inherits(cond, "warning")) {
[10:58:42.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.891]                         if (muffled) 
[10:58:42.891]                           invokeRestart("muffleWarning")
[10:58:42.891]                       }
[10:58:42.891]                       else if (inherits(cond, "condition")) {
[10:58:42.891]                         if (!is.null(pattern)) {
[10:58:42.891]                           computeRestarts <- base::computeRestarts
[10:58:42.891]                           grepl <- base::grepl
[10:58:42.891]                           restarts <- computeRestarts(cond)
[10:58:42.891]                           for (restart in restarts) {
[10:58:42.891]                             name <- restart$name
[10:58:42.891]                             if (is.null(name)) 
[10:58:42.891]                               next
[10:58:42.891]                             if (!grepl(pattern, name)) 
[10:58:42.891]                               next
[10:58:42.891]                             invokeRestart(restart)
[10:58:42.891]                             muffled <- TRUE
[10:58:42.891]                             break
[10:58:42.891]                           }
[10:58:42.891]                         }
[10:58:42.891]                       }
[10:58:42.891]                       invisible(muffled)
[10:58:42.891]                     }
[10:58:42.891]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.891]                   }
[10:58:42.891]                 }
[10:58:42.891]                 else {
[10:58:42.891]                   if (TRUE) {
[10:58:42.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.891]                     {
[10:58:42.891]                       inherits <- base::inherits
[10:58:42.891]                       invokeRestart <- base::invokeRestart
[10:58:42.891]                       is.null <- base::is.null
[10:58:42.891]                       muffled <- FALSE
[10:58:42.891]                       if (inherits(cond, "message")) {
[10:58:42.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.891]                         if (muffled) 
[10:58:42.891]                           invokeRestart("muffleMessage")
[10:58:42.891]                       }
[10:58:42.891]                       else if (inherits(cond, "warning")) {
[10:58:42.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.891]                         if (muffled) 
[10:58:42.891]                           invokeRestart("muffleWarning")
[10:58:42.891]                       }
[10:58:42.891]                       else if (inherits(cond, "condition")) {
[10:58:42.891]                         if (!is.null(pattern)) {
[10:58:42.891]                           computeRestarts <- base::computeRestarts
[10:58:42.891]                           grepl <- base::grepl
[10:58:42.891]                           restarts <- computeRestarts(cond)
[10:58:42.891]                           for (restart in restarts) {
[10:58:42.891]                             name <- restart$name
[10:58:42.891]                             if (is.null(name)) 
[10:58:42.891]                               next
[10:58:42.891]                             if (!grepl(pattern, name)) 
[10:58:42.891]                               next
[10:58:42.891]                             invokeRestart(restart)
[10:58:42.891]                             muffled <- TRUE
[10:58:42.891]                             break
[10:58:42.891]                           }
[10:58:42.891]                         }
[10:58:42.891]                       }
[10:58:42.891]                       invisible(muffled)
[10:58:42.891]                     }
[10:58:42.891]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.891]                   }
[10:58:42.891]                 }
[10:58:42.891]             }
[10:58:42.891]         }))
[10:58:42.891]     }, error = function(ex) {
[10:58:42.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.891]                 ...future.rng), started = ...future.startTime, 
[10:58:42.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.891]             version = "1.8"), class = "FutureResult")
[10:58:42.891]     }, finally = {
[10:58:42.891]         if (!identical(...future.workdir, getwd())) 
[10:58:42.891]             setwd(...future.workdir)
[10:58:42.891]         {
[10:58:42.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.891]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.891]             }
[10:58:42.891]             base::options(...future.oldOptions)
[10:58:42.891]             if (.Platform$OS.type == "windows") {
[10:58:42.891]                 old_names <- names(...future.oldEnvVars)
[10:58:42.891]                 envs <- base::Sys.getenv()
[10:58:42.891]                 names <- names(envs)
[10:58:42.891]                 common <- intersect(names, old_names)
[10:58:42.891]                 added <- setdiff(names, old_names)
[10:58:42.891]                 removed <- setdiff(old_names, names)
[10:58:42.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.891]                   envs[common]]
[10:58:42.891]                 NAMES <- toupper(changed)
[10:58:42.891]                 args <- list()
[10:58:42.891]                 for (kk in seq_along(NAMES)) {
[10:58:42.891]                   name <- changed[[kk]]
[10:58:42.891]                   NAME <- NAMES[[kk]]
[10:58:42.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.891]                     next
[10:58:42.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.891]                 }
[10:58:42.891]                 NAMES <- toupper(added)
[10:58:42.891]                 for (kk in seq_along(NAMES)) {
[10:58:42.891]                   name <- added[[kk]]
[10:58:42.891]                   NAME <- NAMES[[kk]]
[10:58:42.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.891]                     next
[10:58:42.891]                   args[[name]] <- ""
[10:58:42.891]                 }
[10:58:42.891]                 NAMES <- toupper(removed)
[10:58:42.891]                 for (kk in seq_along(NAMES)) {
[10:58:42.891]                   name <- removed[[kk]]
[10:58:42.891]                   NAME <- NAMES[[kk]]
[10:58:42.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.891]                     next
[10:58:42.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.891]                 }
[10:58:42.891]                 if (length(args) > 0) 
[10:58:42.891]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.891]             }
[10:58:42.891]             else {
[10:58:42.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.891]             }
[10:58:42.891]             {
[10:58:42.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.891]                   0L) {
[10:58:42.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.891]                   base::options(opts)
[10:58:42.891]                 }
[10:58:42.891]                 {
[10:58:42.891]                   {
[10:58:42.891]                     NULL
[10:58:42.891]                     RNGkind("Mersenne-Twister")
[10:58:42.891]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:42.891]                       inherits = FALSE)
[10:58:42.891]                   }
[10:58:42.891]                   options(future.plan = NULL)
[10:58:42.891]                   if (is.na(NA_character_)) 
[10:58:42.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.891]                     .init = FALSE)
[10:58:42.891]                 }
[10:58:42.891]             }
[10:58:42.891]         }
[10:58:42.891]     })
[10:58:42.891]     if (TRUE) {
[10:58:42.891]         base::sink(type = "output", split = FALSE)
[10:58:42.891]         if (TRUE) {
[10:58:42.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.891]         }
[10:58:42.891]         else {
[10:58:42.891]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.891]         }
[10:58:42.891]         base::close(...future.stdout)
[10:58:42.891]         ...future.stdout <- NULL
[10:58:42.891]     }
[10:58:42.891]     ...future.result$conditions <- ...future.conditions
[10:58:42.891]     ...future.result$finished <- base::Sys.time()
[10:58:42.891]     ...future.result
[10:58:42.891] }
[10:58:42.893] assign_globals() ...
[10:58:42.893] List of 5
[10:58:42.893]  $ ...future.FUN            :function (object, ...)  
[10:58:42.893]  $ future.call.arguments    : list()
[10:58:42.893]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.893]  $ ...future.elements_ii    :List of 3
[10:58:42.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.893]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:42.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:42.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.893]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:42.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:42.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:42.893]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:42.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:42.893]  $ ...future.seeds_ii       : NULL
[10:58:42.893]  $ ...future.globals.maxSize: NULL
[10:58:42.893]  - attr(*, "where")=List of 5
[10:58:42.893]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:42.893]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:42.893]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:42.893]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:42.893]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:42.893]  - attr(*, "resolved")= logi FALSE
[10:58:42.893]  - attr(*, "total_size")= num 18647
[10:58:42.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.893]  - attr(*, "already-done")= logi TRUE
[10:58:42.901] - copied ‘...future.FUN’ to environment
[10:58:42.901] - copied ‘future.call.arguments’ to environment
[10:58:42.901] - copied ‘...future.elements_ii’ to environment
[10:58:42.901] - copied ‘...future.seeds_ii’ to environment
[10:58:42.901] - copied ‘...future.globals.maxSize’ to environment
[10:58:42.901] assign_globals() ... done
[10:58:42.902] plan(): Setting new future strategy stack:
[10:58:42.902] List of future strategies:
[10:58:42.902] 1. sequential:
[10:58:42.902]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.902]    - tweaked: FALSE
[10:58:42.902]    - call: NULL
[10:58:42.902] plan(): nbrOfWorkers() = 1
[10:58:42.904] plan(): Setting new future strategy stack:
[10:58:42.905] List of future strategies:
[10:58:42.905] 1. sequential:
[10:58:42.905]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.905]    - tweaked: FALSE
[10:58:42.905]    - call: plan(strategy)
[10:58:42.905] plan(): nbrOfWorkers() = 1
[10:58:42.905] SequentialFuture started (and completed)
[10:58:42.905] - Launch lazy future ... done
[10:58:42.905] run() for ‘SequentialFuture’ ... done
[10:58:42.906] Created future:
[10:58:42.906] SequentialFuture:
[10:58:42.906] Label: ‘future_by-1’
[10:58:42.906] Expression:
[10:58:42.906] {
[10:58:42.906]     do.call(function(...) {
[10:58:42.906]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.906]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.906]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.906]             on.exit(options(oopts), add = TRUE)
[10:58:42.906]         }
[10:58:42.906]         {
[10:58:42.906]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.906]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.906]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.906]             })
[10:58:42.906]         }
[10:58:42.906]     }, args = future.call.arguments)
[10:58:42.906] }
[10:58:42.906] Lazy evaluation: FALSE
[10:58:42.906] Asynchronous evaluation: FALSE
[10:58:42.906] Local evaluation: TRUE
[10:58:42.906] Environment: 0x55974c1b1a30
[10:58:42.906] Capture standard output: TRUE
[10:58:42.906] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.906] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:42.906] Packages: <none>
[10:58:42.906] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.906] Resolved: TRUE
[10:58:42.906] Value: 1.39 KiB of class ‘list’
[10:58:42.906] Early signaling: FALSE
[10:58:42.906] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:42.906] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.907] Chunk #1 of 1 ... DONE
[10:58:42.907] Launching 1 futures (chunks) ... DONE
[10:58:42.907] Resolving 1 futures (chunks) ...
[10:58:42.907] resolve() on list ...
[10:58:42.907]  recursive: 0
[10:58:42.907]  length: 1
[10:58:42.907] 
[10:58:42.907] resolved() for ‘SequentialFuture’ ...
[10:58:42.907] - state: ‘finished’
[10:58:42.907] - run: TRUE
[10:58:42.907] - result: ‘FutureResult’
[10:58:42.908] resolved() for ‘SequentialFuture’ ... done
[10:58:42.908] Future #1
[10:58:42.908] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:42.908] - nx: 1
[10:58:42.908] - relay: TRUE
[10:58:42.908] - stdout: TRUE
[10:58:42.908] - signal: TRUE
[10:58:42.908] - resignal: FALSE
[10:58:42.908] - force: TRUE
[10:58:42.908] - relayed: [n=1] FALSE
[10:58:42.908] - queued futures: [n=1] FALSE
[10:58:42.909]  - until=1
[10:58:42.909]  - relaying element #1
[10:58:42.909] - relayed: [n=1] TRUE
[10:58:42.909] - queued futures: [n=1] TRUE
[10:58:42.909] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:42.909]  length: 0 (resolved future 1)
[10:58:42.911] Relaying remaining futures
[10:58:42.911] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.911] - nx: 1
[10:58:42.911] - relay: TRUE
[10:58:42.911] - stdout: TRUE
[10:58:42.911] - signal: TRUE
[10:58:42.911] - resignal: FALSE
[10:58:42.911] - force: TRUE
[10:58:42.911] - relayed: [n=1] TRUE
[10:58:42.911] - queued futures: [n=1] TRUE
 - flush all
[10:58:42.911] - relayed: [n=1] TRUE
[10:58:42.912] - queued futures: [n=1] TRUE
[10:58:42.912] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.912] resolve() on list ... DONE
[10:58:42.912]  - Number of value chunks collected: 1
[10:58:42.912] Resolving 1 futures (chunks) ... DONE
[10:58:42.912] Reducing values from 1 chunks ...
[10:58:42.912]  - Number of values collected after concatenation: 3
[10:58:42.912]  - Number of values expected: 3
[10:58:42.912] Reducing values from 1 chunks ... DONE
[10:58:42.912] future_lapply() ... DONE
[10:58:42.912] future_by_internal() ... DONE
[10:58:42.913] future_by_internal() ...
- plan('multicore') ...
[10:58:42.914] plan(): Setting new future strategy stack:
[10:58:42.914] List of future strategies:
[10:58:42.914] 1. multicore:
[10:58:42.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:42.914]    - tweaked: FALSE
[10:58:42.914]    - call: plan(strategy)
[10:58:42.916] plan(): nbrOfWorkers() = 1
[10:58:42.916] future_by_internal() ...
[10:58:42.916] future_lapply() ...
[10:58:42.918] Number of chunks: 1
[10:58:42.918] getGlobalsAndPackagesXApply() ...
[10:58:42.918]  - future.globals: TRUE
[10:58:42.918] getGlobalsAndPackages() ...
[10:58:42.918] Searching for globals...
[10:58:42.919] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:42.919] Searching for globals ... DONE
[10:58:42.920] Resolving globals: FALSE
[10:58:42.920] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:42.920] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:42.920] - globals: [1] ‘FUN’
[10:58:42.920] 
[10:58:42.920] getGlobalsAndPackages() ... DONE
[10:58:42.921]  - globals found/used: [n=1] ‘FUN’
[10:58:42.921]  - needed namespaces: [n=0] 
[10:58:42.921] Finding globals ... DONE
[10:58:42.921]  - use_args: TRUE
[10:58:42.921]  - Getting '...' globals ...
[10:58:42.921] resolve() on list ...
[10:58:42.921]  recursive: 0
[10:58:42.921]  length: 1
[10:58:42.922]  elements: ‘...’
[10:58:42.922]  length: 0 (resolved future 1)
[10:58:42.922] resolve() on list ... DONE
[10:58:42.922]    - '...' content: [n=0] 
[10:58:42.922] List of 1
[10:58:42.922]  $ ...: list()
[10:58:42.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.922]  - attr(*, "where")=List of 1
[10:58:42.922]   ..$ ...:<environment: 0x55974b7cda80> 
[10:58:42.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.922]  - attr(*, "resolved")= logi TRUE
[10:58:42.922]  - attr(*, "total_size")= num NA
[10:58:42.924]  - Getting '...' globals ... DONE
[10:58:42.924] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:42.925] List of 2
[10:58:42.925]  $ ...future.FUN:function (object, ...)  
[10:58:42.925]  $ ...          : list()
[10:58:42.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.925]  - attr(*, "where")=List of 2
[10:58:42.925]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.925]   ..$ ...          :<environment: 0x55974b7cda80> 
[10:58:42.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.925]  - attr(*, "resolved")= logi FALSE
[10:58:42.925]  - attr(*, "total_size")= num 15670
[10:58:42.927] Packages to be attached in all futures: [n=0] 
[10:58:42.927] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.927] Number of futures (= number of chunks): 1
[10:58:42.927] Launching 1 futures (chunks) ...
[10:58:42.928] Chunk #1 of 1 ...
[10:58:42.928]  - Finding globals in 'X' for chunk #1 ...
[10:58:42.928] getGlobalsAndPackages() ...
[10:58:42.928] Searching for globals...
[10:58:42.928] 
[10:58:42.928] Searching for globals ... DONE
[10:58:42.928] - globals: [0] <none>
[10:58:42.929] getGlobalsAndPackages() ... DONE
[10:58:42.929]    + additional globals found: [n=0] 
[10:58:42.929]    + additional namespaces needed: [n=0] 
[10:58:42.929]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:42.929]  - seeds: <none>
[10:58:42.929]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.929] getGlobalsAndPackages() ...
[10:58:42.929] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.929] Resolving globals: FALSE
[10:58:42.929] Tweak future expression to call with '...' arguments ...
[10:58:42.929] {
[10:58:42.929]     do.call(function(...) {
[10:58:42.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.929]             on.exit(options(oopts), add = TRUE)
[10:58:42.929]         }
[10:58:42.929]         {
[10:58:42.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.929]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.929]             })
[10:58:42.929]         }
[10:58:42.929]     }, args = future.call.arguments)
[10:58:42.929] }
[10:58:42.930] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.930] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.932] 
[10:58:42.932] getGlobalsAndPackages() ... DONE
[10:58:42.932] run() for ‘Future’ ...
[10:58:42.932] - state: ‘created’
[10:58:42.932] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:42.934] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:42.934]   - Field: ‘label’
[10:58:42.934]   - Field: ‘local’
[10:58:42.934]   - Field: ‘owner’
[10:58:42.934]   - Field: ‘envir’
[10:58:42.935]   - Field: ‘packages’
[10:58:42.935]   - Field: ‘gc’
[10:58:42.935]   - Field: ‘conditions’
[10:58:42.935]   - Field: ‘expr’
[10:58:42.935]   - Field: ‘uuid’
[10:58:42.935]   - Field: ‘seed’
[10:58:42.935]   - Field: ‘version’
[10:58:42.935]   - Field: ‘result’
[10:58:42.935]   - Field: ‘asynchronous’
[10:58:42.935]   - Field: ‘calls’
[10:58:42.936]   - Field: ‘globals’
[10:58:42.936]   - Field: ‘stdout’
[10:58:42.936]   - Field: ‘earlySignal’
[10:58:42.936]   - Field: ‘lazy’
[10:58:42.936]   - Field: ‘state’
[10:58:42.936] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:42.936] - Launch lazy future ...
[10:58:42.936] Packages needed by the future expression (n = 0): <none>
[10:58:42.936] Packages needed by future strategies (n = 0): <none>
[10:58:42.937] {
[10:58:42.937]     {
[10:58:42.937]         {
[10:58:42.937]             ...future.startTime <- base::Sys.time()
[10:58:42.937]             {
[10:58:42.937]                 {
[10:58:42.937]                   {
[10:58:42.937]                     base::local({
[10:58:42.937]                       has_future <- base::requireNamespace("future", 
[10:58:42.937]                         quietly = TRUE)
[10:58:42.937]                       if (has_future) {
[10:58:42.937]                         ns <- base::getNamespace("future")
[10:58:42.937]                         version <- ns[[".package"]][["version"]]
[10:58:42.937]                         if (is.null(version)) 
[10:58:42.937]                           version <- utils::packageVersion("future")
[10:58:42.937]                       }
[10:58:42.937]                       else {
[10:58:42.937]                         version <- NULL
[10:58:42.937]                       }
[10:58:42.937]                       if (!has_future || version < "1.8.0") {
[10:58:42.937]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.937]                           "", base::R.version$version.string), 
[10:58:42.937]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:42.937]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.937]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.937]                             "release", "version")], collapse = " "), 
[10:58:42.937]                           hostname = base::Sys.info()[["nodename"]])
[10:58:42.937]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.937]                           info)
[10:58:42.937]                         info <- base::paste(info, collapse = "; ")
[10:58:42.937]                         if (!has_future) {
[10:58:42.937]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.937]                             info)
[10:58:42.937]                         }
[10:58:42.937]                         else {
[10:58:42.937]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.937]                             info, version)
[10:58:42.937]                         }
[10:58:42.937]                         base::stop(msg)
[10:58:42.937]                       }
[10:58:42.937]                     })
[10:58:42.937]                   }
[10:58:42.937]                   ...future.strategy.old <- future::plan("list")
[10:58:42.937]                   options(future.plan = NULL)
[10:58:42.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.937]                 }
[10:58:42.937]                 ...future.workdir <- getwd()
[10:58:42.937]             }
[10:58:42.937]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.937]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.937]         }
[10:58:42.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.937]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:42.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.937]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.937]             base::names(...future.oldOptions))
[10:58:42.937]     }
[10:58:42.937]     if (FALSE) {
[10:58:42.937]     }
[10:58:42.937]     else {
[10:58:42.937]         if (TRUE) {
[10:58:42.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.937]                 open = "w")
[10:58:42.937]         }
[10:58:42.937]         else {
[10:58:42.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.937]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.937]         }
[10:58:42.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.937]             base::sink(type = "output", split = FALSE)
[10:58:42.937]             base::close(...future.stdout)
[10:58:42.937]         }, add = TRUE)
[10:58:42.937]     }
[10:58:42.937]     ...future.frame <- base::sys.nframe()
[10:58:42.937]     ...future.conditions <- base::list()
[10:58:42.937]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.937]     if (FALSE) {
[10:58:42.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.937]     }
[10:58:42.937]     ...future.result <- base::tryCatch({
[10:58:42.937]         base::withCallingHandlers({
[10:58:42.937]             ...future.value <- base::withVisible(base::local({
[10:58:42.937]                 do.call(function(...) {
[10:58:42.937]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.937]                   if (!identical(...future.globals.maxSize.org, 
[10:58:42.937]                     ...future.globals.maxSize)) {
[10:58:42.937]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.937]                     on.exit(options(oopts), add = TRUE)
[10:58:42.937]                   }
[10:58:42.937]                   {
[10:58:42.937]                     lapply(seq_along(...future.elements_ii), 
[10:58:42.937]                       FUN = function(jj) {
[10:58:42.937]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.937]                         ...future.FUN(...future.X_jj, ...)
[10:58:42.937]                       })
[10:58:42.937]                   }
[10:58:42.937]                 }, args = future.call.arguments)
[10:58:42.937]             }))
[10:58:42.937]             future::FutureResult(value = ...future.value$value, 
[10:58:42.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.937]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.937]                     ...future.globalenv.names))
[10:58:42.937]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.937]         }, condition = base::local({
[10:58:42.937]             c <- base::c
[10:58:42.937]             inherits <- base::inherits
[10:58:42.937]             invokeRestart <- base::invokeRestart
[10:58:42.937]             length <- base::length
[10:58:42.937]             list <- base::list
[10:58:42.937]             seq.int <- base::seq.int
[10:58:42.937]             signalCondition <- base::signalCondition
[10:58:42.937]             sys.calls <- base::sys.calls
[10:58:42.937]             `[[` <- base::`[[`
[10:58:42.937]             `+` <- base::`+`
[10:58:42.937]             `<<-` <- base::`<<-`
[10:58:42.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.937]                   3L)]
[10:58:42.937]             }
[10:58:42.937]             function(cond) {
[10:58:42.937]                 is_error <- inherits(cond, "error")
[10:58:42.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.937]                   NULL)
[10:58:42.937]                 if (is_error) {
[10:58:42.937]                   sessionInformation <- function() {
[10:58:42.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.937]                       search = base::search(), system = base::Sys.info())
[10:58:42.937]                   }
[10:58:42.937]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.937]                     cond$call), session = sessionInformation(), 
[10:58:42.937]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.937]                   signalCondition(cond)
[10:58:42.937]                 }
[10:58:42.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.937]                 "immediateCondition"))) {
[10:58:42.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.937]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.937]                   if (TRUE && !signal) {
[10:58:42.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.937]                     {
[10:58:42.937]                       inherits <- base::inherits
[10:58:42.937]                       invokeRestart <- base::invokeRestart
[10:58:42.937]                       is.null <- base::is.null
[10:58:42.937]                       muffled <- FALSE
[10:58:42.937]                       if (inherits(cond, "message")) {
[10:58:42.937]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.937]                         if (muffled) 
[10:58:42.937]                           invokeRestart("muffleMessage")
[10:58:42.937]                       }
[10:58:42.937]                       else if (inherits(cond, "warning")) {
[10:58:42.937]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.937]                         if (muffled) 
[10:58:42.937]                           invokeRestart("muffleWarning")
[10:58:42.937]                       }
[10:58:42.937]                       else if (inherits(cond, "condition")) {
[10:58:42.937]                         if (!is.null(pattern)) {
[10:58:42.937]                           computeRestarts <- base::computeRestarts
[10:58:42.937]                           grepl <- base::grepl
[10:58:42.937]                           restarts <- computeRestarts(cond)
[10:58:42.937]                           for (restart in restarts) {
[10:58:42.937]                             name <- restart$name
[10:58:42.937]                             if (is.null(name)) 
[10:58:42.937]                               next
[10:58:42.937]                             if (!grepl(pattern, name)) 
[10:58:42.937]                               next
[10:58:42.937]                             invokeRestart(restart)
[10:58:42.937]                             muffled <- TRUE
[10:58:42.937]                             break
[10:58:42.937]                           }
[10:58:42.937]                         }
[10:58:42.937]                       }
[10:58:42.937]                       invisible(muffled)
[10:58:42.937]                     }
[10:58:42.937]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.937]                   }
[10:58:42.937]                 }
[10:58:42.937]                 else {
[10:58:42.937]                   if (TRUE) {
[10:58:42.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.937]                     {
[10:58:42.937]                       inherits <- base::inherits
[10:58:42.937]                       invokeRestart <- base::invokeRestart
[10:58:42.937]                       is.null <- base::is.null
[10:58:42.937]                       muffled <- FALSE
[10:58:42.937]                       if (inherits(cond, "message")) {
[10:58:42.937]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.937]                         if (muffled) 
[10:58:42.937]                           invokeRestart("muffleMessage")
[10:58:42.937]                       }
[10:58:42.937]                       else if (inherits(cond, "warning")) {
[10:58:42.937]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.937]                         if (muffled) 
[10:58:42.937]                           invokeRestart("muffleWarning")
[10:58:42.937]                       }
[10:58:42.937]                       else if (inherits(cond, "condition")) {
[10:58:42.937]                         if (!is.null(pattern)) {
[10:58:42.937]                           computeRestarts <- base::computeRestarts
[10:58:42.937]                           grepl <- base::grepl
[10:58:42.937]                           restarts <- computeRestarts(cond)
[10:58:42.937]                           for (restart in restarts) {
[10:58:42.937]                             name <- restart$name
[10:58:42.937]                             if (is.null(name)) 
[10:58:42.937]                               next
[10:58:42.937]                             if (!grepl(pattern, name)) 
[10:58:42.937]                               next
[10:58:42.937]                             invokeRestart(restart)
[10:58:42.937]                             muffled <- TRUE
[10:58:42.937]                             break
[10:58:42.937]                           }
[10:58:42.937]                         }
[10:58:42.937]                       }
[10:58:42.937]                       invisible(muffled)
[10:58:42.937]                     }
[10:58:42.937]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.937]                   }
[10:58:42.937]                 }
[10:58:42.937]             }
[10:58:42.937]         }))
[10:58:42.937]     }, error = function(ex) {
[10:58:42.937]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.937]                 ...future.rng), started = ...future.startTime, 
[10:58:42.937]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.937]             version = "1.8"), class = "FutureResult")
[10:58:42.937]     }, finally = {
[10:58:42.937]         if (!identical(...future.workdir, getwd())) 
[10:58:42.937]             setwd(...future.workdir)
[10:58:42.937]         {
[10:58:42.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.937]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.937]             }
[10:58:42.937]             base::options(...future.oldOptions)
[10:58:42.937]             if (.Platform$OS.type == "windows") {
[10:58:42.937]                 old_names <- names(...future.oldEnvVars)
[10:58:42.937]                 envs <- base::Sys.getenv()
[10:58:42.937]                 names <- names(envs)
[10:58:42.937]                 common <- intersect(names, old_names)
[10:58:42.937]                 added <- setdiff(names, old_names)
[10:58:42.937]                 removed <- setdiff(old_names, names)
[10:58:42.937]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.937]                   envs[common]]
[10:58:42.937]                 NAMES <- toupper(changed)
[10:58:42.937]                 args <- list()
[10:58:42.937]                 for (kk in seq_along(NAMES)) {
[10:58:42.937]                   name <- changed[[kk]]
[10:58:42.937]                   NAME <- NAMES[[kk]]
[10:58:42.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.937]                     next
[10:58:42.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.937]                 }
[10:58:42.937]                 NAMES <- toupper(added)
[10:58:42.937]                 for (kk in seq_along(NAMES)) {
[10:58:42.937]                   name <- added[[kk]]
[10:58:42.937]                   NAME <- NAMES[[kk]]
[10:58:42.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.937]                     next
[10:58:42.937]                   args[[name]] <- ""
[10:58:42.937]                 }
[10:58:42.937]                 NAMES <- toupper(removed)
[10:58:42.937]                 for (kk in seq_along(NAMES)) {
[10:58:42.937]                   name <- removed[[kk]]
[10:58:42.937]                   NAME <- NAMES[[kk]]
[10:58:42.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.937]                     next
[10:58:42.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.937]                 }
[10:58:42.937]                 if (length(args) > 0) 
[10:58:42.937]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.937]             }
[10:58:42.937]             else {
[10:58:42.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.937]             }
[10:58:42.937]             {
[10:58:42.937]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.937]                   0L) {
[10:58:42.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.937]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.937]                   base::options(opts)
[10:58:42.937]                 }
[10:58:42.937]                 {
[10:58:42.937]                   {
[10:58:42.937]                     NULL
[10:58:42.937]                     RNGkind("Mersenne-Twister")
[10:58:42.937]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:42.937]                       inherits = FALSE)
[10:58:42.937]                   }
[10:58:42.937]                   options(future.plan = NULL)
[10:58:42.937]                   if (is.na(NA_character_)) 
[10:58:42.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.937]                     .init = FALSE)
[10:58:42.937]                 }
[10:58:42.937]             }
[10:58:42.937]         }
[10:58:42.937]     })
[10:58:42.937]     if (TRUE) {
[10:58:42.937]         base::sink(type = "output", split = FALSE)
[10:58:42.937]         if (TRUE) {
[10:58:42.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.937]         }
[10:58:42.937]         else {
[10:58:42.937]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.937]         }
[10:58:42.937]         base::close(...future.stdout)
[10:58:42.937]         ...future.stdout <- NULL
[10:58:42.937]     }
[10:58:42.937]     ...future.result$conditions <- ...future.conditions
[10:58:42.937]     ...future.result$finished <- base::Sys.time()
[10:58:42.937]     ...future.result
[10:58:42.937] }
[10:58:42.939] assign_globals() ...
[10:58:42.939] List of 5
[10:58:42.939]  $ ...future.FUN            :function (object, ...)  
[10:58:42.939]  $ future.call.arguments    : list()
[10:58:42.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.939]  $ ...future.elements_ii    :List of 3
[10:58:42.939]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:42.939]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:42.939]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.939]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:42.939]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:42.939]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.939]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:42.939]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:42.939]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:42.939]  $ ...future.seeds_ii       : NULL
[10:58:42.939]  $ ...future.globals.maxSize: NULL
[10:58:42.939]  - attr(*, "where")=List of 5
[10:58:42.939]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:42.939]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:42.939]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:42.939]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:42.939]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:42.939]  - attr(*, "resolved")= logi FALSE
[10:58:42.939]  - attr(*, "total_size")= num 15670
[10:58:42.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.939]  - attr(*, "already-done")= logi TRUE
[10:58:42.946] - copied ‘...future.FUN’ to environment
[10:58:42.946] - copied ‘future.call.arguments’ to environment
[10:58:42.946] - copied ‘...future.elements_ii’ to environment
[10:58:42.946] - copied ‘...future.seeds_ii’ to environment
[10:58:42.946] - copied ‘...future.globals.maxSize’ to environment
[10:58:42.946] assign_globals() ... done
[10:58:42.947] plan(): Setting new future strategy stack:
[10:58:42.947] List of future strategies:
[10:58:42.947] 1. sequential:
[10:58:42.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.947]    - tweaked: FALSE
[10:58:42.947]    - call: NULL
[10:58:42.947] plan(): nbrOfWorkers() = 1
[10:58:42.949] plan(): Setting new future strategy stack:
[10:58:42.949] List of future strategies:
[10:58:42.949] 1. multicore:
[10:58:42.949]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:42.949]    - tweaked: FALSE
[10:58:42.949]    - call: plan(strategy)
[10:58:42.951] plan(): nbrOfWorkers() = 1
[10:58:42.951] SequentialFuture started (and completed)
[10:58:42.951] - Launch lazy future ... done
[10:58:42.951] run() for ‘SequentialFuture’ ... done
[10:58:42.951] Created future:
[10:58:42.952] SequentialFuture:
[10:58:42.952] Label: ‘future_by-1’
[10:58:42.952] Expression:
[10:58:42.952] {
[10:58:42.952]     do.call(function(...) {
[10:58:42.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.952]             on.exit(options(oopts), add = TRUE)
[10:58:42.952]         }
[10:58:42.952]         {
[10:58:42.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.952]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.952]             })
[10:58:42.952]         }
[10:58:42.952]     }, args = future.call.arguments)
[10:58:42.952] }
[10:58:42.952] Lazy evaluation: FALSE
[10:58:42.952] Asynchronous evaluation: FALSE
[10:58:42.952] Local evaluation: TRUE
[10:58:42.952] Environment: R_GlobalEnv
[10:58:42.952] Capture standard output: TRUE
[10:58:42.952] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.952] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:42.952] Packages: <none>
[10:58:42.952] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.952] Resolved: TRUE
[10:58:42.952] Value: 1.16 KiB of class ‘list’
[10:58:42.952] Early signaling: FALSE
[10:58:42.952] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:42.952] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.952] Chunk #1 of 1 ... DONE
[10:58:42.952] Launching 1 futures (chunks) ... DONE
[10:58:42.953] Resolving 1 futures (chunks) ...
[10:58:42.953] resolve() on list ...
[10:58:42.953]  recursive: 0
[10:58:42.953]  length: 1
[10:58:42.953] 
[10:58:42.953] resolved() for ‘SequentialFuture’ ...
[10:58:42.953] - state: ‘finished’
[10:58:42.953] - run: TRUE
[10:58:42.955] - result: ‘FutureResult’
[10:58:42.955] resolved() for ‘SequentialFuture’ ... done
[10:58:42.955] Future #1
[10:58:42.955] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:42.955] - nx: 1
[10:58:42.955] - relay: TRUE
[10:58:42.955] - stdout: TRUE
[10:58:42.955] - signal: TRUE
[10:58:42.956] - resignal: FALSE
[10:58:42.956] - force: TRUE
[10:58:42.956] - relayed: [n=1] FALSE
[10:58:42.956] - queued futures: [n=1] FALSE
[10:58:42.956]  - until=1
[10:58:42.956]  - relaying element #1
[10:58:42.956] - relayed: [n=1] TRUE
[10:58:42.956] - queued futures: [n=1] TRUE
[10:58:42.956] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:42.956]  length: 0 (resolved future 1)
[10:58:42.957] Relaying remaining futures
[10:58:42.957] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.957] - nx: 1
[10:58:42.957] - relay: TRUE
[10:58:42.957] - stdout: TRUE
[10:58:42.957] - signal: TRUE
[10:58:42.957] - resignal: FALSE
[10:58:42.957] - force: TRUE
[10:58:42.957] - relayed: [n=1] TRUE
[10:58:42.957] - queued futures: [n=1] TRUE
 - flush all
[10:58:42.957] - relayed: [n=1] TRUE
[10:58:42.957] - queued futures: [n=1] TRUE
[10:58:42.957] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.958] resolve() on list ... DONE
[10:58:42.958]  - Number of value chunks collected: 1
[10:58:42.958] Resolving 1 futures (chunks) ... DONE
[10:58:42.958] Reducing values from 1 chunks ...
[10:58:42.958]  - Number of values collected after concatenation: 3
[10:58:42.958]  - Number of values expected: 3
[10:58:42.958] Reducing values from 1 chunks ... DONE
[10:58:42.958] future_lapply() ... DONE
[10:58:42.958] future_by_internal() ... DONE
[10:58:42.959] future_by_internal() ...
[10:58:42.959] future_lapply() ...
[10:58:42.961] Number of chunks: 1
[10:58:42.961] getGlobalsAndPackagesXApply() ...
[10:58:42.961]  - future.globals: TRUE
[10:58:42.961] getGlobalsAndPackages() ...
[10:58:42.961] Searching for globals...
[10:58:42.962] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:42.962] Searching for globals ... DONE
[10:58:42.962] Resolving globals: FALSE
[10:58:42.963] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:42.963] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:42.963] - globals: [1] ‘FUN’
[10:58:42.963] 
[10:58:42.963] getGlobalsAndPackages() ... DONE
[10:58:42.963]  - globals found/used: [n=1] ‘FUN’
[10:58:42.963]  - needed namespaces: [n=0] 
[10:58:42.963] Finding globals ... DONE
[10:58:42.964]  - use_args: TRUE
[10:58:42.964]  - Getting '...' globals ...
[10:58:42.964] resolve() on list ...
[10:58:42.964]  recursive: 0
[10:58:42.964]  length: 1
[10:58:42.964]  elements: ‘...’
[10:58:42.964]  length: 0 (resolved future 1)
[10:58:42.964] resolve() on list ... DONE
[10:58:42.964]    - '...' content: [n=1] ‘digits’
[10:58:42.965] List of 1
[10:58:42.965]  $ ...:List of 1
[10:58:42.965]   ..$ digits: int 2
[10:58:42.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.965]  - attr(*, "where")=List of 1
[10:58:42.965]   ..$ ...:<environment: 0x55974b8e4220> 
[10:58:42.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.965]  - attr(*, "resolved")= logi TRUE
[10:58:42.965]  - attr(*, "total_size")= num NA
[10:58:42.967]  - Getting '...' globals ... DONE
[10:58:42.967] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:42.968] List of 2
[10:58:42.968]  $ ...future.FUN:function (object, ...)  
[10:58:42.968]  $ ...          :List of 1
[10:58:42.968]   ..$ digits: int 2
[10:58:42.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.968]  - attr(*, "where")=List of 2
[10:58:42.968]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.968]   ..$ ...          :<environment: 0x55974b8e4220> 
[10:58:42.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.968]  - attr(*, "resolved")= logi FALSE
[10:58:42.968]  - attr(*, "total_size")= num 13284
[10:58:42.970] Packages to be attached in all futures: [n=0] 
[10:58:42.971] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.971] Number of futures (= number of chunks): 1
[10:58:42.971] Launching 1 futures (chunks) ...
[10:58:42.971] Chunk #1 of 1 ...
[10:58:42.971]  - Finding globals in 'X' for chunk #1 ...
[10:58:42.971] getGlobalsAndPackages() ...
[10:58:42.971] Searching for globals...
[10:58:42.971] 
[10:58:42.972] Searching for globals ... DONE
[10:58:42.972] - globals: [0] <none>
[10:58:42.972] getGlobalsAndPackages() ... DONE
[10:58:42.972]    + additional globals found: [n=0] 
[10:58:42.972]    + additional namespaces needed: [n=0] 
[10:58:42.972]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:42.972]  - seeds: <none>
[10:58:42.972]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.972] getGlobalsAndPackages() ...
[10:58:42.972] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.972] Resolving globals: FALSE
[10:58:42.972] Tweak future expression to call with '...' arguments ...
[10:58:42.973] {
[10:58:42.973]     do.call(function(...) {
[10:58:42.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.973]             on.exit(options(oopts), add = TRUE)
[10:58:42.973]         }
[10:58:42.973]         {
[10:58:42.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.973]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.973]             })
[10:58:42.973]         }
[10:58:42.973]     }, args = future.call.arguments)
[10:58:42.973] }
[10:58:42.973] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.973] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.975] 
[10:58:42.975] getGlobalsAndPackages() ... DONE
[10:58:42.975] run() for ‘Future’ ...
[10:58:42.975] - state: ‘created’
[10:58:42.975] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:42.977] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:42.977]   - Field: ‘label’
[10:58:42.977]   - Field: ‘local’
[10:58:42.977]   - Field: ‘owner’
[10:58:42.977]   - Field: ‘envir’
[10:58:42.977]   - Field: ‘packages’
[10:58:42.977]   - Field: ‘gc’
[10:58:42.978]   - Field: ‘conditions’
[10:58:42.978]   - Field: ‘expr’
[10:58:42.978]   - Field: ‘uuid’
[10:58:42.978]   - Field: ‘seed’
[10:58:42.978]   - Field: ‘version’
[10:58:42.978]   - Field: ‘result’
[10:58:42.978]   - Field: ‘asynchronous’
[10:58:42.978]   - Field: ‘calls’
[10:58:42.978]   - Field: ‘globals’
[10:58:42.978]   - Field: ‘stdout’
[10:58:42.978]   - Field: ‘earlySignal’
[10:58:42.979]   - Field: ‘lazy’
[10:58:42.979]   - Field: ‘state’
[10:58:42.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:42.979] - Launch lazy future ...
[10:58:42.979] Packages needed by the future expression (n = 0): <none>
[10:58:42.979] Packages needed by future strategies (n = 0): <none>
[10:58:42.979] {
[10:58:42.979]     {
[10:58:42.979]         {
[10:58:42.979]             ...future.startTime <- base::Sys.time()
[10:58:42.979]             {
[10:58:42.979]                 {
[10:58:42.979]                   {
[10:58:42.979]                     base::local({
[10:58:42.979]                       has_future <- base::requireNamespace("future", 
[10:58:42.979]                         quietly = TRUE)
[10:58:42.979]                       if (has_future) {
[10:58:42.979]                         ns <- base::getNamespace("future")
[10:58:42.979]                         version <- ns[[".package"]][["version"]]
[10:58:42.979]                         if (is.null(version)) 
[10:58:42.979]                           version <- utils::packageVersion("future")
[10:58:42.979]                       }
[10:58:42.979]                       else {
[10:58:42.979]                         version <- NULL
[10:58:42.979]                       }
[10:58:42.979]                       if (!has_future || version < "1.8.0") {
[10:58:42.979]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.979]                           "", base::R.version$version.string), 
[10:58:42.979]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:42.979]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.979]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.979]                             "release", "version")], collapse = " "), 
[10:58:42.979]                           hostname = base::Sys.info()[["nodename"]])
[10:58:42.979]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.979]                           info)
[10:58:42.979]                         info <- base::paste(info, collapse = "; ")
[10:58:42.979]                         if (!has_future) {
[10:58:42.979]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.979]                             info)
[10:58:42.979]                         }
[10:58:42.979]                         else {
[10:58:42.979]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.979]                             info, version)
[10:58:42.979]                         }
[10:58:42.979]                         base::stop(msg)
[10:58:42.979]                       }
[10:58:42.979]                     })
[10:58:42.979]                   }
[10:58:42.979]                   ...future.strategy.old <- future::plan("list")
[10:58:42.979]                   options(future.plan = NULL)
[10:58:42.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.979]                 }
[10:58:42.979]                 ...future.workdir <- getwd()
[10:58:42.979]             }
[10:58:42.979]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.979]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.979]         }
[10:58:42.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:42.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.979]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.979]             base::names(...future.oldOptions))
[10:58:42.979]     }
[10:58:42.979]     if (FALSE) {
[10:58:42.979]     }
[10:58:42.979]     else {
[10:58:42.979]         if (TRUE) {
[10:58:42.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.979]                 open = "w")
[10:58:42.979]         }
[10:58:42.979]         else {
[10:58:42.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.979]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.979]         }
[10:58:42.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.979]             base::sink(type = "output", split = FALSE)
[10:58:42.979]             base::close(...future.stdout)
[10:58:42.979]         }, add = TRUE)
[10:58:42.979]     }
[10:58:42.979]     ...future.frame <- base::sys.nframe()
[10:58:42.979]     ...future.conditions <- base::list()
[10:58:42.979]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.979]     if (FALSE) {
[10:58:42.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.979]     }
[10:58:42.979]     ...future.result <- base::tryCatch({
[10:58:42.979]         base::withCallingHandlers({
[10:58:42.979]             ...future.value <- base::withVisible(base::local({
[10:58:42.979]                 do.call(function(...) {
[10:58:42.979]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.979]                   if (!identical(...future.globals.maxSize.org, 
[10:58:42.979]                     ...future.globals.maxSize)) {
[10:58:42.979]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.979]                     on.exit(options(oopts), add = TRUE)
[10:58:42.979]                   }
[10:58:42.979]                   {
[10:58:42.979]                     lapply(seq_along(...future.elements_ii), 
[10:58:42.979]                       FUN = function(jj) {
[10:58:42.979]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.979]                         ...future.FUN(...future.X_jj, ...)
[10:58:42.979]                       })
[10:58:42.979]                   }
[10:58:42.979]                 }, args = future.call.arguments)
[10:58:42.979]             }))
[10:58:42.979]             future::FutureResult(value = ...future.value$value, 
[10:58:42.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.979]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.979]                     ...future.globalenv.names))
[10:58:42.979]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.979]         }, condition = base::local({
[10:58:42.979]             c <- base::c
[10:58:42.979]             inherits <- base::inherits
[10:58:42.979]             invokeRestart <- base::invokeRestart
[10:58:42.979]             length <- base::length
[10:58:42.979]             list <- base::list
[10:58:42.979]             seq.int <- base::seq.int
[10:58:42.979]             signalCondition <- base::signalCondition
[10:58:42.979]             sys.calls <- base::sys.calls
[10:58:42.979]             `[[` <- base::`[[`
[10:58:42.979]             `+` <- base::`+`
[10:58:42.979]             `<<-` <- base::`<<-`
[10:58:42.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.979]                   3L)]
[10:58:42.979]             }
[10:58:42.979]             function(cond) {
[10:58:42.979]                 is_error <- inherits(cond, "error")
[10:58:42.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.979]                   NULL)
[10:58:42.979]                 if (is_error) {
[10:58:42.979]                   sessionInformation <- function() {
[10:58:42.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.979]                       search = base::search(), system = base::Sys.info())
[10:58:42.979]                   }
[10:58:42.979]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.979]                     cond$call), session = sessionInformation(), 
[10:58:42.979]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.979]                   signalCondition(cond)
[10:58:42.979]                 }
[10:58:42.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.979]                 "immediateCondition"))) {
[10:58:42.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.979]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.979]                   if (TRUE && !signal) {
[10:58:42.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.979]                     {
[10:58:42.979]                       inherits <- base::inherits
[10:58:42.979]                       invokeRestart <- base::invokeRestart
[10:58:42.979]                       is.null <- base::is.null
[10:58:42.979]                       muffled <- FALSE
[10:58:42.979]                       if (inherits(cond, "message")) {
[10:58:42.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.979]                         if (muffled) 
[10:58:42.979]                           invokeRestart("muffleMessage")
[10:58:42.979]                       }
[10:58:42.979]                       else if (inherits(cond, "warning")) {
[10:58:42.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.979]                         if (muffled) 
[10:58:42.979]                           invokeRestart("muffleWarning")
[10:58:42.979]                       }
[10:58:42.979]                       else if (inherits(cond, "condition")) {
[10:58:42.979]                         if (!is.null(pattern)) {
[10:58:42.979]                           computeRestarts <- base::computeRestarts
[10:58:42.979]                           grepl <- base::grepl
[10:58:42.979]                           restarts <- computeRestarts(cond)
[10:58:42.979]                           for (restart in restarts) {
[10:58:42.979]                             name <- restart$name
[10:58:42.979]                             if (is.null(name)) 
[10:58:42.979]                               next
[10:58:42.979]                             if (!grepl(pattern, name)) 
[10:58:42.979]                               next
[10:58:42.979]                             invokeRestart(restart)
[10:58:42.979]                             muffled <- TRUE
[10:58:42.979]                             break
[10:58:42.979]                           }
[10:58:42.979]                         }
[10:58:42.979]                       }
[10:58:42.979]                       invisible(muffled)
[10:58:42.979]                     }
[10:58:42.979]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.979]                   }
[10:58:42.979]                 }
[10:58:42.979]                 else {
[10:58:42.979]                   if (TRUE) {
[10:58:42.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.979]                     {
[10:58:42.979]                       inherits <- base::inherits
[10:58:42.979]                       invokeRestart <- base::invokeRestart
[10:58:42.979]                       is.null <- base::is.null
[10:58:42.979]                       muffled <- FALSE
[10:58:42.979]                       if (inherits(cond, "message")) {
[10:58:42.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.979]                         if (muffled) 
[10:58:42.979]                           invokeRestart("muffleMessage")
[10:58:42.979]                       }
[10:58:42.979]                       else if (inherits(cond, "warning")) {
[10:58:42.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.979]                         if (muffled) 
[10:58:42.979]                           invokeRestart("muffleWarning")
[10:58:42.979]                       }
[10:58:42.979]                       else if (inherits(cond, "condition")) {
[10:58:42.979]                         if (!is.null(pattern)) {
[10:58:42.979]                           computeRestarts <- base::computeRestarts
[10:58:42.979]                           grepl <- base::grepl
[10:58:42.979]                           restarts <- computeRestarts(cond)
[10:58:42.979]                           for (restart in restarts) {
[10:58:42.979]                             name <- restart$name
[10:58:42.979]                             if (is.null(name)) 
[10:58:42.979]                               next
[10:58:42.979]                             if (!grepl(pattern, name)) 
[10:58:42.979]                               next
[10:58:42.979]                             invokeRestart(restart)
[10:58:42.979]                             muffled <- TRUE
[10:58:42.979]                             break
[10:58:42.979]                           }
[10:58:42.979]                         }
[10:58:42.979]                       }
[10:58:42.979]                       invisible(muffled)
[10:58:42.979]                     }
[10:58:42.979]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.979]                   }
[10:58:42.979]                 }
[10:58:42.979]             }
[10:58:42.979]         }))
[10:58:42.979]     }, error = function(ex) {
[10:58:42.979]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.979]                 ...future.rng), started = ...future.startTime, 
[10:58:42.979]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.979]             version = "1.8"), class = "FutureResult")
[10:58:42.979]     }, finally = {
[10:58:42.979]         if (!identical(...future.workdir, getwd())) 
[10:58:42.979]             setwd(...future.workdir)
[10:58:42.979]         {
[10:58:42.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.979]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.979]             }
[10:58:42.979]             base::options(...future.oldOptions)
[10:58:42.979]             if (.Platform$OS.type == "windows") {
[10:58:42.979]                 old_names <- names(...future.oldEnvVars)
[10:58:42.979]                 envs <- base::Sys.getenv()
[10:58:42.979]                 names <- names(envs)
[10:58:42.979]                 common <- intersect(names, old_names)
[10:58:42.979]                 added <- setdiff(names, old_names)
[10:58:42.979]                 removed <- setdiff(old_names, names)
[10:58:42.979]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.979]                   envs[common]]
[10:58:42.979]                 NAMES <- toupper(changed)
[10:58:42.979]                 args <- list()
[10:58:42.979]                 for (kk in seq_along(NAMES)) {
[10:58:42.979]                   name <- changed[[kk]]
[10:58:42.979]                   NAME <- NAMES[[kk]]
[10:58:42.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.979]                     next
[10:58:42.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.979]                 }
[10:58:42.979]                 NAMES <- toupper(added)
[10:58:42.979]                 for (kk in seq_along(NAMES)) {
[10:58:42.979]                   name <- added[[kk]]
[10:58:42.979]                   NAME <- NAMES[[kk]]
[10:58:42.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.979]                     next
[10:58:42.979]                   args[[name]] <- ""
[10:58:42.979]                 }
[10:58:42.979]                 NAMES <- toupper(removed)
[10:58:42.979]                 for (kk in seq_along(NAMES)) {
[10:58:42.979]                   name <- removed[[kk]]
[10:58:42.979]                   NAME <- NAMES[[kk]]
[10:58:42.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.979]                     next
[10:58:42.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.979]                 }
[10:58:42.979]                 if (length(args) > 0) 
[10:58:42.979]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.979]             }
[10:58:42.979]             else {
[10:58:42.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.979]             }
[10:58:42.979]             {
[10:58:42.979]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.979]                   0L) {
[10:58:42.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.979]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.979]                   base::options(opts)
[10:58:42.979]                 }
[10:58:42.979]                 {
[10:58:42.979]                   {
[10:58:42.979]                     NULL
[10:58:42.979]                     RNGkind("Mersenne-Twister")
[10:58:42.979]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:42.979]                       inherits = FALSE)
[10:58:42.979]                   }
[10:58:42.979]                   options(future.plan = NULL)
[10:58:42.979]                   if (is.na(NA_character_)) 
[10:58:42.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.979]                     .init = FALSE)
[10:58:42.979]                 }
[10:58:42.979]             }
[10:58:42.979]         }
[10:58:42.979]     })
[10:58:42.979]     if (TRUE) {
[10:58:42.979]         base::sink(type = "output", split = FALSE)
[10:58:42.979]         if (TRUE) {
[10:58:42.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.979]         }
[10:58:42.979]         else {
[10:58:42.979]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.979]         }
[10:58:42.979]         base::close(...future.stdout)
[10:58:42.979]         ...future.stdout <- NULL
[10:58:42.979]     }
[10:58:42.979]     ...future.result$conditions <- ...future.conditions
[10:58:42.979]     ...future.result$finished <- base::Sys.time()
[10:58:42.979]     ...future.result
[10:58:42.979] }
[10:58:42.981] assign_globals() ...
[10:58:42.981] List of 5
[10:58:42.981]  $ ...future.FUN            :function (object, ...)  
[10:58:42.981]  $ future.call.arguments    :List of 1
[10:58:42.981]   ..$ digits: int 2
[10:58:42.981]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.981]  $ ...future.elements_ii    :List of 6
[10:58:42.981]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:58:42.981]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:58:42.981]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:58:42.981]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:58:42.981]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:58:42.981]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:58:42.981]  $ ...future.seeds_ii       : NULL
[10:58:42.981]  $ ...future.globals.maxSize: NULL
[10:58:42.981]  - attr(*, "where")=List of 5
[10:58:42.981]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:42.981]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:42.981]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:42.981]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:42.981]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:42.981]  - attr(*, "resolved")= logi FALSE
[10:58:42.981]  - attr(*, "total_size")= num 13284
[10:58:42.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.981]  - attr(*, "already-done")= logi TRUE
[10:58:42.988] - copied ‘...future.FUN’ to environment
[10:58:42.988] - copied ‘future.call.arguments’ to environment
[10:58:42.988] - copied ‘...future.elements_ii’ to environment
[10:58:42.988] - copied ‘...future.seeds_ii’ to environment
[10:58:42.988] - copied ‘...future.globals.maxSize’ to environment
[10:58:42.988] assign_globals() ... done
[10:58:42.989] plan(): Setting new future strategy stack:
[10:58:42.989] List of future strategies:
[10:58:42.989] 1. sequential:
[10:58:42.989]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.989]    - tweaked: FALSE
[10:58:42.989]    - call: NULL
[10:58:42.989] plan(): nbrOfWorkers() = 1
[10:58:42.990] plan(): Setting new future strategy stack:
[10:58:42.991] List of future strategies:
[10:58:42.991] 1. multicore:
[10:58:42.991]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:42.991]    - tweaked: FALSE
[10:58:42.991]    - call: plan(strategy)
[10:58:42.992] plan(): nbrOfWorkers() = 1
[10:58:42.992] SequentialFuture started (and completed)
[10:58:42.992] - Launch lazy future ... done
[10:58:42.993] run() for ‘SequentialFuture’ ... done
[10:58:42.993] Created future:
[10:58:42.993] SequentialFuture:
[10:58:42.993] Label: ‘future_by-1’
[10:58:42.993] Expression:
[10:58:42.993] {
[10:58:42.993]     do.call(function(...) {
[10:58:42.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.993]             on.exit(options(oopts), add = TRUE)
[10:58:42.993]         }
[10:58:42.993]         {
[10:58:42.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.993]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.993]             })
[10:58:42.993]         }
[10:58:42.993]     }, args = future.call.arguments)
[10:58:42.993] }
[10:58:42.993] Lazy evaluation: FALSE
[10:58:42.993] Asynchronous evaluation: FALSE
[10:58:42.993] Local evaluation: TRUE
[10:58:42.993] Environment: R_GlobalEnv
[10:58:42.993] Capture standard output: TRUE
[10:58:42.993] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.993] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:42.993] Packages: <none>
[10:58:42.993] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.993] Resolved: TRUE
[10:58:42.993] Value: 1.27 KiB of class ‘list’
[10:58:42.993] Early signaling: FALSE
[10:58:42.993] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:42.993] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:42.994] Chunk #1 of 1 ... DONE
[10:58:42.994] Launching 1 futures (chunks) ... DONE
[10:58:42.994] Resolving 1 futures (chunks) ...
[10:58:42.994] resolve() on list ...
[10:58:42.994]  recursive: 0
[10:58:42.994]  length: 1
[10:58:42.994] 
[10:58:42.994] resolved() for ‘SequentialFuture’ ...
[10:58:42.994] - state: ‘finished’
[10:58:42.994] - run: TRUE
[10:58:42.995] - result: ‘FutureResult’
[10:58:42.995] resolved() for ‘SequentialFuture’ ... done
[10:58:42.995] Future #1
[10:58:42.995] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:42.995] - nx: 1
[10:58:42.995] - relay: TRUE
[10:58:42.995] - stdout: TRUE
[10:58:42.995] - signal: TRUE
[10:58:42.995] - resignal: FALSE
[10:58:42.995] - force: TRUE
[10:58:42.997] - relayed: [n=1] FALSE
[10:58:42.997] - queued futures: [n=1] FALSE
[10:58:42.997]  - until=1
[10:58:42.997]  - relaying element #1
[10:58:42.998] - relayed: [n=1] TRUE
[10:58:42.998] - queued futures: [n=1] TRUE
[10:58:42.998] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:42.998]  length: 0 (resolved future 1)
[10:58:42.998] Relaying remaining futures
[10:58:42.998] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.998] - nx: 1
[10:58:42.998] - relay: TRUE
[10:58:42.998] - stdout: TRUE
[10:58:42.998] - signal: TRUE
[10:58:42.998] - resignal: FALSE
[10:58:42.998] - force: TRUE
[10:58:42.999] - relayed: [n=1] TRUE
[10:58:42.999] - queued futures: [n=1] TRUE
 - flush all
[10:58:42.999] - relayed: [n=1] TRUE
[10:58:42.999] - queued futures: [n=1] TRUE
[10:58:42.999] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.999] resolve() on list ... DONE
[10:58:42.999]  - Number of value chunks collected: 1
[10:58:42.999] Resolving 1 futures (chunks) ... DONE
[10:58:42.999] Reducing values from 1 chunks ...
[10:58:42.999]  - Number of values collected after concatenation: 6
[10:58:43.000]  - Number of values expected: 6
[10:58:43.000] Reducing values from 1 chunks ... DONE
[10:58:43.000] future_lapply() ... DONE
[10:58:43.000] future_by_internal() ... DONE
[10:58:43.001] future_by_internal() ...
[10:58:43.001] future_lapply() ...
[10:58:43.003] Number of chunks: 1
[10:58:43.003] getGlobalsAndPackagesXApply() ...
[10:58:43.003]  - future.globals: TRUE
[10:58:43.004] getGlobalsAndPackages() ...
[10:58:43.004] Searching for globals...
[10:58:43.005] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:43.005] Searching for globals ... DONE
[10:58:43.005] Resolving globals: FALSE
[10:58:43.006] The total size of the 1 globals is 762 bytes (762 bytes)
[10:58:43.006] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:58:43.006] - globals: [1] ‘FUN’
[10:58:43.006] - packages: [1] ‘stats’
[10:58:43.007] getGlobalsAndPackages() ... DONE
[10:58:43.007]  - globals found/used: [n=1] ‘FUN’
[10:58:43.007]  - needed namespaces: [n=1] ‘stats’
[10:58:43.007] Finding globals ... DONE
[10:58:43.007]  - use_args: TRUE
[10:58:43.007]  - Getting '...' globals ...
[10:58:43.007] resolve() on list ...
[10:58:43.007]  recursive: 0
[10:58:43.007]  length: 1
[10:58:43.008]  elements: ‘...’
[10:58:43.008]  length: 0 (resolved future 1)
[10:58:43.008] resolve() on list ... DONE
[10:58:43.008]    - '...' content: [n=1] ‘singular.ok’
[10:58:43.008] List of 1
[10:58:43.008]  $ ...:List of 1
[10:58:43.008]   ..$ singular.ok: logi FALSE
[10:58:43.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.008]  - attr(*, "where")=List of 1
[10:58:43.008]   ..$ ...:<environment: 0x55974b8a4170> 
[10:58:43.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.008]  - attr(*, "resolved")= logi TRUE
[10:58:43.008]  - attr(*, "total_size")= num NA
[10:58:43.011]  - Getting '...' globals ... DONE
[10:58:43.011] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.011] List of 2
[10:58:43.011]  $ ...future.FUN:function (x, ...)  
[10:58:43.011]  $ ...          :List of 1
[10:58:43.011]   ..$ singular.ok: logi FALSE
[10:58:43.011]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.011]  - attr(*, "where")=List of 2
[10:58:43.011]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.011]   ..$ ...          :<environment: 0x55974b8a4170> 
[10:58:43.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.011]  - attr(*, "resolved")= logi FALSE
[10:58:43.011]  - attr(*, "total_size")= num 19977
[10:58:43.014] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:43.014] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.014] Number of futures (= number of chunks): 1
[10:58:43.014] Launching 1 futures (chunks) ...
[10:58:43.014] Chunk #1 of 1 ...
[10:58:43.015]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.015] getGlobalsAndPackages() ...
[10:58:43.015] Searching for globals...
[10:58:43.042] 
[10:58:43.042] Searching for globals ... DONE
[10:58:43.042] - globals: [0] <none>
[10:58:43.042] getGlobalsAndPackages() ... DONE
[10:58:43.043]    + additional globals found: [n=0] 
[10:58:43.043]    + additional namespaces needed: [n=0] 
[10:58:43.043]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.043]  - seeds: <none>
[10:58:43.043]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.043] getGlobalsAndPackages() ...
[10:58:43.043] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.043] Resolving globals: FALSE
[10:58:43.043] Tweak future expression to call with '...' arguments ...
[10:58:43.043] {
[10:58:43.043]     do.call(function(...) {
[10:58:43.043]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.043]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.043]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.043]             on.exit(options(oopts), add = TRUE)
[10:58:43.043]         }
[10:58:43.043]         {
[10:58:43.043]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.043]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.043]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.043]             })
[10:58:43.043]         }
[10:58:43.043]     }, args = future.call.arguments)
[10:58:43.043] }
[10:58:43.044] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.044] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.044] 
[10:58:43.044] getGlobalsAndPackages() ... DONE
[10:58:43.045] run() for ‘Future’ ...
[10:58:43.045] - state: ‘created’
[10:58:43.045] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.046] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.046] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.047]   - Field: ‘label’
[10:58:43.047]   - Field: ‘local’
[10:58:43.047]   - Field: ‘owner’
[10:58:43.047]   - Field: ‘envir’
[10:58:43.047]   - Field: ‘packages’
[10:58:43.047]   - Field: ‘gc’
[10:58:43.047]   - Field: ‘conditions’
[10:58:43.047]   - Field: ‘expr’
[10:58:43.047]   - Field: ‘uuid’
[10:58:43.047]   - Field: ‘seed’
[10:58:43.047]   - Field: ‘version’
[10:58:43.048]   - Field: ‘result’
[10:58:43.048]   - Field: ‘asynchronous’
[10:58:43.048]   - Field: ‘calls’
[10:58:43.048]   - Field: ‘globals’
[10:58:43.048]   - Field: ‘stdout’
[10:58:43.048]   - Field: ‘earlySignal’
[10:58:43.048]   - Field: ‘lazy’
[10:58:43.048]   - Field: ‘state’
[10:58:43.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.048] - Launch lazy future ...
[10:58:43.048] Packages needed by the future expression (n = 1): ‘stats’
[10:58:43.049] Packages needed by future strategies (n = 0): <none>
[10:58:43.049] {
[10:58:43.049]     {
[10:58:43.049]         {
[10:58:43.049]             ...future.startTime <- base::Sys.time()
[10:58:43.049]             {
[10:58:43.049]                 {
[10:58:43.049]                   {
[10:58:43.049]                     {
[10:58:43.049]                       base::local({
[10:58:43.049]                         has_future <- base::requireNamespace("future", 
[10:58:43.049]                           quietly = TRUE)
[10:58:43.049]                         if (has_future) {
[10:58:43.049]                           ns <- base::getNamespace("future")
[10:58:43.049]                           version <- ns[[".package"]][["version"]]
[10:58:43.049]                           if (is.null(version)) 
[10:58:43.049]                             version <- utils::packageVersion("future")
[10:58:43.049]                         }
[10:58:43.049]                         else {
[10:58:43.049]                           version <- NULL
[10:58:43.049]                         }
[10:58:43.049]                         if (!has_future || version < "1.8.0") {
[10:58:43.049]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.049]                             "", base::R.version$version.string), 
[10:58:43.049]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.049]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.049]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.049]                               "release", "version")], collapse = " "), 
[10:58:43.049]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.049]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.049]                             info)
[10:58:43.049]                           info <- base::paste(info, collapse = "; ")
[10:58:43.049]                           if (!has_future) {
[10:58:43.049]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.049]                               info)
[10:58:43.049]                           }
[10:58:43.049]                           else {
[10:58:43.049]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.049]                               info, version)
[10:58:43.049]                           }
[10:58:43.049]                           base::stop(msg)
[10:58:43.049]                         }
[10:58:43.049]                       })
[10:58:43.049]                     }
[10:58:43.049]                     base::local({
[10:58:43.049]                       for (pkg in "stats") {
[10:58:43.049]                         base::loadNamespace(pkg)
[10:58:43.049]                         base::library(pkg, character.only = TRUE)
[10:58:43.049]                       }
[10:58:43.049]                     })
[10:58:43.049]                   }
[10:58:43.049]                   ...future.strategy.old <- future::plan("list")
[10:58:43.049]                   options(future.plan = NULL)
[10:58:43.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.049]                 }
[10:58:43.049]                 ...future.workdir <- getwd()
[10:58:43.049]             }
[10:58:43.049]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.049]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.049]         }
[10:58:43.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.049]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.049]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.049]             base::names(...future.oldOptions))
[10:58:43.049]     }
[10:58:43.049]     if (FALSE) {
[10:58:43.049]     }
[10:58:43.049]     else {
[10:58:43.049]         if (TRUE) {
[10:58:43.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.049]                 open = "w")
[10:58:43.049]         }
[10:58:43.049]         else {
[10:58:43.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.049]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.049]         }
[10:58:43.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.049]             base::sink(type = "output", split = FALSE)
[10:58:43.049]             base::close(...future.stdout)
[10:58:43.049]         }, add = TRUE)
[10:58:43.049]     }
[10:58:43.049]     ...future.frame <- base::sys.nframe()
[10:58:43.049]     ...future.conditions <- base::list()
[10:58:43.049]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.049]     if (FALSE) {
[10:58:43.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.049]     }
[10:58:43.049]     ...future.result <- base::tryCatch({
[10:58:43.049]         base::withCallingHandlers({
[10:58:43.049]             ...future.value <- base::withVisible(base::local({
[10:58:43.049]                 do.call(function(...) {
[10:58:43.049]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.049]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.049]                     ...future.globals.maxSize)) {
[10:58:43.049]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.049]                     on.exit(options(oopts), add = TRUE)
[10:58:43.049]                   }
[10:58:43.049]                   {
[10:58:43.049]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.049]                       FUN = function(jj) {
[10:58:43.049]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.049]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.049]                       })
[10:58:43.049]                   }
[10:58:43.049]                 }, args = future.call.arguments)
[10:58:43.049]             }))
[10:58:43.049]             future::FutureResult(value = ...future.value$value, 
[10:58:43.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.049]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.049]                     ...future.globalenv.names))
[10:58:43.049]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.049]         }, condition = base::local({
[10:58:43.049]             c <- base::c
[10:58:43.049]             inherits <- base::inherits
[10:58:43.049]             invokeRestart <- base::invokeRestart
[10:58:43.049]             length <- base::length
[10:58:43.049]             list <- base::list
[10:58:43.049]             seq.int <- base::seq.int
[10:58:43.049]             signalCondition <- base::signalCondition
[10:58:43.049]             sys.calls <- base::sys.calls
[10:58:43.049]             `[[` <- base::`[[`
[10:58:43.049]             `+` <- base::`+`
[10:58:43.049]             `<<-` <- base::`<<-`
[10:58:43.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.049]                   3L)]
[10:58:43.049]             }
[10:58:43.049]             function(cond) {
[10:58:43.049]                 is_error <- inherits(cond, "error")
[10:58:43.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.049]                   NULL)
[10:58:43.049]                 if (is_error) {
[10:58:43.049]                   sessionInformation <- function() {
[10:58:43.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.049]                       search = base::search(), system = base::Sys.info())
[10:58:43.049]                   }
[10:58:43.049]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.049]                     cond$call), session = sessionInformation(), 
[10:58:43.049]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.049]                   signalCondition(cond)
[10:58:43.049]                 }
[10:58:43.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.049]                 "immediateCondition"))) {
[10:58:43.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.049]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.049]                   if (TRUE && !signal) {
[10:58:43.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.049]                     {
[10:58:43.049]                       inherits <- base::inherits
[10:58:43.049]                       invokeRestart <- base::invokeRestart
[10:58:43.049]                       is.null <- base::is.null
[10:58:43.049]                       muffled <- FALSE
[10:58:43.049]                       if (inherits(cond, "message")) {
[10:58:43.049]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.049]                         if (muffled) 
[10:58:43.049]                           invokeRestart("muffleMessage")
[10:58:43.049]                       }
[10:58:43.049]                       else if (inherits(cond, "warning")) {
[10:58:43.049]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.049]                         if (muffled) 
[10:58:43.049]                           invokeRestart("muffleWarning")
[10:58:43.049]                       }
[10:58:43.049]                       else if (inherits(cond, "condition")) {
[10:58:43.049]                         if (!is.null(pattern)) {
[10:58:43.049]                           computeRestarts <- base::computeRestarts
[10:58:43.049]                           grepl <- base::grepl
[10:58:43.049]                           restarts <- computeRestarts(cond)
[10:58:43.049]                           for (restart in restarts) {
[10:58:43.049]                             name <- restart$name
[10:58:43.049]                             if (is.null(name)) 
[10:58:43.049]                               next
[10:58:43.049]                             if (!grepl(pattern, name)) 
[10:58:43.049]                               next
[10:58:43.049]                             invokeRestart(restart)
[10:58:43.049]                             muffled <- TRUE
[10:58:43.049]                             break
[10:58:43.049]                           }
[10:58:43.049]                         }
[10:58:43.049]                       }
[10:58:43.049]                       invisible(muffled)
[10:58:43.049]                     }
[10:58:43.049]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.049]                   }
[10:58:43.049]                 }
[10:58:43.049]                 else {
[10:58:43.049]                   if (TRUE) {
[10:58:43.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.049]                     {
[10:58:43.049]                       inherits <- base::inherits
[10:58:43.049]                       invokeRestart <- base::invokeRestart
[10:58:43.049]                       is.null <- base::is.null
[10:58:43.049]                       muffled <- FALSE
[10:58:43.049]                       if (inherits(cond, "message")) {
[10:58:43.049]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.049]                         if (muffled) 
[10:58:43.049]                           invokeRestart("muffleMessage")
[10:58:43.049]                       }
[10:58:43.049]                       else if (inherits(cond, "warning")) {
[10:58:43.049]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.049]                         if (muffled) 
[10:58:43.049]                           invokeRestart("muffleWarning")
[10:58:43.049]                       }
[10:58:43.049]                       else if (inherits(cond, "condition")) {
[10:58:43.049]                         if (!is.null(pattern)) {
[10:58:43.049]                           computeRestarts <- base::computeRestarts
[10:58:43.049]                           grepl <- base::grepl
[10:58:43.049]                           restarts <- computeRestarts(cond)
[10:58:43.049]                           for (restart in restarts) {
[10:58:43.049]                             name <- restart$name
[10:58:43.049]                             if (is.null(name)) 
[10:58:43.049]                               next
[10:58:43.049]                             if (!grepl(pattern, name)) 
[10:58:43.049]                               next
[10:58:43.049]                             invokeRestart(restart)
[10:58:43.049]                             muffled <- TRUE
[10:58:43.049]                             break
[10:58:43.049]                           }
[10:58:43.049]                         }
[10:58:43.049]                       }
[10:58:43.049]                       invisible(muffled)
[10:58:43.049]                     }
[10:58:43.049]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.049]                   }
[10:58:43.049]                 }
[10:58:43.049]             }
[10:58:43.049]         }))
[10:58:43.049]     }, error = function(ex) {
[10:58:43.049]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.049]                 ...future.rng), started = ...future.startTime, 
[10:58:43.049]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.049]             version = "1.8"), class = "FutureResult")
[10:58:43.049]     }, finally = {
[10:58:43.049]         if (!identical(...future.workdir, getwd())) 
[10:58:43.049]             setwd(...future.workdir)
[10:58:43.049]         {
[10:58:43.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.049]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.049]             }
[10:58:43.049]             base::options(...future.oldOptions)
[10:58:43.049]             if (.Platform$OS.type == "windows") {
[10:58:43.049]                 old_names <- names(...future.oldEnvVars)
[10:58:43.049]                 envs <- base::Sys.getenv()
[10:58:43.049]                 names <- names(envs)
[10:58:43.049]                 common <- intersect(names, old_names)
[10:58:43.049]                 added <- setdiff(names, old_names)
[10:58:43.049]                 removed <- setdiff(old_names, names)
[10:58:43.049]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.049]                   envs[common]]
[10:58:43.049]                 NAMES <- toupper(changed)
[10:58:43.049]                 args <- list()
[10:58:43.049]                 for (kk in seq_along(NAMES)) {
[10:58:43.049]                   name <- changed[[kk]]
[10:58:43.049]                   NAME <- NAMES[[kk]]
[10:58:43.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.049]                     next
[10:58:43.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.049]                 }
[10:58:43.049]                 NAMES <- toupper(added)
[10:58:43.049]                 for (kk in seq_along(NAMES)) {
[10:58:43.049]                   name <- added[[kk]]
[10:58:43.049]                   NAME <- NAMES[[kk]]
[10:58:43.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.049]                     next
[10:58:43.049]                   args[[name]] <- ""
[10:58:43.049]                 }
[10:58:43.049]                 NAMES <- toupper(removed)
[10:58:43.049]                 for (kk in seq_along(NAMES)) {
[10:58:43.049]                   name <- removed[[kk]]
[10:58:43.049]                   NAME <- NAMES[[kk]]
[10:58:43.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.049]                     next
[10:58:43.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.049]                 }
[10:58:43.049]                 if (length(args) > 0) 
[10:58:43.049]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.049]             }
[10:58:43.049]             else {
[10:58:43.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.049]             }
[10:58:43.049]             {
[10:58:43.049]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.049]                   0L) {
[10:58:43.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.049]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.049]                   base::options(opts)
[10:58:43.049]                 }
[10:58:43.049]                 {
[10:58:43.049]                   {
[10:58:43.049]                     NULL
[10:58:43.049]                     RNGkind("Mersenne-Twister")
[10:58:43.049]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.049]                       inherits = FALSE)
[10:58:43.049]                   }
[10:58:43.049]                   options(future.plan = NULL)
[10:58:43.049]                   if (is.na(NA_character_)) 
[10:58:43.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.049]                     .init = FALSE)
[10:58:43.049]                 }
[10:58:43.049]             }
[10:58:43.049]         }
[10:58:43.049]     })
[10:58:43.049]     if (TRUE) {
[10:58:43.049]         base::sink(type = "output", split = FALSE)
[10:58:43.049]         if (TRUE) {
[10:58:43.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.049]         }
[10:58:43.049]         else {
[10:58:43.049]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.049]         }
[10:58:43.049]         base::close(...future.stdout)
[10:58:43.049]         ...future.stdout <- NULL
[10:58:43.049]     }
[10:58:43.049]     ...future.result$conditions <- ...future.conditions
[10:58:43.049]     ...future.result$finished <- base::Sys.time()
[10:58:43.049]     ...future.result
[10:58:43.049] }
[10:58:43.051] assign_globals() ...
[10:58:43.051] List of 5
[10:58:43.051]  $ ...future.FUN            :function (x, ...)  
[10:58:43.051]  $ future.call.arguments    :List of 1
[10:58:43.051]   ..$ singular.ok: logi FALSE
[10:58:43.051]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.051]  $ ...future.elements_ii    :List of 3
[10:58:43.051]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.051]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.051]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.051]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.051]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.051]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.051]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.051]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.051]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.051]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.051]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.051]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.051]  $ ...future.seeds_ii       : NULL
[10:58:43.051]  $ ...future.globals.maxSize: NULL
[10:58:43.051]  - attr(*, "where")=List of 5
[10:58:43.051]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.051]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.051]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.051]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.051]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.051]  - attr(*, "resolved")= logi FALSE
[10:58:43.051]  - attr(*, "total_size")= num 19977
[10:58:43.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.051]  - attr(*, "already-done")= logi TRUE
[10:58:43.059] - reassign environment for ‘...future.FUN’
[10:58:43.059] - copied ‘...future.FUN’ to environment
[10:58:43.060] - copied ‘future.call.arguments’ to environment
[10:58:43.060] - copied ‘...future.elements_ii’ to environment
[10:58:43.060] - copied ‘...future.seeds_ii’ to environment
[10:58:43.060] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.060] assign_globals() ... done
[10:58:43.060] plan(): Setting new future strategy stack:
[10:58:43.060] List of future strategies:
[10:58:43.060] 1. sequential:
[10:58:43.060]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.060]    - tweaked: FALSE
[10:58:43.060]    - call: NULL
[10:58:43.061] plan(): nbrOfWorkers() = 1
[10:58:43.063] plan(): Setting new future strategy stack:
[10:58:43.064] List of future strategies:
[10:58:43.064] 1. multicore:
[10:58:43.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.064]    - tweaked: FALSE
[10:58:43.064]    - call: plan(strategy)
[10:58:43.066] plan(): nbrOfWorkers() = 1
[10:58:43.066] SequentialFuture started (and completed)
[10:58:43.066] - Launch lazy future ... done
[10:58:43.066] run() for ‘SequentialFuture’ ... done
[10:58:43.066] Created future:
[10:58:43.067] SequentialFuture:
[10:58:43.067] Label: ‘future_by-1’
[10:58:43.067] Expression:
[10:58:43.067] {
[10:58:43.067]     do.call(function(...) {
[10:58:43.067]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.067]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.067]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.067]             on.exit(options(oopts), add = TRUE)
[10:58:43.067]         }
[10:58:43.067]         {
[10:58:43.067]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.067]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.067]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.067]             })
[10:58:43.067]         }
[10:58:43.067]     }, args = future.call.arguments)
[10:58:43.067] }
[10:58:43.067] Lazy evaluation: FALSE
[10:58:43.067] Asynchronous evaluation: FALSE
[10:58:43.067] Local evaluation: TRUE
[10:58:43.067] Environment: R_GlobalEnv
[10:58:43.067] Capture standard output: TRUE
[10:58:43.067] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.067] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.067] Packages: 1 packages (‘stats’)
[10:58:43.067] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.067] Resolved: TRUE
[10:58:43.067] Value: 81.44 KiB of class ‘list’
[10:58:43.067] Early signaling: FALSE
[10:58:43.067] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.067] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.068] Chunk #1 of 1 ... DONE
[10:58:43.068] Launching 1 futures (chunks) ... DONE
[10:58:43.068] Resolving 1 futures (chunks) ...
[10:58:43.068] resolve() on list ...
[10:58:43.068]  recursive: 0
[10:58:43.068]  length: 1
[10:58:43.068] 
[10:58:43.068] resolved() for ‘SequentialFuture’ ...
[10:58:43.069] - state: ‘finished’
[10:58:43.069] - run: TRUE
[10:58:43.069] - result: ‘FutureResult’
[10:58:43.069] resolved() for ‘SequentialFuture’ ... done
[10:58:43.069] Future #1
[10:58:43.069] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.069] - nx: 1
[10:58:43.069] - relay: TRUE
[10:58:43.069] - stdout: TRUE
[10:58:43.069] - signal: TRUE
[10:58:43.069] - resignal: FALSE
[10:58:43.069] - force: TRUE
[10:58:43.069] - relayed: [n=1] FALSE
[10:58:43.070] - queued futures: [n=1] FALSE
[10:58:43.070]  - until=1
[10:58:43.070]  - relaying element #1
[10:58:43.070] - relayed: [n=1] TRUE
[10:58:43.070] - queued futures: [n=1] TRUE
[10:58:43.070] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.070]  length: 0 (resolved future 1)
[10:58:43.070] Relaying remaining futures
[10:58:43.070] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.070] - nx: 1
[10:58:43.070] - relay: TRUE
[10:58:43.071] - stdout: TRUE
[10:58:43.071] - signal: TRUE
[10:58:43.071] - resignal: FALSE
[10:58:43.071] - force: TRUE
[10:58:43.071] - relayed: [n=1] TRUE
[10:58:43.071] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.071] - relayed: [n=1] TRUE
[10:58:43.071] - queued futures: [n=1] TRUE
[10:58:43.071] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.071] resolve() on list ... DONE
[10:58:43.071]  - Number of value chunks collected: 1
[10:58:43.071] Resolving 1 futures (chunks) ... DONE
[10:58:43.072] Reducing values from 1 chunks ...
[10:58:43.072]  - Number of values collected after concatenation: 3
[10:58:43.072]  - Number of values expected: 3
[10:58:43.072] Reducing values from 1 chunks ... DONE
[10:58:43.072] future_lapply() ... DONE
[10:58:43.072] future_by_internal() ... DONE
[10:58:43.076] future_by_internal() ...
[10:58:43.076] future_lapply() ...
[10:58:43.078] Number of chunks: 1
[10:58:43.078] getGlobalsAndPackagesXApply() ...
[10:58:43.078]  - future.globals: TRUE
[10:58:43.078] getGlobalsAndPackages() ...
[10:58:43.078] Searching for globals...
[10:58:43.080] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:43.080] Searching for globals ... DONE
[10:58:43.080] Resolving globals: FALSE
[10:58:43.080] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:58:43.081] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:58:43.081] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:43.081] - packages: [1] ‘stats’
[10:58:43.081] getGlobalsAndPackages() ... DONE
[10:58:43.081]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:43.081]  - needed namespaces: [n=1] ‘stats’
[10:58:43.081] Finding globals ... DONE
[10:58:43.081]  - use_args: TRUE
[10:58:43.081]  - Getting '...' globals ...
[10:58:43.082] resolve() on list ...
[10:58:43.082]  recursive: 0
[10:58:43.082]  length: 1
[10:58:43.082]  elements: ‘...’
[10:58:43.082]  length: 0 (resolved future 1)
[10:58:43.082] resolve() on list ... DONE
[10:58:43.082]    - '...' content: [n=0] 
[10:58:43.082] List of 1
[10:58:43.082]  $ ...: list()
[10:58:43.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.082]  - attr(*, "where")=List of 1
[10:58:43.082]   ..$ ...:<environment: 0x55974da5bb10> 
[10:58:43.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.082]  - attr(*, "resolved")= logi TRUE
[10:58:43.082]  - attr(*, "total_size")= num NA
[10:58:43.085]  - Getting '...' globals ... DONE
[10:58:43.085] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:58:43.085] List of 4
[10:58:43.085]  $ ...future.FUN:function (x)  
[10:58:43.085]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:43.085]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.085]  $ ...          : list()
[10:58:43.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.085]  - attr(*, "where")=List of 4
[10:58:43.085]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.085]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:58:43.085]   ..$ wool         :<environment: R_EmptyEnv> 
[10:58:43.085]   ..$ ...          :<environment: 0x55974da5bb10> 
[10:58:43.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.085]  - attr(*, "resolved")= logi FALSE
[10:58:43.085]  - attr(*, "total_size")= num 18867
[10:58:43.089] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:43.089] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.089] Number of futures (= number of chunks): 1
[10:58:43.089] Launching 1 futures (chunks) ...
[10:58:43.089] Chunk #1 of 1 ...
[10:58:43.090]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.090] getGlobalsAndPackages() ...
[10:58:43.090] Searching for globals...
[10:58:43.090] 
[10:58:43.090] Searching for globals ... DONE
[10:58:43.090] - globals: [0] <none>
[10:58:43.090] getGlobalsAndPackages() ... DONE
[10:58:43.090]    + additional globals found: [n=0] 
[10:58:43.091]    + additional namespaces needed: [n=0] 
[10:58:43.091]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.091]  - seeds: <none>
[10:58:43.091]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.091] getGlobalsAndPackages() ...
[10:58:43.091] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.091] Resolving globals: FALSE
[10:58:43.091] Tweak future expression to call with '...' arguments ...
[10:58:43.091] {
[10:58:43.091]     do.call(function(...) {
[10:58:43.091]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.091]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.091]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.091]             on.exit(options(oopts), add = TRUE)
[10:58:43.091]         }
[10:58:43.091]         {
[10:58:43.091]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.091]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.091]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.091]             })
[10:58:43.091]         }
[10:58:43.091]     }, args = future.call.arguments)
[10:58:43.091] }
[10:58:43.091] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.092] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.092] 
[10:58:43.092] getGlobalsAndPackages() ... DONE
[10:58:43.092] run() for ‘Future’ ...
[10:58:43.092] - state: ‘created’
[10:58:43.092] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.094] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.094]   - Field: ‘label’
[10:58:43.094]   - Field: ‘local’
[10:58:43.094]   - Field: ‘owner’
[10:58:43.094]   - Field: ‘envir’
[10:58:43.094]   - Field: ‘packages’
[10:58:43.095]   - Field: ‘gc’
[10:58:43.095]   - Field: ‘conditions’
[10:58:43.095]   - Field: ‘expr’
[10:58:43.095]   - Field: ‘uuid’
[10:58:43.095]   - Field: ‘seed’
[10:58:43.095]   - Field: ‘version’
[10:58:43.095]   - Field: ‘result’
[10:58:43.095]   - Field: ‘asynchronous’
[10:58:43.095]   - Field: ‘calls’
[10:58:43.095]   - Field: ‘globals’
[10:58:43.095]   - Field: ‘stdout’
[10:58:43.095]   - Field: ‘earlySignal’
[10:58:43.095]   - Field: ‘lazy’
[10:58:43.096]   - Field: ‘state’
[10:58:43.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.096] - Launch lazy future ...
[10:58:43.096] Packages needed by the future expression (n = 1): ‘stats’
[10:58:43.096] Packages needed by future strategies (n = 0): <none>
[10:58:43.096] {
[10:58:43.096]     {
[10:58:43.096]         {
[10:58:43.096]             ...future.startTime <- base::Sys.time()
[10:58:43.096]             {
[10:58:43.096]                 {
[10:58:43.096]                   {
[10:58:43.096]                     {
[10:58:43.096]                       base::local({
[10:58:43.096]                         has_future <- base::requireNamespace("future", 
[10:58:43.096]                           quietly = TRUE)
[10:58:43.096]                         if (has_future) {
[10:58:43.096]                           ns <- base::getNamespace("future")
[10:58:43.096]                           version <- ns[[".package"]][["version"]]
[10:58:43.096]                           if (is.null(version)) 
[10:58:43.096]                             version <- utils::packageVersion("future")
[10:58:43.096]                         }
[10:58:43.096]                         else {
[10:58:43.096]                           version <- NULL
[10:58:43.096]                         }
[10:58:43.096]                         if (!has_future || version < "1.8.0") {
[10:58:43.096]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.096]                             "", base::R.version$version.string), 
[10:58:43.096]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.096]                               "release", "version")], collapse = " "), 
[10:58:43.096]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.096]                             info)
[10:58:43.096]                           info <- base::paste(info, collapse = "; ")
[10:58:43.096]                           if (!has_future) {
[10:58:43.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.096]                               info)
[10:58:43.096]                           }
[10:58:43.096]                           else {
[10:58:43.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.096]                               info, version)
[10:58:43.096]                           }
[10:58:43.096]                           base::stop(msg)
[10:58:43.096]                         }
[10:58:43.096]                       })
[10:58:43.096]                     }
[10:58:43.096]                     base::local({
[10:58:43.096]                       for (pkg in "stats") {
[10:58:43.096]                         base::loadNamespace(pkg)
[10:58:43.096]                         base::library(pkg, character.only = TRUE)
[10:58:43.096]                       }
[10:58:43.096]                     })
[10:58:43.096]                   }
[10:58:43.096]                   ...future.strategy.old <- future::plan("list")
[10:58:43.096]                   options(future.plan = NULL)
[10:58:43.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.096]                 }
[10:58:43.096]                 ...future.workdir <- getwd()
[10:58:43.096]             }
[10:58:43.096]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.096]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.096]         }
[10:58:43.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.096]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.096]             base::names(...future.oldOptions))
[10:58:43.096]     }
[10:58:43.096]     if (FALSE) {
[10:58:43.096]     }
[10:58:43.096]     else {
[10:58:43.096]         if (TRUE) {
[10:58:43.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.096]                 open = "w")
[10:58:43.096]         }
[10:58:43.096]         else {
[10:58:43.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.096]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.096]         }
[10:58:43.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.096]             base::sink(type = "output", split = FALSE)
[10:58:43.096]             base::close(...future.stdout)
[10:58:43.096]         }, add = TRUE)
[10:58:43.096]     }
[10:58:43.096]     ...future.frame <- base::sys.nframe()
[10:58:43.096]     ...future.conditions <- base::list()
[10:58:43.096]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.096]     if (FALSE) {
[10:58:43.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.096]     }
[10:58:43.096]     ...future.result <- base::tryCatch({
[10:58:43.096]         base::withCallingHandlers({
[10:58:43.096]             ...future.value <- base::withVisible(base::local({
[10:58:43.096]                 do.call(function(...) {
[10:58:43.096]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.096]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.096]                     ...future.globals.maxSize)) {
[10:58:43.096]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.096]                     on.exit(options(oopts), add = TRUE)
[10:58:43.096]                   }
[10:58:43.096]                   {
[10:58:43.096]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.096]                       FUN = function(jj) {
[10:58:43.096]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.096]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.096]                       })
[10:58:43.096]                   }
[10:58:43.096]                 }, args = future.call.arguments)
[10:58:43.096]             }))
[10:58:43.096]             future::FutureResult(value = ...future.value$value, 
[10:58:43.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.096]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.096]                     ...future.globalenv.names))
[10:58:43.096]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.096]         }, condition = base::local({
[10:58:43.096]             c <- base::c
[10:58:43.096]             inherits <- base::inherits
[10:58:43.096]             invokeRestart <- base::invokeRestart
[10:58:43.096]             length <- base::length
[10:58:43.096]             list <- base::list
[10:58:43.096]             seq.int <- base::seq.int
[10:58:43.096]             signalCondition <- base::signalCondition
[10:58:43.096]             sys.calls <- base::sys.calls
[10:58:43.096]             `[[` <- base::`[[`
[10:58:43.096]             `+` <- base::`+`
[10:58:43.096]             `<<-` <- base::`<<-`
[10:58:43.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.096]                   3L)]
[10:58:43.096]             }
[10:58:43.096]             function(cond) {
[10:58:43.096]                 is_error <- inherits(cond, "error")
[10:58:43.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.096]                   NULL)
[10:58:43.096]                 if (is_error) {
[10:58:43.096]                   sessionInformation <- function() {
[10:58:43.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.096]                       search = base::search(), system = base::Sys.info())
[10:58:43.096]                   }
[10:58:43.096]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.096]                     cond$call), session = sessionInformation(), 
[10:58:43.096]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.096]                   signalCondition(cond)
[10:58:43.096]                 }
[10:58:43.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.096]                 "immediateCondition"))) {
[10:58:43.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.096]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.096]                   if (TRUE && !signal) {
[10:58:43.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.096]                     {
[10:58:43.096]                       inherits <- base::inherits
[10:58:43.096]                       invokeRestart <- base::invokeRestart
[10:58:43.096]                       is.null <- base::is.null
[10:58:43.096]                       muffled <- FALSE
[10:58:43.096]                       if (inherits(cond, "message")) {
[10:58:43.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.096]                         if (muffled) 
[10:58:43.096]                           invokeRestart("muffleMessage")
[10:58:43.096]                       }
[10:58:43.096]                       else if (inherits(cond, "warning")) {
[10:58:43.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.096]                         if (muffled) 
[10:58:43.096]                           invokeRestart("muffleWarning")
[10:58:43.096]                       }
[10:58:43.096]                       else if (inherits(cond, "condition")) {
[10:58:43.096]                         if (!is.null(pattern)) {
[10:58:43.096]                           computeRestarts <- base::computeRestarts
[10:58:43.096]                           grepl <- base::grepl
[10:58:43.096]                           restarts <- computeRestarts(cond)
[10:58:43.096]                           for (restart in restarts) {
[10:58:43.096]                             name <- restart$name
[10:58:43.096]                             if (is.null(name)) 
[10:58:43.096]                               next
[10:58:43.096]                             if (!grepl(pattern, name)) 
[10:58:43.096]                               next
[10:58:43.096]                             invokeRestart(restart)
[10:58:43.096]                             muffled <- TRUE
[10:58:43.096]                             break
[10:58:43.096]                           }
[10:58:43.096]                         }
[10:58:43.096]                       }
[10:58:43.096]                       invisible(muffled)
[10:58:43.096]                     }
[10:58:43.096]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.096]                   }
[10:58:43.096]                 }
[10:58:43.096]                 else {
[10:58:43.096]                   if (TRUE) {
[10:58:43.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.096]                     {
[10:58:43.096]                       inherits <- base::inherits
[10:58:43.096]                       invokeRestart <- base::invokeRestart
[10:58:43.096]                       is.null <- base::is.null
[10:58:43.096]                       muffled <- FALSE
[10:58:43.096]                       if (inherits(cond, "message")) {
[10:58:43.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.096]                         if (muffled) 
[10:58:43.096]                           invokeRestart("muffleMessage")
[10:58:43.096]                       }
[10:58:43.096]                       else if (inherits(cond, "warning")) {
[10:58:43.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.096]                         if (muffled) 
[10:58:43.096]                           invokeRestart("muffleWarning")
[10:58:43.096]                       }
[10:58:43.096]                       else if (inherits(cond, "condition")) {
[10:58:43.096]                         if (!is.null(pattern)) {
[10:58:43.096]                           computeRestarts <- base::computeRestarts
[10:58:43.096]                           grepl <- base::grepl
[10:58:43.096]                           restarts <- computeRestarts(cond)
[10:58:43.096]                           for (restart in restarts) {
[10:58:43.096]                             name <- restart$name
[10:58:43.096]                             if (is.null(name)) 
[10:58:43.096]                               next
[10:58:43.096]                             if (!grepl(pattern, name)) 
[10:58:43.096]                               next
[10:58:43.096]                             invokeRestart(restart)
[10:58:43.096]                             muffled <- TRUE
[10:58:43.096]                             break
[10:58:43.096]                           }
[10:58:43.096]                         }
[10:58:43.096]                       }
[10:58:43.096]                       invisible(muffled)
[10:58:43.096]                     }
[10:58:43.096]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.096]                   }
[10:58:43.096]                 }
[10:58:43.096]             }
[10:58:43.096]         }))
[10:58:43.096]     }, error = function(ex) {
[10:58:43.096]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.096]                 ...future.rng), started = ...future.startTime, 
[10:58:43.096]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.096]             version = "1.8"), class = "FutureResult")
[10:58:43.096]     }, finally = {
[10:58:43.096]         if (!identical(...future.workdir, getwd())) 
[10:58:43.096]             setwd(...future.workdir)
[10:58:43.096]         {
[10:58:43.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.096]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.096]             }
[10:58:43.096]             base::options(...future.oldOptions)
[10:58:43.096]             if (.Platform$OS.type == "windows") {
[10:58:43.096]                 old_names <- names(...future.oldEnvVars)
[10:58:43.096]                 envs <- base::Sys.getenv()
[10:58:43.096]                 names <- names(envs)
[10:58:43.096]                 common <- intersect(names, old_names)
[10:58:43.096]                 added <- setdiff(names, old_names)
[10:58:43.096]                 removed <- setdiff(old_names, names)
[10:58:43.096]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.096]                   envs[common]]
[10:58:43.096]                 NAMES <- toupper(changed)
[10:58:43.096]                 args <- list()
[10:58:43.096]                 for (kk in seq_along(NAMES)) {
[10:58:43.096]                   name <- changed[[kk]]
[10:58:43.096]                   NAME <- NAMES[[kk]]
[10:58:43.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.096]                     next
[10:58:43.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.096]                 }
[10:58:43.096]                 NAMES <- toupper(added)
[10:58:43.096]                 for (kk in seq_along(NAMES)) {
[10:58:43.096]                   name <- added[[kk]]
[10:58:43.096]                   NAME <- NAMES[[kk]]
[10:58:43.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.096]                     next
[10:58:43.096]                   args[[name]] <- ""
[10:58:43.096]                 }
[10:58:43.096]                 NAMES <- toupper(removed)
[10:58:43.096]                 for (kk in seq_along(NAMES)) {
[10:58:43.096]                   name <- removed[[kk]]
[10:58:43.096]                   NAME <- NAMES[[kk]]
[10:58:43.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.096]                     next
[10:58:43.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.096]                 }
[10:58:43.096]                 if (length(args) > 0) 
[10:58:43.096]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.096]             }
[10:58:43.096]             else {
[10:58:43.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.096]             }
[10:58:43.096]             {
[10:58:43.096]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.096]                   0L) {
[10:58:43.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.096]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.096]                   base::options(opts)
[10:58:43.096]                 }
[10:58:43.096]                 {
[10:58:43.096]                   {
[10:58:43.096]                     NULL
[10:58:43.096]                     RNGkind("Mersenne-Twister")
[10:58:43.096]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.096]                       inherits = FALSE)
[10:58:43.096]                   }
[10:58:43.096]                   options(future.plan = NULL)
[10:58:43.096]                   if (is.na(NA_character_)) 
[10:58:43.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.096]                     .init = FALSE)
[10:58:43.096]                 }
[10:58:43.096]             }
[10:58:43.096]         }
[10:58:43.096]     })
[10:58:43.096]     if (TRUE) {
[10:58:43.096]         base::sink(type = "output", split = FALSE)
[10:58:43.096]         if (TRUE) {
[10:58:43.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.096]         }
[10:58:43.096]         else {
[10:58:43.096]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.096]         }
[10:58:43.096]         base::close(...future.stdout)
[10:58:43.096]         ...future.stdout <- NULL
[10:58:43.096]     }
[10:58:43.096]     ...future.result$conditions <- ...future.conditions
[10:58:43.096]     ...future.result$finished <- base::Sys.time()
[10:58:43.096]     ...future.result
[10:58:43.096] }
[10:58:43.098] assign_globals() ...
[10:58:43.098] List of 7
[10:58:43.098]  $ ...future.FUN            :function (x)  
[10:58:43.098]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:43.098]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.098]  $ future.call.arguments    : list()
[10:58:43.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.098]  $ ...future.elements_ii    :List of 3
[10:58:43.098]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.098]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.098]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.098]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.098]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.098]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.098]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.098]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.098]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.098]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.098]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.098]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.098]  $ ...future.seeds_ii       : NULL
[10:58:43.098]  $ ...future.globals.maxSize: NULL
[10:58:43.098]  - attr(*, "where")=List of 7
[10:58:43.098]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.098]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:58:43.098]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:58:43.098]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.098]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.098]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.098]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.098]  - attr(*, "resolved")= logi FALSE
[10:58:43.098]  - attr(*, "total_size")= num 18867
[10:58:43.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.098]  - attr(*, "already-done")= logi TRUE
[10:58:43.108] - reassign environment for ‘...future.FUN’
[10:58:43.108] - copied ‘...future.FUN’ to environment
[10:58:43.109] - copied ‘breaks’ to environment
[10:58:43.109] - copied ‘wool’ to environment
[10:58:43.109] - copied ‘future.call.arguments’ to environment
[10:58:43.109] - copied ‘...future.elements_ii’ to environment
[10:58:43.109] - copied ‘...future.seeds_ii’ to environment
[10:58:43.109] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.109] assign_globals() ... done
[10:58:43.109] plan(): Setting new future strategy stack:
[10:58:43.110] List of future strategies:
[10:58:43.110] 1. sequential:
[10:58:43.110]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.110]    - tweaked: FALSE
[10:58:43.110]    - call: NULL
[10:58:43.110] plan(): nbrOfWorkers() = 1
[10:58:43.113] plan(): Setting new future strategy stack:
[10:58:43.113] List of future strategies:
[10:58:43.113] 1. multicore:
[10:58:43.113]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.113]    - tweaked: FALSE
[10:58:43.113]    - call: plan(strategy)
[10:58:43.114] plan(): nbrOfWorkers() = 1
[10:58:43.114] SequentialFuture started (and completed)
[10:58:43.114] - Launch lazy future ... done
[10:58:43.115] run() for ‘SequentialFuture’ ... done
[10:58:43.115] Created future:
[10:58:43.115] SequentialFuture:
[10:58:43.115] Label: ‘future_by-1’
[10:58:43.115] Expression:
[10:58:43.115] {
[10:58:43.115]     do.call(function(...) {
[10:58:43.115]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.115]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.115]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.115]             on.exit(options(oopts), add = TRUE)
[10:58:43.115]         }
[10:58:43.115]         {
[10:58:43.115]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.115]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.115]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.115]             })
[10:58:43.115]         }
[10:58:43.115]     }, args = future.call.arguments)
[10:58:43.115] }
[10:58:43.115] Lazy evaluation: FALSE
[10:58:43.115] Asynchronous evaluation: FALSE
[10:58:43.115] Local evaluation: TRUE
[10:58:43.115] Environment: 0x55974da2a2b8
[10:58:43.115] Capture standard output: TRUE
[10:58:43.115] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.115] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[10:58:43.115] Packages: 1 packages (‘stats’)
[10:58:43.115] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.115] Resolved: TRUE
[10:58:43.115] Value: 82.82 KiB of class ‘list’
[10:58:43.115] Early signaling: FALSE
[10:58:43.115] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.115] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.116] Chunk #1 of 1 ... DONE
[10:58:43.116] Launching 1 futures (chunks) ... DONE
[10:58:43.116] Resolving 1 futures (chunks) ...
[10:58:43.116] resolve() on list ...
[10:58:43.116]  recursive: 0
[10:58:43.116]  length: 1
[10:58:43.117] 
[10:58:43.117] resolved() for ‘SequentialFuture’ ...
[10:58:43.117] - state: ‘finished’
[10:58:43.117] - run: TRUE
[10:58:43.117] - result: ‘FutureResult’
[10:58:43.117] resolved() for ‘SequentialFuture’ ... done
[10:58:43.117] Future #1
[10:58:43.117] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.117] - nx: 1
[10:58:43.117] - relay: TRUE
[10:58:43.117] - stdout: TRUE
[10:58:43.117] - signal: TRUE
[10:58:43.118] - resignal: FALSE
[10:58:43.118] - force: TRUE
[10:58:43.118] - relayed: [n=1] FALSE
[10:58:43.118] - queued futures: [n=1] FALSE
[10:58:43.118]  - until=1
[10:58:43.118]  - relaying element #1
[10:58:43.118] - relayed: [n=1] TRUE
[10:58:43.118] - queued futures: [n=1] TRUE
[10:58:43.118] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.118]  length: 0 (resolved future 1)
[10:58:43.118] Relaying remaining futures
[10:58:43.119] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.119] - nx: 1
[10:58:43.119] - relay: TRUE
[10:58:43.119] - stdout: TRUE
[10:58:43.119] - signal: TRUE
[10:58:43.119] - resignal: FALSE
[10:58:43.119] - force: TRUE
[10:58:43.119] - relayed: [n=1] TRUE
[10:58:43.119] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.119] - relayed: [n=1] TRUE
[10:58:43.119] - queued futures: [n=1] TRUE
[10:58:43.119] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.119] resolve() on list ... DONE
[10:58:43.120]  - Number of value chunks collected: 1
[10:58:43.120] Resolving 1 futures (chunks) ... DONE
[10:58:43.120] Reducing values from 1 chunks ...
[10:58:43.120]  - Number of values collected after concatenation: 3
[10:58:43.120]  - Number of values expected: 3
[10:58:43.120] Reducing values from 1 chunks ... DONE
[10:58:43.120] future_lapply() ... DONE
[10:58:43.120] future_by_internal() ... DONE
[10:58:43.120] future_by_internal() ...
[10:58:43.121] future_lapply() ...
[10:58:43.122] Number of chunks: 1
[10:58:43.122] getGlobalsAndPackagesXApply() ...
[10:58:43.123]  - future.globals: TRUE
[10:58:43.123] getGlobalsAndPackages() ...
[10:58:43.123] Searching for globals...
[10:58:43.124] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.124] Searching for globals ... DONE
[10:58:43.124] Resolving globals: FALSE
[10:58:43.124] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.124] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.125] - globals: [1] ‘FUN’
[10:58:43.125] 
[10:58:43.125] getGlobalsAndPackages() ... DONE
[10:58:43.125]  - globals found/used: [n=1] ‘FUN’
[10:58:43.125]  - needed namespaces: [n=0] 
[10:58:43.125] Finding globals ... DONE
[10:58:43.125]  - use_args: TRUE
[10:58:43.125]  - Getting '...' globals ...
[10:58:43.125] resolve() on list ...
[10:58:43.126]  recursive: 0
[10:58:43.126]  length: 1
[10:58:43.126]  elements: ‘...’
[10:58:43.126]  length: 0 (resolved future 1)
[10:58:43.126] resolve() on list ... DONE
[10:58:43.126]    - '...' content: [n=0] 
[10:58:43.126] List of 1
[10:58:43.126]  $ ...: list()
[10:58:43.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.126]  - attr(*, "where")=List of 1
[10:58:43.126]   ..$ ...:<environment: 0x55974dc97970> 
[10:58:43.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.126]  - attr(*, "resolved")= logi TRUE
[10:58:43.126]  - attr(*, "total_size")= num NA
[10:58:43.129]  - Getting '...' globals ... DONE
[10:58:43.129] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.129] List of 2
[10:58:43.129]  $ ...future.FUN:function (object, ...)  
[10:58:43.129]  $ ...          : list()
[10:58:43.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.129]  - attr(*, "where")=List of 2
[10:58:43.129]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.129]   ..$ ...          :<environment: 0x55974dc97970> 
[10:58:43.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.129]  - attr(*, "resolved")= logi FALSE
[10:58:43.129]  - attr(*, "total_size")= num 19278
[10:58:43.132] Packages to be attached in all futures: [n=0] 
[10:58:43.132] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.132] Number of futures (= number of chunks): 1
[10:58:43.132] Launching 1 futures (chunks) ...
[10:58:43.132] Chunk #1 of 1 ...
[10:58:43.132]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.132] getGlobalsAndPackages() ...
[10:58:43.132] Searching for globals...
[10:58:43.133] 
[10:58:43.133] Searching for globals ... DONE
[10:58:43.133] - globals: [0] <none>
[10:58:43.133] getGlobalsAndPackages() ... DONE
[10:58:43.133]    + additional globals found: [n=0] 
[10:58:43.133]    + additional namespaces needed: [n=0] 
[10:58:43.133]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.133]  - seeds: <none>
[10:58:43.133]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.134] getGlobalsAndPackages() ...
[10:58:43.134] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.134] Resolving globals: FALSE
[10:58:43.134] Tweak future expression to call with '...' arguments ...
[10:58:43.134] {
[10:58:43.134]     do.call(function(...) {
[10:58:43.134]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.134]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.134]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.134]             on.exit(options(oopts), add = TRUE)
[10:58:43.134]         }
[10:58:43.134]         {
[10:58:43.134]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.134]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.134]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.134]             })
[10:58:43.134]         }
[10:58:43.134]     }, args = future.call.arguments)
[10:58:43.134] }
[10:58:43.134] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.134] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.135] 
[10:58:43.135] getGlobalsAndPackages() ... DONE
[10:58:43.135] run() for ‘Future’ ...
[10:58:43.135] - state: ‘created’
[10:58:43.135] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.136] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.137]   - Field: ‘label’
[10:58:43.137]   - Field: ‘local’
[10:58:43.137]   - Field: ‘owner’
[10:58:43.137]   - Field: ‘envir’
[10:58:43.137]   - Field: ‘packages’
[10:58:43.137]   - Field: ‘gc’
[10:58:43.137]   - Field: ‘conditions’
[10:58:43.137]   - Field: ‘expr’
[10:58:43.137]   - Field: ‘uuid’
[10:58:43.137]   - Field: ‘seed’
[10:58:43.138]   - Field: ‘version’
[10:58:43.138]   - Field: ‘result’
[10:58:43.138]   - Field: ‘asynchronous’
[10:58:43.138]   - Field: ‘calls’
[10:58:43.138]   - Field: ‘globals’
[10:58:43.138]   - Field: ‘stdout’
[10:58:43.138]   - Field: ‘earlySignal’
[10:58:43.138]   - Field: ‘lazy’
[10:58:43.138]   - Field: ‘state’
[10:58:43.138] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.138] - Launch lazy future ...
[10:58:43.138] Packages needed by the future expression (n = 0): <none>
[10:58:43.139] Packages needed by future strategies (n = 0): <none>
[10:58:43.139] {
[10:58:43.139]     {
[10:58:43.139]         {
[10:58:43.139]             ...future.startTime <- base::Sys.time()
[10:58:43.139]             {
[10:58:43.139]                 {
[10:58:43.139]                   {
[10:58:43.139]                     base::local({
[10:58:43.139]                       has_future <- base::requireNamespace("future", 
[10:58:43.139]                         quietly = TRUE)
[10:58:43.139]                       if (has_future) {
[10:58:43.139]                         ns <- base::getNamespace("future")
[10:58:43.139]                         version <- ns[[".package"]][["version"]]
[10:58:43.139]                         if (is.null(version)) 
[10:58:43.139]                           version <- utils::packageVersion("future")
[10:58:43.139]                       }
[10:58:43.139]                       else {
[10:58:43.139]                         version <- NULL
[10:58:43.139]                       }
[10:58:43.139]                       if (!has_future || version < "1.8.0") {
[10:58:43.139]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.139]                           "", base::R.version$version.string), 
[10:58:43.139]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.139]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.139]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.139]                             "release", "version")], collapse = " "), 
[10:58:43.139]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.139]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.139]                           info)
[10:58:43.139]                         info <- base::paste(info, collapse = "; ")
[10:58:43.139]                         if (!has_future) {
[10:58:43.139]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.139]                             info)
[10:58:43.139]                         }
[10:58:43.139]                         else {
[10:58:43.139]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.139]                             info, version)
[10:58:43.139]                         }
[10:58:43.139]                         base::stop(msg)
[10:58:43.139]                       }
[10:58:43.139]                     })
[10:58:43.139]                   }
[10:58:43.139]                   ...future.strategy.old <- future::plan("list")
[10:58:43.139]                   options(future.plan = NULL)
[10:58:43.139]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.139]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.139]                 }
[10:58:43.139]                 ...future.workdir <- getwd()
[10:58:43.139]             }
[10:58:43.139]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.139]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.139]         }
[10:58:43.139]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.139]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.139]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.139]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.139]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.139]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.139]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.139]             base::names(...future.oldOptions))
[10:58:43.139]     }
[10:58:43.139]     if (FALSE) {
[10:58:43.139]     }
[10:58:43.139]     else {
[10:58:43.139]         if (TRUE) {
[10:58:43.139]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.139]                 open = "w")
[10:58:43.139]         }
[10:58:43.139]         else {
[10:58:43.139]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.139]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.139]         }
[10:58:43.139]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.139]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.139]             base::sink(type = "output", split = FALSE)
[10:58:43.139]             base::close(...future.stdout)
[10:58:43.139]         }, add = TRUE)
[10:58:43.139]     }
[10:58:43.139]     ...future.frame <- base::sys.nframe()
[10:58:43.139]     ...future.conditions <- base::list()
[10:58:43.139]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.139]     if (FALSE) {
[10:58:43.139]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.139]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.139]     }
[10:58:43.139]     ...future.result <- base::tryCatch({
[10:58:43.139]         base::withCallingHandlers({
[10:58:43.139]             ...future.value <- base::withVisible(base::local({
[10:58:43.139]                 do.call(function(...) {
[10:58:43.139]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.139]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.139]                     ...future.globals.maxSize)) {
[10:58:43.139]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.139]                     on.exit(options(oopts), add = TRUE)
[10:58:43.139]                   }
[10:58:43.139]                   {
[10:58:43.139]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.139]                       FUN = function(jj) {
[10:58:43.139]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.139]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.139]                       })
[10:58:43.139]                   }
[10:58:43.139]                 }, args = future.call.arguments)
[10:58:43.139]             }))
[10:58:43.139]             future::FutureResult(value = ...future.value$value, 
[10:58:43.139]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.139]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.139]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.139]                     ...future.globalenv.names))
[10:58:43.139]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.139]         }, condition = base::local({
[10:58:43.139]             c <- base::c
[10:58:43.139]             inherits <- base::inherits
[10:58:43.139]             invokeRestart <- base::invokeRestart
[10:58:43.139]             length <- base::length
[10:58:43.139]             list <- base::list
[10:58:43.139]             seq.int <- base::seq.int
[10:58:43.139]             signalCondition <- base::signalCondition
[10:58:43.139]             sys.calls <- base::sys.calls
[10:58:43.139]             `[[` <- base::`[[`
[10:58:43.139]             `+` <- base::`+`
[10:58:43.139]             `<<-` <- base::`<<-`
[10:58:43.139]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.139]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.139]                   3L)]
[10:58:43.139]             }
[10:58:43.139]             function(cond) {
[10:58:43.139]                 is_error <- inherits(cond, "error")
[10:58:43.139]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.139]                   NULL)
[10:58:43.139]                 if (is_error) {
[10:58:43.139]                   sessionInformation <- function() {
[10:58:43.139]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.139]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.139]                       search = base::search(), system = base::Sys.info())
[10:58:43.139]                   }
[10:58:43.139]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.139]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.139]                     cond$call), session = sessionInformation(), 
[10:58:43.139]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.139]                   signalCondition(cond)
[10:58:43.139]                 }
[10:58:43.139]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.139]                 "immediateCondition"))) {
[10:58:43.139]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.139]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.139]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.139]                   if (TRUE && !signal) {
[10:58:43.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.139]                     {
[10:58:43.139]                       inherits <- base::inherits
[10:58:43.139]                       invokeRestart <- base::invokeRestart
[10:58:43.139]                       is.null <- base::is.null
[10:58:43.139]                       muffled <- FALSE
[10:58:43.139]                       if (inherits(cond, "message")) {
[10:58:43.139]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.139]                         if (muffled) 
[10:58:43.139]                           invokeRestart("muffleMessage")
[10:58:43.139]                       }
[10:58:43.139]                       else if (inherits(cond, "warning")) {
[10:58:43.139]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.139]                         if (muffled) 
[10:58:43.139]                           invokeRestart("muffleWarning")
[10:58:43.139]                       }
[10:58:43.139]                       else if (inherits(cond, "condition")) {
[10:58:43.139]                         if (!is.null(pattern)) {
[10:58:43.139]                           computeRestarts <- base::computeRestarts
[10:58:43.139]                           grepl <- base::grepl
[10:58:43.139]                           restarts <- computeRestarts(cond)
[10:58:43.139]                           for (restart in restarts) {
[10:58:43.139]                             name <- restart$name
[10:58:43.139]                             if (is.null(name)) 
[10:58:43.139]                               next
[10:58:43.139]                             if (!grepl(pattern, name)) 
[10:58:43.139]                               next
[10:58:43.139]                             invokeRestart(restart)
[10:58:43.139]                             muffled <- TRUE
[10:58:43.139]                             break
[10:58:43.139]                           }
[10:58:43.139]                         }
[10:58:43.139]                       }
[10:58:43.139]                       invisible(muffled)
[10:58:43.139]                     }
[10:58:43.139]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.139]                   }
[10:58:43.139]                 }
[10:58:43.139]                 else {
[10:58:43.139]                   if (TRUE) {
[10:58:43.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.139]                     {
[10:58:43.139]                       inherits <- base::inherits
[10:58:43.139]                       invokeRestart <- base::invokeRestart
[10:58:43.139]                       is.null <- base::is.null
[10:58:43.139]                       muffled <- FALSE
[10:58:43.139]                       if (inherits(cond, "message")) {
[10:58:43.139]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.139]                         if (muffled) 
[10:58:43.139]                           invokeRestart("muffleMessage")
[10:58:43.139]                       }
[10:58:43.139]                       else if (inherits(cond, "warning")) {
[10:58:43.139]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.139]                         if (muffled) 
[10:58:43.139]                           invokeRestart("muffleWarning")
[10:58:43.139]                       }
[10:58:43.139]                       else if (inherits(cond, "condition")) {
[10:58:43.139]                         if (!is.null(pattern)) {
[10:58:43.139]                           computeRestarts <- base::computeRestarts
[10:58:43.139]                           grepl <- base::grepl
[10:58:43.139]                           restarts <- computeRestarts(cond)
[10:58:43.139]                           for (restart in restarts) {
[10:58:43.139]                             name <- restart$name
[10:58:43.139]                             if (is.null(name)) 
[10:58:43.139]                               next
[10:58:43.139]                             if (!grepl(pattern, name)) 
[10:58:43.139]                               next
[10:58:43.139]                             invokeRestart(restart)
[10:58:43.139]                             muffled <- TRUE
[10:58:43.139]                             break
[10:58:43.139]                           }
[10:58:43.139]                         }
[10:58:43.139]                       }
[10:58:43.139]                       invisible(muffled)
[10:58:43.139]                     }
[10:58:43.139]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.139]                   }
[10:58:43.139]                 }
[10:58:43.139]             }
[10:58:43.139]         }))
[10:58:43.139]     }, error = function(ex) {
[10:58:43.139]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.139]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.139]                 ...future.rng), started = ...future.startTime, 
[10:58:43.139]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.139]             version = "1.8"), class = "FutureResult")
[10:58:43.139]     }, finally = {
[10:58:43.139]         if (!identical(...future.workdir, getwd())) 
[10:58:43.139]             setwd(...future.workdir)
[10:58:43.139]         {
[10:58:43.139]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.139]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.139]             }
[10:58:43.139]             base::options(...future.oldOptions)
[10:58:43.139]             if (.Platform$OS.type == "windows") {
[10:58:43.139]                 old_names <- names(...future.oldEnvVars)
[10:58:43.139]                 envs <- base::Sys.getenv()
[10:58:43.139]                 names <- names(envs)
[10:58:43.139]                 common <- intersect(names, old_names)
[10:58:43.139]                 added <- setdiff(names, old_names)
[10:58:43.139]                 removed <- setdiff(old_names, names)
[10:58:43.139]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.139]                   envs[common]]
[10:58:43.139]                 NAMES <- toupper(changed)
[10:58:43.139]                 args <- list()
[10:58:43.139]                 for (kk in seq_along(NAMES)) {
[10:58:43.139]                   name <- changed[[kk]]
[10:58:43.139]                   NAME <- NAMES[[kk]]
[10:58:43.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.139]                     next
[10:58:43.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.139]                 }
[10:58:43.139]                 NAMES <- toupper(added)
[10:58:43.139]                 for (kk in seq_along(NAMES)) {
[10:58:43.139]                   name <- added[[kk]]
[10:58:43.139]                   NAME <- NAMES[[kk]]
[10:58:43.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.139]                     next
[10:58:43.139]                   args[[name]] <- ""
[10:58:43.139]                 }
[10:58:43.139]                 NAMES <- toupper(removed)
[10:58:43.139]                 for (kk in seq_along(NAMES)) {
[10:58:43.139]                   name <- removed[[kk]]
[10:58:43.139]                   NAME <- NAMES[[kk]]
[10:58:43.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.139]                     next
[10:58:43.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.139]                 }
[10:58:43.139]                 if (length(args) > 0) 
[10:58:43.139]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.139]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.139]             }
[10:58:43.139]             else {
[10:58:43.139]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.139]             }
[10:58:43.139]             {
[10:58:43.139]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.139]                   0L) {
[10:58:43.139]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.139]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.139]                   base::options(opts)
[10:58:43.139]                 }
[10:58:43.139]                 {
[10:58:43.139]                   {
[10:58:43.139]                     NULL
[10:58:43.139]                     RNGkind("Mersenne-Twister")
[10:58:43.139]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.139]                       inherits = FALSE)
[10:58:43.139]                   }
[10:58:43.139]                   options(future.plan = NULL)
[10:58:43.139]                   if (is.na(NA_character_)) 
[10:58:43.139]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.139]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.139]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.139]                     .init = FALSE)
[10:58:43.139]                 }
[10:58:43.139]             }
[10:58:43.139]         }
[10:58:43.139]     })
[10:58:43.139]     if (TRUE) {
[10:58:43.139]         base::sink(type = "output", split = FALSE)
[10:58:43.139]         if (TRUE) {
[10:58:43.139]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.139]         }
[10:58:43.139]         else {
[10:58:43.139]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.139]         }
[10:58:43.139]         base::close(...future.stdout)
[10:58:43.139]         ...future.stdout <- NULL
[10:58:43.139]     }
[10:58:43.139]     ...future.result$conditions <- ...future.conditions
[10:58:43.139]     ...future.result$finished <- base::Sys.time()
[10:58:43.139]     ...future.result
[10:58:43.139] }
[10:58:43.141] assign_globals() ...
[10:58:43.141] List of 5
[10:58:43.141]  $ ...future.FUN            :function (object, ...)  
[10:58:43.141]  $ future.call.arguments    : list()
[10:58:43.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.141]  $ ...future.elements_ii    :List of 3
[10:58:43.141]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.141]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.141]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.141]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.141]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.141]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.141]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.141]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.141]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.141]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.141]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.141]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.141]  $ ...future.seeds_ii       : NULL
[10:58:43.141]  $ ...future.globals.maxSize: NULL
[10:58:43.141]  - attr(*, "where")=List of 5
[10:58:43.141]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.141]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.141]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.141]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.141]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.141]  - attr(*, "resolved")= logi FALSE
[10:58:43.141]  - attr(*, "total_size")= num 19278
[10:58:43.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.141]  - attr(*, "already-done")= logi TRUE
[10:58:43.149] - copied ‘...future.FUN’ to environment
[10:58:43.149] - copied ‘future.call.arguments’ to environment
[10:58:43.149] - copied ‘...future.elements_ii’ to environment
[10:58:43.150] - copied ‘...future.seeds_ii’ to environment
[10:58:43.150] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.150] assign_globals() ... done
[10:58:43.150] plan(): Setting new future strategy stack:
[10:58:43.150] List of future strategies:
[10:58:43.150] 1. sequential:
[10:58:43.150]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.150]    - tweaked: FALSE
[10:58:43.150]    - call: NULL
[10:58:43.150] plan(): nbrOfWorkers() = 1
[10:58:43.152] plan(): Setting new future strategy stack:
[10:58:43.152] List of future strategies:
[10:58:43.152] 1. multicore:
[10:58:43.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.152]    - tweaked: FALSE
[10:58:43.152]    - call: plan(strategy)
[10:58:43.154] plan(): nbrOfWorkers() = 1
[10:58:43.154] SequentialFuture started (and completed)
[10:58:43.154] - Launch lazy future ... done
[10:58:43.154] run() for ‘SequentialFuture’ ... done
[10:58:43.154] Created future:
[10:58:43.154] SequentialFuture:
[10:58:43.154] Label: ‘future_by-1’
[10:58:43.154] Expression:
[10:58:43.154] {
[10:58:43.154]     do.call(function(...) {
[10:58:43.154]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.154]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.154]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.154]             on.exit(options(oopts), add = TRUE)
[10:58:43.154]         }
[10:58:43.154]         {
[10:58:43.154]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.154]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.154]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.154]             })
[10:58:43.154]         }
[10:58:43.154]     }, args = future.call.arguments)
[10:58:43.154] }
[10:58:43.154] Lazy evaluation: FALSE
[10:58:43.154] Asynchronous evaluation: FALSE
[10:58:43.154] Local evaluation: TRUE
[10:58:43.154] Environment: 0x55974dc64058
[10:58:43.154] Capture standard output: TRUE
[10:58:43.154] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.154] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.154] Packages: <none>
[10:58:43.154] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.154] Resolved: TRUE
[10:58:43.154] Value: 1.39 KiB of class ‘list’
[10:58:43.154] Early signaling: FALSE
[10:58:43.154] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.154] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.155] Chunk #1 of 1 ... DONE
[10:58:43.155] Launching 1 futures (chunks) ... DONE
[10:58:43.155] Resolving 1 futures (chunks) ...
[10:58:43.156] resolve() on list ...
[10:58:43.156]  recursive: 0
[10:58:43.156]  length: 1
[10:58:43.156] 
[10:58:43.156] resolved() for ‘SequentialFuture’ ...
[10:58:43.156] - state: ‘finished’
[10:58:43.156] - run: TRUE
[10:58:43.156] - result: ‘FutureResult’
[10:58:43.156] resolved() for ‘SequentialFuture’ ... done
[10:58:43.156] Future #1
[10:58:43.156] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.157] - nx: 1
[10:58:43.157] - relay: TRUE
[10:58:43.157] - stdout: TRUE
[10:58:43.157] - signal: TRUE
[10:58:43.157] - resignal: FALSE
[10:58:43.157] - force: TRUE
[10:58:43.157] - relayed: [n=1] FALSE
[10:58:43.157] - queued futures: [n=1] FALSE
[10:58:43.157]  - until=1
[10:58:43.157]  - relaying element #1
[10:58:43.157] - relayed: [n=1] TRUE
[10:58:43.157] - queued futures: [n=1] TRUE
[10:58:43.157] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.158]  length: 0 (resolved future 1)
[10:58:43.158] Relaying remaining futures
[10:58:43.158] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.158] - nx: 1
[10:58:43.158] - relay: TRUE
[10:58:43.158] - stdout: TRUE
[10:58:43.158] - signal: TRUE
[10:58:43.158] - resignal: FALSE
[10:58:43.158] - force: TRUE
[10:58:43.158] - relayed: [n=1] TRUE
[10:58:43.158] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.158] - relayed: [n=1] TRUE
[10:58:43.158] - queued futures: [n=1] TRUE
[10:58:43.159] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.159] resolve() on list ... DONE
[10:58:43.159]  - Number of value chunks collected: 1
[10:58:43.159] Resolving 1 futures (chunks) ... DONE
[10:58:43.159] Reducing values from 1 chunks ...
[10:58:43.159]  - Number of values collected after concatenation: 3
[10:58:43.159]  - Number of values expected: 3
[10:58:43.159] Reducing values from 1 chunks ... DONE
[10:58:43.159] future_lapply() ... DONE
[10:58:43.159] future_by_internal() ... DONE
[10:58:43.160] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:58:43.160] future_lapply() ...
[10:58:43.162] Number of chunks: 1
[10:58:43.162] getGlobalsAndPackagesXApply() ...
[10:58:43.162]  - future.globals: TRUE
[10:58:43.162] getGlobalsAndPackages() ...
[10:58:43.162] Searching for globals...
[10:58:43.163] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.163] Searching for globals ... DONE
[10:58:43.163] Resolving globals: FALSE
[10:58:43.164] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.164] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.164] - globals: [1] ‘FUN’
[10:58:43.164] 
[10:58:43.164] getGlobalsAndPackages() ... DONE
[10:58:43.164]  - globals found/used: [n=1] ‘FUN’
[10:58:43.164]  - needed namespaces: [n=0] 
[10:58:43.165] Finding globals ... DONE
[10:58:43.165]  - use_args: TRUE
[10:58:43.165]  - Getting '...' globals ...
[10:58:43.165] resolve() on list ...
[10:58:43.165]  recursive: 0
[10:58:43.165]  length: 1
[10:58:43.165]  elements: ‘...’
[10:58:43.165]  length: 0 (resolved future 1)
[10:58:43.165] resolve() on list ... DONE
[10:58:43.166]    - '...' content: [n=0] 
[10:58:43.166] List of 1
[10:58:43.166]  $ ...: list()
[10:58:43.166]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.166]  - attr(*, "where")=List of 1
[10:58:43.166]   ..$ ...:<environment: 0x55974dafcaa8> 
[10:58:43.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.166]  - attr(*, "resolved")= logi TRUE
[10:58:43.166]  - attr(*, "total_size")= num NA
[10:58:43.169]  - Getting '...' globals ... DONE
[10:58:43.169] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.169] List of 2
[10:58:43.169]  $ ...future.FUN:function (object, ...)  
[10:58:43.169]  $ ...          : list()
[10:58:43.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.169]  - attr(*, "where")=List of 2
[10:58:43.169]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.169]   ..$ ...          :<environment: 0x55974dafcaa8> 
[10:58:43.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.169]  - attr(*, "resolved")= logi FALSE
[10:58:43.169]  - attr(*, "total_size")= num 18647
[10:58:43.172] Packages to be attached in all futures: [n=0] 
[10:58:43.172] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.172] Number of futures (= number of chunks): 1
[10:58:43.172] Launching 1 futures (chunks) ...
[10:58:43.172] Chunk #1 of 1 ...
[10:58:43.172]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.172] getGlobalsAndPackages() ...
[10:58:43.172] Searching for globals...
[10:58:43.173] 
[10:58:43.173] Searching for globals ... DONE
[10:58:43.173] - globals: [0] <none>
[10:58:43.173] getGlobalsAndPackages() ... DONE
[10:58:43.173]    + additional globals found: [n=0] 
[10:58:43.173]    + additional namespaces needed: [n=0] 
[10:58:43.173]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.173]  - seeds: <none>
[10:58:43.173]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.174] getGlobalsAndPackages() ...
[10:58:43.174] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.174] Resolving globals: FALSE
[10:58:43.174] Tweak future expression to call with '...' arguments ...
[10:58:43.174] {
[10:58:43.174]     do.call(function(...) {
[10:58:43.174]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.174]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.174]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.174]             on.exit(options(oopts), add = TRUE)
[10:58:43.174]         }
[10:58:43.174]         {
[10:58:43.174]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.174]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.174]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.174]             })
[10:58:43.174]         }
[10:58:43.174]     }, args = future.call.arguments)
[10:58:43.174] }
[10:58:43.174] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.174] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.175] 
[10:58:43.175] getGlobalsAndPackages() ... DONE
[10:58:43.175] run() for ‘Future’ ...
[10:58:43.175] - state: ‘created’
[10:58:43.175] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.177] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.177] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.177]   - Field: ‘label’
[10:58:43.177]   - Field: ‘local’
[10:58:43.177]   - Field: ‘owner’
[10:58:43.177]   - Field: ‘envir’
[10:58:43.177]   - Field: ‘packages’
[10:58:43.177]   - Field: ‘gc’
[10:58:43.177]   - Field: ‘conditions’
[10:58:43.177]   - Field: ‘expr’
[10:58:43.177]   - Field: ‘uuid’
[10:58:43.178]   - Field: ‘seed’
[10:58:43.178]   - Field: ‘version’
[10:58:43.178]   - Field: ‘result’
[10:58:43.178]   - Field: ‘asynchronous’
[10:58:43.178]   - Field: ‘calls’
[10:58:43.178]   - Field: ‘globals’
[10:58:43.178]   - Field: ‘stdout’
[10:58:43.178]   - Field: ‘earlySignal’
[10:58:43.178]   - Field: ‘lazy’
[10:58:43.178]   - Field: ‘state’
[10:58:43.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.178] - Launch lazy future ...
[10:58:43.179] Packages needed by the future expression (n = 0): <none>
[10:58:43.179] Packages needed by future strategies (n = 0): <none>
[10:58:43.179] {
[10:58:43.179]     {
[10:58:43.179]         {
[10:58:43.179]             ...future.startTime <- base::Sys.time()
[10:58:43.179]             {
[10:58:43.179]                 {
[10:58:43.179]                   {
[10:58:43.179]                     base::local({
[10:58:43.179]                       has_future <- base::requireNamespace("future", 
[10:58:43.179]                         quietly = TRUE)
[10:58:43.179]                       if (has_future) {
[10:58:43.179]                         ns <- base::getNamespace("future")
[10:58:43.179]                         version <- ns[[".package"]][["version"]]
[10:58:43.179]                         if (is.null(version)) 
[10:58:43.179]                           version <- utils::packageVersion("future")
[10:58:43.179]                       }
[10:58:43.179]                       else {
[10:58:43.179]                         version <- NULL
[10:58:43.179]                       }
[10:58:43.179]                       if (!has_future || version < "1.8.0") {
[10:58:43.179]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.179]                           "", base::R.version$version.string), 
[10:58:43.179]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.179]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.179]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.179]                             "release", "version")], collapse = " "), 
[10:58:43.179]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.179]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.179]                           info)
[10:58:43.179]                         info <- base::paste(info, collapse = "; ")
[10:58:43.179]                         if (!has_future) {
[10:58:43.179]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.179]                             info)
[10:58:43.179]                         }
[10:58:43.179]                         else {
[10:58:43.179]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.179]                             info, version)
[10:58:43.179]                         }
[10:58:43.179]                         base::stop(msg)
[10:58:43.179]                       }
[10:58:43.179]                     })
[10:58:43.179]                   }
[10:58:43.179]                   ...future.strategy.old <- future::plan("list")
[10:58:43.179]                   options(future.plan = NULL)
[10:58:43.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.179]                 }
[10:58:43.179]                 ...future.workdir <- getwd()
[10:58:43.179]             }
[10:58:43.179]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.179]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.179]         }
[10:58:43.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.179]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.179]             base::names(...future.oldOptions))
[10:58:43.179]     }
[10:58:43.179]     if (FALSE) {
[10:58:43.179]     }
[10:58:43.179]     else {
[10:58:43.179]         if (TRUE) {
[10:58:43.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.179]                 open = "w")
[10:58:43.179]         }
[10:58:43.179]         else {
[10:58:43.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.179]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.179]         }
[10:58:43.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.179]             base::sink(type = "output", split = FALSE)
[10:58:43.179]             base::close(...future.stdout)
[10:58:43.179]         }, add = TRUE)
[10:58:43.179]     }
[10:58:43.179]     ...future.frame <- base::sys.nframe()
[10:58:43.179]     ...future.conditions <- base::list()
[10:58:43.179]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.179]     if (FALSE) {
[10:58:43.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.179]     }
[10:58:43.179]     ...future.result <- base::tryCatch({
[10:58:43.179]         base::withCallingHandlers({
[10:58:43.179]             ...future.value <- base::withVisible(base::local({
[10:58:43.179]                 do.call(function(...) {
[10:58:43.179]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.179]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.179]                     ...future.globals.maxSize)) {
[10:58:43.179]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.179]                     on.exit(options(oopts), add = TRUE)
[10:58:43.179]                   }
[10:58:43.179]                   {
[10:58:43.179]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.179]                       FUN = function(jj) {
[10:58:43.179]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.179]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.179]                       })
[10:58:43.179]                   }
[10:58:43.179]                 }, args = future.call.arguments)
[10:58:43.179]             }))
[10:58:43.179]             future::FutureResult(value = ...future.value$value, 
[10:58:43.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.179]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.179]                     ...future.globalenv.names))
[10:58:43.179]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.179]         }, condition = base::local({
[10:58:43.179]             c <- base::c
[10:58:43.179]             inherits <- base::inherits
[10:58:43.179]             invokeRestart <- base::invokeRestart
[10:58:43.179]             length <- base::length
[10:58:43.179]             list <- base::list
[10:58:43.179]             seq.int <- base::seq.int
[10:58:43.179]             signalCondition <- base::signalCondition
[10:58:43.179]             sys.calls <- base::sys.calls
[10:58:43.179]             `[[` <- base::`[[`
[10:58:43.179]             `+` <- base::`+`
[10:58:43.179]             `<<-` <- base::`<<-`
[10:58:43.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.179]                   3L)]
[10:58:43.179]             }
[10:58:43.179]             function(cond) {
[10:58:43.179]                 is_error <- inherits(cond, "error")
[10:58:43.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.179]                   NULL)
[10:58:43.179]                 if (is_error) {
[10:58:43.179]                   sessionInformation <- function() {
[10:58:43.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.179]                       search = base::search(), system = base::Sys.info())
[10:58:43.179]                   }
[10:58:43.179]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.179]                     cond$call), session = sessionInformation(), 
[10:58:43.179]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.179]                   signalCondition(cond)
[10:58:43.179]                 }
[10:58:43.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.179]                 "immediateCondition"))) {
[10:58:43.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.179]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.179]                   if (TRUE && !signal) {
[10:58:43.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.179]                     {
[10:58:43.179]                       inherits <- base::inherits
[10:58:43.179]                       invokeRestart <- base::invokeRestart
[10:58:43.179]                       is.null <- base::is.null
[10:58:43.179]                       muffled <- FALSE
[10:58:43.179]                       if (inherits(cond, "message")) {
[10:58:43.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.179]                         if (muffled) 
[10:58:43.179]                           invokeRestart("muffleMessage")
[10:58:43.179]                       }
[10:58:43.179]                       else if (inherits(cond, "warning")) {
[10:58:43.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.179]                         if (muffled) 
[10:58:43.179]                           invokeRestart("muffleWarning")
[10:58:43.179]                       }
[10:58:43.179]                       else if (inherits(cond, "condition")) {
[10:58:43.179]                         if (!is.null(pattern)) {
[10:58:43.179]                           computeRestarts <- base::computeRestarts
[10:58:43.179]                           grepl <- base::grepl
[10:58:43.179]                           restarts <- computeRestarts(cond)
[10:58:43.179]                           for (restart in restarts) {
[10:58:43.179]                             name <- restart$name
[10:58:43.179]                             if (is.null(name)) 
[10:58:43.179]                               next
[10:58:43.179]                             if (!grepl(pattern, name)) 
[10:58:43.179]                               next
[10:58:43.179]                             invokeRestart(restart)
[10:58:43.179]                             muffled <- TRUE
[10:58:43.179]                             break
[10:58:43.179]                           }
[10:58:43.179]                         }
[10:58:43.179]                       }
[10:58:43.179]                       invisible(muffled)
[10:58:43.179]                     }
[10:58:43.179]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.179]                   }
[10:58:43.179]                 }
[10:58:43.179]                 else {
[10:58:43.179]                   if (TRUE) {
[10:58:43.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.179]                     {
[10:58:43.179]                       inherits <- base::inherits
[10:58:43.179]                       invokeRestart <- base::invokeRestart
[10:58:43.179]                       is.null <- base::is.null
[10:58:43.179]                       muffled <- FALSE
[10:58:43.179]                       if (inherits(cond, "message")) {
[10:58:43.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.179]                         if (muffled) 
[10:58:43.179]                           invokeRestart("muffleMessage")
[10:58:43.179]                       }
[10:58:43.179]                       else if (inherits(cond, "warning")) {
[10:58:43.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.179]                         if (muffled) 
[10:58:43.179]                           invokeRestart("muffleWarning")
[10:58:43.179]                       }
[10:58:43.179]                       else if (inherits(cond, "condition")) {
[10:58:43.179]                         if (!is.null(pattern)) {
[10:58:43.179]                           computeRestarts <- base::computeRestarts
[10:58:43.179]                           grepl <- base::grepl
[10:58:43.179]                           restarts <- computeRestarts(cond)
[10:58:43.179]                           for (restart in restarts) {
[10:58:43.179]                             name <- restart$name
[10:58:43.179]                             if (is.null(name)) 
[10:58:43.179]                               next
[10:58:43.179]                             if (!grepl(pattern, name)) 
[10:58:43.179]                               next
[10:58:43.179]                             invokeRestart(restart)
[10:58:43.179]                             muffled <- TRUE
[10:58:43.179]                             break
[10:58:43.179]                           }
[10:58:43.179]                         }
[10:58:43.179]                       }
[10:58:43.179]                       invisible(muffled)
[10:58:43.179]                     }
[10:58:43.179]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.179]                   }
[10:58:43.179]                 }
[10:58:43.179]             }
[10:58:43.179]         }))
[10:58:43.179]     }, error = function(ex) {
[10:58:43.179]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.179]                 ...future.rng), started = ...future.startTime, 
[10:58:43.179]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.179]             version = "1.8"), class = "FutureResult")
[10:58:43.179]     }, finally = {
[10:58:43.179]         if (!identical(...future.workdir, getwd())) 
[10:58:43.179]             setwd(...future.workdir)
[10:58:43.179]         {
[10:58:43.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.179]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.179]             }
[10:58:43.179]             base::options(...future.oldOptions)
[10:58:43.179]             if (.Platform$OS.type == "windows") {
[10:58:43.179]                 old_names <- names(...future.oldEnvVars)
[10:58:43.179]                 envs <- base::Sys.getenv()
[10:58:43.179]                 names <- names(envs)
[10:58:43.179]                 common <- intersect(names, old_names)
[10:58:43.179]                 added <- setdiff(names, old_names)
[10:58:43.179]                 removed <- setdiff(old_names, names)
[10:58:43.179]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.179]                   envs[common]]
[10:58:43.179]                 NAMES <- toupper(changed)
[10:58:43.179]                 args <- list()
[10:58:43.179]                 for (kk in seq_along(NAMES)) {
[10:58:43.179]                   name <- changed[[kk]]
[10:58:43.179]                   NAME <- NAMES[[kk]]
[10:58:43.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.179]                     next
[10:58:43.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.179]                 }
[10:58:43.179]                 NAMES <- toupper(added)
[10:58:43.179]                 for (kk in seq_along(NAMES)) {
[10:58:43.179]                   name <- added[[kk]]
[10:58:43.179]                   NAME <- NAMES[[kk]]
[10:58:43.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.179]                     next
[10:58:43.179]                   args[[name]] <- ""
[10:58:43.179]                 }
[10:58:43.179]                 NAMES <- toupper(removed)
[10:58:43.179]                 for (kk in seq_along(NAMES)) {
[10:58:43.179]                   name <- removed[[kk]]
[10:58:43.179]                   NAME <- NAMES[[kk]]
[10:58:43.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.179]                     next
[10:58:43.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.179]                 }
[10:58:43.179]                 if (length(args) > 0) 
[10:58:43.179]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.179]             }
[10:58:43.179]             else {
[10:58:43.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.179]             }
[10:58:43.179]             {
[10:58:43.179]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.179]                   0L) {
[10:58:43.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.179]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.179]                   base::options(opts)
[10:58:43.179]                 }
[10:58:43.179]                 {
[10:58:43.179]                   {
[10:58:43.179]                     NULL
[10:58:43.179]                     RNGkind("Mersenne-Twister")
[10:58:43.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.179]                       inherits = FALSE)
[10:58:43.179]                   }
[10:58:43.179]                   options(future.plan = NULL)
[10:58:43.179]                   if (is.na(NA_character_)) 
[10:58:43.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.179]                     .init = FALSE)
[10:58:43.179]                 }
[10:58:43.179]             }
[10:58:43.179]         }
[10:58:43.179]     })
[10:58:43.179]     if (TRUE) {
[10:58:43.179]         base::sink(type = "output", split = FALSE)
[10:58:43.179]         if (TRUE) {
[10:58:43.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.179]         }
[10:58:43.179]         else {
[10:58:43.179]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.179]         }
[10:58:43.179]         base::close(...future.stdout)
[10:58:43.179]         ...future.stdout <- NULL
[10:58:43.179]     }
[10:58:43.179]     ...future.result$conditions <- ...future.conditions
[10:58:43.179]     ...future.result$finished <- base::Sys.time()
[10:58:43.179]     ...future.result
[10:58:43.179] }
[10:58:43.181] assign_globals() ...
[10:58:43.181] List of 5
[10:58:43.181]  $ ...future.FUN            :function (object, ...)  
[10:58:43.181]  $ future.call.arguments    : list()
[10:58:43.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.181]  $ ...future.elements_ii    :List of 3
[10:58:43.181]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.181]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.181]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.181]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.181]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.181]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.181]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.181]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.181]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.181]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.181]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.181]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.181]  $ ...future.seeds_ii       : NULL
[10:58:43.181]  $ ...future.globals.maxSize: NULL
[10:58:43.181]  - attr(*, "where")=List of 5
[10:58:43.181]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.181]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.181]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.181]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.181]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.181]  - attr(*, "resolved")= logi FALSE
[10:58:43.181]  - attr(*, "total_size")= num 18647
[10:58:43.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.181]  - attr(*, "already-done")= logi TRUE
[10:58:43.190] - copied ‘...future.FUN’ to environment
[10:58:43.190] - copied ‘future.call.arguments’ to environment
[10:58:43.190] - copied ‘...future.elements_ii’ to environment
[10:58:43.190] - copied ‘...future.seeds_ii’ to environment
[10:58:43.190] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.190] assign_globals() ... done
[10:58:43.190] plan(): Setting new future strategy stack:
[10:58:43.190] List of future strategies:
[10:58:43.190] 1. sequential:
[10:58:43.190]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.190]    - tweaked: FALSE
[10:58:43.190]    - call: NULL
[10:58:43.191] plan(): nbrOfWorkers() = 1
[10:58:43.193] plan(): Setting new future strategy stack:
[10:58:43.193] List of future strategies:
[10:58:43.193] 1. multicore:
[10:58:43.193]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.193]    - tweaked: FALSE
[10:58:43.193]    - call: plan(strategy)
[10:58:43.194] plan(): nbrOfWorkers() = 1
[10:58:43.195] SequentialFuture started (and completed)
[10:58:43.195] - Launch lazy future ... done
[10:58:43.195] run() for ‘SequentialFuture’ ... done
[10:58:43.195] Created future:
[10:58:43.195] SequentialFuture:
[10:58:43.195] Label: ‘future_by-1’
[10:58:43.195] Expression:
[10:58:43.195] {
[10:58:43.195]     do.call(function(...) {
[10:58:43.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.195]             on.exit(options(oopts), add = TRUE)
[10:58:43.195]         }
[10:58:43.195]         {
[10:58:43.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.195]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.195]             })
[10:58:43.195]         }
[10:58:43.195]     }, args = future.call.arguments)
[10:58:43.195] }
[10:58:43.195] Lazy evaluation: FALSE
[10:58:43.195] Asynchronous evaluation: FALSE
[10:58:43.195] Local evaluation: TRUE
[10:58:43.195] Environment: 0x55974daa2d68
[10:58:43.195] Capture standard output: TRUE
[10:58:43.195] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.195] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.195] Packages: <none>
[10:58:43.195] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.195] Resolved: TRUE
[10:58:43.195] Value: 1.39 KiB of class ‘list’
[10:58:43.195] Early signaling: FALSE
[10:58:43.195] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.195] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.196] Chunk #1 of 1 ... DONE
[10:58:43.196] Launching 1 futures (chunks) ... DONE
[10:58:43.196] Resolving 1 futures (chunks) ...
[10:58:43.196] resolve() on list ...
[10:58:43.196]  recursive: 0
[10:58:43.196]  length: 1
[10:58:43.196] 
[10:58:43.196] resolved() for ‘SequentialFuture’ ...
[10:58:43.196] - state: ‘finished’
[10:58:43.197] - run: TRUE
[10:58:43.197] - result: ‘FutureResult’
[10:58:43.197] resolved() for ‘SequentialFuture’ ... done
[10:58:43.197] Future #1
[10:58:43.197] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.197] - nx: 1
[10:58:43.197] - relay: TRUE
[10:58:43.197] - stdout: TRUE
[10:58:43.197] - signal: TRUE
[10:58:43.197] - resignal: FALSE
[10:58:43.197] - force: TRUE
[10:58:43.197] - relayed: [n=1] FALSE
[10:58:43.198] - queued futures: [n=1] FALSE
[10:58:43.198]  - until=1
[10:58:43.198]  - relaying element #1
[10:58:43.198] - relayed: [n=1] TRUE
[10:58:43.198] - queued futures: [n=1] TRUE
[10:58:43.198] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.198]  length: 0 (resolved future 1)
[10:58:43.198] Relaying remaining futures
[10:58:43.198] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.198] - nx: 1
[10:58:43.198] - relay: TRUE
[10:58:43.198] - stdout: TRUE
[10:58:43.199] - signal: TRUE
[10:58:43.199] - resignal: FALSE
[10:58:43.199] - force: TRUE
[10:58:43.199] - relayed: [n=1] TRUE
[10:58:43.199] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.199] - relayed: [n=1] TRUE
[10:58:43.199] - queued futures: [n=1] TRUE
[10:58:43.199] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.199] resolve() on list ... DONE
[10:58:43.199]  - Number of value chunks collected: 1
[10:58:43.199] Resolving 1 futures (chunks) ... DONE
[10:58:43.200] Reducing values from 1 chunks ...
[10:58:43.200]  - Number of values collected after concatenation: 3
[10:58:43.200]  - Number of values expected: 3
[10:58:43.200] Reducing values from 1 chunks ... DONE
[10:58:43.200] future_lapply() ... DONE
[10:58:43.200] future_by_internal() ... DONE
[10:58:43.201] future_by_internal() ...
- plan('multisession') ...
[10:58:43.201] plan(): Setting new future strategy stack:
[10:58:43.201] List of future strategies:
[10:58:43.201] 1. multisession:
[10:58:43.201]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.201]    - tweaked: FALSE
[10:58:43.201]    - call: plan(strategy)
[10:58:43.202] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:58:43.202] multisession:
[10:58:43.202] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.202] - tweaked: FALSE
[10:58:43.202] - call: plan(strategy)
[10:58:43.203] getGlobalsAndPackages() ...
[10:58:43.203] Not searching for globals
[10:58:43.203] - globals: [0] <none>
[10:58:43.203] getGlobalsAndPackages() ... DONE
[10:58:43.204] Packages needed by the future expression (n = 0): <none>
[10:58:43.204] Packages needed by future strategies (n = 0): <none>
[10:58:43.204] {
[10:58:43.204]     {
[10:58:43.204]         {
[10:58:43.204]             ...future.startTime <- base::Sys.time()
[10:58:43.204]             {
[10:58:43.204]                 {
[10:58:43.204]                   {
[10:58:43.204]                     base::local({
[10:58:43.204]                       has_future <- base::requireNamespace("future", 
[10:58:43.204]                         quietly = TRUE)
[10:58:43.204]                       if (has_future) {
[10:58:43.204]                         ns <- base::getNamespace("future")
[10:58:43.204]                         version <- ns[[".package"]][["version"]]
[10:58:43.204]                         if (is.null(version)) 
[10:58:43.204]                           version <- utils::packageVersion("future")
[10:58:43.204]                       }
[10:58:43.204]                       else {
[10:58:43.204]                         version <- NULL
[10:58:43.204]                       }
[10:58:43.204]                       if (!has_future || version < "1.8.0") {
[10:58:43.204]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.204]                           "", base::R.version$version.string), 
[10:58:43.204]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.204]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.204]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.204]                             "release", "version")], collapse = " "), 
[10:58:43.204]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.204]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.204]                           info)
[10:58:43.204]                         info <- base::paste(info, collapse = "; ")
[10:58:43.204]                         if (!has_future) {
[10:58:43.204]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.204]                             info)
[10:58:43.204]                         }
[10:58:43.204]                         else {
[10:58:43.204]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.204]                             info, version)
[10:58:43.204]                         }
[10:58:43.204]                         base::stop(msg)
[10:58:43.204]                       }
[10:58:43.204]                     })
[10:58:43.204]                   }
[10:58:43.204]                   ...future.strategy.old <- future::plan("list")
[10:58:43.204]                   options(future.plan = NULL)
[10:58:43.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.204]                 }
[10:58:43.204]                 ...future.workdir <- getwd()
[10:58:43.204]             }
[10:58:43.204]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.204]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.204]         }
[10:58:43.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.204]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.204]             base::names(...future.oldOptions))
[10:58:43.204]     }
[10:58:43.204]     if (FALSE) {
[10:58:43.204]     }
[10:58:43.204]     else {
[10:58:43.204]         if (TRUE) {
[10:58:43.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.204]                 open = "w")
[10:58:43.204]         }
[10:58:43.204]         else {
[10:58:43.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.204]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.204]         }
[10:58:43.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.204]             base::sink(type = "output", split = FALSE)
[10:58:43.204]             base::close(...future.stdout)
[10:58:43.204]         }, add = TRUE)
[10:58:43.204]     }
[10:58:43.204]     ...future.frame <- base::sys.nframe()
[10:58:43.204]     ...future.conditions <- base::list()
[10:58:43.204]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.204]     if (FALSE) {
[10:58:43.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.204]     }
[10:58:43.204]     ...future.result <- base::tryCatch({
[10:58:43.204]         base::withCallingHandlers({
[10:58:43.204]             ...future.value <- base::withVisible(base::local(NA))
[10:58:43.204]             future::FutureResult(value = ...future.value$value, 
[10:58:43.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.204]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.204]                     ...future.globalenv.names))
[10:58:43.204]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.204]         }, condition = base::local({
[10:58:43.204]             c <- base::c
[10:58:43.204]             inherits <- base::inherits
[10:58:43.204]             invokeRestart <- base::invokeRestart
[10:58:43.204]             length <- base::length
[10:58:43.204]             list <- base::list
[10:58:43.204]             seq.int <- base::seq.int
[10:58:43.204]             signalCondition <- base::signalCondition
[10:58:43.204]             sys.calls <- base::sys.calls
[10:58:43.204]             `[[` <- base::`[[`
[10:58:43.204]             `+` <- base::`+`
[10:58:43.204]             `<<-` <- base::`<<-`
[10:58:43.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.204]                   3L)]
[10:58:43.204]             }
[10:58:43.204]             function(cond) {
[10:58:43.204]                 is_error <- inherits(cond, "error")
[10:58:43.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.204]                   NULL)
[10:58:43.204]                 if (is_error) {
[10:58:43.204]                   sessionInformation <- function() {
[10:58:43.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.204]                       search = base::search(), system = base::Sys.info())
[10:58:43.204]                   }
[10:58:43.204]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.204]                     cond$call), session = sessionInformation(), 
[10:58:43.204]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.204]                   signalCondition(cond)
[10:58:43.204]                 }
[10:58:43.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.204]                 "immediateCondition"))) {
[10:58:43.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.204]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.204]                   if (TRUE && !signal) {
[10:58:43.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.204]                     {
[10:58:43.204]                       inherits <- base::inherits
[10:58:43.204]                       invokeRestart <- base::invokeRestart
[10:58:43.204]                       is.null <- base::is.null
[10:58:43.204]                       muffled <- FALSE
[10:58:43.204]                       if (inherits(cond, "message")) {
[10:58:43.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.204]                         if (muffled) 
[10:58:43.204]                           invokeRestart("muffleMessage")
[10:58:43.204]                       }
[10:58:43.204]                       else if (inherits(cond, "warning")) {
[10:58:43.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.204]                         if (muffled) 
[10:58:43.204]                           invokeRestart("muffleWarning")
[10:58:43.204]                       }
[10:58:43.204]                       else if (inherits(cond, "condition")) {
[10:58:43.204]                         if (!is.null(pattern)) {
[10:58:43.204]                           computeRestarts <- base::computeRestarts
[10:58:43.204]                           grepl <- base::grepl
[10:58:43.204]                           restarts <- computeRestarts(cond)
[10:58:43.204]                           for (restart in restarts) {
[10:58:43.204]                             name <- restart$name
[10:58:43.204]                             if (is.null(name)) 
[10:58:43.204]                               next
[10:58:43.204]                             if (!grepl(pattern, name)) 
[10:58:43.204]                               next
[10:58:43.204]                             invokeRestart(restart)
[10:58:43.204]                             muffled <- TRUE
[10:58:43.204]                             break
[10:58:43.204]                           }
[10:58:43.204]                         }
[10:58:43.204]                       }
[10:58:43.204]                       invisible(muffled)
[10:58:43.204]                     }
[10:58:43.204]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.204]                   }
[10:58:43.204]                 }
[10:58:43.204]                 else {
[10:58:43.204]                   if (TRUE) {
[10:58:43.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.204]                     {
[10:58:43.204]                       inherits <- base::inherits
[10:58:43.204]                       invokeRestart <- base::invokeRestart
[10:58:43.204]                       is.null <- base::is.null
[10:58:43.204]                       muffled <- FALSE
[10:58:43.204]                       if (inherits(cond, "message")) {
[10:58:43.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.204]                         if (muffled) 
[10:58:43.204]                           invokeRestart("muffleMessage")
[10:58:43.204]                       }
[10:58:43.204]                       else if (inherits(cond, "warning")) {
[10:58:43.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.204]                         if (muffled) 
[10:58:43.204]                           invokeRestart("muffleWarning")
[10:58:43.204]                       }
[10:58:43.204]                       else if (inherits(cond, "condition")) {
[10:58:43.204]                         if (!is.null(pattern)) {
[10:58:43.204]                           computeRestarts <- base::computeRestarts
[10:58:43.204]                           grepl <- base::grepl
[10:58:43.204]                           restarts <- computeRestarts(cond)
[10:58:43.204]                           for (restart in restarts) {
[10:58:43.204]                             name <- restart$name
[10:58:43.204]                             if (is.null(name)) 
[10:58:43.204]                               next
[10:58:43.204]                             if (!grepl(pattern, name)) 
[10:58:43.204]                               next
[10:58:43.204]                             invokeRestart(restart)
[10:58:43.204]                             muffled <- TRUE
[10:58:43.204]                             break
[10:58:43.204]                           }
[10:58:43.204]                         }
[10:58:43.204]                       }
[10:58:43.204]                       invisible(muffled)
[10:58:43.204]                     }
[10:58:43.204]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.204]                   }
[10:58:43.204]                 }
[10:58:43.204]             }
[10:58:43.204]         }))
[10:58:43.204]     }, error = function(ex) {
[10:58:43.204]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.204]                 ...future.rng), started = ...future.startTime, 
[10:58:43.204]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.204]             version = "1.8"), class = "FutureResult")
[10:58:43.204]     }, finally = {
[10:58:43.204]         if (!identical(...future.workdir, getwd())) 
[10:58:43.204]             setwd(...future.workdir)
[10:58:43.204]         {
[10:58:43.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.204]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.204]             }
[10:58:43.204]             base::options(...future.oldOptions)
[10:58:43.204]             if (.Platform$OS.type == "windows") {
[10:58:43.204]                 old_names <- names(...future.oldEnvVars)
[10:58:43.204]                 envs <- base::Sys.getenv()
[10:58:43.204]                 names <- names(envs)
[10:58:43.204]                 common <- intersect(names, old_names)
[10:58:43.204]                 added <- setdiff(names, old_names)
[10:58:43.204]                 removed <- setdiff(old_names, names)
[10:58:43.204]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.204]                   envs[common]]
[10:58:43.204]                 NAMES <- toupper(changed)
[10:58:43.204]                 args <- list()
[10:58:43.204]                 for (kk in seq_along(NAMES)) {
[10:58:43.204]                   name <- changed[[kk]]
[10:58:43.204]                   NAME <- NAMES[[kk]]
[10:58:43.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.204]                     next
[10:58:43.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.204]                 }
[10:58:43.204]                 NAMES <- toupper(added)
[10:58:43.204]                 for (kk in seq_along(NAMES)) {
[10:58:43.204]                   name <- added[[kk]]
[10:58:43.204]                   NAME <- NAMES[[kk]]
[10:58:43.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.204]                     next
[10:58:43.204]                   args[[name]] <- ""
[10:58:43.204]                 }
[10:58:43.204]                 NAMES <- toupper(removed)
[10:58:43.204]                 for (kk in seq_along(NAMES)) {
[10:58:43.204]                   name <- removed[[kk]]
[10:58:43.204]                   NAME <- NAMES[[kk]]
[10:58:43.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.204]                     next
[10:58:43.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.204]                 }
[10:58:43.204]                 if (length(args) > 0) 
[10:58:43.204]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.204]             }
[10:58:43.204]             else {
[10:58:43.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.204]             }
[10:58:43.204]             {
[10:58:43.204]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.204]                   0L) {
[10:58:43.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.204]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.204]                   base::options(opts)
[10:58:43.204]                 }
[10:58:43.204]                 {
[10:58:43.204]                   {
[10:58:43.204]                     NULL
[10:58:43.204]                     RNGkind("Mersenne-Twister")
[10:58:43.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.204]                       inherits = FALSE)
[10:58:43.204]                   }
[10:58:43.204]                   options(future.plan = NULL)
[10:58:43.204]                   if (is.na(NA_character_)) 
[10:58:43.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.204]                     .init = FALSE)
[10:58:43.204]                 }
[10:58:43.204]             }
[10:58:43.204]         }
[10:58:43.204]     })
[10:58:43.204]     if (TRUE) {
[10:58:43.204]         base::sink(type = "output", split = FALSE)
[10:58:43.204]         if (TRUE) {
[10:58:43.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.204]         }
[10:58:43.204]         else {
[10:58:43.204]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.204]         }
[10:58:43.204]         base::close(...future.stdout)
[10:58:43.204]         ...future.stdout <- NULL
[10:58:43.204]     }
[10:58:43.204]     ...future.result$conditions <- ...future.conditions
[10:58:43.204]     ...future.result$finished <- base::Sys.time()
[10:58:43.204]     ...future.result
[10:58:43.204] }
[10:58:43.206] plan(): Setting new future strategy stack:
[10:58:43.206] List of future strategies:
[10:58:43.206] 1. sequential:
[10:58:43.206]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.206]    - tweaked: FALSE
[10:58:43.206]    - call: NULL
[10:58:43.207] plan(): nbrOfWorkers() = 1
[10:58:43.207] plan(): Setting new future strategy stack:
[10:58:43.207] List of future strategies:
[10:58:43.207] 1. multisession:
[10:58:43.207]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.207]    - tweaked: FALSE
[10:58:43.207]    - call: plan(strategy)
[10:58:43.209] plan(): nbrOfWorkers() = 1
[10:58:43.209] SequentialFuture started (and completed)
[10:58:43.209] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:58:43.210] plan(): nbrOfWorkers() = 1
[10:58:43.210] future_by_internal() ...
[10:58:43.211] future_lapply() ...
[10:58:43.213] Number of chunks: 1
[10:58:43.213] getGlobalsAndPackagesXApply() ...
[10:58:43.213]  - future.globals: TRUE
[10:58:43.213] getGlobalsAndPackages() ...
[10:58:43.214] Searching for globals...
[10:58:43.214] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.215] Searching for globals ... DONE
[10:58:43.215] Resolving globals: FALSE
[10:58:43.215] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.215] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.215] - globals: [1] ‘FUN’
[10:58:43.215] 
[10:58:43.216] getGlobalsAndPackages() ... DONE
[10:58:43.216]  - globals found/used: [n=1] ‘FUN’
[10:58:43.216]  - needed namespaces: [n=0] 
[10:58:43.216] Finding globals ... DONE
[10:58:43.216]  - use_args: TRUE
[10:58:43.216]  - Getting '...' globals ...
[10:58:43.216] resolve() on list ...
[10:58:43.216]  recursive: 0
[10:58:43.216]  length: 1
[10:58:43.216]  elements: ‘...’
[10:58:43.217]  length: 0 (resolved future 1)
[10:58:43.217] resolve() on list ... DONE
[10:58:43.217]    - '...' content: [n=0] 
[10:58:43.217] List of 1
[10:58:43.217]  $ ...: list()
[10:58:43.217]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.217]  - attr(*, "where")=List of 1
[10:58:43.217]   ..$ ...:<environment: 0x55974dfd3a08> 
[10:58:43.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.217]  - attr(*, "resolved")= logi TRUE
[10:58:43.217]  - attr(*, "total_size")= num NA
[10:58:43.219]  - Getting '...' globals ... DONE
[10:58:43.219] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.219] List of 2
[10:58:43.219]  $ ...future.FUN:function (object, ...)  
[10:58:43.219]  $ ...          : list()
[10:58:43.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.219]  - attr(*, "where")=List of 2
[10:58:43.219]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.219]   ..$ ...          :<environment: 0x55974dfd3a08> 
[10:58:43.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.219]  - attr(*, "resolved")= logi FALSE
[10:58:43.219]  - attr(*, "total_size")= num 15670
[10:58:43.222] Packages to be attached in all futures: [n=0] 
[10:58:43.222] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.222] Number of futures (= number of chunks): 1
[10:58:43.222] Launching 1 futures (chunks) ...
[10:58:43.222] Chunk #1 of 1 ...
[10:58:43.222]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.222] getGlobalsAndPackages() ...
[10:58:43.222] Searching for globals...
[10:58:43.223] 
[10:58:43.223] Searching for globals ... DONE
[10:58:43.223] - globals: [0] <none>
[10:58:43.223] getGlobalsAndPackages() ... DONE
[10:58:43.223]    + additional globals found: [n=0] 
[10:58:43.223]    + additional namespaces needed: [n=0] 
[10:58:43.223]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.223]  - seeds: <none>
[10:58:43.223]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.224] getGlobalsAndPackages() ...
[10:58:43.224] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.224] Resolving globals: FALSE
[10:58:43.224] Tweak future expression to call with '...' arguments ...
[10:58:43.224] {
[10:58:43.224]     do.call(function(...) {
[10:58:43.224]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.224]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.224]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.224]             on.exit(options(oopts), add = TRUE)
[10:58:43.224]         }
[10:58:43.224]         {
[10:58:43.224]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.224]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.224]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.224]             })
[10:58:43.224]         }
[10:58:43.224]     }, args = future.call.arguments)
[10:58:43.224] }
[10:58:43.224] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.224] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.225] 
[10:58:43.225] getGlobalsAndPackages() ... DONE
[10:58:43.225] run() for ‘Future’ ...
[10:58:43.225] - state: ‘created’
[10:58:43.225] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.226] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.227]   - Field: ‘label’
[10:58:43.227]   - Field: ‘local’
[10:58:43.227]   - Field: ‘owner’
[10:58:43.227]   - Field: ‘envir’
[10:58:43.227]   - Field: ‘packages’
[10:58:43.227]   - Field: ‘gc’
[10:58:43.227]   - Field: ‘conditions’
[10:58:43.227]   - Field: ‘expr’
[10:58:43.227]   - Field: ‘uuid’
[10:58:43.227]   - Field: ‘seed’
[10:58:43.227]   - Field: ‘version’
[10:58:43.228]   - Field: ‘result’
[10:58:43.228]   - Field: ‘asynchronous’
[10:58:43.228]   - Field: ‘calls’
[10:58:43.228]   - Field: ‘globals’
[10:58:43.228]   - Field: ‘stdout’
[10:58:43.228]   - Field: ‘earlySignal’
[10:58:43.228]   - Field: ‘lazy’
[10:58:43.228]   - Field: ‘state’
[10:58:43.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.228] - Launch lazy future ...
[10:58:43.228] Packages needed by the future expression (n = 0): <none>
[10:58:43.229] Packages needed by future strategies (n = 0): <none>
[10:58:43.229] {
[10:58:43.229]     {
[10:58:43.229]         {
[10:58:43.229]             ...future.startTime <- base::Sys.time()
[10:58:43.229]             {
[10:58:43.229]                 {
[10:58:43.229]                   {
[10:58:43.229]                     base::local({
[10:58:43.229]                       has_future <- base::requireNamespace("future", 
[10:58:43.229]                         quietly = TRUE)
[10:58:43.229]                       if (has_future) {
[10:58:43.229]                         ns <- base::getNamespace("future")
[10:58:43.229]                         version <- ns[[".package"]][["version"]]
[10:58:43.229]                         if (is.null(version)) 
[10:58:43.229]                           version <- utils::packageVersion("future")
[10:58:43.229]                       }
[10:58:43.229]                       else {
[10:58:43.229]                         version <- NULL
[10:58:43.229]                       }
[10:58:43.229]                       if (!has_future || version < "1.8.0") {
[10:58:43.229]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.229]                           "", base::R.version$version.string), 
[10:58:43.229]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.229]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.229]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.229]                             "release", "version")], collapse = " "), 
[10:58:43.229]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.229]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.229]                           info)
[10:58:43.229]                         info <- base::paste(info, collapse = "; ")
[10:58:43.229]                         if (!has_future) {
[10:58:43.229]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.229]                             info)
[10:58:43.229]                         }
[10:58:43.229]                         else {
[10:58:43.229]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.229]                             info, version)
[10:58:43.229]                         }
[10:58:43.229]                         base::stop(msg)
[10:58:43.229]                       }
[10:58:43.229]                     })
[10:58:43.229]                   }
[10:58:43.229]                   ...future.strategy.old <- future::plan("list")
[10:58:43.229]                   options(future.plan = NULL)
[10:58:43.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.229]                 }
[10:58:43.229]                 ...future.workdir <- getwd()
[10:58:43.229]             }
[10:58:43.229]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.229]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.229]         }
[10:58:43.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.229]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.229]             base::names(...future.oldOptions))
[10:58:43.229]     }
[10:58:43.229]     if (FALSE) {
[10:58:43.229]     }
[10:58:43.229]     else {
[10:58:43.229]         if (TRUE) {
[10:58:43.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.229]                 open = "w")
[10:58:43.229]         }
[10:58:43.229]         else {
[10:58:43.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.229]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.229]         }
[10:58:43.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.229]             base::sink(type = "output", split = FALSE)
[10:58:43.229]             base::close(...future.stdout)
[10:58:43.229]         }, add = TRUE)
[10:58:43.229]     }
[10:58:43.229]     ...future.frame <- base::sys.nframe()
[10:58:43.229]     ...future.conditions <- base::list()
[10:58:43.229]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.229]     if (FALSE) {
[10:58:43.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.229]     }
[10:58:43.229]     ...future.result <- base::tryCatch({
[10:58:43.229]         base::withCallingHandlers({
[10:58:43.229]             ...future.value <- base::withVisible(base::local({
[10:58:43.229]                 do.call(function(...) {
[10:58:43.229]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.229]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.229]                     ...future.globals.maxSize)) {
[10:58:43.229]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.229]                     on.exit(options(oopts), add = TRUE)
[10:58:43.229]                   }
[10:58:43.229]                   {
[10:58:43.229]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.229]                       FUN = function(jj) {
[10:58:43.229]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.229]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.229]                       })
[10:58:43.229]                   }
[10:58:43.229]                 }, args = future.call.arguments)
[10:58:43.229]             }))
[10:58:43.229]             future::FutureResult(value = ...future.value$value, 
[10:58:43.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.229]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.229]                     ...future.globalenv.names))
[10:58:43.229]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.229]         }, condition = base::local({
[10:58:43.229]             c <- base::c
[10:58:43.229]             inherits <- base::inherits
[10:58:43.229]             invokeRestart <- base::invokeRestart
[10:58:43.229]             length <- base::length
[10:58:43.229]             list <- base::list
[10:58:43.229]             seq.int <- base::seq.int
[10:58:43.229]             signalCondition <- base::signalCondition
[10:58:43.229]             sys.calls <- base::sys.calls
[10:58:43.229]             `[[` <- base::`[[`
[10:58:43.229]             `+` <- base::`+`
[10:58:43.229]             `<<-` <- base::`<<-`
[10:58:43.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.229]                   3L)]
[10:58:43.229]             }
[10:58:43.229]             function(cond) {
[10:58:43.229]                 is_error <- inherits(cond, "error")
[10:58:43.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.229]                   NULL)
[10:58:43.229]                 if (is_error) {
[10:58:43.229]                   sessionInformation <- function() {
[10:58:43.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.229]                       search = base::search(), system = base::Sys.info())
[10:58:43.229]                   }
[10:58:43.229]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.229]                     cond$call), session = sessionInformation(), 
[10:58:43.229]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.229]                   signalCondition(cond)
[10:58:43.229]                 }
[10:58:43.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.229]                 "immediateCondition"))) {
[10:58:43.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.229]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.229]                   if (TRUE && !signal) {
[10:58:43.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.229]                     {
[10:58:43.229]                       inherits <- base::inherits
[10:58:43.229]                       invokeRestart <- base::invokeRestart
[10:58:43.229]                       is.null <- base::is.null
[10:58:43.229]                       muffled <- FALSE
[10:58:43.229]                       if (inherits(cond, "message")) {
[10:58:43.229]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.229]                         if (muffled) 
[10:58:43.229]                           invokeRestart("muffleMessage")
[10:58:43.229]                       }
[10:58:43.229]                       else if (inherits(cond, "warning")) {
[10:58:43.229]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.229]                         if (muffled) 
[10:58:43.229]                           invokeRestart("muffleWarning")
[10:58:43.229]                       }
[10:58:43.229]                       else if (inherits(cond, "condition")) {
[10:58:43.229]                         if (!is.null(pattern)) {
[10:58:43.229]                           computeRestarts <- base::computeRestarts
[10:58:43.229]                           grepl <- base::grepl
[10:58:43.229]                           restarts <- computeRestarts(cond)
[10:58:43.229]                           for (restart in restarts) {
[10:58:43.229]                             name <- restart$name
[10:58:43.229]                             if (is.null(name)) 
[10:58:43.229]                               next
[10:58:43.229]                             if (!grepl(pattern, name)) 
[10:58:43.229]                               next
[10:58:43.229]                             invokeRestart(restart)
[10:58:43.229]                             muffled <- TRUE
[10:58:43.229]                             break
[10:58:43.229]                           }
[10:58:43.229]                         }
[10:58:43.229]                       }
[10:58:43.229]                       invisible(muffled)
[10:58:43.229]                     }
[10:58:43.229]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.229]                   }
[10:58:43.229]                 }
[10:58:43.229]                 else {
[10:58:43.229]                   if (TRUE) {
[10:58:43.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.229]                     {
[10:58:43.229]                       inherits <- base::inherits
[10:58:43.229]                       invokeRestart <- base::invokeRestart
[10:58:43.229]                       is.null <- base::is.null
[10:58:43.229]                       muffled <- FALSE
[10:58:43.229]                       if (inherits(cond, "message")) {
[10:58:43.229]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.229]                         if (muffled) 
[10:58:43.229]                           invokeRestart("muffleMessage")
[10:58:43.229]                       }
[10:58:43.229]                       else if (inherits(cond, "warning")) {
[10:58:43.229]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.229]                         if (muffled) 
[10:58:43.229]                           invokeRestart("muffleWarning")
[10:58:43.229]                       }
[10:58:43.229]                       else if (inherits(cond, "condition")) {
[10:58:43.229]                         if (!is.null(pattern)) {
[10:58:43.229]                           computeRestarts <- base::computeRestarts
[10:58:43.229]                           grepl <- base::grepl
[10:58:43.229]                           restarts <- computeRestarts(cond)
[10:58:43.229]                           for (restart in restarts) {
[10:58:43.229]                             name <- restart$name
[10:58:43.229]                             if (is.null(name)) 
[10:58:43.229]                               next
[10:58:43.229]                             if (!grepl(pattern, name)) 
[10:58:43.229]                               next
[10:58:43.229]                             invokeRestart(restart)
[10:58:43.229]                             muffled <- TRUE
[10:58:43.229]                             break
[10:58:43.229]                           }
[10:58:43.229]                         }
[10:58:43.229]                       }
[10:58:43.229]                       invisible(muffled)
[10:58:43.229]                     }
[10:58:43.229]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.229]                   }
[10:58:43.229]                 }
[10:58:43.229]             }
[10:58:43.229]         }))
[10:58:43.229]     }, error = function(ex) {
[10:58:43.229]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.229]                 ...future.rng), started = ...future.startTime, 
[10:58:43.229]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.229]             version = "1.8"), class = "FutureResult")
[10:58:43.229]     }, finally = {
[10:58:43.229]         if (!identical(...future.workdir, getwd())) 
[10:58:43.229]             setwd(...future.workdir)
[10:58:43.229]         {
[10:58:43.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.229]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.229]             }
[10:58:43.229]             base::options(...future.oldOptions)
[10:58:43.229]             if (.Platform$OS.type == "windows") {
[10:58:43.229]                 old_names <- names(...future.oldEnvVars)
[10:58:43.229]                 envs <- base::Sys.getenv()
[10:58:43.229]                 names <- names(envs)
[10:58:43.229]                 common <- intersect(names, old_names)
[10:58:43.229]                 added <- setdiff(names, old_names)
[10:58:43.229]                 removed <- setdiff(old_names, names)
[10:58:43.229]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.229]                   envs[common]]
[10:58:43.229]                 NAMES <- toupper(changed)
[10:58:43.229]                 args <- list()
[10:58:43.229]                 for (kk in seq_along(NAMES)) {
[10:58:43.229]                   name <- changed[[kk]]
[10:58:43.229]                   NAME <- NAMES[[kk]]
[10:58:43.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.229]                     next
[10:58:43.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.229]                 }
[10:58:43.229]                 NAMES <- toupper(added)
[10:58:43.229]                 for (kk in seq_along(NAMES)) {
[10:58:43.229]                   name <- added[[kk]]
[10:58:43.229]                   NAME <- NAMES[[kk]]
[10:58:43.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.229]                     next
[10:58:43.229]                   args[[name]] <- ""
[10:58:43.229]                 }
[10:58:43.229]                 NAMES <- toupper(removed)
[10:58:43.229]                 for (kk in seq_along(NAMES)) {
[10:58:43.229]                   name <- removed[[kk]]
[10:58:43.229]                   NAME <- NAMES[[kk]]
[10:58:43.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.229]                     next
[10:58:43.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.229]                 }
[10:58:43.229]                 if (length(args) > 0) 
[10:58:43.229]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.229]             }
[10:58:43.229]             else {
[10:58:43.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.229]             }
[10:58:43.229]             {
[10:58:43.229]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.229]                   0L) {
[10:58:43.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.229]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.229]                   base::options(opts)
[10:58:43.229]                 }
[10:58:43.229]                 {
[10:58:43.229]                   {
[10:58:43.229]                     NULL
[10:58:43.229]                     RNGkind("Mersenne-Twister")
[10:58:43.229]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.229]                       inherits = FALSE)
[10:58:43.229]                   }
[10:58:43.229]                   options(future.plan = NULL)
[10:58:43.229]                   if (is.na(NA_character_)) 
[10:58:43.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.229]                     .init = FALSE)
[10:58:43.229]                 }
[10:58:43.229]             }
[10:58:43.229]         }
[10:58:43.229]     })
[10:58:43.229]     if (TRUE) {
[10:58:43.229]         base::sink(type = "output", split = FALSE)
[10:58:43.229]         if (TRUE) {
[10:58:43.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.229]         }
[10:58:43.229]         else {
[10:58:43.229]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.229]         }
[10:58:43.229]         base::close(...future.stdout)
[10:58:43.229]         ...future.stdout <- NULL
[10:58:43.229]     }
[10:58:43.229]     ...future.result$conditions <- ...future.conditions
[10:58:43.229]     ...future.result$finished <- base::Sys.time()
[10:58:43.229]     ...future.result
[10:58:43.229] }
[10:58:43.231] assign_globals() ...
[10:58:43.231] List of 5
[10:58:43.231]  $ ...future.FUN            :function (object, ...)  
[10:58:43.231]  $ future.call.arguments    : list()
[10:58:43.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.231]  $ ...future.elements_ii    :List of 3
[10:58:43.231]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.231]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.231]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.231]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.231]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.231]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.231]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.231]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.231]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.231]  $ ...future.seeds_ii       : NULL
[10:58:43.231]  $ ...future.globals.maxSize: NULL
[10:58:43.231]  - attr(*, "where")=List of 5
[10:58:43.231]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.231]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.231]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.231]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.231]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.231]  - attr(*, "resolved")= logi FALSE
[10:58:43.231]  - attr(*, "total_size")= num 15670
[10:58:43.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.231]  - attr(*, "already-done")= logi TRUE
[10:58:43.238] - copied ‘...future.FUN’ to environment
[10:58:43.239] - copied ‘future.call.arguments’ to environment
[10:58:43.239] - copied ‘...future.elements_ii’ to environment
[10:58:43.239] - copied ‘...future.seeds_ii’ to environment
[10:58:43.239] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.239] assign_globals() ... done
[10:58:43.239] plan(): Setting new future strategy stack:
[10:58:43.239] List of future strategies:
[10:58:43.239] 1. sequential:
[10:58:43.239]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.239]    - tweaked: FALSE
[10:58:43.239]    - call: NULL
[10:58:43.240] plan(): nbrOfWorkers() = 1
[10:58:43.241] plan(): Setting new future strategy stack:
[10:58:43.241] List of future strategies:
[10:58:43.241] 1. multisession:
[10:58:43.241]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.241]    - tweaked: FALSE
[10:58:43.241]    - call: plan(strategy)
[10:58:43.243] plan(): nbrOfWorkers() = 1
[10:58:43.243] SequentialFuture started (and completed)
[10:58:43.243] - Launch lazy future ... done
[10:58:43.243] run() for ‘SequentialFuture’ ... done
[10:58:43.243] Created future:
[10:58:43.243] SequentialFuture:
[10:58:43.243] Label: ‘future_by-1’
[10:58:43.243] Expression:
[10:58:43.243] {
[10:58:43.243]     do.call(function(...) {
[10:58:43.243]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.243]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.243]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.243]             on.exit(options(oopts), add = TRUE)
[10:58:43.243]         }
[10:58:43.243]         {
[10:58:43.243]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.243]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.243]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.243]             })
[10:58:43.243]         }
[10:58:43.243]     }, args = future.call.arguments)
[10:58:43.243] }
[10:58:43.243] Lazy evaluation: FALSE
[10:58:43.243] Asynchronous evaluation: FALSE
[10:58:43.243] Local evaluation: TRUE
[10:58:43.243] Environment: R_GlobalEnv
[10:58:43.243] Capture standard output: TRUE
[10:58:43.243] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.243] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.243] Packages: <none>
[10:58:43.243] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.243] Resolved: TRUE
[10:58:43.243] Value: 1.16 KiB of class ‘list’
[10:58:43.243] Early signaling: FALSE
[10:58:43.243] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.243] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.244] Chunk #1 of 1 ... DONE
[10:58:43.244] Launching 1 futures (chunks) ... DONE
[10:58:43.244] Resolving 1 futures (chunks) ...
[10:58:43.244] resolve() on list ...
[10:58:43.244]  recursive: 0
[10:58:43.244]  length: 1
[10:58:43.245] 
[10:58:43.245] resolved() for ‘SequentialFuture’ ...
[10:58:43.245] - state: ‘finished’
[10:58:43.245] - run: TRUE
[10:58:43.245] - result: ‘FutureResult’
[10:58:43.245] resolved() for ‘SequentialFuture’ ... done
[10:58:43.245] Future #1
[10:58:43.245] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.245] - nx: 1
[10:58:43.245] - relay: TRUE
[10:58:43.245] - stdout: TRUE
[10:58:43.245] - signal: TRUE
[10:58:43.246] - resignal: FALSE
[10:58:43.246] - force: TRUE
[10:58:43.246] - relayed: [n=1] FALSE
[10:58:43.246] - queued futures: [n=1] FALSE
[10:58:43.246]  - until=1
[10:58:43.246]  - relaying element #1
[10:58:43.246] - relayed: [n=1] TRUE
[10:58:43.246] - queued futures: [n=1] TRUE
[10:58:43.246] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.246]  length: 0 (resolved future 1)
[10:58:43.246] Relaying remaining futures
[10:58:43.246] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.247] - nx: 1
[10:58:43.247] - relay: TRUE
[10:58:43.247] - stdout: TRUE
[10:58:43.247] - signal: TRUE
[10:58:43.247] - resignal: FALSE
[10:58:43.247] - force: TRUE
[10:58:43.247] - relayed: [n=1] TRUE
[10:58:43.247] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.247] - relayed: [n=1] TRUE
[10:58:43.247] - queued futures: [n=1] TRUE
[10:58:43.247] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.247] resolve() on list ... DONE
[10:58:43.248]  - Number of value chunks collected: 1
[10:58:43.248] Resolving 1 futures (chunks) ... DONE
[10:58:43.248] Reducing values from 1 chunks ...
[10:58:43.248]  - Number of values collected after concatenation: 3
[10:58:43.248]  - Number of values expected: 3
[10:58:43.248] Reducing values from 1 chunks ... DONE
[10:58:43.248] future_lapply() ... DONE
[10:58:43.248] future_by_internal() ... DONE
[10:58:43.248] future_by_internal() ...
[10:58:43.249] future_lapply() ...
[10:58:43.250] Number of chunks: 1
[10:58:43.250] getGlobalsAndPackagesXApply() ...
[10:58:43.250]  - future.globals: TRUE
[10:58:43.250] getGlobalsAndPackages() ...
[10:58:43.250] Searching for globals...
[10:58:43.251] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.251] Searching for globals ... DONE
[10:58:43.252] Resolving globals: FALSE
[10:58:43.253] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.253] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.253] - globals: [1] ‘FUN’
[10:58:43.253] 
[10:58:43.253] getGlobalsAndPackages() ... DONE
[10:58:43.253]  - globals found/used: [n=1] ‘FUN’
[10:58:43.253]  - needed namespaces: [n=0] 
[10:58:43.253] Finding globals ... DONE
[10:58:43.254]  - use_args: TRUE
[10:58:43.254]  - Getting '...' globals ...
[10:58:43.254] resolve() on list ...
[10:58:43.254]  recursive: 0
[10:58:43.254]  length: 1
[10:58:43.254]  elements: ‘...’
[10:58:43.254]  length: 0 (resolved future 1)
[10:58:43.254] resolve() on list ... DONE
[10:58:43.254]    - '...' content: [n=1] ‘digits’
[10:58:43.254] List of 1
[10:58:43.254]  $ ...:List of 1
[10:58:43.254]   ..$ digits: int 2
[10:58:43.254]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.254]  - attr(*, "where")=List of 1
[10:58:43.254]   ..$ ...:<environment: 0x55974de19130> 
[10:58:43.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.254]  - attr(*, "resolved")= logi TRUE
[10:58:43.254]  - attr(*, "total_size")= num NA
[10:58:43.257]  - Getting '...' globals ... DONE
[10:58:43.257] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.257] List of 2
[10:58:43.257]  $ ...future.FUN:function (object, ...)  
[10:58:43.257]  $ ...          :List of 1
[10:58:43.257]   ..$ digits: int 2
[10:58:43.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.257]  - attr(*, "where")=List of 2
[10:58:43.257]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.257]   ..$ ...          :<environment: 0x55974de19130> 
[10:58:43.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.257]  - attr(*, "resolved")= logi FALSE
[10:58:43.257]  - attr(*, "total_size")= num 13284
[10:58:43.260] Packages to be attached in all futures: [n=0] 
[10:58:43.260] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.260] Number of futures (= number of chunks): 1
[10:58:43.261] Launching 1 futures (chunks) ...
[10:58:43.261] Chunk #1 of 1 ...
[10:58:43.261]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.261] getGlobalsAndPackages() ...
[10:58:43.261] Searching for globals...
[10:58:43.261] 
[10:58:43.261] Searching for globals ... DONE
[10:58:43.261] - globals: [0] <none>
[10:58:43.261] getGlobalsAndPackages() ... DONE
[10:58:43.261]    + additional globals found: [n=0] 
[10:58:43.262]    + additional namespaces needed: [n=0] 
[10:58:43.262]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.262]  - seeds: <none>
[10:58:43.262]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.262] getGlobalsAndPackages() ...
[10:58:43.262] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.262] Resolving globals: FALSE
[10:58:43.262] Tweak future expression to call with '...' arguments ...
[10:58:43.262] {
[10:58:43.262]     do.call(function(...) {
[10:58:43.262]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.262]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.262]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.262]             on.exit(options(oopts), add = TRUE)
[10:58:43.262]         }
[10:58:43.262]         {
[10:58:43.262]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.262]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.262]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.262]             })
[10:58:43.262]         }
[10:58:43.262]     }, args = future.call.arguments)
[10:58:43.262] }
[10:58:43.263] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.263] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.263] 
[10:58:43.263] getGlobalsAndPackages() ... DONE
[10:58:43.263] run() for ‘Future’ ...
[10:58:43.263] - state: ‘created’
[10:58:43.264] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.265] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.265]   - Field: ‘label’
[10:58:43.265]   - Field: ‘local’
[10:58:43.265]   - Field: ‘owner’
[10:58:43.265]   - Field: ‘envir’
[10:58:43.266]   - Field: ‘packages’
[10:58:43.266]   - Field: ‘gc’
[10:58:43.266]   - Field: ‘conditions’
[10:58:43.266]   - Field: ‘expr’
[10:58:43.266]   - Field: ‘uuid’
[10:58:43.266]   - Field: ‘seed’
[10:58:43.266]   - Field: ‘version’
[10:58:43.266]   - Field: ‘result’
[10:58:43.266]   - Field: ‘asynchronous’
[10:58:43.266]   - Field: ‘calls’
[10:58:43.266]   - Field: ‘globals’
[10:58:43.266]   - Field: ‘stdout’
[10:58:43.267]   - Field: ‘earlySignal’
[10:58:43.267]   - Field: ‘lazy’
[10:58:43.267]   - Field: ‘state’
[10:58:43.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.267] - Launch lazy future ...
[10:58:43.267] Packages needed by the future expression (n = 0): <none>
[10:58:43.267] Packages needed by future strategies (n = 0): <none>
[10:58:43.268] {
[10:58:43.268]     {
[10:58:43.268]         {
[10:58:43.268]             ...future.startTime <- base::Sys.time()
[10:58:43.268]             {
[10:58:43.268]                 {
[10:58:43.268]                   {
[10:58:43.268]                     base::local({
[10:58:43.268]                       has_future <- base::requireNamespace("future", 
[10:58:43.268]                         quietly = TRUE)
[10:58:43.268]                       if (has_future) {
[10:58:43.268]                         ns <- base::getNamespace("future")
[10:58:43.268]                         version <- ns[[".package"]][["version"]]
[10:58:43.268]                         if (is.null(version)) 
[10:58:43.268]                           version <- utils::packageVersion("future")
[10:58:43.268]                       }
[10:58:43.268]                       else {
[10:58:43.268]                         version <- NULL
[10:58:43.268]                       }
[10:58:43.268]                       if (!has_future || version < "1.8.0") {
[10:58:43.268]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.268]                           "", base::R.version$version.string), 
[10:58:43.268]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.268]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.268]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.268]                             "release", "version")], collapse = " "), 
[10:58:43.268]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.268]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.268]                           info)
[10:58:43.268]                         info <- base::paste(info, collapse = "; ")
[10:58:43.268]                         if (!has_future) {
[10:58:43.268]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.268]                             info)
[10:58:43.268]                         }
[10:58:43.268]                         else {
[10:58:43.268]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.268]                             info, version)
[10:58:43.268]                         }
[10:58:43.268]                         base::stop(msg)
[10:58:43.268]                       }
[10:58:43.268]                     })
[10:58:43.268]                   }
[10:58:43.268]                   ...future.strategy.old <- future::plan("list")
[10:58:43.268]                   options(future.plan = NULL)
[10:58:43.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.268]                 }
[10:58:43.268]                 ...future.workdir <- getwd()
[10:58:43.268]             }
[10:58:43.268]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.268]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.268]         }
[10:58:43.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.268]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.268]             base::names(...future.oldOptions))
[10:58:43.268]     }
[10:58:43.268]     if (FALSE) {
[10:58:43.268]     }
[10:58:43.268]     else {
[10:58:43.268]         if (TRUE) {
[10:58:43.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.268]                 open = "w")
[10:58:43.268]         }
[10:58:43.268]         else {
[10:58:43.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.268]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.268]         }
[10:58:43.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.268]             base::sink(type = "output", split = FALSE)
[10:58:43.268]             base::close(...future.stdout)
[10:58:43.268]         }, add = TRUE)
[10:58:43.268]     }
[10:58:43.268]     ...future.frame <- base::sys.nframe()
[10:58:43.268]     ...future.conditions <- base::list()
[10:58:43.268]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.268]     if (FALSE) {
[10:58:43.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.268]     }
[10:58:43.268]     ...future.result <- base::tryCatch({
[10:58:43.268]         base::withCallingHandlers({
[10:58:43.268]             ...future.value <- base::withVisible(base::local({
[10:58:43.268]                 do.call(function(...) {
[10:58:43.268]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.268]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.268]                     ...future.globals.maxSize)) {
[10:58:43.268]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.268]                     on.exit(options(oopts), add = TRUE)
[10:58:43.268]                   }
[10:58:43.268]                   {
[10:58:43.268]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.268]                       FUN = function(jj) {
[10:58:43.268]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.268]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.268]                       })
[10:58:43.268]                   }
[10:58:43.268]                 }, args = future.call.arguments)
[10:58:43.268]             }))
[10:58:43.268]             future::FutureResult(value = ...future.value$value, 
[10:58:43.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.268]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.268]                     ...future.globalenv.names))
[10:58:43.268]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.268]         }, condition = base::local({
[10:58:43.268]             c <- base::c
[10:58:43.268]             inherits <- base::inherits
[10:58:43.268]             invokeRestart <- base::invokeRestart
[10:58:43.268]             length <- base::length
[10:58:43.268]             list <- base::list
[10:58:43.268]             seq.int <- base::seq.int
[10:58:43.268]             signalCondition <- base::signalCondition
[10:58:43.268]             sys.calls <- base::sys.calls
[10:58:43.268]             `[[` <- base::`[[`
[10:58:43.268]             `+` <- base::`+`
[10:58:43.268]             `<<-` <- base::`<<-`
[10:58:43.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.268]                   3L)]
[10:58:43.268]             }
[10:58:43.268]             function(cond) {
[10:58:43.268]                 is_error <- inherits(cond, "error")
[10:58:43.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.268]                   NULL)
[10:58:43.268]                 if (is_error) {
[10:58:43.268]                   sessionInformation <- function() {
[10:58:43.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.268]                       search = base::search(), system = base::Sys.info())
[10:58:43.268]                   }
[10:58:43.268]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.268]                     cond$call), session = sessionInformation(), 
[10:58:43.268]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.268]                   signalCondition(cond)
[10:58:43.268]                 }
[10:58:43.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.268]                 "immediateCondition"))) {
[10:58:43.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.268]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.268]                   if (TRUE && !signal) {
[10:58:43.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.268]                     {
[10:58:43.268]                       inherits <- base::inherits
[10:58:43.268]                       invokeRestart <- base::invokeRestart
[10:58:43.268]                       is.null <- base::is.null
[10:58:43.268]                       muffled <- FALSE
[10:58:43.268]                       if (inherits(cond, "message")) {
[10:58:43.268]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.268]                         if (muffled) 
[10:58:43.268]                           invokeRestart("muffleMessage")
[10:58:43.268]                       }
[10:58:43.268]                       else if (inherits(cond, "warning")) {
[10:58:43.268]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.268]                         if (muffled) 
[10:58:43.268]                           invokeRestart("muffleWarning")
[10:58:43.268]                       }
[10:58:43.268]                       else if (inherits(cond, "condition")) {
[10:58:43.268]                         if (!is.null(pattern)) {
[10:58:43.268]                           computeRestarts <- base::computeRestarts
[10:58:43.268]                           grepl <- base::grepl
[10:58:43.268]                           restarts <- computeRestarts(cond)
[10:58:43.268]                           for (restart in restarts) {
[10:58:43.268]                             name <- restart$name
[10:58:43.268]                             if (is.null(name)) 
[10:58:43.268]                               next
[10:58:43.268]                             if (!grepl(pattern, name)) 
[10:58:43.268]                               next
[10:58:43.268]                             invokeRestart(restart)
[10:58:43.268]                             muffled <- TRUE
[10:58:43.268]                             break
[10:58:43.268]                           }
[10:58:43.268]                         }
[10:58:43.268]                       }
[10:58:43.268]                       invisible(muffled)
[10:58:43.268]                     }
[10:58:43.268]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.268]                   }
[10:58:43.268]                 }
[10:58:43.268]                 else {
[10:58:43.268]                   if (TRUE) {
[10:58:43.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.268]                     {
[10:58:43.268]                       inherits <- base::inherits
[10:58:43.268]                       invokeRestart <- base::invokeRestart
[10:58:43.268]                       is.null <- base::is.null
[10:58:43.268]                       muffled <- FALSE
[10:58:43.268]                       if (inherits(cond, "message")) {
[10:58:43.268]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.268]                         if (muffled) 
[10:58:43.268]                           invokeRestart("muffleMessage")
[10:58:43.268]                       }
[10:58:43.268]                       else if (inherits(cond, "warning")) {
[10:58:43.268]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.268]                         if (muffled) 
[10:58:43.268]                           invokeRestart("muffleWarning")
[10:58:43.268]                       }
[10:58:43.268]                       else if (inherits(cond, "condition")) {
[10:58:43.268]                         if (!is.null(pattern)) {
[10:58:43.268]                           computeRestarts <- base::computeRestarts
[10:58:43.268]                           grepl <- base::grepl
[10:58:43.268]                           restarts <- computeRestarts(cond)
[10:58:43.268]                           for (restart in restarts) {
[10:58:43.268]                             name <- restart$name
[10:58:43.268]                             if (is.null(name)) 
[10:58:43.268]                               next
[10:58:43.268]                             if (!grepl(pattern, name)) 
[10:58:43.268]                               next
[10:58:43.268]                             invokeRestart(restart)
[10:58:43.268]                             muffled <- TRUE
[10:58:43.268]                             break
[10:58:43.268]                           }
[10:58:43.268]                         }
[10:58:43.268]                       }
[10:58:43.268]                       invisible(muffled)
[10:58:43.268]                     }
[10:58:43.268]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.268]                   }
[10:58:43.268]                 }
[10:58:43.268]             }
[10:58:43.268]         }))
[10:58:43.268]     }, error = function(ex) {
[10:58:43.268]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.268]                 ...future.rng), started = ...future.startTime, 
[10:58:43.268]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.268]             version = "1.8"), class = "FutureResult")
[10:58:43.268]     }, finally = {
[10:58:43.268]         if (!identical(...future.workdir, getwd())) 
[10:58:43.268]             setwd(...future.workdir)
[10:58:43.268]         {
[10:58:43.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.268]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.268]             }
[10:58:43.268]             base::options(...future.oldOptions)
[10:58:43.268]             if (.Platform$OS.type == "windows") {
[10:58:43.268]                 old_names <- names(...future.oldEnvVars)
[10:58:43.268]                 envs <- base::Sys.getenv()
[10:58:43.268]                 names <- names(envs)
[10:58:43.268]                 common <- intersect(names, old_names)
[10:58:43.268]                 added <- setdiff(names, old_names)
[10:58:43.268]                 removed <- setdiff(old_names, names)
[10:58:43.268]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.268]                   envs[common]]
[10:58:43.268]                 NAMES <- toupper(changed)
[10:58:43.268]                 args <- list()
[10:58:43.268]                 for (kk in seq_along(NAMES)) {
[10:58:43.268]                   name <- changed[[kk]]
[10:58:43.268]                   NAME <- NAMES[[kk]]
[10:58:43.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.268]                     next
[10:58:43.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.268]                 }
[10:58:43.268]                 NAMES <- toupper(added)
[10:58:43.268]                 for (kk in seq_along(NAMES)) {
[10:58:43.268]                   name <- added[[kk]]
[10:58:43.268]                   NAME <- NAMES[[kk]]
[10:58:43.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.268]                     next
[10:58:43.268]                   args[[name]] <- ""
[10:58:43.268]                 }
[10:58:43.268]                 NAMES <- toupper(removed)
[10:58:43.268]                 for (kk in seq_along(NAMES)) {
[10:58:43.268]                   name <- removed[[kk]]
[10:58:43.268]                   NAME <- NAMES[[kk]]
[10:58:43.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.268]                     next
[10:58:43.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.268]                 }
[10:58:43.268]                 if (length(args) > 0) 
[10:58:43.268]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.268]             }
[10:58:43.268]             else {
[10:58:43.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.268]             }
[10:58:43.268]             {
[10:58:43.268]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.268]                   0L) {
[10:58:43.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.268]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.268]                   base::options(opts)
[10:58:43.268]                 }
[10:58:43.268]                 {
[10:58:43.268]                   {
[10:58:43.268]                     NULL
[10:58:43.268]                     RNGkind("Mersenne-Twister")
[10:58:43.268]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.268]                       inherits = FALSE)
[10:58:43.268]                   }
[10:58:43.268]                   options(future.plan = NULL)
[10:58:43.268]                   if (is.na(NA_character_)) 
[10:58:43.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.268]                     .init = FALSE)
[10:58:43.268]                 }
[10:58:43.268]             }
[10:58:43.268]         }
[10:58:43.268]     })
[10:58:43.268]     if (TRUE) {
[10:58:43.268]         base::sink(type = "output", split = FALSE)
[10:58:43.268]         if (TRUE) {
[10:58:43.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.268]         }
[10:58:43.268]         else {
[10:58:43.268]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.268]         }
[10:58:43.268]         base::close(...future.stdout)
[10:58:43.268]         ...future.stdout <- NULL
[10:58:43.268]     }
[10:58:43.268]     ...future.result$conditions <- ...future.conditions
[10:58:43.268]     ...future.result$finished <- base::Sys.time()
[10:58:43.268]     ...future.result
[10:58:43.268] }
[10:58:43.269] assign_globals() ...
[10:58:43.269] List of 5
[10:58:43.269]  $ ...future.FUN            :function (object, ...)  
[10:58:43.269]  $ future.call.arguments    :List of 1
[10:58:43.269]   ..$ digits: int 2
[10:58:43.269]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.269]  $ ...future.elements_ii    :List of 6
[10:58:43.269]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:58:43.269]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:58:43.269]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:58:43.269]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:58:43.269]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:58:43.269]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:58:43.269]  $ ...future.seeds_ii       : NULL
[10:58:43.269]  $ ...future.globals.maxSize: NULL
[10:58:43.269]  - attr(*, "where")=List of 5
[10:58:43.269]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.269]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.269]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.269]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.269]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.269]  - attr(*, "resolved")= logi FALSE
[10:58:43.269]  - attr(*, "total_size")= num 13284
[10:58:43.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.269]  - attr(*, "already-done")= logi TRUE
[10:58:43.278] - copied ‘...future.FUN’ to environment
[10:58:43.278] - copied ‘future.call.arguments’ to environment
[10:58:43.278] - copied ‘...future.elements_ii’ to environment
[10:58:43.278] - copied ‘...future.seeds_ii’ to environment
[10:58:43.278] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.279] assign_globals() ... done
[10:58:43.279] plan(): Setting new future strategy stack:
[10:58:43.279] List of future strategies:
[10:58:43.279] 1. sequential:
[10:58:43.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.279]    - tweaked: FALSE
[10:58:43.279]    - call: NULL
[10:58:43.279] plan(): nbrOfWorkers() = 1
[10:58:43.281] plan(): Setting new future strategy stack:
[10:58:43.281] List of future strategies:
[10:58:43.281] 1. multisession:
[10:58:43.281]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.281]    - tweaked: FALSE
[10:58:43.281]    - call: plan(strategy)
[10:58:43.282] plan(): nbrOfWorkers() = 1
[10:58:43.283] SequentialFuture started (and completed)
[10:58:43.283] - Launch lazy future ... done
[10:58:43.283] run() for ‘SequentialFuture’ ... done
[10:58:43.283] Created future:
[10:58:43.283] SequentialFuture:
[10:58:43.283] Label: ‘future_by-1’
[10:58:43.283] Expression:
[10:58:43.283] {
[10:58:43.283]     do.call(function(...) {
[10:58:43.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.283]             on.exit(options(oopts), add = TRUE)
[10:58:43.283]         }
[10:58:43.283]         {
[10:58:43.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.283]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.283]             })
[10:58:43.283]         }
[10:58:43.283]     }, args = future.call.arguments)
[10:58:43.283] }
[10:58:43.283] Lazy evaluation: FALSE
[10:58:43.283] Asynchronous evaluation: FALSE
[10:58:43.283] Local evaluation: TRUE
[10:58:43.283] Environment: R_GlobalEnv
[10:58:43.283] Capture standard output: TRUE
[10:58:43.283] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.283] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.283] Packages: <none>
[10:58:43.283] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.283] Resolved: TRUE
[10:58:43.283] Value: 1.27 KiB of class ‘list’
[10:58:43.283] Early signaling: FALSE
[10:58:43.283] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.283] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.284] Chunk #1 of 1 ... DONE
[10:58:43.284] Launching 1 futures (chunks) ... DONE
[10:58:43.284] Resolving 1 futures (chunks) ...
[10:58:43.284] resolve() on list ...
[10:58:43.284]  recursive: 0
[10:58:43.284]  length: 1
[10:58:43.285] 
[10:58:43.285] resolved() for ‘SequentialFuture’ ...
[10:58:43.285] - state: ‘finished’
[10:58:43.285] - run: TRUE
[10:58:43.285] - result: ‘FutureResult’
[10:58:43.285] resolved() for ‘SequentialFuture’ ... done
[10:58:43.285] Future #1
[10:58:43.285] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.285] - nx: 1
[10:58:43.286] - relay: TRUE
[10:58:43.286] - stdout: TRUE
[10:58:43.286] - signal: TRUE
[10:58:43.286] - resignal: FALSE
[10:58:43.286] - force: TRUE
[10:58:43.286] - relayed: [n=1] FALSE
[10:58:43.286] - queued futures: [n=1] FALSE
[10:58:43.286]  - until=1
[10:58:43.286]  - relaying element #1
[10:58:43.286] - relayed: [n=1] TRUE
[10:58:43.286] - queued futures: [n=1] TRUE
[10:58:43.287] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.287]  length: 0 (resolved future 1)
[10:58:43.287] Relaying remaining futures
[10:58:43.287] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.287] - nx: 1
[10:58:43.287] - relay: TRUE
[10:58:43.287] - stdout: TRUE
[10:58:43.287] - signal: TRUE
[10:58:43.287] - resignal: FALSE
[10:58:43.287] - force: TRUE
[10:58:43.287] - relayed: [n=1] TRUE
[10:58:43.287] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.288] - relayed: [n=1] TRUE
[10:58:43.288] - queued futures: [n=1] TRUE
[10:58:43.288] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.288] resolve() on list ... DONE
[10:58:43.288]  - Number of value chunks collected: 1
[10:58:43.288] Resolving 1 futures (chunks) ... DONE
[10:58:43.288] Reducing values from 1 chunks ...
[10:58:43.288]  - Number of values collected after concatenation: 6
[10:58:43.288]  - Number of values expected: 6
[10:58:43.288] Reducing values from 1 chunks ... DONE
[10:58:43.288] future_lapply() ... DONE
[10:58:43.289] future_by_internal() ... DONE
[10:58:43.290] future_by_internal() ...
[10:58:43.290] future_lapply() ...
[10:58:43.292] Number of chunks: 1
[10:58:43.292] getGlobalsAndPackagesXApply() ...
[10:58:43.292]  - future.globals: TRUE
[10:58:43.292] getGlobalsAndPackages() ...
[10:58:43.292] Searching for globals...
[10:58:43.295] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:43.296] Searching for globals ... DONE
[10:58:43.296] Resolving globals: FALSE
[10:58:43.296] The total size of the 1 globals is 762 bytes (762 bytes)
[10:58:43.296] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:58:43.297] - globals: [1] ‘FUN’
[10:58:43.297] - packages: [1] ‘stats’
[10:58:43.297] getGlobalsAndPackages() ... DONE
[10:58:43.297]  - globals found/used: [n=1] ‘FUN’
[10:58:43.297]  - needed namespaces: [n=1] ‘stats’
[10:58:43.297] Finding globals ... DONE
[10:58:43.297]  - use_args: TRUE
[10:58:43.297]  - Getting '...' globals ...
[10:58:43.298] resolve() on list ...
[10:58:43.298]  recursive: 0
[10:58:43.298]  length: 1
[10:58:43.298]  elements: ‘...’
[10:58:43.298]  length: 0 (resolved future 1)
[10:58:43.298] resolve() on list ... DONE
[10:58:43.298]    - '...' content: [n=1] ‘singular.ok’
[10:58:43.298] List of 1
[10:58:43.298]  $ ...:List of 1
[10:58:43.298]   ..$ singular.ok: logi FALSE
[10:58:43.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.298]  - attr(*, "where")=List of 1
[10:58:43.298]   ..$ ...:<environment: 0x55974dd0bdc8> 
[10:58:43.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.298]  - attr(*, "resolved")= logi TRUE
[10:58:43.298]  - attr(*, "total_size")= num NA
[10:58:43.301]  - Getting '...' globals ... DONE
[10:58:43.301] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.301] List of 2
[10:58:43.301]  $ ...future.FUN:function (x, ...)  
[10:58:43.301]  $ ...          :List of 1
[10:58:43.301]   ..$ singular.ok: logi FALSE
[10:58:43.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.301]  - attr(*, "where")=List of 2
[10:58:43.301]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.301]   ..$ ...          :<environment: 0x55974dd0bdc8> 
[10:58:43.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.301]  - attr(*, "resolved")= logi FALSE
[10:58:43.301]  - attr(*, "total_size")= num 19977
[10:58:43.304] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:43.305] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.305] Number of futures (= number of chunks): 1
[10:58:43.305] Launching 1 futures (chunks) ...
[10:58:43.305] Chunk #1 of 1 ...
[10:58:43.305]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.305] getGlobalsAndPackages() ...
[10:58:43.305] Searching for globals...
[10:58:43.306] 
[10:58:43.306] Searching for globals ... DONE
[10:58:43.306] - globals: [0] <none>
[10:58:43.306] getGlobalsAndPackages() ... DONE
[10:58:43.306]    + additional globals found: [n=0] 
[10:58:43.306]    + additional namespaces needed: [n=0] 
[10:58:43.306]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.306]  - seeds: <none>
[10:58:43.306]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.306] getGlobalsAndPackages() ...
[10:58:43.307] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.307] Resolving globals: FALSE
[10:58:43.307] Tweak future expression to call with '...' arguments ...
[10:58:43.307] {
[10:58:43.307]     do.call(function(...) {
[10:58:43.307]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.307]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.307]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.307]             on.exit(options(oopts), add = TRUE)
[10:58:43.307]         }
[10:58:43.307]         {
[10:58:43.307]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.307]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.307]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.307]             })
[10:58:43.307]         }
[10:58:43.307]     }, args = future.call.arguments)
[10:58:43.307] }
[10:58:43.307] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.307] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.308] 
[10:58:43.308] getGlobalsAndPackages() ... DONE
[10:58:43.308] run() for ‘Future’ ...
[10:58:43.308] - state: ‘created’
[10:58:43.308] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.310] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.310]   - Field: ‘label’
[10:58:43.310]   - Field: ‘local’
[10:58:43.310]   - Field: ‘owner’
[10:58:43.310]   - Field: ‘envir’
[10:58:43.310]   - Field: ‘packages’
[10:58:43.310]   - Field: ‘gc’
[10:58:43.310]   - Field: ‘conditions’
[10:58:43.310]   - Field: ‘expr’
[10:58:43.311]   - Field: ‘uuid’
[10:58:43.311]   - Field: ‘seed’
[10:58:43.311]   - Field: ‘version’
[10:58:43.311]   - Field: ‘result’
[10:58:43.311]   - Field: ‘asynchronous’
[10:58:43.311]   - Field: ‘calls’
[10:58:43.311]   - Field: ‘globals’
[10:58:43.311]   - Field: ‘stdout’
[10:58:43.311]   - Field: ‘earlySignal’
[10:58:43.311]   - Field: ‘lazy’
[10:58:43.311]   - Field: ‘state’
[10:58:43.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.312] - Launch lazy future ...
[10:58:43.312] Packages needed by the future expression (n = 1): ‘stats’
[10:58:43.312] Packages needed by future strategies (n = 0): <none>
[10:58:43.312] {
[10:58:43.312]     {
[10:58:43.312]         {
[10:58:43.312]             ...future.startTime <- base::Sys.time()
[10:58:43.312]             {
[10:58:43.312]                 {
[10:58:43.312]                   {
[10:58:43.312]                     {
[10:58:43.312]                       base::local({
[10:58:43.312]                         has_future <- base::requireNamespace("future", 
[10:58:43.312]                           quietly = TRUE)
[10:58:43.312]                         if (has_future) {
[10:58:43.312]                           ns <- base::getNamespace("future")
[10:58:43.312]                           version <- ns[[".package"]][["version"]]
[10:58:43.312]                           if (is.null(version)) 
[10:58:43.312]                             version <- utils::packageVersion("future")
[10:58:43.312]                         }
[10:58:43.312]                         else {
[10:58:43.312]                           version <- NULL
[10:58:43.312]                         }
[10:58:43.312]                         if (!has_future || version < "1.8.0") {
[10:58:43.312]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.312]                             "", base::R.version$version.string), 
[10:58:43.312]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.312]                               "release", "version")], collapse = " "), 
[10:58:43.312]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.312]                             info)
[10:58:43.312]                           info <- base::paste(info, collapse = "; ")
[10:58:43.312]                           if (!has_future) {
[10:58:43.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.312]                               info)
[10:58:43.312]                           }
[10:58:43.312]                           else {
[10:58:43.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.312]                               info, version)
[10:58:43.312]                           }
[10:58:43.312]                           base::stop(msg)
[10:58:43.312]                         }
[10:58:43.312]                       })
[10:58:43.312]                     }
[10:58:43.312]                     base::local({
[10:58:43.312]                       for (pkg in "stats") {
[10:58:43.312]                         base::loadNamespace(pkg)
[10:58:43.312]                         base::library(pkg, character.only = TRUE)
[10:58:43.312]                       }
[10:58:43.312]                     })
[10:58:43.312]                   }
[10:58:43.312]                   ...future.strategy.old <- future::plan("list")
[10:58:43.312]                   options(future.plan = NULL)
[10:58:43.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.312]                 }
[10:58:43.312]                 ...future.workdir <- getwd()
[10:58:43.312]             }
[10:58:43.312]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.312]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.312]         }
[10:58:43.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.312]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.312]             base::names(...future.oldOptions))
[10:58:43.312]     }
[10:58:43.312]     if (FALSE) {
[10:58:43.312]     }
[10:58:43.312]     else {
[10:58:43.312]         if (TRUE) {
[10:58:43.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.312]                 open = "w")
[10:58:43.312]         }
[10:58:43.312]         else {
[10:58:43.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.312]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.312]         }
[10:58:43.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.312]             base::sink(type = "output", split = FALSE)
[10:58:43.312]             base::close(...future.stdout)
[10:58:43.312]         }, add = TRUE)
[10:58:43.312]     }
[10:58:43.312]     ...future.frame <- base::sys.nframe()
[10:58:43.312]     ...future.conditions <- base::list()
[10:58:43.312]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.312]     if (FALSE) {
[10:58:43.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.312]     }
[10:58:43.312]     ...future.result <- base::tryCatch({
[10:58:43.312]         base::withCallingHandlers({
[10:58:43.312]             ...future.value <- base::withVisible(base::local({
[10:58:43.312]                 do.call(function(...) {
[10:58:43.312]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.312]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.312]                     ...future.globals.maxSize)) {
[10:58:43.312]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.312]                     on.exit(options(oopts), add = TRUE)
[10:58:43.312]                   }
[10:58:43.312]                   {
[10:58:43.312]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.312]                       FUN = function(jj) {
[10:58:43.312]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.312]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.312]                       })
[10:58:43.312]                   }
[10:58:43.312]                 }, args = future.call.arguments)
[10:58:43.312]             }))
[10:58:43.312]             future::FutureResult(value = ...future.value$value, 
[10:58:43.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.312]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.312]                     ...future.globalenv.names))
[10:58:43.312]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.312]         }, condition = base::local({
[10:58:43.312]             c <- base::c
[10:58:43.312]             inherits <- base::inherits
[10:58:43.312]             invokeRestart <- base::invokeRestart
[10:58:43.312]             length <- base::length
[10:58:43.312]             list <- base::list
[10:58:43.312]             seq.int <- base::seq.int
[10:58:43.312]             signalCondition <- base::signalCondition
[10:58:43.312]             sys.calls <- base::sys.calls
[10:58:43.312]             `[[` <- base::`[[`
[10:58:43.312]             `+` <- base::`+`
[10:58:43.312]             `<<-` <- base::`<<-`
[10:58:43.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.312]                   3L)]
[10:58:43.312]             }
[10:58:43.312]             function(cond) {
[10:58:43.312]                 is_error <- inherits(cond, "error")
[10:58:43.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.312]                   NULL)
[10:58:43.312]                 if (is_error) {
[10:58:43.312]                   sessionInformation <- function() {
[10:58:43.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.312]                       search = base::search(), system = base::Sys.info())
[10:58:43.312]                   }
[10:58:43.312]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.312]                     cond$call), session = sessionInformation(), 
[10:58:43.312]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.312]                   signalCondition(cond)
[10:58:43.312]                 }
[10:58:43.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.312]                 "immediateCondition"))) {
[10:58:43.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.312]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.312]                   if (TRUE && !signal) {
[10:58:43.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.312]                     {
[10:58:43.312]                       inherits <- base::inherits
[10:58:43.312]                       invokeRestart <- base::invokeRestart
[10:58:43.312]                       is.null <- base::is.null
[10:58:43.312]                       muffled <- FALSE
[10:58:43.312]                       if (inherits(cond, "message")) {
[10:58:43.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.312]                         if (muffled) 
[10:58:43.312]                           invokeRestart("muffleMessage")
[10:58:43.312]                       }
[10:58:43.312]                       else if (inherits(cond, "warning")) {
[10:58:43.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.312]                         if (muffled) 
[10:58:43.312]                           invokeRestart("muffleWarning")
[10:58:43.312]                       }
[10:58:43.312]                       else if (inherits(cond, "condition")) {
[10:58:43.312]                         if (!is.null(pattern)) {
[10:58:43.312]                           computeRestarts <- base::computeRestarts
[10:58:43.312]                           grepl <- base::grepl
[10:58:43.312]                           restarts <- computeRestarts(cond)
[10:58:43.312]                           for (restart in restarts) {
[10:58:43.312]                             name <- restart$name
[10:58:43.312]                             if (is.null(name)) 
[10:58:43.312]                               next
[10:58:43.312]                             if (!grepl(pattern, name)) 
[10:58:43.312]                               next
[10:58:43.312]                             invokeRestart(restart)
[10:58:43.312]                             muffled <- TRUE
[10:58:43.312]                             break
[10:58:43.312]                           }
[10:58:43.312]                         }
[10:58:43.312]                       }
[10:58:43.312]                       invisible(muffled)
[10:58:43.312]                     }
[10:58:43.312]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.312]                   }
[10:58:43.312]                 }
[10:58:43.312]                 else {
[10:58:43.312]                   if (TRUE) {
[10:58:43.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.312]                     {
[10:58:43.312]                       inherits <- base::inherits
[10:58:43.312]                       invokeRestart <- base::invokeRestart
[10:58:43.312]                       is.null <- base::is.null
[10:58:43.312]                       muffled <- FALSE
[10:58:43.312]                       if (inherits(cond, "message")) {
[10:58:43.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.312]                         if (muffled) 
[10:58:43.312]                           invokeRestart("muffleMessage")
[10:58:43.312]                       }
[10:58:43.312]                       else if (inherits(cond, "warning")) {
[10:58:43.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.312]                         if (muffled) 
[10:58:43.312]                           invokeRestart("muffleWarning")
[10:58:43.312]                       }
[10:58:43.312]                       else if (inherits(cond, "condition")) {
[10:58:43.312]                         if (!is.null(pattern)) {
[10:58:43.312]                           computeRestarts <- base::computeRestarts
[10:58:43.312]                           grepl <- base::grepl
[10:58:43.312]                           restarts <- computeRestarts(cond)
[10:58:43.312]                           for (restart in restarts) {
[10:58:43.312]                             name <- restart$name
[10:58:43.312]                             if (is.null(name)) 
[10:58:43.312]                               next
[10:58:43.312]                             if (!grepl(pattern, name)) 
[10:58:43.312]                               next
[10:58:43.312]                             invokeRestart(restart)
[10:58:43.312]                             muffled <- TRUE
[10:58:43.312]                             break
[10:58:43.312]                           }
[10:58:43.312]                         }
[10:58:43.312]                       }
[10:58:43.312]                       invisible(muffled)
[10:58:43.312]                     }
[10:58:43.312]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.312]                   }
[10:58:43.312]                 }
[10:58:43.312]             }
[10:58:43.312]         }))
[10:58:43.312]     }, error = function(ex) {
[10:58:43.312]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.312]                 ...future.rng), started = ...future.startTime, 
[10:58:43.312]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.312]             version = "1.8"), class = "FutureResult")
[10:58:43.312]     }, finally = {
[10:58:43.312]         if (!identical(...future.workdir, getwd())) 
[10:58:43.312]             setwd(...future.workdir)
[10:58:43.312]         {
[10:58:43.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.312]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.312]             }
[10:58:43.312]             base::options(...future.oldOptions)
[10:58:43.312]             if (.Platform$OS.type == "windows") {
[10:58:43.312]                 old_names <- names(...future.oldEnvVars)
[10:58:43.312]                 envs <- base::Sys.getenv()
[10:58:43.312]                 names <- names(envs)
[10:58:43.312]                 common <- intersect(names, old_names)
[10:58:43.312]                 added <- setdiff(names, old_names)
[10:58:43.312]                 removed <- setdiff(old_names, names)
[10:58:43.312]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.312]                   envs[common]]
[10:58:43.312]                 NAMES <- toupper(changed)
[10:58:43.312]                 args <- list()
[10:58:43.312]                 for (kk in seq_along(NAMES)) {
[10:58:43.312]                   name <- changed[[kk]]
[10:58:43.312]                   NAME <- NAMES[[kk]]
[10:58:43.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.312]                     next
[10:58:43.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.312]                 }
[10:58:43.312]                 NAMES <- toupper(added)
[10:58:43.312]                 for (kk in seq_along(NAMES)) {
[10:58:43.312]                   name <- added[[kk]]
[10:58:43.312]                   NAME <- NAMES[[kk]]
[10:58:43.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.312]                     next
[10:58:43.312]                   args[[name]] <- ""
[10:58:43.312]                 }
[10:58:43.312]                 NAMES <- toupper(removed)
[10:58:43.312]                 for (kk in seq_along(NAMES)) {
[10:58:43.312]                   name <- removed[[kk]]
[10:58:43.312]                   NAME <- NAMES[[kk]]
[10:58:43.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.312]                     next
[10:58:43.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.312]                 }
[10:58:43.312]                 if (length(args) > 0) 
[10:58:43.312]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.312]             }
[10:58:43.312]             else {
[10:58:43.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.312]             }
[10:58:43.312]             {
[10:58:43.312]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.312]                   0L) {
[10:58:43.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.312]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.312]                   base::options(opts)
[10:58:43.312]                 }
[10:58:43.312]                 {
[10:58:43.312]                   {
[10:58:43.312]                     NULL
[10:58:43.312]                     RNGkind("Mersenne-Twister")
[10:58:43.312]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.312]                       inherits = FALSE)
[10:58:43.312]                   }
[10:58:43.312]                   options(future.plan = NULL)
[10:58:43.312]                   if (is.na(NA_character_)) 
[10:58:43.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.312]                     .init = FALSE)
[10:58:43.312]                 }
[10:58:43.312]             }
[10:58:43.312]         }
[10:58:43.312]     })
[10:58:43.312]     if (TRUE) {
[10:58:43.312]         base::sink(type = "output", split = FALSE)
[10:58:43.312]         if (TRUE) {
[10:58:43.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.312]         }
[10:58:43.312]         else {
[10:58:43.312]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.312]         }
[10:58:43.312]         base::close(...future.stdout)
[10:58:43.312]         ...future.stdout <- NULL
[10:58:43.312]     }
[10:58:43.312]     ...future.result$conditions <- ...future.conditions
[10:58:43.312]     ...future.result$finished <- base::Sys.time()
[10:58:43.312]     ...future.result
[10:58:43.312] }
[10:58:43.314] assign_globals() ...
[10:58:43.314] List of 5
[10:58:43.314]  $ ...future.FUN            :function (x, ...)  
[10:58:43.314]  $ future.call.arguments    :List of 1
[10:58:43.314]   ..$ singular.ok: logi FALSE
[10:58:43.314]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.314]  $ ...future.elements_ii    :List of 3
[10:58:43.314]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.314]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.314]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.314]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.314]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.314]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.314]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.314]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.314]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.314]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.314]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.314]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.314]  $ ...future.seeds_ii       : NULL
[10:58:43.314]  $ ...future.globals.maxSize: NULL
[10:58:43.314]  - attr(*, "where")=List of 5
[10:58:43.314]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.314]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.314]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.314]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.314]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.314]  - attr(*, "resolved")= logi FALSE
[10:58:43.314]  - attr(*, "total_size")= num 19977
[10:58:43.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.314]  - attr(*, "already-done")= logi TRUE
[10:58:43.325] - reassign environment for ‘...future.FUN’
[10:58:43.325] - copied ‘...future.FUN’ to environment
[10:58:43.325] - copied ‘future.call.arguments’ to environment
[10:58:43.325] - copied ‘...future.elements_ii’ to environment
[10:58:43.325] - copied ‘...future.seeds_ii’ to environment
[10:58:43.325] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.325] assign_globals() ... done
[10:58:43.326] plan(): Setting new future strategy stack:
[10:58:43.326] List of future strategies:
[10:58:43.326] 1. sequential:
[10:58:43.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.326]    - tweaked: FALSE
[10:58:43.326]    - call: NULL
[10:58:43.326] plan(): nbrOfWorkers() = 1
[10:58:43.329] plan(): Setting new future strategy stack:
[10:58:43.329] List of future strategies:
[10:58:43.329] 1. multisession:
[10:58:43.329]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.329]    - tweaked: FALSE
[10:58:43.329]    - call: plan(strategy)
[10:58:43.331] plan(): nbrOfWorkers() = 1
[10:58:43.331] SequentialFuture started (and completed)
[10:58:43.331] - Launch lazy future ... done
[10:58:43.331] run() for ‘SequentialFuture’ ... done
[10:58:43.331] Created future:
[10:58:43.331] SequentialFuture:
[10:58:43.331] Label: ‘future_by-1’
[10:58:43.331] Expression:
[10:58:43.331] {
[10:58:43.331]     do.call(function(...) {
[10:58:43.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.331]             on.exit(options(oopts), add = TRUE)
[10:58:43.331]         }
[10:58:43.331]         {
[10:58:43.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.331]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.331]             })
[10:58:43.331]         }
[10:58:43.331]     }, args = future.call.arguments)
[10:58:43.331] }
[10:58:43.331] Lazy evaluation: FALSE
[10:58:43.331] Asynchronous evaluation: FALSE
[10:58:43.331] Local evaluation: TRUE
[10:58:43.331] Environment: R_GlobalEnv
[10:58:43.331] Capture standard output: TRUE
[10:58:43.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.331] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.331] Packages: 1 packages (‘stats’)
[10:58:43.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.331] Resolved: TRUE
[10:58:43.331] Value: 81.13 KiB of class ‘list’
[10:58:43.331] Early signaling: FALSE
[10:58:43.331] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.331] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.333] Chunk #1 of 1 ... DONE
[10:58:43.333] Launching 1 futures (chunks) ... DONE
[10:58:43.333] Resolving 1 futures (chunks) ...
[10:58:43.333] resolve() on list ...
[10:58:43.333]  recursive: 0
[10:58:43.333]  length: 1
[10:58:43.333] 
[10:58:43.333] resolved() for ‘SequentialFuture’ ...
[10:58:43.334] - state: ‘finished’
[10:58:43.334] - run: TRUE
[10:58:43.334] - result: ‘FutureResult’
[10:58:43.334] resolved() for ‘SequentialFuture’ ... done
[10:58:43.334] Future #1
[10:58:43.334] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.334] - nx: 1
[10:58:43.334] - relay: TRUE
[10:58:43.334] - stdout: TRUE
[10:58:43.334] - signal: TRUE
[10:58:43.334] - resignal: FALSE
[10:58:43.334] - force: TRUE
[10:58:43.335] - relayed: [n=1] FALSE
[10:58:43.335] - queued futures: [n=1] FALSE
[10:58:43.335]  - until=1
[10:58:43.335]  - relaying element #1
[10:58:43.335] - relayed: [n=1] TRUE
[10:58:43.335] - queued futures: [n=1] TRUE
[10:58:43.335] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.335]  length: 0 (resolved future 1)
[10:58:43.335] Relaying remaining futures
[10:58:43.335] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.336] - nx: 1
[10:58:43.336] - relay: TRUE
[10:58:43.336] - stdout: TRUE
[10:58:43.336] - signal: TRUE
[10:58:43.336] - resignal: FALSE
[10:58:43.336] - force: TRUE
[10:58:43.336] - relayed: [n=1] TRUE
[10:58:43.336] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.336] - relayed: [n=1] TRUE
[10:58:43.336] - queued futures: [n=1] TRUE
[10:58:43.336] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.337] resolve() on list ... DONE
[10:58:43.337]  - Number of value chunks collected: 1
[10:58:43.337] Resolving 1 futures (chunks) ... DONE
[10:58:43.337] Reducing values from 1 chunks ...
[10:58:43.338]  - Number of values collected after concatenation: 3
[10:58:43.339]  - Number of values expected: 3
[10:58:43.339] Reducing values from 1 chunks ... DONE
[10:58:43.339] future_lapply() ... DONE
[10:58:43.339] future_by_internal() ... DONE
[10:58:43.343] future_by_internal() ...
[10:58:43.343] future_lapply() ...
[10:58:43.345] Number of chunks: 1
[10:58:43.346] getGlobalsAndPackagesXApply() ...
[10:58:43.346]  - future.globals: TRUE
[10:58:43.346] getGlobalsAndPackages() ...
[10:58:43.346] Searching for globals...
[10:58:43.347] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:43.348] Searching for globals ... DONE
[10:58:43.348] Resolving globals: FALSE
[10:58:43.348] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:58:43.349] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:58:43.349] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:43.349] - packages: [1] ‘stats’
[10:58:43.349] getGlobalsAndPackages() ... DONE
[10:58:43.349]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:43.349]  - needed namespaces: [n=1] ‘stats’
[10:58:43.349] Finding globals ... DONE
[10:58:43.349]  - use_args: TRUE
[10:58:43.349]  - Getting '...' globals ...
[10:58:43.350] resolve() on list ...
[10:58:43.350]  recursive: 0
[10:58:43.350]  length: 1
[10:58:43.350]  elements: ‘...’
[10:58:43.350]  length: 0 (resolved future 1)
[10:58:43.350] resolve() on list ... DONE
[10:58:43.350]    - '...' content: [n=0] 
[10:58:43.350] List of 1
[10:58:43.350]  $ ...: list()
[10:58:43.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.350]  - attr(*, "where")=List of 1
[10:58:43.350]   ..$ ...:<environment: 0x55974b7f5908> 
[10:58:43.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.350]  - attr(*, "resolved")= logi TRUE
[10:58:43.350]  - attr(*, "total_size")= num NA
[10:58:43.353]  - Getting '...' globals ... DONE
[10:58:43.353] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:58:43.353] List of 4
[10:58:43.353]  $ ...future.FUN:function (x)  
[10:58:43.353]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:43.353]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.353]  $ ...          : list()
[10:58:43.353]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.353]  - attr(*, "where")=List of 4
[10:58:43.353]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.353]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:58:43.353]   ..$ wool         :<environment: R_EmptyEnv> 
[10:58:43.353]   ..$ ...          :<environment: 0x55974b7f5908> 
[10:58:43.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.353]  - attr(*, "resolved")= logi FALSE
[10:58:43.353]  - attr(*, "total_size")= num 18867
[10:58:43.358] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:43.358] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.359] Number of futures (= number of chunks): 1
[10:58:43.359] Launching 1 futures (chunks) ...
[10:58:43.359] Chunk #1 of 1 ...
[10:58:43.359]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.359] getGlobalsAndPackages() ...
[10:58:43.359] Searching for globals...
[10:58:43.360] 
[10:58:43.360] Searching for globals ... DONE
[10:58:43.360] - globals: [0] <none>
[10:58:43.360] getGlobalsAndPackages() ... DONE
[10:58:43.360]    + additional globals found: [n=0] 
[10:58:43.360]    + additional namespaces needed: [n=0] 
[10:58:43.360]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.360]  - seeds: <none>
[10:58:43.360]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.360] getGlobalsAndPackages() ...
[10:58:43.360] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.361] Resolving globals: FALSE
[10:58:43.361] Tweak future expression to call with '...' arguments ...
[10:58:43.361] {
[10:58:43.361]     do.call(function(...) {
[10:58:43.361]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.361]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.361]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.361]             on.exit(options(oopts), add = TRUE)
[10:58:43.361]         }
[10:58:43.361]         {
[10:58:43.361]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.361]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.361]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.361]             })
[10:58:43.361]         }
[10:58:43.361]     }, args = future.call.arguments)
[10:58:43.361] }
[10:58:43.361] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.361] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.362] 
[10:58:43.362] getGlobalsAndPackages() ... DONE
[10:58:43.362] run() for ‘Future’ ...
[10:58:43.362] - state: ‘created’
[10:58:43.362] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.364] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.364]   - Field: ‘label’
[10:58:43.364]   - Field: ‘local’
[10:58:43.364]   - Field: ‘owner’
[10:58:43.364]   - Field: ‘envir’
[10:58:43.364]   - Field: ‘packages’
[10:58:43.364]   - Field: ‘gc’
[10:58:43.364]   - Field: ‘conditions’
[10:58:43.364]   - Field: ‘expr’
[10:58:43.365]   - Field: ‘uuid’
[10:58:43.365]   - Field: ‘seed’
[10:58:43.365]   - Field: ‘version’
[10:58:43.365]   - Field: ‘result’
[10:58:43.365]   - Field: ‘asynchronous’
[10:58:43.365]   - Field: ‘calls’
[10:58:43.365]   - Field: ‘globals’
[10:58:43.365]   - Field: ‘stdout’
[10:58:43.365]   - Field: ‘earlySignal’
[10:58:43.365]   - Field: ‘lazy’
[10:58:43.365]   - Field: ‘state’
[10:58:43.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.366] - Launch lazy future ...
[10:58:43.366] Packages needed by the future expression (n = 1): ‘stats’
[10:58:43.366] Packages needed by future strategies (n = 0): <none>
[10:58:43.366] {
[10:58:43.366]     {
[10:58:43.366]         {
[10:58:43.366]             ...future.startTime <- base::Sys.time()
[10:58:43.366]             {
[10:58:43.366]                 {
[10:58:43.366]                   {
[10:58:43.366]                     {
[10:58:43.366]                       base::local({
[10:58:43.366]                         has_future <- base::requireNamespace("future", 
[10:58:43.366]                           quietly = TRUE)
[10:58:43.366]                         if (has_future) {
[10:58:43.366]                           ns <- base::getNamespace("future")
[10:58:43.366]                           version <- ns[[".package"]][["version"]]
[10:58:43.366]                           if (is.null(version)) 
[10:58:43.366]                             version <- utils::packageVersion("future")
[10:58:43.366]                         }
[10:58:43.366]                         else {
[10:58:43.366]                           version <- NULL
[10:58:43.366]                         }
[10:58:43.366]                         if (!has_future || version < "1.8.0") {
[10:58:43.366]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.366]                             "", base::R.version$version.string), 
[10:58:43.366]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.366]                               "release", "version")], collapse = " "), 
[10:58:43.366]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.366]                             info)
[10:58:43.366]                           info <- base::paste(info, collapse = "; ")
[10:58:43.366]                           if (!has_future) {
[10:58:43.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.366]                               info)
[10:58:43.366]                           }
[10:58:43.366]                           else {
[10:58:43.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.366]                               info, version)
[10:58:43.366]                           }
[10:58:43.366]                           base::stop(msg)
[10:58:43.366]                         }
[10:58:43.366]                       })
[10:58:43.366]                     }
[10:58:43.366]                     base::local({
[10:58:43.366]                       for (pkg in "stats") {
[10:58:43.366]                         base::loadNamespace(pkg)
[10:58:43.366]                         base::library(pkg, character.only = TRUE)
[10:58:43.366]                       }
[10:58:43.366]                     })
[10:58:43.366]                   }
[10:58:43.366]                   ...future.strategy.old <- future::plan("list")
[10:58:43.366]                   options(future.plan = NULL)
[10:58:43.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.366]                 }
[10:58:43.366]                 ...future.workdir <- getwd()
[10:58:43.366]             }
[10:58:43.366]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.366]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.366]         }
[10:58:43.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.366]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.366]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.366]             base::names(...future.oldOptions))
[10:58:43.366]     }
[10:58:43.366]     if (FALSE) {
[10:58:43.366]     }
[10:58:43.366]     else {
[10:58:43.366]         if (TRUE) {
[10:58:43.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.366]                 open = "w")
[10:58:43.366]         }
[10:58:43.366]         else {
[10:58:43.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.366]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.366]         }
[10:58:43.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.366]             base::sink(type = "output", split = FALSE)
[10:58:43.366]             base::close(...future.stdout)
[10:58:43.366]         }, add = TRUE)
[10:58:43.366]     }
[10:58:43.366]     ...future.frame <- base::sys.nframe()
[10:58:43.366]     ...future.conditions <- base::list()
[10:58:43.366]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.366]     if (FALSE) {
[10:58:43.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.366]     }
[10:58:43.366]     ...future.result <- base::tryCatch({
[10:58:43.366]         base::withCallingHandlers({
[10:58:43.366]             ...future.value <- base::withVisible(base::local({
[10:58:43.366]                 do.call(function(...) {
[10:58:43.366]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.366]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.366]                     ...future.globals.maxSize)) {
[10:58:43.366]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.366]                     on.exit(options(oopts), add = TRUE)
[10:58:43.366]                   }
[10:58:43.366]                   {
[10:58:43.366]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.366]                       FUN = function(jj) {
[10:58:43.366]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.366]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.366]                       })
[10:58:43.366]                   }
[10:58:43.366]                 }, args = future.call.arguments)
[10:58:43.366]             }))
[10:58:43.366]             future::FutureResult(value = ...future.value$value, 
[10:58:43.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.366]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.366]                     ...future.globalenv.names))
[10:58:43.366]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.366]         }, condition = base::local({
[10:58:43.366]             c <- base::c
[10:58:43.366]             inherits <- base::inherits
[10:58:43.366]             invokeRestart <- base::invokeRestart
[10:58:43.366]             length <- base::length
[10:58:43.366]             list <- base::list
[10:58:43.366]             seq.int <- base::seq.int
[10:58:43.366]             signalCondition <- base::signalCondition
[10:58:43.366]             sys.calls <- base::sys.calls
[10:58:43.366]             `[[` <- base::`[[`
[10:58:43.366]             `+` <- base::`+`
[10:58:43.366]             `<<-` <- base::`<<-`
[10:58:43.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.366]                   3L)]
[10:58:43.366]             }
[10:58:43.366]             function(cond) {
[10:58:43.366]                 is_error <- inherits(cond, "error")
[10:58:43.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.366]                   NULL)
[10:58:43.366]                 if (is_error) {
[10:58:43.366]                   sessionInformation <- function() {
[10:58:43.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.366]                       search = base::search(), system = base::Sys.info())
[10:58:43.366]                   }
[10:58:43.366]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.366]                     cond$call), session = sessionInformation(), 
[10:58:43.366]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.366]                   signalCondition(cond)
[10:58:43.366]                 }
[10:58:43.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.366]                 "immediateCondition"))) {
[10:58:43.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.366]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.366]                   if (TRUE && !signal) {
[10:58:43.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.366]                     {
[10:58:43.366]                       inherits <- base::inherits
[10:58:43.366]                       invokeRestart <- base::invokeRestart
[10:58:43.366]                       is.null <- base::is.null
[10:58:43.366]                       muffled <- FALSE
[10:58:43.366]                       if (inherits(cond, "message")) {
[10:58:43.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.366]                         if (muffled) 
[10:58:43.366]                           invokeRestart("muffleMessage")
[10:58:43.366]                       }
[10:58:43.366]                       else if (inherits(cond, "warning")) {
[10:58:43.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.366]                         if (muffled) 
[10:58:43.366]                           invokeRestart("muffleWarning")
[10:58:43.366]                       }
[10:58:43.366]                       else if (inherits(cond, "condition")) {
[10:58:43.366]                         if (!is.null(pattern)) {
[10:58:43.366]                           computeRestarts <- base::computeRestarts
[10:58:43.366]                           grepl <- base::grepl
[10:58:43.366]                           restarts <- computeRestarts(cond)
[10:58:43.366]                           for (restart in restarts) {
[10:58:43.366]                             name <- restart$name
[10:58:43.366]                             if (is.null(name)) 
[10:58:43.366]                               next
[10:58:43.366]                             if (!grepl(pattern, name)) 
[10:58:43.366]                               next
[10:58:43.366]                             invokeRestart(restart)
[10:58:43.366]                             muffled <- TRUE
[10:58:43.366]                             break
[10:58:43.366]                           }
[10:58:43.366]                         }
[10:58:43.366]                       }
[10:58:43.366]                       invisible(muffled)
[10:58:43.366]                     }
[10:58:43.366]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.366]                   }
[10:58:43.366]                 }
[10:58:43.366]                 else {
[10:58:43.366]                   if (TRUE) {
[10:58:43.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.366]                     {
[10:58:43.366]                       inherits <- base::inherits
[10:58:43.366]                       invokeRestart <- base::invokeRestart
[10:58:43.366]                       is.null <- base::is.null
[10:58:43.366]                       muffled <- FALSE
[10:58:43.366]                       if (inherits(cond, "message")) {
[10:58:43.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.366]                         if (muffled) 
[10:58:43.366]                           invokeRestart("muffleMessage")
[10:58:43.366]                       }
[10:58:43.366]                       else if (inherits(cond, "warning")) {
[10:58:43.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.366]                         if (muffled) 
[10:58:43.366]                           invokeRestart("muffleWarning")
[10:58:43.366]                       }
[10:58:43.366]                       else if (inherits(cond, "condition")) {
[10:58:43.366]                         if (!is.null(pattern)) {
[10:58:43.366]                           computeRestarts <- base::computeRestarts
[10:58:43.366]                           grepl <- base::grepl
[10:58:43.366]                           restarts <- computeRestarts(cond)
[10:58:43.366]                           for (restart in restarts) {
[10:58:43.366]                             name <- restart$name
[10:58:43.366]                             if (is.null(name)) 
[10:58:43.366]                               next
[10:58:43.366]                             if (!grepl(pattern, name)) 
[10:58:43.366]                               next
[10:58:43.366]                             invokeRestart(restart)
[10:58:43.366]                             muffled <- TRUE
[10:58:43.366]                             break
[10:58:43.366]                           }
[10:58:43.366]                         }
[10:58:43.366]                       }
[10:58:43.366]                       invisible(muffled)
[10:58:43.366]                     }
[10:58:43.366]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.366]                   }
[10:58:43.366]                 }
[10:58:43.366]             }
[10:58:43.366]         }))
[10:58:43.366]     }, error = function(ex) {
[10:58:43.366]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.366]                 ...future.rng), started = ...future.startTime, 
[10:58:43.366]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.366]             version = "1.8"), class = "FutureResult")
[10:58:43.366]     }, finally = {
[10:58:43.366]         if (!identical(...future.workdir, getwd())) 
[10:58:43.366]             setwd(...future.workdir)
[10:58:43.366]         {
[10:58:43.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.366]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.366]             }
[10:58:43.366]             base::options(...future.oldOptions)
[10:58:43.366]             if (.Platform$OS.type == "windows") {
[10:58:43.366]                 old_names <- names(...future.oldEnvVars)
[10:58:43.366]                 envs <- base::Sys.getenv()
[10:58:43.366]                 names <- names(envs)
[10:58:43.366]                 common <- intersect(names, old_names)
[10:58:43.366]                 added <- setdiff(names, old_names)
[10:58:43.366]                 removed <- setdiff(old_names, names)
[10:58:43.366]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.366]                   envs[common]]
[10:58:43.366]                 NAMES <- toupper(changed)
[10:58:43.366]                 args <- list()
[10:58:43.366]                 for (kk in seq_along(NAMES)) {
[10:58:43.366]                   name <- changed[[kk]]
[10:58:43.366]                   NAME <- NAMES[[kk]]
[10:58:43.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.366]                     next
[10:58:43.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.366]                 }
[10:58:43.366]                 NAMES <- toupper(added)
[10:58:43.366]                 for (kk in seq_along(NAMES)) {
[10:58:43.366]                   name <- added[[kk]]
[10:58:43.366]                   NAME <- NAMES[[kk]]
[10:58:43.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.366]                     next
[10:58:43.366]                   args[[name]] <- ""
[10:58:43.366]                 }
[10:58:43.366]                 NAMES <- toupper(removed)
[10:58:43.366]                 for (kk in seq_along(NAMES)) {
[10:58:43.366]                   name <- removed[[kk]]
[10:58:43.366]                   NAME <- NAMES[[kk]]
[10:58:43.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.366]                     next
[10:58:43.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.366]                 }
[10:58:43.366]                 if (length(args) > 0) 
[10:58:43.366]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.366]             }
[10:58:43.366]             else {
[10:58:43.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.366]             }
[10:58:43.366]             {
[10:58:43.366]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.366]                   0L) {
[10:58:43.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.366]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.366]                   base::options(opts)
[10:58:43.366]                 }
[10:58:43.366]                 {
[10:58:43.366]                   {
[10:58:43.366]                     NULL
[10:58:43.366]                     RNGkind("Mersenne-Twister")
[10:58:43.366]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.366]                       inherits = FALSE)
[10:58:43.366]                   }
[10:58:43.366]                   options(future.plan = NULL)
[10:58:43.366]                   if (is.na(NA_character_)) 
[10:58:43.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.366]                     .init = FALSE)
[10:58:43.366]                 }
[10:58:43.366]             }
[10:58:43.366]         }
[10:58:43.366]     })
[10:58:43.366]     if (TRUE) {
[10:58:43.366]         base::sink(type = "output", split = FALSE)
[10:58:43.366]         if (TRUE) {
[10:58:43.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.366]         }
[10:58:43.366]         else {
[10:58:43.366]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.366]         }
[10:58:43.366]         base::close(...future.stdout)
[10:58:43.366]         ...future.stdout <- NULL
[10:58:43.366]     }
[10:58:43.366]     ...future.result$conditions <- ...future.conditions
[10:58:43.366]     ...future.result$finished <- base::Sys.time()
[10:58:43.366]     ...future.result
[10:58:43.366] }
[10:58:43.368] assign_globals() ...
[10:58:43.368] List of 7
[10:58:43.368]  $ ...future.FUN            :function (x)  
[10:58:43.368]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:43.368]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.368]  $ future.call.arguments    : list()
[10:58:43.368]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.368]  $ ...future.elements_ii    :List of 3
[10:58:43.368]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.368]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.368]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.368]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.368]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.368]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.368]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.368]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.368]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.368]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.368]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.368]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.368]  $ ...future.seeds_ii       : NULL
[10:58:43.368]  $ ...future.globals.maxSize: NULL
[10:58:43.368]  - attr(*, "where")=List of 7
[10:58:43.368]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.368]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:58:43.368]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:58:43.368]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.368]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.368]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.368]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.368]  - attr(*, "resolved")= logi FALSE
[10:58:43.368]  - attr(*, "total_size")= num 18867
[10:58:43.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.368]  - attr(*, "already-done")= logi TRUE
[10:58:43.379] - reassign environment for ‘...future.FUN’
[10:58:43.379] - copied ‘...future.FUN’ to environment
[10:58:43.379] - copied ‘breaks’ to environment
[10:58:43.380] - copied ‘wool’ to environment
[10:58:43.380] - copied ‘future.call.arguments’ to environment
[10:58:43.380] - copied ‘...future.elements_ii’ to environment
[10:58:43.380] - copied ‘...future.seeds_ii’ to environment
[10:58:43.380] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.380] assign_globals() ... done
[10:58:43.380] plan(): Setting new future strategy stack:
[10:58:43.381] List of future strategies:
[10:58:43.381] 1. sequential:
[10:58:43.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.381]    - tweaked: FALSE
[10:58:43.381]    - call: NULL
[10:58:43.381] plan(): nbrOfWorkers() = 1
[10:58:43.384] plan(): Setting new future strategy stack:
[10:58:43.384] List of future strategies:
[10:58:43.384] 1. multisession:
[10:58:43.384]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.384]    - tweaked: FALSE
[10:58:43.384]    - call: plan(strategy)
[10:58:43.385] plan(): nbrOfWorkers() = 1
[10:58:43.386] SequentialFuture started (and completed)
[10:58:43.386] - Launch lazy future ... done
[10:58:43.386] run() for ‘SequentialFuture’ ... done
[10:58:43.386] Created future:
[10:58:43.386] SequentialFuture:
[10:58:43.386] Label: ‘future_by-1’
[10:58:43.386] Expression:
[10:58:43.386] {
[10:58:43.386]     do.call(function(...) {
[10:58:43.386]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.386]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.386]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.386]             on.exit(options(oopts), add = TRUE)
[10:58:43.386]         }
[10:58:43.386]         {
[10:58:43.386]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.386]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.386]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.386]             })
[10:58:43.386]         }
[10:58:43.386]     }, args = future.call.arguments)
[10:58:43.386] }
[10:58:43.386] Lazy evaluation: FALSE
[10:58:43.386] Asynchronous evaluation: FALSE
[10:58:43.386] Local evaluation: TRUE
[10:58:43.386] Environment: 0x55974b8cafa8
[10:58:43.386] Capture standard output: TRUE
[10:58:43.386] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.386] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[10:58:43.386] Packages: 1 packages (‘stats’)
[10:58:43.386] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.386] Resolved: TRUE
[10:58:43.386] Value: 82.51 KiB of class ‘list’
[10:58:43.386] Early signaling: FALSE
[10:58:43.386] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.386] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.387] Chunk #1 of 1 ... DONE
[10:58:43.388] Launching 1 futures (chunks) ... DONE
[10:58:43.388] Resolving 1 futures (chunks) ...
[10:58:43.388] resolve() on list ...
[10:58:43.388]  recursive: 0
[10:58:43.388]  length: 1
[10:58:43.388] 
[10:58:43.388] resolved() for ‘SequentialFuture’ ...
[10:58:43.388] - state: ‘finished’
[10:58:43.388] - run: TRUE
[10:58:43.388] - result: ‘FutureResult’
[10:58:43.389] resolved() for ‘SequentialFuture’ ... done
[10:58:43.389] Future #1
[10:58:43.389] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.389] - nx: 1
[10:58:43.389] - relay: TRUE
[10:58:43.389] - stdout: TRUE
[10:58:43.389] - signal: TRUE
[10:58:43.389] - resignal: FALSE
[10:58:43.389] - force: TRUE
[10:58:43.389] - relayed: [n=1] FALSE
[10:58:43.389] - queued futures: [n=1] FALSE
[10:58:43.389]  - until=1
[10:58:43.390]  - relaying element #1
[10:58:43.390] - relayed: [n=1] TRUE
[10:58:43.390] - queued futures: [n=1] TRUE
[10:58:43.390] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.390]  length: 0 (resolved future 1)
[10:58:43.390] Relaying remaining futures
[10:58:43.390] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.390] - nx: 1
[10:58:43.390] - relay: TRUE
[10:58:43.390] - stdout: TRUE
[10:58:43.390] - signal: TRUE
[10:58:43.391] - resignal: FALSE
[10:58:43.391] - force: TRUE
[10:58:43.391] - relayed: [n=1] TRUE
[10:58:43.391] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.391] - relayed: [n=1] TRUE
[10:58:43.391] - queued futures: [n=1] TRUE
[10:58:43.391] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.391] resolve() on list ... DONE
[10:58:43.391]  - Number of value chunks collected: 1
[10:58:43.391] Resolving 1 futures (chunks) ... DONE
[10:58:43.391] Reducing values from 1 chunks ...
[10:58:43.392]  - Number of values collected after concatenation: 3
[10:58:43.392]  - Number of values expected: 3
[10:58:43.392] Reducing values from 1 chunks ... DONE
[10:58:43.392] future_lapply() ... DONE
[10:58:43.392] future_by_internal() ... DONE
[10:58:43.392] future_by_internal() ...
[10:58:43.393] future_lapply() ...
[10:58:43.394] Number of chunks: 1
[10:58:43.394] getGlobalsAndPackagesXApply() ...
[10:58:43.394]  - future.globals: TRUE
[10:58:43.395] getGlobalsAndPackages() ...
[10:58:43.395] Searching for globals...
[10:58:43.396] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.396] Searching for globals ... DONE
[10:58:43.396] Resolving globals: FALSE
[10:58:43.396] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.397] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.397] - globals: [1] ‘FUN’
[10:58:43.397] 
[10:58:43.397] getGlobalsAndPackages() ... DONE
[10:58:43.397]  - globals found/used: [n=1] ‘FUN’
[10:58:43.397]  - needed namespaces: [n=0] 
[10:58:43.397] Finding globals ... DONE
[10:58:43.397]  - use_args: TRUE
[10:58:43.397]  - Getting '...' globals ...
[10:58:43.399] resolve() on list ...
[10:58:43.399]  recursive: 0
[10:58:43.399]  length: 1
[10:58:43.399]  elements: ‘...’
[10:58:43.400]  length: 0 (resolved future 1)
[10:58:43.400] resolve() on list ... DONE
[10:58:43.400]    - '...' content: [n=0] 
[10:58:43.400] List of 1
[10:58:43.400]  $ ...: list()
[10:58:43.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.400]  - attr(*, "where")=List of 1
[10:58:43.400]   ..$ ...:<environment: 0x55974dc4a8d0> 
[10:58:43.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.400]  - attr(*, "resolved")= logi TRUE
[10:58:43.400]  - attr(*, "total_size")= num NA
[10:58:43.402]  - Getting '...' globals ... DONE
[10:58:43.403] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.403] List of 2
[10:58:43.403]  $ ...future.FUN:function (object, ...)  
[10:58:43.403]  $ ...          : list()
[10:58:43.403]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.403]  - attr(*, "where")=List of 2
[10:58:43.403]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.403]   ..$ ...          :<environment: 0x55974dc4a8d0> 
[10:58:43.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.403]  - attr(*, "resolved")= logi FALSE
[10:58:43.403]  - attr(*, "total_size")= num 19278
[10:58:43.405] Packages to be attached in all futures: [n=0] 
[10:58:43.406] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.406] Number of futures (= number of chunks): 1
[10:58:43.406] Launching 1 futures (chunks) ...
[10:58:43.406] Chunk #1 of 1 ...
[10:58:43.406]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.406] getGlobalsAndPackages() ...
[10:58:43.406] Searching for globals...
[10:58:43.407] 
[10:58:43.407] Searching for globals ... DONE
[10:58:43.407] - globals: [0] <none>
[10:58:43.407] getGlobalsAndPackages() ... DONE
[10:58:43.407]    + additional globals found: [n=0] 
[10:58:43.407]    + additional namespaces needed: [n=0] 
[10:58:43.407]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.407]  - seeds: <none>
[10:58:43.407]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.407] getGlobalsAndPackages() ...
[10:58:43.408] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.408] Resolving globals: FALSE
[10:58:43.408] Tweak future expression to call with '...' arguments ...
[10:58:43.408] {
[10:58:43.408]     do.call(function(...) {
[10:58:43.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.408]             on.exit(options(oopts), add = TRUE)
[10:58:43.408]         }
[10:58:43.408]         {
[10:58:43.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.408]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.408]             })
[10:58:43.408]         }
[10:58:43.408]     }, args = future.call.arguments)
[10:58:43.408] }
[10:58:43.408] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.408] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.409] 
[10:58:43.409] getGlobalsAndPackages() ... DONE
[10:58:43.409] run() for ‘Future’ ...
[10:58:43.409] - state: ‘created’
[10:58:43.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.411] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.411] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.411]   - Field: ‘label’
[10:58:43.411]   - Field: ‘local’
[10:58:43.411]   - Field: ‘owner’
[10:58:43.411]   - Field: ‘envir’
[10:58:43.411]   - Field: ‘packages’
[10:58:43.411]   - Field: ‘gc’
[10:58:43.411]   - Field: ‘conditions’
[10:58:43.411]   - Field: ‘expr’
[10:58:43.412]   - Field: ‘uuid’
[10:58:43.412]   - Field: ‘seed’
[10:58:43.412]   - Field: ‘version’
[10:58:43.412]   - Field: ‘result’
[10:58:43.412]   - Field: ‘asynchronous’
[10:58:43.412]   - Field: ‘calls’
[10:58:43.412]   - Field: ‘globals’
[10:58:43.412]   - Field: ‘stdout’
[10:58:43.412]   - Field: ‘earlySignal’
[10:58:43.412]   - Field: ‘lazy’
[10:58:43.412]   - Field: ‘state’
[10:58:43.413] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.413] - Launch lazy future ...
[10:58:43.413] Packages needed by the future expression (n = 0): <none>
[10:58:43.413] Packages needed by future strategies (n = 0): <none>
[10:58:43.413] {
[10:58:43.413]     {
[10:58:43.413]         {
[10:58:43.413]             ...future.startTime <- base::Sys.time()
[10:58:43.413]             {
[10:58:43.413]                 {
[10:58:43.413]                   {
[10:58:43.413]                     base::local({
[10:58:43.413]                       has_future <- base::requireNamespace("future", 
[10:58:43.413]                         quietly = TRUE)
[10:58:43.413]                       if (has_future) {
[10:58:43.413]                         ns <- base::getNamespace("future")
[10:58:43.413]                         version <- ns[[".package"]][["version"]]
[10:58:43.413]                         if (is.null(version)) 
[10:58:43.413]                           version <- utils::packageVersion("future")
[10:58:43.413]                       }
[10:58:43.413]                       else {
[10:58:43.413]                         version <- NULL
[10:58:43.413]                       }
[10:58:43.413]                       if (!has_future || version < "1.8.0") {
[10:58:43.413]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.413]                           "", base::R.version$version.string), 
[10:58:43.413]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.413]                             "release", "version")], collapse = " "), 
[10:58:43.413]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.413]                           info)
[10:58:43.413]                         info <- base::paste(info, collapse = "; ")
[10:58:43.413]                         if (!has_future) {
[10:58:43.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.413]                             info)
[10:58:43.413]                         }
[10:58:43.413]                         else {
[10:58:43.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.413]                             info, version)
[10:58:43.413]                         }
[10:58:43.413]                         base::stop(msg)
[10:58:43.413]                       }
[10:58:43.413]                     })
[10:58:43.413]                   }
[10:58:43.413]                   ...future.strategy.old <- future::plan("list")
[10:58:43.413]                   options(future.plan = NULL)
[10:58:43.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.413]                 }
[10:58:43.413]                 ...future.workdir <- getwd()
[10:58:43.413]             }
[10:58:43.413]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.413]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.413]         }
[10:58:43.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.413]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.413]             base::names(...future.oldOptions))
[10:58:43.413]     }
[10:58:43.413]     if (FALSE) {
[10:58:43.413]     }
[10:58:43.413]     else {
[10:58:43.413]         if (TRUE) {
[10:58:43.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.413]                 open = "w")
[10:58:43.413]         }
[10:58:43.413]         else {
[10:58:43.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.413]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.413]         }
[10:58:43.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.413]             base::sink(type = "output", split = FALSE)
[10:58:43.413]             base::close(...future.stdout)
[10:58:43.413]         }, add = TRUE)
[10:58:43.413]     }
[10:58:43.413]     ...future.frame <- base::sys.nframe()
[10:58:43.413]     ...future.conditions <- base::list()
[10:58:43.413]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.413]     if (FALSE) {
[10:58:43.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.413]     }
[10:58:43.413]     ...future.result <- base::tryCatch({
[10:58:43.413]         base::withCallingHandlers({
[10:58:43.413]             ...future.value <- base::withVisible(base::local({
[10:58:43.413]                 do.call(function(...) {
[10:58:43.413]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.413]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.413]                     ...future.globals.maxSize)) {
[10:58:43.413]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.413]                     on.exit(options(oopts), add = TRUE)
[10:58:43.413]                   }
[10:58:43.413]                   {
[10:58:43.413]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.413]                       FUN = function(jj) {
[10:58:43.413]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.413]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.413]                       })
[10:58:43.413]                   }
[10:58:43.413]                 }, args = future.call.arguments)
[10:58:43.413]             }))
[10:58:43.413]             future::FutureResult(value = ...future.value$value, 
[10:58:43.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.413]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.413]                     ...future.globalenv.names))
[10:58:43.413]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.413]         }, condition = base::local({
[10:58:43.413]             c <- base::c
[10:58:43.413]             inherits <- base::inherits
[10:58:43.413]             invokeRestart <- base::invokeRestart
[10:58:43.413]             length <- base::length
[10:58:43.413]             list <- base::list
[10:58:43.413]             seq.int <- base::seq.int
[10:58:43.413]             signalCondition <- base::signalCondition
[10:58:43.413]             sys.calls <- base::sys.calls
[10:58:43.413]             `[[` <- base::`[[`
[10:58:43.413]             `+` <- base::`+`
[10:58:43.413]             `<<-` <- base::`<<-`
[10:58:43.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.413]                   3L)]
[10:58:43.413]             }
[10:58:43.413]             function(cond) {
[10:58:43.413]                 is_error <- inherits(cond, "error")
[10:58:43.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.413]                   NULL)
[10:58:43.413]                 if (is_error) {
[10:58:43.413]                   sessionInformation <- function() {
[10:58:43.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.413]                       search = base::search(), system = base::Sys.info())
[10:58:43.413]                   }
[10:58:43.413]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.413]                     cond$call), session = sessionInformation(), 
[10:58:43.413]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.413]                   signalCondition(cond)
[10:58:43.413]                 }
[10:58:43.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.413]                 "immediateCondition"))) {
[10:58:43.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.413]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.413]                   if (TRUE && !signal) {
[10:58:43.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.413]                     {
[10:58:43.413]                       inherits <- base::inherits
[10:58:43.413]                       invokeRestart <- base::invokeRestart
[10:58:43.413]                       is.null <- base::is.null
[10:58:43.413]                       muffled <- FALSE
[10:58:43.413]                       if (inherits(cond, "message")) {
[10:58:43.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.413]                         if (muffled) 
[10:58:43.413]                           invokeRestart("muffleMessage")
[10:58:43.413]                       }
[10:58:43.413]                       else if (inherits(cond, "warning")) {
[10:58:43.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.413]                         if (muffled) 
[10:58:43.413]                           invokeRestart("muffleWarning")
[10:58:43.413]                       }
[10:58:43.413]                       else if (inherits(cond, "condition")) {
[10:58:43.413]                         if (!is.null(pattern)) {
[10:58:43.413]                           computeRestarts <- base::computeRestarts
[10:58:43.413]                           grepl <- base::grepl
[10:58:43.413]                           restarts <- computeRestarts(cond)
[10:58:43.413]                           for (restart in restarts) {
[10:58:43.413]                             name <- restart$name
[10:58:43.413]                             if (is.null(name)) 
[10:58:43.413]                               next
[10:58:43.413]                             if (!grepl(pattern, name)) 
[10:58:43.413]                               next
[10:58:43.413]                             invokeRestart(restart)
[10:58:43.413]                             muffled <- TRUE
[10:58:43.413]                             break
[10:58:43.413]                           }
[10:58:43.413]                         }
[10:58:43.413]                       }
[10:58:43.413]                       invisible(muffled)
[10:58:43.413]                     }
[10:58:43.413]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.413]                   }
[10:58:43.413]                 }
[10:58:43.413]                 else {
[10:58:43.413]                   if (TRUE) {
[10:58:43.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.413]                     {
[10:58:43.413]                       inherits <- base::inherits
[10:58:43.413]                       invokeRestart <- base::invokeRestart
[10:58:43.413]                       is.null <- base::is.null
[10:58:43.413]                       muffled <- FALSE
[10:58:43.413]                       if (inherits(cond, "message")) {
[10:58:43.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.413]                         if (muffled) 
[10:58:43.413]                           invokeRestart("muffleMessage")
[10:58:43.413]                       }
[10:58:43.413]                       else if (inherits(cond, "warning")) {
[10:58:43.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.413]                         if (muffled) 
[10:58:43.413]                           invokeRestart("muffleWarning")
[10:58:43.413]                       }
[10:58:43.413]                       else if (inherits(cond, "condition")) {
[10:58:43.413]                         if (!is.null(pattern)) {
[10:58:43.413]                           computeRestarts <- base::computeRestarts
[10:58:43.413]                           grepl <- base::grepl
[10:58:43.413]                           restarts <- computeRestarts(cond)
[10:58:43.413]                           for (restart in restarts) {
[10:58:43.413]                             name <- restart$name
[10:58:43.413]                             if (is.null(name)) 
[10:58:43.413]                               next
[10:58:43.413]                             if (!grepl(pattern, name)) 
[10:58:43.413]                               next
[10:58:43.413]                             invokeRestart(restart)
[10:58:43.413]                             muffled <- TRUE
[10:58:43.413]                             break
[10:58:43.413]                           }
[10:58:43.413]                         }
[10:58:43.413]                       }
[10:58:43.413]                       invisible(muffled)
[10:58:43.413]                     }
[10:58:43.413]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.413]                   }
[10:58:43.413]                 }
[10:58:43.413]             }
[10:58:43.413]         }))
[10:58:43.413]     }, error = function(ex) {
[10:58:43.413]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.413]                 ...future.rng), started = ...future.startTime, 
[10:58:43.413]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.413]             version = "1.8"), class = "FutureResult")
[10:58:43.413]     }, finally = {
[10:58:43.413]         if (!identical(...future.workdir, getwd())) 
[10:58:43.413]             setwd(...future.workdir)
[10:58:43.413]         {
[10:58:43.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.413]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.413]             }
[10:58:43.413]             base::options(...future.oldOptions)
[10:58:43.413]             if (.Platform$OS.type == "windows") {
[10:58:43.413]                 old_names <- names(...future.oldEnvVars)
[10:58:43.413]                 envs <- base::Sys.getenv()
[10:58:43.413]                 names <- names(envs)
[10:58:43.413]                 common <- intersect(names, old_names)
[10:58:43.413]                 added <- setdiff(names, old_names)
[10:58:43.413]                 removed <- setdiff(old_names, names)
[10:58:43.413]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.413]                   envs[common]]
[10:58:43.413]                 NAMES <- toupper(changed)
[10:58:43.413]                 args <- list()
[10:58:43.413]                 for (kk in seq_along(NAMES)) {
[10:58:43.413]                   name <- changed[[kk]]
[10:58:43.413]                   NAME <- NAMES[[kk]]
[10:58:43.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.413]                     next
[10:58:43.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.413]                 }
[10:58:43.413]                 NAMES <- toupper(added)
[10:58:43.413]                 for (kk in seq_along(NAMES)) {
[10:58:43.413]                   name <- added[[kk]]
[10:58:43.413]                   NAME <- NAMES[[kk]]
[10:58:43.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.413]                     next
[10:58:43.413]                   args[[name]] <- ""
[10:58:43.413]                 }
[10:58:43.413]                 NAMES <- toupper(removed)
[10:58:43.413]                 for (kk in seq_along(NAMES)) {
[10:58:43.413]                   name <- removed[[kk]]
[10:58:43.413]                   NAME <- NAMES[[kk]]
[10:58:43.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.413]                     next
[10:58:43.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.413]                 }
[10:58:43.413]                 if (length(args) > 0) 
[10:58:43.413]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.413]             }
[10:58:43.413]             else {
[10:58:43.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.413]             }
[10:58:43.413]             {
[10:58:43.413]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.413]                   0L) {
[10:58:43.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.413]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.413]                   base::options(opts)
[10:58:43.413]                 }
[10:58:43.413]                 {
[10:58:43.413]                   {
[10:58:43.413]                     NULL
[10:58:43.413]                     RNGkind("Mersenne-Twister")
[10:58:43.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.413]                       inherits = FALSE)
[10:58:43.413]                   }
[10:58:43.413]                   options(future.plan = NULL)
[10:58:43.413]                   if (is.na(NA_character_)) 
[10:58:43.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.413]                     .init = FALSE)
[10:58:43.413]                 }
[10:58:43.413]             }
[10:58:43.413]         }
[10:58:43.413]     })
[10:58:43.413]     if (TRUE) {
[10:58:43.413]         base::sink(type = "output", split = FALSE)
[10:58:43.413]         if (TRUE) {
[10:58:43.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.413]         }
[10:58:43.413]         else {
[10:58:43.413]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.413]         }
[10:58:43.413]         base::close(...future.stdout)
[10:58:43.413]         ...future.stdout <- NULL
[10:58:43.413]     }
[10:58:43.413]     ...future.result$conditions <- ...future.conditions
[10:58:43.413]     ...future.result$finished <- base::Sys.time()
[10:58:43.413]     ...future.result
[10:58:43.413] }
[10:58:43.415] assign_globals() ...
[10:58:43.415] List of 5
[10:58:43.415]  $ ...future.FUN            :function (object, ...)  
[10:58:43.415]  $ future.call.arguments    : list()
[10:58:43.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.415]  $ ...future.elements_ii    :List of 3
[10:58:43.415]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.415]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.415]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.415]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.415]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.415]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.415]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.415]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.415]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.415]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.415]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.415]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.415]  $ ...future.seeds_ii       : NULL
[10:58:43.415]  $ ...future.globals.maxSize: NULL
[10:58:43.415]  - attr(*, "where")=List of 5
[10:58:43.415]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.415]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.415]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.415]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.415]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.415]  - attr(*, "resolved")= logi FALSE
[10:58:43.415]  - attr(*, "total_size")= num 19278
[10:58:43.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.415]  - attr(*, "already-done")= logi TRUE
[10:58:43.425] - copied ‘...future.FUN’ to environment
[10:58:43.425] - copied ‘future.call.arguments’ to environment
[10:58:43.425] - copied ‘...future.elements_ii’ to environment
[10:58:43.426] - copied ‘...future.seeds_ii’ to environment
[10:58:43.426] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.426] assign_globals() ... done
[10:58:43.426] plan(): Setting new future strategy stack:
[10:58:43.426] List of future strategies:
[10:58:43.426] 1. sequential:
[10:58:43.426]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.426]    - tweaked: FALSE
[10:58:43.426]    - call: NULL
[10:58:43.427] plan(): nbrOfWorkers() = 1
[10:58:43.429] plan(): Setting new future strategy stack:
[10:58:43.429] List of future strategies:
[10:58:43.429] 1. multisession:
[10:58:43.429]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.429]    - tweaked: FALSE
[10:58:43.429]    - call: plan(strategy)
[10:58:43.431] plan(): nbrOfWorkers() = 1
[10:58:43.431] SequentialFuture started (and completed)
[10:58:43.431] - Launch lazy future ... done
[10:58:43.431] run() for ‘SequentialFuture’ ... done
[10:58:43.431] Created future:
[10:58:43.431] SequentialFuture:
[10:58:43.431] Label: ‘future_by-1’
[10:58:43.431] Expression:
[10:58:43.431] {
[10:58:43.431]     do.call(function(...) {
[10:58:43.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.431]             on.exit(options(oopts), add = TRUE)
[10:58:43.431]         }
[10:58:43.431]         {
[10:58:43.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.431]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.431]             })
[10:58:43.431]         }
[10:58:43.431]     }, args = future.call.arguments)
[10:58:43.431] }
[10:58:43.431] Lazy evaluation: FALSE
[10:58:43.431] Asynchronous evaluation: FALSE
[10:58:43.431] Local evaluation: TRUE
[10:58:43.431] Environment: 0x55974dc20a48
[10:58:43.431] Capture standard output: TRUE
[10:58:43.431] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.431] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.431] Packages: <none>
[10:58:43.431] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.431] Resolved: TRUE
[10:58:43.431] Value: 1.39 KiB of class ‘list’
[10:58:43.431] Early signaling: FALSE
[10:58:43.431] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.431] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.432] Chunk #1 of 1 ... DONE
[10:58:43.432] Launching 1 futures (chunks) ... DONE
[10:58:43.432] Resolving 1 futures (chunks) ...
[10:58:43.432] resolve() on list ...
[10:58:43.433]  recursive: 0
[10:58:43.433]  length: 1
[10:58:43.433] 
[10:58:43.433] resolved() for ‘SequentialFuture’ ...
[10:58:43.433] - state: ‘finished’
[10:58:43.433] - run: TRUE
[10:58:43.433] - result: ‘FutureResult’
[10:58:43.433] resolved() for ‘SequentialFuture’ ... done
[10:58:43.433] Future #1
[10:58:43.433] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.434] - nx: 1
[10:58:43.434] - relay: TRUE
[10:58:43.434] - stdout: TRUE
[10:58:43.434] - signal: TRUE
[10:58:43.434] - resignal: FALSE
[10:58:43.434] - force: TRUE
[10:58:43.434] - relayed: [n=1] FALSE
[10:58:43.434] - queued futures: [n=1] FALSE
[10:58:43.434]  - until=1
[10:58:43.434]  - relaying element #1
[10:58:43.435] - relayed: [n=1] TRUE
[10:58:43.435] - queued futures: [n=1] TRUE
[10:58:43.435] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.435]  length: 0 (resolved future 1)
[10:58:43.435] Relaying remaining futures
[10:58:43.435] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.435] - nx: 1
[10:58:43.435] - relay: TRUE
[10:58:43.435] - stdout: TRUE
[10:58:43.435] - signal: TRUE
[10:58:43.435] - resignal: FALSE
[10:58:43.436] - force: TRUE
[10:58:43.436] - relayed: [n=1] TRUE
[10:58:43.436] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.436] - relayed: [n=1] TRUE
[10:58:43.436] - queued futures: [n=1] TRUE
[10:58:43.436] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.436] resolve() on list ... DONE
[10:58:43.436]  - Number of value chunks collected: 1
[10:58:43.436] Resolving 1 futures (chunks) ... DONE
[10:58:43.436] Reducing values from 1 chunks ...
[10:58:43.437]  - Number of values collected after concatenation: 3
[10:58:43.437]  - Number of values expected: 3
[10:58:43.437] Reducing values from 1 chunks ... DONE
[10:58:43.437] future_lapply() ... DONE
[10:58:43.437] future_by_internal() ... DONE
[10:58:43.438] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:58:43.438] future_lapply() ...
[10:58:43.442] Number of chunks: 1
[10:58:43.442] getGlobalsAndPackagesXApply() ...
[10:58:43.442]  - future.globals: TRUE
[10:58:43.442] getGlobalsAndPackages() ...
[10:58:43.442] Searching for globals...
[10:58:43.443] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.443] Searching for globals ... DONE
[10:58:43.444] Resolving globals: FALSE
[10:58:43.444] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.444] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.444] - globals: [1] ‘FUN’
[10:58:43.444] 
[10:58:43.444] getGlobalsAndPackages() ... DONE
[10:58:43.445]  - globals found/used: [n=1] ‘FUN’
[10:58:43.445]  - needed namespaces: [n=0] 
[10:58:43.445] Finding globals ... DONE
[10:58:43.445]  - use_args: TRUE
[10:58:43.445]  - Getting '...' globals ...
[10:58:43.445] resolve() on list ...
[10:58:43.445]  recursive: 0
[10:58:43.445]  length: 1
[10:58:43.446]  elements: ‘...’
[10:58:43.446]  length: 0 (resolved future 1)
[10:58:43.446] resolve() on list ... DONE
[10:58:43.446]    - '...' content: [n=0] 
[10:58:43.446] List of 1
[10:58:43.446]  $ ...: list()
[10:58:43.446]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.446]  - attr(*, "where")=List of 1
[10:58:43.446]   ..$ ...:<environment: 0x55974df293f8> 
[10:58:43.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.446]  - attr(*, "resolved")= logi TRUE
[10:58:43.446]  - attr(*, "total_size")= num NA
[10:58:43.448]  - Getting '...' globals ... DONE
[10:58:43.449] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.449] List of 2
[10:58:43.449]  $ ...future.FUN:function (object, ...)  
[10:58:43.449]  $ ...          : list()
[10:58:43.449]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.449]  - attr(*, "where")=List of 2
[10:58:43.449]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.449]   ..$ ...          :<environment: 0x55974df293f8> 
[10:58:43.449]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.449]  - attr(*, "resolved")= logi FALSE
[10:58:43.449]  - attr(*, "total_size")= num 18647
[10:58:43.451] Packages to be attached in all futures: [n=0] 
[10:58:43.451] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.452] Number of futures (= number of chunks): 1
[10:58:43.452] Launching 1 futures (chunks) ...
[10:58:43.452] Chunk #1 of 1 ...
[10:58:43.452]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.452] getGlobalsAndPackages() ...
[10:58:43.452] Searching for globals...
[10:58:43.453] 
[10:58:43.453] Searching for globals ... DONE
[10:58:43.453] - globals: [0] <none>
[10:58:43.453] getGlobalsAndPackages() ... DONE
[10:58:43.453]    + additional globals found: [n=0] 
[10:58:43.453]    + additional namespaces needed: [n=0] 
[10:58:43.453]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.453]  - seeds: <none>
[10:58:43.453]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.453] getGlobalsAndPackages() ...
[10:58:43.453] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.454] Resolving globals: FALSE
[10:58:43.454] Tweak future expression to call with '...' arguments ...
[10:58:43.454] {
[10:58:43.454]     do.call(function(...) {
[10:58:43.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.454]             on.exit(options(oopts), add = TRUE)
[10:58:43.454]         }
[10:58:43.454]         {
[10:58:43.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.454]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.454]             })
[10:58:43.454]         }
[10:58:43.454]     }, args = future.call.arguments)
[10:58:43.454] }
[10:58:43.454] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.454] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.455] 
[10:58:43.455] getGlobalsAndPackages() ... DONE
[10:58:43.455] run() for ‘Future’ ...
[10:58:43.455] - state: ‘created’
[10:58:43.455] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.457]   - Field: ‘label’
[10:58:43.457]   - Field: ‘local’
[10:58:43.457]   - Field: ‘owner’
[10:58:43.457]   - Field: ‘envir’
[10:58:43.457]   - Field: ‘packages’
[10:58:43.457]   - Field: ‘gc’
[10:58:43.457]   - Field: ‘conditions’
[10:58:43.458]   - Field: ‘expr’
[10:58:43.458]   - Field: ‘uuid’
[10:58:43.458]   - Field: ‘seed’
[10:58:43.458]   - Field: ‘version’
[10:58:43.458]   - Field: ‘result’
[10:58:43.458]   - Field: ‘asynchronous’
[10:58:43.458]   - Field: ‘calls’
[10:58:43.458]   - Field: ‘globals’
[10:58:43.458]   - Field: ‘stdout’
[10:58:43.458]   - Field: ‘earlySignal’
[10:58:43.458]   - Field: ‘lazy’
[10:58:43.459]   - Field: ‘state’
[10:58:43.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.459] - Launch lazy future ...
[10:58:43.459] Packages needed by the future expression (n = 0): <none>
[10:58:43.459] Packages needed by future strategies (n = 0): <none>
[10:58:43.459] {
[10:58:43.459]     {
[10:58:43.459]         {
[10:58:43.459]             ...future.startTime <- base::Sys.time()
[10:58:43.459]             {
[10:58:43.459]                 {
[10:58:43.459]                   {
[10:58:43.459]                     base::local({
[10:58:43.459]                       has_future <- base::requireNamespace("future", 
[10:58:43.459]                         quietly = TRUE)
[10:58:43.459]                       if (has_future) {
[10:58:43.459]                         ns <- base::getNamespace("future")
[10:58:43.459]                         version <- ns[[".package"]][["version"]]
[10:58:43.459]                         if (is.null(version)) 
[10:58:43.459]                           version <- utils::packageVersion("future")
[10:58:43.459]                       }
[10:58:43.459]                       else {
[10:58:43.459]                         version <- NULL
[10:58:43.459]                       }
[10:58:43.459]                       if (!has_future || version < "1.8.0") {
[10:58:43.459]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.459]                           "", base::R.version$version.string), 
[10:58:43.459]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.459]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.459]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.459]                             "release", "version")], collapse = " "), 
[10:58:43.459]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.459]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.459]                           info)
[10:58:43.459]                         info <- base::paste(info, collapse = "; ")
[10:58:43.459]                         if (!has_future) {
[10:58:43.459]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.459]                             info)
[10:58:43.459]                         }
[10:58:43.459]                         else {
[10:58:43.459]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.459]                             info, version)
[10:58:43.459]                         }
[10:58:43.459]                         base::stop(msg)
[10:58:43.459]                       }
[10:58:43.459]                     })
[10:58:43.459]                   }
[10:58:43.459]                   ...future.strategy.old <- future::plan("list")
[10:58:43.459]                   options(future.plan = NULL)
[10:58:43.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.459]                 }
[10:58:43.459]                 ...future.workdir <- getwd()
[10:58:43.459]             }
[10:58:43.459]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.459]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.459]         }
[10:58:43.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.459]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.459]             base::names(...future.oldOptions))
[10:58:43.459]     }
[10:58:43.459]     if (FALSE) {
[10:58:43.459]     }
[10:58:43.459]     else {
[10:58:43.459]         if (TRUE) {
[10:58:43.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.459]                 open = "w")
[10:58:43.459]         }
[10:58:43.459]         else {
[10:58:43.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.459]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.459]         }
[10:58:43.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.459]             base::sink(type = "output", split = FALSE)
[10:58:43.459]             base::close(...future.stdout)
[10:58:43.459]         }, add = TRUE)
[10:58:43.459]     }
[10:58:43.459]     ...future.frame <- base::sys.nframe()
[10:58:43.459]     ...future.conditions <- base::list()
[10:58:43.459]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.459]     if (FALSE) {
[10:58:43.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.459]     }
[10:58:43.459]     ...future.result <- base::tryCatch({
[10:58:43.459]         base::withCallingHandlers({
[10:58:43.459]             ...future.value <- base::withVisible(base::local({
[10:58:43.459]                 do.call(function(...) {
[10:58:43.459]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.459]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.459]                     ...future.globals.maxSize)) {
[10:58:43.459]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.459]                     on.exit(options(oopts), add = TRUE)
[10:58:43.459]                   }
[10:58:43.459]                   {
[10:58:43.459]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.459]                       FUN = function(jj) {
[10:58:43.459]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.459]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.459]                       })
[10:58:43.459]                   }
[10:58:43.459]                 }, args = future.call.arguments)
[10:58:43.459]             }))
[10:58:43.459]             future::FutureResult(value = ...future.value$value, 
[10:58:43.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.459]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.459]                     ...future.globalenv.names))
[10:58:43.459]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.459]         }, condition = base::local({
[10:58:43.459]             c <- base::c
[10:58:43.459]             inherits <- base::inherits
[10:58:43.459]             invokeRestart <- base::invokeRestart
[10:58:43.459]             length <- base::length
[10:58:43.459]             list <- base::list
[10:58:43.459]             seq.int <- base::seq.int
[10:58:43.459]             signalCondition <- base::signalCondition
[10:58:43.459]             sys.calls <- base::sys.calls
[10:58:43.459]             `[[` <- base::`[[`
[10:58:43.459]             `+` <- base::`+`
[10:58:43.459]             `<<-` <- base::`<<-`
[10:58:43.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.459]                   3L)]
[10:58:43.459]             }
[10:58:43.459]             function(cond) {
[10:58:43.459]                 is_error <- inherits(cond, "error")
[10:58:43.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.459]                   NULL)
[10:58:43.459]                 if (is_error) {
[10:58:43.459]                   sessionInformation <- function() {
[10:58:43.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.459]                       search = base::search(), system = base::Sys.info())
[10:58:43.459]                   }
[10:58:43.459]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.459]                     cond$call), session = sessionInformation(), 
[10:58:43.459]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.459]                   signalCondition(cond)
[10:58:43.459]                 }
[10:58:43.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.459]                 "immediateCondition"))) {
[10:58:43.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.459]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.459]                   if (TRUE && !signal) {
[10:58:43.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.459]                     {
[10:58:43.459]                       inherits <- base::inherits
[10:58:43.459]                       invokeRestart <- base::invokeRestart
[10:58:43.459]                       is.null <- base::is.null
[10:58:43.459]                       muffled <- FALSE
[10:58:43.459]                       if (inherits(cond, "message")) {
[10:58:43.459]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.459]                         if (muffled) 
[10:58:43.459]                           invokeRestart("muffleMessage")
[10:58:43.459]                       }
[10:58:43.459]                       else if (inherits(cond, "warning")) {
[10:58:43.459]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.459]                         if (muffled) 
[10:58:43.459]                           invokeRestart("muffleWarning")
[10:58:43.459]                       }
[10:58:43.459]                       else if (inherits(cond, "condition")) {
[10:58:43.459]                         if (!is.null(pattern)) {
[10:58:43.459]                           computeRestarts <- base::computeRestarts
[10:58:43.459]                           grepl <- base::grepl
[10:58:43.459]                           restarts <- computeRestarts(cond)
[10:58:43.459]                           for (restart in restarts) {
[10:58:43.459]                             name <- restart$name
[10:58:43.459]                             if (is.null(name)) 
[10:58:43.459]                               next
[10:58:43.459]                             if (!grepl(pattern, name)) 
[10:58:43.459]                               next
[10:58:43.459]                             invokeRestart(restart)
[10:58:43.459]                             muffled <- TRUE
[10:58:43.459]                             break
[10:58:43.459]                           }
[10:58:43.459]                         }
[10:58:43.459]                       }
[10:58:43.459]                       invisible(muffled)
[10:58:43.459]                     }
[10:58:43.459]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.459]                   }
[10:58:43.459]                 }
[10:58:43.459]                 else {
[10:58:43.459]                   if (TRUE) {
[10:58:43.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.459]                     {
[10:58:43.459]                       inherits <- base::inherits
[10:58:43.459]                       invokeRestart <- base::invokeRestart
[10:58:43.459]                       is.null <- base::is.null
[10:58:43.459]                       muffled <- FALSE
[10:58:43.459]                       if (inherits(cond, "message")) {
[10:58:43.459]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.459]                         if (muffled) 
[10:58:43.459]                           invokeRestart("muffleMessage")
[10:58:43.459]                       }
[10:58:43.459]                       else if (inherits(cond, "warning")) {
[10:58:43.459]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.459]                         if (muffled) 
[10:58:43.459]                           invokeRestart("muffleWarning")
[10:58:43.459]                       }
[10:58:43.459]                       else if (inherits(cond, "condition")) {
[10:58:43.459]                         if (!is.null(pattern)) {
[10:58:43.459]                           computeRestarts <- base::computeRestarts
[10:58:43.459]                           grepl <- base::grepl
[10:58:43.459]                           restarts <- computeRestarts(cond)
[10:58:43.459]                           for (restart in restarts) {
[10:58:43.459]                             name <- restart$name
[10:58:43.459]                             if (is.null(name)) 
[10:58:43.459]                               next
[10:58:43.459]                             if (!grepl(pattern, name)) 
[10:58:43.459]                               next
[10:58:43.459]                             invokeRestart(restart)
[10:58:43.459]                             muffled <- TRUE
[10:58:43.459]                             break
[10:58:43.459]                           }
[10:58:43.459]                         }
[10:58:43.459]                       }
[10:58:43.459]                       invisible(muffled)
[10:58:43.459]                     }
[10:58:43.459]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.459]                   }
[10:58:43.459]                 }
[10:58:43.459]             }
[10:58:43.459]         }))
[10:58:43.459]     }, error = function(ex) {
[10:58:43.459]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.459]                 ...future.rng), started = ...future.startTime, 
[10:58:43.459]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.459]             version = "1.8"), class = "FutureResult")
[10:58:43.459]     }, finally = {
[10:58:43.459]         if (!identical(...future.workdir, getwd())) 
[10:58:43.459]             setwd(...future.workdir)
[10:58:43.459]         {
[10:58:43.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.459]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.459]             }
[10:58:43.459]             base::options(...future.oldOptions)
[10:58:43.459]             if (.Platform$OS.type == "windows") {
[10:58:43.459]                 old_names <- names(...future.oldEnvVars)
[10:58:43.459]                 envs <- base::Sys.getenv()
[10:58:43.459]                 names <- names(envs)
[10:58:43.459]                 common <- intersect(names, old_names)
[10:58:43.459]                 added <- setdiff(names, old_names)
[10:58:43.459]                 removed <- setdiff(old_names, names)
[10:58:43.459]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.459]                   envs[common]]
[10:58:43.459]                 NAMES <- toupper(changed)
[10:58:43.459]                 args <- list()
[10:58:43.459]                 for (kk in seq_along(NAMES)) {
[10:58:43.459]                   name <- changed[[kk]]
[10:58:43.459]                   NAME <- NAMES[[kk]]
[10:58:43.459]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.459]                     next
[10:58:43.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.459]                 }
[10:58:43.459]                 NAMES <- toupper(added)
[10:58:43.459]                 for (kk in seq_along(NAMES)) {
[10:58:43.459]                   name <- added[[kk]]
[10:58:43.459]                   NAME <- NAMES[[kk]]
[10:58:43.459]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.459]                     next
[10:58:43.459]                   args[[name]] <- ""
[10:58:43.459]                 }
[10:58:43.459]                 NAMES <- toupper(removed)
[10:58:43.459]                 for (kk in seq_along(NAMES)) {
[10:58:43.459]                   name <- removed[[kk]]
[10:58:43.459]                   NAME <- NAMES[[kk]]
[10:58:43.459]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.459]                     next
[10:58:43.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.459]                 }
[10:58:43.459]                 if (length(args) > 0) 
[10:58:43.459]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.459]             }
[10:58:43.459]             else {
[10:58:43.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.459]             }
[10:58:43.459]             {
[10:58:43.459]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.459]                   0L) {
[10:58:43.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.459]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.459]                   base::options(opts)
[10:58:43.459]                 }
[10:58:43.459]                 {
[10:58:43.459]                   {
[10:58:43.459]                     NULL
[10:58:43.459]                     RNGkind("Mersenne-Twister")
[10:58:43.459]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.459]                       inherits = FALSE)
[10:58:43.459]                   }
[10:58:43.459]                   options(future.plan = NULL)
[10:58:43.459]                   if (is.na(NA_character_)) 
[10:58:43.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.459]                     .init = FALSE)
[10:58:43.459]                 }
[10:58:43.459]             }
[10:58:43.459]         }
[10:58:43.459]     })
[10:58:43.459]     if (TRUE) {
[10:58:43.459]         base::sink(type = "output", split = FALSE)
[10:58:43.459]         if (TRUE) {
[10:58:43.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.459]         }
[10:58:43.459]         else {
[10:58:43.459]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.459]         }
[10:58:43.459]         base::close(...future.stdout)
[10:58:43.459]         ...future.stdout <- NULL
[10:58:43.459]     }
[10:58:43.459]     ...future.result$conditions <- ...future.conditions
[10:58:43.459]     ...future.result$finished <- base::Sys.time()
[10:58:43.459]     ...future.result
[10:58:43.459] }
[10:58:43.463] assign_globals() ...
[10:58:43.463] List of 5
[10:58:43.463]  $ ...future.FUN            :function (object, ...)  
[10:58:43.463]  $ future.call.arguments    : list()
[10:58:43.463]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.463]  $ ...future.elements_ii    :List of 3
[10:58:43.463]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.463]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.463]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.463]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.463]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.463]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.463]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.463]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.463]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.463]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.463]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.463]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.463]  $ ...future.seeds_ii       : NULL
[10:58:43.463]  $ ...future.globals.maxSize: NULL
[10:58:43.463]  - attr(*, "where")=List of 5
[10:58:43.463]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.463]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.463]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.463]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.463]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.463]  - attr(*, "resolved")= logi FALSE
[10:58:43.463]  - attr(*, "total_size")= num 18647
[10:58:43.463]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.463]  - attr(*, "already-done")= logi TRUE
[10:58:43.472] - copied ‘...future.FUN’ to environment
[10:58:43.472] - copied ‘future.call.arguments’ to environment
[10:58:43.472] - copied ‘...future.elements_ii’ to environment
[10:58:43.472] - copied ‘...future.seeds_ii’ to environment
[10:58:43.472] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.472] assign_globals() ... done
[10:58:43.472] plan(): Setting new future strategy stack:
[10:58:43.473] List of future strategies:
[10:58:43.473] 1. sequential:
[10:58:43.473]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.473]    - tweaked: FALSE
[10:58:43.473]    - call: NULL
[10:58:43.473] plan(): nbrOfWorkers() = 1
[10:58:43.475] plan(): Setting new future strategy stack:
[10:58:43.475] List of future strategies:
[10:58:43.475] 1. multisession:
[10:58:43.475]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:43.475]    - tweaked: FALSE
[10:58:43.475]    - call: plan(strategy)
[10:58:43.477] plan(): nbrOfWorkers() = 1
[10:58:43.477] SequentialFuture started (and completed)
[10:58:43.477] - Launch lazy future ... done
[10:58:43.477] run() for ‘SequentialFuture’ ... done
[10:58:43.477] Created future:
[10:58:43.478] SequentialFuture:
[10:58:43.478] Label: ‘future_by-1’
[10:58:43.478] Expression:
[10:58:43.478] {
[10:58:43.478]     do.call(function(...) {
[10:58:43.478]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.478]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.478]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.478]             on.exit(options(oopts), add = TRUE)
[10:58:43.478]         }
[10:58:43.478]         {
[10:58:43.478]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.478]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.478]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.478]             })
[10:58:43.478]         }
[10:58:43.478]     }, args = future.call.arguments)
[10:58:43.478] }
[10:58:43.478] Lazy evaluation: FALSE
[10:58:43.478] Asynchronous evaluation: FALSE
[10:58:43.478] Local evaluation: TRUE
[10:58:43.478] Environment: 0x55974dea1558
[10:58:43.478] Capture standard output: TRUE
[10:58:43.478] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.478] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.478] Packages: <none>
[10:58:43.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.478] Resolved: TRUE
[10:58:43.478] Value: 1.39 KiB of class ‘list’
[10:58:43.478] Early signaling: FALSE
[10:58:43.478] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.478] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.478] Chunk #1 of 1 ... DONE
[10:58:43.479] Launching 1 futures (chunks) ... DONE
[10:58:43.479] Resolving 1 futures (chunks) ...
[10:58:43.479] resolve() on list ...
[10:58:43.479]  recursive: 0
[10:58:43.479]  length: 1
[10:58:43.479] 
[10:58:43.479] resolved() for ‘SequentialFuture’ ...
[10:58:43.479] - state: ‘finished’
[10:58:43.479] - run: TRUE
[10:58:43.479] - result: ‘FutureResult’
[10:58:43.479] resolved() for ‘SequentialFuture’ ... done
[10:58:43.480] Future #1
[10:58:43.480] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.480] - nx: 1
[10:58:43.480] - relay: TRUE
[10:58:43.480] - stdout: TRUE
[10:58:43.480] - signal: TRUE
[10:58:43.480] - resignal: FALSE
[10:58:43.480] - force: TRUE
[10:58:43.480] - relayed: [n=1] FALSE
[10:58:43.480] - queued futures: [n=1] FALSE
[10:58:43.480]  - until=1
[10:58:43.481]  - relaying element #1
[10:58:43.481] - relayed: [n=1] TRUE
[10:58:43.481] - queued futures: [n=1] TRUE
[10:58:43.481] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.481]  length: 0 (resolved future 1)
[10:58:43.481] Relaying remaining futures
[10:58:43.484] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.484] - nx: 1
[10:58:43.485] - relay: TRUE
[10:58:43.485] - stdout: TRUE
[10:58:43.485] - signal: TRUE
[10:58:43.485] - resignal: FALSE
[10:58:43.485] - force: TRUE
[10:58:43.485] - relayed: [n=1] TRUE
[10:58:43.485] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.485] - relayed: [n=1] TRUE
[10:58:43.485] - queued futures: [n=1] TRUE
[10:58:43.485] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.485] resolve() on list ... DONE
[10:58:43.486]  - Number of value chunks collected: 1
[10:58:43.486] Resolving 1 futures (chunks) ... DONE
[10:58:43.486] Reducing values from 1 chunks ...
[10:58:43.486]  - Number of values collected after concatenation: 3
[10:58:43.486]  - Number of values expected: 3
[10:58:43.486] Reducing values from 1 chunks ... DONE
[10:58:43.486] future_lapply() ... DONE
[10:58:43.486] future_by_internal() ... DONE
[10:58:43.487] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[10:58:43.488] plan(): Setting new future strategy stack:
[10:58:43.488] List of future strategies:
[10:58:43.488] 1. sequential:
[10:58:43.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.488]    - tweaked: FALSE
[10:58:43.488]    - call: plan(strategy)
[10:58:43.489] plan(): nbrOfWorkers() = 1
[10:58:43.489] future_by_internal() ...
[10:58:43.489] future_lapply() ...
[10:58:43.490] Number of chunks: 1
[10:58:43.490] getGlobalsAndPackagesXApply() ...
[10:58:43.490]  - future.globals: TRUE
[10:58:43.490] getGlobalsAndPackages() ...
[10:58:43.490] Searching for globals...
[10:58:43.491] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.491] Searching for globals ... DONE
[10:58:43.491] Resolving globals: FALSE
[10:58:43.492] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.492] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.492] - globals: [1] ‘FUN’
[10:58:43.492] 
[10:58:43.492] getGlobalsAndPackages() ... DONE
[10:58:43.492]  - globals found/used: [n=1] ‘FUN’
[10:58:43.492]  - needed namespaces: [n=0] 
[10:58:43.492] Finding globals ... DONE
[10:58:43.493]  - use_args: TRUE
[10:58:43.493]  - Getting '...' globals ...
[10:58:43.493] resolve() on list ...
[10:58:43.493]  recursive: 0
[10:58:43.493]  length: 1
[10:58:43.493]  elements: ‘...’
[10:58:43.493]  length: 0 (resolved future 1)
[10:58:43.493] resolve() on list ... DONE
[10:58:43.494]    - '...' content: [n=0] 
[10:58:43.494] List of 1
[10:58:43.494]  $ ...: list()
[10:58:43.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.494]  - attr(*, "where")=List of 1
[10:58:43.494]   ..$ ...:<environment: 0x55974cfec1a0> 
[10:58:43.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.494]  - attr(*, "resolved")= logi TRUE
[10:58:43.494]  - attr(*, "total_size")= num NA
[10:58:43.496]  - Getting '...' globals ... DONE
[10:58:43.496] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.496] List of 2
[10:58:43.496]  $ ...future.FUN:function (object, ...)  
[10:58:43.496]  $ ...          : list()
[10:58:43.496]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.496]  - attr(*, "where")=List of 2
[10:58:43.496]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.496]   ..$ ...          :<environment: 0x55974cfec1a0> 
[10:58:43.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.496]  - attr(*, "resolved")= logi FALSE
[10:58:43.496]  - attr(*, "total_size")= num 15670
[10:58:43.499] Packages to be attached in all futures: [n=0] 
[10:58:43.499] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.499] Number of futures (= number of chunks): 1
[10:58:43.499] Launching 1 futures (chunks) ...
[10:58:43.499] Chunk #1 of 1 ...
[10:58:43.499]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.500] getGlobalsAndPackages() ...
[10:58:43.500] Searching for globals...
[10:58:43.500] 
[10:58:43.500] Searching for globals ... DONE
[10:58:43.500] - globals: [0] <none>
[10:58:43.500] getGlobalsAndPackages() ... DONE
[10:58:43.500]    + additional globals found: [n=0] 
[10:58:43.500]    + additional namespaces needed: [n=0] 
[10:58:43.501]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.501]  - seeds: <none>
[10:58:43.501]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.501] getGlobalsAndPackages() ...
[10:58:43.501] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.501] Resolving globals: FALSE
[10:58:43.501] Tweak future expression to call with '...' arguments ...
[10:58:43.501] {
[10:58:43.501]     do.call(function(...) {
[10:58:43.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.501]             on.exit(options(oopts), add = TRUE)
[10:58:43.501]         }
[10:58:43.501]         {
[10:58:43.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.501]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.501]             })
[10:58:43.501]         }
[10:58:43.501]     }, args = future.call.arguments)
[10:58:43.501] }
[10:58:43.501] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.502] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.502] 
[10:58:43.502] getGlobalsAndPackages() ... DONE
[10:58:43.502] run() for ‘Future’ ...
[10:58:43.502] - state: ‘created’
[10:58:43.502] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:43.503] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.503]   - Field: ‘label’
[10:58:43.503]   - Field: ‘local’
[10:58:43.503]   - Field: ‘owner’
[10:58:43.503]   - Field: ‘envir’
[10:58:43.503]   - Field: ‘packages’
[10:58:43.503]   - Field: ‘gc’
[10:58:43.503]   - Field: ‘conditions’
[10:58:43.504]   - Field: ‘expr’
[10:58:43.504]   - Field: ‘uuid’
[10:58:43.504]   - Field: ‘seed’
[10:58:43.504]   - Field: ‘version’
[10:58:43.504]   - Field: ‘result’
[10:58:43.504]   - Field: ‘asynchronous’
[10:58:43.504]   - Field: ‘calls’
[10:58:43.504]   - Field: ‘globals’
[10:58:43.505]   - Field: ‘stdout’
[10:58:43.506]   - Field: ‘earlySignal’
[10:58:43.506]   - Field: ‘lazy’
[10:58:43.506]   - Field: ‘state’
[10:58:43.506] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.506] - Launch lazy future ...
[10:58:43.506] Packages needed by the future expression (n = 0): <none>
[10:58:43.506] Packages needed by future strategies (n = 0): <none>
[10:58:43.507] {
[10:58:43.507]     {
[10:58:43.507]         {
[10:58:43.507]             ...future.startTime <- base::Sys.time()
[10:58:43.507]             {
[10:58:43.507]                 {
[10:58:43.507]                   {
[10:58:43.507]                     base::local({
[10:58:43.507]                       has_future <- base::requireNamespace("future", 
[10:58:43.507]                         quietly = TRUE)
[10:58:43.507]                       if (has_future) {
[10:58:43.507]                         ns <- base::getNamespace("future")
[10:58:43.507]                         version <- ns[[".package"]][["version"]]
[10:58:43.507]                         if (is.null(version)) 
[10:58:43.507]                           version <- utils::packageVersion("future")
[10:58:43.507]                       }
[10:58:43.507]                       else {
[10:58:43.507]                         version <- NULL
[10:58:43.507]                       }
[10:58:43.507]                       if (!has_future || version < "1.8.0") {
[10:58:43.507]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.507]                           "", base::R.version$version.string), 
[10:58:43.507]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.507]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.507]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.507]                             "release", "version")], collapse = " "), 
[10:58:43.507]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.507]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.507]                           info)
[10:58:43.507]                         info <- base::paste(info, collapse = "; ")
[10:58:43.507]                         if (!has_future) {
[10:58:43.507]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.507]                             info)
[10:58:43.507]                         }
[10:58:43.507]                         else {
[10:58:43.507]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.507]                             info, version)
[10:58:43.507]                         }
[10:58:43.507]                         base::stop(msg)
[10:58:43.507]                       }
[10:58:43.507]                     })
[10:58:43.507]                   }
[10:58:43.507]                   ...future.strategy.old <- future::plan("list")
[10:58:43.507]                   options(future.plan = NULL)
[10:58:43.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.507]                 }
[10:58:43.507]                 ...future.workdir <- getwd()
[10:58:43.507]             }
[10:58:43.507]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.507]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.507]         }
[10:58:43.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.507]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.507]             base::names(...future.oldOptions))
[10:58:43.507]     }
[10:58:43.507]     if (FALSE) {
[10:58:43.507]     }
[10:58:43.507]     else {
[10:58:43.507]         if (TRUE) {
[10:58:43.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.507]                 open = "w")
[10:58:43.507]         }
[10:58:43.507]         else {
[10:58:43.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.507]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.507]         }
[10:58:43.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.507]             base::sink(type = "output", split = FALSE)
[10:58:43.507]             base::close(...future.stdout)
[10:58:43.507]         }, add = TRUE)
[10:58:43.507]     }
[10:58:43.507]     ...future.frame <- base::sys.nframe()
[10:58:43.507]     ...future.conditions <- base::list()
[10:58:43.507]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.507]     if (FALSE) {
[10:58:43.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.507]     }
[10:58:43.507]     ...future.result <- base::tryCatch({
[10:58:43.507]         base::withCallingHandlers({
[10:58:43.507]             ...future.value <- base::withVisible(base::local({
[10:58:43.507]                 do.call(function(...) {
[10:58:43.507]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.507]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.507]                     ...future.globals.maxSize)) {
[10:58:43.507]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.507]                     on.exit(options(oopts), add = TRUE)
[10:58:43.507]                   }
[10:58:43.507]                   {
[10:58:43.507]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.507]                       FUN = function(jj) {
[10:58:43.507]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.507]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.507]                       })
[10:58:43.507]                   }
[10:58:43.507]                 }, args = future.call.arguments)
[10:58:43.507]             }))
[10:58:43.507]             future::FutureResult(value = ...future.value$value, 
[10:58:43.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.507]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.507]                     ...future.globalenv.names))
[10:58:43.507]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.507]         }, condition = base::local({
[10:58:43.507]             c <- base::c
[10:58:43.507]             inherits <- base::inherits
[10:58:43.507]             invokeRestart <- base::invokeRestart
[10:58:43.507]             length <- base::length
[10:58:43.507]             list <- base::list
[10:58:43.507]             seq.int <- base::seq.int
[10:58:43.507]             signalCondition <- base::signalCondition
[10:58:43.507]             sys.calls <- base::sys.calls
[10:58:43.507]             `[[` <- base::`[[`
[10:58:43.507]             `+` <- base::`+`
[10:58:43.507]             `<<-` <- base::`<<-`
[10:58:43.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.507]                   3L)]
[10:58:43.507]             }
[10:58:43.507]             function(cond) {
[10:58:43.507]                 is_error <- inherits(cond, "error")
[10:58:43.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.507]                   NULL)
[10:58:43.507]                 if (is_error) {
[10:58:43.507]                   sessionInformation <- function() {
[10:58:43.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.507]                       search = base::search(), system = base::Sys.info())
[10:58:43.507]                   }
[10:58:43.507]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.507]                     cond$call), session = sessionInformation(), 
[10:58:43.507]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.507]                   signalCondition(cond)
[10:58:43.507]                 }
[10:58:43.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.507]                 "immediateCondition"))) {
[10:58:43.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.507]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.507]                   if (TRUE && !signal) {
[10:58:43.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.507]                     {
[10:58:43.507]                       inherits <- base::inherits
[10:58:43.507]                       invokeRestart <- base::invokeRestart
[10:58:43.507]                       is.null <- base::is.null
[10:58:43.507]                       muffled <- FALSE
[10:58:43.507]                       if (inherits(cond, "message")) {
[10:58:43.507]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.507]                         if (muffled) 
[10:58:43.507]                           invokeRestart("muffleMessage")
[10:58:43.507]                       }
[10:58:43.507]                       else if (inherits(cond, "warning")) {
[10:58:43.507]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.507]                         if (muffled) 
[10:58:43.507]                           invokeRestart("muffleWarning")
[10:58:43.507]                       }
[10:58:43.507]                       else if (inherits(cond, "condition")) {
[10:58:43.507]                         if (!is.null(pattern)) {
[10:58:43.507]                           computeRestarts <- base::computeRestarts
[10:58:43.507]                           grepl <- base::grepl
[10:58:43.507]                           restarts <- computeRestarts(cond)
[10:58:43.507]                           for (restart in restarts) {
[10:58:43.507]                             name <- restart$name
[10:58:43.507]                             if (is.null(name)) 
[10:58:43.507]                               next
[10:58:43.507]                             if (!grepl(pattern, name)) 
[10:58:43.507]                               next
[10:58:43.507]                             invokeRestart(restart)
[10:58:43.507]                             muffled <- TRUE
[10:58:43.507]                             break
[10:58:43.507]                           }
[10:58:43.507]                         }
[10:58:43.507]                       }
[10:58:43.507]                       invisible(muffled)
[10:58:43.507]                     }
[10:58:43.507]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.507]                   }
[10:58:43.507]                 }
[10:58:43.507]                 else {
[10:58:43.507]                   if (TRUE) {
[10:58:43.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.507]                     {
[10:58:43.507]                       inherits <- base::inherits
[10:58:43.507]                       invokeRestart <- base::invokeRestart
[10:58:43.507]                       is.null <- base::is.null
[10:58:43.507]                       muffled <- FALSE
[10:58:43.507]                       if (inherits(cond, "message")) {
[10:58:43.507]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.507]                         if (muffled) 
[10:58:43.507]                           invokeRestart("muffleMessage")
[10:58:43.507]                       }
[10:58:43.507]                       else if (inherits(cond, "warning")) {
[10:58:43.507]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.507]                         if (muffled) 
[10:58:43.507]                           invokeRestart("muffleWarning")
[10:58:43.507]                       }
[10:58:43.507]                       else if (inherits(cond, "condition")) {
[10:58:43.507]                         if (!is.null(pattern)) {
[10:58:43.507]                           computeRestarts <- base::computeRestarts
[10:58:43.507]                           grepl <- base::grepl
[10:58:43.507]                           restarts <- computeRestarts(cond)
[10:58:43.507]                           for (restart in restarts) {
[10:58:43.507]                             name <- restart$name
[10:58:43.507]                             if (is.null(name)) 
[10:58:43.507]                               next
[10:58:43.507]                             if (!grepl(pattern, name)) 
[10:58:43.507]                               next
[10:58:43.507]                             invokeRestart(restart)
[10:58:43.507]                             muffled <- TRUE
[10:58:43.507]                             break
[10:58:43.507]                           }
[10:58:43.507]                         }
[10:58:43.507]                       }
[10:58:43.507]                       invisible(muffled)
[10:58:43.507]                     }
[10:58:43.507]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.507]                   }
[10:58:43.507]                 }
[10:58:43.507]             }
[10:58:43.507]         }))
[10:58:43.507]     }, error = function(ex) {
[10:58:43.507]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.507]                 ...future.rng), started = ...future.startTime, 
[10:58:43.507]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.507]             version = "1.8"), class = "FutureResult")
[10:58:43.507]     }, finally = {
[10:58:43.507]         if (!identical(...future.workdir, getwd())) 
[10:58:43.507]             setwd(...future.workdir)
[10:58:43.507]         {
[10:58:43.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.507]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.507]             }
[10:58:43.507]             base::options(...future.oldOptions)
[10:58:43.507]             if (.Platform$OS.type == "windows") {
[10:58:43.507]                 old_names <- names(...future.oldEnvVars)
[10:58:43.507]                 envs <- base::Sys.getenv()
[10:58:43.507]                 names <- names(envs)
[10:58:43.507]                 common <- intersect(names, old_names)
[10:58:43.507]                 added <- setdiff(names, old_names)
[10:58:43.507]                 removed <- setdiff(old_names, names)
[10:58:43.507]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.507]                   envs[common]]
[10:58:43.507]                 NAMES <- toupper(changed)
[10:58:43.507]                 args <- list()
[10:58:43.507]                 for (kk in seq_along(NAMES)) {
[10:58:43.507]                   name <- changed[[kk]]
[10:58:43.507]                   NAME <- NAMES[[kk]]
[10:58:43.507]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.507]                     next
[10:58:43.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.507]                 }
[10:58:43.507]                 NAMES <- toupper(added)
[10:58:43.507]                 for (kk in seq_along(NAMES)) {
[10:58:43.507]                   name <- added[[kk]]
[10:58:43.507]                   NAME <- NAMES[[kk]]
[10:58:43.507]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.507]                     next
[10:58:43.507]                   args[[name]] <- ""
[10:58:43.507]                 }
[10:58:43.507]                 NAMES <- toupper(removed)
[10:58:43.507]                 for (kk in seq_along(NAMES)) {
[10:58:43.507]                   name <- removed[[kk]]
[10:58:43.507]                   NAME <- NAMES[[kk]]
[10:58:43.507]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.507]                     next
[10:58:43.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.507]                 }
[10:58:43.507]                 if (length(args) > 0) 
[10:58:43.507]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.507]             }
[10:58:43.507]             else {
[10:58:43.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.507]             }
[10:58:43.507]             {
[10:58:43.507]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.507]                   0L) {
[10:58:43.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.507]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.507]                   base::options(opts)
[10:58:43.507]                 }
[10:58:43.507]                 {
[10:58:43.507]                   {
[10:58:43.507]                     NULL
[10:58:43.507]                     RNGkind("Mersenne-Twister")
[10:58:43.507]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.507]                       inherits = FALSE)
[10:58:43.507]                   }
[10:58:43.507]                   options(future.plan = NULL)
[10:58:43.507]                   if (is.na(NA_character_)) 
[10:58:43.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.507]                     .init = FALSE)
[10:58:43.507]                 }
[10:58:43.507]             }
[10:58:43.507]         }
[10:58:43.507]     })
[10:58:43.507]     if (TRUE) {
[10:58:43.507]         base::sink(type = "output", split = FALSE)
[10:58:43.507]         if (TRUE) {
[10:58:43.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.507]         }
[10:58:43.507]         else {
[10:58:43.507]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.507]         }
[10:58:43.507]         base::close(...future.stdout)
[10:58:43.507]         ...future.stdout <- NULL
[10:58:43.507]     }
[10:58:43.507]     ...future.result$conditions <- ...future.conditions
[10:58:43.507]     ...future.result$finished <- base::Sys.time()
[10:58:43.507]     ...future.result
[10:58:43.507] }
[10:58:43.508] assign_globals() ...
[10:58:43.508] List of 5
[10:58:43.508]  $ ...future.FUN            :function (object, ...)  
[10:58:43.508]  $ future.call.arguments    : list()
[10:58:43.508]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.508]  $ ...future.elements_ii    :List of 3
[10:58:43.508]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.508]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.508]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.508]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.508]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.508]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.508]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.508]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.508]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.508]  $ ...future.seeds_ii       : NULL
[10:58:43.508]  $ ...future.globals.maxSize: NULL
[10:58:43.508]  - attr(*, "where")=List of 5
[10:58:43.508]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.508]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.508]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.508]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.508]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.508]  - attr(*, "resolved")= logi FALSE
[10:58:43.508]  - attr(*, "total_size")= num 15670
[10:58:43.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.508]  - attr(*, "already-done")= logi TRUE
[10:58:43.516] - copied ‘...future.FUN’ to environment
[10:58:43.516] - copied ‘future.call.arguments’ to environment
[10:58:43.516] - copied ‘...future.elements_ii’ to environment
[10:58:43.516] - copied ‘...future.seeds_ii’ to environment
[10:58:43.516] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.516] assign_globals() ... done
[10:58:43.517] plan(): Setting new future strategy stack:
[10:58:43.517] List of future strategies:
[10:58:43.517] 1. sequential:
[10:58:43.517]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.517]    - tweaked: FALSE
[10:58:43.517]    - call: NULL
[10:58:43.517] plan(): nbrOfWorkers() = 1
[10:58:43.519] plan(): Setting new future strategy stack:
[10:58:43.519] List of future strategies:
[10:58:43.519] 1. sequential:
[10:58:43.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.519]    - tweaked: FALSE
[10:58:43.519]    - call: plan(strategy)
[10:58:43.519] plan(): nbrOfWorkers() = 1
[10:58:43.520] SequentialFuture started (and completed)
[10:58:43.520] - Launch lazy future ... done
[10:58:43.520] run() for ‘SequentialFuture’ ... done
[10:58:43.520] Created future:
[10:58:43.520] SequentialFuture:
[10:58:43.520] Label: ‘future_by-1’
[10:58:43.520] Expression:
[10:58:43.520] {
[10:58:43.520]     do.call(function(...) {
[10:58:43.520]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.520]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.520]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.520]             on.exit(options(oopts), add = TRUE)
[10:58:43.520]         }
[10:58:43.520]         {
[10:58:43.520]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.520]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.520]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.520]             })
[10:58:43.520]         }
[10:58:43.520]     }, args = future.call.arguments)
[10:58:43.520] }
[10:58:43.520] Lazy evaluation: FALSE
[10:58:43.520] Asynchronous evaluation: FALSE
[10:58:43.520] Local evaluation: TRUE
[10:58:43.520] Environment: R_GlobalEnv
[10:58:43.520] Capture standard output: TRUE
[10:58:43.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.520] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.520] Packages: <none>
[10:58:43.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.520] Resolved: TRUE
[10:58:43.520] Value: 1.16 KiB of class ‘list’
[10:58:43.520] Early signaling: FALSE
[10:58:43.520] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.520] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.521] Chunk #1 of 1 ... DONE
[10:58:43.521] Launching 1 futures (chunks) ... DONE
[10:58:43.521] Resolving 1 futures (chunks) ...
[10:58:43.521] resolve() on list ...
[10:58:43.521]  recursive: 0
[10:58:43.521]  length: 1
[10:58:43.521] 
[10:58:43.521] resolved() for ‘SequentialFuture’ ...
[10:58:43.521] - state: ‘finished’
[10:58:43.521] - run: TRUE
[10:58:43.522] - result: ‘FutureResult’
[10:58:43.522] resolved() for ‘SequentialFuture’ ... done
[10:58:43.522] Future #1
[10:58:43.522] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.522] - nx: 1
[10:58:43.522] - relay: TRUE
[10:58:43.522] - stdout: TRUE
[10:58:43.522] - signal: TRUE
[10:58:43.522] - resignal: FALSE
[10:58:43.522] - force: TRUE
[10:58:43.522] - relayed: [n=1] FALSE
[10:58:43.522] - queued futures: [n=1] FALSE
[10:58:43.523]  - until=1
[10:58:43.523]  - relaying element #1
[10:58:43.523] - relayed: [n=1] TRUE
[10:58:43.523] - queued futures: [n=1] TRUE
[10:58:43.523] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.523]  length: 0 (resolved future 1)
[10:58:43.523] Relaying remaining futures
[10:58:43.523] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.523] - nx: 1
[10:58:43.523] - relay: TRUE
[10:58:43.523] - stdout: TRUE
[10:58:43.524] - signal: TRUE
[10:58:43.524] - resignal: FALSE
[10:58:43.524] - force: TRUE
[10:58:43.524] - relayed: [n=1] TRUE
[10:58:43.524] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.524] - relayed: [n=1] TRUE
[10:58:43.524] - queued futures: [n=1] TRUE
[10:58:43.524] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.524] resolve() on list ... DONE
[10:58:43.524]  - Number of value chunks collected: 1
[10:58:43.524] Resolving 1 futures (chunks) ... DONE
[10:58:43.525] Reducing values from 1 chunks ...
[10:58:43.525]  - Number of values collected after concatenation: 3
[10:58:43.525]  - Number of values expected: 3
[10:58:43.525] Reducing values from 1 chunks ... DONE
[10:58:43.525] future_lapply() ... DONE
[10:58:43.525] future_by_internal() ... DONE
[10:58:43.525] future_by_internal() ...
[10:58:43.525] future_lapply() ...
[10:58:43.526] Number of chunks: 1
[10:58:43.526] getGlobalsAndPackagesXApply() ...
[10:58:43.526]  - future.globals: TRUE
[10:58:43.527] getGlobalsAndPackages() ...
[10:58:43.527] Searching for globals...
[10:58:43.528] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.528] Searching for globals ... DONE
[10:58:43.529] Resolving globals: FALSE
[10:58:43.529] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.529] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.529] - globals: [1] ‘FUN’
[10:58:43.529] 
[10:58:43.529] getGlobalsAndPackages() ... DONE
[10:58:43.530]  - globals found/used: [n=1] ‘FUN’
[10:58:43.530]  - needed namespaces: [n=0] 
[10:58:43.530] Finding globals ... DONE
[10:58:43.530]  - use_args: TRUE
[10:58:43.530]  - Getting '...' globals ...
[10:58:43.530] resolve() on list ...
[10:58:43.530]  recursive: 0
[10:58:43.530]  length: 1
[10:58:43.530]  elements: ‘...’
[10:58:43.531]  length: 0 (resolved future 1)
[10:58:43.531] resolve() on list ... DONE
[10:58:43.531]    - '...' content: [n=1] ‘digits’
[10:58:43.531] List of 1
[10:58:43.531]  $ ...:List of 1
[10:58:43.531]   ..$ digits: int 2
[10:58:43.531]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.531]  - attr(*, "where")=List of 1
[10:58:43.531]   ..$ ...:<environment: 0x55974def10c0> 
[10:58:43.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.531]  - attr(*, "resolved")= logi TRUE
[10:58:43.531]  - attr(*, "total_size")= num NA
[10:58:43.533]  - Getting '...' globals ... DONE
[10:58:43.534] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.534] List of 2
[10:58:43.534]  $ ...future.FUN:function (object, ...)  
[10:58:43.534]  $ ...          :List of 1
[10:58:43.534]   ..$ digits: int 2
[10:58:43.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.534]  - attr(*, "where")=List of 2
[10:58:43.534]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.534]   ..$ ...          :<environment: 0x55974def10c0> 
[10:58:43.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.534]  - attr(*, "resolved")= logi FALSE
[10:58:43.534]  - attr(*, "total_size")= num 13284
[10:58:43.537] Packages to be attached in all futures: [n=0] 
[10:58:43.537] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.537] Number of futures (= number of chunks): 1
[10:58:43.537] Launching 1 futures (chunks) ...
[10:58:43.537] Chunk #1 of 1 ...
[10:58:43.537]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.537] getGlobalsAndPackages() ...
[10:58:43.537] Searching for globals...
[10:58:43.537] 
[10:58:43.538] Searching for globals ... DONE
[10:58:43.538] - globals: [0] <none>
[10:58:43.538] getGlobalsAndPackages() ... DONE
[10:58:43.538]    + additional globals found: [n=0] 
[10:58:43.538]    + additional namespaces needed: [n=0] 
[10:58:43.538]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.538]  - seeds: <none>
[10:58:43.538]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.538] getGlobalsAndPackages() ...
[10:58:43.538] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.538] Resolving globals: FALSE
[10:58:43.538] Tweak future expression to call with '...' arguments ...
[10:58:43.539] {
[10:58:43.539]     do.call(function(...) {
[10:58:43.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.539]             on.exit(options(oopts), add = TRUE)
[10:58:43.539]         }
[10:58:43.539]         {
[10:58:43.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.539]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.539]             })
[10:58:43.539]         }
[10:58:43.539]     }, args = future.call.arguments)
[10:58:43.539] }
[10:58:43.539] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.539] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.539] 
[10:58:43.539] getGlobalsAndPackages() ... DONE
[10:58:43.539] run() for ‘Future’ ...
[10:58:43.540] - state: ‘created’
[10:58:43.540] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:43.540] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.540] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.540]   - Field: ‘label’
[10:58:43.540]   - Field: ‘local’
[10:58:43.540]   - Field: ‘owner’
[10:58:43.540]   - Field: ‘envir’
[10:58:43.540]   - Field: ‘packages’
[10:58:43.541]   - Field: ‘gc’
[10:58:43.541]   - Field: ‘conditions’
[10:58:43.541]   - Field: ‘expr’
[10:58:43.541]   - Field: ‘uuid’
[10:58:43.541]   - Field: ‘seed’
[10:58:43.541]   - Field: ‘version’
[10:58:43.541]   - Field: ‘result’
[10:58:43.541]   - Field: ‘asynchronous’
[10:58:43.541]   - Field: ‘calls’
[10:58:43.541]   - Field: ‘globals’
[10:58:43.541]   - Field: ‘stdout’
[10:58:43.541]   - Field: ‘earlySignal’
[10:58:43.542]   - Field: ‘lazy’
[10:58:43.542]   - Field: ‘state’
[10:58:43.542] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.542] - Launch lazy future ...
[10:58:43.542] Packages needed by the future expression (n = 0): <none>
[10:58:43.542] Packages needed by future strategies (n = 0): <none>
[10:58:43.542] {
[10:58:43.542]     {
[10:58:43.542]         {
[10:58:43.542]             ...future.startTime <- base::Sys.time()
[10:58:43.542]             {
[10:58:43.542]                 {
[10:58:43.542]                   {
[10:58:43.542]                     base::local({
[10:58:43.542]                       has_future <- base::requireNamespace("future", 
[10:58:43.542]                         quietly = TRUE)
[10:58:43.542]                       if (has_future) {
[10:58:43.542]                         ns <- base::getNamespace("future")
[10:58:43.542]                         version <- ns[[".package"]][["version"]]
[10:58:43.542]                         if (is.null(version)) 
[10:58:43.542]                           version <- utils::packageVersion("future")
[10:58:43.542]                       }
[10:58:43.542]                       else {
[10:58:43.542]                         version <- NULL
[10:58:43.542]                       }
[10:58:43.542]                       if (!has_future || version < "1.8.0") {
[10:58:43.542]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.542]                           "", base::R.version$version.string), 
[10:58:43.542]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.542]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.542]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.542]                             "release", "version")], collapse = " "), 
[10:58:43.542]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.542]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.542]                           info)
[10:58:43.542]                         info <- base::paste(info, collapse = "; ")
[10:58:43.542]                         if (!has_future) {
[10:58:43.542]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.542]                             info)
[10:58:43.542]                         }
[10:58:43.542]                         else {
[10:58:43.542]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.542]                             info, version)
[10:58:43.542]                         }
[10:58:43.542]                         base::stop(msg)
[10:58:43.542]                       }
[10:58:43.542]                     })
[10:58:43.542]                   }
[10:58:43.542]                   ...future.strategy.old <- future::plan("list")
[10:58:43.542]                   options(future.plan = NULL)
[10:58:43.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.542]                 }
[10:58:43.542]                 ...future.workdir <- getwd()
[10:58:43.542]             }
[10:58:43.542]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.542]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.542]         }
[10:58:43.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.542]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.542]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.542]             base::names(...future.oldOptions))
[10:58:43.542]     }
[10:58:43.542]     if (FALSE) {
[10:58:43.542]     }
[10:58:43.542]     else {
[10:58:43.542]         if (TRUE) {
[10:58:43.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.542]                 open = "w")
[10:58:43.542]         }
[10:58:43.542]         else {
[10:58:43.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.542]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.542]         }
[10:58:43.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.542]             base::sink(type = "output", split = FALSE)
[10:58:43.542]             base::close(...future.stdout)
[10:58:43.542]         }, add = TRUE)
[10:58:43.542]     }
[10:58:43.542]     ...future.frame <- base::sys.nframe()
[10:58:43.542]     ...future.conditions <- base::list()
[10:58:43.542]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.542]     if (FALSE) {
[10:58:43.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.542]     }
[10:58:43.542]     ...future.result <- base::tryCatch({
[10:58:43.542]         base::withCallingHandlers({
[10:58:43.542]             ...future.value <- base::withVisible(base::local({
[10:58:43.542]                 do.call(function(...) {
[10:58:43.542]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.542]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.542]                     ...future.globals.maxSize)) {
[10:58:43.542]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.542]                     on.exit(options(oopts), add = TRUE)
[10:58:43.542]                   }
[10:58:43.542]                   {
[10:58:43.542]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.542]                       FUN = function(jj) {
[10:58:43.542]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.542]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.542]                       })
[10:58:43.542]                   }
[10:58:43.542]                 }, args = future.call.arguments)
[10:58:43.542]             }))
[10:58:43.542]             future::FutureResult(value = ...future.value$value, 
[10:58:43.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.542]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.542]                     ...future.globalenv.names))
[10:58:43.542]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.542]         }, condition = base::local({
[10:58:43.542]             c <- base::c
[10:58:43.542]             inherits <- base::inherits
[10:58:43.542]             invokeRestart <- base::invokeRestart
[10:58:43.542]             length <- base::length
[10:58:43.542]             list <- base::list
[10:58:43.542]             seq.int <- base::seq.int
[10:58:43.542]             signalCondition <- base::signalCondition
[10:58:43.542]             sys.calls <- base::sys.calls
[10:58:43.542]             `[[` <- base::`[[`
[10:58:43.542]             `+` <- base::`+`
[10:58:43.542]             `<<-` <- base::`<<-`
[10:58:43.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.542]                   3L)]
[10:58:43.542]             }
[10:58:43.542]             function(cond) {
[10:58:43.542]                 is_error <- inherits(cond, "error")
[10:58:43.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.542]                   NULL)
[10:58:43.542]                 if (is_error) {
[10:58:43.542]                   sessionInformation <- function() {
[10:58:43.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.542]                       search = base::search(), system = base::Sys.info())
[10:58:43.542]                   }
[10:58:43.542]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.542]                     cond$call), session = sessionInformation(), 
[10:58:43.542]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.542]                   signalCondition(cond)
[10:58:43.542]                 }
[10:58:43.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.542]                 "immediateCondition"))) {
[10:58:43.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.542]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.542]                   if (TRUE && !signal) {
[10:58:43.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.542]                     {
[10:58:43.542]                       inherits <- base::inherits
[10:58:43.542]                       invokeRestart <- base::invokeRestart
[10:58:43.542]                       is.null <- base::is.null
[10:58:43.542]                       muffled <- FALSE
[10:58:43.542]                       if (inherits(cond, "message")) {
[10:58:43.542]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.542]                         if (muffled) 
[10:58:43.542]                           invokeRestart("muffleMessage")
[10:58:43.542]                       }
[10:58:43.542]                       else if (inherits(cond, "warning")) {
[10:58:43.542]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.542]                         if (muffled) 
[10:58:43.542]                           invokeRestart("muffleWarning")
[10:58:43.542]                       }
[10:58:43.542]                       else if (inherits(cond, "condition")) {
[10:58:43.542]                         if (!is.null(pattern)) {
[10:58:43.542]                           computeRestarts <- base::computeRestarts
[10:58:43.542]                           grepl <- base::grepl
[10:58:43.542]                           restarts <- computeRestarts(cond)
[10:58:43.542]                           for (restart in restarts) {
[10:58:43.542]                             name <- restart$name
[10:58:43.542]                             if (is.null(name)) 
[10:58:43.542]                               next
[10:58:43.542]                             if (!grepl(pattern, name)) 
[10:58:43.542]                               next
[10:58:43.542]                             invokeRestart(restart)
[10:58:43.542]                             muffled <- TRUE
[10:58:43.542]                             break
[10:58:43.542]                           }
[10:58:43.542]                         }
[10:58:43.542]                       }
[10:58:43.542]                       invisible(muffled)
[10:58:43.542]                     }
[10:58:43.542]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.542]                   }
[10:58:43.542]                 }
[10:58:43.542]                 else {
[10:58:43.542]                   if (TRUE) {
[10:58:43.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.542]                     {
[10:58:43.542]                       inherits <- base::inherits
[10:58:43.542]                       invokeRestart <- base::invokeRestart
[10:58:43.542]                       is.null <- base::is.null
[10:58:43.542]                       muffled <- FALSE
[10:58:43.542]                       if (inherits(cond, "message")) {
[10:58:43.542]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.542]                         if (muffled) 
[10:58:43.542]                           invokeRestart("muffleMessage")
[10:58:43.542]                       }
[10:58:43.542]                       else if (inherits(cond, "warning")) {
[10:58:43.542]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.542]                         if (muffled) 
[10:58:43.542]                           invokeRestart("muffleWarning")
[10:58:43.542]                       }
[10:58:43.542]                       else if (inherits(cond, "condition")) {
[10:58:43.542]                         if (!is.null(pattern)) {
[10:58:43.542]                           computeRestarts <- base::computeRestarts
[10:58:43.542]                           grepl <- base::grepl
[10:58:43.542]                           restarts <- computeRestarts(cond)
[10:58:43.542]                           for (restart in restarts) {
[10:58:43.542]                             name <- restart$name
[10:58:43.542]                             if (is.null(name)) 
[10:58:43.542]                               next
[10:58:43.542]                             if (!grepl(pattern, name)) 
[10:58:43.542]                               next
[10:58:43.542]                             invokeRestart(restart)
[10:58:43.542]                             muffled <- TRUE
[10:58:43.542]                             break
[10:58:43.542]                           }
[10:58:43.542]                         }
[10:58:43.542]                       }
[10:58:43.542]                       invisible(muffled)
[10:58:43.542]                     }
[10:58:43.542]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.542]                   }
[10:58:43.542]                 }
[10:58:43.542]             }
[10:58:43.542]         }))
[10:58:43.542]     }, error = function(ex) {
[10:58:43.542]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.542]                 ...future.rng), started = ...future.startTime, 
[10:58:43.542]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.542]             version = "1.8"), class = "FutureResult")
[10:58:43.542]     }, finally = {
[10:58:43.542]         if (!identical(...future.workdir, getwd())) 
[10:58:43.542]             setwd(...future.workdir)
[10:58:43.542]         {
[10:58:43.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.542]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.542]             }
[10:58:43.542]             base::options(...future.oldOptions)
[10:58:43.542]             if (.Platform$OS.type == "windows") {
[10:58:43.542]                 old_names <- names(...future.oldEnvVars)
[10:58:43.542]                 envs <- base::Sys.getenv()
[10:58:43.542]                 names <- names(envs)
[10:58:43.542]                 common <- intersect(names, old_names)
[10:58:43.542]                 added <- setdiff(names, old_names)
[10:58:43.542]                 removed <- setdiff(old_names, names)
[10:58:43.542]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.542]                   envs[common]]
[10:58:43.542]                 NAMES <- toupper(changed)
[10:58:43.542]                 args <- list()
[10:58:43.542]                 for (kk in seq_along(NAMES)) {
[10:58:43.542]                   name <- changed[[kk]]
[10:58:43.542]                   NAME <- NAMES[[kk]]
[10:58:43.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.542]                     next
[10:58:43.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.542]                 }
[10:58:43.542]                 NAMES <- toupper(added)
[10:58:43.542]                 for (kk in seq_along(NAMES)) {
[10:58:43.542]                   name <- added[[kk]]
[10:58:43.542]                   NAME <- NAMES[[kk]]
[10:58:43.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.542]                     next
[10:58:43.542]                   args[[name]] <- ""
[10:58:43.542]                 }
[10:58:43.542]                 NAMES <- toupper(removed)
[10:58:43.542]                 for (kk in seq_along(NAMES)) {
[10:58:43.542]                   name <- removed[[kk]]
[10:58:43.542]                   NAME <- NAMES[[kk]]
[10:58:43.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.542]                     next
[10:58:43.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.542]                 }
[10:58:43.542]                 if (length(args) > 0) 
[10:58:43.542]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.542]             }
[10:58:43.542]             else {
[10:58:43.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.542]             }
[10:58:43.542]             {
[10:58:43.542]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.542]                   0L) {
[10:58:43.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.542]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.542]                   base::options(opts)
[10:58:43.542]                 }
[10:58:43.542]                 {
[10:58:43.542]                   {
[10:58:43.542]                     NULL
[10:58:43.542]                     RNGkind("Mersenne-Twister")
[10:58:43.542]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.542]                       inherits = FALSE)
[10:58:43.542]                   }
[10:58:43.542]                   options(future.plan = NULL)
[10:58:43.542]                   if (is.na(NA_character_)) 
[10:58:43.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.542]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.542]                     .init = FALSE)
[10:58:43.542]                 }
[10:58:43.542]             }
[10:58:43.542]         }
[10:58:43.542]     })
[10:58:43.542]     if (TRUE) {
[10:58:43.542]         base::sink(type = "output", split = FALSE)
[10:58:43.542]         if (TRUE) {
[10:58:43.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.542]         }
[10:58:43.542]         else {
[10:58:43.542]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.542]         }
[10:58:43.542]         base::close(...future.stdout)
[10:58:43.542]         ...future.stdout <- NULL
[10:58:43.542]     }
[10:58:43.542]     ...future.result$conditions <- ...future.conditions
[10:58:43.542]     ...future.result$finished <- base::Sys.time()
[10:58:43.542]     ...future.result
[10:58:43.542] }
[10:58:43.544] assign_globals() ...
[10:58:43.544] List of 5
[10:58:43.544]  $ ...future.FUN            :function (object, ...)  
[10:58:43.544]  $ future.call.arguments    :List of 1
[10:58:43.544]   ..$ digits: int 2
[10:58:43.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.544]  $ ...future.elements_ii    :List of 6
[10:58:43.544]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:58:43.544]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:58:43.544]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:58:43.544]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:58:43.544]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:58:43.544]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:58:43.544]  $ ...future.seeds_ii       : NULL
[10:58:43.544]  $ ...future.globals.maxSize: NULL
[10:58:43.544]  - attr(*, "where")=List of 5
[10:58:43.544]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.544]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.544]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.544]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.544]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.544]  - attr(*, "resolved")= logi FALSE
[10:58:43.544]  - attr(*, "total_size")= num 13284
[10:58:43.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.544]  - attr(*, "already-done")= logi TRUE
[10:58:43.551] - copied ‘...future.FUN’ to environment
[10:58:43.551] - copied ‘future.call.arguments’ to environment
[10:58:43.551] - copied ‘...future.elements_ii’ to environment
[10:58:43.552] - copied ‘...future.seeds_ii’ to environment
[10:58:43.552] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.552] assign_globals() ... done
[10:58:43.552] plan(): Setting new future strategy stack:
[10:58:43.552] List of future strategies:
[10:58:43.552] 1. sequential:
[10:58:43.552]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.552]    - tweaked: FALSE
[10:58:43.552]    - call: NULL
[10:58:43.552] plan(): nbrOfWorkers() = 1
[10:58:43.554] plan(): Setting new future strategy stack:
[10:58:43.554] List of future strategies:
[10:58:43.554] 1. sequential:
[10:58:43.554]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.554]    - tweaked: FALSE
[10:58:43.554]    - call: plan(strategy)
[10:58:43.554] plan(): nbrOfWorkers() = 1
[10:58:43.554] SequentialFuture started (and completed)
[10:58:43.554] - Launch lazy future ... done
[10:58:43.554] run() for ‘SequentialFuture’ ... done
[10:58:43.555] Created future:
[10:58:43.555] SequentialFuture:
[10:58:43.555] Label: ‘future_by-1’
[10:58:43.555] Expression:
[10:58:43.555] {
[10:58:43.555]     do.call(function(...) {
[10:58:43.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.555]             on.exit(options(oopts), add = TRUE)
[10:58:43.555]         }
[10:58:43.555]         {
[10:58:43.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.555]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.555]             })
[10:58:43.555]         }
[10:58:43.555]     }, args = future.call.arguments)
[10:58:43.555] }
[10:58:43.555] Lazy evaluation: FALSE
[10:58:43.555] Asynchronous evaluation: FALSE
[10:58:43.555] Local evaluation: TRUE
[10:58:43.555] Environment: R_GlobalEnv
[10:58:43.555] Capture standard output: TRUE
[10:58:43.555] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.555] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.555] Packages: <none>
[10:58:43.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.555] Resolved: TRUE
[10:58:43.555] Value: 1.27 KiB of class ‘list’
[10:58:43.555] Early signaling: FALSE
[10:58:43.555] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.555] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.555] Chunk #1 of 1 ... DONE
[10:58:43.555] Launching 1 futures (chunks) ... DONE
[10:58:43.556] Resolving 1 futures (chunks) ...
[10:58:43.556] resolve() on list ...
[10:58:43.556]  recursive: 0
[10:58:43.556]  length: 1
[10:58:43.556] 
[10:58:43.556] resolved() for ‘SequentialFuture’ ...
[10:58:43.556] - state: ‘finished’
[10:58:43.556] - run: TRUE
[10:58:43.556] - result: ‘FutureResult’
[10:58:43.556] resolved() for ‘SequentialFuture’ ... done
[10:58:43.556] Future #1
[10:58:43.557] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.557] - nx: 1
[10:58:43.557] - relay: TRUE
[10:58:43.557] - stdout: TRUE
[10:58:43.557] - signal: TRUE
[10:58:43.557] - resignal: FALSE
[10:58:43.557] - force: TRUE
[10:58:43.557] - relayed: [n=1] FALSE
[10:58:43.557] - queued futures: [n=1] FALSE
[10:58:43.557]  - until=1
[10:58:43.557]  - relaying element #1
[10:58:43.557] - relayed: [n=1] TRUE
[10:58:43.557] - queued futures: [n=1] TRUE
[10:58:43.558] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.558]  length: 0 (resolved future 1)
[10:58:43.558] Relaying remaining futures
[10:58:43.558] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.558] - nx: 1
[10:58:43.558] - relay: TRUE
[10:58:43.558] - stdout: TRUE
[10:58:43.558] - signal: TRUE
[10:58:43.558] - resignal: FALSE
[10:58:43.558] - force: TRUE
[10:58:43.558] - relayed: [n=1] TRUE
[10:58:43.558] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.559] - relayed: [n=1] TRUE
[10:58:43.559] - queued futures: [n=1] TRUE
[10:58:43.559] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.559] resolve() on list ... DONE
[10:58:43.559]  - Number of value chunks collected: 1
[10:58:43.559] Resolving 1 futures (chunks) ... DONE
[10:58:43.559] Reducing values from 1 chunks ...
[10:58:43.559]  - Number of values collected after concatenation: 6
[10:58:43.559]  - Number of values expected: 6
[10:58:43.559] Reducing values from 1 chunks ... DONE
[10:58:43.559] future_lapply() ... DONE
[10:58:43.559] future_by_internal() ... DONE
[10:58:43.560] future_by_internal() ...
[10:58:43.561] future_lapply() ...
[10:58:43.561] Number of chunks: 1
[10:58:43.561] getGlobalsAndPackagesXApply() ...
[10:58:43.562]  - future.globals: TRUE
[10:58:43.562] getGlobalsAndPackages() ...
[10:58:43.562] Searching for globals...
[10:58:43.563] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:43.563] Searching for globals ... DONE
[10:58:43.563] Resolving globals: FALSE
[10:58:43.564] The total size of the 1 globals is 762 bytes (762 bytes)
[10:58:43.564] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:58:43.564] - globals: [1] ‘FUN’
[10:58:43.564] - packages: [1] ‘stats’
[10:58:43.564] getGlobalsAndPackages() ... DONE
[10:58:43.564]  - globals found/used: [n=1] ‘FUN’
[10:58:43.564]  - needed namespaces: [n=1] ‘stats’
[10:58:43.565] Finding globals ... DONE
[10:58:43.565]  - use_args: TRUE
[10:58:43.565]  - Getting '...' globals ...
[10:58:43.566] resolve() on list ...
[10:58:43.566]  recursive: 0
[10:58:43.566]  length: 1
[10:58:43.566]  elements: ‘...’
[10:58:43.566]  length: 0 (resolved future 1)
[10:58:43.566] resolve() on list ... DONE
[10:58:43.566]    - '...' content: [n=1] ‘singular.ok’
[10:58:43.566] List of 1
[10:58:43.566]  $ ...:List of 1
[10:58:43.566]   ..$ singular.ok: logi FALSE
[10:58:43.566]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.566]  - attr(*, "where")=List of 1
[10:58:43.566]   ..$ ...:<environment: 0x55974dabe800> 
[10:58:43.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.566]  - attr(*, "resolved")= logi TRUE
[10:58:43.566]  - attr(*, "total_size")= num NA
[10:58:43.569]  - Getting '...' globals ... DONE
[10:58:43.569] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.569] List of 2
[10:58:43.569]  $ ...future.FUN:function (x, ...)  
[10:58:43.569]  $ ...          :List of 1
[10:58:43.569]   ..$ singular.ok: logi FALSE
[10:58:43.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.569]  - attr(*, "where")=List of 2
[10:58:43.569]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.569]   ..$ ...          :<environment: 0x55974dabe800> 
[10:58:43.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.569]  - attr(*, "resolved")= logi FALSE
[10:58:43.569]  - attr(*, "total_size")= num 19977
[10:58:43.572] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:43.572] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.572] Number of futures (= number of chunks): 1
[10:58:43.572] Launching 1 futures (chunks) ...
[10:58:43.573] Chunk #1 of 1 ...
[10:58:43.573]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.573] getGlobalsAndPackages() ...
[10:58:43.573] Searching for globals...
[10:58:43.573] 
[10:58:43.573] Searching for globals ... DONE
[10:58:43.573] - globals: [0] <none>
[10:58:43.573] getGlobalsAndPackages() ... DONE
[10:58:43.574]    + additional globals found: [n=0] 
[10:58:43.574]    + additional namespaces needed: [n=0] 
[10:58:43.574]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.574]  - seeds: <none>
[10:58:43.574]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.574] getGlobalsAndPackages() ...
[10:58:43.574] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.574] Resolving globals: FALSE
[10:58:43.574] Tweak future expression to call with '...' arguments ...
[10:58:43.574] {
[10:58:43.574]     do.call(function(...) {
[10:58:43.574]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.574]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.574]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.574]             on.exit(options(oopts), add = TRUE)
[10:58:43.574]         }
[10:58:43.574]         {
[10:58:43.574]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.574]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.574]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.574]             })
[10:58:43.574]         }
[10:58:43.574]     }, args = future.call.arguments)
[10:58:43.574] }
[10:58:43.575] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.575] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.575] 
[10:58:43.575] getGlobalsAndPackages() ... DONE
[10:58:43.575] run() for ‘Future’ ...
[10:58:43.575] - state: ‘created’
[10:58:43.576] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:43.576] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.576]   - Field: ‘label’
[10:58:43.576]   - Field: ‘local’
[10:58:43.576]   - Field: ‘owner’
[10:58:43.576]   - Field: ‘envir’
[10:58:43.576]   - Field: ‘packages’
[10:58:43.576]   - Field: ‘gc’
[10:58:43.576]   - Field: ‘conditions’
[10:58:43.577]   - Field: ‘expr’
[10:58:43.577]   - Field: ‘uuid’
[10:58:43.577]   - Field: ‘seed’
[10:58:43.577]   - Field: ‘version’
[10:58:43.577]   - Field: ‘result’
[10:58:43.577]   - Field: ‘asynchronous’
[10:58:43.577]   - Field: ‘calls’
[10:58:43.577]   - Field: ‘globals’
[10:58:43.577]   - Field: ‘stdout’
[10:58:43.577]   - Field: ‘earlySignal’
[10:58:43.577]   - Field: ‘lazy’
[10:58:43.577]   - Field: ‘state’
[10:58:43.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.578] - Launch lazy future ...
[10:58:43.578] Packages needed by the future expression (n = 1): ‘stats’
[10:58:43.578] Packages needed by future strategies (n = 0): <none>
[10:58:43.578] {
[10:58:43.578]     {
[10:58:43.578]         {
[10:58:43.578]             ...future.startTime <- base::Sys.time()
[10:58:43.578]             {
[10:58:43.578]                 {
[10:58:43.578]                   {
[10:58:43.578]                     {
[10:58:43.578]                       base::local({
[10:58:43.578]                         has_future <- base::requireNamespace("future", 
[10:58:43.578]                           quietly = TRUE)
[10:58:43.578]                         if (has_future) {
[10:58:43.578]                           ns <- base::getNamespace("future")
[10:58:43.578]                           version <- ns[[".package"]][["version"]]
[10:58:43.578]                           if (is.null(version)) 
[10:58:43.578]                             version <- utils::packageVersion("future")
[10:58:43.578]                         }
[10:58:43.578]                         else {
[10:58:43.578]                           version <- NULL
[10:58:43.578]                         }
[10:58:43.578]                         if (!has_future || version < "1.8.0") {
[10:58:43.578]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.578]                             "", base::R.version$version.string), 
[10:58:43.578]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.578]                               "release", "version")], collapse = " "), 
[10:58:43.578]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.578]                             info)
[10:58:43.578]                           info <- base::paste(info, collapse = "; ")
[10:58:43.578]                           if (!has_future) {
[10:58:43.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.578]                               info)
[10:58:43.578]                           }
[10:58:43.578]                           else {
[10:58:43.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.578]                               info, version)
[10:58:43.578]                           }
[10:58:43.578]                           base::stop(msg)
[10:58:43.578]                         }
[10:58:43.578]                       })
[10:58:43.578]                     }
[10:58:43.578]                     base::local({
[10:58:43.578]                       for (pkg in "stats") {
[10:58:43.578]                         base::loadNamespace(pkg)
[10:58:43.578]                         base::library(pkg, character.only = TRUE)
[10:58:43.578]                       }
[10:58:43.578]                     })
[10:58:43.578]                   }
[10:58:43.578]                   ...future.strategy.old <- future::plan("list")
[10:58:43.578]                   options(future.plan = NULL)
[10:58:43.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.578]                 }
[10:58:43.578]                 ...future.workdir <- getwd()
[10:58:43.578]             }
[10:58:43.578]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.578]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.578]         }
[10:58:43.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.578]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.578]             base::names(...future.oldOptions))
[10:58:43.578]     }
[10:58:43.578]     if (FALSE) {
[10:58:43.578]     }
[10:58:43.578]     else {
[10:58:43.578]         if (TRUE) {
[10:58:43.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.578]                 open = "w")
[10:58:43.578]         }
[10:58:43.578]         else {
[10:58:43.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.578]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.578]         }
[10:58:43.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.578]             base::sink(type = "output", split = FALSE)
[10:58:43.578]             base::close(...future.stdout)
[10:58:43.578]         }, add = TRUE)
[10:58:43.578]     }
[10:58:43.578]     ...future.frame <- base::sys.nframe()
[10:58:43.578]     ...future.conditions <- base::list()
[10:58:43.578]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.578]     if (FALSE) {
[10:58:43.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.578]     }
[10:58:43.578]     ...future.result <- base::tryCatch({
[10:58:43.578]         base::withCallingHandlers({
[10:58:43.578]             ...future.value <- base::withVisible(base::local({
[10:58:43.578]                 do.call(function(...) {
[10:58:43.578]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.578]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.578]                     ...future.globals.maxSize)) {
[10:58:43.578]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.578]                     on.exit(options(oopts), add = TRUE)
[10:58:43.578]                   }
[10:58:43.578]                   {
[10:58:43.578]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.578]                       FUN = function(jj) {
[10:58:43.578]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.578]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.578]                       })
[10:58:43.578]                   }
[10:58:43.578]                 }, args = future.call.arguments)
[10:58:43.578]             }))
[10:58:43.578]             future::FutureResult(value = ...future.value$value, 
[10:58:43.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.578]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.578]                     ...future.globalenv.names))
[10:58:43.578]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.578]         }, condition = base::local({
[10:58:43.578]             c <- base::c
[10:58:43.578]             inherits <- base::inherits
[10:58:43.578]             invokeRestart <- base::invokeRestart
[10:58:43.578]             length <- base::length
[10:58:43.578]             list <- base::list
[10:58:43.578]             seq.int <- base::seq.int
[10:58:43.578]             signalCondition <- base::signalCondition
[10:58:43.578]             sys.calls <- base::sys.calls
[10:58:43.578]             `[[` <- base::`[[`
[10:58:43.578]             `+` <- base::`+`
[10:58:43.578]             `<<-` <- base::`<<-`
[10:58:43.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.578]                   3L)]
[10:58:43.578]             }
[10:58:43.578]             function(cond) {
[10:58:43.578]                 is_error <- inherits(cond, "error")
[10:58:43.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.578]                   NULL)
[10:58:43.578]                 if (is_error) {
[10:58:43.578]                   sessionInformation <- function() {
[10:58:43.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.578]                       search = base::search(), system = base::Sys.info())
[10:58:43.578]                   }
[10:58:43.578]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.578]                     cond$call), session = sessionInformation(), 
[10:58:43.578]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.578]                   signalCondition(cond)
[10:58:43.578]                 }
[10:58:43.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.578]                 "immediateCondition"))) {
[10:58:43.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.578]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.578]                   if (TRUE && !signal) {
[10:58:43.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.578]                     {
[10:58:43.578]                       inherits <- base::inherits
[10:58:43.578]                       invokeRestart <- base::invokeRestart
[10:58:43.578]                       is.null <- base::is.null
[10:58:43.578]                       muffled <- FALSE
[10:58:43.578]                       if (inherits(cond, "message")) {
[10:58:43.578]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.578]                         if (muffled) 
[10:58:43.578]                           invokeRestart("muffleMessage")
[10:58:43.578]                       }
[10:58:43.578]                       else if (inherits(cond, "warning")) {
[10:58:43.578]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.578]                         if (muffled) 
[10:58:43.578]                           invokeRestart("muffleWarning")
[10:58:43.578]                       }
[10:58:43.578]                       else if (inherits(cond, "condition")) {
[10:58:43.578]                         if (!is.null(pattern)) {
[10:58:43.578]                           computeRestarts <- base::computeRestarts
[10:58:43.578]                           grepl <- base::grepl
[10:58:43.578]                           restarts <- computeRestarts(cond)
[10:58:43.578]                           for (restart in restarts) {
[10:58:43.578]                             name <- restart$name
[10:58:43.578]                             if (is.null(name)) 
[10:58:43.578]                               next
[10:58:43.578]                             if (!grepl(pattern, name)) 
[10:58:43.578]                               next
[10:58:43.578]                             invokeRestart(restart)
[10:58:43.578]                             muffled <- TRUE
[10:58:43.578]                             break
[10:58:43.578]                           }
[10:58:43.578]                         }
[10:58:43.578]                       }
[10:58:43.578]                       invisible(muffled)
[10:58:43.578]                     }
[10:58:43.578]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.578]                   }
[10:58:43.578]                 }
[10:58:43.578]                 else {
[10:58:43.578]                   if (TRUE) {
[10:58:43.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.578]                     {
[10:58:43.578]                       inherits <- base::inherits
[10:58:43.578]                       invokeRestart <- base::invokeRestart
[10:58:43.578]                       is.null <- base::is.null
[10:58:43.578]                       muffled <- FALSE
[10:58:43.578]                       if (inherits(cond, "message")) {
[10:58:43.578]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.578]                         if (muffled) 
[10:58:43.578]                           invokeRestart("muffleMessage")
[10:58:43.578]                       }
[10:58:43.578]                       else if (inherits(cond, "warning")) {
[10:58:43.578]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.578]                         if (muffled) 
[10:58:43.578]                           invokeRestart("muffleWarning")
[10:58:43.578]                       }
[10:58:43.578]                       else if (inherits(cond, "condition")) {
[10:58:43.578]                         if (!is.null(pattern)) {
[10:58:43.578]                           computeRestarts <- base::computeRestarts
[10:58:43.578]                           grepl <- base::grepl
[10:58:43.578]                           restarts <- computeRestarts(cond)
[10:58:43.578]                           for (restart in restarts) {
[10:58:43.578]                             name <- restart$name
[10:58:43.578]                             if (is.null(name)) 
[10:58:43.578]                               next
[10:58:43.578]                             if (!grepl(pattern, name)) 
[10:58:43.578]                               next
[10:58:43.578]                             invokeRestart(restart)
[10:58:43.578]                             muffled <- TRUE
[10:58:43.578]                             break
[10:58:43.578]                           }
[10:58:43.578]                         }
[10:58:43.578]                       }
[10:58:43.578]                       invisible(muffled)
[10:58:43.578]                     }
[10:58:43.578]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.578]                   }
[10:58:43.578]                 }
[10:58:43.578]             }
[10:58:43.578]         }))
[10:58:43.578]     }, error = function(ex) {
[10:58:43.578]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.578]                 ...future.rng), started = ...future.startTime, 
[10:58:43.578]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.578]             version = "1.8"), class = "FutureResult")
[10:58:43.578]     }, finally = {
[10:58:43.578]         if (!identical(...future.workdir, getwd())) 
[10:58:43.578]             setwd(...future.workdir)
[10:58:43.578]         {
[10:58:43.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.578]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.578]             }
[10:58:43.578]             base::options(...future.oldOptions)
[10:58:43.578]             if (.Platform$OS.type == "windows") {
[10:58:43.578]                 old_names <- names(...future.oldEnvVars)
[10:58:43.578]                 envs <- base::Sys.getenv()
[10:58:43.578]                 names <- names(envs)
[10:58:43.578]                 common <- intersect(names, old_names)
[10:58:43.578]                 added <- setdiff(names, old_names)
[10:58:43.578]                 removed <- setdiff(old_names, names)
[10:58:43.578]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.578]                   envs[common]]
[10:58:43.578]                 NAMES <- toupper(changed)
[10:58:43.578]                 args <- list()
[10:58:43.578]                 for (kk in seq_along(NAMES)) {
[10:58:43.578]                   name <- changed[[kk]]
[10:58:43.578]                   NAME <- NAMES[[kk]]
[10:58:43.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.578]                     next
[10:58:43.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.578]                 }
[10:58:43.578]                 NAMES <- toupper(added)
[10:58:43.578]                 for (kk in seq_along(NAMES)) {
[10:58:43.578]                   name <- added[[kk]]
[10:58:43.578]                   NAME <- NAMES[[kk]]
[10:58:43.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.578]                     next
[10:58:43.578]                   args[[name]] <- ""
[10:58:43.578]                 }
[10:58:43.578]                 NAMES <- toupper(removed)
[10:58:43.578]                 for (kk in seq_along(NAMES)) {
[10:58:43.578]                   name <- removed[[kk]]
[10:58:43.578]                   NAME <- NAMES[[kk]]
[10:58:43.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.578]                     next
[10:58:43.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.578]                 }
[10:58:43.578]                 if (length(args) > 0) 
[10:58:43.578]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.578]             }
[10:58:43.578]             else {
[10:58:43.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.578]             }
[10:58:43.578]             {
[10:58:43.578]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.578]                   0L) {
[10:58:43.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.578]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.578]                   base::options(opts)
[10:58:43.578]                 }
[10:58:43.578]                 {
[10:58:43.578]                   {
[10:58:43.578]                     NULL
[10:58:43.578]                     RNGkind("Mersenne-Twister")
[10:58:43.578]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.578]                       inherits = FALSE)
[10:58:43.578]                   }
[10:58:43.578]                   options(future.plan = NULL)
[10:58:43.578]                   if (is.na(NA_character_)) 
[10:58:43.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.578]                     .init = FALSE)
[10:58:43.578]                 }
[10:58:43.578]             }
[10:58:43.578]         }
[10:58:43.578]     })
[10:58:43.578]     if (TRUE) {
[10:58:43.578]         base::sink(type = "output", split = FALSE)
[10:58:43.578]         if (TRUE) {
[10:58:43.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.578]         }
[10:58:43.578]         else {
[10:58:43.578]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.578]         }
[10:58:43.578]         base::close(...future.stdout)
[10:58:43.578]         ...future.stdout <- NULL
[10:58:43.578]     }
[10:58:43.578]     ...future.result$conditions <- ...future.conditions
[10:58:43.578]     ...future.result$finished <- base::Sys.time()
[10:58:43.578]     ...future.result
[10:58:43.578] }
[10:58:43.580] assign_globals() ...
[10:58:43.580] List of 5
[10:58:43.580]  $ ...future.FUN            :function (x, ...)  
[10:58:43.580]  $ future.call.arguments    :List of 1
[10:58:43.580]   ..$ singular.ok: logi FALSE
[10:58:43.580]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.580]  $ ...future.elements_ii    :List of 3
[10:58:43.580]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.580]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.580]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.580]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.580]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.580]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.580]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.580]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.580]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.580]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.580]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.580]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.580]  $ ...future.seeds_ii       : NULL
[10:58:43.580]  $ ...future.globals.maxSize: NULL
[10:58:43.580]  - attr(*, "where")=List of 5
[10:58:43.580]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.580]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.580]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.580]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.580]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.580]  - attr(*, "resolved")= logi FALSE
[10:58:43.580]  - attr(*, "total_size")= num 19977
[10:58:43.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.580]  - attr(*, "already-done")= logi TRUE
[10:58:43.590] - reassign environment for ‘...future.FUN’
[10:58:43.590] - copied ‘...future.FUN’ to environment
[10:58:43.590] - copied ‘future.call.arguments’ to environment
[10:58:43.590] - copied ‘...future.elements_ii’ to environment
[10:58:43.590] - copied ‘...future.seeds_ii’ to environment
[10:58:43.590] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.590] assign_globals() ... done
[10:58:43.591] plan(): Setting new future strategy stack:
[10:58:43.591] List of future strategies:
[10:58:43.591] 1. sequential:
[10:58:43.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.591]    - tweaked: FALSE
[10:58:43.591]    - call: NULL
[10:58:43.591] plan(): nbrOfWorkers() = 1
[10:58:43.594] plan(): Setting new future strategy stack:
[10:58:43.594] List of future strategies:
[10:58:43.594] 1. sequential:
[10:58:43.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.594]    - tweaked: FALSE
[10:58:43.594]    - call: plan(strategy)
[10:58:43.594] plan(): nbrOfWorkers() = 1
[10:58:43.595] SequentialFuture started (and completed)
[10:58:43.595] - Launch lazy future ... done
[10:58:43.595] run() for ‘SequentialFuture’ ... done
[10:58:43.595] Created future:
[10:58:43.595] SequentialFuture:
[10:58:43.595] Label: ‘future_by-1’
[10:58:43.595] Expression:
[10:58:43.595] {
[10:58:43.595]     do.call(function(...) {
[10:58:43.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.595]             on.exit(options(oopts), add = TRUE)
[10:58:43.595]         }
[10:58:43.595]         {
[10:58:43.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.595]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.595]             })
[10:58:43.595]         }
[10:58:43.595]     }, args = future.call.arguments)
[10:58:43.595] }
[10:58:43.595] Lazy evaluation: FALSE
[10:58:43.595] Asynchronous evaluation: FALSE
[10:58:43.595] Local evaluation: TRUE
[10:58:43.595] Environment: R_GlobalEnv
[10:58:43.595] Capture standard output: TRUE
[10:58:43.595] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.595] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.595] Packages: 1 packages (‘stats’)
[10:58:43.595] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.595] Resolved: TRUE
[10:58:43.595] Value: 77.05 KiB of class ‘list’
[10:58:43.595] Early signaling: FALSE
[10:58:43.595] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.595] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.596] Chunk #1 of 1 ... DONE
[10:58:43.596] Launching 1 futures (chunks) ... DONE
[10:58:43.596] Resolving 1 futures (chunks) ...
[10:58:43.596] resolve() on list ...
[10:58:43.596]  recursive: 0
[10:58:43.597]  length: 1
[10:58:43.597] 
[10:58:43.597] resolved() for ‘SequentialFuture’ ...
[10:58:43.597] - state: ‘finished’
[10:58:43.597] - run: TRUE
[10:58:43.597] - result: ‘FutureResult’
[10:58:43.597] resolved() for ‘SequentialFuture’ ... done
[10:58:43.597] Future #1
[10:58:43.597] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.597] - nx: 1
[10:58:43.597] - relay: TRUE
[10:58:43.597] - stdout: TRUE
[10:58:43.598] - signal: TRUE
[10:58:43.598] - resignal: FALSE
[10:58:43.598] - force: TRUE
[10:58:43.598] - relayed: [n=1] FALSE
[10:58:43.598] - queued futures: [n=1] FALSE
[10:58:43.598]  - until=1
[10:58:43.598]  - relaying element #1
[10:58:43.598] - relayed: [n=1] TRUE
[10:58:43.598] - queued futures: [n=1] TRUE
[10:58:43.598] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.598]  length: 0 (resolved future 1)
[10:58:43.599] Relaying remaining futures
[10:58:43.599] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.599] - nx: 1
[10:58:43.599] - relay: TRUE
[10:58:43.599] - stdout: TRUE
[10:58:43.599] - signal: TRUE
[10:58:43.599] - resignal: FALSE
[10:58:43.599] - force: TRUE
[10:58:43.599] - relayed: [n=1] TRUE
[10:58:43.599] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.599] - relayed: [n=1] TRUE
[10:58:43.599] - queued futures: [n=1] TRUE
[10:58:43.599] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.600] resolve() on list ... DONE
[10:58:43.600]  - Number of value chunks collected: 1
[10:58:43.600] Resolving 1 futures (chunks) ... DONE
[10:58:43.600] Reducing values from 1 chunks ...
[10:58:43.600]  - Number of values collected after concatenation: 3
[10:58:43.600]  - Number of values expected: 3
[10:58:43.600] Reducing values from 1 chunks ... DONE
[10:58:43.600] future_lapply() ... DONE
[10:58:43.600] future_by_internal() ... DONE
[10:58:43.605] future_by_internal() ...
[10:58:43.605] future_lapply() ...
[10:58:43.606] Number of chunks: 1
[10:58:43.606] getGlobalsAndPackagesXApply() ...
[10:58:43.606]  - future.globals: TRUE
[10:58:43.607] getGlobalsAndPackages() ...
[10:58:43.607] Searching for globals...
[10:58:43.608] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:43.608] Searching for globals ... DONE
[10:58:43.608] Resolving globals: FALSE
[10:58:43.609] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:58:43.609] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:58:43.609] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:43.609] - packages: [1] ‘stats’
[10:58:43.610] getGlobalsAndPackages() ... DONE
[10:58:43.610]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:43.610]  - needed namespaces: [n=1] ‘stats’
[10:58:43.610] Finding globals ... DONE
[10:58:43.610]  - use_args: TRUE
[10:58:43.610]  - Getting '...' globals ...
[10:58:43.610] resolve() on list ...
[10:58:43.610]  recursive: 0
[10:58:43.610]  length: 1
[10:58:43.610]  elements: ‘...’
[10:58:43.611]  length: 0 (resolved future 1)
[10:58:43.611] resolve() on list ... DONE
[10:58:43.611]    - '...' content: [n=0] 
[10:58:43.611] List of 1
[10:58:43.611]  $ ...: list()
[10:58:43.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.611]  - attr(*, "where")=List of 1
[10:58:43.611]   ..$ ...:<environment: 0x55974ddb36d8> 
[10:58:43.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.611]  - attr(*, "resolved")= logi TRUE
[10:58:43.611]  - attr(*, "total_size")= num NA
[10:58:43.613]  - Getting '...' globals ... DONE
[10:58:43.613] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:58:43.613] List of 4
[10:58:43.613]  $ ...future.FUN:function (x)  
[10:58:43.613]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:43.613]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.613]  $ ...          : list()
[10:58:43.613]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.613]  - attr(*, "where")=List of 4
[10:58:43.613]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.613]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:58:43.613]   ..$ wool         :<environment: R_EmptyEnv> 
[10:58:43.613]   ..$ ...          :<environment: 0x55974ddb36d8> 
[10:58:43.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.613]  - attr(*, "resolved")= logi FALSE
[10:58:43.613]  - attr(*, "total_size")= num 18867
[10:58:43.617] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:43.617] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.617] Number of futures (= number of chunks): 1
[10:58:43.617] Launching 1 futures (chunks) ...
[10:58:43.617] Chunk #1 of 1 ...
[10:58:43.617]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.617] getGlobalsAndPackages() ...
[10:58:43.618] Searching for globals...
[10:58:43.618] 
[10:58:43.618] Searching for globals ... DONE
[10:58:43.618] - globals: [0] <none>
[10:58:43.618] getGlobalsAndPackages() ... DONE
[10:58:43.618]    + additional globals found: [n=0] 
[10:58:43.618]    + additional namespaces needed: [n=0] 
[10:58:43.618]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.619]  - seeds: <none>
[10:58:43.619]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.619] getGlobalsAndPackages() ...
[10:58:43.619] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.619] Resolving globals: FALSE
[10:58:43.619] Tweak future expression to call with '...' arguments ...
[10:58:43.619] {
[10:58:43.619]     do.call(function(...) {
[10:58:43.619]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.619]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.619]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.619]             on.exit(options(oopts), add = TRUE)
[10:58:43.619]         }
[10:58:43.619]         {
[10:58:43.619]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.619]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.619]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.619]             })
[10:58:43.619]         }
[10:58:43.619]     }, args = future.call.arguments)
[10:58:43.619] }
[10:58:43.619] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.620] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.620] 
[10:58:43.620] getGlobalsAndPackages() ... DONE
[10:58:43.620] run() for ‘Future’ ...
[10:58:43.620] - state: ‘created’
[10:58:43.620] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:43.621] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.621] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.621]   - Field: ‘label’
[10:58:43.621]   - Field: ‘local’
[10:58:43.621]   - Field: ‘owner’
[10:58:43.621]   - Field: ‘envir’
[10:58:43.622]   - Field: ‘packages’
[10:58:43.622]   - Field: ‘gc’
[10:58:43.622]   - Field: ‘conditions’
[10:58:43.622]   - Field: ‘expr’
[10:58:43.622]   - Field: ‘uuid’
[10:58:43.623]   - Field: ‘seed’
[10:58:43.623]   - Field: ‘version’
[10:58:43.623]   - Field: ‘result’
[10:58:43.623]   - Field: ‘asynchronous’
[10:58:43.623]   - Field: ‘calls’
[10:58:43.623]   - Field: ‘globals’
[10:58:43.623]   - Field: ‘stdout’
[10:58:43.623]   - Field: ‘earlySignal’
[10:58:43.623]   - Field: ‘lazy’
[10:58:43.623]   - Field: ‘state’
[10:58:43.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.623] - Launch lazy future ...
[10:58:43.624] Packages needed by the future expression (n = 1): ‘stats’
[10:58:43.624] Packages needed by future strategies (n = 0): <none>
[10:58:43.624] {
[10:58:43.624]     {
[10:58:43.624]         {
[10:58:43.624]             ...future.startTime <- base::Sys.time()
[10:58:43.624]             {
[10:58:43.624]                 {
[10:58:43.624]                   {
[10:58:43.624]                     {
[10:58:43.624]                       base::local({
[10:58:43.624]                         has_future <- base::requireNamespace("future", 
[10:58:43.624]                           quietly = TRUE)
[10:58:43.624]                         if (has_future) {
[10:58:43.624]                           ns <- base::getNamespace("future")
[10:58:43.624]                           version <- ns[[".package"]][["version"]]
[10:58:43.624]                           if (is.null(version)) 
[10:58:43.624]                             version <- utils::packageVersion("future")
[10:58:43.624]                         }
[10:58:43.624]                         else {
[10:58:43.624]                           version <- NULL
[10:58:43.624]                         }
[10:58:43.624]                         if (!has_future || version < "1.8.0") {
[10:58:43.624]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.624]                             "", base::R.version$version.string), 
[10:58:43.624]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.624]                               "release", "version")], collapse = " "), 
[10:58:43.624]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.624]                             info)
[10:58:43.624]                           info <- base::paste(info, collapse = "; ")
[10:58:43.624]                           if (!has_future) {
[10:58:43.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.624]                               info)
[10:58:43.624]                           }
[10:58:43.624]                           else {
[10:58:43.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.624]                               info, version)
[10:58:43.624]                           }
[10:58:43.624]                           base::stop(msg)
[10:58:43.624]                         }
[10:58:43.624]                       })
[10:58:43.624]                     }
[10:58:43.624]                     base::local({
[10:58:43.624]                       for (pkg in "stats") {
[10:58:43.624]                         base::loadNamespace(pkg)
[10:58:43.624]                         base::library(pkg, character.only = TRUE)
[10:58:43.624]                       }
[10:58:43.624]                     })
[10:58:43.624]                   }
[10:58:43.624]                   ...future.strategy.old <- future::plan("list")
[10:58:43.624]                   options(future.plan = NULL)
[10:58:43.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.624]                 }
[10:58:43.624]                 ...future.workdir <- getwd()
[10:58:43.624]             }
[10:58:43.624]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.624]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.624]         }
[10:58:43.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.624]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.624]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.624]             base::names(...future.oldOptions))
[10:58:43.624]     }
[10:58:43.624]     if (FALSE) {
[10:58:43.624]     }
[10:58:43.624]     else {
[10:58:43.624]         if (TRUE) {
[10:58:43.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.624]                 open = "w")
[10:58:43.624]         }
[10:58:43.624]         else {
[10:58:43.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.624]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.624]         }
[10:58:43.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.624]             base::sink(type = "output", split = FALSE)
[10:58:43.624]             base::close(...future.stdout)
[10:58:43.624]         }, add = TRUE)
[10:58:43.624]     }
[10:58:43.624]     ...future.frame <- base::sys.nframe()
[10:58:43.624]     ...future.conditions <- base::list()
[10:58:43.624]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.624]     if (FALSE) {
[10:58:43.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.624]     }
[10:58:43.624]     ...future.result <- base::tryCatch({
[10:58:43.624]         base::withCallingHandlers({
[10:58:43.624]             ...future.value <- base::withVisible(base::local({
[10:58:43.624]                 do.call(function(...) {
[10:58:43.624]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.624]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.624]                     ...future.globals.maxSize)) {
[10:58:43.624]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.624]                     on.exit(options(oopts), add = TRUE)
[10:58:43.624]                   }
[10:58:43.624]                   {
[10:58:43.624]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.624]                       FUN = function(jj) {
[10:58:43.624]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.624]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.624]                       })
[10:58:43.624]                   }
[10:58:43.624]                 }, args = future.call.arguments)
[10:58:43.624]             }))
[10:58:43.624]             future::FutureResult(value = ...future.value$value, 
[10:58:43.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.624]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.624]                     ...future.globalenv.names))
[10:58:43.624]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.624]         }, condition = base::local({
[10:58:43.624]             c <- base::c
[10:58:43.624]             inherits <- base::inherits
[10:58:43.624]             invokeRestart <- base::invokeRestart
[10:58:43.624]             length <- base::length
[10:58:43.624]             list <- base::list
[10:58:43.624]             seq.int <- base::seq.int
[10:58:43.624]             signalCondition <- base::signalCondition
[10:58:43.624]             sys.calls <- base::sys.calls
[10:58:43.624]             `[[` <- base::`[[`
[10:58:43.624]             `+` <- base::`+`
[10:58:43.624]             `<<-` <- base::`<<-`
[10:58:43.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.624]                   3L)]
[10:58:43.624]             }
[10:58:43.624]             function(cond) {
[10:58:43.624]                 is_error <- inherits(cond, "error")
[10:58:43.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.624]                   NULL)
[10:58:43.624]                 if (is_error) {
[10:58:43.624]                   sessionInformation <- function() {
[10:58:43.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.624]                       search = base::search(), system = base::Sys.info())
[10:58:43.624]                   }
[10:58:43.624]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.624]                     cond$call), session = sessionInformation(), 
[10:58:43.624]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.624]                   signalCondition(cond)
[10:58:43.624]                 }
[10:58:43.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.624]                 "immediateCondition"))) {
[10:58:43.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.624]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.624]                   if (TRUE && !signal) {
[10:58:43.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.624]                     {
[10:58:43.624]                       inherits <- base::inherits
[10:58:43.624]                       invokeRestart <- base::invokeRestart
[10:58:43.624]                       is.null <- base::is.null
[10:58:43.624]                       muffled <- FALSE
[10:58:43.624]                       if (inherits(cond, "message")) {
[10:58:43.624]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.624]                         if (muffled) 
[10:58:43.624]                           invokeRestart("muffleMessage")
[10:58:43.624]                       }
[10:58:43.624]                       else if (inherits(cond, "warning")) {
[10:58:43.624]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.624]                         if (muffled) 
[10:58:43.624]                           invokeRestart("muffleWarning")
[10:58:43.624]                       }
[10:58:43.624]                       else if (inherits(cond, "condition")) {
[10:58:43.624]                         if (!is.null(pattern)) {
[10:58:43.624]                           computeRestarts <- base::computeRestarts
[10:58:43.624]                           grepl <- base::grepl
[10:58:43.624]                           restarts <- computeRestarts(cond)
[10:58:43.624]                           for (restart in restarts) {
[10:58:43.624]                             name <- restart$name
[10:58:43.624]                             if (is.null(name)) 
[10:58:43.624]                               next
[10:58:43.624]                             if (!grepl(pattern, name)) 
[10:58:43.624]                               next
[10:58:43.624]                             invokeRestart(restart)
[10:58:43.624]                             muffled <- TRUE
[10:58:43.624]                             break
[10:58:43.624]                           }
[10:58:43.624]                         }
[10:58:43.624]                       }
[10:58:43.624]                       invisible(muffled)
[10:58:43.624]                     }
[10:58:43.624]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.624]                   }
[10:58:43.624]                 }
[10:58:43.624]                 else {
[10:58:43.624]                   if (TRUE) {
[10:58:43.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.624]                     {
[10:58:43.624]                       inherits <- base::inherits
[10:58:43.624]                       invokeRestart <- base::invokeRestart
[10:58:43.624]                       is.null <- base::is.null
[10:58:43.624]                       muffled <- FALSE
[10:58:43.624]                       if (inherits(cond, "message")) {
[10:58:43.624]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.624]                         if (muffled) 
[10:58:43.624]                           invokeRestart("muffleMessage")
[10:58:43.624]                       }
[10:58:43.624]                       else if (inherits(cond, "warning")) {
[10:58:43.624]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.624]                         if (muffled) 
[10:58:43.624]                           invokeRestart("muffleWarning")
[10:58:43.624]                       }
[10:58:43.624]                       else if (inherits(cond, "condition")) {
[10:58:43.624]                         if (!is.null(pattern)) {
[10:58:43.624]                           computeRestarts <- base::computeRestarts
[10:58:43.624]                           grepl <- base::grepl
[10:58:43.624]                           restarts <- computeRestarts(cond)
[10:58:43.624]                           for (restart in restarts) {
[10:58:43.624]                             name <- restart$name
[10:58:43.624]                             if (is.null(name)) 
[10:58:43.624]                               next
[10:58:43.624]                             if (!grepl(pattern, name)) 
[10:58:43.624]                               next
[10:58:43.624]                             invokeRestart(restart)
[10:58:43.624]                             muffled <- TRUE
[10:58:43.624]                             break
[10:58:43.624]                           }
[10:58:43.624]                         }
[10:58:43.624]                       }
[10:58:43.624]                       invisible(muffled)
[10:58:43.624]                     }
[10:58:43.624]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.624]                   }
[10:58:43.624]                 }
[10:58:43.624]             }
[10:58:43.624]         }))
[10:58:43.624]     }, error = function(ex) {
[10:58:43.624]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.624]                 ...future.rng), started = ...future.startTime, 
[10:58:43.624]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.624]             version = "1.8"), class = "FutureResult")
[10:58:43.624]     }, finally = {
[10:58:43.624]         if (!identical(...future.workdir, getwd())) 
[10:58:43.624]             setwd(...future.workdir)
[10:58:43.624]         {
[10:58:43.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.624]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.624]             }
[10:58:43.624]             base::options(...future.oldOptions)
[10:58:43.624]             if (.Platform$OS.type == "windows") {
[10:58:43.624]                 old_names <- names(...future.oldEnvVars)
[10:58:43.624]                 envs <- base::Sys.getenv()
[10:58:43.624]                 names <- names(envs)
[10:58:43.624]                 common <- intersect(names, old_names)
[10:58:43.624]                 added <- setdiff(names, old_names)
[10:58:43.624]                 removed <- setdiff(old_names, names)
[10:58:43.624]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.624]                   envs[common]]
[10:58:43.624]                 NAMES <- toupper(changed)
[10:58:43.624]                 args <- list()
[10:58:43.624]                 for (kk in seq_along(NAMES)) {
[10:58:43.624]                   name <- changed[[kk]]
[10:58:43.624]                   NAME <- NAMES[[kk]]
[10:58:43.624]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.624]                     next
[10:58:43.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.624]                 }
[10:58:43.624]                 NAMES <- toupper(added)
[10:58:43.624]                 for (kk in seq_along(NAMES)) {
[10:58:43.624]                   name <- added[[kk]]
[10:58:43.624]                   NAME <- NAMES[[kk]]
[10:58:43.624]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.624]                     next
[10:58:43.624]                   args[[name]] <- ""
[10:58:43.624]                 }
[10:58:43.624]                 NAMES <- toupper(removed)
[10:58:43.624]                 for (kk in seq_along(NAMES)) {
[10:58:43.624]                   name <- removed[[kk]]
[10:58:43.624]                   NAME <- NAMES[[kk]]
[10:58:43.624]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.624]                     next
[10:58:43.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.624]                 }
[10:58:43.624]                 if (length(args) > 0) 
[10:58:43.624]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.624]             }
[10:58:43.624]             else {
[10:58:43.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.624]             }
[10:58:43.624]             {
[10:58:43.624]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.624]                   0L) {
[10:58:43.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.624]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.624]                   base::options(opts)
[10:58:43.624]                 }
[10:58:43.624]                 {
[10:58:43.624]                   {
[10:58:43.624]                     NULL
[10:58:43.624]                     RNGkind("Mersenne-Twister")
[10:58:43.624]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.624]                       inherits = FALSE)
[10:58:43.624]                   }
[10:58:43.624]                   options(future.plan = NULL)
[10:58:43.624]                   if (is.na(NA_character_)) 
[10:58:43.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.624]                     .init = FALSE)
[10:58:43.624]                 }
[10:58:43.624]             }
[10:58:43.624]         }
[10:58:43.624]     })
[10:58:43.624]     if (TRUE) {
[10:58:43.624]         base::sink(type = "output", split = FALSE)
[10:58:43.624]         if (TRUE) {
[10:58:43.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.624]         }
[10:58:43.624]         else {
[10:58:43.624]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.624]         }
[10:58:43.624]         base::close(...future.stdout)
[10:58:43.624]         ...future.stdout <- NULL
[10:58:43.624]     }
[10:58:43.624]     ...future.result$conditions <- ...future.conditions
[10:58:43.624]     ...future.result$finished <- base::Sys.time()
[10:58:43.624]     ...future.result
[10:58:43.624] }
[10:58:43.626] assign_globals() ...
[10:58:43.626] List of 7
[10:58:43.626]  $ ...future.FUN            :function (x)  
[10:58:43.626]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:43.626]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.626]  $ future.call.arguments    : list()
[10:58:43.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.626]  $ ...future.elements_ii    :List of 3
[10:58:43.626]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.626]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.626]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.626]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.626]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.626]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.626]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.626]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.626]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.626]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.626]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.626]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.626]  $ ...future.seeds_ii       : NULL
[10:58:43.626]  $ ...future.globals.maxSize: NULL
[10:58:43.626]  - attr(*, "where")=List of 7
[10:58:43.626]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.626]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:58:43.626]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:58:43.626]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.626]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.626]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.626]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.626]  - attr(*, "resolved")= logi FALSE
[10:58:43.626]  - attr(*, "total_size")= num 18867
[10:58:43.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.626]  - attr(*, "already-done")= logi TRUE
[10:58:43.635] - reassign environment for ‘...future.FUN’
[10:58:43.635] - copied ‘...future.FUN’ to environment
[10:58:43.635] - copied ‘breaks’ to environment
[10:58:43.635] - copied ‘wool’ to environment
[10:58:43.635] - copied ‘future.call.arguments’ to environment
[10:58:43.635] - copied ‘...future.elements_ii’ to environment
[10:58:43.635] - copied ‘...future.seeds_ii’ to environment
[10:58:43.636] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.636] assign_globals() ... done
[10:58:43.636] plan(): Setting new future strategy stack:
[10:58:43.636] List of future strategies:
[10:58:43.636] 1. sequential:
[10:58:43.636]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.636]    - tweaked: FALSE
[10:58:43.636]    - call: NULL
[10:58:43.636] plan(): nbrOfWorkers() = 1
[10:58:43.639] plan(): Setting new future strategy stack:
[10:58:43.639] List of future strategies:
[10:58:43.639] 1. sequential:
[10:58:43.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.639]    - tweaked: FALSE
[10:58:43.639]    - call: plan(strategy)
[10:58:43.640] plan(): nbrOfWorkers() = 1
[10:58:43.640] SequentialFuture started (and completed)
[10:58:43.640] - Launch lazy future ... done
[10:58:43.640] run() for ‘SequentialFuture’ ... done
[10:58:43.640] Created future:
[10:58:43.640] SequentialFuture:
[10:58:43.640] Label: ‘future_by-1’
[10:58:43.640] Expression:
[10:58:43.640] {
[10:58:43.640]     do.call(function(...) {
[10:58:43.640]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.640]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.640]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.640]             on.exit(options(oopts), add = TRUE)
[10:58:43.640]         }
[10:58:43.640]         {
[10:58:43.640]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.640]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.640]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.640]             })
[10:58:43.640]         }
[10:58:43.640]     }, args = future.call.arguments)
[10:58:43.640] }
[10:58:43.640] Lazy evaluation: FALSE
[10:58:43.640] Asynchronous evaluation: FALSE
[10:58:43.640] Local evaluation: TRUE
[10:58:43.640] Environment: 0x55974da23a70
[10:58:43.640] Capture standard output: TRUE
[10:58:43.640] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.640] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[10:58:43.640] Packages: 1 packages (‘stats’)
[10:58:43.640] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.640] Resolved: TRUE
[10:58:43.640] Value: 78.42 KiB of class ‘list’
[10:58:43.640] Early signaling: FALSE
[10:58:43.640] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.640] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.642] Chunk #1 of 1 ... DONE
[10:58:43.642] Launching 1 futures (chunks) ... DONE
[10:58:43.642] Resolving 1 futures (chunks) ...
[10:58:43.642] resolve() on list ...
[10:58:43.643]  recursive: 0
[10:58:43.643]  length: 1
[10:58:43.643] 
[10:58:43.643] resolved() for ‘SequentialFuture’ ...
[10:58:43.643] - state: ‘finished’
[10:58:43.643] - run: TRUE
[10:58:43.643] - result: ‘FutureResult’
[10:58:43.643] resolved() for ‘SequentialFuture’ ... done
[10:58:43.643] Future #1
[10:58:43.643] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.643] - nx: 1
[10:58:43.644] - relay: TRUE
[10:58:43.644] - stdout: TRUE
[10:58:43.644] - signal: TRUE
[10:58:43.644] - resignal: FALSE
[10:58:43.644] - force: TRUE
[10:58:43.644] - relayed: [n=1] FALSE
[10:58:43.644] - queued futures: [n=1] FALSE
[10:58:43.644]  - until=1
[10:58:43.644]  - relaying element #1
[10:58:43.644] - relayed: [n=1] TRUE
[10:58:43.644] - queued futures: [n=1] TRUE
[10:58:43.644] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.645]  length: 0 (resolved future 1)
[10:58:43.645] Relaying remaining futures
[10:58:43.645] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.645] - nx: 1
[10:58:43.645] - relay: TRUE
[10:58:43.645] - stdout: TRUE
[10:58:43.645] - signal: TRUE
[10:58:43.645] - resignal: FALSE
[10:58:43.645] - force: TRUE
[10:58:43.645] - relayed: [n=1] TRUE
[10:58:43.645] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.645] - relayed: [n=1] TRUE
[10:58:43.646] - queued futures: [n=1] TRUE
[10:58:43.646] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.646] resolve() on list ... DONE
[10:58:43.646]  - Number of value chunks collected: 1
[10:58:43.646] Resolving 1 futures (chunks) ... DONE
[10:58:43.646] Reducing values from 1 chunks ...
[10:58:43.646]  - Number of values collected after concatenation: 3
[10:58:43.646]  - Number of values expected: 3
[10:58:43.646] Reducing values from 1 chunks ... DONE
[10:58:43.646] future_lapply() ... DONE
[10:58:43.646] future_by_internal() ... DONE
[10:58:43.647] future_by_internal() ...
[10:58:43.647] future_lapply() ...
[10:58:43.647] Number of chunks: 1
[10:58:43.648] getGlobalsAndPackagesXApply() ...
[10:58:43.648]  - future.globals: TRUE
[10:58:43.648] getGlobalsAndPackages() ...
[10:58:43.648] Searching for globals...
[10:58:43.649] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.649] Searching for globals ... DONE
[10:58:43.649] Resolving globals: FALSE
[10:58:43.649] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.649] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.650] - globals: [1] ‘FUN’
[10:58:43.650] 
[10:58:43.650] getGlobalsAndPackages() ... DONE
[10:58:43.650]  - globals found/used: [n=1] ‘FUN’
[10:58:43.650]  - needed namespaces: [n=0] 
[10:58:43.650] Finding globals ... DONE
[10:58:43.650]  - use_args: TRUE
[10:58:43.650]  - Getting '...' globals ...
[10:58:43.650] resolve() on list ...
[10:58:43.651]  recursive: 0
[10:58:43.651]  length: 1
[10:58:43.651]  elements: ‘...’
[10:58:43.651]  length: 0 (resolved future 1)
[10:58:43.651] resolve() on list ... DONE
[10:58:43.651]    - '...' content: [n=0] 
[10:58:43.651] List of 1
[10:58:43.651]  $ ...: list()
[10:58:43.651]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.651]  - attr(*, "where")=List of 1
[10:58:43.651]   ..$ ...:<environment: 0x55974ce0bff8> 
[10:58:43.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.651]  - attr(*, "resolved")= logi TRUE
[10:58:43.651]  - attr(*, "total_size")= num NA
[10:58:43.653]  - Getting '...' globals ... DONE
[10:58:43.653] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.653] List of 2
[10:58:43.653]  $ ...future.FUN:function (object, ...)  
[10:58:43.653]  $ ...          : list()
[10:58:43.653]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.653]  - attr(*, "where")=List of 2
[10:58:43.653]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.653]   ..$ ...          :<environment: 0x55974ce0bff8> 
[10:58:43.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.653]  - attr(*, "resolved")= logi FALSE
[10:58:43.653]  - attr(*, "total_size")= num 19278
[10:58:43.656] Packages to be attached in all futures: [n=0] 
[10:58:43.656] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.656] Number of futures (= number of chunks): 1
[10:58:43.656] Launching 1 futures (chunks) ...
[10:58:43.656] Chunk #1 of 1 ...
[10:58:43.656]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.657] getGlobalsAndPackages() ...
[10:58:43.657] Searching for globals...
[10:58:43.657] 
[10:58:43.657] Searching for globals ... DONE
[10:58:43.657] - globals: [0] <none>
[10:58:43.657] getGlobalsAndPackages() ... DONE
[10:58:43.657]    + additional globals found: [n=0] 
[10:58:43.657]    + additional namespaces needed: [n=0] 
[10:58:43.657]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.658]  - seeds: <none>
[10:58:43.658]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.658] getGlobalsAndPackages() ...
[10:58:43.658] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.658] Resolving globals: FALSE
[10:58:43.658] Tweak future expression to call with '...' arguments ...
[10:58:43.658] {
[10:58:43.658]     do.call(function(...) {
[10:58:43.658]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.658]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.658]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.658]             on.exit(options(oopts), add = TRUE)
[10:58:43.658]         }
[10:58:43.658]         {
[10:58:43.658]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.658]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.658]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.658]             })
[10:58:43.658]         }
[10:58:43.658]     }, args = future.call.arguments)
[10:58:43.658] }
[10:58:43.658] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.659] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.659] 
[10:58:43.659] getGlobalsAndPackages() ... DONE
[10:58:43.660] run() for ‘Future’ ...
[10:58:43.660] - state: ‘created’
[10:58:43.660] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:43.660] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.661]   - Field: ‘label’
[10:58:43.661]   - Field: ‘local’
[10:58:43.661]   - Field: ‘owner’
[10:58:43.661]   - Field: ‘envir’
[10:58:43.661]   - Field: ‘packages’
[10:58:43.661]   - Field: ‘gc’
[10:58:43.661]   - Field: ‘conditions’
[10:58:43.661]   - Field: ‘expr’
[10:58:43.661]   - Field: ‘uuid’
[10:58:43.661]   - Field: ‘seed’
[10:58:43.661]   - Field: ‘version’
[10:58:43.661]   - Field: ‘result’
[10:58:43.662]   - Field: ‘asynchronous’
[10:58:43.662]   - Field: ‘calls’
[10:58:43.662]   - Field: ‘globals’
[10:58:43.662]   - Field: ‘stdout’
[10:58:43.662]   - Field: ‘earlySignal’
[10:58:43.662]   - Field: ‘lazy’
[10:58:43.662]   - Field: ‘state’
[10:58:43.662] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.662] - Launch lazy future ...
[10:58:43.662] Packages needed by the future expression (n = 0): <none>
[10:58:43.662] Packages needed by future strategies (n = 0): <none>
[10:58:43.663] {
[10:58:43.663]     {
[10:58:43.663]         {
[10:58:43.663]             ...future.startTime <- base::Sys.time()
[10:58:43.663]             {
[10:58:43.663]                 {
[10:58:43.663]                   {
[10:58:43.663]                     base::local({
[10:58:43.663]                       has_future <- base::requireNamespace("future", 
[10:58:43.663]                         quietly = TRUE)
[10:58:43.663]                       if (has_future) {
[10:58:43.663]                         ns <- base::getNamespace("future")
[10:58:43.663]                         version <- ns[[".package"]][["version"]]
[10:58:43.663]                         if (is.null(version)) 
[10:58:43.663]                           version <- utils::packageVersion("future")
[10:58:43.663]                       }
[10:58:43.663]                       else {
[10:58:43.663]                         version <- NULL
[10:58:43.663]                       }
[10:58:43.663]                       if (!has_future || version < "1.8.0") {
[10:58:43.663]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.663]                           "", base::R.version$version.string), 
[10:58:43.663]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.663]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.663]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.663]                             "release", "version")], collapse = " "), 
[10:58:43.663]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.663]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.663]                           info)
[10:58:43.663]                         info <- base::paste(info, collapse = "; ")
[10:58:43.663]                         if (!has_future) {
[10:58:43.663]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.663]                             info)
[10:58:43.663]                         }
[10:58:43.663]                         else {
[10:58:43.663]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.663]                             info, version)
[10:58:43.663]                         }
[10:58:43.663]                         base::stop(msg)
[10:58:43.663]                       }
[10:58:43.663]                     })
[10:58:43.663]                   }
[10:58:43.663]                   ...future.strategy.old <- future::plan("list")
[10:58:43.663]                   options(future.plan = NULL)
[10:58:43.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.663]                 }
[10:58:43.663]                 ...future.workdir <- getwd()
[10:58:43.663]             }
[10:58:43.663]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.663]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.663]         }
[10:58:43.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.663]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.663]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.663]             base::names(...future.oldOptions))
[10:58:43.663]     }
[10:58:43.663]     if (FALSE) {
[10:58:43.663]     }
[10:58:43.663]     else {
[10:58:43.663]         if (TRUE) {
[10:58:43.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.663]                 open = "w")
[10:58:43.663]         }
[10:58:43.663]         else {
[10:58:43.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.663]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.663]         }
[10:58:43.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.663]             base::sink(type = "output", split = FALSE)
[10:58:43.663]             base::close(...future.stdout)
[10:58:43.663]         }, add = TRUE)
[10:58:43.663]     }
[10:58:43.663]     ...future.frame <- base::sys.nframe()
[10:58:43.663]     ...future.conditions <- base::list()
[10:58:43.663]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.663]     if (FALSE) {
[10:58:43.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.663]     }
[10:58:43.663]     ...future.result <- base::tryCatch({
[10:58:43.663]         base::withCallingHandlers({
[10:58:43.663]             ...future.value <- base::withVisible(base::local({
[10:58:43.663]                 do.call(function(...) {
[10:58:43.663]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.663]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.663]                     ...future.globals.maxSize)) {
[10:58:43.663]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.663]                     on.exit(options(oopts), add = TRUE)
[10:58:43.663]                   }
[10:58:43.663]                   {
[10:58:43.663]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.663]                       FUN = function(jj) {
[10:58:43.663]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.663]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.663]                       })
[10:58:43.663]                   }
[10:58:43.663]                 }, args = future.call.arguments)
[10:58:43.663]             }))
[10:58:43.663]             future::FutureResult(value = ...future.value$value, 
[10:58:43.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.663]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.663]                     ...future.globalenv.names))
[10:58:43.663]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.663]         }, condition = base::local({
[10:58:43.663]             c <- base::c
[10:58:43.663]             inherits <- base::inherits
[10:58:43.663]             invokeRestart <- base::invokeRestart
[10:58:43.663]             length <- base::length
[10:58:43.663]             list <- base::list
[10:58:43.663]             seq.int <- base::seq.int
[10:58:43.663]             signalCondition <- base::signalCondition
[10:58:43.663]             sys.calls <- base::sys.calls
[10:58:43.663]             `[[` <- base::`[[`
[10:58:43.663]             `+` <- base::`+`
[10:58:43.663]             `<<-` <- base::`<<-`
[10:58:43.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.663]                   3L)]
[10:58:43.663]             }
[10:58:43.663]             function(cond) {
[10:58:43.663]                 is_error <- inherits(cond, "error")
[10:58:43.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.663]                   NULL)
[10:58:43.663]                 if (is_error) {
[10:58:43.663]                   sessionInformation <- function() {
[10:58:43.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.663]                       search = base::search(), system = base::Sys.info())
[10:58:43.663]                   }
[10:58:43.663]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.663]                     cond$call), session = sessionInformation(), 
[10:58:43.663]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.663]                   signalCondition(cond)
[10:58:43.663]                 }
[10:58:43.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.663]                 "immediateCondition"))) {
[10:58:43.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.663]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.663]                   if (TRUE && !signal) {
[10:58:43.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.663]                     {
[10:58:43.663]                       inherits <- base::inherits
[10:58:43.663]                       invokeRestart <- base::invokeRestart
[10:58:43.663]                       is.null <- base::is.null
[10:58:43.663]                       muffled <- FALSE
[10:58:43.663]                       if (inherits(cond, "message")) {
[10:58:43.663]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.663]                         if (muffled) 
[10:58:43.663]                           invokeRestart("muffleMessage")
[10:58:43.663]                       }
[10:58:43.663]                       else if (inherits(cond, "warning")) {
[10:58:43.663]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.663]                         if (muffled) 
[10:58:43.663]                           invokeRestart("muffleWarning")
[10:58:43.663]                       }
[10:58:43.663]                       else if (inherits(cond, "condition")) {
[10:58:43.663]                         if (!is.null(pattern)) {
[10:58:43.663]                           computeRestarts <- base::computeRestarts
[10:58:43.663]                           grepl <- base::grepl
[10:58:43.663]                           restarts <- computeRestarts(cond)
[10:58:43.663]                           for (restart in restarts) {
[10:58:43.663]                             name <- restart$name
[10:58:43.663]                             if (is.null(name)) 
[10:58:43.663]                               next
[10:58:43.663]                             if (!grepl(pattern, name)) 
[10:58:43.663]                               next
[10:58:43.663]                             invokeRestart(restart)
[10:58:43.663]                             muffled <- TRUE
[10:58:43.663]                             break
[10:58:43.663]                           }
[10:58:43.663]                         }
[10:58:43.663]                       }
[10:58:43.663]                       invisible(muffled)
[10:58:43.663]                     }
[10:58:43.663]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.663]                   }
[10:58:43.663]                 }
[10:58:43.663]                 else {
[10:58:43.663]                   if (TRUE) {
[10:58:43.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.663]                     {
[10:58:43.663]                       inherits <- base::inherits
[10:58:43.663]                       invokeRestart <- base::invokeRestart
[10:58:43.663]                       is.null <- base::is.null
[10:58:43.663]                       muffled <- FALSE
[10:58:43.663]                       if (inherits(cond, "message")) {
[10:58:43.663]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.663]                         if (muffled) 
[10:58:43.663]                           invokeRestart("muffleMessage")
[10:58:43.663]                       }
[10:58:43.663]                       else if (inherits(cond, "warning")) {
[10:58:43.663]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.663]                         if (muffled) 
[10:58:43.663]                           invokeRestart("muffleWarning")
[10:58:43.663]                       }
[10:58:43.663]                       else if (inherits(cond, "condition")) {
[10:58:43.663]                         if (!is.null(pattern)) {
[10:58:43.663]                           computeRestarts <- base::computeRestarts
[10:58:43.663]                           grepl <- base::grepl
[10:58:43.663]                           restarts <- computeRestarts(cond)
[10:58:43.663]                           for (restart in restarts) {
[10:58:43.663]                             name <- restart$name
[10:58:43.663]                             if (is.null(name)) 
[10:58:43.663]                               next
[10:58:43.663]                             if (!grepl(pattern, name)) 
[10:58:43.663]                               next
[10:58:43.663]                             invokeRestart(restart)
[10:58:43.663]                             muffled <- TRUE
[10:58:43.663]                             break
[10:58:43.663]                           }
[10:58:43.663]                         }
[10:58:43.663]                       }
[10:58:43.663]                       invisible(muffled)
[10:58:43.663]                     }
[10:58:43.663]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.663]                   }
[10:58:43.663]                 }
[10:58:43.663]             }
[10:58:43.663]         }))
[10:58:43.663]     }, error = function(ex) {
[10:58:43.663]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.663]                 ...future.rng), started = ...future.startTime, 
[10:58:43.663]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.663]             version = "1.8"), class = "FutureResult")
[10:58:43.663]     }, finally = {
[10:58:43.663]         if (!identical(...future.workdir, getwd())) 
[10:58:43.663]             setwd(...future.workdir)
[10:58:43.663]         {
[10:58:43.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.663]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.663]             }
[10:58:43.663]             base::options(...future.oldOptions)
[10:58:43.663]             if (.Platform$OS.type == "windows") {
[10:58:43.663]                 old_names <- names(...future.oldEnvVars)
[10:58:43.663]                 envs <- base::Sys.getenv()
[10:58:43.663]                 names <- names(envs)
[10:58:43.663]                 common <- intersect(names, old_names)
[10:58:43.663]                 added <- setdiff(names, old_names)
[10:58:43.663]                 removed <- setdiff(old_names, names)
[10:58:43.663]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.663]                   envs[common]]
[10:58:43.663]                 NAMES <- toupper(changed)
[10:58:43.663]                 args <- list()
[10:58:43.663]                 for (kk in seq_along(NAMES)) {
[10:58:43.663]                   name <- changed[[kk]]
[10:58:43.663]                   NAME <- NAMES[[kk]]
[10:58:43.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.663]                     next
[10:58:43.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.663]                 }
[10:58:43.663]                 NAMES <- toupper(added)
[10:58:43.663]                 for (kk in seq_along(NAMES)) {
[10:58:43.663]                   name <- added[[kk]]
[10:58:43.663]                   NAME <- NAMES[[kk]]
[10:58:43.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.663]                     next
[10:58:43.663]                   args[[name]] <- ""
[10:58:43.663]                 }
[10:58:43.663]                 NAMES <- toupper(removed)
[10:58:43.663]                 for (kk in seq_along(NAMES)) {
[10:58:43.663]                   name <- removed[[kk]]
[10:58:43.663]                   NAME <- NAMES[[kk]]
[10:58:43.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.663]                     next
[10:58:43.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.663]                 }
[10:58:43.663]                 if (length(args) > 0) 
[10:58:43.663]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.663]             }
[10:58:43.663]             else {
[10:58:43.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.663]             }
[10:58:43.663]             {
[10:58:43.663]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.663]                   0L) {
[10:58:43.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.663]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.663]                   base::options(opts)
[10:58:43.663]                 }
[10:58:43.663]                 {
[10:58:43.663]                   {
[10:58:43.663]                     NULL
[10:58:43.663]                     RNGkind("Mersenne-Twister")
[10:58:43.663]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.663]                       inherits = FALSE)
[10:58:43.663]                   }
[10:58:43.663]                   options(future.plan = NULL)
[10:58:43.663]                   if (is.na(NA_character_)) 
[10:58:43.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.663]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.663]                     .init = FALSE)
[10:58:43.663]                 }
[10:58:43.663]             }
[10:58:43.663]         }
[10:58:43.663]     })
[10:58:43.663]     if (TRUE) {
[10:58:43.663]         base::sink(type = "output", split = FALSE)
[10:58:43.663]         if (TRUE) {
[10:58:43.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.663]         }
[10:58:43.663]         else {
[10:58:43.663]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.663]         }
[10:58:43.663]         base::close(...future.stdout)
[10:58:43.663]         ...future.stdout <- NULL
[10:58:43.663]     }
[10:58:43.663]     ...future.result$conditions <- ...future.conditions
[10:58:43.663]     ...future.result$finished <- base::Sys.time()
[10:58:43.663]     ...future.result
[10:58:43.663] }
[10:58:43.665] assign_globals() ...
[10:58:43.665] List of 5
[10:58:43.665]  $ ...future.FUN            :function (object, ...)  
[10:58:43.665]  $ future.call.arguments    : list()
[10:58:43.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.665]  $ ...future.elements_ii    :List of 3
[10:58:43.665]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.665]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.665]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.665]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.665]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.665]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.665]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.665]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.665]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.665]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.665]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.665]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.665]  $ ...future.seeds_ii       : NULL
[10:58:43.665]  $ ...future.globals.maxSize: NULL
[10:58:43.665]  - attr(*, "where")=List of 5
[10:58:43.665]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.665]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.665]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.665]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.665]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.665]  - attr(*, "resolved")= logi FALSE
[10:58:43.665]  - attr(*, "total_size")= num 19278
[10:58:43.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.665]  - attr(*, "already-done")= logi TRUE
[10:58:43.672] - copied ‘...future.FUN’ to environment
[10:58:43.672] - copied ‘future.call.arguments’ to environment
[10:58:43.672] - copied ‘...future.elements_ii’ to environment
[10:58:43.673] - copied ‘...future.seeds_ii’ to environment
[10:58:43.673] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.673] assign_globals() ... done
[10:58:43.673] plan(): Setting new future strategy stack:
[10:58:43.673] List of future strategies:
[10:58:43.673] 1. sequential:
[10:58:43.673]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.673]    - tweaked: FALSE
[10:58:43.673]    - call: NULL
[10:58:43.673] plan(): nbrOfWorkers() = 1
[10:58:43.675] plan(): Setting new future strategy stack:
[10:58:43.676] List of future strategies:
[10:58:43.676] 1. sequential:
[10:58:43.676]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.676]    - tweaked: FALSE
[10:58:43.676]    - call: plan(strategy)
[10:58:43.676] plan(): nbrOfWorkers() = 1
[10:58:43.676] SequentialFuture started (and completed)
[10:58:43.676] - Launch lazy future ... done
[10:58:43.676] run() for ‘SequentialFuture’ ... done
[10:58:43.676] Created future:
[10:58:43.677] SequentialFuture:
[10:58:43.677] Label: ‘future_by-1’
[10:58:43.677] Expression:
[10:58:43.677] {
[10:58:43.677]     do.call(function(...) {
[10:58:43.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.677]             on.exit(options(oopts), add = TRUE)
[10:58:43.677]         }
[10:58:43.677]         {
[10:58:43.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.677]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.677]             })
[10:58:43.677]         }
[10:58:43.677]     }, args = future.call.arguments)
[10:58:43.677] }
[10:58:43.677] Lazy evaluation: FALSE
[10:58:43.677] Asynchronous evaluation: FALSE
[10:58:43.677] Local evaluation: TRUE
[10:58:43.677] Environment: 0x55974cf5a250
[10:58:43.677] Capture standard output: TRUE
[10:58:43.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.677] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.677] Packages: <none>
[10:58:43.677] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.677] Resolved: TRUE
[10:58:43.677] Value: 1.39 KiB of class ‘list’
[10:58:43.677] Early signaling: FALSE
[10:58:43.677] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.677] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.677] Chunk #1 of 1 ... DONE
[10:58:43.677] Launching 1 futures (chunks) ... DONE
[10:58:43.678] Resolving 1 futures (chunks) ...
[10:58:43.678] resolve() on list ...
[10:58:43.678]  recursive: 0
[10:58:43.678]  length: 1
[10:58:43.678] 
[10:58:43.678] resolved() for ‘SequentialFuture’ ...
[10:58:43.678] - state: ‘finished’
[10:58:43.678] - run: TRUE
[10:58:43.679] - result: ‘FutureResult’
[10:58:43.679] resolved() for ‘SequentialFuture’ ... done
[10:58:43.679] Future #1
[10:58:43.680] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.680] - nx: 1
[10:58:43.680] - relay: TRUE
[10:58:43.680] - stdout: TRUE
[10:58:43.680] - signal: TRUE
[10:58:43.680] - resignal: FALSE
[10:58:43.680] - force: TRUE
[10:58:43.680] - relayed: [n=1] FALSE
[10:58:43.680] - queued futures: [n=1] FALSE
[10:58:43.680]  - until=1
[10:58:43.681]  - relaying element #1
[10:58:43.681] - relayed: [n=1] TRUE
[10:58:43.681] - queued futures: [n=1] TRUE
[10:58:43.681] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.681]  length: 0 (resolved future 1)
[10:58:43.681] Relaying remaining futures
[10:58:43.681] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.681] - nx: 1
[10:58:43.681] - relay: TRUE
[10:58:43.681] - stdout: TRUE
[10:58:43.681] - signal: TRUE
[10:58:43.682] - resignal: FALSE
[10:58:43.682] - force: TRUE
[10:58:43.682] - relayed: [n=1] TRUE
[10:58:43.682] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.682] - relayed: [n=1] TRUE
[10:58:43.682] - queued futures: [n=1] TRUE
[10:58:43.682] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.682] resolve() on list ... DONE
[10:58:43.682]  - Number of value chunks collected: 1
[10:58:43.682] Resolving 1 futures (chunks) ... DONE
[10:58:43.682] Reducing values from 1 chunks ...
[10:58:43.683]  - Number of values collected after concatenation: 3
[10:58:43.683]  - Number of values expected: 3
[10:58:43.683] Reducing values from 1 chunks ... DONE
[10:58:43.683] future_lapply() ... DONE
[10:58:43.683] future_by_internal() ... DONE
[10:58:43.684] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:58:43.684] future_lapply() ...
[10:58:43.685] Number of chunks: 1
[10:58:43.685] getGlobalsAndPackagesXApply() ...
[10:58:43.685]  - future.globals: TRUE
[10:58:43.685] getGlobalsAndPackages() ...
[10:58:43.685] Searching for globals...
[10:58:43.686] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.686] Searching for globals ... DONE
[10:58:43.686] Resolving globals: FALSE
[10:58:43.686] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.687] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.687] - globals: [1] ‘FUN’
[10:58:43.687] 
[10:58:43.687] getGlobalsAndPackages() ... DONE
[10:58:43.687]  - globals found/used: [n=1] ‘FUN’
[10:58:43.687]  - needed namespaces: [n=0] 
[10:58:43.687] Finding globals ... DONE
[10:58:43.687]  - use_args: TRUE
[10:58:43.687]  - Getting '...' globals ...
[10:58:43.688] resolve() on list ...
[10:58:43.688]  recursive: 0
[10:58:43.688]  length: 1
[10:58:43.688]  elements: ‘...’
[10:58:43.688]  length: 0 (resolved future 1)
[10:58:43.688] resolve() on list ... DONE
[10:58:43.688]    - '...' content: [n=0] 
[10:58:43.688] List of 1
[10:58:43.688]  $ ...: list()
[10:58:43.688]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.688]  - attr(*, "where")=List of 1
[10:58:43.688]   ..$ ...:<environment: 0x55974cf3ee60> 
[10:58:43.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.688]  - attr(*, "resolved")= logi TRUE
[10:58:43.688]  - attr(*, "total_size")= num NA
[10:58:43.690]  - Getting '...' globals ... DONE
[10:58:43.691] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.691] List of 2
[10:58:43.691]  $ ...future.FUN:function (object, ...)  
[10:58:43.691]  $ ...          : list()
[10:58:43.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.691]  - attr(*, "where")=List of 2
[10:58:43.691]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.691]   ..$ ...          :<environment: 0x55974cf3ee60> 
[10:58:43.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.691]  - attr(*, "resolved")= logi FALSE
[10:58:43.691]  - attr(*, "total_size")= num 18647
[10:58:43.693] Packages to be attached in all futures: [n=0] 
[10:58:43.693] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.693] Number of futures (= number of chunks): 1
[10:58:43.693] Launching 1 futures (chunks) ...
[10:58:43.694] Chunk #1 of 1 ...
[10:58:43.694]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.694] getGlobalsAndPackages() ...
[10:58:43.694] Searching for globals...
[10:58:43.694] 
[10:58:43.694] Searching for globals ... DONE
[10:58:43.694] - globals: [0] <none>
[10:58:43.694] getGlobalsAndPackages() ... DONE
[10:58:43.695]    + additional globals found: [n=0] 
[10:58:43.695]    + additional namespaces needed: [n=0] 
[10:58:43.695]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.695]  - seeds: <none>
[10:58:43.695]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.695] getGlobalsAndPackages() ...
[10:58:43.695] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.695] Resolving globals: FALSE
[10:58:43.695] Tweak future expression to call with '...' arguments ...
[10:58:43.695] {
[10:58:43.695]     do.call(function(...) {
[10:58:43.695]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.695]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.695]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.695]             on.exit(options(oopts), add = TRUE)
[10:58:43.695]         }
[10:58:43.695]         {
[10:58:43.695]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.695]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.695]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.695]             })
[10:58:43.695]         }
[10:58:43.695]     }, args = future.call.arguments)
[10:58:43.695] }
[10:58:43.696] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.696] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.696] 
[10:58:43.696] getGlobalsAndPackages() ... DONE
[10:58:43.697] run() for ‘Future’ ...
[10:58:43.697] - state: ‘created’
[10:58:43.698] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:43.698] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:43.698]   - Field: ‘label’
[10:58:43.698]   - Field: ‘local’
[10:58:43.698]   - Field: ‘owner’
[10:58:43.698]   - Field: ‘envir’
[10:58:43.698]   - Field: ‘packages’
[10:58:43.698]   - Field: ‘gc’
[10:58:43.699]   - Field: ‘conditions’
[10:58:43.699]   - Field: ‘expr’
[10:58:43.699]   - Field: ‘uuid’
[10:58:43.699]   - Field: ‘seed’
[10:58:43.699]   - Field: ‘version’
[10:58:43.699]   - Field: ‘result’
[10:58:43.699]   - Field: ‘asynchronous’
[10:58:43.699]   - Field: ‘calls’
[10:58:43.699]   - Field: ‘globals’
[10:58:43.699]   - Field: ‘stdout’
[10:58:43.699]   - Field: ‘earlySignal’
[10:58:43.699]   - Field: ‘lazy’
[10:58:43.700]   - Field: ‘state’
[10:58:43.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:43.700] - Launch lazy future ...
[10:58:43.700] Packages needed by the future expression (n = 0): <none>
[10:58:43.700] Packages needed by future strategies (n = 0): <none>
[10:58:43.700] {
[10:58:43.700]     {
[10:58:43.700]         {
[10:58:43.700]             ...future.startTime <- base::Sys.time()
[10:58:43.700]             {
[10:58:43.700]                 {
[10:58:43.700]                   {
[10:58:43.700]                     base::local({
[10:58:43.700]                       has_future <- base::requireNamespace("future", 
[10:58:43.700]                         quietly = TRUE)
[10:58:43.700]                       if (has_future) {
[10:58:43.700]                         ns <- base::getNamespace("future")
[10:58:43.700]                         version <- ns[[".package"]][["version"]]
[10:58:43.700]                         if (is.null(version)) 
[10:58:43.700]                           version <- utils::packageVersion("future")
[10:58:43.700]                       }
[10:58:43.700]                       else {
[10:58:43.700]                         version <- NULL
[10:58:43.700]                       }
[10:58:43.700]                       if (!has_future || version < "1.8.0") {
[10:58:43.700]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.700]                           "", base::R.version$version.string), 
[10:58:43.700]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:43.700]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.700]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.700]                             "release", "version")], collapse = " "), 
[10:58:43.700]                           hostname = base::Sys.info()[["nodename"]])
[10:58:43.700]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.700]                           info)
[10:58:43.700]                         info <- base::paste(info, collapse = "; ")
[10:58:43.700]                         if (!has_future) {
[10:58:43.700]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.700]                             info)
[10:58:43.700]                         }
[10:58:43.700]                         else {
[10:58:43.700]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.700]                             info, version)
[10:58:43.700]                         }
[10:58:43.700]                         base::stop(msg)
[10:58:43.700]                       }
[10:58:43.700]                     })
[10:58:43.700]                   }
[10:58:43.700]                   ...future.strategy.old <- future::plan("list")
[10:58:43.700]                   options(future.plan = NULL)
[10:58:43.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.700]                 }
[10:58:43.700]                 ...future.workdir <- getwd()
[10:58:43.700]             }
[10:58:43.700]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.700]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.700]         }
[10:58:43.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:43.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.700]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.700]             base::names(...future.oldOptions))
[10:58:43.700]     }
[10:58:43.700]     if (FALSE) {
[10:58:43.700]     }
[10:58:43.700]     else {
[10:58:43.700]         if (TRUE) {
[10:58:43.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.700]                 open = "w")
[10:58:43.700]         }
[10:58:43.700]         else {
[10:58:43.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.700]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.700]         }
[10:58:43.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.700]             base::sink(type = "output", split = FALSE)
[10:58:43.700]             base::close(...future.stdout)
[10:58:43.700]         }, add = TRUE)
[10:58:43.700]     }
[10:58:43.700]     ...future.frame <- base::sys.nframe()
[10:58:43.700]     ...future.conditions <- base::list()
[10:58:43.700]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.700]     if (FALSE) {
[10:58:43.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.700]     }
[10:58:43.700]     ...future.result <- base::tryCatch({
[10:58:43.700]         base::withCallingHandlers({
[10:58:43.700]             ...future.value <- base::withVisible(base::local({
[10:58:43.700]                 do.call(function(...) {
[10:58:43.700]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.700]                   if (!identical(...future.globals.maxSize.org, 
[10:58:43.700]                     ...future.globals.maxSize)) {
[10:58:43.700]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.700]                     on.exit(options(oopts), add = TRUE)
[10:58:43.700]                   }
[10:58:43.700]                   {
[10:58:43.700]                     lapply(seq_along(...future.elements_ii), 
[10:58:43.700]                       FUN = function(jj) {
[10:58:43.700]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.700]                         ...future.FUN(...future.X_jj, ...)
[10:58:43.700]                       })
[10:58:43.700]                   }
[10:58:43.700]                 }, args = future.call.arguments)
[10:58:43.700]             }))
[10:58:43.700]             future::FutureResult(value = ...future.value$value, 
[10:58:43.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.700]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.700]                     ...future.globalenv.names))
[10:58:43.700]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.700]         }, condition = base::local({
[10:58:43.700]             c <- base::c
[10:58:43.700]             inherits <- base::inherits
[10:58:43.700]             invokeRestart <- base::invokeRestart
[10:58:43.700]             length <- base::length
[10:58:43.700]             list <- base::list
[10:58:43.700]             seq.int <- base::seq.int
[10:58:43.700]             signalCondition <- base::signalCondition
[10:58:43.700]             sys.calls <- base::sys.calls
[10:58:43.700]             `[[` <- base::`[[`
[10:58:43.700]             `+` <- base::`+`
[10:58:43.700]             `<<-` <- base::`<<-`
[10:58:43.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.700]                   3L)]
[10:58:43.700]             }
[10:58:43.700]             function(cond) {
[10:58:43.700]                 is_error <- inherits(cond, "error")
[10:58:43.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.700]                   NULL)
[10:58:43.700]                 if (is_error) {
[10:58:43.700]                   sessionInformation <- function() {
[10:58:43.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.700]                       search = base::search(), system = base::Sys.info())
[10:58:43.700]                   }
[10:58:43.700]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.700]                     cond$call), session = sessionInformation(), 
[10:58:43.700]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.700]                   signalCondition(cond)
[10:58:43.700]                 }
[10:58:43.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.700]                 "immediateCondition"))) {
[10:58:43.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.700]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.700]                   if (TRUE && !signal) {
[10:58:43.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.700]                     {
[10:58:43.700]                       inherits <- base::inherits
[10:58:43.700]                       invokeRestart <- base::invokeRestart
[10:58:43.700]                       is.null <- base::is.null
[10:58:43.700]                       muffled <- FALSE
[10:58:43.700]                       if (inherits(cond, "message")) {
[10:58:43.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.700]                         if (muffled) 
[10:58:43.700]                           invokeRestart("muffleMessage")
[10:58:43.700]                       }
[10:58:43.700]                       else if (inherits(cond, "warning")) {
[10:58:43.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.700]                         if (muffled) 
[10:58:43.700]                           invokeRestart("muffleWarning")
[10:58:43.700]                       }
[10:58:43.700]                       else if (inherits(cond, "condition")) {
[10:58:43.700]                         if (!is.null(pattern)) {
[10:58:43.700]                           computeRestarts <- base::computeRestarts
[10:58:43.700]                           grepl <- base::grepl
[10:58:43.700]                           restarts <- computeRestarts(cond)
[10:58:43.700]                           for (restart in restarts) {
[10:58:43.700]                             name <- restart$name
[10:58:43.700]                             if (is.null(name)) 
[10:58:43.700]                               next
[10:58:43.700]                             if (!grepl(pattern, name)) 
[10:58:43.700]                               next
[10:58:43.700]                             invokeRestart(restart)
[10:58:43.700]                             muffled <- TRUE
[10:58:43.700]                             break
[10:58:43.700]                           }
[10:58:43.700]                         }
[10:58:43.700]                       }
[10:58:43.700]                       invisible(muffled)
[10:58:43.700]                     }
[10:58:43.700]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.700]                   }
[10:58:43.700]                 }
[10:58:43.700]                 else {
[10:58:43.700]                   if (TRUE) {
[10:58:43.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.700]                     {
[10:58:43.700]                       inherits <- base::inherits
[10:58:43.700]                       invokeRestart <- base::invokeRestart
[10:58:43.700]                       is.null <- base::is.null
[10:58:43.700]                       muffled <- FALSE
[10:58:43.700]                       if (inherits(cond, "message")) {
[10:58:43.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.700]                         if (muffled) 
[10:58:43.700]                           invokeRestart("muffleMessage")
[10:58:43.700]                       }
[10:58:43.700]                       else if (inherits(cond, "warning")) {
[10:58:43.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.700]                         if (muffled) 
[10:58:43.700]                           invokeRestart("muffleWarning")
[10:58:43.700]                       }
[10:58:43.700]                       else if (inherits(cond, "condition")) {
[10:58:43.700]                         if (!is.null(pattern)) {
[10:58:43.700]                           computeRestarts <- base::computeRestarts
[10:58:43.700]                           grepl <- base::grepl
[10:58:43.700]                           restarts <- computeRestarts(cond)
[10:58:43.700]                           for (restart in restarts) {
[10:58:43.700]                             name <- restart$name
[10:58:43.700]                             if (is.null(name)) 
[10:58:43.700]                               next
[10:58:43.700]                             if (!grepl(pattern, name)) 
[10:58:43.700]                               next
[10:58:43.700]                             invokeRestart(restart)
[10:58:43.700]                             muffled <- TRUE
[10:58:43.700]                             break
[10:58:43.700]                           }
[10:58:43.700]                         }
[10:58:43.700]                       }
[10:58:43.700]                       invisible(muffled)
[10:58:43.700]                     }
[10:58:43.700]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.700]                   }
[10:58:43.700]                 }
[10:58:43.700]             }
[10:58:43.700]         }))
[10:58:43.700]     }, error = function(ex) {
[10:58:43.700]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.700]                 ...future.rng), started = ...future.startTime, 
[10:58:43.700]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.700]             version = "1.8"), class = "FutureResult")
[10:58:43.700]     }, finally = {
[10:58:43.700]         if (!identical(...future.workdir, getwd())) 
[10:58:43.700]             setwd(...future.workdir)
[10:58:43.700]         {
[10:58:43.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.700]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.700]             }
[10:58:43.700]             base::options(...future.oldOptions)
[10:58:43.700]             if (.Platform$OS.type == "windows") {
[10:58:43.700]                 old_names <- names(...future.oldEnvVars)
[10:58:43.700]                 envs <- base::Sys.getenv()
[10:58:43.700]                 names <- names(envs)
[10:58:43.700]                 common <- intersect(names, old_names)
[10:58:43.700]                 added <- setdiff(names, old_names)
[10:58:43.700]                 removed <- setdiff(old_names, names)
[10:58:43.700]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.700]                   envs[common]]
[10:58:43.700]                 NAMES <- toupper(changed)
[10:58:43.700]                 args <- list()
[10:58:43.700]                 for (kk in seq_along(NAMES)) {
[10:58:43.700]                   name <- changed[[kk]]
[10:58:43.700]                   NAME <- NAMES[[kk]]
[10:58:43.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.700]                     next
[10:58:43.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.700]                 }
[10:58:43.700]                 NAMES <- toupper(added)
[10:58:43.700]                 for (kk in seq_along(NAMES)) {
[10:58:43.700]                   name <- added[[kk]]
[10:58:43.700]                   NAME <- NAMES[[kk]]
[10:58:43.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.700]                     next
[10:58:43.700]                   args[[name]] <- ""
[10:58:43.700]                 }
[10:58:43.700]                 NAMES <- toupper(removed)
[10:58:43.700]                 for (kk in seq_along(NAMES)) {
[10:58:43.700]                   name <- removed[[kk]]
[10:58:43.700]                   NAME <- NAMES[[kk]]
[10:58:43.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.700]                     next
[10:58:43.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.700]                 }
[10:58:43.700]                 if (length(args) > 0) 
[10:58:43.700]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.700]             }
[10:58:43.700]             else {
[10:58:43.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.700]             }
[10:58:43.700]             {
[10:58:43.700]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.700]                   0L) {
[10:58:43.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.700]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.700]                   base::options(opts)
[10:58:43.700]                 }
[10:58:43.700]                 {
[10:58:43.700]                   {
[10:58:43.700]                     NULL
[10:58:43.700]                     RNGkind("Mersenne-Twister")
[10:58:43.700]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:43.700]                       inherits = FALSE)
[10:58:43.700]                   }
[10:58:43.700]                   options(future.plan = NULL)
[10:58:43.700]                   if (is.na(NA_character_)) 
[10:58:43.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.700]                     .init = FALSE)
[10:58:43.700]                 }
[10:58:43.700]             }
[10:58:43.700]         }
[10:58:43.700]     })
[10:58:43.700]     if (TRUE) {
[10:58:43.700]         base::sink(type = "output", split = FALSE)
[10:58:43.700]         if (TRUE) {
[10:58:43.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.700]         }
[10:58:43.700]         else {
[10:58:43.700]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.700]         }
[10:58:43.700]         base::close(...future.stdout)
[10:58:43.700]         ...future.stdout <- NULL
[10:58:43.700]     }
[10:58:43.700]     ...future.result$conditions <- ...future.conditions
[10:58:43.700]     ...future.result$finished <- base::Sys.time()
[10:58:43.700]     ...future.result
[10:58:43.700] }
[10:58:43.702] assign_globals() ...
[10:58:43.702] List of 5
[10:58:43.702]  $ ...future.FUN            :function (object, ...)  
[10:58:43.702]  $ future.call.arguments    : list()
[10:58:43.702]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.702]  $ ...future.elements_ii    :List of 3
[10:58:43.702]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.702]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.702]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.702]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.702]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.702]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.702]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.702]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:43.702]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.702]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.702]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.702]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:43.702]  $ ...future.seeds_ii       : NULL
[10:58:43.702]  $ ...future.globals.maxSize: NULL
[10:58:43.702]  - attr(*, "where")=List of 5
[10:58:43.702]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.702]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.702]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.702]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.702]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.702]  - attr(*, "resolved")= logi FALSE
[10:58:43.702]  - attr(*, "total_size")= num 18647
[10:58:43.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.702]  - attr(*, "already-done")= logi TRUE
[10:58:43.710] - copied ‘...future.FUN’ to environment
[10:58:43.710] - copied ‘future.call.arguments’ to environment
[10:58:43.710] - copied ‘...future.elements_ii’ to environment
[10:58:43.710] - copied ‘...future.seeds_ii’ to environment
[10:58:43.710] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.710] assign_globals() ... done
[10:58:43.711] plan(): Setting new future strategy stack:
[10:58:43.711] List of future strategies:
[10:58:43.711] 1. sequential:
[10:58:43.711]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.711]    - tweaked: FALSE
[10:58:43.711]    - call: NULL
[10:58:43.711] plan(): nbrOfWorkers() = 1
[10:58:43.713] plan(): Setting new future strategy stack:
[10:58:43.713] List of future strategies:
[10:58:43.713] 1. sequential:
[10:58:43.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.713]    - tweaked: FALSE
[10:58:43.713]    - call: plan(strategy)
[10:58:43.714] plan(): nbrOfWorkers() = 1
[10:58:43.714] SequentialFuture started (and completed)
[10:58:43.714] - Launch lazy future ... done
[10:58:43.714] run() for ‘SequentialFuture’ ... done
[10:58:43.714] Created future:
[10:58:43.714] SequentialFuture:
[10:58:43.714] Label: ‘future_by-1’
[10:58:43.714] Expression:
[10:58:43.714] {
[10:58:43.714]     do.call(function(...) {
[10:58:43.714]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.714]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.714]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.714]             on.exit(options(oopts), add = TRUE)
[10:58:43.714]         }
[10:58:43.714]         {
[10:58:43.714]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.714]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.714]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.714]             })
[10:58:43.714]         }
[10:58:43.714]     }, args = future.call.arguments)
[10:58:43.714] }
[10:58:43.714] Lazy evaluation: FALSE
[10:58:43.714] Asynchronous evaluation: FALSE
[10:58:43.714] Local evaluation: TRUE
[10:58:43.714] Environment: 0x55974cfa99b0
[10:58:43.714] Capture standard output: TRUE
[10:58:43.714] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.714] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.714] Packages: <none>
[10:58:43.714] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.714] Resolved: TRUE
[10:58:43.714] Value: 1.39 KiB of class ‘list’
[10:58:43.714] Early signaling: FALSE
[10:58:43.714] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.714] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:43.715] Chunk #1 of 1 ... DONE
[10:58:43.715] Launching 1 futures (chunks) ... DONE
[10:58:43.715] Resolving 1 futures (chunks) ...
[10:58:43.715] resolve() on list ...
[10:58:43.715]  recursive: 0
[10:58:43.715]  length: 1
[10:58:43.716] 
[10:58:43.716] resolved() for ‘SequentialFuture’ ...
[10:58:43.716] - state: ‘finished’
[10:58:43.717] - run: TRUE
[10:58:43.717] - result: ‘FutureResult’
[10:58:43.717] resolved() for ‘SequentialFuture’ ... done
[10:58:43.717] Future #1
[10:58:43.717] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:43.717] - nx: 1
[10:58:43.717] - relay: TRUE
[10:58:43.717] - stdout: TRUE
[10:58:43.718] - signal: TRUE
[10:58:43.718] - resignal: FALSE
[10:58:43.718] - force: TRUE
[10:58:43.718] - relayed: [n=1] FALSE
[10:58:43.718] - queued futures: [n=1] FALSE
[10:58:43.718]  - until=1
[10:58:43.718]  - relaying element #1
[10:58:43.718] - relayed: [n=1] TRUE
[10:58:43.718] - queued futures: [n=1] TRUE
[10:58:43.718] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:43.718]  length: 0 (resolved future 1)
[10:58:43.719] Relaying remaining futures
[10:58:43.719] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.719] - nx: 1
[10:58:43.719] - relay: TRUE
[10:58:43.719] - stdout: TRUE
[10:58:43.719] - signal: TRUE
[10:58:43.719] - resignal: FALSE
[10:58:43.719] - force: TRUE
[10:58:43.719] - relayed: [n=1] TRUE
[10:58:43.719] - queued futures: [n=1] TRUE
 - flush all
[10:58:43.719] - relayed: [n=1] TRUE
[10:58:43.719] - queued futures: [n=1] TRUE
[10:58:43.720] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.720] resolve() on list ... DONE
[10:58:43.720]  - Number of value chunks collected: 1
[10:58:43.720] Resolving 1 futures (chunks) ... DONE
[10:58:43.720] Reducing values from 1 chunks ...
[10:58:43.720]  - Number of values collected after concatenation: 3
[10:58:43.720]  - Number of values expected: 3
[10:58:43.720] Reducing values from 1 chunks ... DONE
[10:58:43.720] future_lapply() ... DONE
[10:58:43.720] future_by_internal() ... DONE
[10:58:43.721] future_by_internal() ...
- plan('multicore') ...
[10:58:43.722] plan(): Setting new future strategy stack:
[10:58:43.722] List of future strategies:
[10:58:43.722] 1. multicore:
[10:58:43.722]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.722]    - tweaked: FALSE
[10:58:43.722]    - call: plan(strategy)
[10:58:43.723] plan(): nbrOfWorkers() = 2
[10:58:43.723] future_by_internal() ...
[10:58:43.724] future_lapply() ...
[10:58:43.726] Number of chunks: 2
[10:58:43.726] getGlobalsAndPackagesXApply() ...
[10:58:43.726]  - future.globals: TRUE
[10:58:43.726] getGlobalsAndPackages() ...
[10:58:43.726] Searching for globals...
[10:58:43.727] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.727] Searching for globals ... DONE
[10:58:43.727] Resolving globals: FALSE
[10:58:43.728] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.728] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.728] - globals: [1] ‘FUN’
[10:58:43.728] 
[10:58:43.728] getGlobalsAndPackages() ... DONE
[10:58:43.728]  - globals found/used: [n=1] ‘FUN’
[10:58:43.729]  - needed namespaces: [n=0] 
[10:58:43.729] Finding globals ... DONE
[10:58:43.729]  - use_args: TRUE
[10:58:43.729]  - Getting '...' globals ...
[10:58:43.729] resolve() on list ...
[10:58:43.729]  recursive: 0
[10:58:43.729]  length: 1
[10:58:43.729]  elements: ‘...’
[10:58:43.729]  length: 0 (resolved future 1)
[10:58:43.729] resolve() on list ... DONE
[10:58:43.730]    - '...' content: [n=0] 
[10:58:43.730] List of 1
[10:58:43.730]  $ ...: list()
[10:58:43.730]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.730]  - attr(*, "where")=List of 1
[10:58:43.730]   ..$ ...:<environment: 0x55974c1a1678> 
[10:58:43.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.730]  - attr(*, "resolved")= logi TRUE
[10:58:43.730]  - attr(*, "total_size")= num NA
[10:58:43.732]  - Getting '...' globals ... DONE
[10:58:43.732] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.732] List of 2
[10:58:43.732]  $ ...future.FUN:function (object, ...)  
[10:58:43.732]  $ ...          : list()
[10:58:43.732]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.732]  - attr(*, "where")=List of 2
[10:58:43.732]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.732]   ..$ ...          :<environment: 0x55974c1a1678> 
[10:58:43.732]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.732]  - attr(*, "resolved")= logi FALSE
[10:58:43.732]  - attr(*, "total_size")= num 15670
[10:58:43.735] Packages to be attached in all futures: [n=0] 
[10:58:43.735] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.735] Number of futures (= number of chunks): 2
[10:58:43.736] Launching 2 futures (chunks) ...
[10:58:43.736] Chunk #1 of 2 ...
[10:58:43.736]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.736] getGlobalsAndPackages() ...
[10:58:43.736] Searching for globals...
[10:58:43.737] 
[10:58:43.737] Searching for globals ... DONE
[10:58:43.737] - globals: [0] <none>
[10:58:43.737] getGlobalsAndPackages() ... DONE
[10:58:43.737]    + additional globals found: [n=0] 
[10:58:43.737]    + additional namespaces needed: [n=0] 
[10:58:43.737]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.737]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:43.737]  - seeds: <none>
[10:58:43.737]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.738] getGlobalsAndPackages() ...
[10:58:43.738] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.738] Resolving globals: FALSE
[10:58:43.738] Tweak future expression to call with '...' arguments ...
[10:58:43.738] {
[10:58:43.738]     do.call(function(...) {
[10:58:43.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.738]             on.exit(options(oopts), add = TRUE)
[10:58:43.738]         }
[10:58:43.738]         {
[10:58:43.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.738]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.738]             })
[10:58:43.738]         }
[10:58:43.738]     }, args = future.call.arguments)
[10:58:43.738] }
[10:58:43.738] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.738] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.739] 
[10:58:43.739] getGlobalsAndPackages() ... DONE
[10:58:43.739] run() for ‘Future’ ...
[10:58:43.739] - state: ‘created’
[10:58:43.739] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.741] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.741] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:43.741]   - Field: ‘label’
[10:58:43.741]   - Field: ‘local’
[10:58:43.741]   - Field: ‘owner’
[10:58:43.741]   - Field: ‘envir’
[10:58:43.741]   - Field: ‘workers’
[10:58:43.741]   - Field: ‘packages’
[10:58:43.741]   - Field: ‘gc’
[10:58:43.742]   - Field: ‘job’
[10:58:43.742]   - Field: ‘conditions’
[10:58:43.742]   - Field: ‘expr’
[10:58:43.742]   - Field: ‘uuid’
[10:58:43.742]   - Field: ‘seed’
[10:58:43.742]   - Field: ‘version’
[10:58:43.742]   - Field: ‘result’
[10:58:43.742]   - Field: ‘asynchronous’
[10:58:43.742]   - Field: ‘calls’
[10:58:43.742]   - Field: ‘globals’
[10:58:43.742]   - Field: ‘stdout’
[10:58:43.742]   - Field: ‘earlySignal’
[10:58:43.742]   - Field: ‘lazy’
[10:58:43.743]   - Field: ‘state’
[10:58:43.743] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:43.743] - Launch lazy future ...
[10:58:43.744] Packages needed by the future expression (n = 0): <none>
[10:58:43.744] Packages needed by future strategies (n = 0): <none>
[10:58:43.744] {
[10:58:43.744]     {
[10:58:43.744]         {
[10:58:43.744]             ...future.startTime <- base::Sys.time()
[10:58:43.744]             {
[10:58:43.744]                 {
[10:58:43.744]                   {
[10:58:43.744]                     {
[10:58:43.744]                       base::local({
[10:58:43.744]                         has_future <- base::requireNamespace("future", 
[10:58:43.744]                           quietly = TRUE)
[10:58:43.744]                         if (has_future) {
[10:58:43.744]                           ns <- base::getNamespace("future")
[10:58:43.744]                           version <- ns[[".package"]][["version"]]
[10:58:43.744]                           if (is.null(version)) 
[10:58:43.744]                             version <- utils::packageVersion("future")
[10:58:43.744]                         }
[10:58:43.744]                         else {
[10:58:43.744]                           version <- NULL
[10:58:43.744]                         }
[10:58:43.744]                         if (!has_future || version < "1.8.0") {
[10:58:43.744]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.744]                             "", base::R.version$version.string), 
[10:58:43.744]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.744]                               "release", "version")], collapse = " "), 
[10:58:43.744]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.744]                             info)
[10:58:43.744]                           info <- base::paste(info, collapse = "; ")
[10:58:43.744]                           if (!has_future) {
[10:58:43.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.744]                               info)
[10:58:43.744]                           }
[10:58:43.744]                           else {
[10:58:43.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.744]                               info, version)
[10:58:43.744]                           }
[10:58:43.744]                           base::stop(msg)
[10:58:43.744]                         }
[10:58:43.744]                       })
[10:58:43.744]                     }
[10:58:43.744]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:43.744]                     base::options(mc.cores = 1L)
[10:58:43.744]                   }
[10:58:43.744]                   ...future.strategy.old <- future::plan("list")
[10:58:43.744]                   options(future.plan = NULL)
[10:58:43.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.744]                 }
[10:58:43.744]                 ...future.workdir <- getwd()
[10:58:43.744]             }
[10:58:43.744]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.744]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.744]         }
[10:58:43.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.744]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:43.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.744]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.744]             base::names(...future.oldOptions))
[10:58:43.744]     }
[10:58:43.744]     if (FALSE) {
[10:58:43.744]     }
[10:58:43.744]     else {
[10:58:43.744]         if (TRUE) {
[10:58:43.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.744]                 open = "w")
[10:58:43.744]         }
[10:58:43.744]         else {
[10:58:43.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.744]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.744]         }
[10:58:43.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.744]             base::sink(type = "output", split = FALSE)
[10:58:43.744]             base::close(...future.stdout)
[10:58:43.744]         }, add = TRUE)
[10:58:43.744]     }
[10:58:43.744]     ...future.frame <- base::sys.nframe()
[10:58:43.744]     ...future.conditions <- base::list()
[10:58:43.744]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.744]     if (FALSE) {
[10:58:43.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.744]     }
[10:58:43.744]     ...future.result <- base::tryCatch({
[10:58:43.744]         base::withCallingHandlers({
[10:58:43.744]             ...future.value <- base::withVisible(base::local({
[10:58:43.744]                 withCallingHandlers({
[10:58:43.744]                   {
[10:58:43.744]                     do.call(function(...) {
[10:58:43.744]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.744]                       if (!identical(...future.globals.maxSize.org, 
[10:58:43.744]                         ...future.globals.maxSize)) {
[10:58:43.744]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.744]                         on.exit(options(oopts), add = TRUE)
[10:58:43.744]                       }
[10:58:43.744]                       {
[10:58:43.744]                         lapply(seq_along(...future.elements_ii), 
[10:58:43.744]                           FUN = function(jj) {
[10:58:43.744]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.744]                             ...future.FUN(...future.X_jj, ...)
[10:58:43.744]                           })
[10:58:43.744]                       }
[10:58:43.744]                     }, args = future.call.arguments)
[10:58:43.744]                   }
[10:58:43.744]                 }, immediateCondition = function(cond) {
[10:58:43.744]                   save_rds <- function (object, pathname, ...) 
[10:58:43.744]                   {
[10:58:43.744]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:43.744]                     if (file_test("-f", pathname_tmp)) {
[10:58:43.744]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.744]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:43.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.744]                         fi_tmp[["mtime"]])
[10:58:43.744]                     }
[10:58:43.744]                     tryCatch({
[10:58:43.744]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:43.744]                     }, error = function(ex) {
[10:58:43.744]                       msg <- conditionMessage(ex)
[10:58:43.744]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.744]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:43.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.744]                         fi_tmp[["mtime"]], msg)
[10:58:43.744]                       ex$message <- msg
[10:58:43.744]                       stop(ex)
[10:58:43.744]                     })
[10:58:43.744]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:43.744]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:43.744]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:43.744]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.744]                       fi <- file.info(pathname)
[10:58:43.744]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:43.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.744]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:43.744]                         fi[["size"]], fi[["mtime"]])
[10:58:43.744]                       stop(msg)
[10:58:43.744]                     }
[10:58:43.744]                     invisible(pathname)
[10:58:43.744]                   }
[10:58:43.744]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:43.744]                     rootPath = tempdir()) 
[10:58:43.744]                   {
[10:58:43.744]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:43.744]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:43.744]                       tmpdir = path, fileext = ".rds")
[10:58:43.744]                     save_rds(obj, file)
[10:58:43.744]                   }
[10:58:43.744]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:43.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.744]                   {
[10:58:43.744]                     inherits <- base::inherits
[10:58:43.744]                     invokeRestart <- base::invokeRestart
[10:58:43.744]                     is.null <- base::is.null
[10:58:43.744]                     muffled <- FALSE
[10:58:43.744]                     if (inherits(cond, "message")) {
[10:58:43.744]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:43.744]                       if (muffled) 
[10:58:43.744]                         invokeRestart("muffleMessage")
[10:58:43.744]                     }
[10:58:43.744]                     else if (inherits(cond, "warning")) {
[10:58:43.744]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:43.744]                       if (muffled) 
[10:58:43.744]                         invokeRestart("muffleWarning")
[10:58:43.744]                     }
[10:58:43.744]                     else if (inherits(cond, "condition")) {
[10:58:43.744]                       if (!is.null(pattern)) {
[10:58:43.744]                         computeRestarts <- base::computeRestarts
[10:58:43.744]                         grepl <- base::grepl
[10:58:43.744]                         restarts <- computeRestarts(cond)
[10:58:43.744]                         for (restart in restarts) {
[10:58:43.744]                           name <- restart$name
[10:58:43.744]                           if (is.null(name)) 
[10:58:43.744]                             next
[10:58:43.744]                           if (!grepl(pattern, name)) 
[10:58:43.744]                             next
[10:58:43.744]                           invokeRestart(restart)
[10:58:43.744]                           muffled <- TRUE
[10:58:43.744]                           break
[10:58:43.744]                         }
[10:58:43.744]                       }
[10:58:43.744]                     }
[10:58:43.744]                     invisible(muffled)
[10:58:43.744]                   }
[10:58:43.744]                   muffleCondition(cond)
[10:58:43.744]                 })
[10:58:43.744]             }))
[10:58:43.744]             future::FutureResult(value = ...future.value$value, 
[10:58:43.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.744]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.744]                     ...future.globalenv.names))
[10:58:43.744]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.744]         }, condition = base::local({
[10:58:43.744]             c <- base::c
[10:58:43.744]             inherits <- base::inherits
[10:58:43.744]             invokeRestart <- base::invokeRestart
[10:58:43.744]             length <- base::length
[10:58:43.744]             list <- base::list
[10:58:43.744]             seq.int <- base::seq.int
[10:58:43.744]             signalCondition <- base::signalCondition
[10:58:43.744]             sys.calls <- base::sys.calls
[10:58:43.744]             `[[` <- base::`[[`
[10:58:43.744]             `+` <- base::`+`
[10:58:43.744]             `<<-` <- base::`<<-`
[10:58:43.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.744]                   3L)]
[10:58:43.744]             }
[10:58:43.744]             function(cond) {
[10:58:43.744]                 is_error <- inherits(cond, "error")
[10:58:43.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.744]                   NULL)
[10:58:43.744]                 if (is_error) {
[10:58:43.744]                   sessionInformation <- function() {
[10:58:43.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.744]                       search = base::search(), system = base::Sys.info())
[10:58:43.744]                   }
[10:58:43.744]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.744]                     cond$call), session = sessionInformation(), 
[10:58:43.744]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.744]                   signalCondition(cond)
[10:58:43.744]                 }
[10:58:43.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.744]                 "immediateCondition"))) {
[10:58:43.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.744]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.744]                   if (TRUE && !signal) {
[10:58:43.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.744]                     {
[10:58:43.744]                       inherits <- base::inherits
[10:58:43.744]                       invokeRestart <- base::invokeRestart
[10:58:43.744]                       is.null <- base::is.null
[10:58:43.744]                       muffled <- FALSE
[10:58:43.744]                       if (inherits(cond, "message")) {
[10:58:43.744]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.744]                         if (muffled) 
[10:58:43.744]                           invokeRestart("muffleMessage")
[10:58:43.744]                       }
[10:58:43.744]                       else if (inherits(cond, "warning")) {
[10:58:43.744]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.744]                         if (muffled) 
[10:58:43.744]                           invokeRestart("muffleWarning")
[10:58:43.744]                       }
[10:58:43.744]                       else if (inherits(cond, "condition")) {
[10:58:43.744]                         if (!is.null(pattern)) {
[10:58:43.744]                           computeRestarts <- base::computeRestarts
[10:58:43.744]                           grepl <- base::grepl
[10:58:43.744]                           restarts <- computeRestarts(cond)
[10:58:43.744]                           for (restart in restarts) {
[10:58:43.744]                             name <- restart$name
[10:58:43.744]                             if (is.null(name)) 
[10:58:43.744]                               next
[10:58:43.744]                             if (!grepl(pattern, name)) 
[10:58:43.744]                               next
[10:58:43.744]                             invokeRestart(restart)
[10:58:43.744]                             muffled <- TRUE
[10:58:43.744]                             break
[10:58:43.744]                           }
[10:58:43.744]                         }
[10:58:43.744]                       }
[10:58:43.744]                       invisible(muffled)
[10:58:43.744]                     }
[10:58:43.744]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.744]                   }
[10:58:43.744]                 }
[10:58:43.744]                 else {
[10:58:43.744]                   if (TRUE) {
[10:58:43.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.744]                     {
[10:58:43.744]                       inherits <- base::inherits
[10:58:43.744]                       invokeRestart <- base::invokeRestart
[10:58:43.744]                       is.null <- base::is.null
[10:58:43.744]                       muffled <- FALSE
[10:58:43.744]                       if (inherits(cond, "message")) {
[10:58:43.744]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.744]                         if (muffled) 
[10:58:43.744]                           invokeRestart("muffleMessage")
[10:58:43.744]                       }
[10:58:43.744]                       else if (inherits(cond, "warning")) {
[10:58:43.744]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.744]                         if (muffled) 
[10:58:43.744]                           invokeRestart("muffleWarning")
[10:58:43.744]                       }
[10:58:43.744]                       else if (inherits(cond, "condition")) {
[10:58:43.744]                         if (!is.null(pattern)) {
[10:58:43.744]                           computeRestarts <- base::computeRestarts
[10:58:43.744]                           grepl <- base::grepl
[10:58:43.744]                           restarts <- computeRestarts(cond)
[10:58:43.744]                           for (restart in restarts) {
[10:58:43.744]                             name <- restart$name
[10:58:43.744]                             if (is.null(name)) 
[10:58:43.744]                               next
[10:58:43.744]                             if (!grepl(pattern, name)) 
[10:58:43.744]                               next
[10:58:43.744]                             invokeRestart(restart)
[10:58:43.744]                             muffled <- TRUE
[10:58:43.744]                             break
[10:58:43.744]                           }
[10:58:43.744]                         }
[10:58:43.744]                       }
[10:58:43.744]                       invisible(muffled)
[10:58:43.744]                     }
[10:58:43.744]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.744]                   }
[10:58:43.744]                 }
[10:58:43.744]             }
[10:58:43.744]         }))
[10:58:43.744]     }, error = function(ex) {
[10:58:43.744]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.744]                 ...future.rng), started = ...future.startTime, 
[10:58:43.744]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.744]             version = "1.8"), class = "FutureResult")
[10:58:43.744]     }, finally = {
[10:58:43.744]         if (!identical(...future.workdir, getwd())) 
[10:58:43.744]             setwd(...future.workdir)
[10:58:43.744]         {
[10:58:43.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.744]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.744]             }
[10:58:43.744]             base::options(...future.oldOptions)
[10:58:43.744]             if (.Platform$OS.type == "windows") {
[10:58:43.744]                 old_names <- names(...future.oldEnvVars)
[10:58:43.744]                 envs <- base::Sys.getenv()
[10:58:43.744]                 names <- names(envs)
[10:58:43.744]                 common <- intersect(names, old_names)
[10:58:43.744]                 added <- setdiff(names, old_names)
[10:58:43.744]                 removed <- setdiff(old_names, names)
[10:58:43.744]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.744]                   envs[common]]
[10:58:43.744]                 NAMES <- toupper(changed)
[10:58:43.744]                 args <- list()
[10:58:43.744]                 for (kk in seq_along(NAMES)) {
[10:58:43.744]                   name <- changed[[kk]]
[10:58:43.744]                   NAME <- NAMES[[kk]]
[10:58:43.744]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.744]                     next
[10:58:43.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.744]                 }
[10:58:43.744]                 NAMES <- toupper(added)
[10:58:43.744]                 for (kk in seq_along(NAMES)) {
[10:58:43.744]                   name <- added[[kk]]
[10:58:43.744]                   NAME <- NAMES[[kk]]
[10:58:43.744]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.744]                     next
[10:58:43.744]                   args[[name]] <- ""
[10:58:43.744]                 }
[10:58:43.744]                 NAMES <- toupper(removed)
[10:58:43.744]                 for (kk in seq_along(NAMES)) {
[10:58:43.744]                   name <- removed[[kk]]
[10:58:43.744]                   NAME <- NAMES[[kk]]
[10:58:43.744]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.744]                     next
[10:58:43.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.744]                 }
[10:58:43.744]                 if (length(args) > 0) 
[10:58:43.744]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.744]             }
[10:58:43.744]             else {
[10:58:43.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.744]             }
[10:58:43.744]             {
[10:58:43.744]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.744]                   0L) {
[10:58:43.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.744]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.744]                   base::options(opts)
[10:58:43.744]                 }
[10:58:43.744]                 {
[10:58:43.744]                   {
[10:58:43.744]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:43.744]                     NULL
[10:58:43.744]                   }
[10:58:43.744]                   options(future.plan = NULL)
[10:58:43.744]                   if (is.na(NA_character_)) 
[10:58:43.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.744]                     .init = FALSE)
[10:58:43.744]                 }
[10:58:43.744]             }
[10:58:43.744]         }
[10:58:43.744]     })
[10:58:43.744]     if (TRUE) {
[10:58:43.744]         base::sink(type = "output", split = FALSE)
[10:58:43.744]         if (TRUE) {
[10:58:43.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.744]         }
[10:58:43.744]         else {
[10:58:43.744]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.744]         }
[10:58:43.744]         base::close(...future.stdout)
[10:58:43.744]         ...future.stdout <- NULL
[10:58:43.744]     }
[10:58:43.744]     ...future.result$conditions <- ...future.conditions
[10:58:43.744]     ...future.result$finished <- base::Sys.time()
[10:58:43.744]     ...future.result
[10:58:43.744] }
[10:58:43.746] assign_globals() ...
[10:58:43.747] List of 5
[10:58:43.747]  $ ...future.FUN            :function (object, ...)  
[10:58:43.747]  $ future.call.arguments    : list()
[10:58:43.747]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.747]  $ ...future.elements_ii    :List of 1
[10:58:43.747]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.747]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.747]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.747]  $ ...future.seeds_ii       : NULL
[10:58:43.747]  $ ...future.globals.maxSize: NULL
[10:58:43.747]  - attr(*, "where")=List of 5
[10:58:43.747]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.747]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.747]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.747]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.747]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.747]  - attr(*, "resolved")= logi FALSE
[10:58:43.747]  - attr(*, "total_size")= num 15670
[10:58:43.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.747]  - attr(*, "already-done")= logi TRUE
[10:58:43.751] - copied ‘...future.FUN’ to environment
[10:58:43.752] - copied ‘future.call.arguments’ to environment
[10:58:43.752] - copied ‘...future.elements_ii’ to environment
[10:58:43.752] - copied ‘...future.seeds_ii’ to environment
[10:58:43.752] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.752] assign_globals() ... done
[10:58:43.752] requestCore(): workers = 2
[10:58:43.755] MulticoreFuture started
[10:58:43.755] - Launch lazy future ... done
[10:58:43.756] plan(): Setting new future strategy stack:
[10:58:43.756] run() for ‘MulticoreFuture’ ... done
[10:58:43.756] Created future:
[10:58:43.756] List of future strategies:
[10:58:43.756] 1. sequential:
[10:58:43.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.756]    - tweaked: FALSE
[10:58:43.756]    - call: NULL
[10:58:43.757] plan(): nbrOfWorkers() = 1
[10:58:43.761] plan(): Setting new future strategy stack:
[10:58:43.761] List of future strategies:
[10:58:43.761] 1. multicore:
[10:58:43.761]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.761]    - tweaked: FALSE
[10:58:43.761]    - call: plan(strategy)
[10:58:43.765] plan(): nbrOfWorkers() = 2
[10:58:43.756] MulticoreFuture:
[10:58:43.756] Label: ‘future_by-1’
[10:58:43.756] Expression:
[10:58:43.756] {
[10:58:43.756]     do.call(function(...) {
[10:58:43.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.756]             on.exit(options(oopts), add = TRUE)
[10:58:43.756]         }
[10:58:43.756]         {
[10:58:43.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.756]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.756]             })
[10:58:43.756]         }
[10:58:43.756]     }, args = future.call.arguments)
[10:58:43.756] }
[10:58:43.756] Lazy evaluation: FALSE
[10:58:43.756] Asynchronous evaluation: TRUE
[10:58:43.756] Local evaluation: TRUE
[10:58:43.756] Environment: R_GlobalEnv
[10:58:43.756] Capture standard output: TRUE
[10:58:43.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.756] Globals: 5 objects totaling 996 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 564 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.756] Packages: <none>
[10:58:43.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.756] Resolved: TRUE
[10:58:43.756] Value: <not collected>
[10:58:43.756] Conditions captured: <none>
[10:58:43.756] Early signaling: FALSE
[10:58:43.756] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.756] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.766] Chunk #1 of 2 ... DONE
[10:58:43.766] Chunk #2 of 2 ...
[10:58:43.767]  - Finding globals in 'X' for chunk #2 ...
[10:58:43.767] getGlobalsAndPackages() ...
[10:58:43.767] Searching for globals...
[10:58:43.768] 
[10:58:43.768] Searching for globals ... DONE
[10:58:43.768] - globals: [0] <none>
[10:58:43.768] getGlobalsAndPackages() ... DONE
[10:58:43.768]    + additional globals found: [n=0] 
[10:58:43.768]    + additional namespaces needed: [n=0] 
[10:58:43.769]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:43.769]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:43.774]  - seeds: <none>
[10:58:43.774]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.775] getGlobalsAndPackages() ...
[10:58:43.776] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.776] Resolving globals: FALSE
[10:58:43.777] Tweak future expression to call with '...' arguments ...
[10:58:43.777] {
[10:58:43.777]     do.call(function(...) {
[10:58:43.777]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.777]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.777]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.777]             on.exit(options(oopts), add = TRUE)
[10:58:43.777]         }
[10:58:43.777]         {
[10:58:43.777]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.777]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.777]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.777]             })
[10:58:43.777]         }
[10:58:43.777]     }, args = future.call.arguments)
[10:58:43.777] }
[10:58:43.778] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.779] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.780] 
[10:58:43.780] getGlobalsAndPackages() ... DONE
[10:58:43.781] run() for ‘Future’ ...
[10:58:43.781] - state: ‘created’
[10:58:43.781] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:43.785]   - Field: ‘label’
[10:58:43.786]   - Field: ‘local’
[10:58:43.786]   - Field: ‘owner’
[10:58:43.786]   - Field: ‘envir’
[10:58:43.786]   - Field: ‘workers’
[10:58:43.786]   - Field: ‘packages’
[10:58:43.786]   - Field: ‘gc’
[10:58:43.786]   - Field: ‘job’
[10:58:43.787]   - Field: ‘conditions’
[10:58:43.787]   - Field: ‘expr’
[10:58:43.787]   - Field: ‘uuid’
[10:58:43.787]   - Field: ‘seed’
[10:58:43.787]   - Field: ‘version’
[10:58:43.787]   - Field: ‘result’
[10:58:43.787]   - Field: ‘asynchronous’
[10:58:43.788]   - Field: ‘calls’
[10:58:43.788]   - Field: ‘globals’
[10:58:43.788]   - Field: ‘stdout’
[10:58:43.788]   - Field: ‘earlySignal’
[10:58:43.788]   - Field: ‘lazy’
[10:58:43.788]   - Field: ‘state’
[10:58:43.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:43.788] - Launch lazy future ...
[10:58:43.789] Packages needed by the future expression (n = 0): <none>
[10:58:43.789] Packages needed by future strategies (n = 0): <none>
[10:58:43.790] {
[10:58:43.790]     {
[10:58:43.790]         {
[10:58:43.790]             ...future.startTime <- base::Sys.time()
[10:58:43.790]             {
[10:58:43.790]                 {
[10:58:43.790]                   {
[10:58:43.790]                     {
[10:58:43.790]                       base::local({
[10:58:43.790]                         has_future <- base::requireNamespace("future", 
[10:58:43.790]                           quietly = TRUE)
[10:58:43.790]                         if (has_future) {
[10:58:43.790]                           ns <- base::getNamespace("future")
[10:58:43.790]                           version <- ns[[".package"]][["version"]]
[10:58:43.790]                           if (is.null(version)) 
[10:58:43.790]                             version <- utils::packageVersion("future")
[10:58:43.790]                         }
[10:58:43.790]                         else {
[10:58:43.790]                           version <- NULL
[10:58:43.790]                         }
[10:58:43.790]                         if (!has_future || version < "1.8.0") {
[10:58:43.790]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.790]                             "", base::R.version$version.string), 
[10:58:43.790]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.790]                               "release", "version")], collapse = " "), 
[10:58:43.790]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.790]                             info)
[10:58:43.790]                           info <- base::paste(info, collapse = "; ")
[10:58:43.790]                           if (!has_future) {
[10:58:43.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.790]                               info)
[10:58:43.790]                           }
[10:58:43.790]                           else {
[10:58:43.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.790]                               info, version)
[10:58:43.790]                           }
[10:58:43.790]                           base::stop(msg)
[10:58:43.790]                         }
[10:58:43.790]                       })
[10:58:43.790]                     }
[10:58:43.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:43.790]                     base::options(mc.cores = 1L)
[10:58:43.790]                   }
[10:58:43.790]                   ...future.strategy.old <- future::plan("list")
[10:58:43.790]                   options(future.plan = NULL)
[10:58:43.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.790]                 }
[10:58:43.790]                 ...future.workdir <- getwd()
[10:58:43.790]             }
[10:58:43.790]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.790]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.790]         }
[10:58:43.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.790]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:43.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.790]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.790]             base::names(...future.oldOptions))
[10:58:43.790]     }
[10:58:43.790]     if (FALSE) {
[10:58:43.790]     }
[10:58:43.790]     else {
[10:58:43.790]         if (TRUE) {
[10:58:43.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.790]                 open = "w")
[10:58:43.790]         }
[10:58:43.790]         else {
[10:58:43.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.790]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.790]         }
[10:58:43.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.790]             base::sink(type = "output", split = FALSE)
[10:58:43.790]             base::close(...future.stdout)
[10:58:43.790]         }, add = TRUE)
[10:58:43.790]     }
[10:58:43.790]     ...future.frame <- base::sys.nframe()
[10:58:43.790]     ...future.conditions <- base::list()
[10:58:43.790]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.790]     if (FALSE) {
[10:58:43.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.790]     }
[10:58:43.790]     ...future.result <- base::tryCatch({
[10:58:43.790]         base::withCallingHandlers({
[10:58:43.790]             ...future.value <- base::withVisible(base::local({
[10:58:43.790]                 withCallingHandlers({
[10:58:43.790]                   {
[10:58:43.790]                     do.call(function(...) {
[10:58:43.790]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.790]                       if (!identical(...future.globals.maxSize.org, 
[10:58:43.790]                         ...future.globals.maxSize)) {
[10:58:43.790]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.790]                         on.exit(options(oopts), add = TRUE)
[10:58:43.790]                       }
[10:58:43.790]                       {
[10:58:43.790]                         lapply(seq_along(...future.elements_ii), 
[10:58:43.790]                           FUN = function(jj) {
[10:58:43.790]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.790]                             ...future.FUN(...future.X_jj, ...)
[10:58:43.790]                           })
[10:58:43.790]                       }
[10:58:43.790]                     }, args = future.call.arguments)
[10:58:43.790]                   }
[10:58:43.790]                 }, immediateCondition = function(cond) {
[10:58:43.790]                   save_rds <- function (object, pathname, ...) 
[10:58:43.790]                   {
[10:58:43.790]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:43.790]                     if (file_test("-f", pathname_tmp)) {
[10:58:43.790]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.790]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:43.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.790]                         fi_tmp[["mtime"]])
[10:58:43.790]                     }
[10:58:43.790]                     tryCatch({
[10:58:43.790]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:43.790]                     }, error = function(ex) {
[10:58:43.790]                       msg <- conditionMessage(ex)
[10:58:43.790]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.790]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:43.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.790]                         fi_tmp[["mtime"]], msg)
[10:58:43.790]                       ex$message <- msg
[10:58:43.790]                       stop(ex)
[10:58:43.790]                     })
[10:58:43.790]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:43.790]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:43.790]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:43.790]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.790]                       fi <- file.info(pathname)
[10:58:43.790]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:43.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.790]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:43.790]                         fi[["size"]], fi[["mtime"]])
[10:58:43.790]                       stop(msg)
[10:58:43.790]                     }
[10:58:43.790]                     invisible(pathname)
[10:58:43.790]                   }
[10:58:43.790]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:43.790]                     rootPath = tempdir()) 
[10:58:43.790]                   {
[10:58:43.790]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:43.790]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:43.790]                       tmpdir = path, fileext = ".rds")
[10:58:43.790]                     save_rds(obj, file)
[10:58:43.790]                   }
[10:58:43.790]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:43.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.790]                   {
[10:58:43.790]                     inherits <- base::inherits
[10:58:43.790]                     invokeRestart <- base::invokeRestart
[10:58:43.790]                     is.null <- base::is.null
[10:58:43.790]                     muffled <- FALSE
[10:58:43.790]                     if (inherits(cond, "message")) {
[10:58:43.790]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:43.790]                       if (muffled) 
[10:58:43.790]                         invokeRestart("muffleMessage")
[10:58:43.790]                     }
[10:58:43.790]                     else if (inherits(cond, "warning")) {
[10:58:43.790]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:43.790]                       if (muffled) 
[10:58:43.790]                         invokeRestart("muffleWarning")
[10:58:43.790]                     }
[10:58:43.790]                     else if (inherits(cond, "condition")) {
[10:58:43.790]                       if (!is.null(pattern)) {
[10:58:43.790]                         computeRestarts <- base::computeRestarts
[10:58:43.790]                         grepl <- base::grepl
[10:58:43.790]                         restarts <- computeRestarts(cond)
[10:58:43.790]                         for (restart in restarts) {
[10:58:43.790]                           name <- restart$name
[10:58:43.790]                           if (is.null(name)) 
[10:58:43.790]                             next
[10:58:43.790]                           if (!grepl(pattern, name)) 
[10:58:43.790]                             next
[10:58:43.790]                           invokeRestart(restart)
[10:58:43.790]                           muffled <- TRUE
[10:58:43.790]                           break
[10:58:43.790]                         }
[10:58:43.790]                       }
[10:58:43.790]                     }
[10:58:43.790]                     invisible(muffled)
[10:58:43.790]                   }
[10:58:43.790]                   muffleCondition(cond)
[10:58:43.790]                 })
[10:58:43.790]             }))
[10:58:43.790]             future::FutureResult(value = ...future.value$value, 
[10:58:43.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.790]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.790]                     ...future.globalenv.names))
[10:58:43.790]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.790]         }, condition = base::local({
[10:58:43.790]             c <- base::c
[10:58:43.790]             inherits <- base::inherits
[10:58:43.790]             invokeRestart <- base::invokeRestart
[10:58:43.790]             length <- base::length
[10:58:43.790]             list <- base::list
[10:58:43.790]             seq.int <- base::seq.int
[10:58:43.790]             signalCondition <- base::signalCondition
[10:58:43.790]             sys.calls <- base::sys.calls
[10:58:43.790]             `[[` <- base::`[[`
[10:58:43.790]             `+` <- base::`+`
[10:58:43.790]             `<<-` <- base::`<<-`
[10:58:43.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.790]                   3L)]
[10:58:43.790]             }
[10:58:43.790]             function(cond) {
[10:58:43.790]                 is_error <- inherits(cond, "error")
[10:58:43.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.790]                   NULL)
[10:58:43.790]                 if (is_error) {
[10:58:43.790]                   sessionInformation <- function() {
[10:58:43.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.790]                       search = base::search(), system = base::Sys.info())
[10:58:43.790]                   }
[10:58:43.790]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.790]                     cond$call), session = sessionInformation(), 
[10:58:43.790]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.790]                   signalCondition(cond)
[10:58:43.790]                 }
[10:58:43.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.790]                 "immediateCondition"))) {
[10:58:43.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.790]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.790]                   if (TRUE && !signal) {
[10:58:43.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.790]                     {
[10:58:43.790]                       inherits <- base::inherits
[10:58:43.790]                       invokeRestart <- base::invokeRestart
[10:58:43.790]                       is.null <- base::is.null
[10:58:43.790]                       muffled <- FALSE
[10:58:43.790]                       if (inherits(cond, "message")) {
[10:58:43.790]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.790]                         if (muffled) 
[10:58:43.790]                           invokeRestart("muffleMessage")
[10:58:43.790]                       }
[10:58:43.790]                       else if (inherits(cond, "warning")) {
[10:58:43.790]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.790]                         if (muffled) 
[10:58:43.790]                           invokeRestart("muffleWarning")
[10:58:43.790]                       }
[10:58:43.790]                       else if (inherits(cond, "condition")) {
[10:58:43.790]                         if (!is.null(pattern)) {
[10:58:43.790]                           computeRestarts <- base::computeRestarts
[10:58:43.790]                           grepl <- base::grepl
[10:58:43.790]                           restarts <- computeRestarts(cond)
[10:58:43.790]                           for (restart in restarts) {
[10:58:43.790]                             name <- restart$name
[10:58:43.790]                             if (is.null(name)) 
[10:58:43.790]                               next
[10:58:43.790]                             if (!grepl(pattern, name)) 
[10:58:43.790]                               next
[10:58:43.790]                             invokeRestart(restart)
[10:58:43.790]                             muffled <- TRUE
[10:58:43.790]                             break
[10:58:43.790]                           }
[10:58:43.790]                         }
[10:58:43.790]                       }
[10:58:43.790]                       invisible(muffled)
[10:58:43.790]                     }
[10:58:43.790]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.790]                   }
[10:58:43.790]                 }
[10:58:43.790]                 else {
[10:58:43.790]                   if (TRUE) {
[10:58:43.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.790]                     {
[10:58:43.790]                       inherits <- base::inherits
[10:58:43.790]                       invokeRestart <- base::invokeRestart
[10:58:43.790]                       is.null <- base::is.null
[10:58:43.790]                       muffled <- FALSE
[10:58:43.790]                       if (inherits(cond, "message")) {
[10:58:43.790]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.790]                         if (muffled) 
[10:58:43.790]                           invokeRestart("muffleMessage")
[10:58:43.790]                       }
[10:58:43.790]                       else if (inherits(cond, "warning")) {
[10:58:43.790]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.790]                         if (muffled) 
[10:58:43.790]                           invokeRestart("muffleWarning")
[10:58:43.790]                       }
[10:58:43.790]                       else if (inherits(cond, "condition")) {
[10:58:43.790]                         if (!is.null(pattern)) {
[10:58:43.790]                           computeRestarts <- base::computeRestarts
[10:58:43.790]                           grepl <- base::grepl
[10:58:43.790]                           restarts <- computeRestarts(cond)
[10:58:43.790]                           for (restart in restarts) {
[10:58:43.790]                             name <- restart$name
[10:58:43.790]                             if (is.null(name)) 
[10:58:43.790]                               next
[10:58:43.790]                             if (!grepl(pattern, name)) 
[10:58:43.790]                               next
[10:58:43.790]                             invokeRestart(restart)
[10:58:43.790]                             muffled <- TRUE
[10:58:43.790]                             break
[10:58:43.790]                           }
[10:58:43.790]                         }
[10:58:43.790]                       }
[10:58:43.790]                       invisible(muffled)
[10:58:43.790]                     }
[10:58:43.790]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.790]                   }
[10:58:43.790]                 }
[10:58:43.790]             }
[10:58:43.790]         }))
[10:58:43.790]     }, error = function(ex) {
[10:58:43.790]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.790]                 ...future.rng), started = ...future.startTime, 
[10:58:43.790]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.790]             version = "1.8"), class = "FutureResult")
[10:58:43.790]     }, finally = {
[10:58:43.790]         if (!identical(...future.workdir, getwd())) 
[10:58:43.790]             setwd(...future.workdir)
[10:58:43.790]         {
[10:58:43.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.790]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.790]             }
[10:58:43.790]             base::options(...future.oldOptions)
[10:58:43.790]             if (.Platform$OS.type == "windows") {
[10:58:43.790]                 old_names <- names(...future.oldEnvVars)
[10:58:43.790]                 envs <- base::Sys.getenv()
[10:58:43.790]                 names <- names(envs)
[10:58:43.790]                 common <- intersect(names, old_names)
[10:58:43.790]                 added <- setdiff(names, old_names)
[10:58:43.790]                 removed <- setdiff(old_names, names)
[10:58:43.790]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.790]                   envs[common]]
[10:58:43.790]                 NAMES <- toupper(changed)
[10:58:43.790]                 args <- list()
[10:58:43.790]                 for (kk in seq_along(NAMES)) {
[10:58:43.790]                   name <- changed[[kk]]
[10:58:43.790]                   NAME <- NAMES[[kk]]
[10:58:43.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.790]                     next
[10:58:43.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.790]                 }
[10:58:43.790]                 NAMES <- toupper(added)
[10:58:43.790]                 for (kk in seq_along(NAMES)) {
[10:58:43.790]                   name <- added[[kk]]
[10:58:43.790]                   NAME <- NAMES[[kk]]
[10:58:43.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.790]                     next
[10:58:43.790]                   args[[name]] <- ""
[10:58:43.790]                 }
[10:58:43.790]                 NAMES <- toupper(removed)
[10:58:43.790]                 for (kk in seq_along(NAMES)) {
[10:58:43.790]                   name <- removed[[kk]]
[10:58:43.790]                   NAME <- NAMES[[kk]]
[10:58:43.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.790]                     next
[10:58:43.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.790]                 }
[10:58:43.790]                 if (length(args) > 0) 
[10:58:43.790]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.790]             }
[10:58:43.790]             else {
[10:58:43.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.790]             }
[10:58:43.790]             {
[10:58:43.790]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.790]                   0L) {
[10:58:43.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.790]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.790]                   base::options(opts)
[10:58:43.790]                 }
[10:58:43.790]                 {
[10:58:43.790]                   {
[10:58:43.790]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:43.790]                     NULL
[10:58:43.790]                   }
[10:58:43.790]                   options(future.plan = NULL)
[10:58:43.790]                   if (is.na(NA_character_)) 
[10:58:43.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.790]                     .init = FALSE)
[10:58:43.790]                 }
[10:58:43.790]             }
[10:58:43.790]         }
[10:58:43.790]     })
[10:58:43.790]     if (TRUE) {
[10:58:43.790]         base::sink(type = "output", split = FALSE)
[10:58:43.790]         if (TRUE) {
[10:58:43.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.790]         }
[10:58:43.790]         else {
[10:58:43.790]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.790]         }
[10:58:43.790]         base::close(...future.stdout)
[10:58:43.790]         ...future.stdout <- NULL
[10:58:43.790]     }
[10:58:43.790]     ...future.result$conditions <- ...future.conditions
[10:58:43.790]     ...future.result$finished <- base::Sys.time()
[10:58:43.790]     ...future.result
[10:58:43.790] }
[10:58:43.793] assign_globals() ...
[10:58:43.793] List of 5
[10:58:43.793]  $ ...future.FUN            :function (object, ...)  
[10:58:43.793]  $ future.call.arguments    : list()
[10:58:43.793]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.793]  $ ...future.elements_ii    :List of 2
[10:58:43.793]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.793]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:43.793]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.793]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:58:43.793]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:43.793]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.793]  $ ...future.seeds_ii       : NULL
[10:58:43.793]  $ ...future.globals.maxSize: NULL
[10:58:43.793]  - attr(*, "where")=List of 5
[10:58:43.793]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.793]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.793]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.793]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.793]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.793]  - attr(*, "resolved")= logi FALSE
[10:58:43.793]  - attr(*, "total_size")= num 15670
[10:58:43.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.793]  - attr(*, "already-done")= logi TRUE
[10:58:43.801] - copied ‘...future.FUN’ to environment
[10:58:43.801] - copied ‘future.call.arguments’ to environment
[10:58:43.801] - copied ‘...future.elements_ii’ to environment
[10:58:43.801] - copied ‘...future.seeds_ii’ to environment
[10:58:43.801] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.801] assign_globals() ... done
[10:58:43.802] requestCore(): workers = 2
[10:58:43.806] MulticoreFuture started
[10:58:43.807] - Launch lazy future ... done
[10:58:43.807] run() for ‘MulticoreFuture’ ... done
[10:58:43.807] Created future:
[10:58:43.807] plan(): Setting new future strategy stack:
[10:58:43.808] List of future strategies:
[10:58:43.808] 1. sequential:
[10:58:43.808]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.808]    - tweaked: FALSE
[10:58:43.808]    - call: NULL
[10:58:43.808] plan(): nbrOfWorkers() = 1
[10:58:43.817] plan(): Setting new future strategy stack:
[10:58:43.817] List of future strategies:
[10:58:43.817] 1. multicore:
[10:58:43.817]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.817]    - tweaked: FALSE
[10:58:43.817]    - call: plan(strategy)
[10:58:43.821] plan(): nbrOfWorkers() = 2
[10:58:43.807] MulticoreFuture:
[10:58:43.807] Label: ‘future_by-2’
[10:58:43.807] Expression:
[10:58:43.807] {
[10:58:43.807]     do.call(function(...) {
[10:58:43.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.807]             on.exit(options(oopts), add = TRUE)
[10:58:43.807]         }
[10:58:43.807]         {
[10:58:43.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.807]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.807]             })
[10:58:43.807]         }
[10:58:43.807]     }, args = future.call.arguments)
[10:58:43.807] }
[10:58:43.807] Lazy evaluation: FALSE
[10:58:43.807] Asynchronous evaluation: TRUE
[10:58:43.807] Local evaluation: TRUE
[10:58:43.807] Environment: R_GlobalEnv
[10:58:43.807] Capture standard output: TRUE
[10:58:43.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.807] Globals: 5 objects totaling 1.44 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.02 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.807] Packages: <none>
[10:58:43.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.807] Resolved: TRUE
[10:58:43.807] Value: <not collected>
[10:58:43.807] Conditions captured: <none>
[10:58:43.807] Early signaling: FALSE
[10:58:43.807] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.807] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.822] Chunk #2 of 2 ... DONE
[10:58:43.823] Launching 2 futures (chunks) ... DONE
[10:58:43.823] Resolving 2 futures (chunks) ...
[10:58:43.823] resolve() on list ...
[10:58:43.823]  recursive: 0
[10:58:43.823]  length: 2
[10:58:43.824] 
[10:58:43.824] Future #1
[10:58:43.825] result() for MulticoreFuture ...
[10:58:43.827] result() for MulticoreFuture ...
[10:58:43.827] result() for MulticoreFuture ... done
[10:58:43.827] result() for MulticoreFuture ... done
[10:58:43.827] result() for MulticoreFuture ...
[10:58:43.827] result() for MulticoreFuture ... done
[10:58:43.828] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:43.828] - nx: 2
[10:58:43.828] - relay: TRUE
[10:58:43.828] - stdout: TRUE
[10:58:43.828] - signal: TRUE
[10:58:43.829] - resignal: FALSE
[10:58:43.829] - force: TRUE
[10:58:43.829] - relayed: [n=2] FALSE, FALSE
[10:58:43.829] - queued futures: [n=2] FALSE, FALSE
[10:58:43.829]  - until=1
[10:58:43.830]  - relaying element #1
[10:58:43.830] result() for MulticoreFuture ...
[10:58:43.830] result() for MulticoreFuture ... done
[10:58:43.830] result() for MulticoreFuture ...
[10:58:43.830] result() for MulticoreFuture ... done
[10:58:43.831] result() for MulticoreFuture ...
[10:58:43.831] result() for MulticoreFuture ... done
[10:58:43.831] result() for MulticoreFuture ...
[10:58:43.831] result() for MulticoreFuture ... done
[10:58:43.831] - relayed: [n=2] TRUE, FALSE
[10:58:43.831] - queued futures: [n=2] TRUE, FALSE
[10:58:43.831] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:43.832]  length: 1 (resolved future 1)
[10:58:43.832] Future #2
[10:58:43.832] result() for MulticoreFuture ...
[10:58:43.833] result() for MulticoreFuture ...
[10:58:43.833] result() for MulticoreFuture ... done
[10:58:43.833] result() for MulticoreFuture ... done
[10:58:43.833] result() for MulticoreFuture ...
[10:58:43.833] result() for MulticoreFuture ... done
[10:58:43.833] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:43.834] - nx: 2
[10:58:43.834] - relay: TRUE
[10:58:43.834] - stdout: TRUE
[10:58:43.834] - signal: TRUE
[10:58:43.834] - resignal: FALSE
[10:58:43.834] - force: TRUE
[10:58:43.834] - relayed: [n=2] TRUE, FALSE
[10:58:43.834] - queued futures: [n=2] TRUE, FALSE
[10:58:43.835]  - until=2
[10:58:43.835]  - relaying element #2
[10:58:43.835] result() for MulticoreFuture ...
[10:58:43.835] result() for MulticoreFuture ... done
[10:58:43.835] result() for MulticoreFuture ...
[10:58:43.835] result() for MulticoreFuture ... done
[10:58:43.835] result() for MulticoreFuture ...
[10:58:43.835] result() for MulticoreFuture ... done
[10:58:43.835] result() for MulticoreFuture ...
[10:58:43.836] result() for MulticoreFuture ... done
[10:58:43.836] - relayed: [n=2] TRUE, TRUE
[10:58:43.836] - queued futures: [n=2] TRUE, TRUE
[10:58:43.836] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:43.836]  length: 0 (resolved future 2)
[10:58:43.836] Relaying remaining futures
[10:58:43.836] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.836] - nx: 2
[10:58:43.836] - relay: TRUE
[10:58:43.836] - stdout: TRUE
[10:58:43.837] - signal: TRUE
[10:58:43.837] - resignal: FALSE
[10:58:43.837] - force: TRUE
[10:58:43.837] - relayed: [n=2] TRUE, TRUE
[10:58:43.837] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:43.837] - relayed: [n=2] TRUE, TRUE
[10:58:43.837] - queued futures: [n=2] TRUE, TRUE
[10:58:43.837] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.837] resolve() on list ... DONE
[10:58:43.837] result() for MulticoreFuture ...
[10:58:43.837] result() for MulticoreFuture ... done
[10:58:43.838] result() for MulticoreFuture ...
[10:58:43.838] result() for MulticoreFuture ... done
[10:58:43.838] result() for MulticoreFuture ...
[10:58:43.838] result() for MulticoreFuture ... done
[10:58:43.838] result() for MulticoreFuture ...
[10:58:43.838] result() for MulticoreFuture ... done
[10:58:43.838]  - Number of value chunks collected: 2
[10:58:43.838] Resolving 2 futures (chunks) ... DONE
[10:58:43.838] Reducing values from 2 chunks ...
[10:58:43.839]  - Number of values collected after concatenation: 3
[10:58:43.839]  - Number of values expected: 3
[10:58:43.839] Reducing values from 2 chunks ... DONE
[10:58:43.839] future_lapply() ... DONE
[10:58:43.839] future_by_internal() ... DONE
[10:58:43.839] future_by_internal() ...
[10:58:43.840] future_lapply() ...
[10:58:43.842] Number of chunks: 2
[10:58:43.842] getGlobalsAndPackagesXApply() ...
[10:58:43.842]  - future.globals: TRUE
[10:58:43.842] getGlobalsAndPackages() ...
[10:58:43.842] Searching for globals...
[10:58:43.844] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:43.844] Searching for globals ... DONE
[10:58:43.844] Resolving globals: FALSE
[10:58:43.844] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:43.845] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:43.845] - globals: [1] ‘FUN’
[10:58:43.845] 
[10:58:43.845] getGlobalsAndPackages() ... DONE
[10:58:43.845]  - globals found/used: [n=1] ‘FUN’
[10:58:43.845]  - needed namespaces: [n=0] 
[10:58:43.845] Finding globals ... DONE
[10:58:43.845]  - use_args: TRUE
[10:58:43.845]  - Getting '...' globals ...
[10:58:43.846] resolve() on list ...
[10:58:43.846]  recursive: 0
[10:58:43.846]  length: 1
[10:58:43.846]  elements: ‘...’
[10:58:43.846]  length: 0 (resolved future 1)
[10:58:43.846] resolve() on list ... DONE
[10:58:43.846]    - '...' content: [n=1] ‘digits’
[10:58:43.846] List of 1
[10:58:43.846]  $ ...:List of 1
[10:58:43.846]   ..$ digits: int 2
[10:58:43.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.846]  - attr(*, "where")=List of 1
[10:58:43.846]   ..$ ...:<environment: 0x55974d3591c8> 
[10:58:43.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.846]  - attr(*, "resolved")= logi TRUE
[10:58:43.846]  - attr(*, "total_size")= num NA
[10:58:43.851]  - Getting '...' globals ... DONE
[10:58:43.851] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.851] List of 2
[10:58:43.851]  $ ...future.FUN:function (object, ...)  
[10:58:43.851]  $ ...          :List of 1
[10:58:43.851]   ..$ digits: int 2
[10:58:43.851]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.851]  - attr(*, "where")=List of 2
[10:58:43.851]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.851]   ..$ ...          :<environment: 0x55974d3591c8> 
[10:58:43.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.851]  - attr(*, "resolved")= logi FALSE
[10:58:43.851]  - attr(*, "total_size")= num 13284
[10:58:43.854] Packages to be attached in all futures: [n=0] 
[10:58:43.854] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.855] Number of futures (= number of chunks): 2
[10:58:43.855] Launching 2 futures (chunks) ...
[10:58:43.855] Chunk #1 of 2 ...
[10:58:43.855]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.855] getGlobalsAndPackages() ...
[10:58:43.855] Searching for globals...
[10:58:43.855] 
[10:58:43.855] Searching for globals ... DONE
[10:58:43.855] - globals: [0] <none>
[10:58:43.856] getGlobalsAndPackages() ... DONE
[10:58:43.856]    + additional globals found: [n=0] 
[10:58:43.856]    + additional namespaces needed: [n=0] 
[10:58:43.856]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.856]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:43.856]  - seeds: <none>
[10:58:43.856]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.856] getGlobalsAndPackages() ...
[10:58:43.856] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.856] Resolving globals: FALSE
[10:58:43.856] Tweak future expression to call with '...' arguments ...
[10:58:43.857] {
[10:58:43.857]     do.call(function(...) {
[10:58:43.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.857]             on.exit(options(oopts), add = TRUE)
[10:58:43.857]         }
[10:58:43.857]         {
[10:58:43.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.857]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.857]             })
[10:58:43.857]         }
[10:58:43.857]     }, args = future.call.arguments)
[10:58:43.857] }
[10:58:43.857] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.857] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.857] 
[10:58:43.857] getGlobalsAndPackages() ... DONE
[10:58:43.858] run() for ‘Future’ ...
[10:58:43.858] - state: ‘created’
[10:58:43.858] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.859] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:43.860]   - Field: ‘label’
[10:58:43.860]   - Field: ‘local’
[10:58:43.860]   - Field: ‘owner’
[10:58:43.860]   - Field: ‘envir’
[10:58:43.860]   - Field: ‘workers’
[10:58:43.860]   - Field: ‘packages’
[10:58:43.860]   - Field: ‘gc’
[10:58:43.860]   - Field: ‘job’
[10:58:43.860]   - Field: ‘conditions’
[10:58:43.860]   - Field: ‘expr’
[10:58:43.860]   - Field: ‘uuid’
[10:58:43.860]   - Field: ‘seed’
[10:58:43.861]   - Field: ‘version’
[10:58:43.861]   - Field: ‘result’
[10:58:43.861]   - Field: ‘asynchronous’
[10:58:43.861]   - Field: ‘calls’
[10:58:43.861]   - Field: ‘globals’
[10:58:43.861]   - Field: ‘stdout’
[10:58:43.861]   - Field: ‘earlySignal’
[10:58:43.861]   - Field: ‘lazy’
[10:58:43.861]   - Field: ‘state’
[10:58:43.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:43.861] - Launch lazy future ...
[10:58:43.862] Packages needed by the future expression (n = 0): <none>
[10:58:43.862] Packages needed by future strategies (n = 0): <none>
[10:58:43.862] {
[10:58:43.862]     {
[10:58:43.862]         {
[10:58:43.862]             ...future.startTime <- base::Sys.time()
[10:58:43.862]             {
[10:58:43.862]                 {
[10:58:43.862]                   {
[10:58:43.862]                     {
[10:58:43.862]                       base::local({
[10:58:43.862]                         has_future <- base::requireNamespace("future", 
[10:58:43.862]                           quietly = TRUE)
[10:58:43.862]                         if (has_future) {
[10:58:43.862]                           ns <- base::getNamespace("future")
[10:58:43.862]                           version <- ns[[".package"]][["version"]]
[10:58:43.862]                           if (is.null(version)) 
[10:58:43.862]                             version <- utils::packageVersion("future")
[10:58:43.862]                         }
[10:58:43.862]                         else {
[10:58:43.862]                           version <- NULL
[10:58:43.862]                         }
[10:58:43.862]                         if (!has_future || version < "1.8.0") {
[10:58:43.862]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.862]                             "", base::R.version$version.string), 
[10:58:43.862]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.862]                               "release", "version")], collapse = " "), 
[10:58:43.862]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.862]                             info)
[10:58:43.862]                           info <- base::paste(info, collapse = "; ")
[10:58:43.862]                           if (!has_future) {
[10:58:43.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.862]                               info)
[10:58:43.862]                           }
[10:58:43.862]                           else {
[10:58:43.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.862]                               info, version)
[10:58:43.862]                           }
[10:58:43.862]                           base::stop(msg)
[10:58:43.862]                         }
[10:58:43.862]                       })
[10:58:43.862]                     }
[10:58:43.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:43.862]                     base::options(mc.cores = 1L)
[10:58:43.862]                   }
[10:58:43.862]                   ...future.strategy.old <- future::plan("list")
[10:58:43.862]                   options(future.plan = NULL)
[10:58:43.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.862]                 }
[10:58:43.862]                 ...future.workdir <- getwd()
[10:58:43.862]             }
[10:58:43.862]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.862]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.862]         }
[10:58:43.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.862]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:43.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.862]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.862]             base::names(...future.oldOptions))
[10:58:43.862]     }
[10:58:43.862]     if (FALSE) {
[10:58:43.862]     }
[10:58:43.862]     else {
[10:58:43.862]         if (TRUE) {
[10:58:43.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.862]                 open = "w")
[10:58:43.862]         }
[10:58:43.862]         else {
[10:58:43.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.862]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.862]         }
[10:58:43.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.862]             base::sink(type = "output", split = FALSE)
[10:58:43.862]             base::close(...future.stdout)
[10:58:43.862]         }, add = TRUE)
[10:58:43.862]     }
[10:58:43.862]     ...future.frame <- base::sys.nframe()
[10:58:43.862]     ...future.conditions <- base::list()
[10:58:43.862]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.862]     if (FALSE) {
[10:58:43.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.862]     }
[10:58:43.862]     ...future.result <- base::tryCatch({
[10:58:43.862]         base::withCallingHandlers({
[10:58:43.862]             ...future.value <- base::withVisible(base::local({
[10:58:43.862]                 withCallingHandlers({
[10:58:43.862]                   {
[10:58:43.862]                     do.call(function(...) {
[10:58:43.862]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.862]                       if (!identical(...future.globals.maxSize.org, 
[10:58:43.862]                         ...future.globals.maxSize)) {
[10:58:43.862]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.862]                         on.exit(options(oopts), add = TRUE)
[10:58:43.862]                       }
[10:58:43.862]                       {
[10:58:43.862]                         lapply(seq_along(...future.elements_ii), 
[10:58:43.862]                           FUN = function(jj) {
[10:58:43.862]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.862]                             ...future.FUN(...future.X_jj, ...)
[10:58:43.862]                           })
[10:58:43.862]                       }
[10:58:43.862]                     }, args = future.call.arguments)
[10:58:43.862]                   }
[10:58:43.862]                 }, immediateCondition = function(cond) {
[10:58:43.862]                   save_rds <- function (object, pathname, ...) 
[10:58:43.862]                   {
[10:58:43.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:43.862]                     if (file_test("-f", pathname_tmp)) {
[10:58:43.862]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:43.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.862]                         fi_tmp[["mtime"]])
[10:58:43.862]                     }
[10:58:43.862]                     tryCatch({
[10:58:43.862]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:43.862]                     }, error = function(ex) {
[10:58:43.862]                       msg <- conditionMessage(ex)
[10:58:43.862]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:43.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.862]                         fi_tmp[["mtime"]], msg)
[10:58:43.862]                       ex$message <- msg
[10:58:43.862]                       stop(ex)
[10:58:43.862]                     })
[10:58:43.862]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:43.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:43.862]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:43.862]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.862]                       fi <- file.info(pathname)
[10:58:43.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:43.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:43.862]                         fi[["size"]], fi[["mtime"]])
[10:58:43.862]                       stop(msg)
[10:58:43.862]                     }
[10:58:43.862]                     invisible(pathname)
[10:58:43.862]                   }
[10:58:43.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:43.862]                     rootPath = tempdir()) 
[10:58:43.862]                   {
[10:58:43.862]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:43.862]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:43.862]                       tmpdir = path, fileext = ".rds")
[10:58:43.862]                     save_rds(obj, file)
[10:58:43.862]                   }
[10:58:43.862]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:43.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.862]                   {
[10:58:43.862]                     inherits <- base::inherits
[10:58:43.862]                     invokeRestart <- base::invokeRestart
[10:58:43.862]                     is.null <- base::is.null
[10:58:43.862]                     muffled <- FALSE
[10:58:43.862]                     if (inherits(cond, "message")) {
[10:58:43.862]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:43.862]                       if (muffled) 
[10:58:43.862]                         invokeRestart("muffleMessage")
[10:58:43.862]                     }
[10:58:43.862]                     else if (inherits(cond, "warning")) {
[10:58:43.862]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:43.862]                       if (muffled) 
[10:58:43.862]                         invokeRestart("muffleWarning")
[10:58:43.862]                     }
[10:58:43.862]                     else if (inherits(cond, "condition")) {
[10:58:43.862]                       if (!is.null(pattern)) {
[10:58:43.862]                         computeRestarts <- base::computeRestarts
[10:58:43.862]                         grepl <- base::grepl
[10:58:43.862]                         restarts <- computeRestarts(cond)
[10:58:43.862]                         for (restart in restarts) {
[10:58:43.862]                           name <- restart$name
[10:58:43.862]                           if (is.null(name)) 
[10:58:43.862]                             next
[10:58:43.862]                           if (!grepl(pattern, name)) 
[10:58:43.862]                             next
[10:58:43.862]                           invokeRestart(restart)
[10:58:43.862]                           muffled <- TRUE
[10:58:43.862]                           break
[10:58:43.862]                         }
[10:58:43.862]                       }
[10:58:43.862]                     }
[10:58:43.862]                     invisible(muffled)
[10:58:43.862]                   }
[10:58:43.862]                   muffleCondition(cond)
[10:58:43.862]                 })
[10:58:43.862]             }))
[10:58:43.862]             future::FutureResult(value = ...future.value$value, 
[10:58:43.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.862]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.862]                     ...future.globalenv.names))
[10:58:43.862]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.862]         }, condition = base::local({
[10:58:43.862]             c <- base::c
[10:58:43.862]             inherits <- base::inherits
[10:58:43.862]             invokeRestart <- base::invokeRestart
[10:58:43.862]             length <- base::length
[10:58:43.862]             list <- base::list
[10:58:43.862]             seq.int <- base::seq.int
[10:58:43.862]             signalCondition <- base::signalCondition
[10:58:43.862]             sys.calls <- base::sys.calls
[10:58:43.862]             `[[` <- base::`[[`
[10:58:43.862]             `+` <- base::`+`
[10:58:43.862]             `<<-` <- base::`<<-`
[10:58:43.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.862]                   3L)]
[10:58:43.862]             }
[10:58:43.862]             function(cond) {
[10:58:43.862]                 is_error <- inherits(cond, "error")
[10:58:43.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.862]                   NULL)
[10:58:43.862]                 if (is_error) {
[10:58:43.862]                   sessionInformation <- function() {
[10:58:43.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.862]                       search = base::search(), system = base::Sys.info())
[10:58:43.862]                   }
[10:58:43.862]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.862]                     cond$call), session = sessionInformation(), 
[10:58:43.862]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.862]                   signalCondition(cond)
[10:58:43.862]                 }
[10:58:43.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.862]                 "immediateCondition"))) {
[10:58:43.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.862]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.862]                   if (TRUE && !signal) {
[10:58:43.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.862]                     {
[10:58:43.862]                       inherits <- base::inherits
[10:58:43.862]                       invokeRestart <- base::invokeRestart
[10:58:43.862]                       is.null <- base::is.null
[10:58:43.862]                       muffled <- FALSE
[10:58:43.862]                       if (inherits(cond, "message")) {
[10:58:43.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.862]                         if (muffled) 
[10:58:43.862]                           invokeRestart("muffleMessage")
[10:58:43.862]                       }
[10:58:43.862]                       else if (inherits(cond, "warning")) {
[10:58:43.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.862]                         if (muffled) 
[10:58:43.862]                           invokeRestart("muffleWarning")
[10:58:43.862]                       }
[10:58:43.862]                       else if (inherits(cond, "condition")) {
[10:58:43.862]                         if (!is.null(pattern)) {
[10:58:43.862]                           computeRestarts <- base::computeRestarts
[10:58:43.862]                           grepl <- base::grepl
[10:58:43.862]                           restarts <- computeRestarts(cond)
[10:58:43.862]                           for (restart in restarts) {
[10:58:43.862]                             name <- restart$name
[10:58:43.862]                             if (is.null(name)) 
[10:58:43.862]                               next
[10:58:43.862]                             if (!grepl(pattern, name)) 
[10:58:43.862]                               next
[10:58:43.862]                             invokeRestart(restart)
[10:58:43.862]                             muffled <- TRUE
[10:58:43.862]                             break
[10:58:43.862]                           }
[10:58:43.862]                         }
[10:58:43.862]                       }
[10:58:43.862]                       invisible(muffled)
[10:58:43.862]                     }
[10:58:43.862]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.862]                   }
[10:58:43.862]                 }
[10:58:43.862]                 else {
[10:58:43.862]                   if (TRUE) {
[10:58:43.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.862]                     {
[10:58:43.862]                       inherits <- base::inherits
[10:58:43.862]                       invokeRestart <- base::invokeRestart
[10:58:43.862]                       is.null <- base::is.null
[10:58:43.862]                       muffled <- FALSE
[10:58:43.862]                       if (inherits(cond, "message")) {
[10:58:43.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.862]                         if (muffled) 
[10:58:43.862]                           invokeRestart("muffleMessage")
[10:58:43.862]                       }
[10:58:43.862]                       else if (inherits(cond, "warning")) {
[10:58:43.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.862]                         if (muffled) 
[10:58:43.862]                           invokeRestart("muffleWarning")
[10:58:43.862]                       }
[10:58:43.862]                       else if (inherits(cond, "condition")) {
[10:58:43.862]                         if (!is.null(pattern)) {
[10:58:43.862]                           computeRestarts <- base::computeRestarts
[10:58:43.862]                           grepl <- base::grepl
[10:58:43.862]                           restarts <- computeRestarts(cond)
[10:58:43.862]                           for (restart in restarts) {
[10:58:43.862]                             name <- restart$name
[10:58:43.862]                             if (is.null(name)) 
[10:58:43.862]                               next
[10:58:43.862]                             if (!grepl(pattern, name)) 
[10:58:43.862]                               next
[10:58:43.862]                             invokeRestart(restart)
[10:58:43.862]                             muffled <- TRUE
[10:58:43.862]                             break
[10:58:43.862]                           }
[10:58:43.862]                         }
[10:58:43.862]                       }
[10:58:43.862]                       invisible(muffled)
[10:58:43.862]                     }
[10:58:43.862]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.862]                   }
[10:58:43.862]                 }
[10:58:43.862]             }
[10:58:43.862]         }))
[10:58:43.862]     }, error = function(ex) {
[10:58:43.862]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.862]                 ...future.rng), started = ...future.startTime, 
[10:58:43.862]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.862]             version = "1.8"), class = "FutureResult")
[10:58:43.862]     }, finally = {
[10:58:43.862]         if (!identical(...future.workdir, getwd())) 
[10:58:43.862]             setwd(...future.workdir)
[10:58:43.862]         {
[10:58:43.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.862]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.862]             }
[10:58:43.862]             base::options(...future.oldOptions)
[10:58:43.862]             if (.Platform$OS.type == "windows") {
[10:58:43.862]                 old_names <- names(...future.oldEnvVars)
[10:58:43.862]                 envs <- base::Sys.getenv()
[10:58:43.862]                 names <- names(envs)
[10:58:43.862]                 common <- intersect(names, old_names)
[10:58:43.862]                 added <- setdiff(names, old_names)
[10:58:43.862]                 removed <- setdiff(old_names, names)
[10:58:43.862]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.862]                   envs[common]]
[10:58:43.862]                 NAMES <- toupper(changed)
[10:58:43.862]                 args <- list()
[10:58:43.862]                 for (kk in seq_along(NAMES)) {
[10:58:43.862]                   name <- changed[[kk]]
[10:58:43.862]                   NAME <- NAMES[[kk]]
[10:58:43.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.862]                     next
[10:58:43.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.862]                 }
[10:58:43.862]                 NAMES <- toupper(added)
[10:58:43.862]                 for (kk in seq_along(NAMES)) {
[10:58:43.862]                   name <- added[[kk]]
[10:58:43.862]                   NAME <- NAMES[[kk]]
[10:58:43.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.862]                     next
[10:58:43.862]                   args[[name]] <- ""
[10:58:43.862]                 }
[10:58:43.862]                 NAMES <- toupper(removed)
[10:58:43.862]                 for (kk in seq_along(NAMES)) {
[10:58:43.862]                   name <- removed[[kk]]
[10:58:43.862]                   NAME <- NAMES[[kk]]
[10:58:43.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.862]                     next
[10:58:43.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.862]                 }
[10:58:43.862]                 if (length(args) > 0) 
[10:58:43.862]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.862]             }
[10:58:43.862]             else {
[10:58:43.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.862]             }
[10:58:43.862]             {
[10:58:43.862]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.862]                   0L) {
[10:58:43.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.862]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.862]                   base::options(opts)
[10:58:43.862]                 }
[10:58:43.862]                 {
[10:58:43.862]                   {
[10:58:43.862]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:43.862]                     NULL
[10:58:43.862]                   }
[10:58:43.862]                   options(future.plan = NULL)
[10:58:43.862]                   if (is.na(NA_character_)) 
[10:58:43.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.862]                     .init = FALSE)
[10:58:43.862]                 }
[10:58:43.862]             }
[10:58:43.862]         }
[10:58:43.862]     })
[10:58:43.862]     if (TRUE) {
[10:58:43.862]         base::sink(type = "output", split = FALSE)
[10:58:43.862]         if (TRUE) {
[10:58:43.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.862]         }
[10:58:43.862]         else {
[10:58:43.862]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.862]         }
[10:58:43.862]         base::close(...future.stdout)
[10:58:43.862]         ...future.stdout <- NULL
[10:58:43.862]     }
[10:58:43.862]     ...future.result$conditions <- ...future.conditions
[10:58:43.862]     ...future.result$finished <- base::Sys.time()
[10:58:43.862]     ...future.result
[10:58:43.862] }
[10:58:43.865] assign_globals() ...
[10:58:43.865] List of 5
[10:58:43.865]  $ ...future.FUN            :function (object, ...)  
[10:58:43.865]  $ future.call.arguments    :List of 1
[10:58:43.865]   ..$ digits: int 2
[10:58:43.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.865]  $ ...future.elements_ii    :List of 3
[10:58:43.865]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:58:43.865]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:58:43.865]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:58:43.865]  $ ...future.seeds_ii       : NULL
[10:58:43.865]  $ ...future.globals.maxSize: NULL
[10:58:43.865]  - attr(*, "where")=List of 5
[10:58:43.865]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.865]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.865]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.865]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.865]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.865]  - attr(*, "resolved")= logi FALSE
[10:58:43.865]  - attr(*, "total_size")= num 13284
[10:58:43.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.865]  - attr(*, "already-done")= logi TRUE
[10:58:43.871] - copied ‘...future.FUN’ to environment
[10:58:43.871] - copied ‘future.call.arguments’ to environment
[10:58:43.872] - copied ‘...future.elements_ii’ to environment
[10:58:43.872] - copied ‘...future.seeds_ii’ to environment
[10:58:43.872] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.872] assign_globals() ... done
[10:58:43.872] requestCore(): workers = 2
[10:58:43.874] MulticoreFuture started
[10:58:43.875] - Launch lazy future ... done
[10:58:43.875] run() for ‘MulticoreFuture’ ... done
[10:58:43.875] plan(): Setting new future strategy stack:
[10:58:43.875] Created future:
[10:58:43.875] List of future strategies:
[10:58:43.875] 1. sequential:
[10:58:43.875]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.875]    - tweaked: FALSE
[10:58:43.875]    - call: NULL
[10:58:43.877] plan(): nbrOfWorkers() = 1
[10:58:43.879] plan(): Setting new future strategy stack:
[10:58:43.880] List of future strategies:
[10:58:43.880] 1. multicore:
[10:58:43.880]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.880]    - tweaked: FALSE
[10:58:43.880]    - call: plan(strategy)
[10:58:43.883] plan(): nbrOfWorkers() = 2
[10:58:43.876] MulticoreFuture:
[10:58:43.876] Label: ‘future_by-1’
[10:58:43.876] Expression:
[10:58:43.876] {
[10:58:43.876]     do.call(function(...) {
[10:58:43.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.876]             on.exit(options(oopts), add = TRUE)
[10:58:43.876]         }
[10:58:43.876]         {
[10:58:43.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.876]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.876]             })
[10:58:43.876]         }
[10:58:43.876]     }, args = future.call.arguments)
[10:58:43.876] }
[10:58:43.876] Lazy evaluation: FALSE
[10:58:43.876] Asynchronous evaluation: TRUE
[10:58:43.876] Local evaluation: TRUE
[10:58:43.876] Environment: R_GlobalEnv
[10:58:43.876] Capture standard output: TRUE
[10:58:43.876] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.876] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.876] Packages: <none>
[10:58:43.876] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.876] Resolved: TRUE
[10:58:43.876] Value: <not collected>
[10:58:43.876] Conditions captured: <none>
[10:58:43.876] Early signaling: FALSE
[10:58:43.876] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.876] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.884] Chunk #1 of 2 ... DONE
[10:58:43.884] Chunk #2 of 2 ...
[10:58:43.885]  - Finding globals in 'X' for chunk #2 ...
[10:58:43.885] getGlobalsAndPackages() ...
[10:58:43.885] Searching for globals...
[10:58:43.885] 
[10:58:43.885] Searching for globals ... DONE
[10:58:43.886] - globals: [0] <none>
[10:58:43.886] getGlobalsAndPackages() ... DONE
[10:58:43.886]    + additional globals found: [n=0] 
[10:58:43.886]    + additional namespaces needed: [n=0] 
[10:58:43.886]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:43.886]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:43.886]  - seeds: <none>
[10:58:43.887]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.887] getGlobalsAndPackages() ...
[10:58:43.887] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.887] Resolving globals: FALSE
[10:58:43.887] Tweak future expression to call with '...' arguments ...
[10:58:43.887] {
[10:58:43.887]     do.call(function(...) {
[10:58:43.887]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.887]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.887]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.887]             on.exit(options(oopts), add = TRUE)
[10:58:43.887]         }
[10:58:43.887]         {
[10:58:43.887]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.887]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.887]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.887]             })
[10:58:43.887]         }
[10:58:43.887]     }, args = future.call.arguments)
[10:58:43.887] }
[10:58:43.888] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.889] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.889] 
[10:58:43.889] getGlobalsAndPackages() ... DONE
[10:58:43.889] run() for ‘Future’ ...
[10:58:43.890] - state: ‘created’
[10:58:43.890] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.892] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:43.893]   - Field: ‘label’
[10:58:43.893]   - Field: ‘local’
[10:58:43.893]   - Field: ‘owner’
[10:58:43.893]   - Field: ‘envir’
[10:58:43.893]   - Field: ‘workers’
[10:58:43.893]   - Field: ‘packages’
[10:58:43.894]   - Field: ‘gc’
[10:58:43.894]   - Field: ‘job’
[10:58:43.894]   - Field: ‘conditions’
[10:58:43.894]   - Field: ‘expr’
[10:58:43.894]   - Field: ‘uuid’
[10:58:43.894]   - Field: ‘seed’
[10:58:43.894]   - Field: ‘version’
[10:58:43.895]   - Field: ‘result’
[10:58:43.895]   - Field: ‘asynchronous’
[10:58:43.895]   - Field: ‘calls’
[10:58:43.895]   - Field: ‘globals’
[10:58:43.895]   - Field: ‘stdout’
[10:58:43.895]   - Field: ‘earlySignal’
[10:58:43.895]   - Field: ‘lazy’
[10:58:43.896]   - Field: ‘state’
[10:58:43.896] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:43.896] - Launch lazy future ...
[10:58:43.896] Packages needed by the future expression (n = 0): <none>
[10:58:43.896] Packages needed by future strategies (n = 0): <none>
[10:58:43.897] {
[10:58:43.897]     {
[10:58:43.897]         {
[10:58:43.897]             ...future.startTime <- base::Sys.time()
[10:58:43.897]             {
[10:58:43.897]                 {
[10:58:43.897]                   {
[10:58:43.897]                     {
[10:58:43.897]                       base::local({
[10:58:43.897]                         has_future <- base::requireNamespace("future", 
[10:58:43.897]                           quietly = TRUE)
[10:58:43.897]                         if (has_future) {
[10:58:43.897]                           ns <- base::getNamespace("future")
[10:58:43.897]                           version <- ns[[".package"]][["version"]]
[10:58:43.897]                           if (is.null(version)) 
[10:58:43.897]                             version <- utils::packageVersion("future")
[10:58:43.897]                         }
[10:58:43.897]                         else {
[10:58:43.897]                           version <- NULL
[10:58:43.897]                         }
[10:58:43.897]                         if (!has_future || version < "1.8.0") {
[10:58:43.897]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.897]                             "", base::R.version$version.string), 
[10:58:43.897]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:43.897]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:43.897]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.897]                               "release", "version")], collapse = " "), 
[10:58:43.897]                             hostname = base::Sys.info()[["nodename"]])
[10:58:43.897]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.897]                             info)
[10:58:43.897]                           info <- base::paste(info, collapse = "; ")
[10:58:43.897]                           if (!has_future) {
[10:58:43.897]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.897]                               info)
[10:58:43.897]                           }
[10:58:43.897]                           else {
[10:58:43.897]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.897]                               info, version)
[10:58:43.897]                           }
[10:58:43.897]                           base::stop(msg)
[10:58:43.897]                         }
[10:58:43.897]                       })
[10:58:43.897]                     }
[10:58:43.897]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:43.897]                     base::options(mc.cores = 1L)
[10:58:43.897]                   }
[10:58:43.897]                   ...future.strategy.old <- future::plan("list")
[10:58:43.897]                   options(future.plan = NULL)
[10:58:43.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.897]                 }
[10:58:43.897]                 ...future.workdir <- getwd()
[10:58:43.897]             }
[10:58:43.897]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.897]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.897]         }
[10:58:43.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.897]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:43.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.897]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.897]             base::names(...future.oldOptions))
[10:58:43.897]     }
[10:58:43.897]     if (FALSE) {
[10:58:43.897]     }
[10:58:43.897]     else {
[10:58:43.897]         if (TRUE) {
[10:58:43.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.897]                 open = "w")
[10:58:43.897]         }
[10:58:43.897]         else {
[10:58:43.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.897]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.897]         }
[10:58:43.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.897]             base::sink(type = "output", split = FALSE)
[10:58:43.897]             base::close(...future.stdout)
[10:58:43.897]         }, add = TRUE)
[10:58:43.897]     }
[10:58:43.897]     ...future.frame <- base::sys.nframe()
[10:58:43.897]     ...future.conditions <- base::list()
[10:58:43.897]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.897]     if (FALSE) {
[10:58:43.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.897]     }
[10:58:43.897]     ...future.result <- base::tryCatch({
[10:58:43.897]         base::withCallingHandlers({
[10:58:43.897]             ...future.value <- base::withVisible(base::local({
[10:58:43.897]                 withCallingHandlers({
[10:58:43.897]                   {
[10:58:43.897]                     do.call(function(...) {
[10:58:43.897]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.897]                       if (!identical(...future.globals.maxSize.org, 
[10:58:43.897]                         ...future.globals.maxSize)) {
[10:58:43.897]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.897]                         on.exit(options(oopts), add = TRUE)
[10:58:43.897]                       }
[10:58:43.897]                       {
[10:58:43.897]                         lapply(seq_along(...future.elements_ii), 
[10:58:43.897]                           FUN = function(jj) {
[10:58:43.897]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.897]                             ...future.FUN(...future.X_jj, ...)
[10:58:43.897]                           })
[10:58:43.897]                       }
[10:58:43.897]                     }, args = future.call.arguments)
[10:58:43.897]                   }
[10:58:43.897]                 }, immediateCondition = function(cond) {
[10:58:43.897]                   save_rds <- function (object, pathname, ...) 
[10:58:43.897]                   {
[10:58:43.897]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:43.897]                     if (file_test("-f", pathname_tmp)) {
[10:58:43.897]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.897]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:43.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.897]                         fi_tmp[["mtime"]])
[10:58:43.897]                     }
[10:58:43.897]                     tryCatch({
[10:58:43.897]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:43.897]                     }, error = function(ex) {
[10:58:43.897]                       msg <- conditionMessage(ex)
[10:58:43.897]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.897]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:43.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.897]                         fi_tmp[["mtime"]], msg)
[10:58:43.897]                       ex$message <- msg
[10:58:43.897]                       stop(ex)
[10:58:43.897]                     })
[10:58:43.897]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:43.897]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:43.897]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:43.897]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.897]                       fi <- file.info(pathname)
[10:58:43.897]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:43.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.897]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:43.897]                         fi[["size"]], fi[["mtime"]])
[10:58:43.897]                       stop(msg)
[10:58:43.897]                     }
[10:58:43.897]                     invisible(pathname)
[10:58:43.897]                   }
[10:58:43.897]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:43.897]                     rootPath = tempdir()) 
[10:58:43.897]                   {
[10:58:43.897]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:43.897]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:43.897]                       tmpdir = path, fileext = ".rds")
[10:58:43.897]                     save_rds(obj, file)
[10:58:43.897]                   }
[10:58:43.897]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:43.897]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.897]                   {
[10:58:43.897]                     inherits <- base::inherits
[10:58:43.897]                     invokeRestart <- base::invokeRestart
[10:58:43.897]                     is.null <- base::is.null
[10:58:43.897]                     muffled <- FALSE
[10:58:43.897]                     if (inherits(cond, "message")) {
[10:58:43.897]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:43.897]                       if (muffled) 
[10:58:43.897]                         invokeRestart("muffleMessage")
[10:58:43.897]                     }
[10:58:43.897]                     else if (inherits(cond, "warning")) {
[10:58:43.897]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:43.897]                       if (muffled) 
[10:58:43.897]                         invokeRestart("muffleWarning")
[10:58:43.897]                     }
[10:58:43.897]                     else if (inherits(cond, "condition")) {
[10:58:43.897]                       if (!is.null(pattern)) {
[10:58:43.897]                         computeRestarts <- base::computeRestarts
[10:58:43.897]                         grepl <- base::grepl
[10:58:43.897]                         restarts <- computeRestarts(cond)
[10:58:43.897]                         for (restart in restarts) {
[10:58:43.897]                           name <- restart$name
[10:58:43.897]                           if (is.null(name)) 
[10:58:43.897]                             next
[10:58:43.897]                           if (!grepl(pattern, name)) 
[10:58:43.897]                             next
[10:58:43.897]                           invokeRestart(restart)
[10:58:43.897]                           muffled <- TRUE
[10:58:43.897]                           break
[10:58:43.897]                         }
[10:58:43.897]                       }
[10:58:43.897]                     }
[10:58:43.897]                     invisible(muffled)
[10:58:43.897]                   }
[10:58:43.897]                   muffleCondition(cond)
[10:58:43.897]                 })
[10:58:43.897]             }))
[10:58:43.897]             future::FutureResult(value = ...future.value$value, 
[10:58:43.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.897]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.897]                     ...future.globalenv.names))
[10:58:43.897]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.897]         }, condition = base::local({
[10:58:43.897]             c <- base::c
[10:58:43.897]             inherits <- base::inherits
[10:58:43.897]             invokeRestart <- base::invokeRestart
[10:58:43.897]             length <- base::length
[10:58:43.897]             list <- base::list
[10:58:43.897]             seq.int <- base::seq.int
[10:58:43.897]             signalCondition <- base::signalCondition
[10:58:43.897]             sys.calls <- base::sys.calls
[10:58:43.897]             `[[` <- base::`[[`
[10:58:43.897]             `+` <- base::`+`
[10:58:43.897]             `<<-` <- base::`<<-`
[10:58:43.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.897]                   3L)]
[10:58:43.897]             }
[10:58:43.897]             function(cond) {
[10:58:43.897]                 is_error <- inherits(cond, "error")
[10:58:43.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.897]                   NULL)
[10:58:43.897]                 if (is_error) {
[10:58:43.897]                   sessionInformation <- function() {
[10:58:43.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.897]                       search = base::search(), system = base::Sys.info())
[10:58:43.897]                   }
[10:58:43.897]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.897]                     cond$call), session = sessionInformation(), 
[10:58:43.897]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.897]                   signalCondition(cond)
[10:58:43.897]                 }
[10:58:43.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.897]                 "immediateCondition"))) {
[10:58:43.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.897]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.897]                   if (TRUE && !signal) {
[10:58:43.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.897]                     {
[10:58:43.897]                       inherits <- base::inherits
[10:58:43.897]                       invokeRestart <- base::invokeRestart
[10:58:43.897]                       is.null <- base::is.null
[10:58:43.897]                       muffled <- FALSE
[10:58:43.897]                       if (inherits(cond, "message")) {
[10:58:43.897]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.897]                         if (muffled) 
[10:58:43.897]                           invokeRestart("muffleMessage")
[10:58:43.897]                       }
[10:58:43.897]                       else if (inherits(cond, "warning")) {
[10:58:43.897]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.897]                         if (muffled) 
[10:58:43.897]                           invokeRestart("muffleWarning")
[10:58:43.897]                       }
[10:58:43.897]                       else if (inherits(cond, "condition")) {
[10:58:43.897]                         if (!is.null(pattern)) {
[10:58:43.897]                           computeRestarts <- base::computeRestarts
[10:58:43.897]                           grepl <- base::grepl
[10:58:43.897]                           restarts <- computeRestarts(cond)
[10:58:43.897]                           for (restart in restarts) {
[10:58:43.897]                             name <- restart$name
[10:58:43.897]                             if (is.null(name)) 
[10:58:43.897]                               next
[10:58:43.897]                             if (!grepl(pattern, name)) 
[10:58:43.897]                               next
[10:58:43.897]                             invokeRestart(restart)
[10:58:43.897]                             muffled <- TRUE
[10:58:43.897]                             break
[10:58:43.897]                           }
[10:58:43.897]                         }
[10:58:43.897]                       }
[10:58:43.897]                       invisible(muffled)
[10:58:43.897]                     }
[10:58:43.897]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.897]                   }
[10:58:43.897]                 }
[10:58:43.897]                 else {
[10:58:43.897]                   if (TRUE) {
[10:58:43.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.897]                     {
[10:58:43.897]                       inherits <- base::inherits
[10:58:43.897]                       invokeRestart <- base::invokeRestart
[10:58:43.897]                       is.null <- base::is.null
[10:58:43.897]                       muffled <- FALSE
[10:58:43.897]                       if (inherits(cond, "message")) {
[10:58:43.897]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.897]                         if (muffled) 
[10:58:43.897]                           invokeRestart("muffleMessage")
[10:58:43.897]                       }
[10:58:43.897]                       else if (inherits(cond, "warning")) {
[10:58:43.897]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.897]                         if (muffled) 
[10:58:43.897]                           invokeRestart("muffleWarning")
[10:58:43.897]                       }
[10:58:43.897]                       else if (inherits(cond, "condition")) {
[10:58:43.897]                         if (!is.null(pattern)) {
[10:58:43.897]                           computeRestarts <- base::computeRestarts
[10:58:43.897]                           grepl <- base::grepl
[10:58:43.897]                           restarts <- computeRestarts(cond)
[10:58:43.897]                           for (restart in restarts) {
[10:58:43.897]                             name <- restart$name
[10:58:43.897]                             if (is.null(name)) 
[10:58:43.897]                               next
[10:58:43.897]                             if (!grepl(pattern, name)) 
[10:58:43.897]                               next
[10:58:43.897]                             invokeRestart(restart)
[10:58:43.897]                             muffled <- TRUE
[10:58:43.897]                             break
[10:58:43.897]                           }
[10:58:43.897]                         }
[10:58:43.897]                       }
[10:58:43.897]                       invisible(muffled)
[10:58:43.897]                     }
[10:58:43.897]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.897]                   }
[10:58:43.897]                 }
[10:58:43.897]             }
[10:58:43.897]         }))
[10:58:43.897]     }, error = function(ex) {
[10:58:43.897]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.897]                 ...future.rng), started = ...future.startTime, 
[10:58:43.897]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.897]             version = "1.8"), class = "FutureResult")
[10:58:43.897]     }, finally = {
[10:58:43.897]         if (!identical(...future.workdir, getwd())) 
[10:58:43.897]             setwd(...future.workdir)
[10:58:43.897]         {
[10:58:43.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.897]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.897]             }
[10:58:43.897]             base::options(...future.oldOptions)
[10:58:43.897]             if (.Platform$OS.type == "windows") {
[10:58:43.897]                 old_names <- names(...future.oldEnvVars)
[10:58:43.897]                 envs <- base::Sys.getenv()
[10:58:43.897]                 names <- names(envs)
[10:58:43.897]                 common <- intersect(names, old_names)
[10:58:43.897]                 added <- setdiff(names, old_names)
[10:58:43.897]                 removed <- setdiff(old_names, names)
[10:58:43.897]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.897]                   envs[common]]
[10:58:43.897]                 NAMES <- toupper(changed)
[10:58:43.897]                 args <- list()
[10:58:43.897]                 for (kk in seq_along(NAMES)) {
[10:58:43.897]                   name <- changed[[kk]]
[10:58:43.897]                   NAME <- NAMES[[kk]]
[10:58:43.897]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.897]                     next
[10:58:43.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.897]                 }
[10:58:43.897]                 NAMES <- toupper(added)
[10:58:43.897]                 for (kk in seq_along(NAMES)) {
[10:58:43.897]                   name <- added[[kk]]
[10:58:43.897]                   NAME <- NAMES[[kk]]
[10:58:43.897]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.897]                     next
[10:58:43.897]                   args[[name]] <- ""
[10:58:43.897]                 }
[10:58:43.897]                 NAMES <- toupper(removed)
[10:58:43.897]                 for (kk in seq_along(NAMES)) {
[10:58:43.897]                   name <- removed[[kk]]
[10:58:43.897]                   NAME <- NAMES[[kk]]
[10:58:43.897]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.897]                     next
[10:58:43.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.897]                 }
[10:58:43.897]                 if (length(args) > 0) 
[10:58:43.897]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.897]             }
[10:58:43.897]             else {
[10:58:43.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.897]             }
[10:58:43.897]             {
[10:58:43.897]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.897]                   0L) {
[10:58:43.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.897]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.897]                   base::options(opts)
[10:58:43.897]                 }
[10:58:43.897]                 {
[10:58:43.897]                   {
[10:58:43.897]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:43.897]                     NULL
[10:58:43.897]                   }
[10:58:43.897]                   options(future.plan = NULL)
[10:58:43.897]                   if (is.na(NA_character_)) 
[10:58:43.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.897]                     .init = FALSE)
[10:58:43.897]                 }
[10:58:43.897]             }
[10:58:43.897]         }
[10:58:43.897]     })
[10:58:43.897]     if (TRUE) {
[10:58:43.897]         base::sink(type = "output", split = FALSE)
[10:58:43.897]         if (TRUE) {
[10:58:43.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.897]         }
[10:58:43.897]         else {
[10:58:43.897]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.897]         }
[10:58:43.897]         base::close(...future.stdout)
[10:58:43.897]         ...future.stdout <- NULL
[10:58:43.897]     }
[10:58:43.897]     ...future.result$conditions <- ...future.conditions
[10:58:43.897]     ...future.result$finished <- base::Sys.time()
[10:58:43.897]     ...future.result
[10:58:43.897] }
[10:58:43.901] assign_globals() ...
[10:58:43.901] List of 5
[10:58:43.901]  $ ...future.FUN            :function (object, ...)  
[10:58:43.901]  $ future.call.arguments    :List of 1
[10:58:43.901]   ..$ digits: int 2
[10:58:43.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.901]  $ ...future.elements_ii    :List of 3
[10:58:43.901]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:58:43.901]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:58:43.901]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:58:43.901]  $ ...future.seeds_ii       : NULL
[10:58:43.901]  $ ...future.globals.maxSize: NULL
[10:58:43.901]  - attr(*, "where")=List of 5
[10:58:43.901]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.901]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.901]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.901]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.901]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.901]  - attr(*, "resolved")= logi FALSE
[10:58:43.901]  - attr(*, "total_size")= num 13284
[10:58:43.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.901]  - attr(*, "already-done")= logi TRUE
[10:58:43.914] - copied ‘...future.FUN’ to environment
[10:58:43.914] - copied ‘future.call.arguments’ to environment
[10:58:43.914] - copied ‘...future.elements_ii’ to environment
[10:58:43.914] - copied ‘...future.seeds_ii’ to environment
[10:58:43.915] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.915] assign_globals() ... done
[10:58:43.915] requestCore(): workers = 2
[10:58:43.917] MulticoreFuture started
[10:58:43.918] - Launch lazy future ... done
[10:58:43.918] plan(): Setting new future strategy stack:
[10:58:43.918] run() for ‘MulticoreFuture’ ... done
[10:58:43.919] Created future:
[10:58:43.919] List of future strategies:
[10:58:43.919] 1. sequential:
[10:58:43.919]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.919]    - tweaked: FALSE
[10:58:43.919]    - call: NULL
[10:58:43.920] plan(): nbrOfWorkers() = 1
[10:58:43.925] plan(): Setting new future strategy stack:
[10:58:43.925] List of future strategies:
[10:58:43.925] 1. multicore:
[10:58:43.925]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.925]    - tweaked: FALSE
[10:58:43.925]    - call: plan(strategy)
[10:58:43.929] plan(): nbrOfWorkers() = 2
[10:58:43.919] MulticoreFuture:
[10:58:43.919] Label: ‘future_by-2’
[10:58:43.919] Expression:
[10:58:43.919] {
[10:58:43.919]     do.call(function(...) {
[10:58:43.919]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.919]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.919]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.919]             on.exit(options(oopts), add = TRUE)
[10:58:43.919]         }
[10:58:43.919]         {
[10:58:43.919]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.919]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.919]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.919]             })
[10:58:43.919]         }
[10:58:43.919]     }, args = future.call.arguments)
[10:58:43.919] }
[10:58:43.919] Lazy evaluation: FALSE
[10:58:43.919] Asynchronous evaluation: TRUE
[10:58:43.919] Local evaluation: TRUE
[10:58:43.919] Environment: R_GlobalEnv
[10:58:43.919] Capture standard output: TRUE
[10:58:43.919] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.919] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.919] Packages: <none>
[10:58:43.919] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.919] Resolved: TRUE
[10:58:43.919] Value: <not collected>
[10:58:43.919] Conditions captured: <none>
[10:58:43.919] Early signaling: FALSE
[10:58:43.919] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.919] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.930] Chunk #2 of 2 ... DONE
[10:58:43.931] Launching 2 futures (chunks) ... DONE
[10:58:43.931] Resolving 2 futures (chunks) ...
[10:58:43.931] resolve() on list ...
[10:58:43.931]  recursive: 0
[10:58:43.931]  length: 2
[10:58:43.932] 
[10:58:43.932] Future #1
[10:58:43.932] result() for MulticoreFuture ...
[10:58:43.933] result() for MulticoreFuture ...
[10:58:43.933] result() for MulticoreFuture ... done
[10:58:43.934] result() for MulticoreFuture ... done
[10:58:43.934] result() for MulticoreFuture ...
[10:58:43.934] result() for MulticoreFuture ... done
[10:58:43.934] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:43.934] - nx: 2
[10:58:43.934] - relay: TRUE
[10:58:43.934] - stdout: TRUE
[10:58:43.935] - signal: TRUE
[10:58:43.935] - resignal: FALSE
[10:58:43.935] - force: TRUE
[10:58:43.935] - relayed: [n=2] FALSE, FALSE
[10:58:43.935] - queued futures: [n=2] FALSE, FALSE
[10:58:43.935]  - until=1
[10:58:43.935]  - relaying element #1
[10:58:43.936] result() for MulticoreFuture ...
[10:58:43.936] result() for MulticoreFuture ... done
[10:58:43.936] result() for MulticoreFuture ...
[10:58:43.936] result() for MulticoreFuture ... done
[10:58:43.936] result() for MulticoreFuture ...
[10:58:43.937] result() for MulticoreFuture ... done
[10:58:43.937] result() for MulticoreFuture ...
[10:58:43.937] result() for MulticoreFuture ... done
[10:58:43.937] - relayed: [n=2] TRUE, FALSE
[10:58:43.937] - queued futures: [n=2] TRUE, FALSE
[10:58:43.937] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:43.938]  length: 1 (resolved future 1)
[10:58:43.938] Future #2
[10:58:43.938] result() for MulticoreFuture ...
[10:58:43.939] result() for MulticoreFuture ...
[10:58:43.939] result() for MulticoreFuture ... done
[10:58:43.939] result() for MulticoreFuture ... done
[10:58:43.939] result() for MulticoreFuture ...
[10:58:43.940] result() for MulticoreFuture ... done
[10:58:43.940] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:43.940] - nx: 2
[10:58:43.940] - relay: TRUE
[10:58:43.940] - stdout: TRUE
[10:58:43.940] - signal: TRUE
[10:58:43.940] - resignal: FALSE
[10:58:43.940] - force: TRUE
[10:58:43.940] - relayed: [n=2] TRUE, FALSE
[10:58:43.940] - queued futures: [n=2] TRUE, FALSE
[10:58:43.941]  - until=2
[10:58:43.941]  - relaying element #2
[10:58:43.941] result() for MulticoreFuture ...
[10:58:43.941] result() for MulticoreFuture ... done
[10:58:43.941] result() for MulticoreFuture ...
[10:58:43.941] result() for MulticoreFuture ... done
[10:58:43.941] result() for MulticoreFuture ...
[10:58:43.941] result() for MulticoreFuture ... done
[10:58:43.941] result() for MulticoreFuture ...
[10:58:43.942] result() for MulticoreFuture ... done
[10:58:43.942] - relayed: [n=2] TRUE, TRUE
[10:58:43.942] - queued futures: [n=2] TRUE, TRUE
[10:58:43.942] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:43.942]  length: 0 (resolved future 2)
[10:58:43.942] Relaying remaining futures
[10:58:43.942] signalConditionsASAP(NULL, pos=0) ...
[10:58:43.942] - nx: 2
[10:58:43.942] - relay: TRUE
[10:58:43.943] - stdout: TRUE
[10:58:43.943] - signal: TRUE
[10:58:43.943] - resignal: FALSE
[10:58:43.943] - force: TRUE
[10:58:43.943] - relayed: [n=2] TRUE, TRUE
[10:58:43.943] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:43.943] - relayed: [n=2] TRUE, TRUE
[10:58:43.943] - queued futures: [n=2] TRUE, TRUE
[10:58:43.943] signalConditionsASAP(NULL, pos=0) ... done
[10:58:43.943] resolve() on list ... DONE
[10:58:43.944] result() for MulticoreFuture ...
[10:58:43.944] result() for MulticoreFuture ... done
[10:58:43.944] result() for MulticoreFuture ...
[10:58:43.944] result() for MulticoreFuture ... done
[10:58:43.944] result() for MulticoreFuture ...
[10:58:43.944] result() for MulticoreFuture ... done
[10:58:43.944] result() for MulticoreFuture ...
[10:58:43.944] result() for MulticoreFuture ... done
[10:58:43.944]  - Number of value chunks collected: 2
[10:58:43.945] Resolving 2 futures (chunks) ... DONE
[10:58:43.945] Reducing values from 2 chunks ...
[10:58:43.945]  - Number of values collected after concatenation: 6
[10:58:43.945]  - Number of values expected: 6
[10:58:43.945] Reducing values from 2 chunks ... DONE
[10:58:43.945] future_lapply() ... DONE
[10:58:43.945] future_by_internal() ... DONE
[10:58:43.946] future_by_internal() ...
[10:58:43.947] future_lapply() ...
[10:58:43.950] Number of chunks: 2
[10:58:43.950] getGlobalsAndPackagesXApply() ...
[10:58:43.950]  - future.globals: TRUE
[10:58:43.950] getGlobalsAndPackages() ...
[10:58:43.950] Searching for globals...
[10:58:43.954] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:43.954] Searching for globals ... DONE
[10:58:43.954] Resolving globals: FALSE
[10:58:43.955] The total size of the 1 globals is 762 bytes (762 bytes)
[10:58:43.955] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:58:43.955] - globals: [1] ‘FUN’
[10:58:43.955] - packages: [1] ‘stats’
[10:58:43.955] getGlobalsAndPackages() ... DONE
[10:58:43.956]  - globals found/used: [n=1] ‘FUN’
[10:58:43.956]  - needed namespaces: [n=1] ‘stats’
[10:58:43.956] Finding globals ... DONE
[10:58:43.956]  - use_args: TRUE
[10:58:43.956]  - Getting '...' globals ...
[10:58:43.956] resolve() on list ...
[10:58:43.956]  recursive: 0
[10:58:43.957]  length: 1
[10:58:43.957]  elements: ‘...’
[10:58:43.957]  length: 0 (resolved future 1)
[10:58:43.957] resolve() on list ... DONE
[10:58:43.957]    - '...' content: [n=1] ‘singular.ok’
[10:58:43.957] List of 1
[10:58:43.957]  $ ...:List of 1
[10:58:43.957]   ..$ singular.ok: logi FALSE
[10:58:43.957]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.957]  - attr(*, "where")=List of 1
[10:58:43.957]   ..$ ...:<environment: 0x55974dbfa5f8> 
[10:58:43.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.957]  - attr(*, "resolved")= logi TRUE
[10:58:43.957]  - attr(*, "total_size")= num NA
[10:58:43.960]  - Getting '...' globals ... DONE
[10:58:43.960] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:43.960] List of 2
[10:58:43.960]  $ ...future.FUN:function (x, ...)  
[10:58:43.960]  $ ...          :List of 1
[10:58:43.960]   ..$ singular.ok: logi FALSE
[10:58:43.960]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.960]  - attr(*, "where")=List of 2
[10:58:43.960]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:43.960]   ..$ ...          :<environment: 0x55974dbfa5f8> 
[10:58:43.960]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.960]  - attr(*, "resolved")= logi FALSE
[10:58:43.960]  - attr(*, "total_size")= num 19977
[10:58:43.963] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:43.963] getGlobalsAndPackagesXApply() ... DONE
[10:58:43.963] Number of futures (= number of chunks): 2
[10:58:43.964] Launching 2 futures (chunks) ...
[10:58:43.964] Chunk #1 of 2 ...
[10:58:43.964]  - Finding globals in 'X' for chunk #1 ...
[10:58:43.964] getGlobalsAndPackages() ...
[10:58:43.964] Searching for globals...
[10:58:43.964] 
[10:58:43.964] Searching for globals ... DONE
[10:58:43.964] - globals: [0] <none>
[10:58:43.964] getGlobalsAndPackages() ... DONE
[10:58:43.965]    + additional globals found: [n=0] 
[10:58:43.965]    + additional namespaces needed: [n=0] 
[10:58:43.965]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:43.965]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:43.965]  - seeds: <none>
[10:58:43.965]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.965] getGlobalsAndPackages() ...
[10:58:43.965] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.965] Resolving globals: FALSE
[10:58:43.965] Tweak future expression to call with '...' arguments ...
[10:58:43.965] {
[10:58:43.965]     do.call(function(...) {
[10:58:43.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.965]             on.exit(options(oopts), add = TRUE)
[10:58:43.965]         }
[10:58:43.965]         {
[10:58:43.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.965]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.965]             })
[10:58:43.965]         }
[10:58:43.965]     }, args = future.call.arguments)
[10:58:43.965] }
[10:58:43.966] Tweak future expression to call with '...' arguments ... DONE
[10:58:43.966] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.966] 
[10:58:43.966] getGlobalsAndPackages() ... DONE
[10:58:43.966] run() for ‘Future’ ...
[10:58:43.967] - state: ‘created’
[10:58:43.967] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:43.968] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:43.969]   - Field: ‘label’
[10:58:43.969]   - Field: ‘local’
[10:58:43.969]   - Field: ‘owner’
[10:58:43.969]   - Field: ‘envir’
[10:58:43.969]   - Field: ‘workers’
[10:58:43.969]   - Field: ‘packages’
[10:58:43.969]   - Field: ‘gc’
[10:58:43.969]   - Field: ‘job’
[10:58:43.969]   - Field: ‘conditions’
[10:58:43.969]   - Field: ‘expr’
[10:58:43.969]   - Field: ‘uuid’
[10:58:43.969]   - Field: ‘seed’
[10:58:43.970]   - Field: ‘version’
[10:58:43.970]   - Field: ‘result’
[10:58:43.970]   - Field: ‘asynchronous’
[10:58:43.970]   - Field: ‘calls’
[10:58:43.970]   - Field: ‘globals’
[10:58:43.970]   - Field: ‘stdout’
[10:58:43.970]   - Field: ‘earlySignal’
[10:58:43.970]   - Field: ‘lazy’
[10:58:43.970]   - Field: ‘state’
[10:58:43.970] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:43.970] - Launch lazy future ...
[10:58:43.972] Packages needed by the future expression (n = 1): ‘stats’
[10:58:43.972] Packages needed by future strategies (n = 0): <none>
[10:58:43.972] {
[10:58:43.972]     {
[10:58:43.972]         {
[10:58:43.972]             ...future.startTime <- base::Sys.time()
[10:58:43.972]             {
[10:58:43.972]                 {
[10:58:43.972]                   {
[10:58:43.972]                     {
[10:58:43.972]                       {
[10:58:43.972]                         base::local({
[10:58:43.972]                           has_future <- base::requireNamespace("future", 
[10:58:43.972]                             quietly = TRUE)
[10:58:43.972]                           if (has_future) {
[10:58:43.972]                             ns <- base::getNamespace("future")
[10:58:43.972]                             version <- ns[[".package"]][["version"]]
[10:58:43.972]                             if (is.null(version)) 
[10:58:43.972]                               version <- utils::packageVersion("future")
[10:58:43.972]                           }
[10:58:43.972]                           else {
[10:58:43.972]                             version <- NULL
[10:58:43.972]                           }
[10:58:43.972]                           if (!has_future || version < "1.8.0") {
[10:58:43.972]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:43.972]                               "", base::R.version$version.string), 
[10:58:43.972]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:43.972]                                 base::R.version$platform, 8 * 
[10:58:43.972]                                   base::.Machine$sizeof.pointer), 
[10:58:43.972]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:43.972]                                 "release", "version")], collapse = " "), 
[10:58:43.972]                               hostname = base::Sys.info()[["nodename"]])
[10:58:43.972]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:43.972]                               info)
[10:58:43.972]                             info <- base::paste(info, collapse = "; ")
[10:58:43.972]                             if (!has_future) {
[10:58:43.972]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:43.972]                                 info)
[10:58:43.972]                             }
[10:58:43.972]                             else {
[10:58:43.972]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:43.972]                                 info, version)
[10:58:43.972]                             }
[10:58:43.972]                             base::stop(msg)
[10:58:43.972]                           }
[10:58:43.972]                         })
[10:58:43.972]                       }
[10:58:43.972]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:43.972]                       base::options(mc.cores = 1L)
[10:58:43.972]                     }
[10:58:43.972]                     base::local({
[10:58:43.972]                       for (pkg in "stats") {
[10:58:43.972]                         base::loadNamespace(pkg)
[10:58:43.972]                         base::library(pkg, character.only = TRUE)
[10:58:43.972]                       }
[10:58:43.972]                     })
[10:58:43.972]                   }
[10:58:43.972]                   ...future.strategy.old <- future::plan("list")
[10:58:43.972]                   options(future.plan = NULL)
[10:58:43.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:43.972]                 }
[10:58:43.972]                 ...future.workdir <- getwd()
[10:58:43.972]             }
[10:58:43.972]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:43.972]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:43.972]         }
[10:58:43.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:43.972]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:43.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:43.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:43.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:43.972]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:43.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:43.972]             base::names(...future.oldOptions))
[10:58:43.972]     }
[10:58:43.972]     if (FALSE) {
[10:58:43.972]     }
[10:58:43.972]     else {
[10:58:43.972]         if (TRUE) {
[10:58:43.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:43.972]                 open = "w")
[10:58:43.972]         }
[10:58:43.972]         else {
[10:58:43.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:43.972]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:43.972]         }
[10:58:43.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:43.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:43.972]             base::sink(type = "output", split = FALSE)
[10:58:43.972]             base::close(...future.stdout)
[10:58:43.972]         }, add = TRUE)
[10:58:43.972]     }
[10:58:43.972]     ...future.frame <- base::sys.nframe()
[10:58:43.972]     ...future.conditions <- base::list()
[10:58:43.972]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:43.972]     if (FALSE) {
[10:58:43.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:43.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:43.972]     }
[10:58:43.972]     ...future.result <- base::tryCatch({
[10:58:43.972]         base::withCallingHandlers({
[10:58:43.972]             ...future.value <- base::withVisible(base::local({
[10:58:43.972]                 withCallingHandlers({
[10:58:43.972]                   {
[10:58:43.972]                     do.call(function(...) {
[10:58:43.972]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.972]                       if (!identical(...future.globals.maxSize.org, 
[10:58:43.972]                         ...future.globals.maxSize)) {
[10:58:43.972]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.972]                         on.exit(options(oopts), add = TRUE)
[10:58:43.972]                       }
[10:58:43.972]                       {
[10:58:43.972]                         lapply(seq_along(...future.elements_ii), 
[10:58:43.972]                           FUN = function(jj) {
[10:58:43.972]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.972]                             ...future.FUN(...future.X_jj, ...)
[10:58:43.972]                           })
[10:58:43.972]                       }
[10:58:43.972]                     }, args = future.call.arguments)
[10:58:43.972]                   }
[10:58:43.972]                 }, immediateCondition = function(cond) {
[10:58:43.972]                   save_rds <- function (object, pathname, ...) 
[10:58:43.972]                   {
[10:58:43.972]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:43.972]                     if (file_test("-f", pathname_tmp)) {
[10:58:43.972]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.972]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:43.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.972]                         fi_tmp[["mtime"]])
[10:58:43.972]                     }
[10:58:43.972]                     tryCatch({
[10:58:43.972]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:43.972]                     }, error = function(ex) {
[10:58:43.972]                       msg <- conditionMessage(ex)
[10:58:43.972]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.972]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:43.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.972]                         fi_tmp[["mtime"]], msg)
[10:58:43.972]                       ex$message <- msg
[10:58:43.972]                       stop(ex)
[10:58:43.972]                     })
[10:58:43.972]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:43.972]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:43.972]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:43.972]                       fi_tmp <- file.info(pathname_tmp)
[10:58:43.972]                       fi <- file.info(pathname)
[10:58:43.972]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:43.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:43.972]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:43.972]                         fi[["size"]], fi[["mtime"]])
[10:58:43.972]                       stop(msg)
[10:58:43.972]                     }
[10:58:43.972]                     invisible(pathname)
[10:58:43.972]                   }
[10:58:43.972]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:43.972]                     rootPath = tempdir()) 
[10:58:43.972]                   {
[10:58:43.972]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:43.972]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:43.972]                       tmpdir = path, fileext = ".rds")
[10:58:43.972]                     save_rds(obj, file)
[10:58:43.972]                   }
[10:58:43.972]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:43.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.972]                   {
[10:58:43.972]                     inherits <- base::inherits
[10:58:43.972]                     invokeRestart <- base::invokeRestart
[10:58:43.972]                     is.null <- base::is.null
[10:58:43.972]                     muffled <- FALSE
[10:58:43.972]                     if (inherits(cond, "message")) {
[10:58:43.972]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:43.972]                       if (muffled) 
[10:58:43.972]                         invokeRestart("muffleMessage")
[10:58:43.972]                     }
[10:58:43.972]                     else if (inherits(cond, "warning")) {
[10:58:43.972]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:43.972]                       if (muffled) 
[10:58:43.972]                         invokeRestart("muffleWarning")
[10:58:43.972]                     }
[10:58:43.972]                     else if (inherits(cond, "condition")) {
[10:58:43.972]                       if (!is.null(pattern)) {
[10:58:43.972]                         computeRestarts <- base::computeRestarts
[10:58:43.972]                         grepl <- base::grepl
[10:58:43.972]                         restarts <- computeRestarts(cond)
[10:58:43.972]                         for (restart in restarts) {
[10:58:43.972]                           name <- restart$name
[10:58:43.972]                           if (is.null(name)) 
[10:58:43.972]                             next
[10:58:43.972]                           if (!grepl(pattern, name)) 
[10:58:43.972]                             next
[10:58:43.972]                           invokeRestart(restart)
[10:58:43.972]                           muffled <- TRUE
[10:58:43.972]                           break
[10:58:43.972]                         }
[10:58:43.972]                       }
[10:58:43.972]                     }
[10:58:43.972]                     invisible(muffled)
[10:58:43.972]                   }
[10:58:43.972]                   muffleCondition(cond)
[10:58:43.972]                 })
[10:58:43.972]             }))
[10:58:43.972]             future::FutureResult(value = ...future.value$value, 
[10:58:43.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.972]                   ...future.rng), globalenv = if (FALSE) 
[10:58:43.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:43.972]                     ...future.globalenv.names))
[10:58:43.972]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:43.972]         }, condition = base::local({
[10:58:43.972]             c <- base::c
[10:58:43.972]             inherits <- base::inherits
[10:58:43.972]             invokeRestart <- base::invokeRestart
[10:58:43.972]             length <- base::length
[10:58:43.972]             list <- base::list
[10:58:43.972]             seq.int <- base::seq.int
[10:58:43.972]             signalCondition <- base::signalCondition
[10:58:43.972]             sys.calls <- base::sys.calls
[10:58:43.972]             `[[` <- base::`[[`
[10:58:43.972]             `+` <- base::`+`
[10:58:43.972]             `<<-` <- base::`<<-`
[10:58:43.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:43.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:43.972]                   3L)]
[10:58:43.972]             }
[10:58:43.972]             function(cond) {
[10:58:43.972]                 is_error <- inherits(cond, "error")
[10:58:43.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:43.972]                   NULL)
[10:58:43.972]                 if (is_error) {
[10:58:43.972]                   sessionInformation <- function() {
[10:58:43.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:43.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:43.972]                       search = base::search(), system = base::Sys.info())
[10:58:43.972]                   }
[10:58:43.972]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:43.972]                     cond$call), session = sessionInformation(), 
[10:58:43.972]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:43.972]                   signalCondition(cond)
[10:58:43.972]                 }
[10:58:43.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:43.972]                 "immediateCondition"))) {
[10:58:43.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:43.972]                   ...future.conditions[[length(...future.conditions) + 
[10:58:43.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:43.972]                   if (TRUE && !signal) {
[10:58:43.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.972]                     {
[10:58:43.972]                       inherits <- base::inherits
[10:58:43.972]                       invokeRestart <- base::invokeRestart
[10:58:43.972]                       is.null <- base::is.null
[10:58:43.972]                       muffled <- FALSE
[10:58:43.972]                       if (inherits(cond, "message")) {
[10:58:43.972]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.972]                         if (muffled) 
[10:58:43.972]                           invokeRestart("muffleMessage")
[10:58:43.972]                       }
[10:58:43.972]                       else if (inherits(cond, "warning")) {
[10:58:43.972]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.972]                         if (muffled) 
[10:58:43.972]                           invokeRestart("muffleWarning")
[10:58:43.972]                       }
[10:58:43.972]                       else if (inherits(cond, "condition")) {
[10:58:43.972]                         if (!is.null(pattern)) {
[10:58:43.972]                           computeRestarts <- base::computeRestarts
[10:58:43.972]                           grepl <- base::grepl
[10:58:43.972]                           restarts <- computeRestarts(cond)
[10:58:43.972]                           for (restart in restarts) {
[10:58:43.972]                             name <- restart$name
[10:58:43.972]                             if (is.null(name)) 
[10:58:43.972]                               next
[10:58:43.972]                             if (!grepl(pattern, name)) 
[10:58:43.972]                               next
[10:58:43.972]                             invokeRestart(restart)
[10:58:43.972]                             muffled <- TRUE
[10:58:43.972]                             break
[10:58:43.972]                           }
[10:58:43.972]                         }
[10:58:43.972]                       }
[10:58:43.972]                       invisible(muffled)
[10:58:43.972]                     }
[10:58:43.972]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.972]                   }
[10:58:43.972]                 }
[10:58:43.972]                 else {
[10:58:43.972]                   if (TRUE) {
[10:58:43.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:43.972]                     {
[10:58:43.972]                       inherits <- base::inherits
[10:58:43.972]                       invokeRestart <- base::invokeRestart
[10:58:43.972]                       is.null <- base::is.null
[10:58:43.972]                       muffled <- FALSE
[10:58:43.972]                       if (inherits(cond, "message")) {
[10:58:43.972]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:43.972]                         if (muffled) 
[10:58:43.972]                           invokeRestart("muffleMessage")
[10:58:43.972]                       }
[10:58:43.972]                       else if (inherits(cond, "warning")) {
[10:58:43.972]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:43.972]                         if (muffled) 
[10:58:43.972]                           invokeRestart("muffleWarning")
[10:58:43.972]                       }
[10:58:43.972]                       else if (inherits(cond, "condition")) {
[10:58:43.972]                         if (!is.null(pattern)) {
[10:58:43.972]                           computeRestarts <- base::computeRestarts
[10:58:43.972]                           grepl <- base::grepl
[10:58:43.972]                           restarts <- computeRestarts(cond)
[10:58:43.972]                           for (restart in restarts) {
[10:58:43.972]                             name <- restart$name
[10:58:43.972]                             if (is.null(name)) 
[10:58:43.972]                               next
[10:58:43.972]                             if (!grepl(pattern, name)) 
[10:58:43.972]                               next
[10:58:43.972]                             invokeRestart(restart)
[10:58:43.972]                             muffled <- TRUE
[10:58:43.972]                             break
[10:58:43.972]                           }
[10:58:43.972]                         }
[10:58:43.972]                       }
[10:58:43.972]                       invisible(muffled)
[10:58:43.972]                     }
[10:58:43.972]                     muffleCondition(cond, pattern = "^muffle")
[10:58:43.972]                   }
[10:58:43.972]                 }
[10:58:43.972]             }
[10:58:43.972]         }))
[10:58:43.972]     }, error = function(ex) {
[10:58:43.972]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:43.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:43.972]                 ...future.rng), started = ...future.startTime, 
[10:58:43.972]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:43.972]             version = "1.8"), class = "FutureResult")
[10:58:43.972]     }, finally = {
[10:58:43.972]         if (!identical(...future.workdir, getwd())) 
[10:58:43.972]             setwd(...future.workdir)
[10:58:43.972]         {
[10:58:43.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:43.972]                 ...future.oldOptions$nwarnings <- NULL
[10:58:43.972]             }
[10:58:43.972]             base::options(...future.oldOptions)
[10:58:43.972]             if (.Platform$OS.type == "windows") {
[10:58:43.972]                 old_names <- names(...future.oldEnvVars)
[10:58:43.972]                 envs <- base::Sys.getenv()
[10:58:43.972]                 names <- names(envs)
[10:58:43.972]                 common <- intersect(names, old_names)
[10:58:43.972]                 added <- setdiff(names, old_names)
[10:58:43.972]                 removed <- setdiff(old_names, names)
[10:58:43.972]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:43.972]                   envs[common]]
[10:58:43.972]                 NAMES <- toupper(changed)
[10:58:43.972]                 args <- list()
[10:58:43.972]                 for (kk in seq_along(NAMES)) {
[10:58:43.972]                   name <- changed[[kk]]
[10:58:43.972]                   NAME <- NAMES[[kk]]
[10:58:43.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.972]                     next
[10:58:43.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.972]                 }
[10:58:43.972]                 NAMES <- toupper(added)
[10:58:43.972]                 for (kk in seq_along(NAMES)) {
[10:58:43.972]                   name <- added[[kk]]
[10:58:43.972]                   NAME <- NAMES[[kk]]
[10:58:43.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.972]                     next
[10:58:43.972]                   args[[name]] <- ""
[10:58:43.972]                 }
[10:58:43.972]                 NAMES <- toupper(removed)
[10:58:43.972]                 for (kk in seq_along(NAMES)) {
[10:58:43.972]                   name <- removed[[kk]]
[10:58:43.972]                   NAME <- NAMES[[kk]]
[10:58:43.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:43.972]                     next
[10:58:43.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:43.972]                 }
[10:58:43.972]                 if (length(args) > 0) 
[10:58:43.972]                   base::do.call(base::Sys.setenv, args = args)
[10:58:43.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:43.972]             }
[10:58:43.972]             else {
[10:58:43.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:43.972]             }
[10:58:43.972]             {
[10:58:43.972]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:43.972]                   0L) {
[10:58:43.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:43.972]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:43.972]                   base::options(opts)
[10:58:43.972]                 }
[10:58:43.972]                 {
[10:58:43.972]                   {
[10:58:43.972]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:43.972]                     NULL
[10:58:43.972]                   }
[10:58:43.972]                   options(future.plan = NULL)
[10:58:43.972]                   if (is.na(NA_character_)) 
[10:58:43.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:43.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:43.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:43.972]                     .init = FALSE)
[10:58:43.972]                 }
[10:58:43.972]             }
[10:58:43.972]         }
[10:58:43.972]     })
[10:58:43.972]     if (TRUE) {
[10:58:43.972]         base::sink(type = "output", split = FALSE)
[10:58:43.972]         if (TRUE) {
[10:58:43.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:43.972]         }
[10:58:43.972]         else {
[10:58:43.972]             ...future.result["stdout"] <- base::list(NULL)
[10:58:43.972]         }
[10:58:43.972]         base::close(...future.stdout)
[10:58:43.972]         ...future.stdout <- NULL
[10:58:43.972]     }
[10:58:43.972]     ...future.result$conditions <- ...future.conditions
[10:58:43.972]     ...future.result$finished <- base::Sys.time()
[10:58:43.972]     ...future.result
[10:58:43.972] }
[10:58:43.975] assign_globals() ...
[10:58:43.975] List of 5
[10:58:43.975]  $ ...future.FUN            :function (x, ...)  
[10:58:43.975]  $ future.call.arguments    :List of 1
[10:58:43.975]   ..$ singular.ok: logi FALSE
[10:58:43.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:43.975]  $ ...future.elements_ii    :List of 1
[10:58:43.975]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:43.975]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:43.975]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:43.975]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:43.975]  $ ...future.seeds_ii       : NULL
[10:58:43.975]  $ ...future.globals.maxSize: NULL
[10:58:43.975]  - attr(*, "where")=List of 5
[10:58:43.975]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:43.975]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:43.975]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:43.975]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:43.975]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:43.975]  - attr(*, "resolved")= logi FALSE
[10:58:43.975]  - attr(*, "total_size")= num 19977
[10:58:43.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:43.975]  - attr(*, "already-done")= logi TRUE
[10:58:43.981] - reassign environment for ‘...future.FUN’
[10:58:43.981] - copied ‘...future.FUN’ to environment
[10:58:43.981] - copied ‘future.call.arguments’ to environment
[10:58:43.981] - copied ‘...future.elements_ii’ to environment
[10:58:43.981] - copied ‘...future.seeds_ii’ to environment
[10:58:43.981] - copied ‘...future.globals.maxSize’ to environment
[10:58:43.982] assign_globals() ... done
[10:58:43.982] requestCore(): workers = 2
[10:58:43.984] MulticoreFuture started
[10:58:43.984] - Launch lazy future ... done
[10:58:43.984] run() for ‘MulticoreFuture’ ... done
[10:58:43.985] Created future:
[10:58:43.985] plan(): Setting new future strategy stack:
[10:58:43.985] List of future strategies:
[10:58:43.985] 1. sequential:
[10:58:43.985]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:43.985]    - tweaked: FALSE
[10:58:43.985]    - call: NULL
[10:58:43.986] plan(): nbrOfWorkers() = 1
[10:58:43.990] plan(): Setting new future strategy stack:
[10:58:43.990] List of future strategies:
[10:58:43.990] 1. multicore:
[10:58:43.990]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:43.990]    - tweaked: FALSE
[10:58:43.990]    - call: plan(strategy)
[10:58:43.993] plan(): nbrOfWorkers() = 2
[10:58:43.985] MulticoreFuture:
[10:58:43.985] Label: ‘future_by-1’
[10:58:43.985] Expression:
[10:58:43.985] {
[10:58:43.985]     do.call(function(...) {
[10:58:43.985]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.985]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.985]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.985]             on.exit(options(oopts), add = TRUE)
[10:58:43.985]         }
[10:58:43.985]         {
[10:58:43.985]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.985]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.985]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.985]             })
[10:58:43.985]         }
[10:58:43.985]     }, args = future.call.arguments)
[10:58:43.985] }
[10:58:43.985] Lazy evaluation: FALSE
[10:58:43.985] Asynchronous evaluation: TRUE
[10:58:43.985] Local evaluation: TRUE
[10:58:43.985] Environment: R_GlobalEnv
[10:58:43.985] Capture standard output: TRUE
[10:58:43.985] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:43.985] Globals: 5 objects totaling 1.67 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:43.985] Packages: 1 packages (‘stats’)
[10:58:43.985] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:43.985] Resolved: TRUE
[10:58:43.985] Value: <not collected>
[10:58:43.985] Conditions captured: <none>
[10:58:43.985] Early signaling: FALSE
[10:58:43.985] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:43.985] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:43.995] Chunk #1 of 2 ... DONE
[10:58:43.995] Chunk #2 of 2 ...
[10:58:43.996]  - Finding globals in 'X' for chunk #2 ...
[10:58:43.996] getGlobalsAndPackages() ...
[10:58:43.996] Searching for globals...
[10:58:43.997] 
[10:58:43.997] Searching for globals ... DONE
[10:58:43.997] - globals: [0] <none>
[10:58:43.997] getGlobalsAndPackages() ... DONE
[10:58:43.997]    + additional globals found: [n=0] 
[10:58:43.997]    + additional namespaces needed: [n=0] 
[10:58:43.997]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:43.998]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:43.998]  - seeds: <none>
[10:58:43.998]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.998] getGlobalsAndPackages() ...
[10:58:43.998] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:43.998] Resolving globals: FALSE
[10:58:43.998] Tweak future expression to call with '...' arguments ...
[10:58:43.999] {
[10:58:43.999]     do.call(function(...) {
[10:58:43.999]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:43.999]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:43.999]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:43.999]             on.exit(options(oopts), add = TRUE)
[10:58:43.999]         }
[10:58:43.999]         {
[10:58:43.999]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:43.999]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:43.999]                 ...future.FUN(...future.X_jj, ...)
[10:58:43.999]             })
[10:58:43.999]         }
[10:58:43.999]     }, args = future.call.arguments)
[10:58:43.999] }
[10:58:43.999] Tweak future expression to call with '...' arguments ... DONE
[10:58:44.000] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.000] 
[10:58:44.000] getGlobalsAndPackages() ... DONE
[10:58:44.000] run() for ‘Future’ ...
[10:58:44.001] - state: ‘created’
[10:58:44.001] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:44.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:44.004]   - Field: ‘label’
[10:58:44.004]   - Field: ‘local’
[10:58:44.004]   - Field: ‘owner’
[10:58:44.004]   - Field: ‘envir’
[10:58:44.004]   - Field: ‘workers’
[10:58:44.005]   - Field: ‘packages’
[10:58:44.005]   - Field: ‘gc’
[10:58:44.005]   - Field: ‘job’
[10:58:44.005]   - Field: ‘conditions’
[10:58:44.005]   - Field: ‘expr’
[10:58:44.005]   - Field: ‘uuid’
[10:58:44.005]   - Field: ‘seed’
[10:58:44.006]   - Field: ‘version’
[10:58:44.006]   - Field: ‘result’
[10:58:44.006]   - Field: ‘asynchronous’
[10:58:44.006]   - Field: ‘calls’
[10:58:44.006]   - Field: ‘globals’
[10:58:44.006]   - Field: ‘stdout’
[10:58:44.006]   - Field: ‘earlySignal’
[10:58:44.007]   - Field: ‘lazy’
[10:58:44.007]   - Field: ‘state’
[10:58:44.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:44.007] - Launch lazy future ...
[10:58:44.007] Packages needed by the future expression (n = 1): ‘stats’
[10:58:44.008] Packages needed by future strategies (n = 0): <none>
[10:58:44.008] {
[10:58:44.008]     {
[10:58:44.008]         {
[10:58:44.008]             ...future.startTime <- base::Sys.time()
[10:58:44.008]             {
[10:58:44.008]                 {
[10:58:44.008]                   {
[10:58:44.008]                     {
[10:58:44.008]                       {
[10:58:44.008]                         base::local({
[10:58:44.008]                           has_future <- base::requireNamespace("future", 
[10:58:44.008]                             quietly = TRUE)
[10:58:44.008]                           if (has_future) {
[10:58:44.008]                             ns <- base::getNamespace("future")
[10:58:44.008]                             version <- ns[[".package"]][["version"]]
[10:58:44.008]                             if (is.null(version)) 
[10:58:44.008]                               version <- utils::packageVersion("future")
[10:58:44.008]                           }
[10:58:44.008]                           else {
[10:58:44.008]                             version <- NULL
[10:58:44.008]                           }
[10:58:44.008]                           if (!has_future || version < "1.8.0") {
[10:58:44.008]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:44.008]                               "", base::R.version$version.string), 
[10:58:44.008]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:44.008]                                 base::R.version$platform, 8 * 
[10:58:44.008]                                   base::.Machine$sizeof.pointer), 
[10:58:44.008]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:44.008]                                 "release", "version")], collapse = " "), 
[10:58:44.008]                               hostname = base::Sys.info()[["nodename"]])
[10:58:44.008]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:44.008]                               info)
[10:58:44.008]                             info <- base::paste(info, collapse = "; ")
[10:58:44.008]                             if (!has_future) {
[10:58:44.008]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:44.008]                                 info)
[10:58:44.008]                             }
[10:58:44.008]                             else {
[10:58:44.008]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:44.008]                                 info, version)
[10:58:44.008]                             }
[10:58:44.008]                             base::stop(msg)
[10:58:44.008]                           }
[10:58:44.008]                         })
[10:58:44.008]                       }
[10:58:44.008]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:44.008]                       base::options(mc.cores = 1L)
[10:58:44.008]                     }
[10:58:44.008]                     base::local({
[10:58:44.008]                       for (pkg in "stats") {
[10:58:44.008]                         base::loadNamespace(pkg)
[10:58:44.008]                         base::library(pkg, character.only = TRUE)
[10:58:44.008]                       }
[10:58:44.008]                     })
[10:58:44.008]                   }
[10:58:44.008]                   ...future.strategy.old <- future::plan("list")
[10:58:44.008]                   options(future.plan = NULL)
[10:58:44.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:44.008]                 }
[10:58:44.008]                 ...future.workdir <- getwd()
[10:58:44.008]             }
[10:58:44.008]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:44.008]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:44.008]         }
[10:58:44.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:44.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:44.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:44.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:44.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:44.008]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:44.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:44.008]             base::names(...future.oldOptions))
[10:58:44.008]     }
[10:58:44.008]     if (FALSE) {
[10:58:44.008]     }
[10:58:44.008]     else {
[10:58:44.008]         if (TRUE) {
[10:58:44.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:44.008]                 open = "w")
[10:58:44.008]         }
[10:58:44.008]         else {
[10:58:44.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:44.008]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:44.008]         }
[10:58:44.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:44.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:44.008]             base::sink(type = "output", split = FALSE)
[10:58:44.008]             base::close(...future.stdout)
[10:58:44.008]         }, add = TRUE)
[10:58:44.008]     }
[10:58:44.008]     ...future.frame <- base::sys.nframe()
[10:58:44.008]     ...future.conditions <- base::list()
[10:58:44.008]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:44.008]     if (FALSE) {
[10:58:44.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:44.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:44.008]     }
[10:58:44.008]     ...future.result <- base::tryCatch({
[10:58:44.008]         base::withCallingHandlers({
[10:58:44.008]             ...future.value <- base::withVisible(base::local({
[10:58:44.008]                 withCallingHandlers({
[10:58:44.008]                   {
[10:58:44.008]                     do.call(function(...) {
[10:58:44.008]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.008]                       if (!identical(...future.globals.maxSize.org, 
[10:58:44.008]                         ...future.globals.maxSize)) {
[10:58:44.008]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.008]                         on.exit(options(oopts), add = TRUE)
[10:58:44.008]                       }
[10:58:44.008]                       {
[10:58:44.008]                         lapply(seq_along(...future.elements_ii), 
[10:58:44.008]                           FUN = function(jj) {
[10:58:44.008]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.008]                             ...future.FUN(...future.X_jj, ...)
[10:58:44.008]                           })
[10:58:44.008]                       }
[10:58:44.008]                     }, args = future.call.arguments)
[10:58:44.008]                   }
[10:58:44.008]                 }, immediateCondition = function(cond) {
[10:58:44.008]                   save_rds <- function (object, pathname, ...) 
[10:58:44.008]                   {
[10:58:44.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:44.008]                     if (file_test("-f", pathname_tmp)) {
[10:58:44.008]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:44.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.008]                         fi_tmp[["mtime"]])
[10:58:44.008]                     }
[10:58:44.008]                     tryCatch({
[10:58:44.008]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:44.008]                     }, error = function(ex) {
[10:58:44.008]                       msg <- conditionMessage(ex)
[10:58:44.008]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:44.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.008]                         fi_tmp[["mtime"]], msg)
[10:58:44.008]                       ex$message <- msg
[10:58:44.008]                       stop(ex)
[10:58:44.008]                     })
[10:58:44.008]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:44.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:44.008]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:44.008]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.008]                       fi <- file.info(pathname)
[10:58:44.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:44.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:44.008]                         fi[["size"]], fi[["mtime"]])
[10:58:44.008]                       stop(msg)
[10:58:44.008]                     }
[10:58:44.008]                     invisible(pathname)
[10:58:44.008]                   }
[10:58:44.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:44.008]                     rootPath = tempdir()) 
[10:58:44.008]                   {
[10:58:44.008]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:44.008]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:44.008]                       tmpdir = path, fileext = ".rds")
[10:58:44.008]                     save_rds(obj, file)
[10:58:44.008]                   }
[10:58:44.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:44.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.008]                   {
[10:58:44.008]                     inherits <- base::inherits
[10:58:44.008]                     invokeRestart <- base::invokeRestart
[10:58:44.008]                     is.null <- base::is.null
[10:58:44.008]                     muffled <- FALSE
[10:58:44.008]                     if (inherits(cond, "message")) {
[10:58:44.008]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:44.008]                       if (muffled) 
[10:58:44.008]                         invokeRestart("muffleMessage")
[10:58:44.008]                     }
[10:58:44.008]                     else if (inherits(cond, "warning")) {
[10:58:44.008]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:44.008]                       if (muffled) 
[10:58:44.008]                         invokeRestart("muffleWarning")
[10:58:44.008]                     }
[10:58:44.008]                     else if (inherits(cond, "condition")) {
[10:58:44.008]                       if (!is.null(pattern)) {
[10:58:44.008]                         computeRestarts <- base::computeRestarts
[10:58:44.008]                         grepl <- base::grepl
[10:58:44.008]                         restarts <- computeRestarts(cond)
[10:58:44.008]                         for (restart in restarts) {
[10:58:44.008]                           name <- restart$name
[10:58:44.008]                           if (is.null(name)) 
[10:58:44.008]                             next
[10:58:44.008]                           if (!grepl(pattern, name)) 
[10:58:44.008]                             next
[10:58:44.008]                           invokeRestart(restart)
[10:58:44.008]                           muffled <- TRUE
[10:58:44.008]                           break
[10:58:44.008]                         }
[10:58:44.008]                       }
[10:58:44.008]                     }
[10:58:44.008]                     invisible(muffled)
[10:58:44.008]                   }
[10:58:44.008]                   muffleCondition(cond)
[10:58:44.008]                 })
[10:58:44.008]             }))
[10:58:44.008]             future::FutureResult(value = ...future.value$value, 
[10:58:44.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.008]                   ...future.rng), globalenv = if (FALSE) 
[10:58:44.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:44.008]                     ...future.globalenv.names))
[10:58:44.008]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:44.008]         }, condition = base::local({
[10:58:44.008]             c <- base::c
[10:58:44.008]             inherits <- base::inherits
[10:58:44.008]             invokeRestart <- base::invokeRestart
[10:58:44.008]             length <- base::length
[10:58:44.008]             list <- base::list
[10:58:44.008]             seq.int <- base::seq.int
[10:58:44.008]             signalCondition <- base::signalCondition
[10:58:44.008]             sys.calls <- base::sys.calls
[10:58:44.008]             `[[` <- base::`[[`
[10:58:44.008]             `+` <- base::`+`
[10:58:44.008]             `<<-` <- base::`<<-`
[10:58:44.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:44.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:44.008]                   3L)]
[10:58:44.008]             }
[10:58:44.008]             function(cond) {
[10:58:44.008]                 is_error <- inherits(cond, "error")
[10:58:44.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:44.008]                   NULL)
[10:58:44.008]                 if (is_error) {
[10:58:44.008]                   sessionInformation <- function() {
[10:58:44.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:44.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:44.008]                       search = base::search(), system = base::Sys.info())
[10:58:44.008]                   }
[10:58:44.008]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:44.008]                     cond$call), session = sessionInformation(), 
[10:58:44.008]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:44.008]                   signalCondition(cond)
[10:58:44.008]                 }
[10:58:44.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:44.008]                 "immediateCondition"))) {
[10:58:44.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:44.008]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:44.008]                   if (TRUE && !signal) {
[10:58:44.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.008]                     {
[10:58:44.008]                       inherits <- base::inherits
[10:58:44.008]                       invokeRestart <- base::invokeRestart
[10:58:44.008]                       is.null <- base::is.null
[10:58:44.008]                       muffled <- FALSE
[10:58:44.008]                       if (inherits(cond, "message")) {
[10:58:44.008]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.008]                         if (muffled) 
[10:58:44.008]                           invokeRestart("muffleMessage")
[10:58:44.008]                       }
[10:58:44.008]                       else if (inherits(cond, "warning")) {
[10:58:44.008]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.008]                         if (muffled) 
[10:58:44.008]                           invokeRestart("muffleWarning")
[10:58:44.008]                       }
[10:58:44.008]                       else if (inherits(cond, "condition")) {
[10:58:44.008]                         if (!is.null(pattern)) {
[10:58:44.008]                           computeRestarts <- base::computeRestarts
[10:58:44.008]                           grepl <- base::grepl
[10:58:44.008]                           restarts <- computeRestarts(cond)
[10:58:44.008]                           for (restart in restarts) {
[10:58:44.008]                             name <- restart$name
[10:58:44.008]                             if (is.null(name)) 
[10:58:44.008]                               next
[10:58:44.008]                             if (!grepl(pattern, name)) 
[10:58:44.008]                               next
[10:58:44.008]                             invokeRestart(restart)
[10:58:44.008]                             muffled <- TRUE
[10:58:44.008]                             break
[10:58:44.008]                           }
[10:58:44.008]                         }
[10:58:44.008]                       }
[10:58:44.008]                       invisible(muffled)
[10:58:44.008]                     }
[10:58:44.008]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.008]                   }
[10:58:44.008]                 }
[10:58:44.008]                 else {
[10:58:44.008]                   if (TRUE) {
[10:58:44.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.008]                     {
[10:58:44.008]                       inherits <- base::inherits
[10:58:44.008]                       invokeRestart <- base::invokeRestart
[10:58:44.008]                       is.null <- base::is.null
[10:58:44.008]                       muffled <- FALSE
[10:58:44.008]                       if (inherits(cond, "message")) {
[10:58:44.008]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.008]                         if (muffled) 
[10:58:44.008]                           invokeRestart("muffleMessage")
[10:58:44.008]                       }
[10:58:44.008]                       else if (inherits(cond, "warning")) {
[10:58:44.008]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.008]                         if (muffled) 
[10:58:44.008]                           invokeRestart("muffleWarning")
[10:58:44.008]                       }
[10:58:44.008]                       else if (inherits(cond, "condition")) {
[10:58:44.008]                         if (!is.null(pattern)) {
[10:58:44.008]                           computeRestarts <- base::computeRestarts
[10:58:44.008]                           grepl <- base::grepl
[10:58:44.008]                           restarts <- computeRestarts(cond)
[10:58:44.008]                           for (restart in restarts) {
[10:58:44.008]                             name <- restart$name
[10:58:44.008]                             if (is.null(name)) 
[10:58:44.008]                               next
[10:58:44.008]                             if (!grepl(pattern, name)) 
[10:58:44.008]                               next
[10:58:44.008]                             invokeRestart(restart)
[10:58:44.008]                             muffled <- TRUE
[10:58:44.008]                             break
[10:58:44.008]                           }
[10:58:44.008]                         }
[10:58:44.008]                       }
[10:58:44.008]                       invisible(muffled)
[10:58:44.008]                     }
[10:58:44.008]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.008]                   }
[10:58:44.008]                 }
[10:58:44.008]             }
[10:58:44.008]         }))
[10:58:44.008]     }, error = function(ex) {
[10:58:44.008]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:44.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.008]                 ...future.rng), started = ...future.startTime, 
[10:58:44.008]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:44.008]             version = "1.8"), class = "FutureResult")
[10:58:44.008]     }, finally = {
[10:58:44.008]         if (!identical(...future.workdir, getwd())) 
[10:58:44.008]             setwd(...future.workdir)
[10:58:44.008]         {
[10:58:44.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:44.008]                 ...future.oldOptions$nwarnings <- NULL
[10:58:44.008]             }
[10:58:44.008]             base::options(...future.oldOptions)
[10:58:44.008]             if (.Platform$OS.type == "windows") {
[10:58:44.008]                 old_names <- names(...future.oldEnvVars)
[10:58:44.008]                 envs <- base::Sys.getenv()
[10:58:44.008]                 names <- names(envs)
[10:58:44.008]                 common <- intersect(names, old_names)
[10:58:44.008]                 added <- setdiff(names, old_names)
[10:58:44.008]                 removed <- setdiff(old_names, names)
[10:58:44.008]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:44.008]                   envs[common]]
[10:58:44.008]                 NAMES <- toupper(changed)
[10:58:44.008]                 args <- list()
[10:58:44.008]                 for (kk in seq_along(NAMES)) {
[10:58:44.008]                   name <- changed[[kk]]
[10:58:44.008]                   NAME <- NAMES[[kk]]
[10:58:44.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.008]                     next
[10:58:44.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.008]                 }
[10:58:44.008]                 NAMES <- toupper(added)
[10:58:44.008]                 for (kk in seq_along(NAMES)) {
[10:58:44.008]                   name <- added[[kk]]
[10:58:44.008]                   NAME <- NAMES[[kk]]
[10:58:44.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.008]                     next
[10:58:44.008]                   args[[name]] <- ""
[10:58:44.008]                 }
[10:58:44.008]                 NAMES <- toupper(removed)
[10:58:44.008]                 for (kk in seq_along(NAMES)) {
[10:58:44.008]                   name <- removed[[kk]]
[10:58:44.008]                   NAME <- NAMES[[kk]]
[10:58:44.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.008]                     next
[10:58:44.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.008]                 }
[10:58:44.008]                 if (length(args) > 0) 
[10:58:44.008]                   base::do.call(base::Sys.setenv, args = args)
[10:58:44.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:44.008]             }
[10:58:44.008]             else {
[10:58:44.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:44.008]             }
[10:58:44.008]             {
[10:58:44.008]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:44.008]                   0L) {
[10:58:44.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:44.008]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:44.008]                   base::options(opts)
[10:58:44.008]                 }
[10:58:44.008]                 {
[10:58:44.008]                   {
[10:58:44.008]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:44.008]                     NULL
[10:58:44.008]                   }
[10:58:44.008]                   options(future.plan = NULL)
[10:58:44.008]                   if (is.na(NA_character_)) 
[10:58:44.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:44.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:44.008]                     .init = FALSE)
[10:58:44.008]                 }
[10:58:44.008]             }
[10:58:44.008]         }
[10:58:44.008]     })
[10:58:44.008]     if (TRUE) {
[10:58:44.008]         base::sink(type = "output", split = FALSE)
[10:58:44.008]         if (TRUE) {
[10:58:44.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:44.008]         }
[10:58:44.008]         else {
[10:58:44.008]             ...future.result["stdout"] <- base::list(NULL)
[10:58:44.008]         }
[10:58:44.008]         base::close(...future.stdout)
[10:58:44.008]         ...future.stdout <- NULL
[10:58:44.008]     }
[10:58:44.008]     ...future.result$conditions <- ...future.conditions
[10:58:44.008]     ...future.result$finished <- base::Sys.time()
[10:58:44.008]     ...future.result
[10:58:44.008] }
[10:58:44.012] assign_globals() ...
[10:58:44.015] List of 5
[10:58:44.015]  $ ...future.FUN            :function (x, ...)  
[10:58:44.015]  $ future.call.arguments    :List of 1
[10:58:44.015]   ..$ singular.ok: logi FALSE
[10:58:44.015]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.015]  $ ...future.elements_ii    :List of 2
[10:58:44.015]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.015]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:44.015]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.015]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:44.015]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.015]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:44.015]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.015]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:44.015]  $ ...future.seeds_ii       : NULL
[10:58:44.015]  $ ...future.globals.maxSize: NULL
[10:58:44.015]  - attr(*, "where")=List of 5
[10:58:44.015]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:44.015]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:44.015]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:44.015]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:44.015]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:44.015]  - attr(*, "resolved")= logi FALSE
[10:58:44.015]  - attr(*, "total_size")= num 19977
[10:58:44.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.015]  - attr(*, "already-done")= logi TRUE
[10:58:44.028] - reassign environment for ‘...future.FUN’
[10:58:44.028] - copied ‘...future.FUN’ to environment
[10:58:44.028] - copied ‘future.call.arguments’ to environment
[10:58:44.028] - copied ‘...future.elements_ii’ to environment
[10:58:44.028] - copied ‘...future.seeds_ii’ to environment
[10:58:44.029] - copied ‘...future.globals.maxSize’ to environment
[10:58:44.029] assign_globals() ... done
[10:58:44.029] requestCore(): workers = 2
[10:58:44.031] MulticoreFuture started
[10:58:44.031] - Launch lazy future ... done
[10:58:44.032] run() for ‘MulticoreFuture’ ... done
[10:58:44.032] Created future:
[10:58:44.032] plan(): Setting new future strategy stack:
[10:58:44.033] List of future strategies:
[10:58:44.033] 1. sequential:
[10:58:44.033]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:44.033]    - tweaked: FALSE
[10:58:44.033]    - call: NULL
[10:58:44.034] plan(): nbrOfWorkers() = 1
[10:58:44.039] plan(): Setting new future strategy stack:
[10:58:44.039] List of future strategies:
[10:58:44.039] 1. multicore:
[10:58:44.039]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:44.039]    - tweaked: FALSE
[10:58:44.039]    - call: plan(strategy)
[10:58:44.042] plan(): nbrOfWorkers() = 2
[10:58:44.032] MulticoreFuture:
[10:58:44.032] Label: ‘future_by-2’
[10:58:44.032] Expression:
[10:58:44.032] {
[10:58:44.032]     do.call(function(...) {
[10:58:44.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.032]             on.exit(options(oopts), add = TRUE)
[10:58:44.032]         }
[10:58:44.032]         {
[10:58:44.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.032]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.032]             })
[10:58:44.032]         }
[10:58:44.032]     }, args = future.call.arguments)
[10:58:44.032] }
[10:58:44.032] Lazy evaluation: FALSE
[10:58:44.032] Asynchronous evaluation: TRUE
[10:58:44.032] Local evaluation: TRUE
[10:58:44.032] Environment: R_GlobalEnv
[10:58:44.032] Capture standard output: TRUE
[10:58:44.032] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:44.032] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:44.032] Packages: 1 packages (‘stats’)
[10:58:44.032] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:44.032] Resolved: TRUE
[10:58:44.032] Value: <not collected>
[10:58:44.032] Conditions captured: <none>
[10:58:44.032] Early signaling: FALSE
[10:58:44.032] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:44.032] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.044] Chunk #2 of 2 ... DONE
[10:58:44.044] Launching 2 futures (chunks) ... DONE
[10:58:44.044] Resolving 2 futures (chunks) ...
[10:58:44.044] resolve() on list ...
[10:58:44.044]  recursive: 0
[10:58:44.044]  length: 2
[10:58:44.045] 
[10:58:44.045] Future #1
[10:58:44.045] result() for MulticoreFuture ...
[10:58:44.046] result() for MulticoreFuture ...
[10:58:44.047] result() for MulticoreFuture ... done
[10:58:44.047] result() for MulticoreFuture ... done
[10:58:44.047] result() for MulticoreFuture ...
[10:58:44.047] result() for MulticoreFuture ... done
[10:58:44.047] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:44.047] - nx: 2
[10:58:44.047] - relay: TRUE
[10:58:44.048] - stdout: TRUE
[10:58:44.048] - signal: TRUE
[10:58:44.048] - resignal: FALSE
[10:58:44.048] - force: TRUE
[10:58:44.048] - relayed: [n=2] FALSE, FALSE
[10:58:44.048] - queued futures: [n=2] FALSE, FALSE
[10:58:44.048]  - until=1
[10:58:44.048]  - relaying element #1
[10:58:44.049] result() for MulticoreFuture ...
[10:58:44.049] result() for MulticoreFuture ... done
[10:58:44.049] result() for MulticoreFuture ...
[10:58:44.049] result() for MulticoreFuture ... done
[10:58:44.049] result() for MulticoreFuture ...
[10:58:44.049] result() for MulticoreFuture ... done
[10:58:44.049] result() for MulticoreFuture ...
[10:58:44.050] result() for MulticoreFuture ... done
[10:58:44.050] - relayed: [n=2] TRUE, FALSE
[10:58:44.050] - queued futures: [n=2] TRUE, FALSE
[10:58:44.050] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:44.050]  length: 1 (resolved future 1)
[10:58:44.051] Future #2
[10:58:44.051] result() for MulticoreFuture ...
[10:58:44.052] result() for MulticoreFuture ...
[10:58:44.052] result() for MulticoreFuture ... done
[10:58:44.052] result() for MulticoreFuture ... done
[10:58:44.052] result() for MulticoreFuture ...
[10:58:44.053] result() for MulticoreFuture ... done
[10:58:44.053] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:44.053] - nx: 2
[10:58:44.053] - relay: TRUE
[10:58:44.053] - stdout: TRUE
[10:58:44.053] - signal: TRUE
[10:58:44.053] - resignal: FALSE
[10:58:44.053] - force: TRUE
[10:58:44.054] - relayed: [n=2] TRUE, FALSE
[10:58:44.054] - queued futures: [n=2] TRUE, FALSE
[10:58:44.054]  - until=2
[10:58:44.054]  - relaying element #2
[10:58:44.054] result() for MulticoreFuture ...
[10:58:44.054] result() for MulticoreFuture ... done
[10:58:44.054] result() for MulticoreFuture ...
[10:58:44.054] result() for MulticoreFuture ... done
[10:58:44.055] result() for MulticoreFuture ...
[10:58:44.055] result() for MulticoreFuture ... done
[10:58:44.055] result() for MulticoreFuture ...
[10:58:44.055] result() for MulticoreFuture ... done
[10:58:44.055] - relayed: [n=2] TRUE, TRUE
[10:58:44.055] - queued futures: [n=2] TRUE, TRUE
[10:58:44.055] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:44.058]  length: 0 (resolved future 2)
[10:58:44.058] Relaying remaining futures
[10:58:44.058] signalConditionsASAP(NULL, pos=0) ...
[10:58:44.058] - nx: 2
[10:58:44.058] - relay: TRUE
[10:58:44.058] - stdout: TRUE
[10:58:44.059] - signal: TRUE
[10:58:44.059] - resignal: FALSE
[10:58:44.059] - force: TRUE
[10:58:44.059] - relayed: [n=2] TRUE, TRUE
[10:58:44.059] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:44.059] - relayed: [n=2] TRUE, TRUE
[10:58:44.059] - queued futures: [n=2] TRUE, TRUE
[10:58:44.060] signalConditionsASAP(NULL, pos=0) ... done
[10:58:44.060] resolve() on list ... DONE
[10:58:44.060] result() for MulticoreFuture ...
[10:58:44.060] result() for MulticoreFuture ... done
[10:58:44.060] result() for MulticoreFuture ...
[10:58:44.060] result() for MulticoreFuture ... done
[10:58:44.061] result() for MulticoreFuture ...
[10:58:44.061] result() for MulticoreFuture ... done
[10:58:44.061] result() for MulticoreFuture ...
[10:58:44.061] result() for MulticoreFuture ... done
[10:58:44.061]  - Number of value chunks collected: 2
[10:58:44.061] Resolving 2 futures (chunks) ... DONE
[10:58:44.061] Reducing values from 2 chunks ...
[10:58:44.061]  - Number of values collected after concatenation: 3
[10:58:44.062]  - Number of values expected: 3
[10:58:44.062] Reducing values from 2 chunks ... DONE
[10:58:44.062] future_lapply() ... DONE
[10:58:44.062] future_by_internal() ... DONE
[10:58:44.067] future_by_internal() ...
[10:58:44.068] future_lapply() ...
[10:58:44.070] Number of chunks: 2
[10:58:44.070] getGlobalsAndPackagesXApply() ...
[10:58:44.071]  - future.globals: TRUE
[10:58:44.071] getGlobalsAndPackages() ...
[10:58:44.071] Searching for globals...
[10:58:44.072] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:44.073] Searching for globals ... DONE
[10:58:44.073] Resolving globals: FALSE
[10:58:44.073] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:58:44.074] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:58:44.074] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:44.074] - packages: [1] ‘stats’
[10:58:44.074] getGlobalsAndPackages() ... DONE
[10:58:44.074]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:44.074]  - needed namespaces: [n=1] ‘stats’
[10:58:44.074] Finding globals ... DONE
[10:58:44.074]  - use_args: TRUE
[10:58:44.074]  - Getting '...' globals ...
[10:58:44.075] resolve() on list ...
[10:58:44.075]  recursive: 0
[10:58:44.075]  length: 1
[10:58:44.075]  elements: ‘...’
[10:58:44.075]  length: 0 (resolved future 1)
[10:58:44.075] resolve() on list ... DONE
[10:58:44.075]    - '...' content: [n=0] 
[10:58:44.075] List of 1
[10:58:44.075]  $ ...: list()
[10:58:44.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.075]  - attr(*, "where")=List of 1
[10:58:44.075]   ..$ ...:<environment: 0x55974bde93e8> 
[10:58:44.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.075]  - attr(*, "resolved")= logi TRUE
[10:58:44.075]  - attr(*, "total_size")= num NA
[10:58:44.079]  - Getting '...' globals ... DONE
[10:58:44.080] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:58:44.080] List of 4
[10:58:44.080]  $ ...future.FUN:function (x)  
[10:58:44.080]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:44.080]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:44.080]  $ ...          : list()
[10:58:44.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.080]  - attr(*, "where")=List of 4
[10:58:44.080]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:44.080]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:58:44.080]   ..$ wool         :<environment: R_EmptyEnv> 
[10:58:44.080]   ..$ ...          :<environment: 0x55974bde93e8> 
[10:58:44.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.080]  - attr(*, "resolved")= logi FALSE
[10:58:44.080]  - attr(*, "total_size")= num 18867
[10:58:44.084] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:44.084] getGlobalsAndPackagesXApply() ... DONE
[10:58:44.084] Number of futures (= number of chunks): 2
[10:58:44.084] Launching 2 futures (chunks) ...
[10:58:44.084] Chunk #1 of 2 ...
[10:58:44.084]  - Finding globals in 'X' for chunk #1 ...
[10:58:44.085] getGlobalsAndPackages() ...
[10:58:44.085] Searching for globals...
[10:58:44.085] 
[10:58:44.085] Searching for globals ... DONE
[10:58:44.085] - globals: [0] <none>
[10:58:44.085] getGlobalsAndPackages() ... DONE
[10:58:44.085]    + additional globals found: [n=0] 
[10:58:44.085]    + additional namespaces needed: [n=0] 
[10:58:44.085]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:44.086]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:44.086]  - seeds: <none>
[10:58:44.086]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.086] getGlobalsAndPackages() ...
[10:58:44.086] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.086] Resolving globals: FALSE
[10:58:44.086] Tweak future expression to call with '...' arguments ...
[10:58:44.086] {
[10:58:44.086]     do.call(function(...) {
[10:58:44.086]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.086]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.086]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.086]             on.exit(options(oopts), add = TRUE)
[10:58:44.086]         }
[10:58:44.086]         {
[10:58:44.086]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.086]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.086]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.086]             })
[10:58:44.086]         }
[10:58:44.086]     }, args = future.call.arguments)
[10:58:44.086] }
[10:58:44.086] Tweak future expression to call with '...' arguments ... DONE
[10:58:44.087] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.087] 
[10:58:44.087] getGlobalsAndPackages() ... DONE
[10:58:44.087] run() for ‘Future’ ...
[10:58:44.087] - state: ‘created’
[10:58:44.088] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:44.089] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:44.089]   - Field: ‘label’
[10:58:44.089]   - Field: ‘local’
[10:58:44.090]   - Field: ‘owner’
[10:58:44.090]   - Field: ‘envir’
[10:58:44.090]   - Field: ‘workers’
[10:58:44.090]   - Field: ‘packages’
[10:58:44.090]   - Field: ‘gc’
[10:58:44.090]   - Field: ‘job’
[10:58:44.090]   - Field: ‘conditions’
[10:58:44.090]   - Field: ‘expr’
[10:58:44.090]   - Field: ‘uuid’
[10:58:44.090]   - Field: ‘seed’
[10:58:44.090]   - Field: ‘version’
[10:58:44.090]   - Field: ‘result’
[10:58:44.091]   - Field: ‘asynchronous’
[10:58:44.091]   - Field: ‘calls’
[10:58:44.091]   - Field: ‘globals’
[10:58:44.091]   - Field: ‘stdout’
[10:58:44.091]   - Field: ‘earlySignal’
[10:58:44.091]   - Field: ‘lazy’
[10:58:44.091]   - Field: ‘state’
[10:58:44.091] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:44.091] - Launch lazy future ...
[10:58:44.091] Packages needed by the future expression (n = 1): ‘stats’
[10:58:44.092] Packages needed by future strategies (n = 0): <none>
[10:58:44.092] {
[10:58:44.092]     {
[10:58:44.092]         {
[10:58:44.092]             ...future.startTime <- base::Sys.time()
[10:58:44.092]             {
[10:58:44.092]                 {
[10:58:44.092]                   {
[10:58:44.092]                     {
[10:58:44.092]                       {
[10:58:44.092]                         base::local({
[10:58:44.092]                           has_future <- base::requireNamespace("future", 
[10:58:44.092]                             quietly = TRUE)
[10:58:44.092]                           if (has_future) {
[10:58:44.092]                             ns <- base::getNamespace("future")
[10:58:44.092]                             version <- ns[[".package"]][["version"]]
[10:58:44.092]                             if (is.null(version)) 
[10:58:44.092]                               version <- utils::packageVersion("future")
[10:58:44.092]                           }
[10:58:44.092]                           else {
[10:58:44.092]                             version <- NULL
[10:58:44.092]                           }
[10:58:44.092]                           if (!has_future || version < "1.8.0") {
[10:58:44.092]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:44.092]                               "", base::R.version$version.string), 
[10:58:44.092]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:44.092]                                 base::R.version$platform, 8 * 
[10:58:44.092]                                   base::.Machine$sizeof.pointer), 
[10:58:44.092]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:44.092]                                 "release", "version")], collapse = " "), 
[10:58:44.092]                               hostname = base::Sys.info()[["nodename"]])
[10:58:44.092]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:44.092]                               info)
[10:58:44.092]                             info <- base::paste(info, collapse = "; ")
[10:58:44.092]                             if (!has_future) {
[10:58:44.092]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:44.092]                                 info)
[10:58:44.092]                             }
[10:58:44.092]                             else {
[10:58:44.092]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:44.092]                                 info, version)
[10:58:44.092]                             }
[10:58:44.092]                             base::stop(msg)
[10:58:44.092]                           }
[10:58:44.092]                         })
[10:58:44.092]                       }
[10:58:44.092]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:44.092]                       base::options(mc.cores = 1L)
[10:58:44.092]                     }
[10:58:44.092]                     base::local({
[10:58:44.092]                       for (pkg in "stats") {
[10:58:44.092]                         base::loadNamespace(pkg)
[10:58:44.092]                         base::library(pkg, character.only = TRUE)
[10:58:44.092]                       }
[10:58:44.092]                     })
[10:58:44.092]                   }
[10:58:44.092]                   ...future.strategy.old <- future::plan("list")
[10:58:44.092]                   options(future.plan = NULL)
[10:58:44.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:44.092]                 }
[10:58:44.092]                 ...future.workdir <- getwd()
[10:58:44.092]             }
[10:58:44.092]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:44.092]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:44.092]         }
[10:58:44.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:44.092]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:44.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:44.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:44.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:44.092]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:44.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:44.092]             base::names(...future.oldOptions))
[10:58:44.092]     }
[10:58:44.092]     if (FALSE) {
[10:58:44.092]     }
[10:58:44.092]     else {
[10:58:44.092]         if (TRUE) {
[10:58:44.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:44.092]                 open = "w")
[10:58:44.092]         }
[10:58:44.092]         else {
[10:58:44.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:44.092]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:44.092]         }
[10:58:44.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:44.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:44.092]             base::sink(type = "output", split = FALSE)
[10:58:44.092]             base::close(...future.stdout)
[10:58:44.092]         }, add = TRUE)
[10:58:44.092]     }
[10:58:44.092]     ...future.frame <- base::sys.nframe()
[10:58:44.092]     ...future.conditions <- base::list()
[10:58:44.092]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:44.092]     if (FALSE) {
[10:58:44.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:44.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:44.092]     }
[10:58:44.092]     ...future.result <- base::tryCatch({
[10:58:44.092]         base::withCallingHandlers({
[10:58:44.092]             ...future.value <- base::withVisible(base::local({
[10:58:44.092]                 withCallingHandlers({
[10:58:44.092]                   {
[10:58:44.092]                     do.call(function(...) {
[10:58:44.092]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.092]                       if (!identical(...future.globals.maxSize.org, 
[10:58:44.092]                         ...future.globals.maxSize)) {
[10:58:44.092]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.092]                         on.exit(options(oopts), add = TRUE)
[10:58:44.092]                       }
[10:58:44.092]                       {
[10:58:44.092]                         lapply(seq_along(...future.elements_ii), 
[10:58:44.092]                           FUN = function(jj) {
[10:58:44.092]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.092]                             ...future.FUN(...future.X_jj, ...)
[10:58:44.092]                           })
[10:58:44.092]                       }
[10:58:44.092]                     }, args = future.call.arguments)
[10:58:44.092]                   }
[10:58:44.092]                 }, immediateCondition = function(cond) {
[10:58:44.092]                   save_rds <- function (object, pathname, ...) 
[10:58:44.092]                   {
[10:58:44.092]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:44.092]                     if (file_test("-f", pathname_tmp)) {
[10:58:44.092]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.092]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:44.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.092]                         fi_tmp[["mtime"]])
[10:58:44.092]                     }
[10:58:44.092]                     tryCatch({
[10:58:44.092]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:44.092]                     }, error = function(ex) {
[10:58:44.092]                       msg <- conditionMessage(ex)
[10:58:44.092]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.092]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:44.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.092]                         fi_tmp[["mtime"]], msg)
[10:58:44.092]                       ex$message <- msg
[10:58:44.092]                       stop(ex)
[10:58:44.092]                     })
[10:58:44.092]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:44.092]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:44.092]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:44.092]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.092]                       fi <- file.info(pathname)
[10:58:44.092]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:44.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.092]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:44.092]                         fi[["size"]], fi[["mtime"]])
[10:58:44.092]                       stop(msg)
[10:58:44.092]                     }
[10:58:44.092]                     invisible(pathname)
[10:58:44.092]                   }
[10:58:44.092]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:44.092]                     rootPath = tempdir()) 
[10:58:44.092]                   {
[10:58:44.092]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:44.092]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:44.092]                       tmpdir = path, fileext = ".rds")
[10:58:44.092]                     save_rds(obj, file)
[10:58:44.092]                   }
[10:58:44.092]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:44.092]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.092]                   {
[10:58:44.092]                     inherits <- base::inherits
[10:58:44.092]                     invokeRestart <- base::invokeRestart
[10:58:44.092]                     is.null <- base::is.null
[10:58:44.092]                     muffled <- FALSE
[10:58:44.092]                     if (inherits(cond, "message")) {
[10:58:44.092]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:44.092]                       if (muffled) 
[10:58:44.092]                         invokeRestart("muffleMessage")
[10:58:44.092]                     }
[10:58:44.092]                     else if (inherits(cond, "warning")) {
[10:58:44.092]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:44.092]                       if (muffled) 
[10:58:44.092]                         invokeRestart("muffleWarning")
[10:58:44.092]                     }
[10:58:44.092]                     else if (inherits(cond, "condition")) {
[10:58:44.092]                       if (!is.null(pattern)) {
[10:58:44.092]                         computeRestarts <- base::computeRestarts
[10:58:44.092]                         grepl <- base::grepl
[10:58:44.092]                         restarts <- computeRestarts(cond)
[10:58:44.092]                         for (restart in restarts) {
[10:58:44.092]                           name <- restart$name
[10:58:44.092]                           if (is.null(name)) 
[10:58:44.092]                             next
[10:58:44.092]                           if (!grepl(pattern, name)) 
[10:58:44.092]                             next
[10:58:44.092]                           invokeRestart(restart)
[10:58:44.092]                           muffled <- TRUE
[10:58:44.092]                           break
[10:58:44.092]                         }
[10:58:44.092]                       }
[10:58:44.092]                     }
[10:58:44.092]                     invisible(muffled)
[10:58:44.092]                   }
[10:58:44.092]                   muffleCondition(cond)
[10:58:44.092]                 })
[10:58:44.092]             }))
[10:58:44.092]             future::FutureResult(value = ...future.value$value, 
[10:58:44.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.092]                   ...future.rng), globalenv = if (FALSE) 
[10:58:44.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:44.092]                     ...future.globalenv.names))
[10:58:44.092]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:44.092]         }, condition = base::local({
[10:58:44.092]             c <- base::c
[10:58:44.092]             inherits <- base::inherits
[10:58:44.092]             invokeRestart <- base::invokeRestart
[10:58:44.092]             length <- base::length
[10:58:44.092]             list <- base::list
[10:58:44.092]             seq.int <- base::seq.int
[10:58:44.092]             signalCondition <- base::signalCondition
[10:58:44.092]             sys.calls <- base::sys.calls
[10:58:44.092]             `[[` <- base::`[[`
[10:58:44.092]             `+` <- base::`+`
[10:58:44.092]             `<<-` <- base::`<<-`
[10:58:44.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:44.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:44.092]                   3L)]
[10:58:44.092]             }
[10:58:44.092]             function(cond) {
[10:58:44.092]                 is_error <- inherits(cond, "error")
[10:58:44.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:44.092]                   NULL)
[10:58:44.092]                 if (is_error) {
[10:58:44.092]                   sessionInformation <- function() {
[10:58:44.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:44.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:44.092]                       search = base::search(), system = base::Sys.info())
[10:58:44.092]                   }
[10:58:44.092]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:44.092]                     cond$call), session = sessionInformation(), 
[10:58:44.092]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:44.092]                   signalCondition(cond)
[10:58:44.092]                 }
[10:58:44.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:44.092]                 "immediateCondition"))) {
[10:58:44.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:44.092]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:44.092]                   if (TRUE && !signal) {
[10:58:44.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.092]                     {
[10:58:44.092]                       inherits <- base::inherits
[10:58:44.092]                       invokeRestart <- base::invokeRestart
[10:58:44.092]                       is.null <- base::is.null
[10:58:44.092]                       muffled <- FALSE
[10:58:44.092]                       if (inherits(cond, "message")) {
[10:58:44.092]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.092]                         if (muffled) 
[10:58:44.092]                           invokeRestart("muffleMessage")
[10:58:44.092]                       }
[10:58:44.092]                       else if (inherits(cond, "warning")) {
[10:58:44.092]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.092]                         if (muffled) 
[10:58:44.092]                           invokeRestart("muffleWarning")
[10:58:44.092]                       }
[10:58:44.092]                       else if (inherits(cond, "condition")) {
[10:58:44.092]                         if (!is.null(pattern)) {
[10:58:44.092]                           computeRestarts <- base::computeRestarts
[10:58:44.092]                           grepl <- base::grepl
[10:58:44.092]                           restarts <- computeRestarts(cond)
[10:58:44.092]                           for (restart in restarts) {
[10:58:44.092]                             name <- restart$name
[10:58:44.092]                             if (is.null(name)) 
[10:58:44.092]                               next
[10:58:44.092]                             if (!grepl(pattern, name)) 
[10:58:44.092]                               next
[10:58:44.092]                             invokeRestart(restart)
[10:58:44.092]                             muffled <- TRUE
[10:58:44.092]                             break
[10:58:44.092]                           }
[10:58:44.092]                         }
[10:58:44.092]                       }
[10:58:44.092]                       invisible(muffled)
[10:58:44.092]                     }
[10:58:44.092]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.092]                   }
[10:58:44.092]                 }
[10:58:44.092]                 else {
[10:58:44.092]                   if (TRUE) {
[10:58:44.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.092]                     {
[10:58:44.092]                       inherits <- base::inherits
[10:58:44.092]                       invokeRestart <- base::invokeRestart
[10:58:44.092]                       is.null <- base::is.null
[10:58:44.092]                       muffled <- FALSE
[10:58:44.092]                       if (inherits(cond, "message")) {
[10:58:44.092]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.092]                         if (muffled) 
[10:58:44.092]                           invokeRestart("muffleMessage")
[10:58:44.092]                       }
[10:58:44.092]                       else if (inherits(cond, "warning")) {
[10:58:44.092]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.092]                         if (muffled) 
[10:58:44.092]                           invokeRestart("muffleWarning")
[10:58:44.092]                       }
[10:58:44.092]                       else if (inherits(cond, "condition")) {
[10:58:44.092]                         if (!is.null(pattern)) {
[10:58:44.092]                           computeRestarts <- base::computeRestarts
[10:58:44.092]                           grepl <- base::grepl
[10:58:44.092]                           restarts <- computeRestarts(cond)
[10:58:44.092]                           for (restart in restarts) {
[10:58:44.092]                             name <- restart$name
[10:58:44.092]                             if (is.null(name)) 
[10:58:44.092]                               next
[10:58:44.092]                             if (!grepl(pattern, name)) 
[10:58:44.092]                               next
[10:58:44.092]                             invokeRestart(restart)
[10:58:44.092]                             muffled <- TRUE
[10:58:44.092]                             break
[10:58:44.092]                           }
[10:58:44.092]                         }
[10:58:44.092]                       }
[10:58:44.092]                       invisible(muffled)
[10:58:44.092]                     }
[10:58:44.092]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.092]                   }
[10:58:44.092]                 }
[10:58:44.092]             }
[10:58:44.092]         }))
[10:58:44.092]     }, error = function(ex) {
[10:58:44.092]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:44.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.092]                 ...future.rng), started = ...future.startTime, 
[10:58:44.092]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:44.092]             version = "1.8"), class = "FutureResult")
[10:58:44.092]     }, finally = {
[10:58:44.092]         if (!identical(...future.workdir, getwd())) 
[10:58:44.092]             setwd(...future.workdir)
[10:58:44.092]         {
[10:58:44.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:44.092]                 ...future.oldOptions$nwarnings <- NULL
[10:58:44.092]             }
[10:58:44.092]             base::options(...future.oldOptions)
[10:58:44.092]             if (.Platform$OS.type == "windows") {
[10:58:44.092]                 old_names <- names(...future.oldEnvVars)
[10:58:44.092]                 envs <- base::Sys.getenv()
[10:58:44.092]                 names <- names(envs)
[10:58:44.092]                 common <- intersect(names, old_names)
[10:58:44.092]                 added <- setdiff(names, old_names)
[10:58:44.092]                 removed <- setdiff(old_names, names)
[10:58:44.092]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:44.092]                   envs[common]]
[10:58:44.092]                 NAMES <- toupper(changed)
[10:58:44.092]                 args <- list()
[10:58:44.092]                 for (kk in seq_along(NAMES)) {
[10:58:44.092]                   name <- changed[[kk]]
[10:58:44.092]                   NAME <- NAMES[[kk]]
[10:58:44.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.092]                     next
[10:58:44.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.092]                 }
[10:58:44.092]                 NAMES <- toupper(added)
[10:58:44.092]                 for (kk in seq_along(NAMES)) {
[10:58:44.092]                   name <- added[[kk]]
[10:58:44.092]                   NAME <- NAMES[[kk]]
[10:58:44.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.092]                     next
[10:58:44.092]                   args[[name]] <- ""
[10:58:44.092]                 }
[10:58:44.092]                 NAMES <- toupper(removed)
[10:58:44.092]                 for (kk in seq_along(NAMES)) {
[10:58:44.092]                   name <- removed[[kk]]
[10:58:44.092]                   NAME <- NAMES[[kk]]
[10:58:44.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.092]                     next
[10:58:44.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.092]                 }
[10:58:44.092]                 if (length(args) > 0) 
[10:58:44.092]                   base::do.call(base::Sys.setenv, args = args)
[10:58:44.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:44.092]             }
[10:58:44.092]             else {
[10:58:44.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:44.092]             }
[10:58:44.092]             {
[10:58:44.092]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:44.092]                   0L) {
[10:58:44.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:44.092]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:44.092]                   base::options(opts)
[10:58:44.092]                 }
[10:58:44.092]                 {
[10:58:44.092]                   {
[10:58:44.092]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:44.092]                     NULL
[10:58:44.092]                   }
[10:58:44.092]                   options(future.plan = NULL)
[10:58:44.092]                   if (is.na(NA_character_)) 
[10:58:44.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:44.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:44.092]                     .init = FALSE)
[10:58:44.092]                 }
[10:58:44.092]             }
[10:58:44.092]         }
[10:58:44.092]     })
[10:58:44.092]     if (TRUE) {
[10:58:44.092]         base::sink(type = "output", split = FALSE)
[10:58:44.092]         if (TRUE) {
[10:58:44.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:44.092]         }
[10:58:44.092]         else {
[10:58:44.092]             ...future.result["stdout"] <- base::list(NULL)
[10:58:44.092]         }
[10:58:44.092]         base::close(...future.stdout)
[10:58:44.092]         ...future.stdout <- NULL
[10:58:44.092]     }
[10:58:44.092]     ...future.result$conditions <- ...future.conditions
[10:58:44.092]     ...future.result$finished <- base::Sys.time()
[10:58:44.092]     ...future.result
[10:58:44.092] }
[10:58:44.095] assign_globals() ...
[10:58:44.095] List of 7
[10:58:44.095]  $ ...future.FUN            :function (x)  
[10:58:44.095]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:44.095]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:44.095]  $ future.call.arguments    : list()
[10:58:44.095]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.095]  $ ...future.elements_ii    :List of 1
[10:58:44.095]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.095]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:44.095]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.095]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:44.095]  $ ...future.seeds_ii       : NULL
[10:58:44.095]  $ ...future.globals.maxSize: NULL
[10:58:44.095]  - attr(*, "where")=List of 7
[10:58:44.095]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:44.095]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:58:44.095]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:58:44.095]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:44.095]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:44.095]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:44.095]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:44.095]  - attr(*, "resolved")= logi FALSE
[10:58:44.095]  - attr(*, "total_size")= num 18867
[10:58:44.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.095]  - attr(*, "already-done")= logi TRUE
[10:58:44.103] - reassign environment for ‘...future.FUN’
[10:58:44.103] - copied ‘...future.FUN’ to environment
[10:58:44.103] - copied ‘breaks’ to environment
[10:58:44.103] - copied ‘wool’ to environment
[10:58:44.103] - copied ‘future.call.arguments’ to environment
[10:58:44.103] - copied ‘...future.elements_ii’ to environment
[10:58:44.103] - copied ‘...future.seeds_ii’ to environment
[10:58:44.103] - copied ‘...future.globals.maxSize’ to environment
[10:58:44.103] assign_globals() ... done
[10:58:44.103] requestCore(): workers = 2
[10:58:44.106] MulticoreFuture started
[10:58:44.106] - Launch lazy future ... done
[10:58:44.107] run() for ‘MulticoreFuture’ ... done
[10:58:44.107] Created future:
[10:58:44.108] plan(): Setting new future strategy stack:
[10:58:44.108] List of future strategies:
[10:58:44.108] 1. sequential:
[10:58:44.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:44.108]    - tweaked: FALSE
[10:58:44.108]    - call: NULL
[10:58:44.109] plan(): nbrOfWorkers() = 1
[10:58:44.113] plan(): Setting new future strategy stack:
[10:58:44.114] List of future strategies:
[10:58:44.114] 1. multicore:
[10:58:44.114]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:44.114]    - tweaked: FALSE
[10:58:44.114]    - call: plan(strategy)
[10:58:44.117] plan(): nbrOfWorkers() = 2
[10:58:44.108] MulticoreFuture:
[10:58:44.108] Label: ‘future_by-1’
[10:58:44.108] Expression:
[10:58:44.108] {
[10:58:44.108]     do.call(function(...) {
[10:58:44.108]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.108]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.108]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.108]             on.exit(options(oopts), add = TRUE)
[10:58:44.108]         }
[10:58:44.108]         {
[10:58:44.108]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.108]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.108]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.108]             })
[10:58:44.108]         }
[10:58:44.108]     }, args = future.call.arguments)
[10:58:44.108] }
[10:58:44.108] Lazy evaluation: FALSE
[10:58:44.108] Asynchronous evaluation: TRUE
[10:58:44.108] Local evaluation: TRUE
[10:58:44.108] Environment: 0x55974c0df4b8
[10:58:44.108] Capture standard output: TRUE
[10:58:44.108] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:44.108] Globals: 7 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, ...)
[10:58:44.108] Packages: 1 packages (‘stats’)
[10:58:44.108] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:44.108] Resolved: TRUE
[10:58:44.108] Value: <not collected>
[10:58:44.108] Conditions captured: <none>
[10:58:44.108] Early signaling: FALSE
[10:58:44.108] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:44.108] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.119] Chunk #1 of 2 ... DONE
[10:58:44.119] Chunk #2 of 2 ...
[10:58:44.119]  - Finding globals in 'X' for chunk #2 ...
[10:58:44.120] getGlobalsAndPackages() ...
[10:58:44.120] Searching for globals...
[10:58:44.121] 
[10:58:44.121] Searching for globals ... DONE
[10:58:44.121] - globals: [0] <none>
[10:58:44.121] getGlobalsAndPackages() ... DONE
[10:58:44.121]    + additional globals found: [n=0] 
[10:58:44.121]    + additional namespaces needed: [n=0] 
[10:58:44.121]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:44.121]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:44.122]  - seeds: <none>
[10:58:44.122]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.122] getGlobalsAndPackages() ...
[10:58:44.122] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.122] Resolving globals: FALSE
[10:58:44.122] Tweak future expression to call with '...' arguments ...
[10:58:44.123] {
[10:58:44.123]     do.call(function(...) {
[10:58:44.123]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.123]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.123]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.123]             on.exit(options(oopts), add = TRUE)
[10:58:44.123]         }
[10:58:44.123]         {
[10:58:44.123]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.123]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.123]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.123]             })
[10:58:44.123]         }
[10:58:44.123]     }, args = future.call.arguments)
[10:58:44.123] }
[10:58:44.123] Tweak future expression to call with '...' arguments ... DONE
[10:58:44.124] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.124] 
[10:58:44.124] getGlobalsAndPackages() ... DONE
[10:58:44.125] run() for ‘Future’ ...
[10:58:44.125] - state: ‘created’
[10:58:44.125] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:44.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:44.128]   - Field: ‘label’
[10:58:44.128]   - Field: ‘local’
[10:58:44.128]   - Field: ‘owner’
[10:58:44.128]   - Field: ‘envir’
[10:58:44.128]   - Field: ‘workers’
[10:58:44.129]   - Field: ‘packages’
[10:58:44.129]   - Field: ‘gc’
[10:58:44.129]   - Field: ‘job’
[10:58:44.129]   - Field: ‘conditions’
[10:58:44.129]   - Field: ‘expr’
[10:58:44.129]   - Field: ‘uuid’
[10:58:44.129]   - Field: ‘seed’
[10:58:44.130]   - Field: ‘version’
[10:58:44.130]   - Field: ‘result’
[10:58:44.130]   - Field: ‘asynchronous’
[10:58:44.130]   - Field: ‘calls’
[10:58:44.130]   - Field: ‘globals’
[10:58:44.130]   - Field: ‘stdout’
[10:58:44.130]   - Field: ‘earlySignal’
[10:58:44.131]   - Field: ‘lazy’
[10:58:44.131]   - Field: ‘state’
[10:58:44.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:44.131] - Launch lazy future ...
[10:58:44.131] Packages needed by the future expression (n = 1): ‘stats’
[10:58:44.132] Packages needed by future strategies (n = 0): <none>
[10:58:44.132] {
[10:58:44.132]     {
[10:58:44.132]         {
[10:58:44.132]             ...future.startTime <- base::Sys.time()
[10:58:44.132]             {
[10:58:44.132]                 {
[10:58:44.132]                   {
[10:58:44.132]                     {
[10:58:44.132]                       {
[10:58:44.132]                         base::local({
[10:58:44.132]                           has_future <- base::requireNamespace("future", 
[10:58:44.132]                             quietly = TRUE)
[10:58:44.132]                           if (has_future) {
[10:58:44.132]                             ns <- base::getNamespace("future")
[10:58:44.132]                             version <- ns[[".package"]][["version"]]
[10:58:44.132]                             if (is.null(version)) 
[10:58:44.132]                               version <- utils::packageVersion("future")
[10:58:44.132]                           }
[10:58:44.132]                           else {
[10:58:44.132]                             version <- NULL
[10:58:44.132]                           }
[10:58:44.132]                           if (!has_future || version < "1.8.0") {
[10:58:44.132]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:44.132]                               "", base::R.version$version.string), 
[10:58:44.132]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:44.132]                                 base::R.version$platform, 8 * 
[10:58:44.132]                                   base::.Machine$sizeof.pointer), 
[10:58:44.132]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:44.132]                                 "release", "version")], collapse = " "), 
[10:58:44.132]                               hostname = base::Sys.info()[["nodename"]])
[10:58:44.132]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:44.132]                               info)
[10:58:44.132]                             info <- base::paste(info, collapse = "; ")
[10:58:44.132]                             if (!has_future) {
[10:58:44.132]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:44.132]                                 info)
[10:58:44.132]                             }
[10:58:44.132]                             else {
[10:58:44.132]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:44.132]                                 info, version)
[10:58:44.132]                             }
[10:58:44.132]                             base::stop(msg)
[10:58:44.132]                           }
[10:58:44.132]                         })
[10:58:44.132]                       }
[10:58:44.132]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:44.132]                       base::options(mc.cores = 1L)
[10:58:44.132]                     }
[10:58:44.132]                     base::local({
[10:58:44.132]                       for (pkg in "stats") {
[10:58:44.132]                         base::loadNamespace(pkg)
[10:58:44.132]                         base::library(pkg, character.only = TRUE)
[10:58:44.132]                       }
[10:58:44.132]                     })
[10:58:44.132]                   }
[10:58:44.132]                   ...future.strategy.old <- future::plan("list")
[10:58:44.132]                   options(future.plan = NULL)
[10:58:44.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:44.132]                 }
[10:58:44.132]                 ...future.workdir <- getwd()
[10:58:44.132]             }
[10:58:44.132]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:44.132]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:44.132]         }
[10:58:44.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:44.132]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:44.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:44.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:44.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:44.132]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:44.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:44.132]             base::names(...future.oldOptions))
[10:58:44.132]     }
[10:58:44.132]     if (FALSE) {
[10:58:44.132]     }
[10:58:44.132]     else {
[10:58:44.132]         if (TRUE) {
[10:58:44.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:44.132]                 open = "w")
[10:58:44.132]         }
[10:58:44.132]         else {
[10:58:44.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:44.132]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:44.132]         }
[10:58:44.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:44.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:44.132]             base::sink(type = "output", split = FALSE)
[10:58:44.132]             base::close(...future.stdout)
[10:58:44.132]         }, add = TRUE)
[10:58:44.132]     }
[10:58:44.132]     ...future.frame <- base::sys.nframe()
[10:58:44.132]     ...future.conditions <- base::list()
[10:58:44.132]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:44.132]     if (FALSE) {
[10:58:44.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:44.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:44.132]     }
[10:58:44.132]     ...future.result <- base::tryCatch({
[10:58:44.132]         base::withCallingHandlers({
[10:58:44.132]             ...future.value <- base::withVisible(base::local({
[10:58:44.132]                 withCallingHandlers({
[10:58:44.132]                   {
[10:58:44.132]                     do.call(function(...) {
[10:58:44.132]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.132]                       if (!identical(...future.globals.maxSize.org, 
[10:58:44.132]                         ...future.globals.maxSize)) {
[10:58:44.132]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.132]                         on.exit(options(oopts), add = TRUE)
[10:58:44.132]                       }
[10:58:44.132]                       {
[10:58:44.132]                         lapply(seq_along(...future.elements_ii), 
[10:58:44.132]                           FUN = function(jj) {
[10:58:44.132]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.132]                             ...future.FUN(...future.X_jj, ...)
[10:58:44.132]                           })
[10:58:44.132]                       }
[10:58:44.132]                     }, args = future.call.arguments)
[10:58:44.132]                   }
[10:58:44.132]                 }, immediateCondition = function(cond) {
[10:58:44.132]                   save_rds <- function (object, pathname, ...) 
[10:58:44.132]                   {
[10:58:44.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:44.132]                     if (file_test("-f", pathname_tmp)) {
[10:58:44.132]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:44.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.132]                         fi_tmp[["mtime"]])
[10:58:44.132]                     }
[10:58:44.132]                     tryCatch({
[10:58:44.132]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:44.132]                     }, error = function(ex) {
[10:58:44.132]                       msg <- conditionMessage(ex)
[10:58:44.132]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:44.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.132]                         fi_tmp[["mtime"]], msg)
[10:58:44.132]                       ex$message <- msg
[10:58:44.132]                       stop(ex)
[10:58:44.132]                     })
[10:58:44.132]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:44.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:44.132]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:44.132]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.132]                       fi <- file.info(pathname)
[10:58:44.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:44.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:44.132]                         fi[["size"]], fi[["mtime"]])
[10:58:44.132]                       stop(msg)
[10:58:44.132]                     }
[10:58:44.132]                     invisible(pathname)
[10:58:44.132]                   }
[10:58:44.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:44.132]                     rootPath = tempdir()) 
[10:58:44.132]                   {
[10:58:44.132]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:44.132]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:44.132]                       tmpdir = path, fileext = ".rds")
[10:58:44.132]                     save_rds(obj, file)
[10:58:44.132]                   }
[10:58:44.132]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:44.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.132]                   {
[10:58:44.132]                     inherits <- base::inherits
[10:58:44.132]                     invokeRestart <- base::invokeRestart
[10:58:44.132]                     is.null <- base::is.null
[10:58:44.132]                     muffled <- FALSE
[10:58:44.132]                     if (inherits(cond, "message")) {
[10:58:44.132]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:44.132]                       if (muffled) 
[10:58:44.132]                         invokeRestart("muffleMessage")
[10:58:44.132]                     }
[10:58:44.132]                     else if (inherits(cond, "warning")) {
[10:58:44.132]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:44.132]                       if (muffled) 
[10:58:44.132]                         invokeRestart("muffleWarning")
[10:58:44.132]                     }
[10:58:44.132]                     else if (inherits(cond, "condition")) {
[10:58:44.132]                       if (!is.null(pattern)) {
[10:58:44.132]                         computeRestarts <- base::computeRestarts
[10:58:44.132]                         grepl <- base::grepl
[10:58:44.132]                         restarts <- computeRestarts(cond)
[10:58:44.132]                         for (restart in restarts) {
[10:58:44.132]                           name <- restart$name
[10:58:44.132]                           if (is.null(name)) 
[10:58:44.132]                             next
[10:58:44.132]                           if (!grepl(pattern, name)) 
[10:58:44.132]                             next
[10:58:44.132]                           invokeRestart(restart)
[10:58:44.132]                           muffled <- TRUE
[10:58:44.132]                           break
[10:58:44.132]                         }
[10:58:44.132]                       }
[10:58:44.132]                     }
[10:58:44.132]                     invisible(muffled)
[10:58:44.132]                   }
[10:58:44.132]                   muffleCondition(cond)
[10:58:44.132]                 })
[10:58:44.132]             }))
[10:58:44.132]             future::FutureResult(value = ...future.value$value, 
[10:58:44.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.132]                   ...future.rng), globalenv = if (FALSE) 
[10:58:44.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:44.132]                     ...future.globalenv.names))
[10:58:44.132]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:44.132]         }, condition = base::local({
[10:58:44.132]             c <- base::c
[10:58:44.132]             inherits <- base::inherits
[10:58:44.132]             invokeRestart <- base::invokeRestart
[10:58:44.132]             length <- base::length
[10:58:44.132]             list <- base::list
[10:58:44.132]             seq.int <- base::seq.int
[10:58:44.132]             signalCondition <- base::signalCondition
[10:58:44.132]             sys.calls <- base::sys.calls
[10:58:44.132]             `[[` <- base::`[[`
[10:58:44.132]             `+` <- base::`+`
[10:58:44.132]             `<<-` <- base::`<<-`
[10:58:44.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:44.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:44.132]                   3L)]
[10:58:44.132]             }
[10:58:44.132]             function(cond) {
[10:58:44.132]                 is_error <- inherits(cond, "error")
[10:58:44.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:44.132]                   NULL)
[10:58:44.132]                 if (is_error) {
[10:58:44.132]                   sessionInformation <- function() {
[10:58:44.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:44.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:44.132]                       search = base::search(), system = base::Sys.info())
[10:58:44.132]                   }
[10:58:44.132]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:44.132]                     cond$call), session = sessionInformation(), 
[10:58:44.132]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:44.132]                   signalCondition(cond)
[10:58:44.132]                 }
[10:58:44.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:44.132]                 "immediateCondition"))) {
[10:58:44.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:44.132]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:44.132]                   if (TRUE && !signal) {
[10:58:44.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.132]                     {
[10:58:44.132]                       inherits <- base::inherits
[10:58:44.132]                       invokeRestart <- base::invokeRestart
[10:58:44.132]                       is.null <- base::is.null
[10:58:44.132]                       muffled <- FALSE
[10:58:44.132]                       if (inherits(cond, "message")) {
[10:58:44.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.132]                         if (muffled) 
[10:58:44.132]                           invokeRestart("muffleMessage")
[10:58:44.132]                       }
[10:58:44.132]                       else if (inherits(cond, "warning")) {
[10:58:44.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.132]                         if (muffled) 
[10:58:44.132]                           invokeRestart("muffleWarning")
[10:58:44.132]                       }
[10:58:44.132]                       else if (inherits(cond, "condition")) {
[10:58:44.132]                         if (!is.null(pattern)) {
[10:58:44.132]                           computeRestarts <- base::computeRestarts
[10:58:44.132]                           grepl <- base::grepl
[10:58:44.132]                           restarts <- computeRestarts(cond)
[10:58:44.132]                           for (restart in restarts) {
[10:58:44.132]                             name <- restart$name
[10:58:44.132]                             if (is.null(name)) 
[10:58:44.132]                               next
[10:58:44.132]                             if (!grepl(pattern, name)) 
[10:58:44.132]                               next
[10:58:44.132]                             invokeRestart(restart)
[10:58:44.132]                             muffled <- TRUE
[10:58:44.132]                             break
[10:58:44.132]                           }
[10:58:44.132]                         }
[10:58:44.132]                       }
[10:58:44.132]                       invisible(muffled)
[10:58:44.132]                     }
[10:58:44.132]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.132]                   }
[10:58:44.132]                 }
[10:58:44.132]                 else {
[10:58:44.132]                   if (TRUE) {
[10:58:44.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.132]                     {
[10:58:44.132]                       inherits <- base::inherits
[10:58:44.132]                       invokeRestart <- base::invokeRestart
[10:58:44.132]                       is.null <- base::is.null
[10:58:44.132]                       muffled <- FALSE
[10:58:44.132]                       if (inherits(cond, "message")) {
[10:58:44.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.132]                         if (muffled) 
[10:58:44.132]                           invokeRestart("muffleMessage")
[10:58:44.132]                       }
[10:58:44.132]                       else if (inherits(cond, "warning")) {
[10:58:44.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.132]                         if (muffled) 
[10:58:44.132]                           invokeRestart("muffleWarning")
[10:58:44.132]                       }
[10:58:44.132]                       else if (inherits(cond, "condition")) {
[10:58:44.132]                         if (!is.null(pattern)) {
[10:58:44.132]                           computeRestarts <- base::computeRestarts
[10:58:44.132]                           grepl <- base::grepl
[10:58:44.132]                           restarts <- computeRestarts(cond)
[10:58:44.132]                           for (restart in restarts) {
[10:58:44.132]                             name <- restart$name
[10:58:44.132]                             if (is.null(name)) 
[10:58:44.132]                               next
[10:58:44.132]                             if (!grepl(pattern, name)) 
[10:58:44.132]                               next
[10:58:44.132]                             invokeRestart(restart)
[10:58:44.132]                             muffled <- TRUE
[10:58:44.132]                             break
[10:58:44.132]                           }
[10:58:44.132]                         }
[10:58:44.132]                       }
[10:58:44.132]                       invisible(muffled)
[10:58:44.132]                     }
[10:58:44.132]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.132]                   }
[10:58:44.132]                 }
[10:58:44.132]             }
[10:58:44.132]         }))
[10:58:44.132]     }, error = function(ex) {
[10:58:44.132]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:44.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.132]                 ...future.rng), started = ...future.startTime, 
[10:58:44.132]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:44.132]             version = "1.8"), class = "FutureResult")
[10:58:44.132]     }, finally = {
[10:58:44.132]         if (!identical(...future.workdir, getwd())) 
[10:58:44.132]             setwd(...future.workdir)
[10:58:44.132]         {
[10:58:44.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:44.132]                 ...future.oldOptions$nwarnings <- NULL
[10:58:44.132]             }
[10:58:44.132]             base::options(...future.oldOptions)
[10:58:44.132]             if (.Platform$OS.type == "windows") {
[10:58:44.132]                 old_names <- names(...future.oldEnvVars)
[10:58:44.132]                 envs <- base::Sys.getenv()
[10:58:44.132]                 names <- names(envs)
[10:58:44.132]                 common <- intersect(names, old_names)
[10:58:44.132]                 added <- setdiff(names, old_names)
[10:58:44.132]                 removed <- setdiff(old_names, names)
[10:58:44.132]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:44.132]                   envs[common]]
[10:58:44.132]                 NAMES <- toupper(changed)
[10:58:44.132]                 args <- list()
[10:58:44.132]                 for (kk in seq_along(NAMES)) {
[10:58:44.132]                   name <- changed[[kk]]
[10:58:44.132]                   NAME <- NAMES[[kk]]
[10:58:44.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.132]                     next
[10:58:44.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.132]                 }
[10:58:44.132]                 NAMES <- toupper(added)
[10:58:44.132]                 for (kk in seq_along(NAMES)) {
[10:58:44.132]                   name <- added[[kk]]
[10:58:44.132]                   NAME <- NAMES[[kk]]
[10:58:44.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.132]                     next
[10:58:44.132]                   args[[name]] <- ""
[10:58:44.132]                 }
[10:58:44.132]                 NAMES <- toupper(removed)
[10:58:44.132]                 for (kk in seq_along(NAMES)) {
[10:58:44.132]                   name <- removed[[kk]]
[10:58:44.132]                   NAME <- NAMES[[kk]]
[10:58:44.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.132]                     next
[10:58:44.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.132]                 }
[10:58:44.132]                 if (length(args) > 0) 
[10:58:44.132]                   base::do.call(base::Sys.setenv, args = args)
[10:58:44.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:44.132]             }
[10:58:44.132]             else {
[10:58:44.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:44.132]             }
[10:58:44.132]             {
[10:58:44.132]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:44.132]                   0L) {
[10:58:44.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:44.132]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:44.132]                   base::options(opts)
[10:58:44.132]                 }
[10:58:44.132]                 {
[10:58:44.132]                   {
[10:58:44.132]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:44.132]                     NULL
[10:58:44.132]                   }
[10:58:44.132]                   options(future.plan = NULL)
[10:58:44.132]                   if (is.na(NA_character_)) 
[10:58:44.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:44.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:44.132]                     .init = FALSE)
[10:58:44.132]                 }
[10:58:44.132]             }
[10:58:44.132]         }
[10:58:44.132]     })
[10:58:44.132]     if (TRUE) {
[10:58:44.132]         base::sink(type = "output", split = FALSE)
[10:58:44.132]         if (TRUE) {
[10:58:44.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:44.132]         }
[10:58:44.132]         else {
[10:58:44.132]             ...future.result["stdout"] <- base::list(NULL)
[10:58:44.132]         }
[10:58:44.132]         base::close(...future.stdout)
[10:58:44.132]         ...future.stdout <- NULL
[10:58:44.132]     }
[10:58:44.132]     ...future.result$conditions <- ...future.conditions
[10:58:44.132]     ...future.result$finished <- base::Sys.time()
[10:58:44.132]     ...future.result
[10:58:44.132] }
[10:58:44.136] assign_globals() ...
[10:58:44.136] List of 7
[10:58:44.136]  $ ...future.FUN            :function (x)  
[10:58:44.136]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:44.136]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:44.136]  $ future.call.arguments    : list()
[10:58:44.136]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.136]  $ ...future.elements_ii    :List of 2
[10:58:44.136]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.136]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:44.136]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.136]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:44.136]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.136]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:44.136]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.136]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:44.136]  $ ...future.seeds_ii       : NULL
[10:58:44.136]  $ ...future.globals.maxSize: NULL
[10:58:44.136]  - attr(*, "where")=List of 7
[10:58:44.136]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:44.136]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:58:44.136]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:58:44.136]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:44.136]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:44.136]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:44.136]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:44.136]  - attr(*, "resolved")= logi FALSE
[10:58:44.136]  - attr(*, "total_size")= num 18867
[10:58:44.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.136]  - attr(*, "already-done")= logi TRUE
[10:58:44.151] - reassign environment for ‘...future.FUN’
[10:58:44.151] - copied ‘...future.FUN’ to environment
[10:58:44.151] - copied ‘breaks’ to environment
[10:58:44.151] - copied ‘wool’ to environment
[10:58:44.151] - copied ‘future.call.arguments’ to environment
[10:58:44.151] - copied ‘...future.elements_ii’ to environment
[10:58:44.151] - copied ‘...future.seeds_ii’ to environment
[10:58:44.151] - copied ‘...future.globals.maxSize’ to environment
[10:58:44.151] assign_globals() ... done
[10:58:44.152] requestCore(): workers = 2
[10:58:44.154] MulticoreFuture started
[10:58:44.154] - Launch lazy future ... done
[10:58:44.154] run() for ‘MulticoreFuture’ ... done
[10:58:44.155] Created future:
[10:58:44.155] plan(): Setting new future strategy stack:
[10:58:44.155] List of future strategies:
[10:58:44.155] 1. sequential:
[10:58:44.155]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:44.155]    - tweaked: FALSE
[10:58:44.155]    - call: NULL
[10:58:44.156] plan(): nbrOfWorkers() = 1
[10:58:44.162] plan(): Setting new future strategy stack:
[10:58:44.162] List of future strategies:
[10:58:44.162] 1. multicore:
[10:58:44.162]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:44.162]    - tweaked: FALSE
[10:58:44.162]    - call: plan(strategy)
[10:58:44.165] plan(): nbrOfWorkers() = 2
[10:58:44.155] MulticoreFuture:
[10:58:44.155] Label: ‘future_by-2’
[10:58:44.155] Expression:
[10:58:44.155] {
[10:58:44.155]     do.call(function(...) {
[10:58:44.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.155]             on.exit(options(oopts), add = TRUE)
[10:58:44.155]         }
[10:58:44.155]         {
[10:58:44.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.155]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.155]             })
[10:58:44.155]         }
[10:58:44.155]     }, args = future.call.arguments)
[10:58:44.155] }
[10:58:44.155] Lazy evaluation: FALSE
[10:58:44.155] Asynchronous evaluation: TRUE
[10:58:44.155] Local evaluation: TRUE
[10:58:44.155] Environment: 0x55974c0df4b8
[10:58:44.155] Capture standard output: TRUE
[10:58:44.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:44.155] Globals: 7 objects totaling 3.57 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, ...)
[10:58:44.155] Packages: 1 packages (‘stats’)
[10:58:44.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:44.155] Resolved: TRUE
[10:58:44.155] Value: <not collected>
[10:58:44.155] Conditions captured: <none>
[10:58:44.155] Early signaling: FALSE
[10:58:44.155] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:44.155] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.167] Chunk #2 of 2 ... DONE
[10:58:44.167] Launching 2 futures (chunks) ... DONE
[10:58:44.167] Resolving 2 futures (chunks) ...
[10:58:44.167] resolve() on list ...
[10:58:44.167]  recursive: 0
[10:58:44.168]  length: 2
[10:58:44.168] 
[10:58:44.168] Future #1
[10:58:44.168] result() for MulticoreFuture ...
[10:58:44.170] result() for MulticoreFuture ...
[10:58:44.170] result() for MulticoreFuture ... done
[10:58:44.170] result() for MulticoreFuture ... done
[10:58:44.170] result() for MulticoreFuture ...
[10:58:44.170] result() for MulticoreFuture ... done
[10:58:44.170] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:44.171] - nx: 2
[10:58:44.171] - relay: TRUE
[10:58:44.171] - stdout: TRUE
[10:58:44.171] - signal: TRUE
[10:58:44.171] - resignal: FALSE
[10:58:44.171] - force: TRUE
[10:58:44.171] - relayed: [n=2] FALSE, FALSE
[10:58:44.171] - queued futures: [n=2] FALSE, FALSE
[10:58:44.172]  - until=1
[10:58:44.172]  - relaying element #1
[10:58:44.172] result() for MulticoreFuture ...
[10:58:44.172] result() for MulticoreFuture ... done
[10:58:44.172] result() for MulticoreFuture ...
[10:58:44.172] result() for MulticoreFuture ... done
[10:58:44.172] result() for MulticoreFuture ...
[10:58:44.173] result() for MulticoreFuture ... done
[10:58:44.173] result() for MulticoreFuture ...
[10:58:44.173] result() for MulticoreFuture ... done
[10:58:44.173] - relayed: [n=2] TRUE, FALSE
[10:58:44.173] - queued futures: [n=2] TRUE, FALSE
[10:58:44.173] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:44.173]  length: 1 (resolved future 1)
[10:58:44.174] Future #2
[10:58:44.174] result() for MulticoreFuture ...
[10:58:44.175] result() for MulticoreFuture ...
[10:58:44.175] result() for MulticoreFuture ... done
[10:58:44.176] result() for MulticoreFuture ... done
[10:58:44.176] result() for MulticoreFuture ...
[10:58:44.176] result() for MulticoreFuture ... done
[10:58:44.176] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:44.176] - nx: 2
[10:58:44.176] - relay: TRUE
[10:58:44.176] - stdout: TRUE
[10:58:44.176] - signal: TRUE
[10:58:44.177] - resignal: FALSE
[10:58:44.177] - force: TRUE
[10:58:44.177] - relayed: [n=2] TRUE, FALSE
[10:58:44.177] - queued futures: [n=2] TRUE, FALSE
[10:58:44.177]  - until=2
[10:58:44.177]  - relaying element #2
[10:58:44.177] result() for MulticoreFuture ...
[10:58:44.177] result() for MulticoreFuture ... done
[10:58:44.178] result() for MulticoreFuture ...
[10:58:44.178] result() for MulticoreFuture ... done
[10:58:44.178] result() for MulticoreFuture ...
[10:58:44.178] result() for MulticoreFuture ... done
[10:58:44.178] result() for MulticoreFuture ...
[10:58:44.178] result() for MulticoreFuture ... done
[10:58:44.178] - relayed: [n=2] TRUE, TRUE
[10:58:44.178] - queued futures: [n=2] TRUE, TRUE
[10:58:44.179] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:44.179]  length: 0 (resolved future 2)
[10:58:44.179] Relaying remaining futures
[10:58:44.179] signalConditionsASAP(NULL, pos=0) ...
[10:58:44.179] - nx: 2
[10:58:44.179] - relay: TRUE
[10:58:44.181] - stdout: TRUE
[10:58:44.181] - signal: TRUE
[10:58:44.181] - resignal: FALSE
[10:58:44.181] - force: TRUE
[10:58:44.181] - relayed: [n=2] TRUE, TRUE
[10:58:44.182] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:44.182] - relayed: [n=2] TRUE, TRUE
[10:58:44.182] - queued futures: [n=2] TRUE, TRUE
[10:58:44.182] signalConditionsASAP(NULL, pos=0) ... done
[10:58:44.182] resolve() on list ... DONE
[10:58:44.182] result() for MulticoreFuture ...
[10:58:44.182] result() for MulticoreFuture ... done
[10:58:44.183] result() for MulticoreFuture ...
[10:58:44.183] result() for MulticoreFuture ... done
[10:58:44.183] result() for MulticoreFuture ...
[10:58:44.183] result() for MulticoreFuture ... done
[10:58:44.183] result() for MulticoreFuture ...
[10:58:44.183] result() for MulticoreFuture ... done
[10:58:44.184]  - Number of value chunks collected: 2
[10:58:44.184] Resolving 2 futures (chunks) ... DONE
[10:58:44.184] Reducing values from 2 chunks ...
[10:58:44.184]  - Number of values collected after concatenation: 3
[10:58:44.184]  - Number of values expected: 3
[10:58:44.184] Reducing values from 2 chunks ... DONE
[10:58:44.184] future_lapply() ... DONE
[10:58:44.185] future_by_internal() ... DONE
[10:58:44.185] future_by_internal() ...
[10:58:44.186] future_lapply() ...
[10:58:44.188] Number of chunks: 2
[10:58:44.188] getGlobalsAndPackagesXApply() ...
[10:58:44.189]  - future.globals: TRUE
[10:58:44.189] getGlobalsAndPackages() ...
[10:58:44.189] Searching for globals...
[10:58:44.190] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:44.190] Searching for globals ... DONE
[10:58:44.190] Resolving globals: FALSE
[10:58:44.191] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:44.191] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:44.191] - globals: [1] ‘FUN’
[10:58:44.191] 
[10:58:44.191] getGlobalsAndPackages() ... DONE
[10:58:44.191]  - globals found/used: [n=1] ‘FUN’
[10:58:44.192]  - needed namespaces: [n=0] 
[10:58:44.192] Finding globals ... DONE
[10:58:44.192]  - use_args: TRUE
[10:58:44.192]  - Getting '...' globals ...
[10:58:44.192] resolve() on list ...
[10:58:44.192]  recursive: 0
[10:58:44.192]  length: 1
[10:58:44.193]  elements: ‘...’
[10:58:44.193]  length: 0 (resolved future 1)
[10:58:44.193] resolve() on list ... DONE
[10:58:44.193]    - '...' content: [n=0] 
[10:58:44.193] List of 1
[10:58:44.193]  $ ...: list()
[10:58:44.193]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.193]  - attr(*, "where")=List of 1
[10:58:44.193]   ..$ ...:<environment: 0x55974df6bb58> 
[10:58:44.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.193]  - attr(*, "resolved")= logi TRUE
[10:58:44.193]  - attr(*, "total_size")= num NA
[10:58:44.195]  - Getting '...' globals ... DONE
[10:58:44.196] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:44.196] List of 2
[10:58:44.196]  $ ...future.FUN:function (object, ...)  
[10:58:44.196]  $ ...          : list()
[10:58:44.196]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.196]  - attr(*, "where")=List of 2
[10:58:44.196]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:44.196]   ..$ ...          :<environment: 0x55974df6bb58> 
[10:58:44.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.196]  - attr(*, "resolved")= logi FALSE
[10:58:44.196]  - attr(*, "total_size")= num 19278
[10:58:44.198] Packages to be attached in all futures: [n=0] 
[10:58:44.198] getGlobalsAndPackagesXApply() ... DONE
[10:58:44.199] Number of futures (= number of chunks): 2
[10:58:44.199] Launching 2 futures (chunks) ...
[10:58:44.199] Chunk #1 of 2 ...
[10:58:44.199]  - Finding globals in 'X' for chunk #1 ...
[10:58:44.199] getGlobalsAndPackages() ...
[10:58:44.199] Searching for globals...
[10:58:44.199] 
[10:58:44.200] Searching for globals ... DONE
[10:58:44.200] - globals: [0] <none>
[10:58:44.200] getGlobalsAndPackages() ... DONE
[10:58:44.200]    + additional globals found: [n=0] 
[10:58:44.200]    + additional namespaces needed: [n=0] 
[10:58:44.200]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:44.200]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:44.200]  - seeds: <none>
[10:58:44.200]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.200] getGlobalsAndPackages() ...
[10:58:44.200] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.234] Resolving globals: FALSE
[10:58:44.234] Tweak future expression to call with '...' arguments ...
[10:58:44.234] {
[10:58:44.234]     do.call(function(...) {
[10:58:44.234]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.234]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.234]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.234]             on.exit(options(oopts), add = TRUE)
[10:58:44.234]         }
[10:58:44.234]         {
[10:58:44.234]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.234]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.234]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.234]             })
[10:58:44.234]         }
[10:58:44.234]     }, args = future.call.arguments)
[10:58:44.234] }
[10:58:44.235] Tweak future expression to call with '...' arguments ... DONE
[10:58:44.235] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.235] 
[10:58:44.235] getGlobalsAndPackages() ... DONE
[10:58:44.236] run() for ‘Future’ ...
[10:58:44.236] - state: ‘created’
[10:58:44.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:44.237] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:44.238]   - Field: ‘label’
[10:58:44.238]   - Field: ‘local’
[10:58:44.238]   - Field: ‘owner’
[10:58:44.238]   - Field: ‘envir’
[10:58:44.238]   - Field: ‘workers’
[10:58:44.238]   - Field: ‘packages’
[10:58:44.238]   - Field: ‘gc’
[10:58:44.238]   - Field: ‘job’
[10:58:44.238]   - Field: ‘conditions’
[10:58:44.238]   - Field: ‘expr’
[10:58:44.238]   - Field: ‘uuid’
[10:58:44.238]   - Field: ‘seed’
[10:58:44.239]   - Field: ‘version’
[10:58:44.239]   - Field: ‘result’
[10:58:44.239]   - Field: ‘asynchronous’
[10:58:44.239]   - Field: ‘calls’
[10:58:44.239]   - Field: ‘globals’
[10:58:44.239]   - Field: ‘stdout’
[10:58:44.239]   - Field: ‘earlySignal’
[10:58:44.239]   - Field: ‘lazy’
[10:58:44.239]   - Field: ‘state’
[10:58:44.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:44.239] - Launch lazy future ...
[10:58:44.240] Packages needed by the future expression (n = 0): <none>
[10:58:44.240] Packages needed by future strategies (n = 0): <none>
[10:58:44.240] {
[10:58:44.240]     {
[10:58:44.240]         {
[10:58:44.240]             ...future.startTime <- base::Sys.time()
[10:58:44.240]             {
[10:58:44.240]                 {
[10:58:44.240]                   {
[10:58:44.240]                     {
[10:58:44.240]                       base::local({
[10:58:44.240]                         has_future <- base::requireNamespace("future", 
[10:58:44.240]                           quietly = TRUE)
[10:58:44.240]                         if (has_future) {
[10:58:44.240]                           ns <- base::getNamespace("future")
[10:58:44.240]                           version <- ns[[".package"]][["version"]]
[10:58:44.240]                           if (is.null(version)) 
[10:58:44.240]                             version <- utils::packageVersion("future")
[10:58:44.240]                         }
[10:58:44.240]                         else {
[10:58:44.240]                           version <- NULL
[10:58:44.240]                         }
[10:58:44.240]                         if (!has_future || version < "1.8.0") {
[10:58:44.240]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:44.240]                             "", base::R.version$version.string), 
[10:58:44.240]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:44.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:44.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:44.240]                               "release", "version")], collapse = " "), 
[10:58:44.240]                             hostname = base::Sys.info()[["nodename"]])
[10:58:44.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:44.240]                             info)
[10:58:44.240]                           info <- base::paste(info, collapse = "; ")
[10:58:44.240]                           if (!has_future) {
[10:58:44.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:44.240]                               info)
[10:58:44.240]                           }
[10:58:44.240]                           else {
[10:58:44.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:44.240]                               info, version)
[10:58:44.240]                           }
[10:58:44.240]                           base::stop(msg)
[10:58:44.240]                         }
[10:58:44.240]                       })
[10:58:44.240]                     }
[10:58:44.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:44.240]                     base::options(mc.cores = 1L)
[10:58:44.240]                   }
[10:58:44.240]                   ...future.strategy.old <- future::plan("list")
[10:58:44.240]                   options(future.plan = NULL)
[10:58:44.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:44.240]                 }
[10:58:44.240]                 ...future.workdir <- getwd()
[10:58:44.240]             }
[10:58:44.240]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:44.240]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:44.240]         }
[10:58:44.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:44.240]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:44.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:44.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:44.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:44.240]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:44.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:44.240]             base::names(...future.oldOptions))
[10:58:44.240]     }
[10:58:44.240]     if (FALSE) {
[10:58:44.240]     }
[10:58:44.240]     else {
[10:58:44.240]         if (TRUE) {
[10:58:44.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:44.240]                 open = "w")
[10:58:44.240]         }
[10:58:44.240]         else {
[10:58:44.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:44.240]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:44.240]         }
[10:58:44.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:44.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:44.240]             base::sink(type = "output", split = FALSE)
[10:58:44.240]             base::close(...future.stdout)
[10:58:44.240]         }, add = TRUE)
[10:58:44.240]     }
[10:58:44.240]     ...future.frame <- base::sys.nframe()
[10:58:44.240]     ...future.conditions <- base::list()
[10:58:44.240]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:44.240]     if (FALSE) {
[10:58:44.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:44.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:44.240]     }
[10:58:44.240]     ...future.result <- base::tryCatch({
[10:58:44.240]         base::withCallingHandlers({
[10:58:44.240]             ...future.value <- base::withVisible(base::local({
[10:58:44.240]                 withCallingHandlers({
[10:58:44.240]                   {
[10:58:44.240]                     do.call(function(...) {
[10:58:44.240]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.240]                       if (!identical(...future.globals.maxSize.org, 
[10:58:44.240]                         ...future.globals.maxSize)) {
[10:58:44.240]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.240]                         on.exit(options(oopts), add = TRUE)
[10:58:44.240]                       }
[10:58:44.240]                       {
[10:58:44.240]                         lapply(seq_along(...future.elements_ii), 
[10:58:44.240]                           FUN = function(jj) {
[10:58:44.240]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.240]                             ...future.FUN(...future.X_jj, ...)
[10:58:44.240]                           })
[10:58:44.240]                       }
[10:58:44.240]                     }, args = future.call.arguments)
[10:58:44.240]                   }
[10:58:44.240]                 }, immediateCondition = function(cond) {
[10:58:44.240]                   save_rds <- function (object, pathname, ...) 
[10:58:44.240]                   {
[10:58:44.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:44.240]                     if (file_test("-f", pathname_tmp)) {
[10:58:44.240]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:44.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.240]                         fi_tmp[["mtime"]])
[10:58:44.240]                     }
[10:58:44.240]                     tryCatch({
[10:58:44.240]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:44.240]                     }, error = function(ex) {
[10:58:44.240]                       msg <- conditionMessage(ex)
[10:58:44.240]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:44.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.240]                         fi_tmp[["mtime"]], msg)
[10:58:44.240]                       ex$message <- msg
[10:58:44.240]                       stop(ex)
[10:58:44.240]                     })
[10:58:44.240]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:44.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:44.240]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:44.240]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.240]                       fi <- file.info(pathname)
[10:58:44.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:44.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:44.240]                         fi[["size"]], fi[["mtime"]])
[10:58:44.240]                       stop(msg)
[10:58:44.240]                     }
[10:58:44.240]                     invisible(pathname)
[10:58:44.240]                   }
[10:58:44.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:44.240]                     rootPath = tempdir()) 
[10:58:44.240]                   {
[10:58:44.240]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:44.240]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:44.240]                       tmpdir = path, fileext = ".rds")
[10:58:44.240]                     save_rds(obj, file)
[10:58:44.240]                   }
[10:58:44.240]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:44.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.240]                   {
[10:58:44.240]                     inherits <- base::inherits
[10:58:44.240]                     invokeRestart <- base::invokeRestart
[10:58:44.240]                     is.null <- base::is.null
[10:58:44.240]                     muffled <- FALSE
[10:58:44.240]                     if (inherits(cond, "message")) {
[10:58:44.240]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:44.240]                       if (muffled) 
[10:58:44.240]                         invokeRestart("muffleMessage")
[10:58:44.240]                     }
[10:58:44.240]                     else if (inherits(cond, "warning")) {
[10:58:44.240]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:44.240]                       if (muffled) 
[10:58:44.240]                         invokeRestart("muffleWarning")
[10:58:44.240]                     }
[10:58:44.240]                     else if (inherits(cond, "condition")) {
[10:58:44.240]                       if (!is.null(pattern)) {
[10:58:44.240]                         computeRestarts <- base::computeRestarts
[10:58:44.240]                         grepl <- base::grepl
[10:58:44.240]                         restarts <- computeRestarts(cond)
[10:58:44.240]                         for (restart in restarts) {
[10:58:44.240]                           name <- restart$name
[10:58:44.240]                           if (is.null(name)) 
[10:58:44.240]                             next
[10:58:44.240]                           if (!grepl(pattern, name)) 
[10:58:44.240]                             next
[10:58:44.240]                           invokeRestart(restart)
[10:58:44.240]                           muffled <- TRUE
[10:58:44.240]                           break
[10:58:44.240]                         }
[10:58:44.240]                       }
[10:58:44.240]                     }
[10:58:44.240]                     invisible(muffled)
[10:58:44.240]                   }
[10:58:44.240]                   muffleCondition(cond)
[10:58:44.240]                 })
[10:58:44.240]             }))
[10:58:44.240]             future::FutureResult(value = ...future.value$value, 
[10:58:44.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.240]                   ...future.rng), globalenv = if (FALSE) 
[10:58:44.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:44.240]                     ...future.globalenv.names))
[10:58:44.240]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:44.240]         }, condition = base::local({
[10:58:44.240]             c <- base::c
[10:58:44.240]             inherits <- base::inherits
[10:58:44.240]             invokeRestart <- base::invokeRestart
[10:58:44.240]             length <- base::length
[10:58:44.240]             list <- base::list
[10:58:44.240]             seq.int <- base::seq.int
[10:58:44.240]             signalCondition <- base::signalCondition
[10:58:44.240]             sys.calls <- base::sys.calls
[10:58:44.240]             `[[` <- base::`[[`
[10:58:44.240]             `+` <- base::`+`
[10:58:44.240]             `<<-` <- base::`<<-`
[10:58:44.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:44.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:44.240]                   3L)]
[10:58:44.240]             }
[10:58:44.240]             function(cond) {
[10:58:44.240]                 is_error <- inherits(cond, "error")
[10:58:44.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:44.240]                   NULL)
[10:58:44.240]                 if (is_error) {
[10:58:44.240]                   sessionInformation <- function() {
[10:58:44.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:44.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:44.240]                       search = base::search(), system = base::Sys.info())
[10:58:44.240]                   }
[10:58:44.240]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:44.240]                     cond$call), session = sessionInformation(), 
[10:58:44.240]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:44.240]                   signalCondition(cond)
[10:58:44.240]                 }
[10:58:44.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:44.240]                 "immediateCondition"))) {
[10:58:44.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:44.240]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:44.240]                   if (TRUE && !signal) {
[10:58:44.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.240]                     {
[10:58:44.240]                       inherits <- base::inherits
[10:58:44.240]                       invokeRestart <- base::invokeRestart
[10:58:44.240]                       is.null <- base::is.null
[10:58:44.240]                       muffled <- FALSE
[10:58:44.240]                       if (inherits(cond, "message")) {
[10:58:44.240]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.240]                         if (muffled) 
[10:58:44.240]                           invokeRestart("muffleMessage")
[10:58:44.240]                       }
[10:58:44.240]                       else if (inherits(cond, "warning")) {
[10:58:44.240]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.240]                         if (muffled) 
[10:58:44.240]                           invokeRestart("muffleWarning")
[10:58:44.240]                       }
[10:58:44.240]                       else if (inherits(cond, "condition")) {
[10:58:44.240]                         if (!is.null(pattern)) {
[10:58:44.240]                           computeRestarts <- base::computeRestarts
[10:58:44.240]                           grepl <- base::grepl
[10:58:44.240]                           restarts <- computeRestarts(cond)
[10:58:44.240]                           for (restart in restarts) {
[10:58:44.240]                             name <- restart$name
[10:58:44.240]                             if (is.null(name)) 
[10:58:44.240]                               next
[10:58:44.240]                             if (!grepl(pattern, name)) 
[10:58:44.240]                               next
[10:58:44.240]                             invokeRestart(restart)
[10:58:44.240]                             muffled <- TRUE
[10:58:44.240]                             break
[10:58:44.240]                           }
[10:58:44.240]                         }
[10:58:44.240]                       }
[10:58:44.240]                       invisible(muffled)
[10:58:44.240]                     }
[10:58:44.240]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.240]                   }
[10:58:44.240]                 }
[10:58:44.240]                 else {
[10:58:44.240]                   if (TRUE) {
[10:58:44.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.240]                     {
[10:58:44.240]                       inherits <- base::inherits
[10:58:44.240]                       invokeRestart <- base::invokeRestart
[10:58:44.240]                       is.null <- base::is.null
[10:58:44.240]                       muffled <- FALSE
[10:58:44.240]                       if (inherits(cond, "message")) {
[10:58:44.240]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.240]                         if (muffled) 
[10:58:44.240]                           invokeRestart("muffleMessage")
[10:58:44.240]                       }
[10:58:44.240]                       else if (inherits(cond, "warning")) {
[10:58:44.240]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.240]                         if (muffled) 
[10:58:44.240]                           invokeRestart("muffleWarning")
[10:58:44.240]                       }
[10:58:44.240]                       else if (inherits(cond, "condition")) {
[10:58:44.240]                         if (!is.null(pattern)) {
[10:58:44.240]                           computeRestarts <- base::computeRestarts
[10:58:44.240]                           grepl <- base::grepl
[10:58:44.240]                           restarts <- computeRestarts(cond)
[10:58:44.240]                           for (restart in restarts) {
[10:58:44.240]                             name <- restart$name
[10:58:44.240]                             if (is.null(name)) 
[10:58:44.240]                               next
[10:58:44.240]                             if (!grepl(pattern, name)) 
[10:58:44.240]                               next
[10:58:44.240]                             invokeRestart(restart)
[10:58:44.240]                             muffled <- TRUE
[10:58:44.240]                             break
[10:58:44.240]                           }
[10:58:44.240]                         }
[10:58:44.240]                       }
[10:58:44.240]                       invisible(muffled)
[10:58:44.240]                     }
[10:58:44.240]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.240]                   }
[10:58:44.240]                 }
[10:58:44.240]             }
[10:58:44.240]         }))
[10:58:44.240]     }, error = function(ex) {
[10:58:44.240]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:44.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.240]                 ...future.rng), started = ...future.startTime, 
[10:58:44.240]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:44.240]             version = "1.8"), class = "FutureResult")
[10:58:44.240]     }, finally = {
[10:58:44.240]         if (!identical(...future.workdir, getwd())) 
[10:58:44.240]             setwd(...future.workdir)
[10:58:44.240]         {
[10:58:44.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:44.240]                 ...future.oldOptions$nwarnings <- NULL
[10:58:44.240]             }
[10:58:44.240]             base::options(...future.oldOptions)
[10:58:44.240]             if (.Platform$OS.type == "windows") {
[10:58:44.240]                 old_names <- names(...future.oldEnvVars)
[10:58:44.240]                 envs <- base::Sys.getenv()
[10:58:44.240]                 names <- names(envs)
[10:58:44.240]                 common <- intersect(names, old_names)
[10:58:44.240]                 added <- setdiff(names, old_names)
[10:58:44.240]                 removed <- setdiff(old_names, names)
[10:58:44.240]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:44.240]                   envs[common]]
[10:58:44.240]                 NAMES <- toupper(changed)
[10:58:44.240]                 args <- list()
[10:58:44.240]                 for (kk in seq_along(NAMES)) {
[10:58:44.240]                   name <- changed[[kk]]
[10:58:44.240]                   NAME <- NAMES[[kk]]
[10:58:44.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.240]                     next
[10:58:44.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.240]                 }
[10:58:44.240]                 NAMES <- toupper(added)
[10:58:44.240]                 for (kk in seq_along(NAMES)) {
[10:58:44.240]                   name <- added[[kk]]
[10:58:44.240]                   NAME <- NAMES[[kk]]
[10:58:44.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.240]                     next
[10:58:44.240]                   args[[name]] <- ""
[10:58:44.240]                 }
[10:58:44.240]                 NAMES <- toupper(removed)
[10:58:44.240]                 for (kk in seq_along(NAMES)) {
[10:58:44.240]                   name <- removed[[kk]]
[10:58:44.240]                   NAME <- NAMES[[kk]]
[10:58:44.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.240]                     next
[10:58:44.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.240]                 }
[10:58:44.240]                 if (length(args) > 0) 
[10:58:44.240]                   base::do.call(base::Sys.setenv, args = args)
[10:58:44.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:44.240]             }
[10:58:44.240]             else {
[10:58:44.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:44.240]             }
[10:58:44.240]             {
[10:58:44.240]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:44.240]                   0L) {
[10:58:44.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:44.240]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:44.240]                   base::options(opts)
[10:58:44.240]                 }
[10:58:44.240]                 {
[10:58:44.240]                   {
[10:58:44.240]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:44.240]                     NULL
[10:58:44.240]                   }
[10:58:44.240]                   options(future.plan = NULL)
[10:58:44.240]                   if (is.na(NA_character_)) 
[10:58:44.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:44.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:44.240]                     .init = FALSE)
[10:58:44.240]                 }
[10:58:44.240]             }
[10:58:44.240]         }
[10:58:44.240]     })
[10:58:44.240]     if (TRUE) {
[10:58:44.240]         base::sink(type = "output", split = FALSE)
[10:58:44.240]         if (TRUE) {
[10:58:44.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:44.240]         }
[10:58:44.240]         else {
[10:58:44.240]             ...future.result["stdout"] <- base::list(NULL)
[10:58:44.240]         }
[10:58:44.240]         base::close(...future.stdout)
[10:58:44.240]         ...future.stdout <- NULL
[10:58:44.240]     }
[10:58:44.240]     ...future.result$conditions <- ...future.conditions
[10:58:44.240]     ...future.result$finished <- base::Sys.time()
[10:58:44.240]     ...future.result
[10:58:44.240] }
[10:58:44.242] assign_globals() ...
[10:58:44.242] List of 5
[10:58:44.242]  $ ...future.FUN            :function (object, ...)  
[10:58:44.242]  $ future.call.arguments    : list()
[10:58:44.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.242]  $ ...future.elements_ii    :List of 1
[10:58:44.242]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.242]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:44.242]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.242]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:44.242]  $ ...future.seeds_ii       : NULL
[10:58:44.242]  $ ...future.globals.maxSize: NULL
[10:58:44.242]  - attr(*, "where")=List of 5
[10:58:44.242]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:44.242]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:44.242]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:44.242]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:44.242]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:44.242]  - attr(*, "resolved")= logi FALSE
[10:58:44.242]  - attr(*, "total_size")= num 19278
[10:58:44.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.242]  - attr(*, "already-done")= logi TRUE
[10:58:44.248] - copied ‘...future.FUN’ to environment
[10:58:44.248] - copied ‘future.call.arguments’ to environment
[10:58:44.248] - copied ‘...future.elements_ii’ to environment
[10:58:44.248] - copied ‘...future.seeds_ii’ to environment
[10:58:44.248] - copied ‘...future.globals.maxSize’ to environment
[10:58:44.248] assign_globals() ... done
[10:58:44.248] requestCore(): workers = 2
[10:58:44.251] MulticoreFuture started
[10:58:44.251] - Launch lazy future ... done
[10:58:44.251] run() for ‘MulticoreFuture’ ... done
[10:58:44.251] Created future:
[10:58:44.252] plan(): Setting new future strategy stack:
[10:58:44.252] List of future strategies:
[10:58:44.252] 1. sequential:
[10:58:44.252]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:44.252]    - tweaked: FALSE
[10:58:44.252]    - call: NULL
[10:58:44.253] plan(): nbrOfWorkers() = 1
[10:58:44.256] plan(): Setting new future strategy stack:
[10:58:44.256] List of future strategies:
[10:58:44.256] 1. multicore:
[10:58:44.256]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:44.256]    - tweaked: FALSE
[10:58:44.256]    - call: plan(strategy)
[10:58:44.260] plan(): nbrOfWorkers() = 2
[10:58:44.252] MulticoreFuture:
[10:58:44.252] Label: ‘future_by-1’
[10:58:44.252] Expression:
[10:58:44.252] {
[10:58:44.252]     do.call(function(...) {
[10:58:44.252]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.252]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.252]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.252]             on.exit(options(oopts), add = TRUE)
[10:58:44.252]         }
[10:58:44.252]         {
[10:58:44.252]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.252]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.252]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.252]             })
[10:58:44.252]         }
[10:58:44.252]     }, args = future.call.arguments)
[10:58:44.252] }
[10:58:44.252] Lazy evaluation: FALSE
[10:58:44.252] Asynchronous evaluation: TRUE
[10:58:44.252] Local evaluation: TRUE
[10:58:44.252] Environment: 0x55974dbdb890
[10:58:44.252] Capture standard output: TRUE
[10:58:44.252] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:44.252] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:44.252] Packages: <none>
[10:58:44.252] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:44.252] Resolved: TRUE
[10:58:44.252] Value: <not collected>
[10:58:44.252] Conditions captured: <none>
[10:58:44.252] Early signaling: FALSE
[10:58:44.252] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:44.252] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.261] Chunk #1 of 2 ... DONE
[10:58:44.261] Chunk #2 of 2 ...
[10:58:44.261]  - Finding globals in 'X' for chunk #2 ...
[10:58:44.261] getGlobalsAndPackages() ...
[10:58:44.261] Searching for globals...
[10:58:44.262] 
[10:58:44.262] Searching for globals ... DONE
[10:58:44.262] - globals: [0] <none>
[10:58:44.262] getGlobalsAndPackages() ... DONE
[10:58:44.263]    + additional globals found: [n=0] 
[10:58:44.263]    + additional namespaces needed: [n=0] 
[10:58:44.263]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:44.263]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:44.263]  - seeds: <none>
[10:58:44.263]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.263] getGlobalsAndPackages() ...
[10:58:44.263] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.264] Resolving globals: FALSE
[10:58:44.264] Tweak future expression to call with '...' arguments ...
[10:58:44.264] {
[10:58:44.264]     do.call(function(...) {
[10:58:44.264]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.264]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.264]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.264]             on.exit(options(oopts), add = TRUE)
[10:58:44.264]         }
[10:58:44.264]         {
[10:58:44.264]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.264]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.264]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.264]             })
[10:58:44.264]         }
[10:58:44.264]     }, args = future.call.arguments)
[10:58:44.264] }
[10:58:44.264] Tweak future expression to call with '...' arguments ... DONE
[10:58:44.265] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.265] 
[10:58:44.265] getGlobalsAndPackages() ... DONE
[10:58:44.266] run() for ‘Future’ ...
[10:58:44.266] - state: ‘created’
[10:58:44.266] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:44.269] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.269] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:44.269]   - Field: ‘label’
[10:58:44.269]   - Field: ‘local’
[10:58:44.269]   - Field: ‘owner’
[10:58:44.269]   - Field: ‘envir’
[10:58:44.270]   - Field: ‘workers’
[10:58:44.270]   - Field: ‘packages’
[10:58:44.270]   - Field: ‘gc’
[10:58:44.270]   - Field: ‘job’
[10:58:44.270]   - Field: ‘conditions’
[10:58:44.270]   - Field: ‘expr’
[10:58:44.271]   - Field: ‘uuid’
[10:58:44.271]   - Field: ‘seed’
[10:58:44.271]   - Field: ‘version’
[10:58:44.271]   - Field: ‘result’
[10:58:44.271]   - Field: ‘asynchronous’
[10:58:44.271]   - Field: ‘calls’
[10:58:44.272]   - Field: ‘globals’
[10:58:44.272]   - Field: ‘stdout’
[10:58:44.272]   - Field: ‘earlySignal’
[10:58:44.272]   - Field: ‘lazy’
[10:58:44.272]   - Field: ‘state’
[10:58:44.273] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:44.273] - Launch lazy future ...
[10:58:44.273] Packages needed by the future expression (n = 0): <none>
[10:58:44.273] Packages needed by future strategies (n = 0): <none>
[10:58:44.274] {
[10:58:44.274]     {
[10:58:44.274]         {
[10:58:44.274]             ...future.startTime <- base::Sys.time()
[10:58:44.274]             {
[10:58:44.274]                 {
[10:58:44.274]                   {
[10:58:44.274]                     {
[10:58:44.274]                       base::local({
[10:58:44.274]                         has_future <- base::requireNamespace("future", 
[10:58:44.274]                           quietly = TRUE)
[10:58:44.274]                         if (has_future) {
[10:58:44.274]                           ns <- base::getNamespace("future")
[10:58:44.274]                           version <- ns[[".package"]][["version"]]
[10:58:44.274]                           if (is.null(version)) 
[10:58:44.274]                             version <- utils::packageVersion("future")
[10:58:44.274]                         }
[10:58:44.274]                         else {
[10:58:44.274]                           version <- NULL
[10:58:44.274]                         }
[10:58:44.274]                         if (!has_future || version < "1.8.0") {
[10:58:44.274]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:44.274]                             "", base::R.version$version.string), 
[10:58:44.274]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:44.274]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:44.274]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:44.274]                               "release", "version")], collapse = " "), 
[10:58:44.274]                             hostname = base::Sys.info()[["nodename"]])
[10:58:44.274]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:44.274]                             info)
[10:58:44.274]                           info <- base::paste(info, collapse = "; ")
[10:58:44.274]                           if (!has_future) {
[10:58:44.274]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:44.274]                               info)
[10:58:44.274]                           }
[10:58:44.274]                           else {
[10:58:44.274]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:44.274]                               info, version)
[10:58:44.274]                           }
[10:58:44.274]                           base::stop(msg)
[10:58:44.274]                         }
[10:58:44.274]                       })
[10:58:44.274]                     }
[10:58:44.274]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:44.274]                     base::options(mc.cores = 1L)
[10:58:44.274]                   }
[10:58:44.274]                   ...future.strategy.old <- future::plan("list")
[10:58:44.274]                   options(future.plan = NULL)
[10:58:44.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:44.274]                 }
[10:58:44.274]                 ...future.workdir <- getwd()
[10:58:44.274]             }
[10:58:44.274]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:44.274]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:44.274]         }
[10:58:44.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:44.274]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:44.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:44.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:44.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:44.274]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:44.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:44.274]             base::names(...future.oldOptions))
[10:58:44.274]     }
[10:58:44.274]     if (FALSE) {
[10:58:44.274]     }
[10:58:44.274]     else {
[10:58:44.274]         if (TRUE) {
[10:58:44.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:44.274]                 open = "w")
[10:58:44.274]         }
[10:58:44.274]         else {
[10:58:44.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:44.274]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:44.274]         }
[10:58:44.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:44.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:44.274]             base::sink(type = "output", split = FALSE)
[10:58:44.274]             base::close(...future.stdout)
[10:58:44.274]         }, add = TRUE)
[10:58:44.274]     }
[10:58:44.274]     ...future.frame <- base::sys.nframe()
[10:58:44.274]     ...future.conditions <- base::list()
[10:58:44.274]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:44.274]     if (FALSE) {
[10:58:44.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:44.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:44.274]     }
[10:58:44.274]     ...future.result <- base::tryCatch({
[10:58:44.274]         base::withCallingHandlers({
[10:58:44.274]             ...future.value <- base::withVisible(base::local({
[10:58:44.274]                 withCallingHandlers({
[10:58:44.274]                   {
[10:58:44.274]                     do.call(function(...) {
[10:58:44.274]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.274]                       if (!identical(...future.globals.maxSize.org, 
[10:58:44.274]                         ...future.globals.maxSize)) {
[10:58:44.274]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.274]                         on.exit(options(oopts), add = TRUE)
[10:58:44.274]                       }
[10:58:44.274]                       {
[10:58:44.274]                         lapply(seq_along(...future.elements_ii), 
[10:58:44.274]                           FUN = function(jj) {
[10:58:44.274]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.274]                             ...future.FUN(...future.X_jj, ...)
[10:58:44.274]                           })
[10:58:44.274]                       }
[10:58:44.274]                     }, args = future.call.arguments)
[10:58:44.274]                   }
[10:58:44.274]                 }, immediateCondition = function(cond) {
[10:58:44.274]                   save_rds <- function (object, pathname, ...) 
[10:58:44.274]                   {
[10:58:44.274]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:44.274]                     if (file_test("-f", pathname_tmp)) {
[10:58:44.274]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.274]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:44.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.274]                         fi_tmp[["mtime"]])
[10:58:44.274]                     }
[10:58:44.274]                     tryCatch({
[10:58:44.274]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:44.274]                     }, error = function(ex) {
[10:58:44.274]                       msg <- conditionMessage(ex)
[10:58:44.274]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.274]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:44.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.274]                         fi_tmp[["mtime"]], msg)
[10:58:44.274]                       ex$message <- msg
[10:58:44.274]                       stop(ex)
[10:58:44.274]                     })
[10:58:44.274]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:44.274]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:44.274]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:44.274]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.274]                       fi <- file.info(pathname)
[10:58:44.274]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:44.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.274]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:44.274]                         fi[["size"]], fi[["mtime"]])
[10:58:44.274]                       stop(msg)
[10:58:44.274]                     }
[10:58:44.274]                     invisible(pathname)
[10:58:44.274]                   }
[10:58:44.274]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:44.274]                     rootPath = tempdir()) 
[10:58:44.274]                   {
[10:58:44.274]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:44.274]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:44.274]                       tmpdir = path, fileext = ".rds")
[10:58:44.274]                     save_rds(obj, file)
[10:58:44.274]                   }
[10:58:44.274]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:44.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.274]                   {
[10:58:44.274]                     inherits <- base::inherits
[10:58:44.274]                     invokeRestart <- base::invokeRestart
[10:58:44.274]                     is.null <- base::is.null
[10:58:44.274]                     muffled <- FALSE
[10:58:44.274]                     if (inherits(cond, "message")) {
[10:58:44.274]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:44.274]                       if (muffled) 
[10:58:44.274]                         invokeRestart("muffleMessage")
[10:58:44.274]                     }
[10:58:44.274]                     else if (inherits(cond, "warning")) {
[10:58:44.274]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:44.274]                       if (muffled) 
[10:58:44.274]                         invokeRestart("muffleWarning")
[10:58:44.274]                     }
[10:58:44.274]                     else if (inherits(cond, "condition")) {
[10:58:44.274]                       if (!is.null(pattern)) {
[10:58:44.274]                         computeRestarts <- base::computeRestarts
[10:58:44.274]                         grepl <- base::grepl
[10:58:44.274]                         restarts <- computeRestarts(cond)
[10:58:44.274]                         for (restart in restarts) {
[10:58:44.274]                           name <- restart$name
[10:58:44.274]                           if (is.null(name)) 
[10:58:44.274]                             next
[10:58:44.274]                           if (!grepl(pattern, name)) 
[10:58:44.274]                             next
[10:58:44.274]                           invokeRestart(restart)
[10:58:44.274]                           muffled <- TRUE
[10:58:44.274]                           break
[10:58:44.274]                         }
[10:58:44.274]                       }
[10:58:44.274]                     }
[10:58:44.274]                     invisible(muffled)
[10:58:44.274]                   }
[10:58:44.274]                   muffleCondition(cond)
[10:58:44.274]                 })
[10:58:44.274]             }))
[10:58:44.274]             future::FutureResult(value = ...future.value$value, 
[10:58:44.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.274]                   ...future.rng), globalenv = if (FALSE) 
[10:58:44.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:44.274]                     ...future.globalenv.names))
[10:58:44.274]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:44.274]         }, condition = base::local({
[10:58:44.274]             c <- base::c
[10:58:44.274]             inherits <- base::inherits
[10:58:44.274]             invokeRestart <- base::invokeRestart
[10:58:44.274]             length <- base::length
[10:58:44.274]             list <- base::list
[10:58:44.274]             seq.int <- base::seq.int
[10:58:44.274]             signalCondition <- base::signalCondition
[10:58:44.274]             sys.calls <- base::sys.calls
[10:58:44.274]             `[[` <- base::`[[`
[10:58:44.274]             `+` <- base::`+`
[10:58:44.274]             `<<-` <- base::`<<-`
[10:58:44.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:44.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:44.274]                   3L)]
[10:58:44.274]             }
[10:58:44.274]             function(cond) {
[10:58:44.274]                 is_error <- inherits(cond, "error")
[10:58:44.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:44.274]                   NULL)
[10:58:44.274]                 if (is_error) {
[10:58:44.274]                   sessionInformation <- function() {
[10:58:44.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:44.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:44.274]                       search = base::search(), system = base::Sys.info())
[10:58:44.274]                   }
[10:58:44.274]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:44.274]                     cond$call), session = sessionInformation(), 
[10:58:44.274]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:44.274]                   signalCondition(cond)
[10:58:44.274]                 }
[10:58:44.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:44.274]                 "immediateCondition"))) {
[10:58:44.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:44.274]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:44.274]                   if (TRUE && !signal) {
[10:58:44.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.274]                     {
[10:58:44.274]                       inherits <- base::inherits
[10:58:44.274]                       invokeRestart <- base::invokeRestart
[10:58:44.274]                       is.null <- base::is.null
[10:58:44.274]                       muffled <- FALSE
[10:58:44.274]                       if (inherits(cond, "message")) {
[10:58:44.274]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.274]                         if (muffled) 
[10:58:44.274]                           invokeRestart("muffleMessage")
[10:58:44.274]                       }
[10:58:44.274]                       else if (inherits(cond, "warning")) {
[10:58:44.274]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.274]                         if (muffled) 
[10:58:44.274]                           invokeRestart("muffleWarning")
[10:58:44.274]                       }
[10:58:44.274]                       else if (inherits(cond, "condition")) {
[10:58:44.274]                         if (!is.null(pattern)) {
[10:58:44.274]                           computeRestarts <- base::computeRestarts
[10:58:44.274]                           grepl <- base::grepl
[10:58:44.274]                           restarts <- computeRestarts(cond)
[10:58:44.274]                           for (restart in restarts) {
[10:58:44.274]                             name <- restart$name
[10:58:44.274]                             if (is.null(name)) 
[10:58:44.274]                               next
[10:58:44.274]                             if (!grepl(pattern, name)) 
[10:58:44.274]                               next
[10:58:44.274]                             invokeRestart(restart)
[10:58:44.274]                             muffled <- TRUE
[10:58:44.274]                             break
[10:58:44.274]                           }
[10:58:44.274]                         }
[10:58:44.274]                       }
[10:58:44.274]                       invisible(muffled)
[10:58:44.274]                     }
[10:58:44.274]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.274]                   }
[10:58:44.274]                 }
[10:58:44.274]                 else {
[10:58:44.274]                   if (TRUE) {
[10:58:44.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.274]                     {
[10:58:44.274]                       inherits <- base::inherits
[10:58:44.274]                       invokeRestart <- base::invokeRestart
[10:58:44.274]                       is.null <- base::is.null
[10:58:44.274]                       muffled <- FALSE
[10:58:44.274]                       if (inherits(cond, "message")) {
[10:58:44.274]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.274]                         if (muffled) 
[10:58:44.274]                           invokeRestart("muffleMessage")
[10:58:44.274]                       }
[10:58:44.274]                       else if (inherits(cond, "warning")) {
[10:58:44.274]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.274]                         if (muffled) 
[10:58:44.274]                           invokeRestart("muffleWarning")
[10:58:44.274]                       }
[10:58:44.274]                       else if (inherits(cond, "condition")) {
[10:58:44.274]                         if (!is.null(pattern)) {
[10:58:44.274]                           computeRestarts <- base::computeRestarts
[10:58:44.274]                           grepl <- base::grepl
[10:58:44.274]                           restarts <- computeRestarts(cond)
[10:58:44.274]                           for (restart in restarts) {
[10:58:44.274]                             name <- restart$name
[10:58:44.274]                             if (is.null(name)) 
[10:58:44.274]                               next
[10:58:44.274]                             if (!grepl(pattern, name)) 
[10:58:44.274]                               next
[10:58:44.274]                             invokeRestart(restart)
[10:58:44.274]                             muffled <- TRUE
[10:58:44.274]                             break
[10:58:44.274]                           }
[10:58:44.274]                         }
[10:58:44.274]                       }
[10:58:44.274]                       invisible(muffled)
[10:58:44.274]                     }
[10:58:44.274]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.274]                   }
[10:58:44.274]                 }
[10:58:44.274]             }
[10:58:44.274]         }))
[10:58:44.274]     }, error = function(ex) {
[10:58:44.274]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:44.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.274]                 ...future.rng), started = ...future.startTime, 
[10:58:44.274]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:44.274]             version = "1.8"), class = "FutureResult")
[10:58:44.274]     }, finally = {
[10:58:44.274]         if (!identical(...future.workdir, getwd())) 
[10:58:44.274]             setwd(...future.workdir)
[10:58:44.274]         {
[10:58:44.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:44.274]                 ...future.oldOptions$nwarnings <- NULL
[10:58:44.274]             }
[10:58:44.274]             base::options(...future.oldOptions)
[10:58:44.274]             if (.Platform$OS.type == "windows") {
[10:58:44.274]                 old_names <- names(...future.oldEnvVars)
[10:58:44.274]                 envs <- base::Sys.getenv()
[10:58:44.274]                 names <- names(envs)
[10:58:44.274]                 common <- intersect(names, old_names)
[10:58:44.274]                 added <- setdiff(names, old_names)
[10:58:44.274]                 removed <- setdiff(old_names, names)
[10:58:44.274]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:44.274]                   envs[common]]
[10:58:44.274]                 NAMES <- toupper(changed)
[10:58:44.274]                 args <- list()
[10:58:44.274]                 for (kk in seq_along(NAMES)) {
[10:58:44.274]                   name <- changed[[kk]]
[10:58:44.274]                   NAME <- NAMES[[kk]]
[10:58:44.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.274]                     next
[10:58:44.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.274]                 }
[10:58:44.274]                 NAMES <- toupper(added)
[10:58:44.274]                 for (kk in seq_along(NAMES)) {
[10:58:44.274]                   name <- added[[kk]]
[10:58:44.274]                   NAME <- NAMES[[kk]]
[10:58:44.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.274]                     next
[10:58:44.274]                   args[[name]] <- ""
[10:58:44.274]                 }
[10:58:44.274]                 NAMES <- toupper(removed)
[10:58:44.274]                 for (kk in seq_along(NAMES)) {
[10:58:44.274]                   name <- removed[[kk]]
[10:58:44.274]                   NAME <- NAMES[[kk]]
[10:58:44.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.274]                     next
[10:58:44.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.274]                 }
[10:58:44.274]                 if (length(args) > 0) 
[10:58:44.274]                   base::do.call(base::Sys.setenv, args = args)
[10:58:44.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:44.274]             }
[10:58:44.274]             else {
[10:58:44.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:44.274]             }
[10:58:44.274]             {
[10:58:44.274]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:44.274]                   0L) {
[10:58:44.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:44.274]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:44.274]                   base::options(opts)
[10:58:44.274]                 }
[10:58:44.274]                 {
[10:58:44.274]                   {
[10:58:44.274]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:44.274]                     NULL
[10:58:44.274]                   }
[10:58:44.274]                   options(future.plan = NULL)
[10:58:44.274]                   if (is.na(NA_character_)) 
[10:58:44.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:44.274]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:44.274]                     .init = FALSE)
[10:58:44.274]                 }
[10:58:44.274]             }
[10:58:44.274]         }
[10:58:44.274]     })
[10:58:44.274]     if (TRUE) {
[10:58:44.274]         base::sink(type = "output", split = FALSE)
[10:58:44.274]         if (TRUE) {
[10:58:44.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:44.274]         }
[10:58:44.274]         else {
[10:58:44.274]             ...future.result["stdout"] <- base::list(NULL)
[10:58:44.274]         }
[10:58:44.274]         base::close(...future.stdout)
[10:58:44.274]         ...future.stdout <- NULL
[10:58:44.274]     }
[10:58:44.274]     ...future.result$conditions <- ...future.conditions
[10:58:44.274]     ...future.result$finished <- base::Sys.time()
[10:58:44.274]     ...future.result
[10:58:44.274] }
[10:58:44.278] assign_globals() ...
[10:58:44.278] List of 5
[10:58:44.278]  $ ...future.FUN            :function (object, ...)  
[10:58:44.278]  $ future.call.arguments    : list()
[10:58:44.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.278]  $ ...future.elements_ii    :List of 2
[10:58:44.278]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.278]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:44.278]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.278]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:44.278]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.278]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:44.278]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.278]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:44.278]  $ ...future.seeds_ii       : NULL
[10:58:44.278]  $ ...future.globals.maxSize: NULL
[10:58:44.278]  - attr(*, "where")=List of 5
[10:58:44.278]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:44.278]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:44.278]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:44.278]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:44.278]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:44.278]  - attr(*, "resolved")= logi FALSE
[10:58:44.278]  - attr(*, "total_size")= num 19278
[10:58:44.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.278]  - attr(*, "already-done")= logi TRUE
[10:58:44.288] - copied ‘...future.FUN’ to environment
[10:58:44.289] - copied ‘future.call.arguments’ to environment
[10:58:44.289] - copied ‘...future.elements_ii’ to environment
[10:58:44.289] - copied ‘...future.seeds_ii’ to environment
[10:58:44.289] - copied ‘...future.globals.maxSize’ to environment
[10:58:44.289] assign_globals() ... done
[10:58:44.289] requestCore(): workers = 2
[10:58:44.291] MulticoreFuture started
[10:58:44.292] - Launch lazy future ... done
[10:58:44.292] run() for ‘MulticoreFuture’ ... done
[10:58:44.292] Created future:
[10:58:44.293] plan(): Setting new future strategy stack:
[10:58:44.293] List of future strategies:
[10:58:44.293] 1. sequential:
[10:58:44.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:44.293]    - tweaked: FALSE
[10:58:44.293]    - call: NULL
[10:58:44.294] plan(): nbrOfWorkers() = 1
[10:58:44.298] plan(): Setting new future strategy stack:
[10:58:44.298] List of future strategies:
[10:58:44.298] 1. multicore:
[10:58:44.298]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:44.298]    - tweaked: FALSE
[10:58:44.298]    - call: plan(strategy)
[10:58:44.301] plan(): nbrOfWorkers() = 2
[10:58:44.293] MulticoreFuture:
[10:58:44.293] Label: ‘future_by-2’
[10:58:44.293] Expression:
[10:58:44.293] {
[10:58:44.293]     do.call(function(...) {
[10:58:44.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.293]             on.exit(options(oopts), add = TRUE)
[10:58:44.293]         }
[10:58:44.293]         {
[10:58:44.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.293]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.293]             })
[10:58:44.293]         }
[10:58:44.293]     }, args = future.call.arguments)
[10:58:44.293] }
[10:58:44.293] Lazy evaluation: FALSE
[10:58:44.293] Asynchronous evaluation: TRUE
[10:58:44.293] Local evaluation: TRUE
[10:58:44.293] Environment: 0x55974dbdb890
[10:58:44.293] Capture standard output: TRUE
[10:58:44.293] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:44.293] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:44.293] Packages: <none>
[10:58:44.293] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:44.293] Resolved: TRUE
[10:58:44.293] Value: <not collected>
[10:58:44.293] Conditions captured: <none>
[10:58:44.293] Early signaling: FALSE
[10:58:44.293] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:44.293] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.302] Chunk #2 of 2 ... DONE
[10:58:44.302] Launching 2 futures (chunks) ... DONE
[10:58:44.302] Resolving 2 futures (chunks) ...
[10:58:44.302] resolve() on list ...
[10:58:44.302]  recursive: 0
[10:58:44.302]  length: 2
[10:58:44.302] 
[10:58:44.303] Future #1
[10:58:44.303] result() for MulticoreFuture ...
[10:58:44.304] result() for MulticoreFuture ...
[10:58:44.304] result() for MulticoreFuture ... done
[10:58:44.304] result() for MulticoreFuture ... done
[10:58:44.304] result() for MulticoreFuture ...
[10:58:44.304] result() for MulticoreFuture ... done
[10:58:44.305] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:44.305] - nx: 2
[10:58:44.305] - relay: TRUE
[10:58:44.305] - stdout: TRUE
[10:58:44.305] - signal: TRUE
[10:58:44.305] - resignal: FALSE
[10:58:44.305] - force: TRUE
[10:58:44.305] - relayed: [n=2] FALSE, FALSE
[10:58:44.305] - queued futures: [n=2] FALSE, FALSE
[10:58:44.306]  - until=1
[10:58:44.306]  - relaying element #1
[10:58:44.306] result() for MulticoreFuture ...
[10:58:44.306] result() for MulticoreFuture ... done
[10:58:44.306] result() for MulticoreFuture ...
[10:58:44.306] result() for MulticoreFuture ... done
[10:58:44.306] result() for MulticoreFuture ...
[10:58:44.306] result() for MulticoreFuture ... done
[10:58:44.307] result() for MulticoreFuture ...
[10:58:44.307] result() for MulticoreFuture ... done
[10:58:44.307] - relayed: [n=2] TRUE, FALSE
[10:58:44.307] - queued futures: [n=2] TRUE, FALSE
[10:58:44.307] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:44.307]  length: 1 (resolved future 1)
[10:58:44.307] Future #2
[10:58:44.308] result() for MulticoreFuture ...
[10:58:44.308] result() for MulticoreFuture ...
[10:58:44.308] result() for MulticoreFuture ... done
[10:58:44.308] result() for MulticoreFuture ... done
[10:58:44.309] result() for MulticoreFuture ...
[10:58:44.309] result() for MulticoreFuture ... done
[10:58:44.309] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:44.309] - nx: 2
[10:58:44.309] - relay: TRUE
[10:58:44.309] - stdout: TRUE
[10:58:44.309] - signal: TRUE
[10:58:44.309] - resignal: FALSE
[10:58:44.310] - force: TRUE
[10:58:44.310] - relayed: [n=2] TRUE, FALSE
[10:58:44.310] - queued futures: [n=2] TRUE, FALSE
[10:58:44.310]  - until=2
[10:58:44.310]  - relaying element #2
[10:58:44.310] result() for MulticoreFuture ...
[10:58:44.310] result() for MulticoreFuture ... done
[10:58:44.310] result() for MulticoreFuture ...
[10:58:44.310] result() for MulticoreFuture ... done
[10:58:44.311] result() for MulticoreFuture ...
[10:58:44.311] result() for MulticoreFuture ... done
[10:58:44.311] result() for MulticoreFuture ...
[10:58:44.311] result() for MulticoreFuture ... done
[10:58:44.311] - relayed: [n=2] TRUE, TRUE
[10:58:44.311] - queued futures: [n=2] TRUE, TRUE
[10:58:44.311] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:44.311]  length: 0 (resolved future 2)
[10:58:44.311] Relaying remaining futures
[10:58:44.312] signalConditionsASAP(NULL, pos=0) ...
[10:58:44.312] - nx: 2
[10:58:44.312] - relay: TRUE
[10:58:44.312] - stdout: TRUE
[10:58:44.312] - signal: TRUE
[10:58:44.312] - resignal: FALSE
[10:58:44.312] - force: TRUE
[10:58:44.312] - relayed: [n=2] TRUE, TRUE
[10:58:44.312] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:44.313] - relayed: [n=2] TRUE, TRUE
[10:58:44.313] - queued futures: [n=2] TRUE, TRUE
[10:58:44.313] signalConditionsASAP(NULL, pos=0) ... done
[10:58:44.313] resolve() on list ... DONE
[10:58:44.313] result() for MulticoreFuture ...
[10:58:44.313] result() for MulticoreFuture ... done
[10:58:44.313] result() for MulticoreFuture ...
[10:58:44.313] result() for MulticoreFuture ... done
[10:58:44.314] result() for MulticoreFuture ...
[10:58:44.314] result() for MulticoreFuture ... done
[10:58:44.314] result() for MulticoreFuture ...
[10:58:44.314] result() for MulticoreFuture ... done
[10:58:44.314]  - Number of value chunks collected: 2
[10:58:44.314] Resolving 2 futures (chunks) ... DONE
[10:58:44.314] Reducing values from 2 chunks ...
[10:58:44.314]  - Number of values collected after concatenation: 3
[10:58:44.314]  - Number of values expected: 3
[10:58:44.315] Reducing values from 2 chunks ... DONE
[10:58:44.315] future_lapply() ... DONE
[10:58:44.315] future_by_internal() ... DONE
[10:58:44.316] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:58:44.317] future_lapply() ...
[10:58:44.320] Number of chunks: 2
[10:58:44.320] getGlobalsAndPackagesXApply() ...
[10:58:44.320]  - future.globals: TRUE
[10:58:44.320] getGlobalsAndPackages() ...
[10:58:44.320] Searching for globals...
[10:58:44.322] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:44.322] Searching for globals ... DONE
[10:58:44.322] Resolving globals: FALSE
[10:58:44.322] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:44.323] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:44.323] - globals: [1] ‘FUN’
[10:58:44.323] 
[10:58:44.323] getGlobalsAndPackages() ... DONE
[10:58:44.323]  - globals found/used: [n=1] ‘FUN’
[10:58:44.324]  - needed namespaces: [n=0] 
[10:58:44.324] Finding globals ... DONE
[10:58:44.324]  - use_args: TRUE
[10:58:44.324]  - Getting '...' globals ...
[10:58:44.324] resolve() on list ...
[10:58:44.325]  recursive: 0
[10:58:44.325]  length: 1
[10:58:44.325]  elements: ‘...’
[10:58:44.325]  length: 0 (resolved future 1)
[10:58:44.325] resolve() on list ... DONE
[10:58:44.325]    - '...' content: [n=0] 
[10:58:44.325] List of 1
[10:58:44.325]  $ ...: list()
[10:58:44.325]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.325]  - attr(*, "where")=List of 1
[10:58:44.325]   ..$ ...:<environment: 0x55974f3a0cc8> 
[10:58:44.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.325]  - attr(*, "resolved")= logi TRUE
[10:58:44.325]  - attr(*, "total_size")= num NA
[10:58:44.329]  - Getting '...' globals ... DONE
[10:58:44.329] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:44.329] List of 2
[10:58:44.329]  $ ...future.FUN:function (object, ...)  
[10:58:44.329]  $ ...          : list()
[10:58:44.329]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.329]  - attr(*, "where")=List of 2
[10:58:44.329]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:44.329]   ..$ ...          :<environment: 0x55974f3a0cc8> 
[10:58:44.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.329]  - attr(*, "resolved")= logi FALSE
[10:58:44.329]  - attr(*, "total_size")= num 18647
[10:58:44.332] Packages to be attached in all futures: [n=0] 
[10:58:44.332] getGlobalsAndPackagesXApply() ... DONE
[10:58:44.333] Number of futures (= number of chunks): 2
[10:58:44.333] Launching 2 futures (chunks) ...
[10:58:44.333] Chunk #1 of 2 ...
[10:58:44.333]  - Finding globals in 'X' for chunk #1 ...
[10:58:44.333] getGlobalsAndPackages() ...
[10:58:44.333] Searching for globals...
[10:58:44.334] 
[10:58:44.334] Searching for globals ... DONE
[10:58:44.334] - globals: [0] <none>
[10:58:44.334] getGlobalsAndPackages() ... DONE
[10:58:44.334]    + additional globals found: [n=0] 
[10:58:44.334]    + additional namespaces needed: [n=0] 
[10:58:44.334]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:44.334]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:44.335]  - seeds: <none>
[10:58:44.335]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.335] getGlobalsAndPackages() ...
[10:58:44.335] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.335] Resolving globals: FALSE
[10:58:44.335] Tweak future expression to call with '...' arguments ...
[10:58:44.335] {
[10:58:44.335]     do.call(function(...) {
[10:58:44.335]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.335]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.335]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.335]             on.exit(options(oopts), add = TRUE)
[10:58:44.335]         }
[10:58:44.335]         {
[10:58:44.335]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.335]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.335]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.335]             })
[10:58:44.335]         }
[10:58:44.335]     }, args = future.call.arguments)
[10:58:44.335] }
[10:58:44.336] Tweak future expression to call with '...' arguments ... DONE
[10:58:44.336] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.336] 
[10:58:44.336] getGlobalsAndPackages() ... DONE
[10:58:44.337] run() for ‘Future’ ...
[10:58:44.337] - state: ‘created’
[10:58:44.337] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:44.339] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:44.339]   - Field: ‘label’
[10:58:44.339]   - Field: ‘local’
[10:58:44.339]   - Field: ‘owner’
[10:58:44.340]   - Field: ‘envir’
[10:58:44.340]   - Field: ‘workers’
[10:58:44.340]   - Field: ‘packages’
[10:58:44.340]   - Field: ‘gc’
[10:58:44.340]   - Field: ‘job’
[10:58:44.340]   - Field: ‘conditions’
[10:58:44.340]   - Field: ‘expr’
[10:58:44.340]   - Field: ‘uuid’
[10:58:44.341]   - Field: ‘seed’
[10:58:44.341]   - Field: ‘version’
[10:58:44.341]   - Field: ‘result’
[10:58:44.341]   - Field: ‘asynchronous’
[10:58:44.341]   - Field: ‘calls’
[10:58:44.341]   - Field: ‘globals’
[10:58:44.341]   - Field: ‘stdout’
[10:58:44.341]   - Field: ‘earlySignal’
[10:58:44.341]   - Field: ‘lazy’
[10:58:44.342]   - Field: ‘state’
[10:58:44.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:44.342] - Launch lazy future ...
[10:58:44.342] Packages needed by the future expression (n = 0): <none>
[10:58:44.342] Packages needed by future strategies (n = 0): <none>
[10:58:44.343] {
[10:58:44.343]     {
[10:58:44.343]         {
[10:58:44.343]             ...future.startTime <- base::Sys.time()
[10:58:44.343]             {
[10:58:44.343]                 {
[10:58:44.343]                   {
[10:58:44.343]                     {
[10:58:44.343]                       base::local({
[10:58:44.343]                         has_future <- base::requireNamespace("future", 
[10:58:44.343]                           quietly = TRUE)
[10:58:44.343]                         if (has_future) {
[10:58:44.343]                           ns <- base::getNamespace("future")
[10:58:44.343]                           version <- ns[[".package"]][["version"]]
[10:58:44.343]                           if (is.null(version)) 
[10:58:44.343]                             version <- utils::packageVersion("future")
[10:58:44.343]                         }
[10:58:44.343]                         else {
[10:58:44.343]                           version <- NULL
[10:58:44.343]                         }
[10:58:44.343]                         if (!has_future || version < "1.8.0") {
[10:58:44.343]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:44.343]                             "", base::R.version$version.string), 
[10:58:44.343]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:44.343]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:44.343]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:44.343]                               "release", "version")], collapse = " "), 
[10:58:44.343]                             hostname = base::Sys.info()[["nodename"]])
[10:58:44.343]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:44.343]                             info)
[10:58:44.343]                           info <- base::paste(info, collapse = "; ")
[10:58:44.343]                           if (!has_future) {
[10:58:44.343]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:44.343]                               info)
[10:58:44.343]                           }
[10:58:44.343]                           else {
[10:58:44.343]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:44.343]                               info, version)
[10:58:44.343]                           }
[10:58:44.343]                           base::stop(msg)
[10:58:44.343]                         }
[10:58:44.343]                       })
[10:58:44.343]                     }
[10:58:44.343]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:44.343]                     base::options(mc.cores = 1L)
[10:58:44.343]                   }
[10:58:44.343]                   ...future.strategy.old <- future::plan("list")
[10:58:44.343]                   options(future.plan = NULL)
[10:58:44.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:44.343]                 }
[10:58:44.343]                 ...future.workdir <- getwd()
[10:58:44.343]             }
[10:58:44.343]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:44.343]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:44.343]         }
[10:58:44.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:44.343]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:44.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:44.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:44.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:44.343]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:44.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:44.343]             base::names(...future.oldOptions))
[10:58:44.343]     }
[10:58:44.343]     if (FALSE) {
[10:58:44.343]     }
[10:58:44.343]     else {
[10:58:44.343]         if (TRUE) {
[10:58:44.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:44.343]                 open = "w")
[10:58:44.343]         }
[10:58:44.343]         else {
[10:58:44.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:44.343]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:44.343]         }
[10:58:44.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:44.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:44.343]             base::sink(type = "output", split = FALSE)
[10:58:44.343]             base::close(...future.stdout)
[10:58:44.343]         }, add = TRUE)
[10:58:44.343]     }
[10:58:44.343]     ...future.frame <- base::sys.nframe()
[10:58:44.343]     ...future.conditions <- base::list()
[10:58:44.343]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:44.343]     if (FALSE) {
[10:58:44.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:44.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:44.343]     }
[10:58:44.343]     ...future.result <- base::tryCatch({
[10:58:44.343]         base::withCallingHandlers({
[10:58:44.343]             ...future.value <- base::withVisible(base::local({
[10:58:44.343]                 withCallingHandlers({
[10:58:44.343]                   {
[10:58:44.343]                     do.call(function(...) {
[10:58:44.343]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.343]                       if (!identical(...future.globals.maxSize.org, 
[10:58:44.343]                         ...future.globals.maxSize)) {
[10:58:44.343]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.343]                         on.exit(options(oopts), add = TRUE)
[10:58:44.343]                       }
[10:58:44.343]                       {
[10:58:44.343]                         lapply(seq_along(...future.elements_ii), 
[10:58:44.343]                           FUN = function(jj) {
[10:58:44.343]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.343]                             ...future.FUN(...future.X_jj, ...)
[10:58:44.343]                           })
[10:58:44.343]                       }
[10:58:44.343]                     }, args = future.call.arguments)
[10:58:44.343]                   }
[10:58:44.343]                 }, immediateCondition = function(cond) {
[10:58:44.343]                   save_rds <- function (object, pathname, ...) 
[10:58:44.343]                   {
[10:58:44.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:44.343]                     if (file_test("-f", pathname_tmp)) {
[10:58:44.343]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:44.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.343]                         fi_tmp[["mtime"]])
[10:58:44.343]                     }
[10:58:44.343]                     tryCatch({
[10:58:44.343]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:44.343]                     }, error = function(ex) {
[10:58:44.343]                       msg <- conditionMessage(ex)
[10:58:44.343]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:44.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.343]                         fi_tmp[["mtime"]], msg)
[10:58:44.343]                       ex$message <- msg
[10:58:44.343]                       stop(ex)
[10:58:44.343]                     })
[10:58:44.343]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:44.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:44.343]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:44.343]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.343]                       fi <- file.info(pathname)
[10:58:44.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:44.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:44.343]                         fi[["size"]], fi[["mtime"]])
[10:58:44.343]                       stop(msg)
[10:58:44.343]                     }
[10:58:44.343]                     invisible(pathname)
[10:58:44.343]                   }
[10:58:44.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:44.343]                     rootPath = tempdir()) 
[10:58:44.343]                   {
[10:58:44.343]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:44.343]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:44.343]                       tmpdir = path, fileext = ".rds")
[10:58:44.343]                     save_rds(obj, file)
[10:58:44.343]                   }
[10:58:44.343]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:44.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.343]                   {
[10:58:44.343]                     inherits <- base::inherits
[10:58:44.343]                     invokeRestart <- base::invokeRestart
[10:58:44.343]                     is.null <- base::is.null
[10:58:44.343]                     muffled <- FALSE
[10:58:44.343]                     if (inherits(cond, "message")) {
[10:58:44.343]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:44.343]                       if (muffled) 
[10:58:44.343]                         invokeRestart("muffleMessage")
[10:58:44.343]                     }
[10:58:44.343]                     else if (inherits(cond, "warning")) {
[10:58:44.343]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:44.343]                       if (muffled) 
[10:58:44.343]                         invokeRestart("muffleWarning")
[10:58:44.343]                     }
[10:58:44.343]                     else if (inherits(cond, "condition")) {
[10:58:44.343]                       if (!is.null(pattern)) {
[10:58:44.343]                         computeRestarts <- base::computeRestarts
[10:58:44.343]                         grepl <- base::grepl
[10:58:44.343]                         restarts <- computeRestarts(cond)
[10:58:44.343]                         for (restart in restarts) {
[10:58:44.343]                           name <- restart$name
[10:58:44.343]                           if (is.null(name)) 
[10:58:44.343]                             next
[10:58:44.343]                           if (!grepl(pattern, name)) 
[10:58:44.343]                             next
[10:58:44.343]                           invokeRestart(restart)
[10:58:44.343]                           muffled <- TRUE
[10:58:44.343]                           break
[10:58:44.343]                         }
[10:58:44.343]                       }
[10:58:44.343]                     }
[10:58:44.343]                     invisible(muffled)
[10:58:44.343]                   }
[10:58:44.343]                   muffleCondition(cond)
[10:58:44.343]                 })
[10:58:44.343]             }))
[10:58:44.343]             future::FutureResult(value = ...future.value$value, 
[10:58:44.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.343]                   ...future.rng), globalenv = if (FALSE) 
[10:58:44.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:44.343]                     ...future.globalenv.names))
[10:58:44.343]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:44.343]         }, condition = base::local({
[10:58:44.343]             c <- base::c
[10:58:44.343]             inherits <- base::inherits
[10:58:44.343]             invokeRestart <- base::invokeRestart
[10:58:44.343]             length <- base::length
[10:58:44.343]             list <- base::list
[10:58:44.343]             seq.int <- base::seq.int
[10:58:44.343]             signalCondition <- base::signalCondition
[10:58:44.343]             sys.calls <- base::sys.calls
[10:58:44.343]             `[[` <- base::`[[`
[10:58:44.343]             `+` <- base::`+`
[10:58:44.343]             `<<-` <- base::`<<-`
[10:58:44.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:44.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:44.343]                   3L)]
[10:58:44.343]             }
[10:58:44.343]             function(cond) {
[10:58:44.343]                 is_error <- inherits(cond, "error")
[10:58:44.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:44.343]                   NULL)
[10:58:44.343]                 if (is_error) {
[10:58:44.343]                   sessionInformation <- function() {
[10:58:44.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:44.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:44.343]                       search = base::search(), system = base::Sys.info())
[10:58:44.343]                   }
[10:58:44.343]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:44.343]                     cond$call), session = sessionInformation(), 
[10:58:44.343]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:44.343]                   signalCondition(cond)
[10:58:44.343]                 }
[10:58:44.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:44.343]                 "immediateCondition"))) {
[10:58:44.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:44.343]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:44.343]                   if (TRUE && !signal) {
[10:58:44.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.343]                     {
[10:58:44.343]                       inherits <- base::inherits
[10:58:44.343]                       invokeRestart <- base::invokeRestart
[10:58:44.343]                       is.null <- base::is.null
[10:58:44.343]                       muffled <- FALSE
[10:58:44.343]                       if (inherits(cond, "message")) {
[10:58:44.343]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.343]                         if (muffled) 
[10:58:44.343]                           invokeRestart("muffleMessage")
[10:58:44.343]                       }
[10:58:44.343]                       else if (inherits(cond, "warning")) {
[10:58:44.343]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.343]                         if (muffled) 
[10:58:44.343]                           invokeRestart("muffleWarning")
[10:58:44.343]                       }
[10:58:44.343]                       else if (inherits(cond, "condition")) {
[10:58:44.343]                         if (!is.null(pattern)) {
[10:58:44.343]                           computeRestarts <- base::computeRestarts
[10:58:44.343]                           grepl <- base::grepl
[10:58:44.343]                           restarts <- computeRestarts(cond)
[10:58:44.343]                           for (restart in restarts) {
[10:58:44.343]                             name <- restart$name
[10:58:44.343]                             if (is.null(name)) 
[10:58:44.343]                               next
[10:58:44.343]                             if (!grepl(pattern, name)) 
[10:58:44.343]                               next
[10:58:44.343]                             invokeRestart(restart)
[10:58:44.343]                             muffled <- TRUE
[10:58:44.343]                             break
[10:58:44.343]                           }
[10:58:44.343]                         }
[10:58:44.343]                       }
[10:58:44.343]                       invisible(muffled)
[10:58:44.343]                     }
[10:58:44.343]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.343]                   }
[10:58:44.343]                 }
[10:58:44.343]                 else {
[10:58:44.343]                   if (TRUE) {
[10:58:44.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.343]                     {
[10:58:44.343]                       inherits <- base::inherits
[10:58:44.343]                       invokeRestart <- base::invokeRestart
[10:58:44.343]                       is.null <- base::is.null
[10:58:44.343]                       muffled <- FALSE
[10:58:44.343]                       if (inherits(cond, "message")) {
[10:58:44.343]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.343]                         if (muffled) 
[10:58:44.343]                           invokeRestart("muffleMessage")
[10:58:44.343]                       }
[10:58:44.343]                       else if (inherits(cond, "warning")) {
[10:58:44.343]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.343]                         if (muffled) 
[10:58:44.343]                           invokeRestart("muffleWarning")
[10:58:44.343]                       }
[10:58:44.343]                       else if (inherits(cond, "condition")) {
[10:58:44.343]                         if (!is.null(pattern)) {
[10:58:44.343]                           computeRestarts <- base::computeRestarts
[10:58:44.343]                           grepl <- base::grepl
[10:58:44.343]                           restarts <- computeRestarts(cond)
[10:58:44.343]                           for (restart in restarts) {
[10:58:44.343]                             name <- restart$name
[10:58:44.343]                             if (is.null(name)) 
[10:58:44.343]                               next
[10:58:44.343]                             if (!grepl(pattern, name)) 
[10:58:44.343]                               next
[10:58:44.343]                             invokeRestart(restart)
[10:58:44.343]                             muffled <- TRUE
[10:58:44.343]                             break
[10:58:44.343]                           }
[10:58:44.343]                         }
[10:58:44.343]                       }
[10:58:44.343]                       invisible(muffled)
[10:58:44.343]                     }
[10:58:44.343]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.343]                   }
[10:58:44.343]                 }
[10:58:44.343]             }
[10:58:44.343]         }))
[10:58:44.343]     }, error = function(ex) {
[10:58:44.343]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:44.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.343]                 ...future.rng), started = ...future.startTime, 
[10:58:44.343]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:44.343]             version = "1.8"), class = "FutureResult")
[10:58:44.343]     }, finally = {
[10:58:44.343]         if (!identical(...future.workdir, getwd())) 
[10:58:44.343]             setwd(...future.workdir)
[10:58:44.343]         {
[10:58:44.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:44.343]                 ...future.oldOptions$nwarnings <- NULL
[10:58:44.343]             }
[10:58:44.343]             base::options(...future.oldOptions)
[10:58:44.343]             if (.Platform$OS.type == "windows") {
[10:58:44.343]                 old_names <- names(...future.oldEnvVars)
[10:58:44.343]                 envs <- base::Sys.getenv()
[10:58:44.343]                 names <- names(envs)
[10:58:44.343]                 common <- intersect(names, old_names)
[10:58:44.343]                 added <- setdiff(names, old_names)
[10:58:44.343]                 removed <- setdiff(old_names, names)
[10:58:44.343]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:44.343]                   envs[common]]
[10:58:44.343]                 NAMES <- toupper(changed)
[10:58:44.343]                 args <- list()
[10:58:44.343]                 for (kk in seq_along(NAMES)) {
[10:58:44.343]                   name <- changed[[kk]]
[10:58:44.343]                   NAME <- NAMES[[kk]]
[10:58:44.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.343]                     next
[10:58:44.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.343]                 }
[10:58:44.343]                 NAMES <- toupper(added)
[10:58:44.343]                 for (kk in seq_along(NAMES)) {
[10:58:44.343]                   name <- added[[kk]]
[10:58:44.343]                   NAME <- NAMES[[kk]]
[10:58:44.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.343]                     next
[10:58:44.343]                   args[[name]] <- ""
[10:58:44.343]                 }
[10:58:44.343]                 NAMES <- toupper(removed)
[10:58:44.343]                 for (kk in seq_along(NAMES)) {
[10:58:44.343]                   name <- removed[[kk]]
[10:58:44.343]                   NAME <- NAMES[[kk]]
[10:58:44.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.343]                     next
[10:58:44.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.343]                 }
[10:58:44.343]                 if (length(args) > 0) 
[10:58:44.343]                   base::do.call(base::Sys.setenv, args = args)
[10:58:44.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:44.343]             }
[10:58:44.343]             else {
[10:58:44.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:44.343]             }
[10:58:44.343]             {
[10:58:44.343]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:44.343]                   0L) {
[10:58:44.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:44.343]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:44.343]                   base::options(opts)
[10:58:44.343]                 }
[10:58:44.343]                 {
[10:58:44.343]                   {
[10:58:44.343]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:44.343]                     NULL
[10:58:44.343]                   }
[10:58:44.343]                   options(future.plan = NULL)
[10:58:44.343]                   if (is.na(NA_character_)) 
[10:58:44.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:44.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:44.343]                     .init = FALSE)
[10:58:44.343]                 }
[10:58:44.343]             }
[10:58:44.343]         }
[10:58:44.343]     })
[10:58:44.343]     if (TRUE) {
[10:58:44.343]         base::sink(type = "output", split = FALSE)
[10:58:44.343]         if (TRUE) {
[10:58:44.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:44.343]         }
[10:58:44.343]         else {
[10:58:44.343]             ...future.result["stdout"] <- base::list(NULL)
[10:58:44.343]         }
[10:58:44.343]         base::close(...future.stdout)
[10:58:44.343]         ...future.stdout <- NULL
[10:58:44.343]     }
[10:58:44.343]     ...future.result$conditions <- ...future.conditions
[10:58:44.343]     ...future.result$finished <- base::Sys.time()
[10:58:44.343]     ...future.result
[10:58:44.343] }
[10:58:44.346] assign_globals() ...
[10:58:44.346] List of 5
[10:58:44.346]  $ ...future.FUN            :function (object, ...)  
[10:58:44.346]  $ future.call.arguments    : list()
[10:58:44.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.346]  $ ...future.elements_ii    :List of 1
[10:58:44.346]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.346]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:58:44.346]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.346]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:44.346]  $ ...future.seeds_ii       : NULL
[10:58:44.346]  $ ...future.globals.maxSize: NULL
[10:58:44.346]  - attr(*, "where")=List of 5
[10:58:44.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:44.346]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:44.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:44.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:44.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:44.346]  - attr(*, "resolved")= logi FALSE
[10:58:44.346]  - attr(*, "total_size")= num 18647
[10:58:44.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.346]  - attr(*, "already-done")= logi TRUE
[10:58:44.353] - copied ‘...future.FUN’ to environment
[10:58:44.353] - copied ‘future.call.arguments’ to environment
[10:58:44.353] - copied ‘...future.elements_ii’ to environment
[10:58:44.353] - copied ‘...future.seeds_ii’ to environment
[10:58:44.353] - copied ‘...future.globals.maxSize’ to environment
[10:58:44.353] assign_globals() ... done
[10:58:44.353] requestCore(): workers = 2
[10:58:44.355] MulticoreFuture started
[10:58:44.356] - Launch lazy future ... done
[10:58:44.356] run() for ‘MulticoreFuture’ ... done
[10:58:44.356] Created future:
[10:58:44.357] plan(): Setting new future strategy stack:
[10:58:44.357] List of future strategies:
[10:58:44.357] 1. sequential:
[10:58:44.357]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:44.357]    - tweaked: FALSE
[10:58:44.357]    - call: NULL
[10:58:44.358] plan(): nbrOfWorkers() = 1
[10:58:44.361] plan(): Setting new future strategy stack:
[10:58:44.361] List of future strategies:
[10:58:44.361] 1. multicore:
[10:58:44.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:44.361]    - tweaked: FALSE
[10:58:44.361]    - call: plan(strategy)
[10:58:44.364] plan(): nbrOfWorkers() = 2
[10:58:44.356] MulticoreFuture:
[10:58:44.356] Label: ‘future_by-1’
[10:58:44.356] Expression:
[10:58:44.356] {
[10:58:44.356]     do.call(function(...) {
[10:58:44.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.356]             on.exit(options(oopts), add = TRUE)
[10:58:44.356]         }
[10:58:44.356]         {
[10:58:44.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.356]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.356]             })
[10:58:44.356]         }
[10:58:44.356]     }, args = future.call.arguments)
[10:58:44.356] }
[10:58:44.356] Lazy evaluation: FALSE
[10:58:44.356] Asynchronous evaluation: TRUE
[10:58:44.356] Local evaluation: TRUE
[10:58:44.356] Environment: 0x55974f370430
[10:58:44.356] Capture standard output: TRUE
[10:58:44.356] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:44.356] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:44.356] Packages: <none>
[10:58:44.356] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:44.356] Resolved: TRUE
[10:58:44.356] Value: <not collected>
[10:58:44.356] Conditions captured: <none>
[10:58:44.356] Early signaling: FALSE
[10:58:44.356] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:44.356] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.365] Chunk #1 of 2 ... DONE
[10:58:44.365] Chunk #2 of 2 ...
[10:58:44.365]  - Finding globals in 'X' for chunk #2 ...
[10:58:44.365] getGlobalsAndPackages() ...
[10:58:44.365] Searching for globals...
[10:58:44.366] 
[10:58:44.366] Searching for globals ... DONE
[10:58:44.366] - globals: [0] <none>
[10:58:44.367] getGlobalsAndPackages() ... DONE
[10:58:44.367]    + additional globals found: [n=0] 
[10:58:44.367]    + additional namespaces needed: [n=0] 
[10:58:44.367]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:44.367]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:44.367]  - seeds: <none>
[10:58:44.367]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.367] getGlobalsAndPackages() ...
[10:58:44.367] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.368] Resolving globals: FALSE
[10:58:44.368] Tweak future expression to call with '...' arguments ...
[10:58:44.368] {
[10:58:44.368]     do.call(function(...) {
[10:58:44.368]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.368]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.368]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.368]             on.exit(options(oopts), add = TRUE)
[10:58:44.368]         }
[10:58:44.368]         {
[10:58:44.368]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.368]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.368]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.368]             })
[10:58:44.368]         }
[10:58:44.368]     }, args = future.call.arguments)
[10:58:44.368] }
[10:58:44.368] Tweak future expression to call with '...' arguments ... DONE
[10:58:44.369] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:44.369] 
[10:58:44.369] getGlobalsAndPackages() ... DONE
[10:58:44.369] run() for ‘Future’ ...
[10:58:44.370] - state: ‘created’
[10:58:44.370] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:44.372] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:44.372]   - Field: ‘label’
[10:58:44.372]   - Field: ‘local’
[10:58:44.373]   - Field: ‘owner’
[10:58:44.373]   - Field: ‘envir’
[10:58:44.373]   - Field: ‘workers’
[10:58:44.373]   - Field: ‘packages’
[10:58:44.373]   - Field: ‘gc’
[10:58:44.373]   - Field: ‘job’
[10:58:44.373]   - Field: ‘conditions’
[10:58:44.373]   - Field: ‘expr’
[10:58:44.373]   - Field: ‘uuid’
[10:58:44.374]   - Field: ‘seed’
[10:58:44.374]   - Field: ‘version’
[10:58:44.374]   - Field: ‘result’
[10:58:44.374]   - Field: ‘asynchronous’
[10:58:44.374]   - Field: ‘calls’
[10:58:44.374]   - Field: ‘globals’
[10:58:44.374]   - Field: ‘stdout’
[10:58:44.374]   - Field: ‘earlySignal’
[10:58:44.374]   - Field: ‘lazy’
[10:58:44.375]   - Field: ‘state’
[10:58:44.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:44.375] - Launch lazy future ...
[10:58:44.375] Packages needed by the future expression (n = 0): <none>
[10:58:44.375] Packages needed by future strategies (n = 0): <none>
[10:58:44.376] {
[10:58:44.376]     {
[10:58:44.376]         {
[10:58:44.376]             ...future.startTime <- base::Sys.time()
[10:58:44.376]             {
[10:58:44.376]                 {
[10:58:44.376]                   {
[10:58:44.376]                     {
[10:58:44.376]                       base::local({
[10:58:44.376]                         has_future <- base::requireNamespace("future", 
[10:58:44.376]                           quietly = TRUE)
[10:58:44.376]                         if (has_future) {
[10:58:44.376]                           ns <- base::getNamespace("future")
[10:58:44.376]                           version <- ns[[".package"]][["version"]]
[10:58:44.376]                           if (is.null(version)) 
[10:58:44.376]                             version <- utils::packageVersion("future")
[10:58:44.376]                         }
[10:58:44.376]                         else {
[10:58:44.376]                           version <- NULL
[10:58:44.376]                         }
[10:58:44.376]                         if (!has_future || version < "1.8.0") {
[10:58:44.376]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:44.376]                             "", base::R.version$version.string), 
[10:58:44.376]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:44.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:44.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:44.376]                               "release", "version")], collapse = " "), 
[10:58:44.376]                             hostname = base::Sys.info()[["nodename"]])
[10:58:44.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:44.376]                             info)
[10:58:44.376]                           info <- base::paste(info, collapse = "; ")
[10:58:44.376]                           if (!has_future) {
[10:58:44.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:44.376]                               info)
[10:58:44.376]                           }
[10:58:44.376]                           else {
[10:58:44.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:44.376]                               info, version)
[10:58:44.376]                           }
[10:58:44.376]                           base::stop(msg)
[10:58:44.376]                         }
[10:58:44.376]                       })
[10:58:44.376]                     }
[10:58:44.376]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:44.376]                     base::options(mc.cores = 1L)
[10:58:44.376]                   }
[10:58:44.376]                   ...future.strategy.old <- future::plan("list")
[10:58:44.376]                   options(future.plan = NULL)
[10:58:44.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:44.376]                 }
[10:58:44.376]                 ...future.workdir <- getwd()
[10:58:44.376]             }
[10:58:44.376]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:44.376]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:44.376]         }
[10:58:44.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:44.376]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:44.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:44.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:44.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:44.376]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:44.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:44.376]             base::names(...future.oldOptions))
[10:58:44.376]     }
[10:58:44.376]     if (FALSE) {
[10:58:44.376]     }
[10:58:44.376]     else {
[10:58:44.376]         if (TRUE) {
[10:58:44.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:44.376]                 open = "w")
[10:58:44.376]         }
[10:58:44.376]         else {
[10:58:44.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:44.376]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:44.376]         }
[10:58:44.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:44.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:44.376]             base::sink(type = "output", split = FALSE)
[10:58:44.376]             base::close(...future.stdout)
[10:58:44.376]         }, add = TRUE)
[10:58:44.376]     }
[10:58:44.376]     ...future.frame <- base::sys.nframe()
[10:58:44.376]     ...future.conditions <- base::list()
[10:58:44.376]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:44.376]     if (FALSE) {
[10:58:44.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:44.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:44.376]     }
[10:58:44.376]     ...future.result <- base::tryCatch({
[10:58:44.376]         base::withCallingHandlers({
[10:58:44.376]             ...future.value <- base::withVisible(base::local({
[10:58:44.376]                 withCallingHandlers({
[10:58:44.376]                   {
[10:58:44.376]                     do.call(function(...) {
[10:58:44.376]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.376]                       if (!identical(...future.globals.maxSize.org, 
[10:58:44.376]                         ...future.globals.maxSize)) {
[10:58:44.376]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.376]                         on.exit(options(oopts), add = TRUE)
[10:58:44.376]                       }
[10:58:44.376]                       {
[10:58:44.376]                         lapply(seq_along(...future.elements_ii), 
[10:58:44.376]                           FUN = function(jj) {
[10:58:44.376]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.376]                             ...future.FUN(...future.X_jj, ...)
[10:58:44.376]                           })
[10:58:44.376]                       }
[10:58:44.376]                     }, args = future.call.arguments)
[10:58:44.376]                   }
[10:58:44.376]                 }, immediateCondition = function(cond) {
[10:58:44.376]                   save_rds <- function (object, pathname, ...) 
[10:58:44.376]                   {
[10:58:44.376]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:44.376]                     if (file_test("-f", pathname_tmp)) {
[10:58:44.376]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.376]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:44.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.376]                         fi_tmp[["mtime"]])
[10:58:44.376]                     }
[10:58:44.376]                     tryCatch({
[10:58:44.376]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:44.376]                     }, error = function(ex) {
[10:58:44.376]                       msg <- conditionMessage(ex)
[10:58:44.376]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.376]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:44.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.376]                         fi_tmp[["mtime"]], msg)
[10:58:44.376]                       ex$message <- msg
[10:58:44.376]                       stop(ex)
[10:58:44.376]                     })
[10:58:44.376]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:44.376]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:44.376]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:44.376]                       fi_tmp <- file.info(pathname_tmp)
[10:58:44.376]                       fi <- file.info(pathname)
[10:58:44.376]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:44.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:44.376]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:44.376]                         fi[["size"]], fi[["mtime"]])
[10:58:44.376]                       stop(msg)
[10:58:44.376]                     }
[10:58:44.376]                     invisible(pathname)
[10:58:44.376]                   }
[10:58:44.376]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:44.376]                     rootPath = tempdir()) 
[10:58:44.376]                   {
[10:58:44.376]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:44.376]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:44.376]                       tmpdir = path, fileext = ".rds")
[10:58:44.376]                     save_rds(obj, file)
[10:58:44.376]                   }
[10:58:44.376]                   saveImmediateCondition(cond, path = "/tmp/RtmpnaR5ku/.future/immediateConditions")
[10:58:44.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.376]                   {
[10:58:44.376]                     inherits <- base::inherits
[10:58:44.376]                     invokeRestart <- base::invokeRestart
[10:58:44.376]                     is.null <- base::is.null
[10:58:44.376]                     muffled <- FALSE
[10:58:44.376]                     if (inherits(cond, "message")) {
[10:58:44.376]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:44.376]                       if (muffled) 
[10:58:44.376]                         invokeRestart("muffleMessage")
[10:58:44.376]                     }
[10:58:44.376]                     else if (inherits(cond, "warning")) {
[10:58:44.376]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:44.376]                       if (muffled) 
[10:58:44.376]                         invokeRestart("muffleWarning")
[10:58:44.376]                     }
[10:58:44.376]                     else if (inherits(cond, "condition")) {
[10:58:44.376]                       if (!is.null(pattern)) {
[10:58:44.376]                         computeRestarts <- base::computeRestarts
[10:58:44.376]                         grepl <- base::grepl
[10:58:44.376]                         restarts <- computeRestarts(cond)
[10:58:44.376]                         for (restart in restarts) {
[10:58:44.376]                           name <- restart$name
[10:58:44.376]                           if (is.null(name)) 
[10:58:44.376]                             next
[10:58:44.376]                           if (!grepl(pattern, name)) 
[10:58:44.376]                             next
[10:58:44.376]                           invokeRestart(restart)
[10:58:44.376]                           muffled <- TRUE
[10:58:44.376]                           break
[10:58:44.376]                         }
[10:58:44.376]                       }
[10:58:44.376]                     }
[10:58:44.376]                     invisible(muffled)
[10:58:44.376]                   }
[10:58:44.376]                   muffleCondition(cond)
[10:58:44.376]                 })
[10:58:44.376]             }))
[10:58:44.376]             future::FutureResult(value = ...future.value$value, 
[10:58:44.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.376]                   ...future.rng), globalenv = if (FALSE) 
[10:58:44.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:44.376]                     ...future.globalenv.names))
[10:58:44.376]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:44.376]         }, condition = base::local({
[10:58:44.376]             c <- base::c
[10:58:44.376]             inherits <- base::inherits
[10:58:44.376]             invokeRestart <- base::invokeRestart
[10:58:44.376]             length <- base::length
[10:58:44.376]             list <- base::list
[10:58:44.376]             seq.int <- base::seq.int
[10:58:44.376]             signalCondition <- base::signalCondition
[10:58:44.376]             sys.calls <- base::sys.calls
[10:58:44.376]             `[[` <- base::`[[`
[10:58:44.376]             `+` <- base::`+`
[10:58:44.376]             `<<-` <- base::`<<-`
[10:58:44.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:44.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:44.376]                   3L)]
[10:58:44.376]             }
[10:58:44.376]             function(cond) {
[10:58:44.376]                 is_error <- inherits(cond, "error")
[10:58:44.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:44.376]                   NULL)
[10:58:44.376]                 if (is_error) {
[10:58:44.376]                   sessionInformation <- function() {
[10:58:44.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:44.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:44.376]                       search = base::search(), system = base::Sys.info())
[10:58:44.376]                   }
[10:58:44.376]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:44.376]                     cond$call), session = sessionInformation(), 
[10:58:44.376]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:44.376]                   signalCondition(cond)
[10:58:44.376]                 }
[10:58:44.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:44.376]                 "immediateCondition"))) {
[10:58:44.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:44.376]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:44.376]                   if (TRUE && !signal) {
[10:58:44.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.376]                     {
[10:58:44.376]                       inherits <- base::inherits
[10:58:44.376]                       invokeRestart <- base::invokeRestart
[10:58:44.376]                       is.null <- base::is.null
[10:58:44.376]                       muffled <- FALSE
[10:58:44.376]                       if (inherits(cond, "message")) {
[10:58:44.376]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.376]                         if (muffled) 
[10:58:44.376]                           invokeRestart("muffleMessage")
[10:58:44.376]                       }
[10:58:44.376]                       else if (inherits(cond, "warning")) {
[10:58:44.376]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.376]                         if (muffled) 
[10:58:44.376]                           invokeRestart("muffleWarning")
[10:58:44.376]                       }
[10:58:44.376]                       else if (inherits(cond, "condition")) {
[10:58:44.376]                         if (!is.null(pattern)) {
[10:58:44.376]                           computeRestarts <- base::computeRestarts
[10:58:44.376]                           grepl <- base::grepl
[10:58:44.376]                           restarts <- computeRestarts(cond)
[10:58:44.376]                           for (restart in restarts) {
[10:58:44.376]                             name <- restart$name
[10:58:44.376]                             if (is.null(name)) 
[10:58:44.376]                               next
[10:58:44.376]                             if (!grepl(pattern, name)) 
[10:58:44.376]                               next
[10:58:44.376]                             invokeRestart(restart)
[10:58:44.376]                             muffled <- TRUE
[10:58:44.376]                             break
[10:58:44.376]                           }
[10:58:44.376]                         }
[10:58:44.376]                       }
[10:58:44.376]                       invisible(muffled)
[10:58:44.376]                     }
[10:58:44.376]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.376]                   }
[10:58:44.376]                 }
[10:58:44.376]                 else {
[10:58:44.376]                   if (TRUE) {
[10:58:44.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.376]                     {
[10:58:44.376]                       inherits <- base::inherits
[10:58:44.376]                       invokeRestart <- base::invokeRestart
[10:58:44.376]                       is.null <- base::is.null
[10:58:44.376]                       muffled <- FALSE
[10:58:44.376]                       if (inherits(cond, "message")) {
[10:58:44.376]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.376]                         if (muffled) 
[10:58:44.376]                           invokeRestart("muffleMessage")
[10:58:44.376]                       }
[10:58:44.376]                       else if (inherits(cond, "warning")) {
[10:58:44.376]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.376]                         if (muffled) 
[10:58:44.376]                           invokeRestart("muffleWarning")
[10:58:44.376]                       }
[10:58:44.376]                       else if (inherits(cond, "condition")) {
[10:58:44.376]                         if (!is.null(pattern)) {
[10:58:44.376]                           computeRestarts <- base::computeRestarts
[10:58:44.376]                           grepl <- base::grepl
[10:58:44.376]                           restarts <- computeRestarts(cond)
[10:58:44.376]                           for (restart in restarts) {
[10:58:44.376]                             name <- restart$name
[10:58:44.376]                             if (is.null(name)) 
[10:58:44.376]                               next
[10:58:44.376]                             if (!grepl(pattern, name)) 
[10:58:44.376]                               next
[10:58:44.376]                             invokeRestart(restart)
[10:58:44.376]                             muffled <- TRUE
[10:58:44.376]                             break
[10:58:44.376]                           }
[10:58:44.376]                         }
[10:58:44.376]                       }
[10:58:44.376]                       invisible(muffled)
[10:58:44.376]                     }
[10:58:44.376]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.376]                   }
[10:58:44.376]                 }
[10:58:44.376]             }
[10:58:44.376]         }))
[10:58:44.376]     }, error = function(ex) {
[10:58:44.376]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:44.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.376]                 ...future.rng), started = ...future.startTime, 
[10:58:44.376]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:44.376]             version = "1.8"), class = "FutureResult")
[10:58:44.376]     }, finally = {
[10:58:44.376]         if (!identical(...future.workdir, getwd())) 
[10:58:44.376]             setwd(...future.workdir)
[10:58:44.376]         {
[10:58:44.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:44.376]                 ...future.oldOptions$nwarnings <- NULL
[10:58:44.376]             }
[10:58:44.376]             base::options(...future.oldOptions)
[10:58:44.376]             if (.Platform$OS.type == "windows") {
[10:58:44.376]                 old_names <- names(...future.oldEnvVars)
[10:58:44.376]                 envs <- base::Sys.getenv()
[10:58:44.376]                 names <- names(envs)
[10:58:44.376]                 common <- intersect(names, old_names)
[10:58:44.376]                 added <- setdiff(names, old_names)
[10:58:44.376]                 removed <- setdiff(old_names, names)
[10:58:44.376]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:44.376]                   envs[common]]
[10:58:44.376]                 NAMES <- toupper(changed)
[10:58:44.376]                 args <- list()
[10:58:44.376]                 for (kk in seq_along(NAMES)) {
[10:58:44.376]                   name <- changed[[kk]]
[10:58:44.376]                   NAME <- NAMES[[kk]]
[10:58:44.376]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.376]                     next
[10:58:44.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.376]                 }
[10:58:44.376]                 NAMES <- toupper(added)
[10:58:44.376]                 for (kk in seq_along(NAMES)) {
[10:58:44.376]                   name <- added[[kk]]
[10:58:44.376]                   NAME <- NAMES[[kk]]
[10:58:44.376]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.376]                     next
[10:58:44.376]                   args[[name]] <- ""
[10:58:44.376]                 }
[10:58:44.376]                 NAMES <- toupper(removed)
[10:58:44.376]                 for (kk in seq_along(NAMES)) {
[10:58:44.376]                   name <- removed[[kk]]
[10:58:44.376]                   NAME <- NAMES[[kk]]
[10:58:44.376]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.376]                     next
[10:58:44.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.376]                 }
[10:58:44.376]                 if (length(args) > 0) 
[10:58:44.376]                   base::do.call(base::Sys.setenv, args = args)
[10:58:44.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:44.376]             }
[10:58:44.376]             else {
[10:58:44.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:44.376]             }
[10:58:44.376]             {
[10:58:44.376]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:44.376]                   0L) {
[10:58:44.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:44.376]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:44.376]                   base::options(opts)
[10:58:44.376]                 }
[10:58:44.376]                 {
[10:58:44.376]                   {
[10:58:44.376]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:44.376]                     NULL
[10:58:44.376]                   }
[10:58:44.376]                   options(future.plan = NULL)
[10:58:44.376]                   if (is.na(NA_character_)) 
[10:58:44.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:44.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:44.376]                     .init = FALSE)
[10:58:44.376]                 }
[10:58:44.376]             }
[10:58:44.376]         }
[10:58:44.376]     })
[10:58:44.376]     if (TRUE) {
[10:58:44.376]         base::sink(type = "output", split = FALSE)
[10:58:44.376]         if (TRUE) {
[10:58:44.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:44.376]         }
[10:58:44.376]         else {
[10:58:44.376]             ...future.result["stdout"] <- base::list(NULL)
[10:58:44.376]         }
[10:58:44.376]         base::close(...future.stdout)
[10:58:44.376]         ...future.stdout <- NULL
[10:58:44.376]     }
[10:58:44.376]     ...future.result$conditions <- ...future.conditions
[10:58:44.376]     ...future.result$finished <- base::Sys.time()
[10:58:44.376]     ...future.result
[10:58:44.376] }
[10:58:44.379] assign_globals() ...
[10:58:44.379] List of 5
[10:58:44.379]  $ ...future.FUN            :function (object, ...)  
[10:58:44.379]  $ future.call.arguments    : list()
[10:58:44.379]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:44.379]  $ ...future.elements_ii    :List of 2
[10:58:44.379]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.379]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:58:44.379]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.379]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:58:44.379]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:58:44.379]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:58:44.379]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:58:44.379]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:58:44.379]  $ ...future.seeds_ii       : NULL
[10:58:44.379]  $ ...future.globals.maxSize: NULL
[10:58:44.379]  - attr(*, "where")=List of 5
[10:58:44.379]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:44.379]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:44.379]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:44.379]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:44.379]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:44.379]  - attr(*, "resolved")= logi FALSE
[10:58:44.379]  - attr(*, "total_size")= num 18647
[10:58:44.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:44.379]  - attr(*, "already-done")= logi TRUE
[10:58:44.394] - copied ‘...future.FUN’ to environment
[10:58:44.394] - copied ‘future.call.arguments’ to environment
[10:58:44.394] - copied ‘...future.elements_ii’ to environment
[10:58:44.394] - copied ‘...future.seeds_ii’ to environment
[10:58:44.394] - copied ‘...future.globals.maxSize’ to environment
[10:58:44.394] assign_globals() ... done
[10:58:44.395] requestCore(): workers = 2
[10:58:44.397] MulticoreFuture started
[10:58:44.397] - Launch lazy future ... done
[10:58:44.398] run() for ‘MulticoreFuture’ ... done
[10:58:44.398] Created future:
[10:58:44.398] plan(): Setting new future strategy stack:
[10:58:44.398] List of future strategies:
[10:58:44.398] 1. sequential:
[10:58:44.398]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:44.398]    - tweaked: FALSE
[10:58:44.398]    - call: NULL
[10:58:44.399] plan(): nbrOfWorkers() = 1
[10:58:44.403] plan(): Setting new future strategy stack:
[10:58:44.403] List of future strategies:
[10:58:44.403] 1. multicore:
[10:58:44.403]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:44.403]    - tweaked: FALSE
[10:58:44.403]    - call: plan(strategy)
[10:58:44.406] plan(): nbrOfWorkers() = 2
[10:58:44.398] MulticoreFuture:
[10:58:44.398] Label: ‘future_by-2’
[10:58:44.398] Expression:
[10:58:44.398] {
[10:58:44.398]     do.call(function(...) {
[10:58:44.398]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:44.398]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:44.398]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:44.398]             on.exit(options(oopts), add = TRUE)
[10:58:44.398]         }
[10:58:44.398]         {
[10:58:44.398]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:44.398]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:44.398]                 ...future.FUN(...future.X_jj, ...)
[10:58:44.398]             })
[10:58:44.398]         }
[10:58:44.398]     }, args = future.call.arguments)
[10:58:44.398] }
[10:58:44.398] Lazy evaluation: FALSE
[10:58:44.398] Asynchronous evaluation: TRUE
[10:58:44.398] Local evaluation: TRUE
[10:58:44.398] Environment: 0x55974f370430
[10:58:44.398] Capture standard output: TRUE
[10:58:44.398] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:44.398] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:44.398] Packages: <none>
[10:58:44.398] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:44.398] Resolved: TRUE
[10:58:44.398] Value: <not collected>
[10:58:44.398] Conditions captured: <none>
[10:58:44.398] Early signaling: FALSE
[10:58:44.398] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:44.398] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:44.407] Chunk #2 of 2 ... DONE
[10:58:44.407] Launching 2 futures (chunks) ... DONE
[10:58:44.407] Resolving 2 futures (chunks) ...
[10:58:44.408] resolve() on list ...
[10:58:44.408]  recursive: 0
[10:58:44.408]  length: 2
[10:58:44.408] 
[10:58:44.408] Future #1
[10:58:44.409] result() for MulticoreFuture ...
[10:58:44.409] result() for MulticoreFuture ...
[10:58:44.410] result() for MulticoreFuture ... done
[10:58:44.410] result() for MulticoreFuture ... done
[10:58:44.410] result() for MulticoreFuture ...
[10:58:44.410] result() for MulticoreFuture ... done
[10:58:44.410] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:44.410] - nx: 2
[10:58:44.410] - relay: TRUE
[10:58:44.411] - stdout: TRUE
[10:58:44.411] - signal: TRUE
[10:58:44.411] - resignal: FALSE
[10:58:44.411] - force: TRUE
[10:58:44.411] - relayed: [n=2] FALSE, FALSE
[10:58:44.411] - queued futures: [n=2] FALSE, FALSE
[10:58:44.411]  - until=1
[10:58:44.411]  - relaying element #1
[10:58:44.412] result() for MulticoreFuture ...
[10:58:44.412] result() for MulticoreFuture ... done
[10:58:44.412] result() for MulticoreFuture ...
[10:58:44.412] result() for MulticoreFuture ... done
[10:58:44.412] result() for MulticoreFuture ...
[10:58:44.412] result() for MulticoreFuture ... done
[10:58:44.412] result() for MulticoreFuture ...
[10:58:44.413] result() for MulticoreFuture ... done
[10:58:44.413] - relayed: [n=2] TRUE, FALSE
[10:58:44.413] - queued futures: [n=2] TRUE, FALSE
[10:58:44.413] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:44.413]  length: 1 (resolved future 1)
[10:58:44.414] Future #2
[10:58:44.414] result() for MulticoreFuture ...
[10:58:44.414] result() for MulticoreFuture ...
[10:58:44.414] result() for MulticoreFuture ... done
[10:58:44.415] result() for MulticoreFuture ... done
[10:58:44.415] result() for MulticoreFuture ...
[10:58:44.415] result() for MulticoreFuture ... done
[10:58:44.415] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:44.415] - nx: 2
[10:58:44.415] - relay: TRUE
[10:58:44.415] - stdout: TRUE
[10:58:44.415] - signal: TRUE
[10:58:44.416] - resignal: FALSE
[10:58:44.416] - force: TRUE
[10:58:44.416] - relayed: [n=2] TRUE, FALSE
[10:58:44.416] - queued futures: [n=2] TRUE, FALSE
[10:58:44.416]  - until=2
[10:58:44.416]  - relaying element #2
[10:58:44.416] result() for MulticoreFuture ...
[10:58:44.416] result() for MulticoreFuture ... done
[10:58:44.417] result() for MulticoreFuture ...
[10:58:44.417] result() for MulticoreFuture ... done
[10:58:44.417] result() for MulticoreFuture ...
[10:58:44.417] result() for MulticoreFuture ... done
[10:58:44.417] result() for MulticoreFuture ...
[10:58:44.417] result() for MulticoreFuture ... done
[10:58:44.417] - relayed: [n=2] TRUE, TRUE
[10:58:44.418] - queued futures: [n=2] TRUE, TRUE
[10:58:44.418] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:44.418]  length: 0 (resolved future 2)
[10:58:44.418] Relaying remaining futures
[10:58:44.418] signalConditionsASAP(NULL, pos=0) ...
[10:58:44.418] - nx: 2
[10:58:44.418] - relay: TRUE
[10:58:44.418] - stdout: TRUE
[10:58:44.418] - signal: TRUE
[10:58:44.418] - resignal: FALSE
[10:58:44.419] - force: TRUE
[10:58:44.419] - relayed: [n=2] TRUE, TRUE
[10:58:44.419] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:44.419] - relayed: [n=2] TRUE, TRUE
[10:58:44.419] - queued futures: [n=2] TRUE, TRUE
[10:58:44.419] signalConditionsASAP(NULL, pos=0) ... done
[10:58:44.419] resolve() on list ... DONE
[10:58:44.419] result() for MulticoreFuture ...
[10:58:44.420] result() for MulticoreFuture ... done
[10:58:44.420] result() for MulticoreFuture ...
[10:58:44.420] result() for MulticoreFuture ... done
[10:58:44.420] result() for MulticoreFuture ...
[10:58:44.420] result() for MulticoreFuture ... done
[10:58:44.420] result() for MulticoreFuture ...
[10:58:44.420] result() for MulticoreFuture ... done
[10:58:44.420]  - Number of value chunks collected: 2
[10:58:44.420] Resolving 2 futures (chunks) ... DONE
[10:58:44.421] Reducing values from 2 chunks ...
[10:58:44.421]  - Number of values collected after concatenation: 3
[10:58:44.421]  - Number of values expected: 3
[10:58:44.421] Reducing values from 2 chunks ... DONE
[10:58:44.421] future_lapply() ... DONE
[10:58:44.421] future_by_internal() ... DONE
[10:58:44.422] future_by_internal() ...
- plan('multisession') ...
[10:58:44.423] plan(): Setting new future strategy stack:
[10:58:44.423] List of future strategies:
[10:58:44.423] 1. multisession:
[10:58:44.423]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:44.423]    - tweaked: FALSE
[10:58:44.423]    - call: plan(strategy)
[10:58:44.424] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:58:44.424] multisession:
[10:58:44.424] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:44.424] - tweaked: FALSE
[10:58:44.424] - call: plan(strategy)
[10:58:44.428] getGlobalsAndPackages() ...
[10:58:44.428] Not searching for globals
[10:58:44.429] - globals: [0] <none>
[10:58:44.429] getGlobalsAndPackages() ... DONE
[10:58:44.932] Packages needed by the future expression (n = 0): <none>
[10:58:44.932] Packages needed by future strategies (n = 0): <none>
[10:58:44.933] {
[10:58:44.933]     {
[10:58:44.933]         {
[10:58:44.933]             ...future.startTime <- base::Sys.time()
[10:58:44.933]             {
[10:58:44.933]                 {
[10:58:44.933]                   {
[10:58:44.933]                     {
[10:58:44.933]                       base::local({
[10:58:44.933]                         has_future <- base::requireNamespace("future", 
[10:58:44.933]                           quietly = TRUE)
[10:58:44.933]                         if (has_future) {
[10:58:44.933]                           ns <- base::getNamespace("future")
[10:58:44.933]                           version <- ns[[".package"]][["version"]]
[10:58:44.933]                           if (is.null(version)) 
[10:58:44.933]                             version <- utils::packageVersion("future")
[10:58:44.933]                         }
[10:58:44.933]                         else {
[10:58:44.933]                           version <- NULL
[10:58:44.933]                         }
[10:58:44.933]                         if (!has_future || version < "1.8.0") {
[10:58:44.933]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:44.933]                             "", base::R.version$version.string), 
[10:58:44.933]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:44.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:44.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:44.933]                               "release", "version")], collapse = " "), 
[10:58:44.933]                             hostname = base::Sys.info()[["nodename"]])
[10:58:44.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:44.933]                             info)
[10:58:44.933]                           info <- base::paste(info, collapse = "; ")
[10:58:44.933]                           if (!has_future) {
[10:58:44.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:44.933]                               info)
[10:58:44.933]                           }
[10:58:44.933]                           else {
[10:58:44.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:44.933]                               info, version)
[10:58:44.933]                           }
[10:58:44.933]                           base::stop(msg)
[10:58:44.933]                         }
[10:58:44.933]                       })
[10:58:44.933]                     }
[10:58:44.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:44.933]                     base::options(mc.cores = 1L)
[10:58:44.933]                   }
[10:58:44.933]                   ...future.strategy.old <- future::plan("list")
[10:58:44.933]                   options(future.plan = NULL)
[10:58:44.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:44.933]                 }
[10:58:44.933]                 ...future.workdir <- getwd()
[10:58:44.933]             }
[10:58:44.933]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:44.933]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:44.933]         }
[10:58:44.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:44.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:44.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:44.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:44.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:44.933]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:44.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:44.933]             base::names(...future.oldOptions))
[10:58:44.933]     }
[10:58:44.933]     if (FALSE) {
[10:58:44.933]     }
[10:58:44.933]     else {
[10:58:44.933]         if (TRUE) {
[10:58:44.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:44.933]                 open = "w")
[10:58:44.933]         }
[10:58:44.933]         else {
[10:58:44.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:44.933]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:44.933]         }
[10:58:44.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:44.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:44.933]             base::sink(type = "output", split = FALSE)
[10:58:44.933]             base::close(...future.stdout)
[10:58:44.933]         }, add = TRUE)
[10:58:44.933]     }
[10:58:44.933]     ...future.frame <- base::sys.nframe()
[10:58:44.933]     ...future.conditions <- base::list()
[10:58:44.933]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:44.933]     if (FALSE) {
[10:58:44.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:44.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:44.933]     }
[10:58:44.933]     ...future.result <- base::tryCatch({
[10:58:44.933]         base::withCallingHandlers({
[10:58:44.933]             ...future.value <- base::withVisible(base::local({
[10:58:44.933]                 ...future.makeSendCondition <- base::local({
[10:58:44.933]                   sendCondition <- NULL
[10:58:44.933]                   function(frame = 1L) {
[10:58:44.933]                     if (is.function(sendCondition)) 
[10:58:44.933]                       return(sendCondition)
[10:58:44.933]                     ns <- getNamespace("parallel")
[10:58:44.933]                     if (exists("sendData", mode = "function", 
[10:58:44.933]                       envir = ns)) {
[10:58:44.933]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:44.933]                         envir = ns)
[10:58:44.933]                       envir <- sys.frame(frame)
[10:58:44.933]                       master <- NULL
[10:58:44.933]                       while (!identical(envir, .GlobalEnv) && 
[10:58:44.933]                         !identical(envir, emptyenv())) {
[10:58:44.933]                         if (exists("master", mode = "list", envir = envir, 
[10:58:44.933]                           inherits = FALSE)) {
[10:58:44.933]                           master <- get("master", mode = "list", 
[10:58:44.933]                             envir = envir, inherits = FALSE)
[10:58:44.933]                           if (inherits(master, c("SOCKnode", 
[10:58:44.933]                             "SOCK0node"))) {
[10:58:44.933]                             sendCondition <<- function(cond) {
[10:58:44.933]                               data <- list(type = "VALUE", value = cond, 
[10:58:44.933]                                 success = TRUE)
[10:58:44.933]                               parallel_sendData(master, data)
[10:58:44.933]                             }
[10:58:44.933]                             return(sendCondition)
[10:58:44.933]                           }
[10:58:44.933]                         }
[10:58:44.933]                         frame <- frame + 1L
[10:58:44.933]                         envir <- sys.frame(frame)
[10:58:44.933]                       }
[10:58:44.933]                     }
[10:58:44.933]                     sendCondition <<- function(cond) NULL
[10:58:44.933]                   }
[10:58:44.933]                 })
[10:58:44.933]                 withCallingHandlers({
[10:58:44.933]                   NA
[10:58:44.933]                 }, immediateCondition = function(cond) {
[10:58:44.933]                   sendCondition <- ...future.makeSendCondition()
[10:58:44.933]                   sendCondition(cond)
[10:58:44.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.933]                   {
[10:58:44.933]                     inherits <- base::inherits
[10:58:44.933]                     invokeRestart <- base::invokeRestart
[10:58:44.933]                     is.null <- base::is.null
[10:58:44.933]                     muffled <- FALSE
[10:58:44.933]                     if (inherits(cond, "message")) {
[10:58:44.933]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:44.933]                       if (muffled) 
[10:58:44.933]                         invokeRestart("muffleMessage")
[10:58:44.933]                     }
[10:58:44.933]                     else if (inherits(cond, "warning")) {
[10:58:44.933]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:44.933]                       if (muffled) 
[10:58:44.933]                         invokeRestart("muffleWarning")
[10:58:44.933]                     }
[10:58:44.933]                     else if (inherits(cond, "condition")) {
[10:58:44.933]                       if (!is.null(pattern)) {
[10:58:44.933]                         computeRestarts <- base::computeRestarts
[10:58:44.933]                         grepl <- base::grepl
[10:58:44.933]                         restarts <- computeRestarts(cond)
[10:58:44.933]                         for (restart in restarts) {
[10:58:44.933]                           name <- restart$name
[10:58:44.933]                           if (is.null(name)) 
[10:58:44.933]                             next
[10:58:44.933]                           if (!grepl(pattern, name)) 
[10:58:44.933]                             next
[10:58:44.933]                           invokeRestart(restart)
[10:58:44.933]                           muffled <- TRUE
[10:58:44.933]                           break
[10:58:44.933]                         }
[10:58:44.933]                       }
[10:58:44.933]                     }
[10:58:44.933]                     invisible(muffled)
[10:58:44.933]                   }
[10:58:44.933]                   muffleCondition(cond)
[10:58:44.933]                 })
[10:58:44.933]             }))
[10:58:44.933]             future::FutureResult(value = ...future.value$value, 
[10:58:44.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.933]                   ...future.rng), globalenv = if (FALSE) 
[10:58:44.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:44.933]                     ...future.globalenv.names))
[10:58:44.933]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:44.933]         }, condition = base::local({
[10:58:44.933]             c <- base::c
[10:58:44.933]             inherits <- base::inherits
[10:58:44.933]             invokeRestart <- base::invokeRestart
[10:58:44.933]             length <- base::length
[10:58:44.933]             list <- base::list
[10:58:44.933]             seq.int <- base::seq.int
[10:58:44.933]             signalCondition <- base::signalCondition
[10:58:44.933]             sys.calls <- base::sys.calls
[10:58:44.933]             `[[` <- base::`[[`
[10:58:44.933]             `+` <- base::`+`
[10:58:44.933]             `<<-` <- base::`<<-`
[10:58:44.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:44.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:44.933]                   3L)]
[10:58:44.933]             }
[10:58:44.933]             function(cond) {
[10:58:44.933]                 is_error <- inherits(cond, "error")
[10:58:44.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:44.933]                   NULL)
[10:58:44.933]                 if (is_error) {
[10:58:44.933]                   sessionInformation <- function() {
[10:58:44.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:44.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:44.933]                       search = base::search(), system = base::Sys.info())
[10:58:44.933]                   }
[10:58:44.933]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:44.933]                     cond$call), session = sessionInformation(), 
[10:58:44.933]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:44.933]                   signalCondition(cond)
[10:58:44.933]                 }
[10:58:44.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:44.933]                 "immediateCondition"))) {
[10:58:44.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:44.933]                   ...future.conditions[[length(...future.conditions) + 
[10:58:44.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:44.933]                   if (TRUE && !signal) {
[10:58:44.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.933]                     {
[10:58:44.933]                       inherits <- base::inherits
[10:58:44.933]                       invokeRestart <- base::invokeRestart
[10:58:44.933]                       is.null <- base::is.null
[10:58:44.933]                       muffled <- FALSE
[10:58:44.933]                       if (inherits(cond, "message")) {
[10:58:44.933]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.933]                         if (muffled) 
[10:58:44.933]                           invokeRestart("muffleMessage")
[10:58:44.933]                       }
[10:58:44.933]                       else if (inherits(cond, "warning")) {
[10:58:44.933]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.933]                         if (muffled) 
[10:58:44.933]                           invokeRestart("muffleWarning")
[10:58:44.933]                       }
[10:58:44.933]                       else if (inherits(cond, "condition")) {
[10:58:44.933]                         if (!is.null(pattern)) {
[10:58:44.933]                           computeRestarts <- base::computeRestarts
[10:58:44.933]                           grepl <- base::grepl
[10:58:44.933]                           restarts <- computeRestarts(cond)
[10:58:44.933]                           for (restart in restarts) {
[10:58:44.933]                             name <- restart$name
[10:58:44.933]                             if (is.null(name)) 
[10:58:44.933]                               next
[10:58:44.933]                             if (!grepl(pattern, name)) 
[10:58:44.933]                               next
[10:58:44.933]                             invokeRestart(restart)
[10:58:44.933]                             muffled <- TRUE
[10:58:44.933]                             break
[10:58:44.933]                           }
[10:58:44.933]                         }
[10:58:44.933]                       }
[10:58:44.933]                       invisible(muffled)
[10:58:44.933]                     }
[10:58:44.933]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.933]                   }
[10:58:44.933]                 }
[10:58:44.933]                 else {
[10:58:44.933]                   if (TRUE) {
[10:58:44.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:44.933]                     {
[10:58:44.933]                       inherits <- base::inherits
[10:58:44.933]                       invokeRestart <- base::invokeRestart
[10:58:44.933]                       is.null <- base::is.null
[10:58:44.933]                       muffled <- FALSE
[10:58:44.933]                       if (inherits(cond, "message")) {
[10:58:44.933]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:44.933]                         if (muffled) 
[10:58:44.933]                           invokeRestart("muffleMessage")
[10:58:44.933]                       }
[10:58:44.933]                       else if (inherits(cond, "warning")) {
[10:58:44.933]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:44.933]                         if (muffled) 
[10:58:44.933]                           invokeRestart("muffleWarning")
[10:58:44.933]                       }
[10:58:44.933]                       else if (inherits(cond, "condition")) {
[10:58:44.933]                         if (!is.null(pattern)) {
[10:58:44.933]                           computeRestarts <- base::computeRestarts
[10:58:44.933]                           grepl <- base::grepl
[10:58:44.933]                           restarts <- computeRestarts(cond)
[10:58:44.933]                           for (restart in restarts) {
[10:58:44.933]                             name <- restart$name
[10:58:44.933]                             if (is.null(name)) 
[10:58:44.933]                               next
[10:58:44.933]                             if (!grepl(pattern, name)) 
[10:58:44.933]                               next
[10:58:44.933]                             invokeRestart(restart)
[10:58:44.933]                             muffled <- TRUE
[10:58:44.933]                             break
[10:58:44.933]                           }
[10:58:44.933]                         }
[10:58:44.933]                       }
[10:58:44.933]                       invisible(muffled)
[10:58:44.933]                     }
[10:58:44.933]                     muffleCondition(cond, pattern = "^muffle")
[10:58:44.933]                   }
[10:58:44.933]                 }
[10:58:44.933]             }
[10:58:44.933]         }))
[10:58:44.933]     }, error = function(ex) {
[10:58:44.933]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:44.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:44.933]                 ...future.rng), started = ...future.startTime, 
[10:58:44.933]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:44.933]             version = "1.8"), class = "FutureResult")
[10:58:44.933]     }, finally = {
[10:58:44.933]         if (!identical(...future.workdir, getwd())) 
[10:58:44.933]             setwd(...future.workdir)
[10:58:44.933]         {
[10:58:44.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:44.933]                 ...future.oldOptions$nwarnings <- NULL
[10:58:44.933]             }
[10:58:44.933]             base::options(...future.oldOptions)
[10:58:44.933]             if (.Platform$OS.type == "windows") {
[10:58:44.933]                 old_names <- names(...future.oldEnvVars)
[10:58:44.933]                 envs <- base::Sys.getenv()
[10:58:44.933]                 names <- names(envs)
[10:58:44.933]                 common <- intersect(names, old_names)
[10:58:44.933]                 added <- setdiff(names, old_names)
[10:58:44.933]                 removed <- setdiff(old_names, names)
[10:58:44.933]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:44.933]                   envs[common]]
[10:58:44.933]                 NAMES <- toupper(changed)
[10:58:44.933]                 args <- list()
[10:58:44.933]                 for (kk in seq_along(NAMES)) {
[10:58:44.933]                   name <- changed[[kk]]
[10:58:44.933]                   NAME <- NAMES[[kk]]
[10:58:44.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.933]                     next
[10:58:44.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.933]                 }
[10:58:44.933]                 NAMES <- toupper(added)
[10:58:44.933]                 for (kk in seq_along(NAMES)) {
[10:58:44.933]                   name <- added[[kk]]
[10:58:44.933]                   NAME <- NAMES[[kk]]
[10:58:44.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.933]                     next
[10:58:44.933]                   args[[name]] <- ""
[10:58:44.933]                 }
[10:58:44.933]                 NAMES <- toupper(removed)
[10:58:44.933]                 for (kk in seq_along(NAMES)) {
[10:58:44.933]                   name <- removed[[kk]]
[10:58:44.933]                   NAME <- NAMES[[kk]]
[10:58:44.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:44.933]                     next
[10:58:44.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:44.933]                 }
[10:58:44.933]                 if (length(args) > 0) 
[10:58:44.933]                   base::do.call(base::Sys.setenv, args = args)
[10:58:44.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:44.933]             }
[10:58:44.933]             else {
[10:58:44.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:44.933]             }
[10:58:44.933]             {
[10:58:44.933]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:44.933]                   0L) {
[10:58:44.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:44.933]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:44.933]                   base::options(opts)
[10:58:44.933]                 }
[10:58:44.933]                 {
[10:58:44.933]                   {
[10:58:44.933]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:44.933]                     NULL
[10:58:44.933]                   }
[10:58:44.933]                   options(future.plan = NULL)
[10:58:44.933]                   if (is.na(NA_character_)) 
[10:58:44.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:44.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:44.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:44.933]                     .init = FALSE)
[10:58:44.933]                 }
[10:58:44.933]             }
[10:58:44.933]         }
[10:58:44.933]     })
[10:58:44.933]     if (TRUE) {
[10:58:44.933]         base::sink(type = "output", split = FALSE)
[10:58:44.933]         if (TRUE) {
[10:58:44.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:44.933]         }
[10:58:44.933]         else {
[10:58:44.933]             ...future.result["stdout"] <- base::list(NULL)
[10:58:44.933]         }
[10:58:44.933]         base::close(...future.stdout)
[10:58:44.933]         ...future.stdout <- NULL
[10:58:44.933]     }
[10:58:44.933]     ...future.result$conditions <- ...future.conditions
[10:58:44.933]     ...future.result$finished <- base::Sys.time()
[10:58:44.933]     ...future.result
[10:58:44.933] }
[10:58:44.985] MultisessionFuture started
[10:58:44.985] result() for ClusterFuture ...
[10:58:44.986] receiveMessageFromWorker() for ClusterFuture ...
[10:58:44.986] - Validating connection of MultisessionFuture
[10:58:45.016] - received message: FutureResult
[10:58:45.016] - Received FutureResult
[10:58:45.016] - Erased future from FutureRegistry
[10:58:45.017] result() for ClusterFuture ...
[10:58:45.017] - result already collected: FutureResult
[10:58:45.017] result() for ClusterFuture ... done
[10:58:45.017] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.017] result() for ClusterFuture ... done
[10:58:45.017] result() for ClusterFuture ...
[10:58:45.017] - result already collected: FutureResult
[10:58:45.017] result() for ClusterFuture ... done
[10:58:45.017] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:58:45.019] plan(): nbrOfWorkers() = 2
[10:58:45.019] future_by_internal() ...
[10:58:45.019] future_lapply() ...
[10:58:45.021] Number of chunks: 2
[10:58:45.021] getGlobalsAndPackagesXApply() ...
[10:58:45.021]  - future.globals: TRUE
[10:58:45.021] getGlobalsAndPackages() ...
[10:58:45.021] Searching for globals...
[10:58:45.022] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:45.023] Searching for globals ... DONE
[10:58:45.023] Resolving globals: FALSE
[10:58:45.023] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:45.023] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:45.023] - globals: [1] ‘FUN’
[10:58:45.024] 
[10:58:45.024] getGlobalsAndPackages() ... DONE
[10:58:45.024]  - globals found/used: [n=1] ‘FUN’
[10:58:45.024]  - needed namespaces: [n=0] 
[10:58:45.024] Finding globals ... DONE
[10:58:45.024]  - use_args: TRUE
[10:58:45.024]  - Getting '...' globals ...
[10:58:45.024] resolve() on list ...
[10:58:45.024]  recursive: 0
[10:58:45.024]  length: 1
[10:58:45.025]  elements: ‘...’
[10:58:45.025]  length: 0 (resolved future 1)
[10:58:45.025] resolve() on list ... DONE
[10:58:45.025]    - '...' content: [n=0] 
[10:58:45.025] List of 1
[10:58:45.025]  $ ...: list()
[10:58:45.025]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.025]  - attr(*, "where")=List of 1
[10:58:45.025]   ..$ ...:<environment: 0x55974fef7b20> 
[10:58:45.025]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.025]  - attr(*, "resolved")= logi TRUE
[10:58:45.025]  - attr(*, "total_size")= num NA
[10:58:45.027]  - Getting '...' globals ... DONE
[10:58:45.027] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:45.028] List of 2
[10:58:45.028]  $ ...future.FUN:function (object, ...)  
[10:58:45.028]  $ ...          : list()
[10:58:45.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.028]  - attr(*, "where")=List of 2
[10:58:45.028]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:45.028]   ..$ ...          :<environment: 0x55974fef7b20> 
[10:58:45.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.028]  - attr(*, "resolved")= logi FALSE
[10:58:45.028]  - attr(*, "total_size")= num 15670
[10:58:45.030] Packages to be attached in all futures: [n=0] 
[10:58:45.030] getGlobalsAndPackagesXApply() ... DONE
[10:58:45.030] Number of futures (= number of chunks): 2
[10:58:45.030] Launching 2 futures (chunks) ...
[10:58:45.030] Chunk #1 of 2 ...
[10:58:45.031]  - Finding globals in 'X' for chunk #1 ...
[10:58:45.031] getGlobalsAndPackages() ...
[10:58:45.031] Searching for globals...
[10:58:45.031] 
[10:58:45.031] Searching for globals ... DONE
[10:58:45.031] - globals: [0] <none>
[10:58:45.031] getGlobalsAndPackages() ... DONE
[10:58:45.031]    + additional globals found: [n=0] 
[10:58:45.032]    + additional namespaces needed: [n=0] 
[10:58:45.032]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:45.032]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.032]  - seeds: <none>
[10:58:45.032]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.032] getGlobalsAndPackages() ...
[10:58:45.032] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.032] Resolving globals: FALSE
[10:58:45.032] Tweak future expression to call with '...' arguments ...
[10:58:45.032] {
[10:58:45.032]     do.call(function(...) {
[10:58:45.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.032]             on.exit(options(oopts), add = TRUE)
[10:58:45.032]         }
[10:58:45.032]         {
[10:58:45.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.032]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.032]             })
[10:58:45.032]         }
[10:58:45.032]     }, args = future.call.arguments)
[10:58:45.032] }
[10:58:45.033] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.033] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.033] 
[10:58:45.033] getGlobalsAndPackages() ... DONE
[10:58:45.033] run() for ‘Future’ ...
[10:58:45.033] - state: ‘created’
[10:58:45.034] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.047]   - Field: ‘node’
[10:58:45.048]   - Field: ‘label’
[10:58:45.048]   - Field: ‘local’
[10:58:45.048]   - Field: ‘owner’
[10:58:45.048]   - Field: ‘envir’
[10:58:45.048]   - Field: ‘workers’
[10:58:45.048]   - Field: ‘packages’
[10:58:45.048]   - Field: ‘gc’
[10:58:45.048]   - Field: ‘conditions’
[10:58:45.048]   - Field: ‘persistent’
[10:58:45.048]   - Field: ‘expr’
[10:58:45.048]   - Field: ‘uuid’
[10:58:45.048]   - Field: ‘seed’
[10:58:45.049]   - Field: ‘version’
[10:58:45.049]   - Field: ‘result’
[10:58:45.049]   - Field: ‘asynchronous’
[10:58:45.049]   - Field: ‘calls’
[10:58:45.049]   - Field: ‘globals’
[10:58:45.049]   - Field: ‘stdout’
[10:58:45.049]   - Field: ‘earlySignal’
[10:58:45.049]   - Field: ‘lazy’
[10:58:45.049]   - Field: ‘state’
[10:58:45.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.049] - Launch lazy future ...
[10:58:45.050] Packages needed by the future expression (n = 0): <none>
[10:58:45.050] Packages needed by future strategies (n = 0): <none>
[10:58:45.050] {
[10:58:45.050]     {
[10:58:45.050]         {
[10:58:45.050]             ...future.startTime <- base::Sys.time()
[10:58:45.050]             {
[10:58:45.050]                 {
[10:58:45.050]                   {
[10:58:45.050]                     {
[10:58:45.050]                       base::local({
[10:58:45.050]                         has_future <- base::requireNamespace("future", 
[10:58:45.050]                           quietly = TRUE)
[10:58:45.050]                         if (has_future) {
[10:58:45.050]                           ns <- base::getNamespace("future")
[10:58:45.050]                           version <- ns[[".package"]][["version"]]
[10:58:45.050]                           if (is.null(version)) 
[10:58:45.050]                             version <- utils::packageVersion("future")
[10:58:45.050]                         }
[10:58:45.050]                         else {
[10:58:45.050]                           version <- NULL
[10:58:45.050]                         }
[10:58:45.050]                         if (!has_future || version < "1.8.0") {
[10:58:45.050]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.050]                             "", base::R.version$version.string), 
[10:58:45.050]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:45.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:45.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.050]                               "release", "version")], collapse = " "), 
[10:58:45.050]                             hostname = base::Sys.info()[["nodename"]])
[10:58:45.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.050]                             info)
[10:58:45.050]                           info <- base::paste(info, collapse = "; ")
[10:58:45.050]                           if (!has_future) {
[10:58:45.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.050]                               info)
[10:58:45.050]                           }
[10:58:45.050]                           else {
[10:58:45.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.050]                               info, version)
[10:58:45.050]                           }
[10:58:45.050]                           base::stop(msg)
[10:58:45.050]                         }
[10:58:45.050]                       })
[10:58:45.050]                     }
[10:58:45.050]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.050]                     base::options(mc.cores = 1L)
[10:58:45.050]                   }
[10:58:45.050]                   ...future.strategy.old <- future::plan("list")
[10:58:45.050]                   options(future.plan = NULL)
[10:58:45.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.050]                 }
[10:58:45.050]                 ...future.workdir <- getwd()
[10:58:45.050]             }
[10:58:45.050]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.050]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.050]         }
[10:58:45.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.050]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.050]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.050]             base::names(...future.oldOptions))
[10:58:45.050]     }
[10:58:45.050]     if (FALSE) {
[10:58:45.050]     }
[10:58:45.050]     else {
[10:58:45.050]         if (TRUE) {
[10:58:45.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.050]                 open = "w")
[10:58:45.050]         }
[10:58:45.050]         else {
[10:58:45.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.050]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.050]         }
[10:58:45.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.050]             base::sink(type = "output", split = FALSE)
[10:58:45.050]             base::close(...future.stdout)
[10:58:45.050]         }, add = TRUE)
[10:58:45.050]     }
[10:58:45.050]     ...future.frame <- base::sys.nframe()
[10:58:45.050]     ...future.conditions <- base::list()
[10:58:45.050]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.050]     if (FALSE) {
[10:58:45.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.050]     }
[10:58:45.050]     ...future.result <- base::tryCatch({
[10:58:45.050]         base::withCallingHandlers({
[10:58:45.050]             ...future.value <- base::withVisible(base::local({
[10:58:45.050]                 ...future.makeSendCondition <- base::local({
[10:58:45.050]                   sendCondition <- NULL
[10:58:45.050]                   function(frame = 1L) {
[10:58:45.050]                     if (is.function(sendCondition)) 
[10:58:45.050]                       return(sendCondition)
[10:58:45.050]                     ns <- getNamespace("parallel")
[10:58:45.050]                     if (exists("sendData", mode = "function", 
[10:58:45.050]                       envir = ns)) {
[10:58:45.050]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.050]                         envir = ns)
[10:58:45.050]                       envir <- sys.frame(frame)
[10:58:45.050]                       master <- NULL
[10:58:45.050]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.050]                         !identical(envir, emptyenv())) {
[10:58:45.050]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.050]                           inherits = FALSE)) {
[10:58:45.050]                           master <- get("master", mode = "list", 
[10:58:45.050]                             envir = envir, inherits = FALSE)
[10:58:45.050]                           if (inherits(master, c("SOCKnode", 
[10:58:45.050]                             "SOCK0node"))) {
[10:58:45.050]                             sendCondition <<- function(cond) {
[10:58:45.050]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.050]                                 success = TRUE)
[10:58:45.050]                               parallel_sendData(master, data)
[10:58:45.050]                             }
[10:58:45.050]                             return(sendCondition)
[10:58:45.050]                           }
[10:58:45.050]                         }
[10:58:45.050]                         frame <- frame + 1L
[10:58:45.050]                         envir <- sys.frame(frame)
[10:58:45.050]                       }
[10:58:45.050]                     }
[10:58:45.050]                     sendCondition <<- function(cond) NULL
[10:58:45.050]                   }
[10:58:45.050]                 })
[10:58:45.050]                 withCallingHandlers({
[10:58:45.050]                   {
[10:58:45.050]                     do.call(function(...) {
[10:58:45.050]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.050]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.050]                         ...future.globals.maxSize)) {
[10:58:45.050]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.050]                         on.exit(options(oopts), add = TRUE)
[10:58:45.050]                       }
[10:58:45.050]                       {
[10:58:45.050]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.050]                           FUN = function(jj) {
[10:58:45.050]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.050]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.050]                           })
[10:58:45.050]                       }
[10:58:45.050]                     }, args = future.call.arguments)
[10:58:45.050]                   }
[10:58:45.050]                 }, immediateCondition = function(cond) {
[10:58:45.050]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.050]                   sendCondition(cond)
[10:58:45.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.050]                   {
[10:58:45.050]                     inherits <- base::inherits
[10:58:45.050]                     invokeRestart <- base::invokeRestart
[10:58:45.050]                     is.null <- base::is.null
[10:58:45.050]                     muffled <- FALSE
[10:58:45.050]                     if (inherits(cond, "message")) {
[10:58:45.050]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.050]                       if (muffled) 
[10:58:45.050]                         invokeRestart("muffleMessage")
[10:58:45.050]                     }
[10:58:45.050]                     else if (inherits(cond, "warning")) {
[10:58:45.050]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.050]                       if (muffled) 
[10:58:45.050]                         invokeRestart("muffleWarning")
[10:58:45.050]                     }
[10:58:45.050]                     else if (inherits(cond, "condition")) {
[10:58:45.050]                       if (!is.null(pattern)) {
[10:58:45.050]                         computeRestarts <- base::computeRestarts
[10:58:45.050]                         grepl <- base::grepl
[10:58:45.050]                         restarts <- computeRestarts(cond)
[10:58:45.050]                         for (restart in restarts) {
[10:58:45.050]                           name <- restart$name
[10:58:45.050]                           if (is.null(name)) 
[10:58:45.050]                             next
[10:58:45.050]                           if (!grepl(pattern, name)) 
[10:58:45.050]                             next
[10:58:45.050]                           invokeRestart(restart)
[10:58:45.050]                           muffled <- TRUE
[10:58:45.050]                           break
[10:58:45.050]                         }
[10:58:45.050]                       }
[10:58:45.050]                     }
[10:58:45.050]                     invisible(muffled)
[10:58:45.050]                   }
[10:58:45.050]                   muffleCondition(cond)
[10:58:45.050]                 })
[10:58:45.050]             }))
[10:58:45.050]             future::FutureResult(value = ...future.value$value, 
[10:58:45.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.050]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.050]                     ...future.globalenv.names))
[10:58:45.050]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.050]         }, condition = base::local({
[10:58:45.050]             c <- base::c
[10:58:45.050]             inherits <- base::inherits
[10:58:45.050]             invokeRestart <- base::invokeRestart
[10:58:45.050]             length <- base::length
[10:58:45.050]             list <- base::list
[10:58:45.050]             seq.int <- base::seq.int
[10:58:45.050]             signalCondition <- base::signalCondition
[10:58:45.050]             sys.calls <- base::sys.calls
[10:58:45.050]             `[[` <- base::`[[`
[10:58:45.050]             `+` <- base::`+`
[10:58:45.050]             `<<-` <- base::`<<-`
[10:58:45.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.050]                   3L)]
[10:58:45.050]             }
[10:58:45.050]             function(cond) {
[10:58:45.050]                 is_error <- inherits(cond, "error")
[10:58:45.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.050]                   NULL)
[10:58:45.050]                 if (is_error) {
[10:58:45.050]                   sessionInformation <- function() {
[10:58:45.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.050]                       search = base::search(), system = base::Sys.info())
[10:58:45.050]                   }
[10:58:45.050]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.050]                     cond$call), session = sessionInformation(), 
[10:58:45.050]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.050]                   signalCondition(cond)
[10:58:45.050]                 }
[10:58:45.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.050]                 "immediateCondition"))) {
[10:58:45.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.050]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.050]                   if (TRUE && !signal) {
[10:58:45.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.050]                     {
[10:58:45.050]                       inherits <- base::inherits
[10:58:45.050]                       invokeRestart <- base::invokeRestart
[10:58:45.050]                       is.null <- base::is.null
[10:58:45.050]                       muffled <- FALSE
[10:58:45.050]                       if (inherits(cond, "message")) {
[10:58:45.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.050]                         if (muffled) 
[10:58:45.050]                           invokeRestart("muffleMessage")
[10:58:45.050]                       }
[10:58:45.050]                       else if (inherits(cond, "warning")) {
[10:58:45.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.050]                         if (muffled) 
[10:58:45.050]                           invokeRestart("muffleWarning")
[10:58:45.050]                       }
[10:58:45.050]                       else if (inherits(cond, "condition")) {
[10:58:45.050]                         if (!is.null(pattern)) {
[10:58:45.050]                           computeRestarts <- base::computeRestarts
[10:58:45.050]                           grepl <- base::grepl
[10:58:45.050]                           restarts <- computeRestarts(cond)
[10:58:45.050]                           for (restart in restarts) {
[10:58:45.050]                             name <- restart$name
[10:58:45.050]                             if (is.null(name)) 
[10:58:45.050]                               next
[10:58:45.050]                             if (!grepl(pattern, name)) 
[10:58:45.050]                               next
[10:58:45.050]                             invokeRestart(restart)
[10:58:45.050]                             muffled <- TRUE
[10:58:45.050]                             break
[10:58:45.050]                           }
[10:58:45.050]                         }
[10:58:45.050]                       }
[10:58:45.050]                       invisible(muffled)
[10:58:45.050]                     }
[10:58:45.050]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.050]                   }
[10:58:45.050]                 }
[10:58:45.050]                 else {
[10:58:45.050]                   if (TRUE) {
[10:58:45.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.050]                     {
[10:58:45.050]                       inherits <- base::inherits
[10:58:45.050]                       invokeRestart <- base::invokeRestart
[10:58:45.050]                       is.null <- base::is.null
[10:58:45.050]                       muffled <- FALSE
[10:58:45.050]                       if (inherits(cond, "message")) {
[10:58:45.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.050]                         if (muffled) 
[10:58:45.050]                           invokeRestart("muffleMessage")
[10:58:45.050]                       }
[10:58:45.050]                       else if (inherits(cond, "warning")) {
[10:58:45.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.050]                         if (muffled) 
[10:58:45.050]                           invokeRestart("muffleWarning")
[10:58:45.050]                       }
[10:58:45.050]                       else if (inherits(cond, "condition")) {
[10:58:45.050]                         if (!is.null(pattern)) {
[10:58:45.050]                           computeRestarts <- base::computeRestarts
[10:58:45.050]                           grepl <- base::grepl
[10:58:45.050]                           restarts <- computeRestarts(cond)
[10:58:45.050]                           for (restart in restarts) {
[10:58:45.050]                             name <- restart$name
[10:58:45.050]                             if (is.null(name)) 
[10:58:45.050]                               next
[10:58:45.050]                             if (!grepl(pattern, name)) 
[10:58:45.050]                               next
[10:58:45.050]                             invokeRestart(restart)
[10:58:45.050]                             muffled <- TRUE
[10:58:45.050]                             break
[10:58:45.050]                           }
[10:58:45.050]                         }
[10:58:45.050]                       }
[10:58:45.050]                       invisible(muffled)
[10:58:45.050]                     }
[10:58:45.050]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.050]                   }
[10:58:45.050]                 }
[10:58:45.050]             }
[10:58:45.050]         }))
[10:58:45.050]     }, error = function(ex) {
[10:58:45.050]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.050]                 ...future.rng), started = ...future.startTime, 
[10:58:45.050]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.050]             version = "1.8"), class = "FutureResult")
[10:58:45.050]     }, finally = {
[10:58:45.050]         if (!identical(...future.workdir, getwd())) 
[10:58:45.050]             setwd(...future.workdir)
[10:58:45.050]         {
[10:58:45.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.050]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.050]             }
[10:58:45.050]             base::options(...future.oldOptions)
[10:58:45.050]             if (.Platform$OS.type == "windows") {
[10:58:45.050]                 old_names <- names(...future.oldEnvVars)
[10:58:45.050]                 envs <- base::Sys.getenv()
[10:58:45.050]                 names <- names(envs)
[10:58:45.050]                 common <- intersect(names, old_names)
[10:58:45.050]                 added <- setdiff(names, old_names)
[10:58:45.050]                 removed <- setdiff(old_names, names)
[10:58:45.050]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.050]                   envs[common]]
[10:58:45.050]                 NAMES <- toupper(changed)
[10:58:45.050]                 args <- list()
[10:58:45.050]                 for (kk in seq_along(NAMES)) {
[10:58:45.050]                   name <- changed[[kk]]
[10:58:45.050]                   NAME <- NAMES[[kk]]
[10:58:45.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.050]                     next
[10:58:45.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.050]                 }
[10:58:45.050]                 NAMES <- toupper(added)
[10:58:45.050]                 for (kk in seq_along(NAMES)) {
[10:58:45.050]                   name <- added[[kk]]
[10:58:45.050]                   NAME <- NAMES[[kk]]
[10:58:45.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.050]                     next
[10:58:45.050]                   args[[name]] <- ""
[10:58:45.050]                 }
[10:58:45.050]                 NAMES <- toupper(removed)
[10:58:45.050]                 for (kk in seq_along(NAMES)) {
[10:58:45.050]                   name <- removed[[kk]]
[10:58:45.050]                   NAME <- NAMES[[kk]]
[10:58:45.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.050]                     next
[10:58:45.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.050]                 }
[10:58:45.050]                 if (length(args) > 0) 
[10:58:45.050]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.050]             }
[10:58:45.050]             else {
[10:58:45.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.050]             }
[10:58:45.050]             {
[10:58:45.050]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.050]                   0L) {
[10:58:45.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.050]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.050]                   base::options(opts)
[10:58:45.050]                 }
[10:58:45.050]                 {
[10:58:45.050]                   {
[10:58:45.050]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.050]                     NULL
[10:58:45.050]                   }
[10:58:45.050]                   options(future.plan = NULL)
[10:58:45.050]                   if (is.na(NA_character_)) 
[10:58:45.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.050]                     .init = FALSE)
[10:58:45.050]                 }
[10:58:45.050]             }
[10:58:45.050]         }
[10:58:45.050]     })
[10:58:45.050]     if (TRUE) {
[10:58:45.050]         base::sink(type = "output", split = FALSE)
[10:58:45.050]         if (TRUE) {
[10:58:45.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.050]         }
[10:58:45.050]         else {
[10:58:45.050]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.050]         }
[10:58:45.050]         base::close(...future.stdout)
[10:58:45.050]         ...future.stdout <- NULL
[10:58:45.050]     }
[10:58:45.050]     ...future.result$conditions <- ...future.conditions
[10:58:45.050]     ...future.result$finished <- base::Sys.time()
[10:58:45.050]     ...future.result
[10:58:45.050] }
[10:58:45.053] Exporting 5 global objects (1.40 KiB) to cluster node #1 ...
[10:58:45.053] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[10:58:45.054] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[10:58:45.054] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:45.054] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:45.054] Exporting ‘...future.elements_ii’ (564 bytes) to cluster node #1 ...
[10:58:45.054] Exporting ‘...future.elements_ii’ (564 bytes) to cluster node #1 ... DONE
[10:58:45.055] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:45.055] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.055] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:45.055] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.055] Exporting 5 global objects (1.40 KiB) to cluster node #1 ... DONE
[10:58:45.056] MultisessionFuture started
[10:58:45.056] - Launch lazy future ... done
[10:58:45.056] run() for ‘MultisessionFuture’ ... done
[10:58:45.056] Created future:
[10:58:45.056] MultisessionFuture:
[10:58:45.056] Label: ‘future_by-1’
[10:58:45.056] Expression:
[10:58:45.056] {
[10:58:45.056]     do.call(function(...) {
[10:58:45.056]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.056]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.056]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.056]             on.exit(options(oopts), add = TRUE)
[10:58:45.056]         }
[10:58:45.056]         {
[10:58:45.056]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.056]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.056]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.056]             })
[10:58:45.056]         }
[10:58:45.056]     }, args = future.call.arguments)
[10:58:45.056] }
[10:58:45.056] Lazy evaluation: FALSE
[10:58:45.056] Asynchronous evaluation: TRUE
[10:58:45.056] Local evaluation: TRUE
[10:58:45.056] Environment: R_GlobalEnv
[10:58:45.056] Capture standard output: TRUE
[10:58:45.056] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.056] Globals: 5 objects totaling 996 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 564 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.056] Packages: <none>
[10:58:45.056] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.056] Resolved: FALSE
[10:58:45.056] Value: <not collected>
[10:58:45.056] Conditions captured: <none>
[10:58:45.056] Early signaling: FALSE
[10:58:45.056] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.056] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.068] Chunk #1 of 2 ... DONE
[10:58:45.068] Chunk #2 of 2 ...
[10:58:45.068]  - Finding globals in 'X' for chunk #2 ...
[10:58:45.068] getGlobalsAndPackages() ...
[10:58:45.068] Searching for globals...
[10:58:45.069] 
[10:58:45.069] Searching for globals ... DONE
[10:58:45.069] - globals: [0] <none>
[10:58:45.069] getGlobalsAndPackages() ... DONE
[10:58:45.069]    + additional globals found: [n=0] 
[10:58:45.069]    + additional namespaces needed: [n=0] 
[10:58:45.069]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:45.069]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.069]  - seeds: <none>
[10:58:45.070]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.070] getGlobalsAndPackages() ...
[10:58:45.070] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.070] Resolving globals: FALSE
[10:58:45.070] Tweak future expression to call with '...' arguments ...
[10:58:45.070] {
[10:58:45.070]     do.call(function(...) {
[10:58:45.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.070]             on.exit(options(oopts), add = TRUE)
[10:58:45.070]         }
[10:58:45.070]         {
[10:58:45.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.070]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.070]             })
[10:58:45.070]         }
[10:58:45.070]     }, args = future.call.arguments)
[10:58:45.070] }
[10:58:45.070] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.071] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.071] 
[10:58:45.071] getGlobalsAndPackages() ... DONE
[10:58:45.071] run() for ‘Future’ ...
[10:58:45.071] - state: ‘created’
[10:58:45.071] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.085] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.085]   - Field: ‘node’
[10:58:45.086]   - Field: ‘label’
[10:58:45.086]   - Field: ‘local’
[10:58:45.086]   - Field: ‘owner’
[10:58:45.086]   - Field: ‘envir’
[10:58:45.086]   - Field: ‘workers’
[10:58:45.086]   - Field: ‘packages’
[10:58:45.086]   - Field: ‘gc’
[10:58:45.086]   - Field: ‘conditions’
[10:58:45.086]   - Field: ‘persistent’
[10:58:45.086]   - Field: ‘expr’
[10:58:45.086]   - Field: ‘uuid’
[10:58:45.087]   - Field: ‘seed’
[10:58:45.087]   - Field: ‘version’
[10:58:45.087]   - Field: ‘result’
[10:58:45.087]   - Field: ‘asynchronous’
[10:58:45.087]   - Field: ‘calls’
[10:58:45.087]   - Field: ‘globals’
[10:58:45.087]   - Field: ‘stdout’
[10:58:45.087]   - Field: ‘earlySignal’
[10:58:45.087]   - Field: ‘lazy’
[10:58:45.087]   - Field: ‘state’
[10:58:45.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.087] - Launch lazy future ...
[10:58:45.088] Packages needed by the future expression (n = 0): <none>
[10:58:45.088] Packages needed by future strategies (n = 0): <none>
[10:58:45.088] {
[10:58:45.088]     {
[10:58:45.088]         {
[10:58:45.088]             ...future.startTime <- base::Sys.time()
[10:58:45.088]             {
[10:58:45.088]                 {
[10:58:45.088]                   {
[10:58:45.088]                     {
[10:58:45.088]                       base::local({
[10:58:45.088]                         has_future <- base::requireNamespace("future", 
[10:58:45.088]                           quietly = TRUE)
[10:58:45.088]                         if (has_future) {
[10:58:45.088]                           ns <- base::getNamespace("future")
[10:58:45.088]                           version <- ns[[".package"]][["version"]]
[10:58:45.088]                           if (is.null(version)) 
[10:58:45.088]                             version <- utils::packageVersion("future")
[10:58:45.088]                         }
[10:58:45.088]                         else {
[10:58:45.088]                           version <- NULL
[10:58:45.088]                         }
[10:58:45.088]                         if (!has_future || version < "1.8.0") {
[10:58:45.088]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.088]                             "", base::R.version$version.string), 
[10:58:45.088]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:45.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:45.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.088]                               "release", "version")], collapse = " "), 
[10:58:45.088]                             hostname = base::Sys.info()[["nodename"]])
[10:58:45.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.088]                             info)
[10:58:45.088]                           info <- base::paste(info, collapse = "; ")
[10:58:45.088]                           if (!has_future) {
[10:58:45.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.088]                               info)
[10:58:45.088]                           }
[10:58:45.088]                           else {
[10:58:45.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.088]                               info, version)
[10:58:45.088]                           }
[10:58:45.088]                           base::stop(msg)
[10:58:45.088]                         }
[10:58:45.088]                       })
[10:58:45.088]                     }
[10:58:45.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.088]                     base::options(mc.cores = 1L)
[10:58:45.088]                   }
[10:58:45.088]                   ...future.strategy.old <- future::plan("list")
[10:58:45.088]                   options(future.plan = NULL)
[10:58:45.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.088]                 }
[10:58:45.088]                 ...future.workdir <- getwd()
[10:58:45.088]             }
[10:58:45.088]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.088]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.088]         }
[10:58:45.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.088]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.088]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.088]             base::names(...future.oldOptions))
[10:58:45.088]     }
[10:58:45.088]     if (FALSE) {
[10:58:45.088]     }
[10:58:45.088]     else {
[10:58:45.088]         if (TRUE) {
[10:58:45.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.088]                 open = "w")
[10:58:45.088]         }
[10:58:45.088]         else {
[10:58:45.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.088]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.088]         }
[10:58:45.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.088]             base::sink(type = "output", split = FALSE)
[10:58:45.088]             base::close(...future.stdout)
[10:58:45.088]         }, add = TRUE)
[10:58:45.088]     }
[10:58:45.088]     ...future.frame <- base::sys.nframe()
[10:58:45.088]     ...future.conditions <- base::list()
[10:58:45.088]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.088]     if (FALSE) {
[10:58:45.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.088]     }
[10:58:45.088]     ...future.result <- base::tryCatch({
[10:58:45.088]         base::withCallingHandlers({
[10:58:45.088]             ...future.value <- base::withVisible(base::local({
[10:58:45.088]                 ...future.makeSendCondition <- base::local({
[10:58:45.088]                   sendCondition <- NULL
[10:58:45.088]                   function(frame = 1L) {
[10:58:45.088]                     if (is.function(sendCondition)) 
[10:58:45.088]                       return(sendCondition)
[10:58:45.088]                     ns <- getNamespace("parallel")
[10:58:45.088]                     if (exists("sendData", mode = "function", 
[10:58:45.088]                       envir = ns)) {
[10:58:45.088]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.088]                         envir = ns)
[10:58:45.088]                       envir <- sys.frame(frame)
[10:58:45.088]                       master <- NULL
[10:58:45.088]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.088]                         !identical(envir, emptyenv())) {
[10:58:45.088]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.088]                           inherits = FALSE)) {
[10:58:45.088]                           master <- get("master", mode = "list", 
[10:58:45.088]                             envir = envir, inherits = FALSE)
[10:58:45.088]                           if (inherits(master, c("SOCKnode", 
[10:58:45.088]                             "SOCK0node"))) {
[10:58:45.088]                             sendCondition <<- function(cond) {
[10:58:45.088]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.088]                                 success = TRUE)
[10:58:45.088]                               parallel_sendData(master, data)
[10:58:45.088]                             }
[10:58:45.088]                             return(sendCondition)
[10:58:45.088]                           }
[10:58:45.088]                         }
[10:58:45.088]                         frame <- frame + 1L
[10:58:45.088]                         envir <- sys.frame(frame)
[10:58:45.088]                       }
[10:58:45.088]                     }
[10:58:45.088]                     sendCondition <<- function(cond) NULL
[10:58:45.088]                   }
[10:58:45.088]                 })
[10:58:45.088]                 withCallingHandlers({
[10:58:45.088]                   {
[10:58:45.088]                     do.call(function(...) {
[10:58:45.088]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.088]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.088]                         ...future.globals.maxSize)) {
[10:58:45.088]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.088]                         on.exit(options(oopts), add = TRUE)
[10:58:45.088]                       }
[10:58:45.088]                       {
[10:58:45.088]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.088]                           FUN = function(jj) {
[10:58:45.088]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.088]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.088]                           })
[10:58:45.088]                       }
[10:58:45.088]                     }, args = future.call.arguments)
[10:58:45.088]                   }
[10:58:45.088]                 }, immediateCondition = function(cond) {
[10:58:45.088]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.088]                   sendCondition(cond)
[10:58:45.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.088]                   {
[10:58:45.088]                     inherits <- base::inherits
[10:58:45.088]                     invokeRestart <- base::invokeRestart
[10:58:45.088]                     is.null <- base::is.null
[10:58:45.088]                     muffled <- FALSE
[10:58:45.088]                     if (inherits(cond, "message")) {
[10:58:45.088]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.088]                       if (muffled) 
[10:58:45.088]                         invokeRestart("muffleMessage")
[10:58:45.088]                     }
[10:58:45.088]                     else if (inherits(cond, "warning")) {
[10:58:45.088]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.088]                       if (muffled) 
[10:58:45.088]                         invokeRestart("muffleWarning")
[10:58:45.088]                     }
[10:58:45.088]                     else if (inherits(cond, "condition")) {
[10:58:45.088]                       if (!is.null(pattern)) {
[10:58:45.088]                         computeRestarts <- base::computeRestarts
[10:58:45.088]                         grepl <- base::grepl
[10:58:45.088]                         restarts <- computeRestarts(cond)
[10:58:45.088]                         for (restart in restarts) {
[10:58:45.088]                           name <- restart$name
[10:58:45.088]                           if (is.null(name)) 
[10:58:45.088]                             next
[10:58:45.088]                           if (!grepl(pattern, name)) 
[10:58:45.088]                             next
[10:58:45.088]                           invokeRestart(restart)
[10:58:45.088]                           muffled <- TRUE
[10:58:45.088]                           break
[10:58:45.088]                         }
[10:58:45.088]                       }
[10:58:45.088]                     }
[10:58:45.088]                     invisible(muffled)
[10:58:45.088]                   }
[10:58:45.088]                   muffleCondition(cond)
[10:58:45.088]                 })
[10:58:45.088]             }))
[10:58:45.088]             future::FutureResult(value = ...future.value$value, 
[10:58:45.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.088]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.088]                     ...future.globalenv.names))
[10:58:45.088]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.088]         }, condition = base::local({
[10:58:45.088]             c <- base::c
[10:58:45.088]             inherits <- base::inherits
[10:58:45.088]             invokeRestart <- base::invokeRestart
[10:58:45.088]             length <- base::length
[10:58:45.088]             list <- base::list
[10:58:45.088]             seq.int <- base::seq.int
[10:58:45.088]             signalCondition <- base::signalCondition
[10:58:45.088]             sys.calls <- base::sys.calls
[10:58:45.088]             `[[` <- base::`[[`
[10:58:45.088]             `+` <- base::`+`
[10:58:45.088]             `<<-` <- base::`<<-`
[10:58:45.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.088]                   3L)]
[10:58:45.088]             }
[10:58:45.088]             function(cond) {
[10:58:45.088]                 is_error <- inherits(cond, "error")
[10:58:45.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.088]                   NULL)
[10:58:45.088]                 if (is_error) {
[10:58:45.088]                   sessionInformation <- function() {
[10:58:45.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.088]                       search = base::search(), system = base::Sys.info())
[10:58:45.088]                   }
[10:58:45.088]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.088]                     cond$call), session = sessionInformation(), 
[10:58:45.088]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.088]                   signalCondition(cond)
[10:58:45.088]                 }
[10:58:45.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.088]                 "immediateCondition"))) {
[10:58:45.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.088]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.088]                   if (TRUE && !signal) {
[10:58:45.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.088]                     {
[10:58:45.088]                       inherits <- base::inherits
[10:58:45.088]                       invokeRestart <- base::invokeRestart
[10:58:45.088]                       is.null <- base::is.null
[10:58:45.088]                       muffled <- FALSE
[10:58:45.088]                       if (inherits(cond, "message")) {
[10:58:45.088]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.088]                         if (muffled) 
[10:58:45.088]                           invokeRestart("muffleMessage")
[10:58:45.088]                       }
[10:58:45.088]                       else if (inherits(cond, "warning")) {
[10:58:45.088]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.088]                         if (muffled) 
[10:58:45.088]                           invokeRestart("muffleWarning")
[10:58:45.088]                       }
[10:58:45.088]                       else if (inherits(cond, "condition")) {
[10:58:45.088]                         if (!is.null(pattern)) {
[10:58:45.088]                           computeRestarts <- base::computeRestarts
[10:58:45.088]                           grepl <- base::grepl
[10:58:45.088]                           restarts <- computeRestarts(cond)
[10:58:45.088]                           for (restart in restarts) {
[10:58:45.088]                             name <- restart$name
[10:58:45.088]                             if (is.null(name)) 
[10:58:45.088]                               next
[10:58:45.088]                             if (!grepl(pattern, name)) 
[10:58:45.088]                               next
[10:58:45.088]                             invokeRestart(restart)
[10:58:45.088]                             muffled <- TRUE
[10:58:45.088]                             break
[10:58:45.088]                           }
[10:58:45.088]                         }
[10:58:45.088]                       }
[10:58:45.088]                       invisible(muffled)
[10:58:45.088]                     }
[10:58:45.088]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.088]                   }
[10:58:45.088]                 }
[10:58:45.088]                 else {
[10:58:45.088]                   if (TRUE) {
[10:58:45.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.088]                     {
[10:58:45.088]                       inherits <- base::inherits
[10:58:45.088]                       invokeRestart <- base::invokeRestart
[10:58:45.088]                       is.null <- base::is.null
[10:58:45.088]                       muffled <- FALSE
[10:58:45.088]                       if (inherits(cond, "message")) {
[10:58:45.088]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.088]                         if (muffled) 
[10:58:45.088]                           invokeRestart("muffleMessage")
[10:58:45.088]                       }
[10:58:45.088]                       else if (inherits(cond, "warning")) {
[10:58:45.088]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.088]                         if (muffled) 
[10:58:45.088]                           invokeRestart("muffleWarning")
[10:58:45.088]                       }
[10:58:45.088]                       else if (inherits(cond, "condition")) {
[10:58:45.088]                         if (!is.null(pattern)) {
[10:58:45.088]                           computeRestarts <- base::computeRestarts
[10:58:45.088]                           grepl <- base::grepl
[10:58:45.088]                           restarts <- computeRestarts(cond)
[10:58:45.088]                           for (restart in restarts) {
[10:58:45.088]                             name <- restart$name
[10:58:45.088]                             if (is.null(name)) 
[10:58:45.088]                               next
[10:58:45.088]                             if (!grepl(pattern, name)) 
[10:58:45.088]                               next
[10:58:45.088]                             invokeRestart(restart)
[10:58:45.088]                             muffled <- TRUE
[10:58:45.088]                             break
[10:58:45.088]                           }
[10:58:45.088]                         }
[10:58:45.088]                       }
[10:58:45.088]                       invisible(muffled)
[10:58:45.088]                     }
[10:58:45.088]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.088]                   }
[10:58:45.088]                 }
[10:58:45.088]             }
[10:58:45.088]         }))
[10:58:45.088]     }, error = function(ex) {
[10:58:45.088]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.088]                 ...future.rng), started = ...future.startTime, 
[10:58:45.088]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.088]             version = "1.8"), class = "FutureResult")
[10:58:45.088]     }, finally = {
[10:58:45.088]         if (!identical(...future.workdir, getwd())) 
[10:58:45.088]             setwd(...future.workdir)
[10:58:45.088]         {
[10:58:45.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.088]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.088]             }
[10:58:45.088]             base::options(...future.oldOptions)
[10:58:45.088]             if (.Platform$OS.type == "windows") {
[10:58:45.088]                 old_names <- names(...future.oldEnvVars)
[10:58:45.088]                 envs <- base::Sys.getenv()
[10:58:45.088]                 names <- names(envs)
[10:58:45.088]                 common <- intersect(names, old_names)
[10:58:45.088]                 added <- setdiff(names, old_names)
[10:58:45.088]                 removed <- setdiff(old_names, names)
[10:58:45.088]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.088]                   envs[common]]
[10:58:45.088]                 NAMES <- toupper(changed)
[10:58:45.088]                 args <- list()
[10:58:45.088]                 for (kk in seq_along(NAMES)) {
[10:58:45.088]                   name <- changed[[kk]]
[10:58:45.088]                   NAME <- NAMES[[kk]]
[10:58:45.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.088]                     next
[10:58:45.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.088]                 }
[10:58:45.088]                 NAMES <- toupper(added)
[10:58:45.088]                 for (kk in seq_along(NAMES)) {
[10:58:45.088]                   name <- added[[kk]]
[10:58:45.088]                   NAME <- NAMES[[kk]]
[10:58:45.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.088]                     next
[10:58:45.088]                   args[[name]] <- ""
[10:58:45.088]                 }
[10:58:45.088]                 NAMES <- toupper(removed)
[10:58:45.088]                 for (kk in seq_along(NAMES)) {
[10:58:45.088]                   name <- removed[[kk]]
[10:58:45.088]                   NAME <- NAMES[[kk]]
[10:58:45.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.088]                     next
[10:58:45.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.088]                 }
[10:58:45.088]                 if (length(args) > 0) 
[10:58:45.088]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.088]             }
[10:58:45.088]             else {
[10:58:45.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.088]             }
[10:58:45.088]             {
[10:58:45.088]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.088]                   0L) {
[10:58:45.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.088]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.088]                   base::options(opts)
[10:58:45.088]                 }
[10:58:45.088]                 {
[10:58:45.088]                   {
[10:58:45.088]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.088]                     NULL
[10:58:45.088]                   }
[10:58:45.088]                   options(future.plan = NULL)
[10:58:45.088]                   if (is.na(NA_character_)) 
[10:58:45.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.088]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.088]                     .init = FALSE)
[10:58:45.088]                 }
[10:58:45.088]             }
[10:58:45.088]         }
[10:58:45.088]     })
[10:58:45.088]     if (TRUE) {
[10:58:45.088]         base::sink(type = "output", split = FALSE)
[10:58:45.088]         if (TRUE) {
[10:58:45.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.088]         }
[10:58:45.088]         else {
[10:58:45.088]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.088]         }
[10:58:45.088]         base::close(...future.stdout)
[10:58:45.088]         ...future.stdout <- NULL
[10:58:45.088]     }
[10:58:45.088]     ...future.result$conditions <- ...future.conditions
[10:58:45.088]     ...future.result$finished <- base::Sys.time()
[10:58:45.088]     ...future.result
[10:58:45.088] }
[10:58:45.141] Exporting 5 global objects (1.86 KiB) to cluster node #2 ...
[10:58:45.141] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[10:58:45.142] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[10:58:45.142] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:45.142] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:45.142] Exporting ‘...future.elements_ii’ (1.02 KiB) to cluster node #2 ...
[10:58:45.143] Exporting ‘...future.elements_ii’ (1.02 KiB) to cluster node #2 ... DONE
[10:58:45.143] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:45.143] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.143] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:45.143] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.144] Exporting 5 global objects (1.86 KiB) to cluster node #2 ... DONE
[10:58:45.144] MultisessionFuture started
[10:58:45.144] - Launch lazy future ... done
[10:58:45.144] run() for ‘MultisessionFuture’ ... done
[10:58:45.144] Created future:
[10:58:45.144] MultisessionFuture:
[10:58:45.144] Label: ‘future_by-2’
[10:58:45.144] Expression:
[10:58:45.144] {
[10:58:45.144]     do.call(function(...) {
[10:58:45.144]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.144]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.144]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.144]             on.exit(options(oopts), add = TRUE)
[10:58:45.144]         }
[10:58:45.144]         {
[10:58:45.144]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.144]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.144]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.144]             })
[10:58:45.144]         }
[10:58:45.144]     }, args = future.call.arguments)
[10:58:45.144] }
[10:58:45.144] Lazy evaluation: FALSE
[10:58:45.144] Asynchronous evaluation: TRUE
[10:58:45.144] Local evaluation: TRUE
[10:58:45.144] Environment: R_GlobalEnv
[10:58:45.144] Capture standard output: TRUE
[10:58:45.144] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.144] Globals: 5 objects totaling 1.44 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.02 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.144] Packages: <none>
[10:58:45.144] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.144] Resolved: FALSE
[10:58:45.144] Value: <not collected>
[10:58:45.144] Conditions captured: <none>
[10:58:45.144] Early signaling: FALSE
[10:58:45.144] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.144] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.156] Chunk #2 of 2 ... DONE
[10:58:45.156] Launching 2 futures (chunks) ... DONE
[10:58:45.156] Resolving 2 futures (chunks) ...
[10:58:45.156] resolve() on list ...
[10:58:45.156]  recursive: 0
[10:58:45.156]  length: 2
[10:58:45.156] 
[10:58:45.157] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.157] - Validating connection of MultisessionFuture
[10:58:45.157] - received message: FutureResult
[10:58:45.157] - Received FutureResult
[10:58:45.157] - Erased future from FutureRegistry
[10:58:45.158] result() for ClusterFuture ...
[10:58:45.158] - result already collected: FutureResult
[10:58:45.158] result() for ClusterFuture ... done
[10:58:45.158] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.158] Future #1
[10:58:45.158] result() for ClusterFuture ...
[10:58:45.158] - result already collected: FutureResult
[10:58:45.158] result() for ClusterFuture ... done
[10:58:45.158] result() for ClusterFuture ...
[10:58:45.158] - result already collected: FutureResult
[10:58:45.158] result() for ClusterFuture ... done
[10:58:45.158] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:45.159] - nx: 2
[10:58:45.159] - relay: TRUE
[10:58:45.159] - stdout: TRUE
[10:58:45.159] - signal: TRUE
[10:58:45.159] - resignal: FALSE
[10:58:45.159] - force: TRUE
[10:58:45.159] - relayed: [n=2] FALSE, FALSE
[10:58:45.159] - queued futures: [n=2] FALSE, FALSE
[10:58:45.159]  - until=1
[10:58:45.159]  - relaying element #1
[10:58:45.159] result() for ClusterFuture ...
[10:58:45.159] - result already collected: FutureResult
[10:58:45.159] result() for ClusterFuture ... done
[10:58:45.160] result() for ClusterFuture ...
[10:58:45.160] - result already collected: FutureResult
[10:58:45.160] result() for ClusterFuture ... done
[10:58:45.160] result() for ClusterFuture ...
[10:58:45.160] - result already collected: FutureResult
[10:58:45.160] result() for ClusterFuture ... done
[10:58:45.160] result() for ClusterFuture ...
[10:58:45.160] - result already collected: FutureResult
[10:58:45.160] result() for ClusterFuture ... done
[10:58:45.160] - relayed: [n=2] TRUE, FALSE
[10:58:45.160] - queued futures: [n=2] TRUE, FALSE
[10:58:45.160] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:45.161]  length: 1 (resolved future 1)
[10:58:45.224] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.224] - Validating connection of MultisessionFuture
[10:58:45.225] - received message: FutureResult
[10:58:45.225] - Received FutureResult
[10:58:45.225] - Erased future from FutureRegistry
[10:58:45.225] result() for ClusterFuture ...
[10:58:45.225] - result already collected: FutureResult
[10:58:45.225] result() for ClusterFuture ... done
[10:58:45.225] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.225] Future #2
[10:58:45.225] result() for ClusterFuture ...
[10:58:45.225] - result already collected: FutureResult
[10:58:45.226] result() for ClusterFuture ... done
[10:58:45.226] result() for ClusterFuture ...
[10:58:45.226] - result already collected: FutureResult
[10:58:45.226] result() for ClusterFuture ... done
[10:58:45.226] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:45.226] - nx: 2
[10:58:45.226] - relay: TRUE
[10:58:45.226] - stdout: TRUE
[10:58:45.226] - signal: TRUE
[10:58:45.226] - resignal: FALSE
[10:58:45.226] - force: TRUE
[10:58:45.226] - relayed: [n=2] TRUE, FALSE
[10:58:45.226] - queued futures: [n=2] TRUE, FALSE
[10:58:45.227]  - until=2
[10:58:45.227]  - relaying element #2
[10:58:45.227] result() for ClusterFuture ...
[10:58:45.227] - result already collected: FutureResult
[10:58:45.227] result() for ClusterFuture ... done
[10:58:45.227] result() for ClusterFuture ...
[10:58:45.227] - result already collected: FutureResult
[10:58:45.227] result() for ClusterFuture ... done
[10:58:45.227] result() for ClusterFuture ...
[10:58:45.227] - result already collected: FutureResult
[10:58:45.227] result() for ClusterFuture ... done
[10:58:45.228] result() for ClusterFuture ...
[10:58:45.228] - result already collected: FutureResult
[10:58:45.228] result() for ClusterFuture ... done
[10:58:45.228] - relayed: [n=2] TRUE, TRUE
[10:58:45.228] - queued futures: [n=2] TRUE, TRUE
[10:58:45.228] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:45.228]  length: 0 (resolved future 2)
[10:58:45.228] Relaying remaining futures
[10:58:45.228] signalConditionsASAP(NULL, pos=0) ...
[10:58:45.228] - nx: 2
[10:58:45.228] - relay: TRUE
[10:58:45.228] - stdout: TRUE
[10:58:45.228] - signal: TRUE
[10:58:45.229] - resignal: FALSE
[10:58:45.229] - force: TRUE
[10:58:45.229] - relayed: [n=2] TRUE, TRUE
[10:58:45.229] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:45.229] - relayed: [n=2] TRUE, TRUE
[10:58:45.229] - queued futures: [n=2] TRUE, TRUE
[10:58:45.229] signalConditionsASAP(NULL, pos=0) ... done
[10:58:45.229] resolve() on list ... DONE
[10:58:45.229] result() for ClusterFuture ...
[10:58:45.229] - result already collected: FutureResult
[10:58:45.229] result() for ClusterFuture ... done
[10:58:45.229] result() for ClusterFuture ...
[10:58:45.230] - result already collected: FutureResult
[10:58:45.230] result() for ClusterFuture ... done
[10:58:45.230] result() for ClusterFuture ...
[10:58:45.230] - result already collected: FutureResult
[10:58:45.230] result() for ClusterFuture ... done
[10:58:45.230] result() for ClusterFuture ...
[10:58:45.230] - result already collected: FutureResult
[10:58:45.230] result() for ClusterFuture ... done
[10:58:45.230]  - Number of value chunks collected: 2
[10:58:45.230] Resolving 2 futures (chunks) ... DONE
[10:58:45.230] Reducing values from 2 chunks ...
[10:58:45.230]  - Number of values collected after concatenation: 3
[10:58:45.231]  - Number of values expected: 3
[10:58:45.231] Reducing values from 2 chunks ... DONE
[10:58:45.231] future_lapply() ... DONE
[10:58:45.231] future_by_internal() ... DONE
[10:58:45.231] future_by_internal() ...
[10:58:45.231] future_lapply() ...
[10:58:45.234] Number of chunks: 2
[10:58:45.234] getGlobalsAndPackagesXApply() ...
[10:58:45.234]  - future.globals: TRUE
[10:58:45.234] getGlobalsAndPackages() ...
[10:58:45.234] Searching for globals...
[10:58:45.235] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:45.235] Searching for globals ... DONE
[10:58:45.235] Resolving globals: FALSE
[10:58:45.236] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:45.236] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:45.236] - globals: [1] ‘FUN’
[10:58:45.236] 
[10:58:45.236] getGlobalsAndPackages() ... DONE
[10:58:45.236]  - globals found/used: [n=1] ‘FUN’
[10:58:45.236]  - needed namespaces: [n=0] 
[10:58:45.236] Finding globals ... DONE
[10:58:45.237]  - use_args: TRUE
[10:58:45.237]  - Getting '...' globals ...
[10:58:45.237] resolve() on list ...
[10:58:45.237]  recursive: 0
[10:58:45.237]  length: 1
[10:58:45.237]  elements: ‘...’
[10:58:45.237]  length: 0 (resolved future 1)
[10:58:45.237] resolve() on list ... DONE
[10:58:45.238]    - '...' content: [n=1] ‘digits’
[10:58:45.238] List of 1
[10:58:45.238]  $ ...:List of 1
[10:58:45.238]   ..$ digits: int 2
[10:58:45.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.238]  - attr(*, "where")=List of 1
[10:58:45.238]   ..$ ...:<environment: 0x55974dff7848> 
[10:58:45.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.238]  - attr(*, "resolved")= logi TRUE
[10:58:45.238]  - attr(*, "total_size")= num NA
[10:58:45.241]  - Getting '...' globals ... DONE
[10:58:45.241] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:45.241] List of 2
[10:58:45.241]  $ ...future.FUN:function (object, ...)  
[10:58:45.241]  $ ...          :List of 1
[10:58:45.241]   ..$ digits: int 2
[10:58:45.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.241]  - attr(*, "where")=List of 2
[10:58:45.241]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:45.241]   ..$ ...          :<environment: 0x55974dff7848> 
[10:58:45.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.241]  - attr(*, "resolved")= logi FALSE
[10:58:45.241]  - attr(*, "total_size")= num 13284
[10:58:45.244] Packages to be attached in all futures: [n=0] 
[10:58:45.244] getGlobalsAndPackagesXApply() ... DONE
[10:58:45.244] Number of futures (= number of chunks): 2
[10:58:45.244] Launching 2 futures (chunks) ...
[10:58:45.244] Chunk #1 of 2 ...
[10:58:45.245]  - Finding globals in 'X' for chunk #1 ...
[10:58:45.245] getGlobalsAndPackages() ...
[10:58:45.245] Searching for globals...
[10:58:45.245] 
[10:58:45.245] Searching for globals ... DONE
[10:58:45.245] - globals: [0] <none>
[10:58:45.245] getGlobalsAndPackages() ... DONE
[10:58:45.245]    + additional globals found: [n=0] 
[10:58:45.245]    + additional namespaces needed: [n=0] 
[10:58:45.246]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:45.246]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.246]  - seeds: <none>
[10:58:45.246]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.246] getGlobalsAndPackages() ...
[10:58:45.246] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.246] Resolving globals: FALSE
[10:58:45.246] Tweak future expression to call with '...' arguments ...
[10:58:45.246] {
[10:58:45.246]     do.call(function(...) {
[10:58:45.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.246]             on.exit(options(oopts), add = TRUE)
[10:58:45.246]         }
[10:58:45.246]         {
[10:58:45.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.246]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.246]             })
[10:58:45.246]         }
[10:58:45.246]     }, args = future.call.arguments)
[10:58:45.246] }
[10:58:45.247] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.247] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.247] 
[10:58:45.247] getGlobalsAndPackages() ... DONE
[10:58:45.247] run() for ‘Future’ ...
[10:58:45.250] - state: ‘created’
[10:58:45.250] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.263] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.264]   - Field: ‘node’
[10:58:45.264]   - Field: ‘label’
[10:58:45.264]   - Field: ‘local’
[10:58:45.264]   - Field: ‘owner’
[10:58:45.264]   - Field: ‘envir’
[10:58:45.264]   - Field: ‘workers’
[10:58:45.264]   - Field: ‘packages’
[10:58:45.264]   - Field: ‘gc’
[10:58:45.264]   - Field: ‘conditions’
[10:58:45.264]   - Field: ‘persistent’
[10:58:45.265]   - Field: ‘expr’
[10:58:45.265]   - Field: ‘uuid’
[10:58:45.265]   - Field: ‘seed’
[10:58:45.265]   - Field: ‘version’
[10:58:45.265]   - Field: ‘result’
[10:58:45.265]   - Field: ‘asynchronous’
[10:58:45.265]   - Field: ‘calls’
[10:58:45.265]   - Field: ‘globals’
[10:58:45.265]   - Field: ‘stdout’
[10:58:45.265]   - Field: ‘earlySignal’
[10:58:45.265]   - Field: ‘lazy’
[10:58:45.265]   - Field: ‘state’
[10:58:45.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.266] - Launch lazy future ...
[10:58:45.266] Packages needed by the future expression (n = 0): <none>
[10:58:45.266] Packages needed by future strategies (n = 0): <none>
[10:58:45.266] {
[10:58:45.266]     {
[10:58:45.266]         {
[10:58:45.266]             ...future.startTime <- base::Sys.time()
[10:58:45.266]             {
[10:58:45.266]                 {
[10:58:45.266]                   {
[10:58:45.266]                     {
[10:58:45.266]                       base::local({
[10:58:45.266]                         has_future <- base::requireNamespace("future", 
[10:58:45.266]                           quietly = TRUE)
[10:58:45.266]                         if (has_future) {
[10:58:45.266]                           ns <- base::getNamespace("future")
[10:58:45.266]                           version <- ns[[".package"]][["version"]]
[10:58:45.266]                           if (is.null(version)) 
[10:58:45.266]                             version <- utils::packageVersion("future")
[10:58:45.266]                         }
[10:58:45.266]                         else {
[10:58:45.266]                           version <- NULL
[10:58:45.266]                         }
[10:58:45.266]                         if (!has_future || version < "1.8.0") {
[10:58:45.266]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.266]                             "", base::R.version$version.string), 
[10:58:45.266]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:45.266]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:45.266]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.266]                               "release", "version")], collapse = " "), 
[10:58:45.266]                             hostname = base::Sys.info()[["nodename"]])
[10:58:45.266]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.266]                             info)
[10:58:45.266]                           info <- base::paste(info, collapse = "; ")
[10:58:45.266]                           if (!has_future) {
[10:58:45.266]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.266]                               info)
[10:58:45.266]                           }
[10:58:45.266]                           else {
[10:58:45.266]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.266]                               info, version)
[10:58:45.266]                           }
[10:58:45.266]                           base::stop(msg)
[10:58:45.266]                         }
[10:58:45.266]                       })
[10:58:45.266]                     }
[10:58:45.266]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.266]                     base::options(mc.cores = 1L)
[10:58:45.266]                   }
[10:58:45.266]                   ...future.strategy.old <- future::plan("list")
[10:58:45.266]                   options(future.plan = NULL)
[10:58:45.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.266]                 }
[10:58:45.266]                 ...future.workdir <- getwd()
[10:58:45.266]             }
[10:58:45.266]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.266]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.266]         }
[10:58:45.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.266]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.266]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.266]             base::names(...future.oldOptions))
[10:58:45.266]     }
[10:58:45.266]     if (FALSE) {
[10:58:45.266]     }
[10:58:45.266]     else {
[10:58:45.266]         if (TRUE) {
[10:58:45.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.266]                 open = "w")
[10:58:45.266]         }
[10:58:45.266]         else {
[10:58:45.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.266]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.266]         }
[10:58:45.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.266]             base::sink(type = "output", split = FALSE)
[10:58:45.266]             base::close(...future.stdout)
[10:58:45.266]         }, add = TRUE)
[10:58:45.266]     }
[10:58:45.266]     ...future.frame <- base::sys.nframe()
[10:58:45.266]     ...future.conditions <- base::list()
[10:58:45.266]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.266]     if (FALSE) {
[10:58:45.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.266]     }
[10:58:45.266]     ...future.result <- base::tryCatch({
[10:58:45.266]         base::withCallingHandlers({
[10:58:45.266]             ...future.value <- base::withVisible(base::local({
[10:58:45.266]                 ...future.makeSendCondition <- base::local({
[10:58:45.266]                   sendCondition <- NULL
[10:58:45.266]                   function(frame = 1L) {
[10:58:45.266]                     if (is.function(sendCondition)) 
[10:58:45.266]                       return(sendCondition)
[10:58:45.266]                     ns <- getNamespace("parallel")
[10:58:45.266]                     if (exists("sendData", mode = "function", 
[10:58:45.266]                       envir = ns)) {
[10:58:45.266]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.266]                         envir = ns)
[10:58:45.266]                       envir <- sys.frame(frame)
[10:58:45.266]                       master <- NULL
[10:58:45.266]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.266]                         !identical(envir, emptyenv())) {
[10:58:45.266]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.266]                           inherits = FALSE)) {
[10:58:45.266]                           master <- get("master", mode = "list", 
[10:58:45.266]                             envir = envir, inherits = FALSE)
[10:58:45.266]                           if (inherits(master, c("SOCKnode", 
[10:58:45.266]                             "SOCK0node"))) {
[10:58:45.266]                             sendCondition <<- function(cond) {
[10:58:45.266]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.266]                                 success = TRUE)
[10:58:45.266]                               parallel_sendData(master, data)
[10:58:45.266]                             }
[10:58:45.266]                             return(sendCondition)
[10:58:45.266]                           }
[10:58:45.266]                         }
[10:58:45.266]                         frame <- frame + 1L
[10:58:45.266]                         envir <- sys.frame(frame)
[10:58:45.266]                       }
[10:58:45.266]                     }
[10:58:45.266]                     sendCondition <<- function(cond) NULL
[10:58:45.266]                   }
[10:58:45.266]                 })
[10:58:45.266]                 withCallingHandlers({
[10:58:45.266]                   {
[10:58:45.266]                     do.call(function(...) {
[10:58:45.266]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.266]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.266]                         ...future.globals.maxSize)) {
[10:58:45.266]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.266]                         on.exit(options(oopts), add = TRUE)
[10:58:45.266]                       }
[10:58:45.266]                       {
[10:58:45.266]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.266]                           FUN = function(jj) {
[10:58:45.266]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.266]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.266]                           })
[10:58:45.266]                       }
[10:58:45.266]                     }, args = future.call.arguments)
[10:58:45.266]                   }
[10:58:45.266]                 }, immediateCondition = function(cond) {
[10:58:45.266]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.266]                   sendCondition(cond)
[10:58:45.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.266]                   {
[10:58:45.266]                     inherits <- base::inherits
[10:58:45.266]                     invokeRestart <- base::invokeRestart
[10:58:45.266]                     is.null <- base::is.null
[10:58:45.266]                     muffled <- FALSE
[10:58:45.266]                     if (inherits(cond, "message")) {
[10:58:45.266]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.266]                       if (muffled) 
[10:58:45.266]                         invokeRestart("muffleMessage")
[10:58:45.266]                     }
[10:58:45.266]                     else if (inherits(cond, "warning")) {
[10:58:45.266]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.266]                       if (muffled) 
[10:58:45.266]                         invokeRestart("muffleWarning")
[10:58:45.266]                     }
[10:58:45.266]                     else if (inherits(cond, "condition")) {
[10:58:45.266]                       if (!is.null(pattern)) {
[10:58:45.266]                         computeRestarts <- base::computeRestarts
[10:58:45.266]                         grepl <- base::grepl
[10:58:45.266]                         restarts <- computeRestarts(cond)
[10:58:45.266]                         for (restart in restarts) {
[10:58:45.266]                           name <- restart$name
[10:58:45.266]                           if (is.null(name)) 
[10:58:45.266]                             next
[10:58:45.266]                           if (!grepl(pattern, name)) 
[10:58:45.266]                             next
[10:58:45.266]                           invokeRestart(restart)
[10:58:45.266]                           muffled <- TRUE
[10:58:45.266]                           break
[10:58:45.266]                         }
[10:58:45.266]                       }
[10:58:45.266]                     }
[10:58:45.266]                     invisible(muffled)
[10:58:45.266]                   }
[10:58:45.266]                   muffleCondition(cond)
[10:58:45.266]                 })
[10:58:45.266]             }))
[10:58:45.266]             future::FutureResult(value = ...future.value$value, 
[10:58:45.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.266]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.266]                     ...future.globalenv.names))
[10:58:45.266]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.266]         }, condition = base::local({
[10:58:45.266]             c <- base::c
[10:58:45.266]             inherits <- base::inherits
[10:58:45.266]             invokeRestart <- base::invokeRestart
[10:58:45.266]             length <- base::length
[10:58:45.266]             list <- base::list
[10:58:45.266]             seq.int <- base::seq.int
[10:58:45.266]             signalCondition <- base::signalCondition
[10:58:45.266]             sys.calls <- base::sys.calls
[10:58:45.266]             `[[` <- base::`[[`
[10:58:45.266]             `+` <- base::`+`
[10:58:45.266]             `<<-` <- base::`<<-`
[10:58:45.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.266]                   3L)]
[10:58:45.266]             }
[10:58:45.266]             function(cond) {
[10:58:45.266]                 is_error <- inherits(cond, "error")
[10:58:45.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.266]                   NULL)
[10:58:45.266]                 if (is_error) {
[10:58:45.266]                   sessionInformation <- function() {
[10:58:45.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.266]                       search = base::search(), system = base::Sys.info())
[10:58:45.266]                   }
[10:58:45.266]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.266]                     cond$call), session = sessionInformation(), 
[10:58:45.266]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.266]                   signalCondition(cond)
[10:58:45.266]                 }
[10:58:45.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.266]                 "immediateCondition"))) {
[10:58:45.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.266]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.266]                   if (TRUE && !signal) {
[10:58:45.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.266]                     {
[10:58:45.266]                       inherits <- base::inherits
[10:58:45.266]                       invokeRestart <- base::invokeRestart
[10:58:45.266]                       is.null <- base::is.null
[10:58:45.266]                       muffled <- FALSE
[10:58:45.266]                       if (inherits(cond, "message")) {
[10:58:45.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.266]                         if (muffled) 
[10:58:45.266]                           invokeRestart("muffleMessage")
[10:58:45.266]                       }
[10:58:45.266]                       else if (inherits(cond, "warning")) {
[10:58:45.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.266]                         if (muffled) 
[10:58:45.266]                           invokeRestart("muffleWarning")
[10:58:45.266]                       }
[10:58:45.266]                       else if (inherits(cond, "condition")) {
[10:58:45.266]                         if (!is.null(pattern)) {
[10:58:45.266]                           computeRestarts <- base::computeRestarts
[10:58:45.266]                           grepl <- base::grepl
[10:58:45.266]                           restarts <- computeRestarts(cond)
[10:58:45.266]                           for (restart in restarts) {
[10:58:45.266]                             name <- restart$name
[10:58:45.266]                             if (is.null(name)) 
[10:58:45.266]                               next
[10:58:45.266]                             if (!grepl(pattern, name)) 
[10:58:45.266]                               next
[10:58:45.266]                             invokeRestart(restart)
[10:58:45.266]                             muffled <- TRUE
[10:58:45.266]                             break
[10:58:45.266]                           }
[10:58:45.266]                         }
[10:58:45.266]                       }
[10:58:45.266]                       invisible(muffled)
[10:58:45.266]                     }
[10:58:45.266]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.266]                   }
[10:58:45.266]                 }
[10:58:45.266]                 else {
[10:58:45.266]                   if (TRUE) {
[10:58:45.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.266]                     {
[10:58:45.266]                       inherits <- base::inherits
[10:58:45.266]                       invokeRestart <- base::invokeRestart
[10:58:45.266]                       is.null <- base::is.null
[10:58:45.266]                       muffled <- FALSE
[10:58:45.266]                       if (inherits(cond, "message")) {
[10:58:45.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.266]                         if (muffled) 
[10:58:45.266]                           invokeRestart("muffleMessage")
[10:58:45.266]                       }
[10:58:45.266]                       else if (inherits(cond, "warning")) {
[10:58:45.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.266]                         if (muffled) 
[10:58:45.266]                           invokeRestart("muffleWarning")
[10:58:45.266]                       }
[10:58:45.266]                       else if (inherits(cond, "condition")) {
[10:58:45.266]                         if (!is.null(pattern)) {
[10:58:45.266]                           computeRestarts <- base::computeRestarts
[10:58:45.266]                           grepl <- base::grepl
[10:58:45.266]                           restarts <- computeRestarts(cond)
[10:58:45.266]                           for (restart in restarts) {
[10:58:45.266]                             name <- restart$name
[10:58:45.266]                             if (is.null(name)) 
[10:58:45.266]                               next
[10:58:45.266]                             if (!grepl(pattern, name)) 
[10:58:45.266]                               next
[10:58:45.266]                             invokeRestart(restart)
[10:58:45.266]                             muffled <- TRUE
[10:58:45.266]                             break
[10:58:45.266]                           }
[10:58:45.266]                         }
[10:58:45.266]                       }
[10:58:45.266]                       invisible(muffled)
[10:58:45.266]                     }
[10:58:45.266]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.266]                   }
[10:58:45.266]                 }
[10:58:45.266]             }
[10:58:45.266]         }))
[10:58:45.266]     }, error = function(ex) {
[10:58:45.266]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.266]                 ...future.rng), started = ...future.startTime, 
[10:58:45.266]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.266]             version = "1.8"), class = "FutureResult")
[10:58:45.266]     }, finally = {
[10:58:45.266]         if (!identical(...future.workdir, getwd())) 
[10:58:45.266]             setwd(...future.workdir)
[10:58:45.266]         {
[10:58:45.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.266]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.266]             }
[10:58:45.266]             base::options(...future.oldOptions)
[10:58:45.266]             if (.Platform$OS.type == "windows") {
[10:58:45.266]                 old_names <- names(...future.oldEnvVars)
[10:58:45.266]                 envs <- base::Sys.getenv()
[10:58:45.266]                 names <- names(envs)
[10:58:45.266]                 common <- intersect(names, old_names)
[10:58:45.266]                 added <- setdiff(names, old_names)
[10:58:45.266]                 removed <- setdiff(old_names, names)
[10:58:45.266]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.266]                   envs[common]]
[10:58:45.266]                 NAMES <- toupper(changed)
[10:58:45.266]                 args <- list()
[10:58:45.266]                 for (kk in seq_along(NAMES)) {
[10:58:45.266]                   name <- changed[[kk]]
[10:58:45.266]                   NAME <- NAMES[[kk]]
[10:58:45.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.266]                     next
[10:58:45.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.266]                 }
[10:58:45.266]                 NAMES <- toupper(added)
[10:58:45.266]                 for (kk in seq_along(NAMES)) {
[10:58:45.266]                   name <- added[[kk]]
[10:58:45.266]                   NAME <- NAMES[[kk]]
[10:58:45.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.266]                     next
[10:58:45.266]                   args[[name]] <- ""
[10:58:45.266]                 }
[10:58:45.266]                 NAMES <- toupper(removed)
[10:58:45.266]                 for (kk in seq_along(NAMES)) {
[10:58:45.266]                   name <- removed[[kk]]
[10:58:45.266]                   NAME <- NAMES[[kk]]
[10:58:45.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.266]                     next
[10:58:45.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.266]                 }
[10:58:45.266]                 if (length(args) > 0) 
[10:58:45.266]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.266]             }
[10:58:45.266]             else {
[10:58:45.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.266]             }
[10:58:45.266]             {
[10:58:45.266]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.266]                   0L) {
[10:58:45.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.266]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.266]                   base::options(opts)
[10:58:45.266]                 }
[10:58:45.266]                 {
[10:58:45.266]                   {
[10:58:45.266]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.266]                     NULL
[10:58:45.266]                   }
[10:58:45.266]                   options(future.plan = NULL)
[10:58:45.266]                   if (is.na(NA_character_)) 
[10:58:45.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.266]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.266]                     .init = FALSE)
[10:58:45.266]                 }
[10:58:45.266]             }
[10:58:45.266]         }
[10:58:45.266]     })
[10:58:45.266]     if (TRUE) {
[10:58:45.266]         base::sink(type = "output", split = FALSE)
[10:58:45.266]         if (TRUE) {
[10:58:45.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.266]         }
[10:58:45.266]         else {
[10:58:45.266]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.266]         }
[10:58:45.266]         base::close(...future.stdout)
[10:58:45.266]         ...future.stdout <- NULL
[10:58:45.266]     }
[10:58:45.266]     ...future.result$conditions <- ...future.conditions
[10:58:45.266]     ...future.result$finished <- base::Sys.time()
[10:58:45.266]     ...future.result
[10:58:45.266] }
[10:58:45.269] Exporting 5 global objects (1.18 KiB) to cluster node #1 ...
[10:58:45.269] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[10:58:45.270] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[10:58:45.270] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #1 ...
[10:58:45.270] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #1 ... DONE
[10:58:45.270] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #1 ...
[10:58:45.271] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #1 ... DONE
[10:58:45.271] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:45.271] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.271] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:45.271] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.271] Exporting 5 global objects (1.18 KiB) to cluster node #1 ... DONE
[10:58:45.272] MultisessionFuture started
[10:58:45.272] - Launch lazy future ... done
[10:58:45.272] run() for ‘MultisessionFuture’ ... done
[10:58:45.272] Created future:
[10:58:45.272] MultisessionFuture:
[10:58:45.272] Label: ‘future_by-1’
[10:58:45.272] Expression:
[10:58:45.272] {
[10:58:45.272]     do.call(function(...) {
[10:58:45.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.272]             on.exit(options(oopts), add = TRUE)
[10:58:45.272]         }
[10:58:45.272]         {
[10:58:45.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.272]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.272]             })
[10:58:45.272]         }
[10:58:45.272]     }, args = future.call.arguments)
[10:58:45.272] }
[10:58:45.272] Lazy evaluation: FALSE
[10:58:45.272] Asynchronous evaluation: TRUE
[10:58:45.272] Local evaluation: TRUE
[10:58:45.272] Environment: R_GlobalEnv
[10:58:45.272] Capture standard output: TRUE
[10:58:45.272] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.272] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.272] Packages: <none>
[10:58:45.272] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.272] Resolved: FALSE
[10:58:45.272] Value: <not collected>
[10:58:45.272] Conditions captured: <none>
[10:58:45.272] Early signaling: FALSE
[10:58:45.272] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.272] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.284] Chunk #1 of 2 ... DONE
[10:58:45.284] Chunk #2 of 2 ...
[10:58:45.284]  - Finding globals in 'X' for chunk #2 ...
[10:58:45.284] getGlobalsAndPackages() ...
[10:58:45.284] Searching for globals...
[10:58:45.284] 
[10:58:45.284] Searching for globals ... DONE
[10:58:45.285] - globals: [0] <none>
[10:58:45.285] getGlobalsAndPackages() ... DONE
[10:58:45.285]    + additional globals found: [n=0] 
[10:58:45.285]    + additional namespaces needed: [n=0] 
[10:58:45.285]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:45.285]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.285]  - seeds: <none>
[10:58:45.285]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.285] getGlobalsAndPackages() ...
[10:58:45.285] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.285] Resolving globals: FALSE
[10:58:45.285] Tweak future expression to call with '...' arguments ...
[10:58:45.286] {
[10:58:45.286]     do.call(function(...) {
[10:58:45.286]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.286]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.286]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.286]             on.exit(options(oopts), add = TRUE)
[10:58:45.286]         }
[10:58:45.286]         {
[10:58:45.286]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.286]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.286]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.286]             })
[10:58:45.286]         }
[10:58:45.286]     }, args = future.call.arguments)
[10:58:45.286] }
[10:58:45.286] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.286] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.286] 
[10:58:45.286] getGlobalsAndPackages() ... DONE
[10:58:45.287] run() for ‘Future’ ...
[10:58:45.287] - state: ‘created’
[10:58:45.287] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.300]   - Field: ‘node’
[10:58:45.300]   - Field: ‘label’
[10:58:45.301]   - Field: ‘local’
[10:58:45.301]   - Field: ‘owner’
[10:58:45.301]   - Field: ‘envir’
[10:58:45.301]   - Field: ‘workers’
[10:58:45.301]   - Field: ‘packages’
[10:58:45.301]   - Field: ‘gc’
[10:58:45.301]   - Field: ‘conditions’
[10:58:45.301]   - Field: ‘persistent’
[10:58:45.301]   - Field: ‘expr’
[10:58:45.301]   - Field: ‘uuid’
[10:58:45.301]   - Field: ‘seed’
[10:58:45.301]   - Field: ‘version’
[10:58:45.302]   - Field: ‘result’
[10:58:45.302]   - Field: ‘asynchronous’
[10:58:45.302]   - Field: ‘calls’
[10:58:45.302]   - Field: ‘globals’
[10:58:45.302]   - Field: ‘stdout’
[10:58:45.302]   - Field: ‘earlySignal’
[10:58:45.302]   - Field: ‘lazy’
[10:58:45.302]   - Field: ‘state’
[10:58:45.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.302] - Launch lazy future ...
[10:58:45.303] Packages needed by the future expression (n = 0): <none>
[10:58:45.303] Packages needed by future strategies (n = 0): <none>
[10:58:45.303] {
[10:58:45.303]     {
[10:58:45.303]         {
[10:58:45.303]             ...future.startTime <- base::Sys.time()
[10:58:45.303]             {
[10:58:45.303]                 {
[10:58:45.303]                   {
[10:58:45.303]                     {
[10:58:45.303]                       base::local({
[10:58:45.303]                         has_future <- base::requireNamespace("future", 
[10:58:45.303]                           quietly = TRUE)
[10:58:45.303]                         if (has_future) {
[10:58:45.303]                           ns <- base::getNamespace("future")
[10:58:45.303]                           version <- ns[[".package"]][["version"]]
[10:58:45.303]                           if (is.null(version)) 
[10:58:45.303]                             version <- utils::packageVersion("future")
[10:58:45.303]                         }
[10:58:45.303]                         else {
[10:58:45.303]                           version <- NULL
[10:58:45.303]                         }
[10:58:45.303]                         if (!has_future || version < "1.8.0") {
[10:58:45.303]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.303]                             "", base::R.version$version.string), 
[10:58:45.303]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:45.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:45.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.303]                               "release", "version")], collapse = " "), 
[10:58:45.303]                             hostname = base::Sys.info()[["nodename"]])
[10:58:45.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.303]                             info)
[10:58:45.303]                           info <- base::paste(info, collapse = "; ")
[10:58:45.303]                           if (!has_future) {
[10:58:45.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.303]                               info)
[10:58:45.303]                           }
[10:58:45.303]                           else {
[10:58:45.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.303]                               info, version)
[10:58:45.303]                           }
[10:58:45.303]                           base::stop(msg)
[10:58:45.303]                         }
[10:58:45.303]                       })
[10:58:45.303]                     }
[10:58:45.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.303]                     base::options(mc.cores = 1L)
[10:58:45.303]                   }
[10:58:45.303]                   ...future.strategy.old <- future::plan("list")
[10:58:45.303]                   options(future.plan = NULL)
[10:58:45.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.303]                 }
[10:58:45.303]                 ...future.workdir <- getwd()
[10:58:45.303]             }
[10:58:45.303]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.303]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.303]         }
[10:58:45.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.303]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.303]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.303]             base::names(...future.oldOptions))
[10:58:45.303]     }
[10:58:45.303]     if (FALSE) {
[10:58:45.303]     }
[10:58:45.303]     else {
[10:58:45.303]         if (TRUE) {
[10:58:45.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.303]                 open = "w")
[10:58:45.303]         }
[10:58:45.303]         else {
[10:58:45.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.303]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.303]         }
[10:58:45.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.303]             base::sink(type = "output", split = FALSE)
[10:58:45.303]             base::close(...future.stdout)
[10:58:45.303]         }, add = TRUE)
[10:58:45.303]     }
[10:58:45.303]     ...future.frame <- base::sys.nframe()
[10:58:45.303]     ...future.conditions <- base::list()
[10:58:45.303]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.303]     if (FALSE) {
[10:58:45.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.303]     }
[10:58:45.303]     ...future.result <- base::tryCatch({
[10:58:45.303]         base::withCallingHandlers({
[10:58:45.303]             ...future.value <- base::withVisible(base::local({
[10:58:45.303]                 ...future.makeSendCondition <- base::local({
[10:58:45.303]                   sendCondition <- NULL
[10:58:45.303]                   function(frame = 1L) {
[10:58:45.303]                     if (is.function(sendCondition)) 
[10:58:45.303]                       return(sendCondition)
[10:58:45.303]                     ns <- getNamespace("parallel")
[10:58:45.303]                     if (exists("sendData", mode = "function", 
[10:58:45.303]                       envir = ns)) {
[10:58:45.303]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.303]                         envir = ns)
[10:58:45.303]                       envir <- sys.frame(frame)
[10:58:45.303]                       master <- NULL
[10:58:45.303]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.303]                         !identical(envir, emptyenv())) {
[10:58:45.303]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.303]                           inherits = FALSE)) {
[10:58:45.303]                           master <- get("master", mode = "list", 
[10:58:45.303]                             envir = envir, inherits = FALSE)
[10:58:45.303]                           if (inherits(master, c("SOCKnode", 
[10:58:45.303]                             "SOCK0node"))) {
[10:58:45.303]                             sendCondition <<- function(cond) {
[10:58:45.303]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.303]                                 success = TRUE)
[10:58:45.303]                               parallel_sendData(master, data)
[10:58:45.303]                             }
[10:58:45.303]                             return(sendCondition)
[10:58:45.303]                           }
[10:58:45.303]                         }
[10:58:45.303]                         frame <- frame + 1L
[10:58:45.303]                         envir <- sys.frame(frame)
[10:58:45.303]                       }
[10:58:45.303]                     }
[10:58:45.303]                     sendCondition <<- function(cond) NULL
[10:58:45.303]                   }
[10:58:45.303]                 })
[10:58:45.303]                 withCallingHandlers({
[10:58:45.303]                   {
[10:58:45.303]                     do.call(function(...) {
[10:58:45.303]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.303]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.303]                         ...future.globals.maxSize)) {
[10:58:45.303]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.303]                         on.exit(options(oopts), add = TRUE)
[10:58:45.303]                       }
[10:58:45.303]                       {
[10:58:45.303]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.303]                           FUN = function(jj) {
[10:58:45.303]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.303]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.303]                           })
[10:58:45.303]                       }
[10:58:45.303]                     }, args = future.call.arguments)
[10:58:45.303]                   }
[10:58:45.303]                 }, immediateCondition = function(cond) {
[10:58:45.303]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.303]                   sendCondition(cond)
[10:58:45.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.303]                   {
[10:58:45.303]                     inherits <- base::inherits
[10:58:45.303]                     invokeRestart <- base::invokeRestart
[10:58:45.303]                     is.null <- base::is.null
[10:58:45.303]                     muffled <- FALSE
[10:58:45.303]                     if (inherits(cond, "message")) {
[10:58:45.303]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.303]                       if (muffled) 
[10:58:45.303]                         invokeRestart("muffleMessage")
[10:58:45.303]                     }
[10:58:45.303]                     else if (inherits(cond, "warning")) {
[10:58:45.303]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.303]                       if (muffled) 
[10:58:45.303]                         invokeRestart("muffleWarning")
[10:58:45.303]                     }
[10:58:45.303]                     else if (inherits(cond, "condition")) {
[10:58:45.303]                       if (!is.null(pattern)) {
[10:58:45.303]                         computeRestarts <- base::computeRestarts
[10:58:45.303]                         grepl <- base::grepl
[10:58:45.303]                         restarts <- computeRestarts(cond)
[10:58:45.303]                         for (restart in restarts) {
[10:58:45.303]                           name <- restart$name
[10:58:45.303]                           if (is.null(name)) 
[10:58:45.303]                             next
[10:58:45.303]                           if (!grepl(pattern, name)) 
[10:58:45.303]                             next
[10:58:45.303]                           invokeRestart(restart)
[10:58:45.303]                           muffled <- TRUE
[10:58:45.303]                           break
[10:58:45.303]                         }
[10:58:45.303]                       }
[10:58:45.303]                     }
[10:58:45.303]                     invisible(muffled)
[10:58:45.303]                   }
[10:58:45.303]                   muffleCondition(cond)
[10:58:45.303]                 })
[10:58:45.303]             }))
[10:58:45.303]             future::FutureResult(value = ...future.value$value, 
[10:58:45.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.303]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.303]                     ...future.globalenv.names))
[10:58:45.303]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.303]         }, condition = base::local({
[10:58:45.303]             c <- base::c
[10:58:45.303]             inherits <- base::inherits
[10:58:45.303]             invokeRestart <- base::invokeRestart
[10:58:45.303]             length <- base::length
[10:58:45.303]             list <- base::list
[10:58:45.303]             seq.int <- base::seq.int
[10:58:45.303]             signalCondition <- base::signalCondition
[10:58:45.303]             sys.calls <- base::sys.calls
[10:58:45.303]             `[[` <- base::`[[`
[10:58:45.303]             `+` <- base::`+`
[10:58:45.303]             `<<-` <- base::`<<-`
[10:58:45.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.303]                   3L)]
[10:58:45.303]             }
[10:58:45.303]             function(cond) {
[10:58:45.303]                 is_error <- inherits(cond, "error")
[10:58:45.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.303]                   NULL)
[10:58:45.303]                 if (is_error) {
[10:58:45.303]                   sessionInformation <- function() {
[10:58:45.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.303]                       search = base::search(), system = base::Sys.info())
[10:58:45.303]                   }
[10:58:45.303]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.303]                     cond$call), session = sessionInformation(), 
[10:58:45.303]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.303]                   signalCondition(cond)
[10:58:45.303]                 }
[10:58:45.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.303]                 "immediateCondition"))) {
[10:58:45.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.303]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.303]                   if (TRUE && !signal) {
[10:58:45.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.303]                     {
[10:58:45.303]                       inherits <- base::inherits
[10:58:45.303]                       invokeRestart <- base::invokeRestart
[10:58:45.303]                       is.null <- base::is.null
[10:58:45.303]                       muffled <- FALSE
[10:58:45.303]                       if (inherits(cond, "message")) {
[10:58:45.303]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.303]                         if (muffled) 
[10:58:45.303]                           invokeRestart("muffleMessage")
[10:58:45.303]                       }
[10:58:45.303]                       else if (inherits(cond, "warning")) {
[10:58:45.303]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.303]                         if (muffled) 
[10:58:45.303]                           invokeRestart("muffleWarning")
[10:58:45.303]                       }
[10:58:45.303]                       else if (inherits(cond, "condition")) {
[10:58:45.303]                         if (!is.null(pattern)) {
[10:58:45.303]                           computeRestarts <- base::computeRestarts
[10:58:45.303]                           grepl <- base::grepl
[10:58:45.303]                           restarts <- computeRestarts(cond)
[10:58:45.303]                           for (restart in restarts) {
[10:58:45.303]                             name <- restart$name
[10:58:45.303]                             if (is.null(name)) 
[10:58:45.303]                               next
[10:58:45.303]                             if (!grepl(pattern, name)) 
[10:58:45.303]                               next
[10:58:45.303]                             invokeRestart(restart)
[10:58:45.303]                             muffled <- TRUE
[10:58:45.303]                             break
[10:58:45.303]                           }
[10:58:45.303]                         }
[10:58:45.303]                       }
[10:58:45.303]                       invisible(muffled)
[10:58:45.303]                     }
[10:58:45.303]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.303]                   }
[10:58:45.303]                 }
[10:58:45.303]                 else {
[10:58:45.303]                   if (TRUE) {
[10:58:45.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.303]                     {
[10:58:45.303]                       inherits <- base::inherits
[10:58:45.303]                       invokeRestart <- base::invokeRestart
[10:58:45.303]                       is.null <- base::is.null
[10:58:45.303]                       muffled <- FALSE
[10:58:45.303]                       if (inherits(cond, "message")) {
[10:58:45.303]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.303]                         if (muffled) 
[10:58:45.303]                           invokeRestart("muffleMessage")
[10:58:45.303]                       }
[10:58:45.303]                       else if (inherits(cond, "warning")) {
[10:58:45.303]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.303]                         if (muffled) 
[10:58:45.303]                           invokeRestart("muffleWarning")
[10:58:45.303]                       }
[10:58:45.303]                       else if (inherits(cond, "condition")) {
[10:58:45.303]                         if (!is.null(pattern)) {
[10:58:45.303]                           computeRestarts <- base::computeRestarts
[10:58:45.303]                           grepl <- base::grepl
[10:58:45.303]                           restarts <- computeRestarts(cond)
[10:58:45.303]                           for (restart in restarts) {
[10:58:45.303]                             name <- restart$name
[10:58:45.303]                             if (is.null(name)) 
[10:58:45.303]                               next
[10:58:45.303]                             if (!grepl(pattern, name)) 
[10:58:45.303]                               next
[10:58:45.303]                             invokeRestart(restart)
[10:58:45.303]                             muffled <- TRUE
[10:58:45.303]                             break
[10:58:45.303]                           }
[10:58:45.303]                         }
[10:58:45.303]                       }
[10:58:45.303]                       invisible(muffled)
[10:58:45.303]                     }
[10:58:45.303]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.303]                   }
[10:58:45.303]                 }
[10:58:45.303]             }
[10:58:45.303]         }))
[10:58:45.303]     }, error = function(ex) {
[10:58:45.303]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.303]                 ...future.rng), started = ...future.startTime, 
[10:58:45.303]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.303]             version = "1.8"), class = "FutureResult")
[10:58:45.303]     }, finally = {
[10:58:45.303]         if (!identical(...future.workdir, getwd())) 
[10:58:45.303]             setwd(...future.workdir)
[10:58:45.303]         {
[10:58:45.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.303]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.303]             }
[10:58:45.303]             base::options(...future.oldOptions)
[10:58:45.303]             if (.Platform$OS.type == "windows") {
[10:58:45.303]                 old_names <- names(...future.oldEnvVars)
[10:58:45.303]                 envs <- base::Sys.getenv()
[10:58:45.303]                 names <- names(envs)
[10:58:45.303]                 common <- intersect(names, old_names)
[10:58:45.303]                 added <- setdiff(names, old_names)
[10:58:45.303]                 removed <- setdiff(old_names, names)
[10:58:45.303]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.303]                   envs[common]]
[10:58:45.303]                 NAMES <- toupper(changed)
[10:58:45.303]                 args <- list()
[10:58:45.303]                 for (kk in seq_along(NAMES)) {
[10:58:45.303]                   name <- changed[[kk]]
[10:58:45.303]                   NAME <- NAMES[[kk]]
[10:58:45.303]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.303]                     next
[10:58:45.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.303]                 }
[10:58:45.303]                 NAMES <- toupper(added)
[10:58:45.303]                 for (kk in seq_along(NAMES)) {
[10:58:45.303]                   name <- added[[kk]]
[10:58:45.303]                   NAME <- NAMES[[kk]]
[10:58:45.303]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.303]                     next
[10:58:45.303]                   args[[name]] <- ""
[10:58:45.303]                 }
[10:58:45.303]                 NAMES <- toupper(removed)
[10:58:45.303]                 for (kk in seq_along(NAMES)) {
[10:58:45.303]                   name <- removed[[kk]]
[10:58:45.303]                   NAME <- NAMES[[kk]]
[10:58:45.303]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.303]                     next
[10:58:45.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.303]                 }
[10:58:45.303]                 if (length(args) > 0) 
[10:58:45.303]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.303]             }
[10:58:45.303]             else {
[10:58:45.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.303]             }
[10:58:45.303]             {
[10:58:45.303]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.303]                   0L) {
[10:58:45.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.303]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.303]                   base::options(opts)
[10:58:45.303]                 }
[10:58:45.303]                 {
[10:58:45.303]                   {
[10:58:45.303]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.303]                     NULL
[10:58:45.303]                   }
[10:58:45.303]                   options(future.plan = NULL)
[10:58:45.303]                   if (is.na(NA_character_)) 
[10:58:45.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.303]                     .init = FALSE)
[10:58:45.303]                 }
[10:58:45.303]             }
[10:58:45.303]         }
[10:58:45.303]     })
[10:58:45.303]     if (TRUE) {
[10:58:45.303]         base::sink(type = "output", split = FALSE)
[10:58:45.303]         if (TRUE) {
[10:58:45.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.303]         }
[10:58:45.303]         else {
[10:58:45.303]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.303]         }
[10:58:45.303]         base::close(...future.stdout)
[10:58:45.303]         ...future.stdout <- NULL
[10:58:45.303]     }
[10:58:45.303]     ...future.result$conditions <- ...future.conditions
[10:58:45.303]     ...future.result$finished <- base::Sys.time()
[10:58:45.303]     ...future.result
[10:58:45.303] }
[10:58:45.306] Exporting 5 global objects (1.18 KiB) to cluster node #2 ...
[10:58:45.306] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[10:58:45.306] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[10:58:45.306] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #2 ...
[10:58:45.307] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #2 ... DONE
[10:58:45.307] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #2 ...
[10:58:45.307] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #2 ... DONE
[10:58:45.307] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:45.308] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.308] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:45.308] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.308] Exporting 5 global objects (1.18 KiB) to cluster node #2 ... DONE
[10:58:45.309] MultisessionFuture started
[10:58:45.309] - Launch lazy future ... done
[10:58:45.309] run() for ‘MultisessionFuture’ ... done
[10:58:45.309] Created future:
[10:58:45.309] MultisessionFuture:
[10:58:45.309] Label: ‘future_by-2’
[10:58:45.309] Expression:
[10:58:45.309] {
[10:58:45.309]     do.call(function(...) {
[10:58:45.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.309]             on.exit(options(oopts), add = TRUE)
[10:58:45.309]         }
[10:58:45.309]         {
[10:58:45.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.309]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.309]             })
[10:58:45.309]         }
[10:58:45.309]     }, args = future.call.arguments)
[10:58:45.309] }
[10:58:45.309] Lazy evaluation: FALSE
[10:58:45.309] Asynchronous evaluation: TRUE
[10:58:45.309] Local evaluation: TRUE
[10:58:45.309] Environment: R_GlobalEnv
[10:58:45.309] Capture standard output: TRUE
[10:58:45.309] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.309] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.309] Packages: <none>
[10:58:45.309] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.309] Resolved: FALSE
[10:58:45.309] Value: <not collected>
[10:58:45.309] Conditions captured: <none>
[10:58:45.309] Early signaling: FALSE
[10:58:45.309] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.309] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.321] Chunk #2 of 2 ... DONE
[10:58:45.321] Launching 2 futures (chunks) ... DONE
[10:58:45.321] Resolving 2 futures (chunks) ...
[10:58:45.321] resolve() on list ...
[10:58:45.321]  recursive: 0
[10:58:45.321]  length: 2
[10:58:45.321] 
[10:58:45.322] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.322] - Validating connection of MultisessionFuture
[10:58:45.322] - received message: FutureResult
[10:58:45.322] - Received FutureResult
[10:58:45.322] - Erased future from FutureRegistry
[10:58:45.322] result() for ClusterFuture ...
[10:58:45.322] - result already collected: FutureResult
[10:58:45.323] result() for ClusterFuture ... done
[10:58:45.323] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.323] Future #1
[10:58:45.323] result() for ClusterFuture ...
[10:58:45.323] - result already collected: FutureResult
[10:58:45.323] result() for ClusterFuture ... done
[10:58:45.323] result() for ClusterFuture ...
[10:58:45.323] - result already collected: FutureResult
[10:58:45.323] result() for ClusterFuture ... done
[10:58:45.323] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:45.323] - nx: 2
[10:58:45.323] - relay: TRUE
[10:58:45.323] - stdout: TRUE
[10:58:45.324] - signal: TRUE
[10:58:45.324] - resignal: FALSE
[10:58:45.324] - force: TRUE
[10:58:45.324] - relayed: [n=2] FALSE, FALSE
[10:58:45.324] - queued futures: [n=2] FALSE, FALSE
[10:58:45.324]  - until=1
[10:58:45.324]  - relaying element #1
[10:58:45.324] result() for ClusterFuture ...
[10:58:45.324] - result already collected: FutureResult
[10:58:45.324] result() for ClusterFuture ... done
[10:58:45.324] result() for ClusterFuture ...
[10:58:45.324] - result already collected: FutureResult
[10:58:45.324] result() for ClusterFuture ... done
[10:58:45.325] result() for ClusterFuture ...
[10:58:45.325] - result already collected: FutureResult
[10:58:45.325] result() for ClusterFuture ... done
[10:58:45.325] result() for ClusterFuture ...
[10:58:45.325] - result already collected: FutureResult
[10:58:45.325] result() for ClusterFuture ... done
[10:58:45.325] - relayed: [n=2] TRUE, FALSE
[10:58:45.325] - queued futures: [n=2] TRUE, FALSE
[10:58:45.325] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:45.325]  length: 1 (resolved future 1)
[10:58:45.352] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.352] - Validating connection of MultisessionFuture
[10:58:45.352] - received message: FutureResult
[10:58:45.352] - Received FutureResult
[10:58:45.352] - Erased future from FutureRegistry
[10:58:45.352] result() for ClusterFuture ...
[10:58:45.352] - result already collected: FutureResult
[10:58:45.352] result() for ClusterFuture ... done
[10:58:45.352] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.353] Future #2
[10:58:45.353] result() for ClusterFuture ...
[10:58:45.353] - result already collected: FutureResult
[10:58:45.353] result() for ClusterFuture ... done
[10:58:45.353] result() for ClusterFuture ...
[10:58:45.353] - result already collected: FutureResult
[10:58:45.353] result() for ClusterFuture ... done
[10:58:45.353] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:45.353] - nx: 2
[10:58:45.353] - relay: TRUE
[10:58:45.353] - stdout: TRUE
[10:58:45.353] - signal: TRUE
[10:58:45.353] - resignal: FALSE
[10:58:45.354] - force: TRUE
[10:58:45.354] - relayed: [n=2] TRUE, FALSE
[10:58:45.354] - queued futures: [n=2] TRUE, FALSE
[10:58:45.354]  - until=2
[10:58:45.354]  - relaying element #2
[10:58:45.354] result() for ClusterFuture ...
[10:58:45.354] - result already collected: FutureResult
[10:58:45.354] result() for ClusterFuture ... done
[10:58:45.354] result() for ClusterFuture ...
[10:58:45.354] - result already collected: FutureResult
[10:58:45.354] result() for ClusterFuture ... done
[10:58:45.355] result() for ClusterFuture ...
[10:58:45.355] - result already collected: FutureResult
[10:58:45.355] result() for ClusterFuture ... done
[10:58:45.355] result() for ClusterFuture ...
[10:58:45.355] - result already collected: FutureResult
[10:58:45.355] result() for ClusterFuture ... done
[10:58:45.355] - relayed: [n=2] TRUE, TRUE
[10:58:45.355] - queued futures: [n=2] TRUE, TRUE
[10:58:45.355] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:45.355]  length: 0 (resolved future 2)
[10:58:45.355] Relaying remaining futures
[10:58:45.355] signalConditionsASAP(NULL, pos=0) ...
[10:58:45.355] - nx: 2
[10:58:45.356] - relay: TRUE
[10:58:45.356] - stdout: TRUE
[10:58:45.356] - signal: TRUE
[10:58:45.356] - resignal: FALSE
[10:58:45.356] - force: TRUE
[10:58:45.356] - relayed: [n=2] TRUE, TRUE
[10:58:45.356] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:45.356] - relayed: [n=2] TRUE, TRUE
[10:58:45.356] - queued futures: [n=2] TRUE, TRUE
[10:58:45.356] signalConditionsASAP(NULL, pos=0) ... done
[10:58:45.356] resolve() on list ... DONE
[10:58:45.356] result() for ClusterFuture ...
[10:58:45.357] - result already collected: FutureResult
[10:58:45.357] result() for ClusterFuture ... done
[10:58:45.357] result() for ClusterFuture ...
[10:58:45.357] - result already collected: FutureResult
[10:58:45.357] result() for ClusterFuture ... done
[10:58:45.357] result() for ClusterFuture ...
[10:58:45.357] - result already collected: FutureResult
[10:58:45.357] result() for ClusterFuture ... done
[10:58:45.357] result() for ClusterFuture ...
[10:58:45.357] - result already collected: FutureResult
[10:58:45.357] result() for ClusterFuture ... done
[10:58:45.357]  - Number of value chunks collected: 2
[10:58:45.357] Resolving 2 futures (chunks) ... DONE
[10:58:45.358] Reducing values from 2 chunks ...
[10:58:45.358]  - Number of values collected after concatenation: 6
[10:58:45.358]  - Number of values expected: 6
[10:58:45.358] Reducing values from 2 chunks ... DONE
[10:58:45.358] future_lapply() ... DONE
[10:58:45.358] future_by_internal() ... DONE
[10:58:45.359] future_by_internal() ...
[10:58:45.359] future_lapply() ...
[10:58:45.362] Number of chunks: 2
[10:58:45.362] getGlobalsAndPackagesXApply() ...
[10:58:45.362]  - future.globals: TRUE
[10:58:45.362] getGlobalsAndPackages() ...
[10:58:45.362] Searching for globals...
[10:58:45.364] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:45.364] Searching for globals ... DONE
[10:58:45.364] Resolving globals: FALSE
[10:58:45.364] The total size of the 1 globals is 762 bytes (762 bytes)
[10:58:45.365] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:58:45.365] - globals: [1] ‘FUN’
[10:58:45.365] - packages: [1] ‘stats’
[10:58:45.365] getGlobalsAndPackages() ... DONE
[10:58:45.365]  - globals found/used: [n=1] ‘FUN’
[10:58:45.365]  - needed namespaces: [n=1] ‘stats’
[10:58:45.365] Finding globals ... DONE
[10:58:45.365]  - use_args: TRUE
[10:58:45.365]  - Getting '...' globals ...
[10:58:45.366] resolve() on list ...
[10:58:45.366]  recursive: 0
[10:58:45.366]  length: 1
[10:58:45.366]  elements: ‘...’
[10:58:45.366]  length: 0 (resolved future 1)
[10:58:45.366] resolve() on list ... DONE
[10:58:45.366]    - '...' content: [n=1] ‘singular.ok’
[10:58:45.366] List of 1
[10:58:45.366]  $ ...:List of 1
[10:58:45.366]   ..$ singular.ok: logi FALSE
[10:58:45.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.366]  - attr(*, "where")=List of 1
[10:58:45.366]   ..$ ...:<environment: 0x55974f311338> 
[10:58:45.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.366]  - attr(*, "resolved")= logi TRUE
[10:58:45.366]  - attr(*, "total_size")= num NA
[10:58:45.369]  - Getting '...' globals ... DONE
[10:58:45.369] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:45.369] List of 2
[10:58:45.369]  $ ...future.FUN:function (x, ...)  
[10:58:45.369]  $ ...          :List of 1
[10:58:45.369]   ..$ singular.ok: logi FALSE
[10:58:45.369]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.369]  - attr(*, "where")=List of 2
[10:58:45.369]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:45.369]   ..$ ...          :<environment: 0x55974f311338> 
[10:58:45.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.369]  - attr(*, "resolved")= logi FALSE
[10:58:45.369]  - attr(*, "total_size")= num 19977
[10:58:45.372] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:45.372] getGlobalsAndPackagesXApply() ... DONE
[10:58:45.373] Number of futures (= number of chunks): 2
[10:58:45.373] Launching 2 futures (chunks) ...
[10:58:45.373] Chunk #1 of 2 ...
[10:58:45.373]  - Finding globals in 'X' for chunk #1 ...
[10:58:45.373] getGlobalsAndPackages() ...
[10:58:45.373] Searching for globals...
[10:58:45.373] 
[10:58:45.373] Searching for globals ... DONE
[10:58:45.374] - globals: [0] <none>
[10:58:45.374] getGlobalsAndPackages() ... DONE
[10:58:45.374]    + additional globals found: [n=0] 
[10:58:45.374]    + additional namespaces needed: [n=0] 
[10:58:45.374]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:45.374]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.374]  - seeds: <none>
[10:58:45.374]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.374] getGlobalsAndPackages() ...
[10:58:45.374] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.374] Resolving globals: FALSE
[10:58:45.375] Tweak future expression to call with '...' arguments ...
[10:58:45.375] {
[10:58:45.375]     do.call(function(...) {
[10:58:45.375]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.375]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.375]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.375]             on.exit(options(oopts), add = TRUE)
[10:58:45.375]         }
[10:58:45.375]         {
[10:58:45.375]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.375]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.375]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.375]             })
[10:58:45.375]         }
[10:58:45.375]     }, args = future.call.arguments)
[10:58:45.375] }
[10:58:45.375] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.375] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.375] 
[10:58:45.375] getGlobalsAndPackages() ... DONE
[10:58:45.376] run() for ‘Future’ ...
[10:58:45.376] - state: ‘created’
[10:58:45.376] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.389] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.390] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.390]   - Field: ‘node’
[10:58:45.390]   - Field: ‘label’
[10:58:45.390]   - Field: ‘local’
[10:58:45.390]   - Field: ‘owner’
[10:58:45.390]   - Field: ‘envir’
[10:58:45.390]   - Field: ‘workers’
[10:58:45.390]   - Field: ‘packages’
[10:58:45.390]   - Field: ‘gc’
[10:58:45.390]   - Field: ‘conditions’
[10:58:45.390]   - Field: ‘persistent’
[10:58:45.391]   - Field: ‘expr’
[10:58:45.391]   - Field: ‘uuid’
[10:58:45.391]   - Field: ‘seed’
[10:58:45.391]   - Field: ‘version’
[10:58:45.391]   - Field: ‘result’
[10:58:45.391]   - Field: ‘asynchronous’
[10:58:45.391]   - Field: ‘calls’
[10:58:45.391]   - Field: ‘globals’
[10:58:45.391]   - Field: ‘stdout’
[10:58:45.391]   - Field: ‘earlySignal’
[10:58:45.391]   - Field: ‘lazy’
[10:58:45.391]   - Field: ‘state’
[10:58:45.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.392] - Launch lazy future ...
[10:58:45.392] Packages needed by the future expression (n = 1): ‘stats’
[10:58:45.392] Packages needed by future strategies (n = 0): <none>
[10:58:45.393] {
[10:58:45.393]     {
[10:58:45.393]         {
[10:58:45.393]             ...future.startTime <- base::Sys.time()
[10:58:45.393]             {
[10:58:45.393]                 {
[10:58:45.393]                   {
[10:58:45.393]                     {
[10:58:45.393]                       {
[10:58:45.393]                         base::local({
[10:58:45.393]                           has_future <- base::requireNamespace("future", 
[10:58:45.393]                             quietly = TRUE)
[10:58:45.393]                           if (has_future) {
[10:58:45.393]                             ns <- base::getNamespace("future")
[10:58:45.393]                             version <- ns[[".package"]][["version"]]
[10:58:45.393]                             if (is.null(version)) 
[10:58:45.393]                               version <- utils::packageVersion("future")
[10:58:45.393]                           }
[10:58:45.393]                           else {
[10:58:45.393]                             version <- NULL
[10:58:45.393]                           }
[10:58:45.393]                           if (!has_future || version < "1.8.0") {
[10:58:45.393]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.393]                               "", base::R.version$version.string), 
[10:58:45.393]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:45.393]                                 base::R.version$platform, 8 * 
[10:58:45.393]                                   base::.Machine$sizeof.pointer), 
[10:58:45.393]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.393]                                 "release", "version")], collapse = " "), 
[10:58:45.393]                               hostname = base::Sys.info()[["nodename"]])
[10:58:45.393]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.393]                               info)
[10:58:45.393]                             info <- base::paste(info, collapse = "; ")
[10:58:45.393]                             if (!has_future) {
[10:58:45.393]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.393]                                 info)
[10:58:45.393]                             }
[10:58:45.393]                             else {
[10:58:45.393]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.393]                                 info, version)
[10:58:45.393]                             }
[10:58:45.393]                             base::stop(msg)
[10:58:45.393]                           }
[10:58:45.393]                         })
[10:58:45.393]                       }
[10:58:45.393]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.393]                       base::options(mc.cores = 1L)
[10:58:45.393]                     }
[10:58:45.393]                     base::local({
[10:58:45.393]                       for (pkg in "stats") {
[10:58:45.393]                         base::loadNamespace(pkg)
[10:58:45.393]                         base::library(pkg, character.only = TRUE)
[10:58:45.393]                       }
[10:58:45.393]                     })
[10:58:45.393]                   }
[10:58:45.393]                   ...future.strategy.old <- future::plan("list")
[10:58:45.393]                   options(future.plan = NULL)
[10:58:45.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.393]                 }
[10:58:45.393]                 ...future.workdir <- getwd()
[10:58:45.393]             }
[10:58:45.393]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.393]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.393]         }
[10:58:45.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.393]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.393]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.393]             base::names(...future.oldOptions))
[10:58:45.393]     }
[10:58:45.393]     if (FALSE) {
[10:58:45.393]     }
[10:58:45.393]     else {
[10:58:45.393]         if (TRUE) {
[10:58:45.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.393]                 open = "w")
[10:58:45.393]         }
[10:58:45.393]         else {
[10:58:45.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.393]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.393]         }
[10:58:45.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.393]             base::sink(type = "output", split = FALSE)
[10:58:45.393]             base::close(...future.stdout)
[10:58:45.393]         }, add = TRUE)
[10:58:45.393]     }
[10:58:45.393]     ...future.frame <- base::sys.nframe()
[10:58:45.393]     ...future.conditions <- base::list()
[10:58:45.393]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.393]     if (FALSE) {
[10:58:45.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.393]     }
[10:58:45.393]     ...future.result <- base::tryCatch({
[10:58:45.393]         base::withCallingHandlers({
[10:58:45.393]             ...future.value <- base::withVisible(base::local({
[10:58:45.393]                 ...future.makeSendCondition <- base::local({
[10:58:45.393]                   sendCondition <- NULL
[10:58:45.393]                   function(frame = 1L) {
[10:58:45.393]                     if (is.function(sendCondition)) 
[10:58:45.393]                       return(sendCondition)
[10:58:45.393]                     ns <- getNamespace("parallel")
[10:58:45.393]                     if (exists("sendData", mode = "function", 
[10:58:45.393]                       envir = ns)) {
[10:58:45.393]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.393]                         envir = ns)
[10:58:45.393]                       envir <- sys.frame(frame)
[10:58:45.393]                       master <- NULL
[10:58:45.393]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.393]                         !identical(envir, emptyenv())) {
[10:58:45.393]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.393]                           inherits = FALSE)) {
[10:58:45.393]                           master <- get("master", mode = "list", 
[10:58:45.393]                             envir = envir, inherits = FALSE)
[10:58:45.393]                           if (inherits(master, c("SOCKnode", 
[10:58:45.393]                             "SOCK0node"))) {
[10:58:45.393]                             sendCondition <<- function(cond) {
[10:58:45.393]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.393]                                 success = TRUE)
[10:58:45.393]                               parallel_sendData(master, data)
[10:58:45.393]                             }
[10:58:45.393]                             return(sendCondition)
[10:58:45.393]                           }
[10:58:45.393]                         }
[10:58:45.393]                         frame <- frame + 1L
[10:58:45.393]                         envir <- sys.frame(frame)
[10:58:45.393]                       }
[10:58:45.393]                     }
[10:58:45.393]                     sendCondition <<- function(cond) NULL
[10:58:45.393]                   }
[10:58:45.393]                 })
[10:58:45.393]                 withCallingHandlers({
[10:58:45.393]                   {
[10:58:45.393]                     do.call(function(...) {
[10:58:45.393]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.393]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.393]                         ...future.globals.maxSize)) {
[10:58:45.393]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.393]                         on.exit(options(oopts), add = TRUE)
[10:58:45.393]                       }
[10:58:45.393]                       {
[10:58:45.393]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.393]                           FUN = function(jj) {
[10:58:45.393]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.393]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.393]                           })
[10:58:45.393]                       }
[10:58:45.393]                     }, args = future.call.arguments)
[10:58:45.393]                   }
[10:58:45.393]                 }, immediateCondition = function(cond) {
[10:58:45.393]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.393]                   sendCondition(cond)
[10:58:45.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.393]                   {
[10:58:45.393]                     inherits <- base::inherits
[10:58:45.393]                     invokeRestart <- base::invokeRestart
[10:58:45.393]                     is.null <- base::is.null
[10:58:45.393]                     muffled <- FALSE
[10:58:45.393]                     if (inherits(cond, "message")) {
[10:58:45.393]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.393]                       if (muffled) 
[10:58:45.393]                         invokeRestart("muffleMessage")
[10:58:45.393]                     }
[10:58:45.393]                     else if (inherits(cond, "warning")) {
[10:58:45.393]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.393]                       if (muffled) 
[10:58:45.393]                         invokeRestart("muffleWarning")
[10:58:45.393]                     }
[10:58:45.393]                     else if (inherits(cond, "condition")) {
[10:58:45.393]                       if (!is.null(pattern)) {
[10:58:45.393]                         computeRestarts <- base::computeRestarts
[10:58:45.393]                         grepl <- base::grepl
[10:58:45.393]                         restarts <- computeRestarts(cond)
[10:58:45.393]                         for (restart in restarts) {
[10:58:45.393]                           name <- restart$name
[10:58:45.393]                           if (is.null(name)) 
[10:58:45.393]                             next
[10:58:45.393]                           if (!grepl(pattern, name)) 
[10:58:45.393]                             next
[10:58:45.393]                           invokeRestart(restart)
[10:58:45.393]                           muffled <- TRUE
[10:58:45.393]                           break
[10:58:45.393]                         }
[10:58:45.393]                       }
[10:58:45.393]                     }
[10:58:45.393]                     invisible(muffled)
[10:58:45.393]                   }
[10:58:45.393]                   muffleCondition(cond)
[10:58:45.393]                 })
[10:58:45.393]             }))
[10:58:45.393]             future::FutureResult(value = ...future.value$value, 
[10:58:45.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.393]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.393]                     ...future.globalenv.names))
[10:58:45.393]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.393]         }, condition = base::local({
[10:58:45.393]             c <- base::c
[10:58:45.393]             inherits <- base::inherits
[10:58:45.393]             invokeRestart <- base::invokeRestart
[10:58:45.393]             length <- base::length
[10:58:45.393]             list <- base::list
[10:58:45.393]             seq.int <- base::seq.int
[10:58:45.393]             signalCondition <- base::signalCondition
[10:58:45.393]             sys.calls <- base::sys.calls
[10:58:45.393]             `[[` <- base::`[[`
[10:58:45.393]             `+` <- base::`+`
[10:58:45.393]             `<<-` <- base::`<<-`
[10:58:45.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.393]                   3L)]
[10:58:45.393]             }
[10:58:45.393]             function(cond) {
[10:58:45.393]                 is_error <- inherits(cond, "error")
[10:58:45.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.393]                   NULL)
[10:58:45.393]                 if (is_error) {
[10:58:45.393]                   sessionInformation <- function() {
[10:58:45.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.393]                       search = base::search(), system = base::Sys.info())
[10:58:45.393]                   }
[10:58:45.393]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.393]                     cond$call), session = sessionInformation(), 
[10:58:45.393]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.393]                   signalCondition(cond)
[10:58:45.393]                 }
[10:58:45.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.393]                 "immediateCondition"))) {
[10:58:45.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.393]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.393]                   if (TRUE && !signal) {
[10:58:45.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.393]                     {
[10:58:45.393]                       inherits <- base::inherits
[10:58:45.393]                       invokeRestart <- base::invokeRestart
[10:58:45.393]                       is.null <- base::is.null
[10:58:45.393]                       muffled <- FALSE
[10:58:45.393]                       if (inherits(cond, "message")) {
[10:58:45.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.393]                         if (muffled) 
[10:58:45.393]                           invokeRestart("muffleMessage")
[10:58:45.393]                       }
[10:58:45.393]                       else if (inherits(cond, "warning")) {
[10:58:45.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.393]                         if (muffled) 
[10:58:45.393]                           invokeRestart("muffleWarning")
[10:58:45.393]                       }
[10:58:45.393]                       else if (inherits(cond, "condition")) {
[10:58:45.393]                         if (!is.null(pattern)) {
[10:58:45.393]                           computeRestarts <- base::computeRestarts
[10:58:45.393]                           grepl <- base::grepl
[10:58:45.393]                           restarts <- computeRestarts(cond)
[10:58:45.393]                           for (restart in restarts) {
[10:58:45.393]                             name <- restart$name
[10:58:45.393]                             if (is.null(name)) 
[10:58:45.393]                               next
[10:58:45.393]                             if (!grepl(pattern, name)) 
[10:58:45.393]                               next
[10:58:45.393]                             invokeRestart(restart)
[10:58:45.393]                             muffled <- TRUE
[10:58:45.393]                             break
[10:58:45.393]                           }
[10:58:45.393]                         }
[10:58:45.393]                       }
[10:58:45.393]                       invisible(muffled)
[10:58:45.393]                     }
[10:58:45.393]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.393]                   }
[10:58:45.393]                 }
[10:58:45.393]                 else {
[10:58:45.393]                   if (TRUE) {
[10:58:45.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.393]                     {
[10:58:45.393]                       inherits <- base::inherits
[10:58:45.393]                       invokeRestart <- base::invokeRestart
[10:58:45.393]                       is.null <- base::is.null
[10:58:45.393]                       muffled <- FALSE
[10:58:45.393]                       if (inherits(cond, "message")) {
[10:58:45.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.393]                         if (muffled) 
[10:58:45.393]                           invokeRestart("muffleMessage")
[10:58:45.393]                       }
[10:58:45.393]                       else if (inherits(cond, "warning")) {
[10:58:45.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.393]                         if (muffled) 
[10:58:45.393]                           invokeRestart("muffleWarning")
[10:58:45.393]                       }
[10:58:45.393]                       else if (inherits(cond, "condition")) {
[10:58:45.393]                         if (!is.null(pattern)) {
[10:58:45.393]                           computeRestarts <- base::computeRestarts
[10:58:45.393]                           grepl <- base::grepl
[10:58:45.393]                           restarts <- computeRestarts(cond)
[10:58:45.393]                           for (restart in restarts) {
[10:58:45.393]                             name <- restart$name
[10:58:45.393]                             if (is.null(name)) 
[10:58:45.393]                               next
[10:58:45.393]                             if (!grepl(pattern, name)) 
[10:58:45.393]                               next
[10:58:45.393]                             invokeRestart(restart)
[10:58:45.393]                             muffled <- TRUE
[10:58:45.393]                             break
[10:58:45.393]                           }
[10:58:45.393]                         }
[10:58:45.393]                       }
[10:58:45.393]                       invisible(muffled)
[10:58:45.393]                     }
[10:58:45.393]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.393]                   }
[10:58:45.393]                 }
[10:58:45.393]             }
[10:58:45.393]         }))
[10:58:45.393]     }, error = function(ex) {
[10:58:45.393]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.393]                 ...future.rng), started = ...future.startTime, 
[10:58:45.393]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.393]             version = "1.8"), class = "FutureResult")
[10:58:45.393]     }, finally = {
[10:58:45.393]         if (!identical(...future.workdir, getwd())) 
[10:58:45.393]             setwd(...future.workdir)
[10:58:45.393]         {
[10:58:45.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.393]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.393]             }
[10:58:45.393]             base::options(...future.oldOptions)
[10:58:45.393]             if (.Platform$OS.type == "windows") {
[10:58:45.393]                 old_names <- names(...future.oldEnvVars)
[10:58:45.393]                 envs <- base::Sys.getenv()
[10:58:45.393]                 names <- names(envs)
[10:58:45.393]                 common <- intersect(names, old_names)
[10:58:45.393]                 added <- setdiff(names, old_names)
[10:58:45.393]                 removed <- setdiff(old_names, names)
[10:58:45.393]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.393]                   envs[common]]
[10:58:45.393]                 NAMES <- toupper(changed)
[10:58:45.393]                 args <- list()
[10:58:45.393]                 for (kk in seq_along(NAMES)) {
[10:58:45.393]                   name <- changed[[kk]]
[10:58:45.393]                   NAME <- NAMES[[kk]]
[10:58:45.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.393]                     next
[10:58:45.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.393]                 }
[10:58:45.393]                 NAMES <- toupper(added)
[10:58:45.393]                 for (kk in seq_along(NAMES)) {
[10:58:45.393]                   name <- added[[kk]]
[10:58:45.393]                   NAME <- NAMES[[kk]]
[10:58:45.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.393]                     next
[10:58:45.393]                   args[[name]] <- ""
[10:58:45.393]                 }
[10:58:45.393]                 NAMES <- toupper(removed)
[10:58:45.393]                 for (kk in seq_along(NAMES)) {
[10:58:45.393]                   name <- removed[[kk]]
[10:58:45.393]                   NAME <- NAMES[[kk]]
[10:58:45.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.393]                     next
[10:58:45.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.393]                 }
[10:58:45.393]                 if (length(args) > 0) 
[10:58:45.393]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.393]             }
[10:58:45.393]             else {
[10:58:45.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.393]             }
[10:58:45.393]             {
[10:58:45.393]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.393]                   0L) {
[10:58:45.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.393]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.393]                   base::options(opts)
[10:58:45.393]                 }
[10:58:45.393]                 {
[10:58:45.393]                   {
[10:58:45.393]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.393]                     NULL
[10:58:45.393]                   }
[10:58:45.393]                   options(future.plan = NULL)
[10:58:45.393]                   if (is.na(NA_character_)) 
[10:58:45.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.393]                     .init = FALSE)
[10:58:45.393]                 }
[10:58:45.393]             }
[10:58:45.393]         }
[10:58:45.393]     })
[10:58:45.393]     if (TRUE) {
[10:58:45.393]         base::sink(type = "output", split = FALSE)
[10:58:45.393]         if (TRUE) {
[10:58:45.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.393]         }
[10:58:45.393]         else {
[10:58:45.393]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.393]         }
[10:58:45.393]         base::close(...future.stdout)
[10:58:45.393]         ...future.stdout <- NULL
[10:58:45.393]     }
[10:58:45.393]     ...future.result$conditions <- ...future.conditions
[10:58:45.393]     ...future.result$finished <- base::Sys.time()
[10:58:45.393]     ...future.result
[10:58:45.393] }
[10:58:45.395] Exporting 5 global objects (2.08 KiB) to cluster node #1 ...
[10:58:45.396] Exporting ‘...future.FUN’ (762 bytes) to cluster node #1 ...
[10:58:45.396] Exporting ‘...future.FUN’ (762 bytes) to cluster node #1 ... DONE
[10:58:45.396] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #1 ...
[10:58:45.396] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #1 ... DONE
[10:58:45.397] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[10:58:45.397] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[10:58:45.397] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:45.397] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.398] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:45.398] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.398] Exporting 5 global objects (2.08 KiB) to cluster node #1 ... DONE
[10:58:45.399] MultisessionFuture started
[10:58:45.399] - Launch lazy future ... done
[10:58:45.399] run() for ‘MultisessionFuture’ ... done
[10:58:45.399] Created future:
[10:58:45.399] MultisessionFuture:
[10:58:45.399] Label: ‘future_by-1’
[10:58:45.399] Expression:
[10:58:45.399] {
[10:58:45.399]     do.call(function(...) {
[10:58:45.399]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.399]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.399]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.399]             on.exit(options(oopts), add = TRUE)
[10:58:45.399]         }
[10:58:45.399]         {
[10:58:45.399]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.399]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.399]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.399]             })
[10:58:45.399]         }
[10:58:45.399]     }, args = future.call.arguments)
[10:58:45.399] }
[10:58:45.399] Lazy evaluation: FALSE
[10:58:45.399] Asynchronous evaluation: TRUE
[10:58:45.399] Local evaluation: TRUE
[10:58:45.399] Environment: R_GlobalEnv
[10:58:45.399] Capture standard output: TRUE
[10:58:45.399] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.399] Globals: 5 objects totaling 1.67 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.399] Packages: 1 packages (‘stats’)
[10:58:45.399] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.399] Resolved: FALSE
[10:58:45.399] Value: <not collected>
[10:58:45.399] Conditions captured: <none>
[10:58:45.399] Early signaling: FALSE
[10:58:45.399] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.399] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.410] Chunk #1 of 2 ... DONE
[10:58:45.410] Chunk #2 of 2 ...
[10:58:45.411]  - Finding globals in 'X' for chunk #2 ...
[10:58:45.411] getGlobalsAndPackages() ...
[10:58:45.411] Searching for globals...
[10:58:45.411] 
[10:58:45.411] Searching for globals ... DONE
[10:58:45.412] - globals: [0] <none>
[10:58:45.412] getGlobalsAndPackages() ... DONE
[10:58:45.412]    + additional globals found: [n=0] 
[10:58:45.412]    + additional namespaces needed: [n=0] 
[10:58:45.412]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:45.412]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.412]  - seeds: <none>
[10:58:45.412]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.412] getGlobalsAndPackages() ...
[10:58:45.412] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.412] Resolving globals: FALSE
[10:58:45.413] Tweak future expression to call with '...' arguments ...
[10:58:45.413] {
[10:58:45.413]     do.call(function(...) {
[10:58:45.413]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.413]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.413]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.413]             on.exit(options(oopts), add = TRUE)
[10:58:45.413]         }
[10:58:45.413]         {
[10:58:45.413]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.413]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.413]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.413]             })
[10:58:45.413]         }
[10:58:45.413]     }, args = future.call.arguments)
[10:58:45.413] }
[10:58:45.413] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.413] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.413] 
[10:58:45.413] getGlobalsAndPackages() ... DONE
[10:58:45.414] run() for ‘Future’ ...
[10:58:45.414] - state: ‘created’
[10:58:45.414] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.429] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.430]   - Field: ‘node’
[10:58:45.430]   - Field: ‘label’
[10:58:45.430]   - Field: ‘local’
[10:58:45.430]   - Field: ‘owner’
[10:58:45.430]   - Field: ‘envir’
[10:58:45.430]   - Field: ‘workers’
[10:58:45.430]   - Field: ‘packages’
[10:58:45.430]   - Field: ‘gc’
[10:58:45.430]   - Field: ‘conditions’
[10:58:45.431]   - Field: ‘persistent’
[10:58:45.431]   - Field: ‘expr’
[10:58:45.431]   - Field: ‘uuid’
[10:58:45.431]   - Field: ‘seed’
[10:58:45.431]   - Field: ‘version’
[10:58:45.431]   - Field: ‘result’
[10:58:45.431]   - Field: ‘asynchronous’
[10:58:45.431]   - Field: ‘calls’
[10:58:45.431]   - Field: ‘globals’
[10:58:45.431]   - Field: ‘stdout’
[10:58:45.431]   - Field: ‘earlySignal’
[10:58:45.431]   - Field: ‘lazy’
[10:58:45.432]   - Field: ‘state’
[10:58:45.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.432] - Launch lazy future ...
[10:58:45.432] Packages needed by the future expression (n = 1): ‘stats’
[10:58:45.432] Packages needed by future strategies (n = 0): <none>
[10:58:45.433] {
[10:58:45.433]     {
[10:58:45.433]         {
[10:58:45.433]             ...future.startTime <- base::Sys.time()
[10:58:45.433]             {
[10:58:45.433]                 {
[10:58:45.433]                   {
[10:58:45.433]                     {
[10:58:45.433]                       {
[10:58:45.433]                         base::local({
[10:58:45.433]                           has_future <- base::requireNamespace("future", 
[10:58:45.433]                             quietly = TRUE)
[10:58:45.433]                           if (has_future) {
[10:58:45.433]                             ns <- base::getNamespace("future")
[10:58:45.433]                             version <- ns[[".package"]][["version"]]
[10:58:45.433]                             if (is.null(version)) 
[10:58:45.433]                               version <- utils::packageVersion("future")
[10:58:45.433]                           }
[10:58:45.433]                           else {
[10:58:45.433]                             version <- NULL
[10:58:45.433]                           }
[10:58:45.433]                           if (!has_future || version < "1.8.0") {
[10:58:45.433]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.433]                               "", base::R.version$version.string), 
[10:58:45.433]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:45.433]                                 base::R.version$platform, 8 * 
[10:58:45.433]                                   base::.Machine$sizeof.pointer), 
[10:58:45.433]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.433]                                 "release", "version")], collapse = " "), 
[10:58:45.433]                               hostname = base::Sys.info()[["nodename"]])
[10:58:45.433]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.433]                               info)
[10:58:45.433]                             info <- base::paste(info, collapse = "; ")
[10:58:45.433]                             if (!has_future) {
[10:58:45.433]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.433]                                 info)
[10:58:45.433]                             }
[10:58:45.433]                             else {
[10:58:45.433]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.433]                                 info, version)
[10:58:45.433]                             }
[10:58:45.433]                             base::stop(msg)
[10:58:45.433]                           }
[10:58:45.433]                         })
[10:58:45.433]                       }
[10:58:45.433]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.433]                       base::options(mc.cores = 1L)
[10:58:45.433]                     }
[10:58:45.433]                     base::local({
[10:58:45.433]                       for (pkg in "stats") {
[10:58:45.433]                         base::loadNamespace(pkg)
[10:58:45.433]                         base::library(pkg, character.only = TRUE)
[10:58:45.433]                       }
[10:58:45.433]                     })
[10:58:45.433]                   }
[10:58:45.433]                   ...future.strategy.old <- future::plan("list")
[10:58:45.433]                   options(future.plan = NULL)
[10:58:45.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.433]                 }
[10:58:45.433]                 ...future.workdir <- getwd()
[10:58:45.433]             }
[10:58:45.433]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.433]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.433]         }
[10:58:45.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.433]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.433]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.433]             base::names(...future.oldOptions))
[10:58:45.433]     }
[10:58:45.433]     if (FALSE) {
[10:58:45.433]     }
[10:58:45.433]     else {
[10:58:45.433]         if (TRUE) {
[10:58:45.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.433]                 open = "w")
[10:58:45.433]         }
[10:58:45.433]         else {
[10:58:45.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.433]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.433]         }
[10:58:45.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.433]             base::sink(type = "output", split = FALSE)
[10:58:45.433]             base::close(...future.stdout)
[10:58:45.433]         }, add = TRUE)
[10:58:45.433]     }
[10:58:45.433]     ...future.frame <- base::sys.nframe()
[10:58:45.433]     ...future.conditions <- base::list()
[10:58:45.433]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.433]     if (FALSE) {
[10:58:45.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.433]     }
[10:58:45.433]     ...future.result <- base::tryCatch({
[10:58:45.433]         base::withCallingHandlers({
[10:58:45.433]             ...future.value <- base::withVisible(base::local({
[10:58:45.433]                 ...future.makeSendCondition <- base::local({
[10:58:45.433]                   sendCondition <- NULL
[10:58:45.433]                   function(frame = 1L) {
[10:58:45.433]                     if (is.function(sendCondition)) 
[10:58:45.433]                       return(sendCondition)
[10:58:45.433]                     ns <- getNamespace("parallel")
[10:58:45.433]                     if (exists("sendData", mode = "function", 
[10:58:45.433]                       envir = ns)) {
[10:58:45.433]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.433]                         envir = ns)
[10:58:45.433]                       envir <- sys.frame(frame)
[10:58:45.433]                       master <- NULL
[10:58:45.433]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.433]                         !identical(envir, emptyenv())) {
[10:58:45.433]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.433]                           inherits = FALSE)) {
[10:58:45.433]                           master <- get("master", mode = "list", 
[10:58:45.433]                             envir = envir, inherits = FALSE)
[10:58:45.433]                           if (inherits(master, c("SOCKnode", 
[10:58:45.433]                             "SOCK0node"))) {
[10:58:45.433]                             sendCondition <<- function(cond) {
[10:58:45.433]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.433]                                 success = TRUE)
[10:58:45.433]                               parallel_sendData(master, data)
[10:58:45.433]                             }
[10:58:45.433]                             return(sendCondition)
[10:58:45.433]                           }
[10:58:45.433]                         }
[10:58:45.433]                         frame <- frame + 1L
[10:58:45.433]                         envir <- sys.frame(frame)
[10:58:45.433]                       }
[10:58:45.433]                     }
[10:58:45.433]                     sendCondition <<- function(cond) NULL
[10:58:45.433]                   }
[10:58:45.433]                 })
[10:58:45.433]                 withCallingHandlers({
[10:58:45.433]                   {
[10:58:45.433]                     do.call(function(...) {
[10:58:45.433]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.433]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.433]                         ...future.globals.maxSize)) {
[10:58:45.433]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.433]                         on.exit(options(oopts), add = TRUE)
[10:58:45.433]                       }
[10:58:45.433]                       {
[10:58:45.433]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.433]                           FUN = function(jj) {
[10:58:45.433]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.433]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.433]                           })
[10:58:45.433]                       }
[10:58:45.433]                     }, args = future.call.arguments)
[10:58:45.433]                   }
[10:58:45.433]                 }, immediateCondition = function(cond) {
[10:58:45.433]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.433]                   sendCondition(cond)
[10:58:45.433]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.433]                   {
[10:58:45.433]                     inherits <- base::inherits
[10:58:45.433]                     invokeRestart <- base::invokeRestart
[10:58:45.433]                     is.null <- base::is.null
[10:58:45.433]                     muffled <- FALSE
[10:58:45.433]                     if (inherits(cond, "message")) {
[10:58:45.433]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.433]                       if (muffled) 
[10:58:45.433]                         invokeRestart("muffleMessage")
[10:58:45.433]                     }
[10:58:45.433]                     else if (inherits(cond, "warning")) {
[10:58:45.433]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.433]                       if (muffled) 
[10:58:45.433]                         invokeRestart("muffleWarning")
[10:58:45.433]                     }
[10:58:45.433]                     else if (inherits(cond, "condition")) {
[10:58:45.433]                       if (!is.null(pattern)) {
[10:58:45.433]                         computeRestarts <- base::computeRestarts
[10:58:45.433]                         grepl <- base::grepl
[10:58:45.433]                         restarts <- computeRestarts(cond)
[10:58:45.433]                         for (restart in restarts) {
[10:58:45.433]                           name <- restart$name
[10:58:45.433]                           if (is.null(name)) 
[10:58:45.433]                             next
[10:58:45.433]                           if (!grepl(pattern, name)) 
[10:58:45.433]                             next
[10:58:45.433]                           invokeRestart(restart)
[10:58:45.433]                           muffled <- TRUE
[10:58:45.433]                           break
[10:58:45.433]                         }
[10:58:45.433]                       }
[10:58:45.433]                     }
[10:58:45.433]                     invisible(muffled)
[10:58:45.433]                   }
[10:58:45.433]                   muffleCondition(cond)
[10:58:45.433]                 })
[10:58:45.433]             }))
[10:58:45.433]             future::FutureResult(value = ...future.value$value, 
[10:58:45.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.433]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.433]                     ...future.globalenv.names))
[10:58:45.433]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.433]         }, condition = base::local({
[10:58:45.433]             c <- base::c
[10:58:45.433]             inherits <- base::inherits
[10:58:45.433]             invokeRestart <- base::invokeRestart
[10:58:45.433]             length <- base::length
[10:58:45.433]             list <- base::list
[10:58:45.433]             seq.int <- base::seq.int
[10:58:45.433]             signalCondition <- base::signalCondition
[10:58:45.433]             sys.calls <- base::sys.calls
[10:58:45.433]             `[[` <- base::`[[`
[10:58:45.433]             `+` <- base::`+`
[10:58:45.433]             `<<-` <- base::`<<-`
[10:58:45.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.433]                   3L)]
[10:58:45.433]             }
[10:58:45.433]             function(cond) {
[10:58:45.433]                 is_error <- inherits(cond, "error")
[10:58:45.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.433]                   NULL)
[10:58:45.433]                 if (is_error) {
[10:58:45.433]                   sessionInformation <- function() {
[10:58:45.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.433]                       search = base::search(), system = base::Sys.info())
[10:58:45.433]                   }
[10:58:45.433]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.433]                     cond$call), session = sessionInformation(), 
[10:58:45.433]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.433]                   signalCondition(cond)
[10:58:45.433]                 }
[10:58:45.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.433]                 "immediateCondition"))) {
[10:58:45.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.433]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.433]                   if (TRUE && !signal) {
[10:58:45.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.433]                     {
[10:58:45.433]                       inherits <- base::inherits
[10:58:45.433]                       invokeRestart <- base::invokeRestart
[10:58:45.433]                       is.null <- base::is.null
[10:58:45.433]                       muffled <- FALSE
[10:58:45.433]                       if (inherits(cond, "message")) {
[10:58:45.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.433]                         if (muffled) 
[10:58:45.433]                           invokeRestart("muffleMessage")
[10:58:45.433]                       }
[10:58:45.433]                       else if (inherits(cond, "warning")) {
[10:58:45.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.433]                         if (muffled) 
[10:58:45.433]                           invokeRestart("muffleWarning")
[10:58:45.433]                       }
[10:58:45.433]                       else if (inherits(cond, "condition")) {
[10:58:45.433]                         if (!is.null(pattern)) {
[10:58:45.433]                           computeRestarts <- base::computeRestarts
[10:58:45.433]                           grepl <- base::grepl
[10:58:45.433]                           restarts <- computeRestarts(cond)
[10:58:45.433]                           for (restart in restarts) {
[10:58:45.433]                             name <- restart$name
[10:58:45.433]                             if (is.null(name)) 
[10:58:45.433]                               next
[10:58:45.433]                             if (!grepl(pattern, name)) 
[10:58:45.433]                               next
[10:58:45.433]                             invokeRestart(restart)
[10:58:45.433]                             muffled <- TRUE
[10:58:45.433]                             break
[10:58:45.433]                           }
[10:58:45.433]                         }
[10:58:45.433]                       }
[10:58:45.433]                       invisible(muffled)
[10:58:45.433]                     }
[10:58:45.433]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.433]                   }
[10:58:45.433]                 }
[10:58:45.433]                 else {
[10:58:45.433]                   if (TRUE) {
[10:58:45.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.433]                     {
[10:58:45.433]                       inherits <- base::inherits
[10:58:45.433]                       invokeRestart <- base::invokeRestart
[10:58:45.433]                       is.null <- base::is.null
[10:58:45.433]                       muffled <- FALSE
[10:58:45.433]                       if (inherits(cond, "message")) {
[10:58:45.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.433]                         if (muffled) 
[10:58:45.433]                           invokeRestart("muffleMessage")
[10:58:45.433]                       }
[10:58:45.433]                       else if (inherits(cond, "warning")) {
[10:58:45.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.433]                         if (muffled) 
[10:58:45.433]                           invokeRestart("muffleWarning")
[10:58:45.433]                       }
[10:58:45.433]                       else if (inherits(cond, "condition")) {
[10:58:45.433]                         if (!is.null(pattern)) {
[10:58:45.433]                           computeRestarts <- base::computeRestarts
[10:58:45.433]                           grepl <- base::grepl
[10:58:45.433]                           restarts <- computeRestarts(cond)
[10:58:45.433]                           for (restart in restarts) {
[10:58:45.433]                             name <- restart$name
[10:58:45.433]                             if (is.null(name)) 
[10:58:45.433]                               next
[10:58:45.433]                             if (!grepl(pattern, name)) 
[10:58:45.433]                               next
[10:58:45.433]                             invokeRestart(restart)
[10:58:45.433]                             muffled <- TRUE
[10:58:45.433]                             break
[10:58:45.433]                           }
[10:58:45.433]                         }
[10:58:45.433]                       }
[10:58:45.433]                       invisible(muffled)
[10:58:45.433]                     }
[10:58:45.433]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.433]                   }
[10:58:45.433]                 }
[10:58:45.433]             }
[10:58:45.433]         }))
[10:58:45.433]     }, error = function(ex) {
[10:58:45.433]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.433]                 ...future.rng), started = ...future.startTime, 
[10:58:45.433]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.433]             version = "1.8"), class = "FutureResult")
[10:58:45.433]     }, finally = {
[10:58:45.433]         if (!identical(...future.workdir, getwd())) 
[10:58:45.433]             setwd(...future.workdir)
[10:58:45.433]         {
[10:58:45.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.433]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.433]             }
[10:58:45.433]             base::options(...future.oldOptions)
[10:58:45.433]             if (.Platform$OS.type == "windows") {
[10:58:45.433]                 old_names <- names(...future.oldEnvVars)
[10:58:45.433]                 envs <- base::Sys.getenv()
[10:58:45.433]                 names <- names(envs)
[10:58:45.433]                 common <- intersect(names, old_names)
[10:58:45.433]                 added <- setdiff(names, old_names)
[10:58:45.433]                 removed <- setdiff(old_names, names)
[10:58:45.433]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.433]                   envs[common]]
[10:58:45.433]                 NAMES <- toupper(changed)
[10:58:45.433]                 args <- list()
[10:58:45.433]                 for (kk in seq_along(NAMES)) {
[10:58:45.433]                   name <- changed[[kk]]
[10:58:45.433]                   NAME <- NAMES[[kk]]
[10:58:45.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.433]                     next
[10:58:45.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.433]                 }
[10:58:45.433]                 NAMES <- toupper(added)
[10:58:45.433]                 for (kk in seq_along(NAMES)) {
[10:58:45.433]                   name <- added[[kk]]
[10:58:45.433]                   NAME <- NAMES[[kk]]
[10:58:45.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.433]                     next
[10:58:45.433]                   args[[name]] <- ""
[10:58:45.433]                 }
[10:58:45.433]                 NAMES <- toupper(removed)
[10:58:45.433]                 for (kk in seq_along(NAMES)) {
[10:58:45.433]                   name <- removed[[kk]]
[10:58:45.433]                   NAME <- NAMES[[kk]]
[10:58:45.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.433]                     next
[10:58:45.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.433]                 }
[10:58:45.433]                 if (length(args) > 0) 
[10:58:45.433]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.433]             }
[10:58:45.433]             else {
[10:58:45.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.433]             }
[10:58:45.433]             {
[10:58:45.433]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.433]                   0L) {
[10:58:45.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.433]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.433]                   base::options(opts)
[10:58:45.433]                 }
[10:58:45.433]                 {
[10:58:45.433]                   {
[10:58:45.433]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.433]                     NULL
[10:58:45.433]                   }
[10:58:45.433]                   options(future.plan = NULL)
[10:58:45.433]                   if (is.na(NA_character_)) 
[10:58:45.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.433]                     .init = FALSE)
[10:58:45.433]                 }
[10:58:45.433]             }
[10:58:45.433]         }
[10:58:45.433]     })
[10:58:45.433]     if (TRUE) {
[10:58:45.433]         base::sink(type = "output", split = FALSE)
[10:58:45.433]         if (TRUE) {
[10:58:45.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.433]         }
[10:58:45.433]         else {
[10:58:45.433]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.433]         }
[10:58:45.433]         base::close(...future.stdout)
[10:58:45.433]         ...future.stdout <- NULL
[10:58:45.433]     }
[10:58:45.433]     ...future.result$conditions <- ...future.conditions
[10:58:45.433]     ...future.result$finished <- base::Sys.time()
[10:58:45.433]     ...future.result
[10:58:45.433] }
[10:58:45.436] Exporting 5 global objects (2.72 KiB) to cluster node #2 ...
[10:58:45.436] Exporting ‘...future.FUN’ (762 bytes) to cluster node #2 ...
[10:58:45.436] Exporting ‘...future.FUN’ (762 bytes) to cluster node #2 ... DONE
[10:58:45.436] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #2 ...
[10:58:45.437] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #2 ... DONE
[10:58:45.437] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[10:58:45.437] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[10:58:45.437] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:45.438] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.438] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:45.438] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.438] Exporting 5 global objects (2.72 KiB) to cluster node #2 ... DONE
[10:58:45.439] MultisessionFuture started
[10:58:45.439] - Launch lazy future ... done
[10:58:45.439] run() for ‘MultisessionFuture’ ... done
[10:58:45.439] Created future:
[10:58:45.439] MultisessionFuture:
[10:58:45.439] Label: ‘future_by-2’
[10:58:45.439] Expression:
[10:58:45.439] {
[10:58:45.439]     do.call(function(...) {
[10:58:45.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.439]             on.exit(options(oopts), add = TRUE)
[10:58:45.439]         }
[10:58:45.439]         {
[10:58:45.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.439]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.439]             })
[10:58:45.439]         }
[10:58:45.439]     }, args = future.call.arguments)
[10:58:45.439] }
[10:58:45.439] Lazy evaluation: FALSE
[10:58:45.439] Asynchronous evaluation: TRUE
[10:58:45.439] Local evaluation: TRUE
[10:58:45.439] Environment: R_GlobalEnv
[10:58:45.439] Capture standard output: TRUE
[10:58:45.439] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.439] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.439] Packages: 1 packages (‘stats’)
[10:58:45.439] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.439] Resolved: FALSE
[10:58:45.439] Value: <not collected>
[10:58:45.439] Conditions captured: <none>
[10:58:45.439] Early signaling: FALSE
[10:58:45.439] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.439] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.451] Chunk #2 of 2 ... DONE
[10:58:45.451] Launching 2 futures (chunks) ... DONE
[10:58:45.451] Resolving 2 futures (chunks) ...
[10:58:45.451] resolve() on list ...
[10:58:45.451]  recursive: 0
[10:58:45.453]  length: 2
[10:58:45.454] 
[10:58:45.454] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.454] - Validating connection of MultisessionFuture
[10:58:45.454] - received message: FutureResult
[10:58:45.454] - Received FutureResult
[10:58:45.455] - Erased future from FutureRegistry
[10:58:45.455] result() for ClusterFuture ...
[10:58:45.455] - result already collected: FutureResult
[10:58:45.455] result() for ClusterFuture ... done
[10:58:45.455] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.455] Future #1
[10:58:45.455] result() for ClusterFuture ...
[10:58:45.455] - result already collected: FutureResult
[10:58:45.455] result() for ClusterFuture ... done
[10:58:45.455] result() for ClusterFuture ...
[10:58:45.455] - result already collected: FutureResult
[10:58:45.455] result() for ClusterFuture ... done
[10:58:45.456] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:45.456] - nx: 2
[10:58:45.456] - relay: TRUE
[10:58:45.456] - stdout: TRUE
[10:58:45.456] - signal: TRUE
[10:58:45.456] - resignal: FALSE
[10:58:45.456] - force: TRUE
[10:58:45.456] - relayed: [n=2] FALSE, FALSE
[10:58:45.456] - queued futures: [n=2] FALSE, FALSE
[10:58:45.456]  - until=1
[10:58:45.456]  - relaying element #1
[10:58:45.456] result() for ClusterFuture ...
[10:58:45.456] - result already collected: FutureResult
[10:58:45.457] result() for ClusterFuture ... done
[10:58:45.457] result() for ClusterFuture ...
[10:58:45.457] - result already collected: FutureResult
[10:58:45.457] result() for ClusterFuture ... done
[10:58:45.457] result() for ClusterFuture ...
[10:58:45.457] - result already collected: FutureResult
[10:58:45.457] result() for ClusterFuture ... done
[10:58:45.457] result() for ClusterFuture ...
[10:58:45.457] - result already collected: FutureResult
[10:58:45.457] result() for ClusterFuture ... done
[10:58:45.457] - relayed: [n=2] TRUE, FALSE
[10:58:45.457] - queued futures: [n=2] TRUE, FALSE
[10:58:45.457] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:45.458]  length: 1 (resolved future 1)
[10:58:45.485] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.485] - Validating connection of MultisessionFuture
[10:58:45.485] - received message: FutureResult
[10:58:45.485] - Received FutureResult
[10:58:45.486] - Erased future from FutureRegistry
[10:58:45.486] result() for ClusterFuture ...
[10:58:45.486] - result already collected: FutureResult
[10:58:45.486] result() for ClusterFuture ... done
[10:58:45.486] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.486] Future #2
[10:58:45.486] result() for ClusterFuture ...
[10:58:45.486] - result already collected: FutureResult
[10:58:45.486] result() for ClusterFuture ... done
[10:58:45.486] result() for ClusterFuture ...
[10:58:45.486] - result already collected: FutureResult
[10:58:45.486] result() for ClusterFuture ... done
[10:58:45.487] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:45.487] - nx: 2
[10:58:45.487] - relay: TRUE
[10:58:45.487] - stdout: TRUE
[10:58:45.487] - signal: TRUE
[10:58:45.487] - resignal: FALSE
[10:58:45.487] - force: TRUE
[10:58:45.487] - relayed: [n=2] TRUE, FALSE
[10:58:45.487] - queued futures: [n=2] TRUE, FALSE
[10:58:45.487]  - until=2
[10:58:45.487]  - relaying element #2
[10:58:45.487] result() for ClusterFuture ...
[10:58:45.487] - result already collected: FutureResult
[10:58:45.488] result() for ClusterFuture ... done
[10:58:45.488] result() for ClusterFuture ...
[10:58:45.488] - result already collected: FutureResult
[10:58:45.488] result() for ClusterFuture ... done
[10:58:45.488] result() for ClusterFuture ...
[10:58:45.488] - result already collected: FutureResult
[10:58:45.488] result() for ClusterFuture ... done
[10:58:45.488] result() for ClusterFuture ...
[10:58:45.488] - result already collected: FutureResult
[10:58:45.488] result() for ClusterFuture ... done
[10:58:45.488] - relayed: [n=2] TRUE, TRUE
[10:58:45.488] - queued futures: [n=2] TRUE, TRUE
[10:58:45.488] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:45.489]  length: 0 (resolved future 2)
[10:58:45.489] Relaying remaining futures
[10:58:45.489] signalConditionsASAP(NULL, pos=0) ...
[10:58:45.489] - nx: 2
[10:58:45.489] - relay: TRUE
[10:58:45.489] - stdout: TRUE
[10:58:45.489] - signal: TRUE
[10:58:45.489] - resignal: FALSE
[10:58:45.489] - force: TRUE
[10:58:45.489] - relayed: [n=2] TRUE, TRUE
[10:58:45.489] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:45.489] - relayed: [n=2] TRUE, TRUE
[10:58:45.490] - queued futures: [n=2] TRUE, TRUE
[10:58:45.490] signalConditionsASAP(NULL, pos=0) ... done
[10:58:45.490] resolve() on list ... DONE
[10:58:45.490] result() for ClusterFuture ...
[10:58:45.490] - result already collected: FutureResult
[10:58:45.490] result() for ClusterFuture ... done
[10:58:45.490] result() for ClusterFuture ...
[10:58:45.490] - result already collected: FutureResult
[10:58:45.490] result() for ClusterFuture ... done
[10:58:45.490] result() for ClusterFuture ...
[10:58:45.490] - result already collected: FutureResult
[10:58:45.490] result() for ClusterFuture ... done
[10:58:45.490] result() for ClusterFuture ...
[10:58:45.491] - result already collected: FutureResult
[10:58:45.491] result() for ClusterFuture ... done
[10:58:45.491]  - Number of value chunks collected: 2
[10:58:45.491] Resolving 2 futures (chunks) ... DONE
[10:58:45.491] Reducing values from 2 chunks ...
[10:58:45.491]  - Number of values collected after concatenation: 3
[10:58:45.491]  - Number of values expected: 3
[10:58:45.491] Reducing values from 2 chunks ... DONE
[10:58:45.491] future_lapply() ... DONE
[10:58:45.491] future_by_internal() ... DONE
[10:58:45.495] future_by_internal() ...
[10:58:45.495] future_lapply() ...
[10:58:45.498] Number of chunks: 2
[10:58:45.498] getGlobalsAndPackagesXApply() ...
[10:58:45.498]  - future.globals: TRUE
[10:58:45.498] getGlobalsAndPackages() ...
[10:58:45.498] Searching for globals...
[10:58:45.500] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:58:45.500] Searching for globals ... DONE
[10:58:45.500] Resolving globals: FALSE
[10:58:45.500] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:58:45.501] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:58:45.501] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:45.501] - packages: [1] ‘stats’
[10:58:45.501] getGlobalsAndPackages() ... DONE
[10:58:45.501]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:58:45.501]  - needed namespaces: [n=1] ‘stats’
[10:58:45.501] Finding globals ... DONE
[10:58:45.501]  - use_args: TRUE
[10:58:45.502]  - Getting '...' globals ...
[10:58:45.502] resolve() on list ...
[10:58:45.502]  recursive: 0
[10:58:45.502]  length: 1
[10:58:45.502]  elements: ‘...’
[10:58:45.502]  length: 0 (resolved future 1)
[10:58:45.502] resolve() on list ... DONE
[10:58:45.502]    - '...' content: [n=0] 
[10:58:45.502] List of 1
[10:58:45.502]  $ ...: list()
[10:58:45.502]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.502]  - attr(*, "where")=List of 1
[10:58:45.502]   ..$ ...:<environment: 0x55974fad3b00> 
[10:58:45.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.502]  - attr(*, "resolved")= logi TRUE
[10:58:45.502]  - attr(*, "total_size")= num NA
[10:58:45.505]  - Getting '...' globals ... DONE
[10:58:45.505] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:58:45.505] List of 4
[10:58:45.505]  $ ...future.FUN:function (x)  
[10:58:45.505]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:58:45.505]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:58:45.505]  $ ...          : list()
[10:58:45.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.505]  - attr(*, "where")=List of 4
[10:58:45.505]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:45.505]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:58:45.505]   ..$ wool         :<environment: R_EmptyEnv> 
[10:58:45.505]   ..$ ...          :<environment: 0x55974fad3b00> 
[10:58:45.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.505]  - attr(*, "resolved")= logi FALSE
[10:58:45.505]  - attr(*, "total_size")= num 18867
[10:58:45.509] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:45.509] getGlobalsAndPackagesXApply() ... DONE
[10:58:45.509] Number of futures (= number of chunks): 2
[10:58:45.509] Launching 2 futures (chunks) ...
[10:58:45.509] Chunk #1 of 2 ...
[10:58:45.509]  - Finding globals in 'X' for chunk #1 ...
[10:58:45.509] getGlobalsAndPackages() ...
[10:58:45.509] Searching for globals...
[10:58:45.510] 
[10:58:45.510] Searching for globals ... DONE
[10:58:45.510] - globals: [0] <none>
[10:58:45.510] getGlobalsAndPackages() ... DONE
[10:58:45.510]    + additional globals found: [n=0] 
[10:58:45.510]    + additional namespaces needed: [n=0] 
[10:58:45.510]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:45.510]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.510]  - seeds: <none>
[10:58:45.510]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.510] getGlobalsAndPackages() ...
[10:58:45.511] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.511] Resolving globals: FALSE
[10:58:45.511] Tweak future expression to call with '...' arguments ...
[10:58:45.511] {
[10:58:45.511]     do.call(function(...) {
[10:58:45.511]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.511]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.511]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.511]             on.exit(options(oopts), add = TRUE)
[10:58:45.511]         }
[10:58:45.511]         {
[10:58:45.511]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.511]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.511]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.511]             })
[10:58:45.511]         }
[10:58:45.511]     }, args = future.call.arguments)
[10:58:45.511] }
[10:58:45.511] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.511] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.512] 
[10:58:45.512] getGlobalsAndPackages() ... DONE
[10:58:45.512] run() for ‘Future’ ...
[10:58:45.512] - state: ‘created’
[10:58:45.512] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.526]   - Field: ‘node’
[10:58:45.526]   - Field: ‘label’
[10:58:45.526]   - Field: ‘local’
[10:58:45.527]   - Field: ‘owner’
[10:58:45.527]   - Field: ‘envir’
[10:58:45.527]   - Field: ‘workers’
[10:58:45.527]   - Field: ‘packages’
[10:58:45.527]   - Field: ‘gc’
[10:58:45.527]   - Field: ‘conditions’
[10:58:45.527]   - Field: ‘persistent’
[10:58:45.527]   - Field: ‘expr’
[10:58:45.527]   - Field: ‘uuid’
[10:58:45.527]   - Field: ‘seed’
[10:58:45.527]   - Field: ‘version’
[10:58:45.527]   - Field: ‘result’
[10:58:45.527]   - Field: ‘asynchronous’
[10:58:45.528]   - Field: ‘calls’
[10:58:45.528]   - Field: ‘globals’
[10:58:45.528]   - Field: ‘stdout’
[10:58:45.528]   - Field: ‘earlySignal’
[10:58:45.528]   - Field: ‘lazy’
[10:58:45.528]   - Field: ‘state’
[10:58:45.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.528] - Launch lazy future ...
[10:58:45.528] Packages needed by the future expression (n = 1): ‘stats’
[10:58:45.529] Packages needed by future strategies (n = 0): <none>
[10:58:45.529] {
[10:58:45.529]     {
[10:58:45.529]         {
[10:58:45.529]             ...future.startTime <- base::Sys.time()
[10:58:45.529]             {
[10:58:45.529]                 {
[10:58:45.529]                   {
[10:58:45.529]                     {
[10:58:45.529]                       {
[10:58:45.529]                         base::local({
[10:58:45.529]                           has_future <- base::requireNamespace("future", 
[10:58:45.529]                             quietly = TRUE)
[10:58:45.529]                           if (has_future) {
[10:58:45.529]                             ns <- base::getNamespace("future")
[10:58:45.529]                             version <- ns[[".package"]][["version"]]
[10:58:45.529]                             if (is.null(version)) 
[10:58:45.529]                               version <- utils::packageVersion("future")
[10:58:45.529]                           }
[10:58:45.529]                           else {
[10:58:45.529]                             version <- NULL
[10:58:45.529]                           }
[10:58:45.529]                           if (!has_future || version < "1.8.0") {
[10:58:45.529]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.529]                               "", base::R.version$version.string), 
[10:58:45.529]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:45.529]                                 base::R.version$platform, 8 * 
[10:58:45.529]                                   base::.Machine$sizeof.pointer), 
[10:58:45.529]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.529]                                 "release", "version")], collapse = " "), 
[10:58:45.529]                               hostname = base::Sys.info()[["nodename"]])
[10:58:45.529]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.529]                               info)
[10:58:45.529]                             info <- base::paste(info, collapse = "; ")
[10:58:45.529]                             if (!has_future) {
[10:58:45.529]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.529]                                 info)
[10:58:45.529]                             }
[10:58:45.529]                             else {
[10:58:45.529]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.529]                                 info, version)
[10:58:45.529]                             }
[10:58:45.529]                             base::stop(msg)
[10:58:45.529]                           }
[10:58:45.529]                         })
[10:58:45.529]                       }
[10:58:45.529]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.529]                       base::options(mc.cores = 1L)
[10:58:45.529]                     }
[10:58:45.529]                     base::local({
[10:58:45.529]                       for (pkg in "stats") {
[10:58:45.529]                         base::loadNamespace(pkg)
[10:58:45.529]                         base::library(pkg, character.only = TRUE)
[10:58:45.529]                       }
[10:58:45.529]                     })
[10:58:45.529]                   }
[10:58:45.529]                   ...future.strategy.old <- future::plan("list")
[10:58:45.529]                   options(future.plan = NULL)
[10:58:45.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.529]                 }
[10:58:45.529]                 ...future.workdir <- getwd()
[10:58:45.529]             }
[10:58:45.529]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.529]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.529]         }
[10:58:45.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.529]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.529]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.529]             base::names(...future.oldOptions))
[10:58:45.529]     }
[10:58:45.529]     if (FALSE) {
[10:58:45.529]     }
[10:58:45.529]     else {
[10:58:45.529]         if (TRUE) {
[10:58:45.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.529]                 open = "w")
[10:58:45.529]         }
[10:58:45.529]         else {
[10:58:45.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.529]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.529]         }
[10:58:45.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.529]             base::sink(type = "output", split = FALSE)
[10:58:45.529]             base::close(...future.stdout)
[10:58:45.529]         }, add = TRUE)
[10:58:45.529]     }
[10:58:45.529]     ...future.frame <- base::sys.nframe()
[10:58:45.529]     ...future.conditions <- base::list()
[10:58:45.529]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.529]     if (FALSE) {
[10:58:45.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.529]     }
[10:58:45.529]     ...future.result <- base::tryCatch({
[10:58:45.529]         base::withCallingHandlers({
[10:58:45.529]             ...future.value <- base::withVisible(base::local({
[10:58:45.529]                 ...future.makeSendCondition <- base::local({
[10:58:45.529]                   sendCondition <- NULL
[10:58:45.529]                   function(frame = 1L) {
[10:58:45.529]                     if (is.function(sendCondition)) 
[10:58:45.529]                       return(sendCondition)
[10:58:45.529]                     ns <- getNamespace("parallel")
[10:58:45.529]                     if (exists("sendData", mode = "function", 
[10:58:45.529]                       envir = ns)) {
[10:58:45.529]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.529]                         envir = ns)
[10:58:45.529]                       envir <- sys.frame(frame)
[10:58:45.529]                       master <- NULL
[10:58:45.529]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.529]                         !identical(envir, emptyenv())) {
[10:58:45.529]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.529]                           inherits = FALSE)) {
[10:58:45.529]                           master <- get("master", mode = "list", 
[10:58:45.529]                             envir = envir, inherits = FALSE)
[10:58:45.529]                           if (inherits(master, c("SOCKnode", 
[10:58:45.529]                             "SOCK0node"))) {
[10:58:45.529]                             sendCondition <<- function(cond) {
[10:58:45.529]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.529]                                 success = TRUE)
[10:58:45.529]                               parallel_sendData(master, data)
[10:58:45.529]                             }
[10:58:45.529]                             return(sendCondition)
[10:58:45.529]                           }
[10:58:45.529]                         }
[10:58:45.529]                         frame <- frame + 1L
[10:58:45.529]                         envir <- sys.frame(frame)
[10:58:45.529]                       }
[10:58:45.529]                     }
[10:58:45.529]                     sendCondition <<- function(cond) NULL
[10:58:45.529]                   }
[10:58:45.529]                 })
[10:58:45.529]                 withCallingHandlers({
[10:58:45.529]                   {
[10:58:45.529]                     do.call(function(...) {
[10:58:45.529]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.529]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.529]                         ...future.globals.maxSize)) {
[10:58:45.529]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.529]                         on.exit(options(oopts), add = TRUE)
[10:58:45.529]                       }
[10:58:45.529]                       {
[10:58:45.529]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.529]                           FUN = function(jj) {
[10:58:45.529]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.529]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.529]                           })
[10:58:45.529]                       }
[10:58:45.529]                     }, args = future.call.arguments)
[10:58:45.529]                   }
[10:58:45.529]                 }, immediateCondition = function(cond) {
[10:58:45.529]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.529]                   sendCondition(cond)
[10:58:45.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.529]                   {
[10:58:45.529]                     inherits <- base::inherits
[10:58:45.529]                     invokeRestart <- base::invokeRestart
[10:58:45.529]                     is.null <- base::is.null
[10:58:45.529]                     muffled <- FALSE
[10:58:45.529]                     if (inherits(cond, "message")) {
[10:58:45.529]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.529]                       if (muffled) 
[10:58:45.529]                         invokeRestart("muffleMessage")
[10:58:45.529]                     }
[10:58:45.529]                     else if (inherits(cond, "warning")) {
[10:58:45.529]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.529]                       if (muffled) 
[10:58:45.529]                         invokeRestart("muffleWarning")
[10:58:45.529]                     }
[10:58:45.529]                     else if (inherits(cond, "condition")) {
[10:58:45.529]                       if (!is.null(pattern)) {
[10:58:45.529]                         computeRestarts <- base::computeRestarts
[10:58:45.529]                         grepl <- base::grepl
[10:58:45.529]                         restarts <- computeRestarts(cond)
[10:58:45.529]                         for (restart in restarts) {
[10:58:45.529]                           name <- restart$name
[10:58:45.529]                           if (is.null(name)) 
[10:58:45.529]                             next
[10:58:45.529]                           if (!grepl(pattern, name)) 
[10:58:45.529]                             next
[10:58:45.529]                           invokeRestart(restart)
[10:58:45.529]                           muffled <- TRUE
[10:58:45.529]                           break
[10:58:45.529]                         }
[10:58:45.529]                       }
[10:58:45.529]                     }
[10:58:45.529]                     invisible(muffled)
[10:58:45.529]                   }
[10:58:45.529]                   muffleCondition(cond)
[10:58:45.529]                 })
[10:58:45.529]             }))
[10:58:45.529]             future::FutureResult(value = ...future.value$value, 
[10:58:45.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.529]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.529]                     ...future.globalenv.names))
[10:58:45.529]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.529]         }, condition = base::local({
[10:58:45.529]             c <- base::c
[10:58:45.529]             inherits <- base::inherits
[10:58:45.529]             invokeRestart <- base::invokeRestart
[10:58:45.529]             length <- base::length
[10:58:45.529]             list <- base::list
[10:58:45.529]             seq.int <- base::seq.int
[10:58:45.529]             signalCondition <- base::signalCondition
[10:58:45.529]             sys.calls <- base::sys.calls
[10:58:45.529]             `[[` <- base::`[[`
[10:58:45.529]             `+` <- base::`+`
[10:58:45.529]             `<<-` <- base::`<<-`
[10:58:45.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.529]                   3L)]
[10:58:45.529]             }
[10:58:45.529]             function(cond) {
[10:58:45.529]                 is_error <- inherits(cond, "error")
[10:58:45.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.529]                   NULL)
[10:58:45.529]                 if (is_error) {
[10:58:45.529]                   sessionInformation <- function() {
[10:58:45.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.529]                       search = base::search(), system = base::Sys.info())
[10:58:45.529]                   }
[10:58:45.529]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.529]                     cond$call), session = sessionInformation(), 
[10:58:45.529]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.529]                   signalCondition(cond)
[10:58:45.529]                 }
[10:58:45.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.529]                 "immediateCondition"))) {
[10:58:45.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.529]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.529]                   if (TRUE && !signal) {
[10:58:45.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.529]                     {
[10:58:45.529]                       inherits <- base::inherits
[10:58:45.529]                       invokeRestart <- base::invokeRestart
[10:58:45.529]                       is.null <- base::is.null
[10:58:45.529]                       muffled <- FALSE
[10:58:45.529]                       if (inherits(cond, "message")) {
[10:58:45.529]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.529]                         if (muffled) 
[10:58:45.529]                           invokeRestart("muffleMessage")
[10:58:45.529]                       }
[10:58:45.529]                       else if (inherits(cond, "warning")) {
[10:58:45.529]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.529]                         if (muffled) 
[10:58:45.529]                           invokeRestart("muffleWarning")
[10:58:45.529]                       }
[10:58:45.529]                       else if (inherits(cond, "condition")) {
[10:58:45.529]                         if (!is.null(pattern)) {
[10:58:45.529]                           computeRestarts <- base::computeRestarts
[10:58:45.529]                           grepl <- base::grepl
[10:58:45.529]                           restarts <- computeRestarts(cond)
[10:58:45.529]                           for (restart in restarts) {
[10:58:45.529]                             name <- restart$name
[10:58:45.529]                             if (is.null(name)) 
[10:58:45.529]                               next
[10:58:45.529]                             if (!grepl(pattern, name)) 
[10:58:45.529]                               next
[10:58:45.529]                             invokeRestart(restart)
[10:58:45.529]                             muffled <- TRUE
[10:58:45.529]                             break
[10:58:45.529]                           }
[10:58:45.529]                         }
[10:58:45.529]                       }
[10:58:45.529]                       invisible(muffled)
[10:58:45.529]                     }
[10:58:45.529]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.529]                   }
[10:58:45.529]                 }
[10:58:45.529]                 else {
[10:58:45.529]                   if (TRUE) {
[10:58:45.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.529]                     {
[10:58:45.529]                       inherits <- base::inherits
[10:58:45.529]                       invokeRestart <- base::invokeRestart
[10:58:45.529]                       is.null <- base::is.null
[10:58:45.529]                       muffled <- FALSE
[10:58:45.529]                       if (inherits(cond, "message")) {
[10:58:45.529]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.529]                         if (muffled) 
[10:58:45.529]                           invokeRestart("muffleMessage")
[10:58:45.529]                       }
[10:58:45.529]                       else if (inherits(cond, "warning")) {
[10:58:45.529]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.529]                         if (muffled) 
[10:58:45.529]                           invokeRestart("muffleWarning")
[10:58:45.529]                       }
[10:58:45.529]                       else if (inherits(cond, "condition")) {
[10:58:45.529]                         if (!is.null(pattern)) {
[10:58:45.529]                           computeRestarts <- base::computeRestarts
[10:58:45.529]                           grepl <- base::grepl
[10:58:45.529]                           restarts <- computeRestarts(cond)
[10:58:45.529]                           for (restart in restarts) {
[10:58:45.529]                             name <- restart$name
[10:58:45.529]                             if (is.null(name)) 
[10:58:45.529]                               next
[10:58:45.529]                             if (!grepl(pattern, name)) 
[10:58:45.529]                               next
[10:58:45.529]                             invokeRestart(restart)
[10:58:45.529]                             muffled <- TRUE
[10:58:45.529]                             break
[10:58:45.529]                           }
[10:58:45.529]                         }
[10:58:45.529]                       }
[10:58:45.529]                       invisible(muffled)
[10:58:45.529]                     }
[10:58:45.529]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.529]                   }
[10:58:45.529]                 }
[10:58:45.529]             }
[10:58:45.529]         }))
[10:58:45.529]     }, error = function(ex) {
[10:58:45.529]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.529]                 ...future.rng), started = ...future.startTime, 
[10:58:45.529]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.529]             version = "1.8"), class = "FutureResult")
[10:58:45.529]     }, finally = {
[10:58:45.529]         if (!identical(...future.workdir, getwd())) 
[10:58:45.529]             setwd(...future.workdir)
[10:58:45.529]         {
[10:58:45.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.529]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.529]             }
[10:58:45.529]             base::options(...future.oldOptions)
[10:58:45.529]             if (.Platform$OS.type == "windows") {
[10:58:45.529]                 old_names <- names(...future.oldEnvVars)
[10:58:45.529]                 envs <- base::Sys.getenv()
[10:58:45.529]                 names <- names(envs)
[10:58:45.529]                 common <- intersect(names, old_names)
[10:58:45.529]                 added <- setdiff(names, old_names)
[10:58:45.529]                 removed <- setdiff(old_names, names)
[10:58:45.529]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.529]                   envs[common]]
[10:58:45.529]                 NAMES <- toupper(changed)
[10:58:45.529]                 args <- list()
[10:58:45.529]                 for (kk in seq_along(NAMES)) {
[10:58:45.529]                   name <- changed[[kk]]
[10:58:45.529]                   NAME <- NAMES[[kk]]
[10:58:45.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.529]                     next
[10:58:45.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.529]                 }
[10:58:45.529]                 NAMES <- toupper(added)
[10:58:45.529]                 for (kk in seq_along(NAMES)) {
[10:58:45.529]                   name <- added[[kk]]
[10:58:45.529]                   NAME <- NAMES[[kk]]
[10:58:45.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.529]                     next
[10:58:45.529]                   args[[name]] <- ""
[10:58:45.529]                 }
[10:58:45.529]                 NAMES <- toupper(removed)
[10:58:45.529]                 for (kk in seq_along(NAMES)) {
[10:58:45.529]                   name <- removed[[kk]]
[10:58:45.529]                   NAME <- NAMES[[kk]]
[10:58:45.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.529]                     next
[10:58:45.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.529]                 }
[10:58:45.529]                 if (length(args) > 0) 
[10:58:45.529]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.529]             }
[10:58:45.529]             else {
[10:58:45.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.529]             }
[10:58:45.529]             {
[10:58:45.529]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.529]                   0L) {
[10:58:45.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.529]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.529]                   base::options(opts)
[10:58:45.529]                 }
[10:58:45.529]                 {
[10:58:45.529]                   {
[10:58:45.529]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.529]                     NULL
[10:58:45.529]                   }
[10:58:45.529]                   options(future.plan = NULL)
[10:58:45.529]                   if (is.na(NA_character_)) 
[10:58:45.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.529]                     .init = FALSE)
[10:58:45.529]                 }
[10:58:45.529]             }
[10:58:45.529]         }
[10:58:45.529]     })
[10:58:45.529]     if (TRUE) {
[10:58:45.529]         base::sink(type = "output", split = FALSE)
[10:58:45.529]         if (TRUE) {
[10:58:45.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.529]         }
[10:58:45.529]         else {
[10:58:45.529]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.529]         }
[10:58:45.529]         base::close(...future.stdout)
[10:58:45.529]         ...future.stdout <- NULL
[10:58:45.529]     }
[10:58:45.529]     ...future.result$conditions <- ...future.conditions
[10:58:45.529]     ...future.result$finished <- base::Sys.time()
[10:58:45.529]     ...future.result
[10:58:45.529] }
[10:58:45.532] Exporting 7 global objects (3.33 KiB) to cluster node #1 ...
[10:58:45.532] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ...
[10:58:45.533] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ... DONE
[10:58:45.533] Exporting ‘breaks’ (463 bytes) to cluster node #1 ...
[10:58:45.533] Exporting ‘breaks’ (463 bytes) to cluster node #1 ... DONE
[10:58:45.533] Exporting ‘wool’ (342 bytes) to cluster node #1 ...
[10:58:45.533] Exporting ‘wool’ (342 bytes) to cluster node #1 ... DONE
[10:58:45.534] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:45.534] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:45.534] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[10:58:45.534] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[10:58:45.535] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:45.535] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.535] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:45.535] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.535] Exporting 7 global objects (3.33 KiB) to cluster node #1 ... DONE
[10:58:45.536] MultisessionFuture started
[10:58:45.536] - Launch lazy future ... done
[10:58:45.536] run() for ‘MultisessionFuture’ ... done
[10:58:45.536] Created future:
[10:58:45.536] MultisessionFuture:
[10:58:45.536] Label: ‘future_by-1’
[10:58:45.536] Expression:
[10:58:45.536] {
[10:58:45.536]     do.call(function(...) {
[10:58:45.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.536]             on.exit(options(oopts), add = TRUE)
[10:58:45.536]         }
[10:58:45.536]         {
[10:58:45.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.536]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.536]             })
[10:58:45.536]         }
[10:58:45.536]     }, args = future.call.arguments)
[10:58:45.536] }
[10:58:45.536] Lazy evaluation: FALSE
[10:58:45.536] Asynchronous evaluation: TRUE
[10:58:45.536] Local evaluation: TRUE
[10:58:45.536] Environment: 0x55974fafee18
[10:58:45.536] Capture standard output: TRUE
[10:58:45.536] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.536] Globals: 7 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, ...)
[10:58:45.536] Packages: 1 packages (‘stats’)
[10:58:45.536] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.536] Resolved: FALSE
[10:58:45.536] Value: <not collected>
[10:58:45.536] Conditions captured: <none>
[10:58:45.536] Early signaling: FALSE
[10:58:45.536] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.536] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.548] Chunk #1 of 2 ... DONE
[10:58:45.548] Chunk #2 of 2 ...
[10:58:45.548]  - Finding globals in 'X' for chunk #2 ...
[10:58:45.548] getGlobalsAndPackages() ...
[10:58:45.548] Searching for globals...
[10:58:45.549] 
[10:58:45.549] Searching for globals ... DONE
[10:58:45.549] - globals: [0] <none>
[10:58:45.549] getGlobalsAndPackages() ... DONE
[10:58:45.549]    + additional globals found: [n=0] 
[10:58:45.549]    + additional namespaces needed: [n=0] 
[10:58:45.549]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:45.549]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.549]  - seeds: <none>
[10:58:45.550]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.550] getGlobalsAndPackages() ...
[10:58:45.550] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.550] Resolving globals: FALSE
[10:58:45.550] Tweak future expression to call with '...' arguments ...
[10:58:45.550] {
[10:58:45.550]     do.call(function(...) {
[10:58:45.550]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.550]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.550]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.550]             on.exit(options(oopts), add = TRUE)
[10:58:45.550]         }
[10:58:45.550]         {
[10:58:45.550]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.550]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.550]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.550]             })
[10:58:45.550]         }
[10:58:45.550]     }, args = future.call.arguments)
[10:58:45.550] }
[10:58:45.550] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.551] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.551] 
[10:58:45.551] getGlobalsAndPackages() ... DONE
[10:58:45.551] run() for ‘Future’ ...
[10:58:45.551] - state: ‘created’
[10:58:45.551] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.565]   - Field: ‘node’
[10:58:45.565]   - Field: ‘label’
[10:58:45.565]   - Field: ‘local’
[10:58:45.565]   - Field: ‘owner’
[10:58:45.566]   - Field: ‘envir’
[10:58:45.566]   - Field: ‘workers’
[10:58:45.566]   - Field: ‘packages’
[10:58:45.566]   - Field: ‘gc’
[10:58:45.566]   - Field: ‘conditions’
[10:58:45.566]   - Field: ‘persistent’
[10:58:45.566]   - Field: ‘expr’
[10:58:45.566]   - Field: ‘uuid’
[10:58:45.566]   - Field: ‘seed’
[10:58:45.566]   - Field: ‘version’
[10:58:45.566]   - Field: ‘result’
[10:58:45.566]   - Field: ‘asynchronous’
[10:58:45.567]   - Field: ‘calls’
[10:58:45.567]   - Field: ‘globals’
[10:58:45.567]   - Field: ‘stdout’
[10:58:45.567]   - Field: ‘earlySignal’
[10:58:45.567]   - Field: ‘lazy’
[10:58:45.567]   - Field: ‘state’
[10:58:45.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.567] - Launch lazy future ...
[10:58:45.567] Packages needed by the future expression (n = 1): ‘stats’
[10:58:45.568] Packages needed by future strategies (n = 0): <none>
[10:58:45.568] {
[10:58:45.568]     {
[10:58:45.568]         {
[10:58:45.568]             ...future.startTime <- base::Sys.time()
[10:58:45.568]             {
[10:58:45.568]                 {
[10:58:45.568]                   {
[10:58:45.568]                     {
[10:58:45.568]                       {
[10:58:45.568]                         base::local({
[10:58:45.568]                           has_future <- base::requireNamespace("future", 
[10:58:45.568]                             quietly = TRUE)
[10:58:45.568]                           if (has_future) {
[10:58:45.568]                             ns <- base::getNamespace("future")
[10:58:45.568]                             version <- ns[[".package"]][["version"]]
[10:58:45.568]                             if (is.null(version)) 
[10:58:45.568]                               version <- utils::packageVersion("future")
[10:58:45.568]                           }
[10:58:45.568]                           else {
[10:58:45.568]                             version <- NULL
[10:58:45.568]                           }
[10:58:45.568]                           if (!has_future || version < "1.8.0") {
[10:58:45.568]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.568]                               "", base::R.version$version.string), 
[10:58:45.568]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:45.568]                                 base::R.version$platform, 8 * 
[10:58:45.568]                                   base::.Machine$sizeof.pointer), 
[10:58:45.568]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.568]                                 "release", "version")], collapse = " "), 
[10:58:45.568]                               hostname = base::Sys.info()[["nodename"]])
[10:58:45.568]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.568]                               info)
[10:58:45.568]                             info <- base::paste(info, collapse = "; ")
[10:58:45.568]                             if (!has_future) {
[10:58:45.568]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.568]                                 info)
[10:58:45.568]                             }
[10:58:45.568]                             else {
[10:58:45.568]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.568]                                 info, version)
[10:58:45.568]                             }
[10:58:45.568]                             base::stop(msg)
[10:58:45.568]                           }
[10:58:45.568]                         })
[10:58:45.568]                       }
[10:58:45.568]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.568]                       base::options(mc.cores = 1L)
[10:58:45.568]                     }
[10:58:45.568]                     base::local({
[10:58:45.568]                       for (pkg in "stats") {
[10:58:45.568]                         base::loadNamespace(pkg)
[10:58:45.568]                         base::library(pkg, character.only = TRUE)
[10:58:45.568]                       }
[10:58:45.568]                     })
[10:58:45.568]                   }
[10:58:45.568]                   ...future.strategy.old <- future::plan("list")
[10:58:45.568]                   options(future.plan = NULL)
[10:58:45.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.568]                 }
[10:58:45.568]                 ...future.workdir <- getwd()
[10:58:45.568]             }
[10:58:45.568]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.568]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.568]         }
[10:58:45.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.568]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.568]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.568]             base::names(...future.oldOptions))
[10:58:45.568]     }
[10:58:45.568]     if (FALSE) {
[10:58:45.568]     }
[10:58:45.568]     else {
[10:58:45.568]         if (TRUE) {
[10:58:45.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.568]                 open = "w")
[10:58:45.568]         }
[10:58:45.568]         else {
[10:58:45.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.568]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.568]         }
[10:58:45.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.568]             base::sink(type = "output", split = FALSE)
[10:58:45.568]             base::close(...future.stdout)
[10:58:45.568]         }, add = TRUE)
[10:58:45.568]     }
[10:58:45.568]     ...future.frame <- base::sys.nframe()
[10:58:45.568]     ...future.conditions <- base::list()
[10:58:45.568]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.568]     if (FALSE) {
[10:58:45.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.568]     }
[10:58:45.568]     ...future.result <- base::tryCatch({
[10:58:45.568]         base::withCallingHandlers({
[10:58:45.568]             ...future.value <- base::withVisible(base::local({
[10:58:45.568]                 ...future.makeSendCondition <- base::local({
[10:58:45.568]                   sendCondition <- NULL
[10:58:45.568]                   function(frame = 1L) {
[10:58:45.568]                     if (is.function(sendCondition)) 
[10:58:45.568]                       return(sendCondition)
[10:58:45.568]                     ns <- getNamespace("parallel")
[10:58:45.568]                     if (exists("sendData", mode = "function", 
[10:58:45.568]                       envir = ns)) {
[10:58:45.568]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.568]                         envir = ns)
[10:58:45.568]                       envir <- sys.frame(frame)
[10:58:45.568]                       master <- NULL
[10:58:45.568]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.568]                         !identical(envir, emptyenv())) {
[10:58:45.568]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.568]                           inherits = FALSE)) {
[10:58:45.568]                           master <- get("master", mode = "list", 
[10:58:45.568]                             envir = envir, inherits = FALSE)
[10:58:45.568]                           if (inherits(master, c("SOCKnode", 
[10:58:45.568]                             "SOCK0node"))) {
[10:58:45.568]                             sendCondition <<- function(cond) {
[10:58:45.568]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.568]                                 success = TRUE)
[10:58:45.568]                               parallel_sendData(master, data)
[10:58:45.568]                             }
[10:58:45.568]                             return(sendCondition)
[10:58:45.568]                           }
[10:58:45.568]                         }
[10:58:45.568]                         frame <- frame + 1L
[10:58:45.568]                         envir <- sys.frame(frame)
[10:58:45.568]                       }
[10:58:45.568]                     }
[10:58:45.568]                     sendCondition <<- function(cond) NULL
[10:58:45.568]                   }
[10:58:45.568]                 })
[10:58:45.568]                 withCallingHandlers({
[10:58:45.568]                   {
[10:58:45.568]                     do.call(function(...) {
[10:58:45.568]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.568]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.568]                         ...future.globals.maxSize)) {
[10:58:45.568]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.568]                         on.exit(options(oopts), add = TRUE)
[10:58:45.568]                       }
[10:58:45.568]                       {
[10:58:45.568]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.568]                           FUN = function(jj) {
[10:58:45.568]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.568]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.568]                           })
[10:58:45.568]                       }
[10:58:45.568]                     }, args = future.call.arguments)
[10:58:45.568]                   }
[10:58:45.568]                 }, immediateCondition = function(cond) {
[10:58:45.568]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.568]                   sendCondition(cond)
[10:58:45.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.568]                   {
[10:58:45.568]                     inherits <- base::inherits
[10:58:45.568]                     invokeRestart <- base::invokeRestart
[10:58:45.568]                     is.null <- base::is.null
[10:58:45.568]                     muffled <- FALSE
[10:58:45.568]                     if (inherits(cond, "message")) {
[10:58:45.568]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.568]                       if (muffled) 
[10:58:45.568]                         invokeRestart("muffleMessage")
[10:58:45.568]                     }
[10:58:45.568]                     else if (inherits(cond, "warning")) {
[10:58:45.568]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.568]                       if (muffled) 
[10:58:45.568]                         invokeRestart("muffleWarning")
[10:58:45.568]                     }
[10:58:45.568]                     else if (inherits(cond, "condition")) {
[10:58:45.568]                       if (!is.null(pattern)) {
[10:58:45.568]                         computeRestarts <- base::computeRestarts
[10:58:45.568]                         grepl <- base::grepl
[10:58:45.568]                         restarts <- computeRestarts(cond)
[10:58:45.568]                         for (restart in restarts) {
[10:58:45.568]                           name <- restart$name
[10:58:45.568]                           if (is.null(name)) 
[10:58:45.568]                             next
[10:58:45.568]                           if (!grepl(pattern, name)) 
[10:58:45.568]                             next
[10:58:45.568]                           invokeRestart(restart)
[10:58:45.568]                           muffled <- TRUE
[10:58:45.568]                           break
[10:58:45.568]                         }
[10:58:45.568]                       }
[10:58:45.568]                     }
[10:58:45.568]                     invisible(muffled)
[10:58:45.568]                   }
[10:58:45.568]                   muffleCondition(cond)
[10:58:45.568]                 })
[10:58:45.568]             }))
[10:58:45.568]             future::FutureResult(value = ...future.value$value, 
[10:58:45.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.568]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.568]                     ...future.globalenv.names))
[10:58:45.568]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.568]         }, condition = base::local({
[10:58:45.568]             c <- base::c
[10:58:45.568]             inherits <- base::inherits
[10:58:45.568]             invokeRestart <- base::invokeRestart
[10:58:45.568]             length <- base::length
[10:58:45.568]             list <- base::list
[10:58:45.568]             seq.int <- base::seq.int
[10:58:45.568]             signalCondition <- base::signalCondition
[10:58:45.568]             sys.calls <- base::sys.calls
[10:58:45.568]             `[[` <- base::`[[`
[10:58:45.568]             `+` <- base::`+`
[10:58:45.568]             `<<-` <- base::`<<-`
[10:58:45.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.568]                   3L)]
[10:58:45.568]             }
[10:58:45.568]             function(cond) {
[10:58:45.568]                 is_error <- inherits(cond, "error")
[10:58:45.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.568]                   NULL)
[10:58:45.568]                 if (is_error) {
[10:58:45.568]                   sessionInformation <- function() {
[10:58:45.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.568]                       search = base::search(), system = base::Sys.info())
[10:58:45.568]                   }
[10:58:45.568]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.568]                     cond$call), session = sessionInformation(), 
[10:58:45.568]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.568]                   signalCondition(cond)
[10:58:45.568]                 }
[10:58:45.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.568]                 "immediateCondition"))) {
[10:58:45.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.568]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.568]                   if (TRUE && !signal) {
[10:58:45.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.568]                     {
[10:58:45.568]                       inherits <- base::inherits
[10:58:45.568]                       invokeRestart <- base::invokeRestart
[10:58:45.568]                       is.null <- base::is.null
[10:58:45.568]                       muffled <- FALSE
[10:58:45.568]                       if (inherits(cond, "message")) {
[10:58:45.568]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.568]                         if (muffled) 
[10:58:45.568]                           invokeRestart("muffleMessage")
[10:58:45.568]                       }
[10:58:45.568]                       else if (inherits(cond, "warning")) {
[10:58:45.568]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.568]                         if (muffled) 
[10:58:45.568]                           invokeRestart("muffleWarning")
[10:58:45.568]                       }
[10:58:45.568]                       else if (inherits(cond, "condition")) {
[10:58:45.568]                         if (!is.null(pattern)) {
[10:58:45.568]                           computeRestarts <- base::computeRestarts
[10:58:45.568]                           grepl <- base::grepl
[10:58:45.568]                           restarts <- computeRestarts(cond)
[10:58:45.568]                           for (restart in restarts) {
[10:58:45.568]                             name <- restart$name
[10:58:45.568]                             if (is.null(name)) 
[10:58:45.568]                               next
[10:58:45.568]                             if (!grepl(pattern, name)) 
[10:58:45.568]                               next
[10:58:45.568]                             invokeRestart(restart)
[10:58:45.568]                             muffled <- TRUE
[10:58:45.568]                             break
[10:58:45.568]                           }
[10:58:45.568]                         }
[10:58:45.568]                       }
[10:58:45.568]                       invisible(muffled)
[10:58:45.568]                     }
[10:58:45.568]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.568]                   }
[10:58:45.568]                 }
[10:58:45.568]                 else {
[10:58:45.568]                   if (TRUE) {
[10:58:45.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.568]                     {
[10:58:45.568]                       inherits <- base::inherits
[10:58:45.568]                       invokeRestart <- base::invokeRestart
[10:58:45.568]                       is.null <- base::is.null
[10:58:45.568]                       muffled <- FALSE
[10:58:45.568]                       if (inherits(cond, "message")) {
[10:58:45.568]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.568]                         if (muffled) 
[10:58:45.568]                           invokeRestart("muffleMessage")
[10:58:45.568]                       }
[10:58:45.568]                       else if (inherits(cond, "warning")) {
[10:58:45.568]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.568]                         if (muffled) 
[10:58:45.568]                           invokeRestart("muffleWarning")
[10:58:45.568]                       }
[10:58:45.568]                       else if (inherits(cond, "condition")) {
[10:58:45.568]                         if (!is.null(pattern)) {
[10:58:45.568]                           computeRestarts <- base::computeRestarts
[10:58:45.568]                           grepl <- base::grepl
[10:58:45.568]                           restarts <- computeRestarts(cond)
[10:58:45.568]                           for (restart in restarts) {
[10:58:45.568]                             name <- restart$name
[10:58:45.568]                             if (is.null(name)) 
[10:58:45.568]                               next
[10:58:45.568]                             if (!grepl(pattern, name)) 
[10:58:45.568]                               next
[10:58:45.568]                             invokeRestart(restart)
[10:58:45.568]                             muffled <- TRUE
[10:58:45.568]                             break
[10:58:45.568]                           }
[10:58:45.568]                         }
[10:58:45.568]                       }
[10:58:45.568]                       invisible(muffled)
[10:58:45.568]                     }
[10:58:45.568]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.568]                   }
[10:58:45.568]                 }
[10:58:45.568]             }
[10:58:45.568]         }))
[10:58:45.568]     }, error = function(ex) {
[10:58:45.568]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.568]                 ...future.rng), started = ...future.startTime, 
[10:58:45.568]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.568]             version = "1.8"), class = "FutureResult")
[10:58:45.568]     }, finally = {
[10:58:45.568]         if (!identical(...future.workdir, getwd())) 
[10:58:45.568]             setwd(...future.workdir)
[10:58:45.568]         {
[10:58:45.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.568]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.568]             }
[10:58:45.568]             base::options(...future.oldOptions)
[10:58:45.568]             if (.Platform$OS.type == "windows") {
[10:58:45.568]                 old_names <- names(...future.oldEnvVars)
[10:58:45.568]                 envs <- base::Sys.getenv()
[10:58:45.568]                 names <- names(envs)
[10:58:45.568]                 common <- intersect(names, old_names)
[10:58:45.568]                 added <- setdiff(names, old_names)
[10:58:45.568]                 removed <- setdiff(old_names, names)
[10:58:45.568]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.568]                   envs[common]]
[10:58:45.568]                 NAMES <- toupper(changed)
[10:58:45.568]                 args <- list()
[10:58:45.568]                 for (kk in seq_along(NAMES)) {
[10:58:45.568]                   name <- changed[[kk]]
[10:58:45.568]                   NAME <- NAMES[[kk]]
[10:58:45.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.568]                     next
[10:58:45.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.568]                 }
[10:58:45.568]                 NAMES <- toupper(added)
[10:58:45.568]                 for (kk in seq_along(NAMES)) {
[10:58:45.568]                   name <- added[[kk]]
[10:58:45.568]                   NAME <- NAMES[[kk]]
[10:58:45.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.568]                     next
[10:58:45.568]                   args[[name]] <- ""
[10:58:45.568]                 }
[10:58:45.568]                 NAMES <- toupper(removed)
[10:58:45.568]                 for (kk in seq_along(NAMES)) {
[10:58:45.568]                   name <- removed[[kk]]
[10:58:45.568]                   NAME <- NAMES[[kk]]
[10:58:45.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.568]                     next
[10:58:45.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.568]                 }
[10:58:45.568]                 if (length(args) > 0) 
[10:58:45.568]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.568]             }
[10:58:45.568]             else {
[10:58:45.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.568]             }
[10:58:45.568]             {
[10:58:45.568]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.568]                   0L) {
[10:58:45.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.568]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.568]                   base::options(opts)
[10:58:45.568]                 }
[10:58:45.568]                 {
[10:58:45.568]                   {
[10:58:45.568]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.568]                     NULL
[10:58:45.568]                   }
[10:58:45.568]                   options(future.plan = NULL)
[10:58:45.568]                   if (is.na(NA_character_)) 
[10:58:45.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.568]                     .init = FALSE)
[10:58:45.568]                 }
[10:58:45.568]             }
[10:58:45.568]         }
[10:58:45.568]     })
[10:58:45.568]     if (TRUE) {
[10:58:45.568]         base::sink(type = "output", split = FALSE)
[10:58:45.568]         if (TRUE) {
[10:58:45.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.568]         }
[10:58:45.568]         else {
[10:58:45.568]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.568]         }
[10:58:45.568]         base::close(...future.stdout)
[10:58:45.568]         ...future.stdout <- NULL
[10:58:45.568]     }
[10:58:45.568]     ...future.result$conditions <- ...future.conditions
[10:58:45.568]     ...future.result$finished <- base::Sys.time()
[10:58:45.568]     ...future.result
[10:58:45.568] }
[10:58:45.571] Exporting 7 global objects (3.97 KiB) to cluster node #2 ...
[10:58:45.571] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ...
[10:58:45.571] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ... DONE
[10:58:45.572] Exporting ‘breaks’ (463 bytes) to cluster node #2 ...
[10:58:45.572] Exporting ‘breaks’ (463 bytes) to cluster node #2 ... DONE
[10:58:45.572] Exporting ‘wool’ (342 bytes) to cluster node #2 ...
[10:58:45.572] Exporting ‘wool’ (342 bytes) to cluster node #2 ... DONE
[10:58:45.573] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:45.573] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:45.573] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[10:58:45.573] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[10:58:45.574] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:45.574] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.574] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:45.574] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.574] Exporting 7 global objects (3.97 KiB) to cluster node #2 ... DONE
[10:58:45.575] MultisessionFuture started
[10:58:45.575] - Launch lazy future ... done
[10:58:45.575] run() for ‘MultisessionFuture’ ... done
[10:58:45.575] Created future:
[10:58:45.575] MultisessionFuture:
[10:58:45.575] Label: ‘future_by-2’
[10:58:45.575] Expression:
[10:58:45.575] {
[10:58:45.575]     do.call(function(...) {
[10:58:45.575]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.575]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.575]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.575]             on.exit(options(oopts), add = TRUE)
[10:58:45.575]         }
[10:58:45.575]         {
[10:58:45.575]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.575]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.575]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.575]             })
[10:58:45.575]         }
[10:58:45.575]     }, args = future.call.arguments)
[10:58:45.575] }
[10:58:45.575] Lazy evaluation: FALSE
[10:58:45.575] Asynchronous evaluation: TRUE
[10:58:45.575] Local evaluation: TRUE
[10:58:45.575] Environment: 0x55974fafee18
[10:58:45.575] Capture standard output: TRUE
[10:58:45.575] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.575] Globals: 7 objects totaling 3.57 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, ...)
[10:58:45.575] Packages: 1 packages (‘stats’)
[10:58:45.575] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.575] Resolved: FALSE
[10:58:45.575] Value: <not collected>
[10:58:45.575] Conditions captured: <none>
[10:58:45.575] Early signaling: FALSE
[10:58:45.575] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.575] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.587] Chunk #2 of 2 ... DONE
[10:58:45.587] Launching 2 futures (chunks) ... DONE
[10:58:45.587] Resolving 2 futures (chunks) ...
[10:58:45.587] resolve() on list ...
[10:58:45.587]  recursive: 0
[10:58:45.587]  length: 2
[10:58:45.588] 
[10:58:45.588] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.588] - Validating connection of MultisessionFuture
[10:58:45.588] - received message: FutureResult
[10:58:45.588] - Received FutureResult
[10:58:45.588] - Erased future from FutureRegistry
[10:58:45.589] result() for ClusterFuture ...
[10:58:45.589] - result already collected: FutureResult
[10:58:45.589] result() for ClusterFuture ... done
[10:58:45.589] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.589] Future #1
[10:58:45.589] result() for ClusterFuture ...
[10:58:45.589] - result already collected: FutureResult
[10:58:45.589] result() for ClusterFuture ... done
[10:58:45.589] result() for ClusterFuture ...
[10:58:45.589] - result already collected: FutureResult
[10:58:45.589] result() for ClusterFuture ... done
[10:58:45.589] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:45.590] - nx: 2
[10:58:45.590] - relay: TRUE
[10:58:45.590] - stdout: TRUE
[10:58:45.590] - signal: TRUE
[10:58:45.590] - resignal: FALSE
[10:58:45.590] - force: TRUE
[10:58:45.590] - relayed: [n=2] FALSE, FALSE
[10:58:45.590] - queued futures: [n=2] FALSE, FALSE
[10:58:45.590]  - until=1
[10:58:45.590]  - relaying element #1
[10:58:45.590] result() for ClusterFuture ...
[10:58:45.590] - result already collected: FutureResult
[10:58:45.591] result() for ClusterFuture ... done
[10:58:45.591] result() for ClusterFuture ...
[10:58:45.591] - result already collected: FutureResult
[10:58:45.591] result() for ClusterFuture ... done
[10:58:45.591] result() for ClusterFuture ...
[10:58:45.591] - result already collected: FutureResult
[10:58:45.591] result() for ClusterFuture ... done
[10:58:45.591] result() for ClusterFuture ...
[10:58:45.591] - result already collected: FutureResult
[10:58:45.591] result() for ClusterFuture ... done
[10:58:45.591] - relayed: [n=2] TRUE, FALSE
[10:58:45.591] - queued futures: [n=2] TRUE, FALSE
[10:58:45.592] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:45.592]  length: 1 (resolved future 1)
[10:58:45.619] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.619] - Validating connection of MultisessionFuture
[10:58:45.619] - received message: FutureResult
[10:58:45.619] - Received FutureResult
[10:58:45.619] - Erased future from FutureRegistry
[10:58:45.619] result() for ClusterFuture ...
[10:58:45.620] - result already collected: FutureResult
[10:58:45.620] result() for ClusterFuture ... done
[10:58:45.620] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.620] Future #2
[10:58:45.620] result() for ClusterFuture ...
[10:58:45.620] - result already collected: FutureResult
[10:58:45.620] result() for ClusterFuture ... done
[10:58:45.620] result() for ClusterFuture ...
[10:58:45.620] - result already collected: FutureResult
[10:58:45.620] result() for ClusterFuture ... done
[10:58:45.620] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:45.620] - nx: 2
[10:58:45.621] - relay: TRUE
[10:58:45.621] - stdout: TRUE
[10:58:45.621] - signal: TRUE
[10:58:45.621] - resignal: FALSE
[10:58:45.621] - force: TRUE
[10:58:45.621] - relayed: [n=2] TRUE, FALSE
[10:58:45.621] - queued futures: [n=2] TRUE, FALSE
[10:58:45.621]  - until=2
[10:58:45.621]  - relaying element #2
[10:58:45.621] result() for ClusterFuture ...
[10:58:45.621] - result already collected: FutureResult
[10:58:45.621] result() for ClusterFuture ... done
[10:58:45.622] result() for ClusterFuture ...
[10:58:45.622] - result already collected: FutureResult
[10:58:45.622] result() for ClusterFuture ... done
[10:58:45.622] result() for ClusterFuture ...
[10:58:45.622] - result already collected: FutureResult
[10:58:45.622] result() for ClusterFuture ... done
[10:58:45.622] result() for ClusterFuture ...
[10:58:45.622] - result already collected: FutureResult
[10:58:45.622] result() for ClusterFuture ... done
[10:58:45.622] - relayed: [n=2] TRUE, TRUE
[10:58:45.622] - queued futures: [n=2] TRUE, TRUE
[10:58:45.622] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:45.623]  length: 0 (resolved future 2)
[10:58:45.623] Relaying remaining futures
[10:58:45.623] signalConditionsASAP(NULL, pos=0) ...
[10:58:45.623] - nx: 2
[10:58:45.623] - relay: TRUE
[10:58:45.623] - stdout: TRUE
[10:58:45.623] - signal: TRUE
[10:58:45.623] - resignal: FALSE
[10:58:45.623] - force: TRUE
[10:58:45.623] - relayed: [n=2] TRUE, TRUE
[10:58:45.623] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:45.623] - relayed: [n=2] TRUE, TRUE
[10:58:45.623] - queued futures: [n=2] TRUE, TRUE
[10:58:45.624] signalConditionsASAP(NULL, pos=0) ... done
[10:58:45.624] resolve() on list ... DONE
[10:58:45.624] result() for ClusterFuture ...
[10:58:45.624] - result already collected: FutureResult
[10:58:45.624] result() for ClusterFuture ... done
[10:58:45.624] result() for ClusterFuture ...
[10:58:45.624] - result already collected: FutureResult
[10:58:45.624] result() for ClusterFuture ... done
[10:58:45.624] result() for ClusterFuture ...
[10:58:45.624] - result already collected: FutureResult
[10:58:45.624] result() for ClusterFuture ... done
[10:58:45.624] result() for ClusterFuture ...
[10:58:45.625] - result already collected: FutureResult
[10:58:45.625] result() for ClusterFuture ... done
[10:58:45.625]  - Number of value chunks collected: 2
[10:58:45.625] Resolving 2 futures (chunks) ... DONE
[10:58:45.625] Reducing values from 2 chunks ...
[10:58:45.625]  - Number of values collected after concatenation: 3
[10:58:45.625]  - Number of values expected: 3
[10:58:45.625] Reducing values from 2 chunks ... DONE
[10:58:45.625] future_lapply() ... DONE
[10:58:45.625] future_by_internal() ... DONE
[10:58:45.626] future_by_internal() ...
[10:58:45.626] future_lapply() ...
[10:58:45.628] Number of chunks: 2
[10:58:45.628] getGlobalsAndPackagesXApply() ...
[10:58:45.628]  - future.globals: TRUE
[10:58:45.628] getGlobalsAndPackages() ...
[10:58:45.628] Searching for globals...
[10:58:45.631] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:45.631] Searching for globals ... DONE
[10:58:45.631] Resolving globals: FALSE
[10:58:45.632] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:45.632] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:45.632] - globals: [1] ‘FUN’
[10:58:45.632] 
[10:58:45.632] getGlobalsAndPackages() ... DONE
[10:58:45.632]  - globals found/used: [n=1] ‘FUN’
[10:58:45.632]  - needed namespaces: [n=0] 
[10:58:45.633] Finding globals ... DONE
[10:58:45.633]  - use_args: TRUE
[10:58:45.633]  - Getting '...' globals ...
[10:58:45.633] resolve() on list ...
[10:58:45.633]  recursive: 0
[10:58:45.633]  length: 1
[10:58:45.633]  elements: ‘...’
[10:58:45.633]  length: 0 (resolved future 1)
[10:58:45.634] resolve() on list ... DONE
[10:58:45.634]    - '...' content: [n=0] 
[10:58:45.634] List of 1
[10:58:45.634]  $ ...: list()
[10:58:45.634]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.634]  - attr(*, "where")=List of 1
[10:58:45.634]   ..$ ...:<environment: 0x55974cf83b78> 
[10:58:45.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.634]  - attr(*, "resolved")= logi TRUE
[10:58:45.634]  - attr(*, "total_size")= num NA
[10:58:45.636]  - Getting '...' globals ... DONE
[10:58:45.636] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:45.636] List of 2
[10:58:45.636]  $ ...future.FUN:function (object, ...)  
[10:58:45.636]  $ ...          : list()
[10:58:45.636]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.636]  - attr(*, "where")=List of 2
[10:58:45.636]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:45.636]   ..$ ...          :<environment: 0x55974cf83b78> 
[10:58:45.636]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.636]  - attr(*, "resolved")= logi FALSE
[10:58:45.636]  - attr(*, "total_size")= num 19278
[10:58:45.639] Packages to be attached in all futures: [n=0] 
[10:58:45.639] getGlobalsAndPackagesXApply() ... DONE
[10:58:45.639] Number of futures (= number of chunks): 2
[10:58:45.639] Launching 2 futures (chunks) ...
[10:58:45.639] Chunk #1 of 2 ...
[10:58:45.639]  - Finding globals in 'X' for chunk #1 ...
[10:58:45.639] getGlobalsAndPackages() ...
[10:58:45.639] Searching for globals...
[10:58:45.640] 
[10:58:45.640] Searching for globals ... DONE
[10:58:45.640] - globals: [0] <none>
[10:58:45.640] getGlobalsAndPackages() ... DONE
[10:58:45.640]    + additional globals found: [n=0] 
[10:58:45.640]    + additional namespaces needed: [n=0] 
[10:58:45.640]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:45.640]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.640]  - seeds: <none>
[10:58:45.641]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.641] getGlobalsAndPackages() ...
[10:58:45.641] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.641] Resolving globals: FALSE
[10:58:45.641] Tweak future expression to call with '...' arguments ...
[10:58:45.641] {
[10:58:45.641]     do.call(function(...) {
[10:58:45.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.641]             on.exit(options(oopts), add = TRUE)
[10:58:45.641]         }
[10:58:45.641]         {
[10:58:45.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.641]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.641]             })
[10:58:45.641]         }
[10:58:45.641]     }, args = future.call.arguments)
[10:58:45.641] }
[10:58:45.641] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.642] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.642] 
[10:58:45.642] getGlobalsAndPackages() ... DONE
[10:58:45.642] run() for ‘Future’ ...
[10:58:45.642] - state: ‘created’
[10:58:45.642] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.656] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.656] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.656]   - Field: ‘node’
[10:58:45.656]   - Field: ‘label’
[10:58:45.656]   - Field: ‘local’
[10:58:45.656]   - Field: ‘owner’
[10:58:45.657]   - Field: ‘envir’
[10:58:45.657]   - Field: ‘workers’
[10:58:45.657]   - Field: ‘packages’
[10:58:45.657]   - Field: ‘gc’
[10:58:45.657]   - Field: ‘conditions’
[10:58:45.657]   - Field: ‘persistent’
[10:58:45.657]   - Field: ‘expr’
[10:58:45.657]   - Field: ‘uuid’
[10:58:45.657]   - Field: ‘seed’
[10:58:45.657]   - Field: ‘version’
[10:58:45.657]   - Field: ‘result’
[10:58:45.657]   - Field: ‘asynchronous’
[10:58:45.658]   - Field: ‘calls’
[10:58:45.658]   - Field: ‘globals’
[10:58:45.658]   - Field: ‘stdout’
[10:58:45.658]   - Field: ‘earlySignal’
[10:58:45.658]   - Field: ‘lazy’
[10:58:45.658]   - Field: ‘state’
[10:58:45.658] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.658] - Launch lazy future ...
[10:58:45.658] Packages needed by the future expression (n = 0): <none>
[10:58:45.658] Packages needed by future strategies (n = 0): <none>
[10:58:45.659] {
[10:58:45.659]     {
[10:58:45.659]         {
[10:58:45.659]             ...future.startTime <- base::Sys.time()
[10:58:45.659]             {
[10:58:45.659]                 {
[10:58:45.659]                   {
[10:58:45.659]                     {
[10:58:45.659]                       base::local({
[10:58:45.659]                         has_future <- base::requireNamespace("future", 
[10:58:45.659]                           quietly = TRUE)
[10:58:45.659]                         if (has_future) {
[10:58:45.659]                           ns <- base::getNamespace("future")
[10:58:45.659]                           version <- ns[[".package"]][["version"]]
[10:58:45.659]                           if (is.null(version)) 
[10:58:45.659]                             version <- utils::packageVersion("future")
[10:58:45.659]                         }
[10:58:45.659]                         else {
[10:58:45.659]                           version <- NULL
[10:58:45.659]                         }
[10:58:45.659]                         if (!has_future || version < "1.8.0") {
[10:58:45.659]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.659]                             "", base::R.version$version.string), 
[10:58:45.659]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:45.659]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:45.659]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.659]                               "release", "version")], collapse = " "), 
[10:58:45.659]                             hostname = base::Sys.info()[["nodename"]])
[10:58:45.659]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.659]                             info)
[10:58:45.659]                           info <- base::paste(info, collapse = "; ")
[10:58:45.659]                           if (!has_future) {
[10:58:45.659]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.659]                               info)
[10:58:45.659]                           }
[10:58:45.659]                           else {
[10:58:45.659]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.659]                               info, version)
[10:58:45.659]                           }
[10:58:45.659]                           base::stop(msg)
[10:58:45.659]                         }
[10:58:45.659]                       })
[10:58:45.659]                     }
[10:58:45.659]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.659]                     base::options(mc.cores = 1L)
[10:58:45.659]                   }
[10:58:45.659]                   ...future.strategy.old <- future::plan("list")
[10:58:45.659]                   options(future.plan = NULL)
[10:58:45.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.659]                 }
[10:58:45.659]                 ...future.workdir <- getwd()
[10:58:45.659]             }
[10:58:45.659]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.659]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.659]         }
[10:58:45.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.659]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.659]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.659]             base::names(...future.oldOptions))
[10:58:45.659]     }
[10:58:45.659]     if (FALSE) {
[10:58:45.659]     }
[10:58:45.659]     else {
[10:58:45.659]         if (TRUE) {
[10:58:45.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.659]                 open = "w")
[10:58:45.659]         }
[10:58:45.659]         else {
[10:58:45.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.659]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.659]         }
[10:58:45.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.659]             base::sink(type = "output", split = FALSE)
[10:58:45.659]             base::close(...future.stdout)
[10:58:45.659]         }, add = TRUE)
[10:58:45.659]     }
[10:58:45.659]     ...future.frame <- base::sys.nframe()
[10:58:45.659]     ...future.conditions <- base::list()
[10:58:45.659]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.659]     if (FALSE) {
[10:58:45.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.659]     }
[10:58:45.659]     ...future.result <- base::tryCatch({
[10:58:45.659]         base::withCallingHandlers({
[10:58:45.659]             ...future.value <- base::withVisible(base::local({
[10:58:45.659]                 ...future.makeSendCondition <- base::local({
[10:58:45.659]                   sendCondition <- NULL
[10:58:45.659]                   function(frame = 1L) {
[10:58:45.659]                     if (is.function(sendCondition)) 
[10:58:45.659]                       return(sendCondition)
[10:58:45.659]                     ns <- getNamespace("parallel")
[10:58:45.659]                     if (exists("sendData", mode = "function", 
[10:58:45.659]                       envir = ns)) {
[10:58:45.659]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.659]                         envir = ns)
[10:58:45.659]                       envir <- sys.frame(frame)
[10:58:45.659]                       master <- NULL
[10:58:45.659]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.659]                         !identical(envir, emptyenv())) {
[10:58:45.659]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.659]                           inherits = FALSE)) {
[10:58:45.659]                           master <- get("master", mode = "list", 
[10:58:45.659]                             envir = envir, inherits = FALSE)
[10:58:45.659]                           if (inherits(master, c("SOCKnode", 
[10:58:45.659]                             "SOCK0node"))) {
[10:58:45.659]                             sendCondition <<- function(cond) {
[10:58:45.659]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.659]                                 success = TRUE)
[10:58:45.659]                               parallel_sendData(master, data)
[10:58:45.659]                             }
[10:58:45.659]                             return(sendCondition)
[10:58:45.659]                           }
[10:58:45.659]                         }
[10:58:45.659]                         frame <- frame + 1L
[10:58:45.659]                         envir <- sys.frame(frame)
[10:58:45.659]                       }
[10:58:45.659]                     }
[10:58:45.659]                     sendCondition <<- function(cond) NULL
[10:58:45.659]                   }
[10:58:45.659]                 })
[10:58:45.659]                 withCallingHandlers({
[10:58:45.659]                   {
[10:58:45.659]                     do.call(function(...) {
[10:58:45.659]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.659]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.659]                         ...future.globals.maxSize)) {
[10:58:45.659]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.659]                         on.exit(options(oopts), add = TRUE)
[10:58:45.659]                       }
[10:58:45.659]                       {
[10:58:45.659]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.659]                           FUN = function(jj) {
[10:58:45.659]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.659]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.659]                           })
[10:58:45.659]                       }
[10:58:45.659]                     }, args = future.call.arguments)
[10:58:45.659]                   }
[10:58:45.659]                 }, immediateCondition = function(cond) {
[10:58:45.659]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.659]                   sendCondition(cond)
[10:58:45.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.659]                   {
[10:58:45.659]                     inherits <- base::inherits
[10:58:45.659]                     invokeRestart <- base::invokeRestart
[10:58:45.659]                     is.null <- base::is.null
[10:58:45.659]                     muffled <- FALSE
[10:58:45.659]                     if (inherits(cond, "message")) {
[10:58:45.659]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.659]                       if (muffled) 
[10:58:45.659]                         invokeRestart("muffleMessage")
[10:58:45.659]                     }
[10:58:45.659]                     else if (inherits(cond, "warning")) {
[10:58:45.659]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.659]                       if (muffled) 
[10:58:45.659]                         invokeRestart("muffleWarning")
[10:58:45.659]                     }
[10:58:45.659]                     else if (inherits(cond, "condition")) {
[10:58:45.659]                       if (!is.null(pattern)) {
[10:58:45.659]                         computeRestarts <- base::computeRestarts
[10:58:45.659]                         grepl <- base::grepl
[10:58:45.659]                         restarts <- computeRestarts(cond)
[10:58:45.659]                         for (restart in restarts) {
[10:58:45.659]                           name <- restart$name
[10:58:45.659]                           if (is.null(name)) 
[10:58:45.659]                             next
[10:58:45.659]                           if (!grepl(pattern, name)) 
[10:58:45.659]                             next
[10:58:45.659]                           invokeRestart(restart)
[10:58:45.659]                           muffled <- TRUE
[10:58:45.659]                           break
[10:58:45.659]                         }
[10:58:45.659]                       }
[10:58:45.659]                     }
[10:58:45.659]                     invisible(muffled)
[10:58:45.659]                   }
[10:58:45.659]                   muffleCondition(cond)
[10:58:45.659]                 })
[10:58:45.659]             }))
[10:58:45.659]             future::FutureResult(value = ...future.value$value, 
[10:58:45.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.659]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.659]                     ...future.globalenv.names))
[10:58:45.659]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.659]         }, condition = base::local({
[10:58:45.659]             c <- base::c
[10:58:45.659]             inherits <- base::inherits
[10:58:45.659]             invokeRestart <- base::invokeRestart
[10:58:45.659]             length <- base::length
[10:58:45.659]             list <- base::list
[10:58:45.659]             seq.int <- base::seq.int
[10:58:45.659]             signalCondition <- base::signalCondition
[10:58:45.659]             sys.calls <- base::sys.calls
[10:58:45.659]             `[[` <- base::`[[`
[10:58:45.659]             `+` <- base::`+`
[10:58:45.659]             `<<-` <- base::`<<-`
[10:58:45.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.659]                   3L)]
[10:58:45.659]             }
[10:58:45.659]             function(cond) {
[10:58:45.659]                 is_error <- inherits(cond, "error")
[10:58:45.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.659]                   NULL)
[10:58:45.659]                 if (is_error) {
[10:58:45.659]                   sessionInformation <- function() {
[10:58:45.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.659]                       search = base::search(), system = base::Sys.info())
[10:58:45.659]                   }
[10:58:45.659]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.659]                     cond$call), session = sessionInformation(), 
[10:58:45.659]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.659]                   signalCondition(cond)
[10:58:45.659]                 }
[10:58:45.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.659]                 "immediateCondition"))) {
[10:58:45.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.659]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.659]                   if (TRUE && !signal) {
[10:58:45.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.659]                     {
[10:58:45.659]                       inherits <- base::inherits
[10:58:45.659]                       invokeRestart <- base::invokeRestart
[10:58:45.659]                       is.null <- base::is.null
[10:58:45.659]                       muffled <- FALSE
[10:58:45.659]                       if (inherits(cond, "message")) {
[10:58:45.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.659]                         if (muffled) 
[10:58:45.659]                           invokeRestart("muffleMessage")
[10:58:45.659]                       }
[10:58:45.659]                       else if (inherits(cond, "warning")) {
[10:58:45.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.659]                         if (muffled) 
[10:58:45.659]                           invokeRestart("muffleWarning")
[10:58:45.659]                       }
[10:58:45.659]                       else if (inherits(cond, "condition")) {
[10:58:45.659]                         if (!is.null(pattern)) {
[10:58:45.659]                           computeRestarts <- base::computeRestarts
[10:58:45.659]                           grepl <- base::grepl
[10:58:45.659]                           restarts <- computeRestarts(cond)
[10:58:45.659]                           for (restart in restarts) {
[10:58:45.659]                             name <- restart$name
[10:58:45.659]                             if (is.null(name)) 
[10:58:45.659]                               next
[10:58:45.659]                             if (!grepl(pattern, name)) 
[10:58:45.659]                               next
[10:58:45.659]                             invokeRestart(restart)
[10:58:45.659]                             muffled <- TRUE
[10:58:45.659]                             break
[10:58:45.659]                           }
[10:58:45.659]                         }
[10:58:45.659]                       }
[10:58:45.659]                       invisible(muffled)
[10:58:45.659]                     }
[10:58:45.659]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.659]                   }
[10:58:45.659]                 }
[10:58:45.659]                 else {
[10:58:45.659]                   if (TRUE) {
[10:58:45.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.659]                     {
[10:58:45.659]                       inherits <- base::inherits
[10:58:45.659]                       invokeRestart <- base::invokeRestart
[10:58:45.659]                       is.null <- base::is.null
[10:58:45.659]                       muffled <- FALSE
[10:58:45.659]                       if (inherits(cond, "message")) {
[10:58:45.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.659]                         if (muffled) 
[10:58:45.659]                           invokeRestart("muffleMessage")
[10:58:45.659]                       }
[10:58:45.659]                       else if (inherits(cond, "warning")) {
[10:58:45.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.659]                         if (muffled) 
[10:58:45.659]                           invokeRestart("muffleWarning")
[10:58:45.659]                       }
[10:58:45.659]                       else if (inherits(cond, "condition")) {
[10:58:45.659]                         if (!is.null(pattern)) {
[10:58:45.659]                           computeRestarts <- base::computeRestarts
[10:58:45.659]                           grepl <- base::grepl
[10:58:45.659]                           restarts <- computeRestarts(cond)
[10:58:45.659]                           for (restart in restarts) {
[10:58:45.659]                             name <- restart$name
[10:58:45.659]                             if (is.null(name)) 
[10:58:45.659]                               next
[10:58:45.659]                             if (!grepl(pattern, name)) 
[10:58:45.659]                               next
[10:58:45.659]                             invokeRestart(restart)
[10:58:45.659]                             muffled <- TRUE
[10:58:45.659]                             break
[10:58:45.659]                           }
[10:58:45.659]                         }
[10:58:45.659]                       }
[10:58:45.659]                       invisible(muffled)
[10:58:45.659]                     }
[10:58:45.659]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.659]                   }
[10:58:45.659]                 }
[10:58:45.659]             }
[10:58:45.659]         }))
[10:58:45.659]     }, error = function(ex) {
[10:58:45.659]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.659]                 ...future.rng), started = ...future.startTime, 
[10:58:45.659]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.659]             version = "1.8"), class = "FutureResult")
[10:58:45.659]     }, finally = {
[10:58:45.659]         if (!identical(...future.workdir, getwd())) 
[10:58:45.659]             setwd(...future.workdir)
[10:58:45.659]         {
[10:58:45.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.659]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.659]             }
[10:58:45.659]             base::options(...future.oldOptions)
[10:58:45.659]             if (.Platform$OS.type == "windows") {
[10:58:45.659]                 old_names <- names(...future.oldEnvVars)
[10:58:45.659]                 envs <- base::Sys.getenv()
[10:58:45.659]                 names <- names(envs)
[10:58:45.659]                 common <- intersect(names, old_names)
[10:58:45.659]                 added <- setdiff(names, old_names)
[10:58:45.659]                 removed <- setdiff(old_names, names)
[10:58:45.659]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.659]                   envs[common]]
[10:58:45.659]                 NAMES <- toupper(changed)
[10:58:45.659]                 args <- list()
[10:58:45.659]                 for (kk in seq_along(NAMES)) {
[10:58:45.659]                   name <- changed[[kk]]
[10:58:45.659]                   NAME <- NAMES[[kk]]
[10:58:45.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.659]                     next
[10:58:45.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.659]                 }
[10:58:45.659]                 NAMES <- toupper(added)
[10:58:45.659]                 for (kk in seq_along(NAMES)) {
[10:58:45.659]                   name <- added[[kk]]
[10:58:45.659]                   NAME <- NAMES[[kk]]
[10:58:45.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.659]                     next
[10:58:45.659]                   args[[name]] <- ""
[10:58:45.659]                 }
[10:58:45.659]                 NAMES <- toupper(removed)
[10:58:45.659]                 for (kk in seq_along(NAMES)) {
[10:58:45.659]                   name <- removed[[kk]]
[10:58:45.659]                   NAME <- NAMES[[kk]]
[10:58:45.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.659]                     next
[10:58:45.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.659]                 }
[10:58:45.659]                 if (length(args) > 0) 
[10:58:45.659]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.659]             }
[10:58:45.659]             else {
[10:58:45.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.659]             }
[10:58:45.659]             {
[10:58:45.659]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.659]                   0L) {
[10:58:45.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.659]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.659]                   base::options(opts)
[10:58:45.659]                 }
[10:58:45.659]                 {
[10:58:45.659]                   {
[10:58:45.659]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.659]                     NULL
[10:58:45.659]                   }
[10:58:45.659]                   options(future.plan = NULL)
[10:58:45.659]                   if (is.na(NA_character_)) 
[10:58:45.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.659]                     .init = FALSE)
[10:58:45.659]                 }
[10:58:45.659]             }
[10:58:45.659]         }
[10:58:45.659]     })
[10:58:45.659]     if (TRUE) {
[10:58:45.659]         base::sink(type = "output", split = FALSE)
[10:58:45.659]         if (TRUE) {
[10:58:45.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.659]         }
[10:58:45.659]         else {
[10:58:45.659]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.659]         }
[10:58:45.659]         base::close(...future.stdout)
[10:58:45.659]         ...future.stdout <- NULL
[10:58:45.659]     }
[10:58:45.659]     ...future.result$conditions <- ...future.conditions
[10:58:45.659]     ...future.result$finished <- base::Sys.time()
[10:58:45.659]     ...future.result
[10:58:45.659] }
[10:58:45.662] Exporting 5 global objects (1.57 KiB) to cluster node #1 ...
[10:58:45.662] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[10:58:45.662] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[10:58:45.662] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:45.663] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:45.663] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[10:58:45.663] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[10:58:45.663] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:45.664] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.664] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:45.664] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.664] Exporting 5 global objects (1.57 KiB) to cluster node #1 ... DONE
[10:58:45.665] MultisessionFuture started
[10:58:45.665] - Launch lazy future ... done
[10:58:45.665] run() for ‘MultisessionFuture’ ... done
[10:58:45.665] Created future:
[10:58:45.665] MultisessionFuture:
[10:58:45.665] Label: ‘future_by-1’
[10:58:45.665] Expression:
[10:58:45.665] {
[10:58:45.665]     do.call(function(...) {
[10:58:45.665]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.665]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.665]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.665]             on.exit(options(oopts), add = TRUE)
[10:58:45.665]         }
[10:58:45.665]         {
[10:58:45.665]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.665]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.665]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.665]             })
[10:58:45.665]         }
[10:58:45.665]     }, args = future.call.arguments)
[10:58:45.665] }
[10:58:45.665] Lazy evaluation: FALSE
[10:58:45.665] Asynchronous evaluation: TRUE
[10:58:45.665] Local evaluation: TRUE
[10:58:45.665] Environment: 0x55974cfd5ba8
[10:58:45.665] Capture standard output: TRUE
[10:58:45.665] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.665] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.665] Packages: <none>
[10:58:45.665] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.665] Resolved: FALSE
[10:58:45.665] Value: <not collected>
[10:58:45.665] Conditions captured: <none>
[10:58:45.665] Early signaling: FALSE
[10:58:45.665] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.665] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.677] Chunk #1 of 2 ... DONE
[10:58:45.677] Chunk #2 of 2 ...
[10:58:45.677]  - Finding globals in 'X' for chunk #2 ...
[10:58:45.677] getGlobalsAndPackages() ...
[10:58:45.677] Searching for globals...
[10:58:45.678] 
[10:58:45.678] Searching for globals ... DONE
[10:58:45.678] - globals: [0] <none>
[10:58:45.678] getGlobalsAndPackages() ... DONE
[10:58:45.678]    + additional globals found: [n=0] 
[10:58:45.678]    + additional namespaces needed: [n=0] 
[10:58:45.678]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:45.678]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.678]  - seeds: <none>
[10:58:45.678]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.678] getGlobalsAndPackages() ...
[10:58:45.679] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.679] Resolving globals: FALSE
[10:58:45.679] Tweak future expression to call with '...' arguments ...
[10:58:45.679] {
[10:58:45.679]     do.call(function(...) {
[10:58:45.679]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.679]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.679]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.679]             on.exit(options(oopts), add = TRUE)
[10:58:45.679]         }
[10:58:45.679]         {
[10:58:45.679]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.679]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.679]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.679]             })
[10:58:45.679]         }
[10:58:45.679]     }, args = future.call.arguments)
[10:58:45.679] }
[10:58:45.679] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.679] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.680] 
[10:58:45.680] getGlobalsAndPackages() ... DONE
[10:58:45.680] run() for ‘Future’ ...
[10:58:45.680] - state: ‘created’
[10:58:45.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.694] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.694]   - Field: ‘node’
[10:58:45.694]   - Field: ‘label’
[10:58:45.694]   - Field: ‘local’
[10:58:45.694]   - Field: ‘owner’
[10:58:45.694]   - Field: ‘envir’
[10:58:45.694]   - Field: ‘workers’
[10:58:45.694]   - Field: ‘packages’
[10:58:45.695]   - Field: ‘gc’
[10:58:45.695]   - Field: ‘conditions’
[10:58:45.695]   - Field: ‘persistent’
[10:58:45.695]   - Field: ‘expr’
[10:58:45.695]   - Field: ‘uuid’
[10:58:45.695]   - Field: ‘seed’
[10:58:45.695]   - Field: ‘version’
[10:58:45.695]   - Field: ‘result’
[10:58:45.695]   - Field: ‘asynchronous’
[10:58:45.695]   - Field: ‘calls’
[10:58:45.695]   - Field: ‘globals’
[10:58:45.695]   - Field: ‘stdout’
[10:58:45.695]   - Field: ‘earlySignal’
[10:58:45.696]   - Field: ‘lazy’
[10:58:45.696]   - Field: ‘state’
[10:58:45.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.696] - Launch lazy future ...
[10:58:45.696] Packages needed by the future expression (n = 0): <none>
[10:58:45.696] Packages needed by future strategies (n = 0): <none>
[10:58:45.697] {
[10:58:45.697]     {
[10:58:45.697]         {
[10:58:45.697]             ...future.startTime <- base::Sys.time()
[10:58:45.697]             {
[10:58:45.697]                 {
[10:58:45.697]                   {
[10:58:45.697]                     {
[10:58:45.697]                       base::local({
[10:58:45.697]                         has_future <- base::requireNamespace("future", 
[10:58:45.697]                           quietly = TRUE)
[10:58:45.697]                         if (has_future) {
[10:58:45.697]                           ns <- base::getNamespace("future")
[10:58:45.697]                           version <- ns[[".package"]][["version"]]
[10:58:45.697]                           if (is.null(version)) 
[10:58:45.697]                             version <- utils::packageVersion("future")
[10:58:45.697]                         }
[10:58:45.697]                         else {
[10:58:45.697]                           version <- NULL
[10:58:45.697]                         }
[10:58:45.697]                         if (!has_future || version < "1.8.0") {
[10:58:45.697]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.697]                             "", base::R.version$version.string), 
[10:58:45.697]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:45.697]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:45.697]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.697]                               "release", "version")], collapse = " "), 
[10:58:45.697]                             hostname = base::Sys.info()[["nodename"]])
[10:58:45.697]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.697]                             info)
[10:58:45.697]                           info <- base::paste(info, collapse = "; ")
[10:58:45.697]                           if (!has_future) {
[10:58:45.697]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.697]                               info)
[10:58:45.697]                           }
[10:58:45.697]                           else {
[10:58:45.697]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.697]                               info, version)
[10:58:45.697]                           }
[10:58:45.697]                           base::stop(msg)
[10:58:45.697]                         }
[10:58:45.697]                       })
[10:58:45.697]                     }
[10:58:45.697]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.697]                     base::options(mc.cores = 1L)
[10:58:45.697]                   }
[10:58:45.697]                   ...future.strategy.old <- future::plan("list")
[10:58:45.697]                   options(future.plan = NULL)
[10:58:45.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.697]                 }
[10:58:45.697]                 ...future.workdir <- getwd()
[10:58:45.697]             }
[10:58:45.697]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.697]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.697]         }
[10:58:45.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.697]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.697]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.697]             base::names(...future.oldOptions))
[10:58:45.697]     }
[10:58:45.697]     if (FALSE) {
[10:58:45.697]     }
[10:58:45.697]     else {
[10:58:45.697]         if (TRUE) {
[10:58:45.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.697]                 open = "w")
[10:58:45.697]         }
[10:58:45.697]         else {
[10:58:45.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.697]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.697]         }
[10:58:45.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.697]             base::sink(type = "output", split = FALSE)
[10:58:45.697]             base::close(...future.stdout)
[10:58:45.697]         }, add = TRUE)
[10:58:45.697]     }
[10:58:45.697]     ...future.frame <- base::sys.nframe()
[10:58:45.697]     ...future.conditions <- base::list()
[10:58:45.697]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.697]     if (FALSE) {
[10:58:45.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.697]     }
[10:58:45.697]     ...future.result <- base::tryCatch({
[10:58:45.697]         base::withCallingHandlers({
[10:58:45.697]             ...future.value <- base::withVisible(base::local({
[10:58:45.697]                 ...future.makeSendCondition <- base::local({
[10:58:45.697]                   sendCondition <- NULL
[10:58:45.697]                   function(frame = 1L) {
[10:58:45.697]                     if (is.function(sendCondition)) 
[10:58:45.697]                       return(sendCondition)
[10:58:45.697]                     ns <- getNamespace("parallel")
[10:58:45.697]                     if (exists("sendData", mode = "function", 
[10:58:45.697]                       envir = ns)) {
[10:58:45.697]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.697]                         envir = ns)
[10:58:45.697]                       envir <- sys.frame(frame)
[10:58:45.697]                       master <- NULL
[10:58:45.697]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.697]                         !identical(envir, emptyenv())) {
[10:58:45.697]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.697]                           inherits = FALSE)) {
[10:58:45.697]                           master <- get("master", mode = "list", 
[10:58:45.697]                             envir = envir, inherits = FALSE)
[10:58:45.697]                           if (inherits(master, c("SOCKnode", 
[10:58:45.697]                             "SOCK0node"))) {
[10:58:45.697]                             sendCondition <<- function(cond) {
[10:58:45.697]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.697]                                 success = TRUE)
[10:58:45.697]                               parallel_sendData(master, data)
[10:58:45.697]                             }
[10:58:45.697]                             return(sendCondition)
[10:58:45.697]                           }
[10:58:45.697]                         }
[10:58:45.697]                         frame <- frame + 1L
[10:58:45.697]                         envir <- sys.frame(frame)
[10:58:45.697]                       }
[10:58:45.697]                     }
[10:58:45.697]                     sendCondition <<- function(cond) NULL
[10:58:45.697]                   }
[10:58:45.697]                 })
[10:58:45.697]                 withCallingHandlers({
[10:58:45.697]                   {
[10:58:45.697]                     do.call(function(...) {
[10:58:45.697]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.697]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.697]                         ...future.globals.maxSize)) {
[10:58:45.697]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.697]                         on.exit(options(oopts), add = TRUE)
[10:58:45.697]                       }
[10:58:45.697]                       {
[10:58:45.697]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.697]                           FUN = function(jj) {
[10:58:45.697]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.697]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.697]                           })
[10:58:45.697]                       }
[10:58:45.697]                     }, args = future.call.arguments)
[10:58:45.697]                   }
[10:58:45.697]                 }, immediateCondition = function(cond) {
[10:58:45.697]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.697]                   sendCondition(cond)
[10:58:45.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.697]                   {
[10:58:45.697]                     inherits <- base::inherits
[10:58:45.697]                     invokeRestart <- base::invokeRestart
[10:58:45.697]                     is.null <- base::is.null
[10:58:45.697]                     muffled <- FALSE
[10:58:45.697]                     if (inherits(cond, "message")) {
[10:58:45.697]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.697]                       if (muffled) 
[10:58:45.697]                         invokeRestart("muffleMessage")
[10:58:45.697]                     }
[10:58:45.697]                     else if (inherits(cond, "warning")) {
[10:58:45.697]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.697]                       if (muffled) 
[10:58:45.697]                         invokeRestart("muffleWarning")
[10:58:45.697]                     }
[10:58:45.697]                     else if (inherits(cond, "condition")) {
[10:58:45.697]                       if (!is.null(pattern)) {
[10:58:45.697]                         computeRestarts <- base::computeRestarts
[10:58:45.697]                         grepl <- base::grepl
[10:58:45.697]                         restarts <- computeRestarts(cond)
[10:58:45.697]                         for (restart in restarts) {
[10:58:45.697]                           name <- restart$name
[10:58:45.697]                           if (is.null(name)) 
[10:58:45.697]                             next
[10:58:45.697]                           if (!grepl(pattern, name)) 
[10:58:45.697]                             next
[10:58:45.697]                           invokeRestart(restart)
[10:58:45.697]                           muffled <- TRUE
[10:58:45.697]                           break
[10:58:45.697]                         }
[10:58:45.697]                       }
[10:58:45.697]                     }
[10:58:45.697]                     invisible(muffled)
[10:58:45.697]                   }
[10:58:45.697]                   muffleCondition(cond)
[10:58:45.697]                 })
[10:58:45.697]             }))
[10:58:45.697]             future::FutureResult(value = ...future.value$value, 
[10:58:45.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.697]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.697]                     ...future.globalenv.names))
[10:58:45.697]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.697]         }, condition = base::local({
[10:58:45.697]             c <- base::c
[10:58:45.697]             inherits <- base::inherits
[10:58:45.697]             invokeRestart <- base::invokeRestart
[10:58:45.697]             length <- base::length
[10:58:45.697]             list <- base::list
[10:58:45.697]             seq.int <- base::seq.int
[10:58:45.697]             signalCondition <- base::signalCondition
[10:58:45.697]             sys.calls <- base::sys.calls
[10:58:45.697]             `[[` <- base::`[[`
[10:58:45.697]             `+` <- base::`+`
[10:58:45.697]             `<<-` <- base::`<<-`
[10:58:45.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.697]                   3L)]
[10:58:45.697]             }
[10:58:45.697]             function(cond) {
[10:58:45.697]                 is_error <- inherits(cond, "error")
[10:58:45.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.697]                   NULL)
[10:58:45.697]                 if (is_error) {
[10:58:45.697]                   sessionInformation <- function() {
[10:58:45.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.697]                       search = base::search(), system = base::Sys.info())
[10:58:45.697]                   }
[10:58:45.697]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.697]                     cond$call), session = sessionInformation(), 
[10:58:45.697]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.697]                   signalCondition(cond)
[10:58:45.697]                 }
[10:58:45.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.697]                 "immediateCondition"))) {
[10:58:45.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.697]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.697]                   if (TRUE && !signal) {
[10:58:45.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.697]                     {
[10:58:45.697]                       inherits <- base::inherits
[10:58:45.697]                       invokeRestart <- base::invokeRestart
[10:58:45.697]                       is.null <- base::is.null
[10:58:45.697]                       muffled <- FALSE
[10:58:45.697]                       if (inherits(cond, "message")) {
[10:58:45.697]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.697]                         if (muffled) 
[10:58:45.697]                           invokeRestart("muffleMessage")
[10:58:45.697]                       }
[10:58:45.697]                       else if (inherits(cond, "warning")) {
[10:58:45.697]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.697]                         if (muffled) 
[10:58:45.697]                           invokeRestart("muffleWarning")
[10:58:45.697]                       }
[10:58:45.697]                       else if (inherits(cond, "condition")) {
[10:58:45.697]                         if (!is.null(pattern)) {
[10:58:45.697]                           computeRestarts <- base::computeRestarts
[10:58:45.697]                           grepl <- base::grepl
[10:58:45.697]                           restarts <- computeRestarts(cond)
[10:58:45.697]                           for (restart in restarts) {
[10:58:45.697]                             name <- restart$name
[10:58:45.697]                             if (is.null(name)) 
[10:58:45.697]                               next
[10:58:45.697]                             if (!grepl(pattern, name)) 
[10:58:45.697]                               next
[10:58:45.697]                             invokeRestart(restart)
[10:58:45.697]                             muffled <- TRUE
[10:58:45.697]                             break
[10:58:45.697]                           }
[10:58:45.697]                         }
[10:58:45.697]                       }
[10:58:45.697]                       invisible(muffled)
[10:58:45.697]                     }
[10:58:45.697]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.697]                   }
[10:58:45.697]                 }
[10:58:45.697]                 else {
[10:58:45.697]                   if (TRUE) {
[10:58:45.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.697]                     {
[10:58:45.697]                       inherits <- base::inherits
[10:58:45.697]                       invokeRestart <- base::invokeRestart
[10:58:45.697]                       is.null <- base::is.null
[10:58:45.697]                       muffled <- FALSE
[10:58:45.697]                       if (inherits(cond, "message")) {
[10:58:45.697]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.697]                         if (muffled) 
[10:58:45.697]                           invokeRestart("muffleMessage")
[10:58:45.697]                       }
[10:58:45.697]                       else if (inherits(cond, "warning")) {
[10:58:45.697]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.697]                         if (muffled) 
[10:58:45.697]                           invokeRestart("muffleWarning")
[10:58:45.697]                       }
[10:58:45.697]                       else if (inherits(cond, "condition")) {
[10:58:45.697]                         if (!is.null(pattern)) {
[10:58:45.697]                           computeRestarts <- base::computeRestarts
[10:58:45.697]                           grepl <- base::grepl
[10:58:45.697]                           restarts <- computeRestarts(cond)
[10:58:45.697]                           for (restart in restarts) {
[10:58:45.697]                             name <- restart$name
[10:58:45.697]                             if (is.null(name)) 
[10:58:45.697]                               next
[10:58:45.697]                             if (!grepl(pattern, name)) 
[10:58:45.697]                               next
[10:58:45.697]                             invokeRestart(restart)
[10:58:45.697]                             muffled <- TRUE
[10:58:45.697]                             break
[10:58:45.697]                           }
[10:58:45.697]                         }
[10:58:45.697]                       }
[10:58:45.697]                       invisible(muffled)
[10:58:45.697]                     }
[10:58:45.697]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.697]                   }
[10:58:45.697]                 }
[10:58:45.697]             }
[10:58:45.697]         }))
[10:58:45.697]     }, error = function(ex) {
[10:58:45.697]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.697]                 ...future.rng), started = ...future.startTime, 
[10:58:45.697]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.697]             version = "1.8"), class = "FutureResult")
[10:58:45.697]     }, finally = {
[10:58:45.697]         if (!identical(...future.workdir, getwd())) 
[10:58:45.697]             setwd(...future.workdir)
[10:58:45.697]         {
[10:58:45.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.697]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.697]             }
[10:58:45.697]             base::options(...future.oldOptions)
[10:58:45.697]             if (.Platform$OS.type == "windows") {
[10:58:45.697]                 old_names <- names(...future.oldEnvVars)
[10:58:45.697]                 envs <- base::Sys.getenv()
[10:58:45.697]                 names <- names(envs)
[10:58:45.697]                 common <- intersect(names, old_names)
[10:58:45.697]                 added <- setdiff(names, old_names)
[10:58:45.697]                 removed <- setdiff(old_names, names)
[10:58:45.697]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.697]                   envs[common]]
[10:58:45.697]                 NAMES <- toupper(changed)
[10:58:45.697]                 args <- list()
[10:58:45.697]                 for (kk in seq_along(NAMES)) {
[10:58:45.697]                   name <- changed[[kk]]
[10:58:45.697]                   NAME <- NAMES[[kk]]
[10:58:45.697]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.697]                     next
[10:58:45.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.697]                 }
[10:58:45.697]                 NAMES <- toupper(added)
[10:58:45.697]                 for (kk in seq_along(NAMES)) {
[10:58:45.697]                   name <- added[[kk]]
[10:58:45.697]                   NAME <- NAMES[[kk]]
[10:58:45.697]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.697]                     next
[10:58:45.697]                   args[[name]] <- ""
[10:58:45.697]                 }
[10:58:45.697]                 NAMES <- toupper(removed)
[10:58:45.697]                 for (kk in seq_along(NAMES)) {
[10:58:45.697]                   name <- removed[[kk]]
[10:58:45.697]                   NAME <- NAMES[[kk]]
[10:58:45.697]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.697]                     next
[10:58:45.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.697]                 }
[10:58:45.697]                 if (length(args) > 0) 
[10:58:45.697]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.697]             }
[10:58:45.697]             else {
[10:58:45.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.697]             }
[10:58:45.697]             {
[10:58:45.697]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.697]                   0L) {
[10:58:45.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.697]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.697]                   base::options(opts)
[10:58:45.697]                 }
[10:58:45.697]                 {
[10:58:45.697]                   {
[10:58:45.697]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.697]                     NULL
[10:58:45.697]                   }
[10:58:45.697]                   options(future.plan = NULL)
[10:58:45.697]                   if (is.na(NA_character_)) 
[10:58:45.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.697]                     .init = FALSE)
[10:58:45.697]                 }
[10:58:45.697]             }
[10:58:45.697]         }
[10:58:45.697]     })
[10:58:45.697]     if (TRUE) {
[10:58:45.697]         base::sink(type = "output", split = FALSE)
[10:58:45.697]         if (TRUE) {
[10:58:45.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.697]         }
[10:58:45.697]         else {
[10:58:45.697]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.697]         }
[10:58:45.697]         base::close(...future.stdout)
[10:58:45.697]         ...future.stdout <- NULL
[10:58:45.697]     }
[10:58:45.697]     ...future.result$conditions <- ...future.conditions
[10:58:45.697]     ...future.result$finished <- base::Sys.time()
[10:58:45.697]     ...future.result
[10:58:45.697] }
[10:58:45.699] Exporting 5 global objects (2.20 KiB) to cluster node #2 ...
[10:58:45.700] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[10:58:45.700] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[10:58:45.700] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:45.700] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:45.701] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[10:58:45.701] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[10:58:45.701] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:45.701] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.702] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:45.702] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.702] Exporting 5 global objects (2.20 KiB) to cluster node #2 ... DONE
[10:58:45.702] MultisessionFuture started
[10:58:45.703] - Launch lazy future ... done
[10:58:45.703] run() for ‘MultisessionFuture’ ... done
[10:58:45.703] Created future:
[10:58:45.703] MultisessionFuture:
[10:58:45.703] Label: ‘future_by-2’
[10:58:45.703] Expression:
[10:58:45.703] {
[10:58:45.703]     do.call(function(...) {
[10:58:45.703]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.703]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.703]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.703]             on.exit(options(oopts), add = TRUE)
[10:58:45.703]         }
[10:58:45.703]         {
[10:58:45.703]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.703]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.703]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.703]             })
[10:58:45.703]         }
[10:58:45.703]     }, args = future.call.arguments)
[10:58:45.703] }
[10:58:45.703] Lazy evaluation: FALSE
[10:58:45.703] Asynchronous evaluation: TRUE
[10:58:45.703] Local evaluation: TRUE
[10:58:45.703] Environment: 0x55974cfd5ba8
[10:58:45.703] Capture standard output: TRUE
[10:58:45.703] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.703] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.703] Packages: <none>
[10:58:45.703] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.703] Resolved: FALSE
[10:58:45.703] Value: <not collected>
[10:58:45.703] Conditions captured: <none>
[10:58:45.703] Early signaling: FALSE
[10:58:45.703] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.703] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.714] Chunk #2 of 2 ... DONE
[10:58:45.714] Launching 2 futures (chunks) ... DONE
[10:58:45.715] Resolving 2 futures (chunks) ...
[10:58:45.715] resolve() on list ...
[10:58:45.715]  recursive: 0
[10:58:45.715]  length: 2
[10:58:45.715] 
[10:58:45.715] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.716] - Validating connection of MultisessionFuture
[10:58:45.716] - received message: FutureResult
[10:58:45.716] - Received FutureResult
[10:58:45.716] - Erased future from FutureRegistry
[10:58:45.716] result() for ClusterFuture ...
[10:58:45.716] - result already collected: FutureResult
[10:58:45.716] result() for ClusterFuture ... done
[10:58:45.716] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.716] Future #1
[10:58:45.716] result() for ClusterFuture ...
[10:58:45.717] - result already collected: FutureResult
[10:58:45.717] result() for ClusterFuture ... done
[10:58:45.717] result() for ClusterFuture ...
[10:58:45.717] - result already collected: FutureResult
[10:58:45.717] result() for ClusterFuture ... done
[10:58:45.717] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:45.717] - nx: 2
[10:58:45.717] - relay: TRUE
[10:58:45.717] - stdout: TRUE
[10:58:45.717] - signal: TRUE
[10:58:45.717] - resignal: FALSE
[10:58:45.717] - force: TRUE
[10:58:45.717] - relayed: [n=2] FALSE, FALSE
[10:58:45.718] - queued futures: [n=2] FALSE, FALSE
[10:58:45.718]  - until=1
[10:58:45.718]  - relaying element #1
[10:58:45.718] result() for ClusterFuture ...
[10:58:45.718] - result already collected: FutureResult
[10:58:45.718] result() for ClusterFuture ... done
[10:58:45.718] result() for ClusterFuture ...
[10:58:45.718] - result already collected: FutureResult
[10:58:45.718] result() for ClusterFuture ... done
[10:58:45.718] result() for ClusterFuture ...
[10:58:45.718] - result already collected: FutureResult
[10:58:45.718] result() for ClusterFuture ... done
[10:58:45.719] result() for ClusterFuture ...
[10:58:45.719] - result already collected: FutureResult
[10:58:45.719] result() for ClusterFuture ... done
[10:58:45.719] - relayed: [n=2] TRUE, FALSE
[10:58:45.719] - queued futures: [n=2] TRUE, FALSE
[10:58:45.719] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:45.719]  length: 1 (resolved future 1)
[10:58:45.745] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.745] - Validating connection of MultisessionFuture
[10:58:45.746] - received message: FutureResult
[10:58:45.746] - Received FutureResult
[10:58:45.746] - Erased future from FutureRegistry
[10:58:45.746] result() for ClusterFuture ...
[10:58:45.746] - result already collected: FutureResult
[10:58:45.746] result() for ClusterFuture ... done
[10:58:45.746] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.746] Future #2
[10:58:45.746] result() for ClusterFuture ...
[10:58:45.746] - result already collected: FutureResult
[10:58:45.747] result() for ClusterFuture ... done
[10:58:45.747] result() for ClusterFuture ...
[10:58:45.747] - result already collected: FutureResult
[10:58:45.747] result() for ClusterFuture ... done
[10:58:45.747] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:45.747] - nx: 2
[10:58:45.747] - relay: TRUE
[10:58:45.747] - stdout: TRUE
[10:58:45.747] - signal: TRUE
[10:58:45.747] - resignal: FALSE
[10:58:45.747] - force: TRUE
[10:58:45.747] - relayed: [n=2] TRUE, FALSE
[10:58:45.748] - queued futures: [n=2] TRUE, FALSE
[10:58:45.748]  - until=2
[10:58:45.748]  - relaying element #2
[10:58:45.748] result() for ClusterFuture ...
[10:58:45.748] - result already collected: FutureResult
[10:58:45.748] result() for ClusterFuture ... done
[10:58:45.748] result() for ClusterFuture ...
[10:58:45.748] - result already collected: FutureResult
[10:58:45.748] result() for ClusterFuture ... done
[10:58:45.748] result() for ClusterFuture ...
[10:58:45.748] - result already collected: FutureResult
[10:58:45.748] result() for ClusterFuture ... done
[10:58:45.749] result() for ClusterFuture ...
[10:58:45.749] - result already collected: FutureResult
[10:58:45.749] result() for ClusterFuture ... done
[10:58:45.749] - relayed: [n=2] TRUE, TRUE
[10:58:45.749] - queued futures: [n=2] TRUE, TRUE
[10:58:45.749] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:45.749]  length: 0 (resolved future 2)
[10:58:45.749] Relaying remaining futures
[10:58:45.749] signalConditionsASAP(NULL, pos=0) ...
[10:58:45.749] - nx: 2
[10:58:45.749] - relay: TRUE
[10:58:45.749] - stdout: TRUE
[10:58:45.749] - signal: TRUE
[10:58:45.750] - resignal: FALSE
[10:58:45.750] - force: TRUE
[10:58:45.750] - relayed: [n=2] TRUE, TRUE
[10:58:45.750] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:45.750] - relayed: [n=2] TRUE, TRUE
[10:58:45.750] - queued futures: [n=2] TRUE, TRUE
[10:58:45.750] signalConditionsASAP(NULL, pos=0) ... done
[10:58:45.750] resolve() on list ... DONE
[10:58:45.750] result() for ClusterFuture ...
[10:58:45.750] - result already collected: FutureResult
[10:58:45.750] result() for ClusterFuture ... done
[10:58:45.750] result() for ClusterFuture ...
[10:58:45.751] - result already collected: FutureResult
[10:58:45.751] result() for ClusterFuture ... done
[10:58:45.751] result() for ClusterFuture ...
[10:58:45.751] - result already collected: FutureResult
[10:58:45.751] result() for ClusterFuture ... done
[10:58:45.751] result() for ClusterFuture ...
[10:58:45.751] - result already collected: FutureResult
[10:58:45.751] result() for ClusterFuture ... done
[10:58:45.751]  - Number of value chunks collected: 2
[10:58:45.751] Resolving 2 futures (chunks) ... DONE
[10:58:45.751] Reducing values from 2 chunks ...
[10:58:45.751]  - Number of values collected after concatenation: 3
[10:58:45.752]  - Number of values expected: 3
[10:58:45.752] Reducing values from 2 chunks ... DONE
[10:58:45.752] future_lapply() ... DONE
[10:58:45.752] future_by_internal() ... DONE
[10:58:45.753] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:58:45.753] future_lapply() ...
[10:58:45.755] Number of chunks: 2
[10:58:45.755] getGlobalsAndPackagesXApply() ...
[10:58:45.755]  - future.globals: TRUE
[10:58:45.755] getGlobalsAndPackages() ...
[10:58:45.756] Searching for globals...
[10:58:45.757] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:45.757] Searching for globals ... DONE
[10:58:45.757] Resolving globals: FALSE
[10:58:45.757] The total size of the 1 globals is 281 bytes (281 bytes)
[10:58:45.757] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:58:45.758] - globals: [1] ‘FUN’
[10:58:45.758] 
[10:58:45.758] getGlobalsAndPackages() ... DONE
[10:58:45.758]  - globals found/used: [n=1] ‘FUN’
[10:58:45.758]  - needed namespaces: [n=0] 
[10:58:45.758] Finding globals ... DONE
[10:58:45.758]  - use_args: TRUE
[10:58:45.758]  - Getting '...' globals ...
[10:58:45.758] resolve() on list ...
[10:58:45.759]  recursive: 0
[10:58:45.759]  length: 1
[10:58:45.759]  elements: ‘...’
[10:58:45.759]  length: 0 (resolved future 1)
[10:58:45.759] resolve() on list ... DONE
[10:58:45.759]    - '...' content: [n=0] 
[10:58:45.759] List of 1
[10:58:45.759]  $ ...: list()
[10:58:45.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.759]  - attr(*, "where")=List of 1
[10:58:45.759]   ..$ ...:<environment: 0x55974ed8b1b0> 
[10:58:45.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.759]  - attr(*, "resolved")= logi TRUE
[10:58:45.759]  - attr(*, "total_size")= num NA
[10:58:45.761]  - Getting '...' globals ... DONE
[10:58:45.762] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:45.762] List of 2
[10:58:45.762]  $ ...future.FUN:function (object, ...)  
[10:58:45.762]  $ ...          : list()
[10:58:45.762]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:45.762]  - attr(*, "where")=List of 2
[10:58:45.762]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:45.762]   ..$ ...          :<environment: 0x55974ed8b1b0> 
[10:58:45.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:45.762]  - attr(*, "resolved")= logi FALSE
[10:58:45.762]  - attr(*, "total_size")= num 18647
[10:58:45.764] Packages to be attached in all futures: [n=0] 
[10:58:45.764] getGlobalsAndPackagesXApply() ... DONE
[10:58:45.764] Number of futures (= number of chunks): 2
[10:58:45.765] Launching 2 futures (chunks) ...
[10:58:45.765] Chunk #1 of 2 ...
[10:58:45.765]  - Finding globals in 'X' for chunk #1 ...
[10:58:45.765] getGlobalsAndPackages() ...
[10:58:45.765] Searching for globals...
[10:58:45.765] 
[10:58:45.765] Searching for globals ... DONE
[10:58:45.766] - globals: [0] <none>
[10:58:45.766] getGlobalsAndPackages() ... DONE
[10:58:45.766]    + additional globals found: [n=0] 
[10:58:45.766]    + additional namespaces needed: [n=0] 
[10:58:45.766]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:45.766]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.766]  - seeds: <none>
[10:58:45.766]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.766] getGlobalsAndPackages() ...
[10:58:45.766] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.766] Resolving globals: FALSE
[10:58:45.766] Tweak future expression to call with '...' arguments ...
[10:58:45.767] {
[10:58:45.767]     do.call(function(...) {
[10:58:45.767]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.767]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.767]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.767]             on.exit(options(oopts), add = TRUE)
[10:58:45.767]         }
[10:58:45.767]         {
[10:58:45.767]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.767]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.767]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.767]             })
[10:58:45.767]         }
[10:58:45.767]     }, args = future.call.arguments)
[10:58:45.767] }
[10:58:45.767] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.767] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.767] 
[10:58:45.767] getGlobalsAndPackages() ... DONE
[10:58:45.768] run() for ‘Future’ ...
[10:58:45.768] - state: ‘created’
[10:58:45.768] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.782] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.782]   - Field: ‘node’
[10:58:45.782]   - Field: ‘label’
[10:58:45.782]   - Field: ‘local’
[10:58:45.782]   - Field: ‘owner’
[10:58:45.782]   - Field: ‘envir’
[10:58:45.782]   - Field: ‘workers’
[10:58:45.783]   - Field: ‘packages’
[10:58:45.783]   - Field: ‘gc’
[10:58:45.783]   - Field: ‘conditions’
[10:58:45.783]   - Field: ‘persistent’
[10:58:45.783]   - Field: ‘expr’
[10:58:45.783]   - Field: ‘uuid’
[10:58:45.783]   - Field: ‘seed’
[10:58:45.783]   - Field: ‘version’
[10:58:45.783]   - Field: ‘result’
[10:58:45.783]   - Field: ‘asynchronous’
[10:58:45.783]   - Field: ‘calls’
[10:58:45.784]   - Field: ‘globals’
[10:58:45.784]   - Field: ‘stdout’
[10:58:45.784]   - Field: ‘earlySignal’
[10:58:45.784]   - Field: ‘lazy’
[10:58:45.784]   - Field: ‘state’
[10:58:45.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.784] - Launch lazy future ...
[10:58:45.784] Packages needed by the future expression (n = 0): <none>
[10:58:45.784] Packages needed by future strategies (n = 0): <none>
[10:58:45.785] {
[10:58:45.785]     {
[10:58:45.785]         {
[10:58:45.785]             ...future.startTime <- base::Sys.time()
[10:58:45.785]             {
[10:58:45.785]                 {
[10:58:45.785]                   {
[10:58:45.785]                     {
[10:58:45.785]                       base::local({
[10:58:45.785]                         has_future <- base::requireNamespace("future", 
[10:58:45.785]                           quietly = TRUE)
[10:58:45.785]                         if (has_future) {
[10:58:45.785]                           ns <- base::getNamespace("future")
[10:58:45.785]                           version <- ns[[".package"]][["version"]]
[10:58:45.785]                           if (is.null(version)) 
[10:58:45.785]                             version <- utils::packageVersion("future")
[10:58:45.785]                         }
[10:58:45.785]                         else {
[10:58:45.785]                           version <- NULL
[10:58:45.785]                         }
[10:58:45.785]                         if (!has_future || version < "1.8.0") {
[10:58:45.785]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.785]                             "", base::R.version$version.string), 
[10:58:45.785]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:45.785]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:45.785]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.785]                               "release", "version")], collapse = " "), 
[10:58:45.785]                             hostname = base::Sys.info()[["nodename"]])
[10:58:45.785]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.785]                             info)
[10:58:45.785]                           info <- base::paste(info, collapse = "; ")
[10:58:45.785]                           if (!has_future) {
[10:58:45.785]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.785]                               info)
[10:58:45.785]                           }
[10:58:45.785]                           else {
[10:58:45.785]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.785]                               info, version)
[10:58:45.785]                           }
[10:58:45.785]                           base::stop(msg)
[10:58:45.785]                         }
[10:58:45.785]                       })
[10:58:45.785]                     }
[10:58:45.785]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.785]                     base::options(mc.cores = 1L)
[10:58:45.785]                   }
[10:58:45.785]                   ...future.strategy.old <- future::plan("list")
[10:58:45.785]                   options(future.plan = NULL)
[10:58:45.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.785]                 }
[10:58:45.785]                 ...future.workdir <- getwd()
[10:58:45.785]             }
[10:58:45.785]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.785]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.785]         }
[10:58:45.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.785]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.785]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.785]             base::names(...future.oldOptions))
[10:58:45.785]     }
[10:58:45.785]     if (FALSE) {
[10:58:45.785]     }
[10:58:45.785]     else {
[10:58:45.785]         if (TRUE) {
[10:58:45.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.785]                 open = "w")
[10:58:45.785]         }
[10:58:45.785]         else {
[10:58:45.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.785]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.785]         }
[10:58:45.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.785]             base::sink(type = "output", split = FALSE)
[10:58:45.785]             base::close(...future.stdout)
[10:58:45.785]         }, add = TRUE)
[10:58:45.785]     }
[10:58:45.785]     ...future.frame <- base::sys.nframe()
[10:58:45.785]     ...future.conditions <- base::list()
[10:58:45.785]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.785]     if (FALSE) {
[10:58:45.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.785]     }
[10:58:45.785]     ...future.result <- base::tryCatch({
[10:58:45.785]         base::withCallingHandlers({
[10:58:45.785]             ...future.value <- base::withVisible(base::local({
[10:58:45.785]                 ...future.makeSendCondition <- base::local({
[10:58:45.785]                   sendCondition <- NULL
[10:58:45.785]                   function(frame = 1L) {
[10:58:45.785]                     if (is.function(sendCondition)) 
[10:58:45.785]                       return(sendCondition)
[10:58:45.785]                     ns <- getNamespace("parallel")
[10:58:45.785]                     if (exists("sendData", mode = "function", 
[10:58:45.785]                       envir = ns)) {
[10:58:45.785]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.785]                         envir = ns)
[10:58:45.785]                       envir <- sys.frame(frame)
[10:58:45.785]                       master <- NULL
[10:58:45.785]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.785]                         !identical(envir, emptyenv())) {
[10:58:45.785]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.785]                           inherits = FALSE)) {
[10:58:45.785]                           master <- get("master", mode = "list", 
[10:58:45.785]                             envir = envir, inherits = FALSE)
[10:58:45.785]                           if (inherits(master, c("SOCKnode", 
[10:58:45.785]                             "SOCK0node"))) {
[10:58:45.785]                             sendCondition <<- function(cond) {
[10:58:45.785]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.785]                                 success = TRUE)
[10:58:45.785]                               parallel_sendData(master, data)
[10:58:45.785]                             }
[10:58:45.785]                             return(sendCondition)
[10:58:45.785]                           }
[10:58:45.785]                         }
[10:58:45.785]                         frame <- frame + 1L
[10:58:45.785]                         envir <- sys.frame(frame)
[10:58:45.785]                       }
[10:58:45.785]                     }
[10:58:45.785]                     sendCondition <<- function(cond) NULL
[10:58:45.785]                   }
[10:58:45.785]                 })
[10:58:45.785]                 withCallingHandlers({
[10:58:45.785]                   {
[10:58:45.785]                     do.call(function(...) {
[10:58:45.785]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.785]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.785]                         ...future.globals.maxSize)) {
[10:58:45.785]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.785]                         on.exit(options(oopts), add = TRUE)
[10:58:45.785]                       }
[10:58:45.785]                       {
[10:58:45.785]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.785]                           FUN = function(jj) {
[10:58:45.785]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.785]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.785]                           })
[10:58:45.785]                       }
[10:58:45.785]                     }, args = future.call.arguments)
[10:58:45.785]                   }
[10:58:45.785]                 }, immediateCondition = function(cond) {
[10:58:45.785]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.785]                   sendCondition(cond)
[10:58:45.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.785]                   {
[10:58:45.785]                     inherits <- base::inherits
[10:58:45.785]                     invokeRestart <- base::invokeRestart
[10:58:45.785]                     is.null <- base::is.null
[10:58:45.785]                     muffled <- FALSE
[10:58:45.785]                     if (inherits(cond, "message")) {
[10:58:45.785]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.785]                       if (muffled) 
[10:58:45.785]                         invokeRestart("muffleMessage")
[10:58:45.785]                     }
[10:58:45.785]                     else if (inherits(cond, "warning")) {
[10:58:45.785]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.785]                       if (muffled) 
[10:58:45.785]                         invokeRestart("muffleWarning")
[10:58:45.785]                     }
[10:58:45.785]                     else if (inherits(cond, "condition")) {
[10:58:45.785]                       if (!is.null(pattern)) {
[10:58:45.785]                         computeRestarts <- base::computeRestarts
[10:58:45.785]                         grepl <- base::grepl
[10:58:45.785]                         restarts <- computeRestarts(cond)
[10:58:45.785]                         for (restart in restarts) {
[10:58:45.785]                           name <- restart$name
[10:58:45.785]                           if (is.null(name)) 
[10:58:45.785]                             next
[10:58:45.785]                           if (!grepl(pattern, name)) 
[10:58:45.785]                             next
[10:58:45.785]                           invokeRestart(restart)
[10:58:45.785]                           muffled <- TRUE
[10:58:45.785]                           break
[10:58:45.785]                         }
[10:58:45.785]                       }
[10:58:45.785]                     }
[10:58:45.785]                     invisible(muffled)
[10:58:45.785]                   }
[10:58:45.785]                   muffleCondition(cond)
[10:58:45.785]                 })
[10:58:45.785]             }))
[10:58:45.785]             future::FutureResult(value = ...future.value$value, 
[10:58:45.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.785]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.785]                     ...future.globalenv.names))
[10:58:45.785]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.785]         }, condition = base::local({
[10:58:45.785]             c <- base::c
[10:58:45.785]             inherits <- base::inherits
[10:58:45.785]             invokeRestart <- base::invokeRestart
[10:58:45.785]             length <- base::length
[10:58:45.785]             list <- base::list
[10:58:45.785]             seq.int <- base::seq.int
[10:58:45.785]             signalCondition <- base::signalCondition
[10:58:45.785]             sys.calls <- base::sys.calls
[10:58:45.785]             `[[` <- base::`[[`
[10:58:45.785]             `+` <- base::`+`
[10:58:45.785]             `<<-` <- base::`<<-`
[10:58:45.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.785]                   3L)]
[10:58:45.785]             }
[10:58:45.785]             function(cond) {
[10:58:45.785]                 is_error <- inherits(cond, "error")
[10:58:45.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.785]                   NULL)
[10:58:45.785]                 if (is_error) {
[10:58:45.785]                   sessionInformation <- function() {
[10:58:45.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.785]                       search = base::search(), system = base::Sys.info())
[10:58:45.785]                   }
[10:58:45.785]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.785]                     cond$call), session = sessionInformation(), 
[10:58:45.785]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.785]                   signalCondition(cond)
[10:58:45.785]                 }
[10:58:45.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.785]                 "immediateCondition"))) {
[10:58:45.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.785]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.785]                   if (TRUE && !signal) {
[10:58:45.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.785]                     {
[10:58:45.785]                       inherits <- base::inherits
[10:58:45.785]                       invokeRestart <- base::invokeRestart
[10:58:45.785]                       is.null <- base::is.null
[10:58:45.785]                       muffled <- FALSE
[10:58:45.785]                       if (inherits(cond, "message")) {
[10:58:45.785]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.785]                         if (muffled) 
[10:58:45.785]                           invokeRestart("muffleMessage")
[10:58:45.785]                       }
[10:58:45.785]                       else if (inherits(cond, "warning")) {
[10:58:45.785]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.785]                         if (muffled) 
[10:58:45.785]                           invokeRestart("muffleWarning")
[10:58:45.785]                       }
[10:58:45.785]                       else if (inherits(cond, "condition")) {
[10:58:45.785]                         if (!is.null(pattern)) {
[10:58:45.785]                           computeRestarts <- base::computeRestarts
[10:58:45.785]                           grepl <- base::grepl
[10:58:45.785]                           restarts <- computeRestarts(cond)
[10:58:45.785]                           for (restart in restarts) {
[10:58:45.785]                             name <- restart$name
[10:58:45.785]                             if (is.null(name)) 
[10:58:45.785]                               next
[10:58:45.785]                             if (!grepl(pattern, name)) 
[10:58:45.785]                               next
[10:58:45.785]                             invokeRestart(restart)
[10:58:45.785]                             muffled <- TRUE
[10:58:45.785]                             break
[10:58:45.785]                           }
[10:58:45.785]                         }
[10:58:45.785]                       }
[10:58:45.785]                       invisible(muffled)
[10:58:45.785]                     }
[10:58:45.785]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.785]                   }
[10:58:45.785]                 }
[10:58:45.785]                 else {
[10:58:45.785]                   if (TRUE) {
[10:58:45.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.785]                     {
[10:58:45.785]                       inherits <- base::inherits
[10:58:45.785]                       invokeRestart <- base::invokeRestart
[10:58:45.785]                       is.null <- base::is.null
[10:58:45.785]                       muffled <- FALSE
[10:58:45.785]                       if (inherits(cond, "message")) {
[10:58:45.785]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.785]                         if (muffled) 
[10:58:45.785]                           invokeRestart("muffleMessage")
[10:58:45.785]                       }
[10:58:45.785]                       else if (inherits(cond, "warning")) {
[10:58:45.785]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.785]                         if (muffled) 
[10:58:45.785]                           invokeRestart("muffleWarning")
[10:58:45.785]                       }
[10:58:45.785]                       else if (inherits(cond, "condition")) {
[10:58:45.785]                         if (!is.null(pattern)) {
[10:58:45.785]                           computeRestarts <- base::computeRestarts
[10:58:45.785]                           grepl <- base::grepl
[10:58:45.785]                           restarts <- computeRestarts(cond)
[10:58:45.785]                           for (restart in restarts) {
[10:58:45.785]                             name <- restart$name
[10:58:45.785]                             if (is.null(name)) 
[10:58:45.785]                               next
[10:58:45.785]                             if (!grepl(pattern, name)) 
[10:58:45.785]                               next
[10:58:45.785]                             invokeRestart(restart)
[10:58:45.785]                             muffled <- TRUE
[10:58:45.785]                             break
[10:58:45.785]                           }
[10:58:45.785]                         }
[10:58:45.785]                       }
[10:58:45.785]                       invisible(muffled)
[10:58:45.785]                     }
[10:58:45.785]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.785]                   }
[10:58:45.785]                 }
[10:58:45.785]             }
[10:58:45.785]         }))
[10:58:45.785]     }, error = function(ex) {
[10:58:45.785]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.785]                 ...future.rng), started = ...future.startTime, 
[10:58:45.785]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.785]             version = "1.8"), class = "FutureResult")
[10:58:45.785]     }, finally = {
[10:58:45.785]         if (!identical(...future.workdir, getwd())) 
[10:58:45.785]             setwd(...future.workdir)
[10:58:45.785]         {
[10:58:45.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.785]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.785]             }
[10:58:45.785]             base::options(...future.oldOptions)
[10:58:45.785]             if (.Platform$OS.type == "windows") {
[10:58:45.785]                 old_names <- names(...future.oldEnvVars)
[10:58:45.785]                 envs <- base::Sys.getenv()
[10:58:45.785]                 names <- names(envs)
[10:58:45.785]                 common <- intersect(names, old_names)
[10:58:45.785]                 added <- setdiff(names, old_names)
[10:58:45.785]                 removed <- setdiff(old_names, names)
[10:58:45.785]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.785]                   envs[common]]
[10:58:45.785]                 NAMES <- toupper(changed)
[10:58:45.785]                 args <- list()
[10:58:45.785]                 for (kk in seq_along(NAMES)) {
[10:58:45.785]                   name <- changed[[kk]]
[10:58:45.785]                   NAME <- NAMES[[kk]]
[10:58:45.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.785]                     next
[10:58:45.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.785]                 }
[10:58:45.785]                 NAMES <- toupper(added)
[10:58:45.785]                 for (kk in seq_along(NAMES)) {
[10:58:45.785]                   name <- added[[kk]]
[10:58:45.785]                   NAME <- NAMES[[kk]]
[10:58:45.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.785]                     next
[10:58:45.785]                   args[[name]] <- ""
[10:58:45.785]                 }
[10:58:45.785]                 NAMES <- toupper(removed)
[10:58:45.785]                 for (kk in seq_along(NAMES)) {
[10:58:45.785]                   name <- removed[[kk]]
[10:58:45.785]                   NAME <- NAMES[[kk]]
[10:58:45.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.785]                     next
[10:58:45.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.785]                 }
[10:58:45.785]                 if (length(args) > 0) 
[10:58:45.785]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.785]             }
[10:58:45.785]             else {
[10:58:45.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.785]             }
[10:58:45.785]             {
[10:58:45.785]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.785]                   0L) {
[10:58:45.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.785]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.785]                   base::options(opts)
[10:58:45.785]                 }
[10:58:45.785]                 {
[10:58:45.785]                   {
[10:58:45.785]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.785]                     NULL
[10:58:45.785]                   }
[10:58:45.785]                   options(future.plan = NULL)
[10:58:45.785]                   if (is.na(NA_character_)) 
[10:58:45.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.785]                     .init = FALSE)
[10:58:45.785]                 }
[10:58:45.785]             }
[10:58:45.785]         }
[10:58:45.785]     })
[10:58:45.785]     if (TRUE) {
[10:58:45.785]         base::sink(type = "output", split = FALSE)
[10:58:45.785]         if (TRUE) {
[10:58:45.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.785]         }
[10:58:45.785]         else {
[10:58:45.785]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.785]         }
[10:58:45.785]         base::close(...future.stdout)
[10:58:45.785]         ...future.stdout <- NULL
[10:58:45.785]     }
[10:58:45.785]     ...future.result$conditions <- ...future.conditions
[10:58:45.785]     ...future.result$finished <- base::Sys.time()
[10:58:45.785]     ...future.result
[10:58:45.785] }
[10:58:45.788] Exporting 5 global objects (1.57 KiB) to cluster node #1 ...
[10:58:45.788] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[10:58:45.788] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[10:58:45.788] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:45.789] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:45.789] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[10:58:45.789] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[10:58:45.789] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:45.790] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.790] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:45.790] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:45.790] Exporting 5 global objects (1.57 KiB) to cluster node #1 ... DONE
[10:58:45.791] MultisessionFuture started
[10:58:45.791] - Launch lazy future ... done
[10:58:45.791] run() for ‘MultisessionFuture’ ... done
[10:58:45.791] Created future:
[10:58:45.791] MultisessionFuture:
[10:58:45.791] Label: ‘future_by-1’
[10:58:45.791] Expression:
[10:58:45.791] {
[10:58:45.791]     do.call(function(...) {
[10:58:45.791]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.791]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.791]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.791]             on.exit(options(oopts), add = TRUE)
[10:58:45.791]         }
[10:58:45.791]         {
[10:58:45.791]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.791]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.791]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.791]             })
[10:58:45.791]         }
[10:58:45.791]     }, args = future.call.arguments)
[10:58:45.791] }
[10:58:45.791] Lazy evaluation: FALSE
[10:58:45.791] Asynchronous evaluation: TRUE
[10:58:45.791] Local evaluation: TRUE
[10:58:45.791] Environment: 0x55974edbba10
[10:58:45.791] Capture standard output: TRUE
[10:58:45.791] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.791] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.791] Packages: <none>
[10:58:45.791] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.791] Resolved: FALSE
[10:58:45.791] Value: <not collected>
[10:58:45.791] Conditions captured: <none>
[10:58:45.791] Early signaling: FALSE
[10:58:45.791] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.791] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.803] Chunk #1 of 2 ... DONE
[10:58:45.803] Chunk #2 of 2 ...
[10:58:45.803]  - Finding globals in 'X' for chunk #2 ...
[10:58:45.803] getGlobalsAndPackages() ...
[10:58:45.803] Searching for globals...
[10:58:45.803] 
[10:58:45.804] Searching for globals ... DONE
[10:58:45.804] - globals: [0] <none>
[10:58:45.804] getGlobalsAndPackages() ... DONE
[10:58:45.804]    + additional globals found: [n=0] 
[10:58:45.804]    + additional namespaces needed: [n=0] 
[10:58:45.804]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:45.804]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:45.804]  - seeds: <none>
[10:58:45.804]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.804] getGlobalsAndPackages() ...
[10:58:45.804] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.805] Resolving globals: FALSE
[10:58:45.805] Tweak future expression to call with '...' arguments ...
[10:58:45.807] {
[10:58:45.807]     do.call(function(...) {
[10:58:45.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.807]             on.exit(options(oopts), add = TRUE)
[10:58:45.807]         }
[10:58:45.807]         {
[10:58:45.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.807]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.807]             })
[10:58:45.807]         }
[10:58:45.807]     }, args = future.call.arguments)
[10:58:45.807] }
[10:58:45.807] Tweak future expression to call with '...' arguments ... DONE
[10:58:45.807] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:45.807] 
[10:58:45.808] getGlobalsAndPackages() ... DONE
[10:58:45.808] run() for ‘Future’ ...
[10:58:45.808] - state: ‘created’
[10:58:45.808] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:45.822] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:45.822]   - Field: ‘node’
[10:58:45.822]   - Field: ‘label’
[10:58:45.822]   - Field: ‘local’
[10:58:45.822]   - Field: ‘owner’
[10:58:45.822]   - Field: ‘envir’
[10:58:45.822]   - Field: ‘workers’
[10:58:45.822]   - Field: ‘packages’
[10:58:45.822]   - Field: ‘gc’
[10:58:45.822]   - Field: ‘conditions’
[10:58:45.823]   - Field: ‘persistent’
[10:58:45.823]   - Field: ‘expr’
[10:58:45.823]   - Field: ‘uuid’
[10:58:45.823]   - Field: ‘seed’
[10:58:45.823]   - Field: ‘version’
[10:58:45.823]   - Field: ‘result’
[10:58:45.823]   - Field: ‘asynchronous’
[10:58:45.823]   - Field: ‘calls’
[10:58:45.823]   - Field: ‘globals’
[10:58:45.823]   - Field: ‘stdout’
[10:58:45.823]   - Field: ‘earlySignal’
[10:58:45.823]   - Field: ‘lazy’
[10:58:45.824]   - Field: ‘state’
[10:58:45.824] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:45.824] - Launch lazy future ...
[10:58:45.824] Packages needed by the future expression (n = 0): <none>
[10:58:45.824] Packages needed by future strategies (n = 0): <none>
[10:58:45.825] {
[10:58:45.825]     {
[10:58:45.825]         {
[10:58:45.825]             ...future.startTime <- base::Sys.time()
[10:58:45.825]             {
[10:58:45.825]                 {
[10:58:45.825]                   {
[10:58:45.825]                     {
[10:58:45.825]                       base::local({
[10:58:45.825]                         has_future <- base::requireNamespace("future", 
[10:58:45.825]                           quietly = TRUE)
[10:58:45.825]                         if (has_future) {
[10:58:45.825]                           ns <- base::getNamespace("future")
[10:58:45.825]                           version <- ns[[".package"]][["version"]]
[10:58:45.825]                           if (is.null(version)) 
[10:58:45.825]                             version <- utils::packageVersion("future")
[10:58:45.825]                         }
[10:58:45.825]                         else {
[10:58:45.825]                           version <- NULL
[10:58:45.825]                         }
[10:58:45.825]                         if (!has_future || version < "1.8.0") {
[10:58:45.825]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:45.825]                             "", base::R.version$version.string), 
[10:58:45.825]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:45.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:45.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:45.825]                               "release", "version")], collapse = " "), 
[10:58:45.825]                             hostname = base::Sys.info()[["nodename"]])
[10:58:45.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:45.825]                             info)
[10:58:45.825]                           info <- base::paste(info, collapse = "; ")
[10:58:45.825]                           if (!has_future) {
[10:58:45.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:45.825]                               info)
[10:58:45.825]                           }
[10:58:45.825]                           else {
[10:58:45.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:45.825]                               info, version)
[10:58:45.825]                           }
[10:58:45.825]                           base::stop(msg)
[10:58:45.825]                         }
[10:58:45.825]                       })
[10:58:45.825]                     }
[10:58:45.825]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:45.825]                     base::options(mc.cores = 1L)
[10:58:45.825]                   }
[10:58:45.825]                   ...future.strategy.old <- future::plan("list")
[10:58:45.825]                   options(future.plan = NULL)
[10:58:45.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:45.825]                 }
[10:58:45.825]                 ...future.workdir <- getwd()
[10:58:45.825]             }
[10:58:45.825]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:45.825]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:45.825]         }
[10:58:45.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:45.825]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:45.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:45.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:45.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:45.825]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:45.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:45.825]             base::names(...future.oldOptions))
[10:58:45.825]     }
[10:58:45.825]     if (FALSE) {
[10:58:45.825]     }
[10:58:45.825]     else {
[10:58:45.825]         if (TRUE) {
[10:58:45.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:45.825]                 open = "w")
[10:58:45.825]         }
[10:58:45.825]         else {
[10:58:45.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:45.825]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:45.825]         }
[10:58:45.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:45.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:45.825]             base::sink(type = "output", split = FALSE)
[10:58:45.825]             base::close(...future.stdout)
[10:58:45.825]         }, add = TRUE)
[10:58:45.825]     }
[10:58:45.825]     ...future.frame <- base::sys.nframe()
[10:58:45.825]     ...future.conditions <- base::list()
[10:58:45.825]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:45.825]     if (FALSE) {
[10:58:45.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:45.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:45.825]     }
[10:58:45.825]     ...future.result <- base::tryCatch({
[10:58:45.825]         base::withCallingHandlers({
[10:58:45.825]             ...future.value <- base::withVisible(base::local({
[10:58:45.825]                 ...future.makeSendCondition <- base::local({
[10:58:45.825]                   sendCondition <- NULL
[10:58:45.825]                   function(frame = 1L) {
[10:58:45.825]                     if (is.function(sendCondition)) 
[10:58:45.825]                       return(sendCondition)
[10:58:45.825]                     ns <- getNamespace("parallel")
[10:58:45.825]                     if (exists("sendData", mode = "function", 
[10:58:45.825]                       envir = ns)) {
[10:58:45.825]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:45.825]                         envir = ns)
[10:58:45.825]                       envir <- sys.frame(frame)
[10:58:45.825]                       master <- NULL
[10:58:45.825]                       while (!identical(envir, .GlobalEnv) && 
[10:58:45.825]                         !identical(envir, emptyenv())) {
[10:58:45.825]                         if (exists("master", mode = "list", envir = envir, 
[10:58:45.825]                           inherits = FALSE)) {
[10:58:45.825]                           master <- get("master", mode = "list", 
[10:58:45.825]                             envir = envir, inherits = FALSE)
[10:58:45.825]                           if (inherits(master, c("SOCKnode", 
[10:58:45.825]                             "SOCK0node"))) {
[10:58:45.825]                             sendCondition <<- function(cond) {
[10:58:45.825]                               data <- list(type = "VALUE", value = cond, 
[10:58:45.825]                                 success = TRUE)
[10:58:45.825]                               parallel_sendData(master, data)
[10:58:45.825]                             }
[10:58:45.825]                             return(sendCondition)
[10:58:45.825]                           }
[10:58:45.825]                         }
[10:58:45.825]                         frame <- frame + 1L
[10:58:45.825]                         envir <- sys.frame(frame)
[10:58:45.825]                       }
[10:58:45.825]                     }
[10:58:45.825]                     sendCondition <<- function(cond) NULL
[10:58:45.825]                   }
[10:58:45.825]                 })
[10:58:45.825]                 withCallingHandlers({
[10:58:45.825]                   {
[10:58:45.825]                     do.call(function(...) {
[10:58:45.825]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.825]                       if (!identical(...future.globals.maxSize.org, 
[10:58:45.825]                         ...future.globals.maxSize)) {
[10:58:45.825]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.825]                         on.exit(options(oopts), add = TRUE)
[10:58:45.825]                       }
[10:58:45.825]                       {
[10:58:45.825]                         lapply(seq_along(...future.elements_ii), 
[10:58:45.825]                           FUN = function(jj) {
[10:58:45.825]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.825]                             ...future.FUN(...future.X_jj, ...)
[10:58:45.825]                           })
[10:58:45.825]                       }
[10:58:45.825]                     }, args = future.call.arguments)
[10:58:45.825]                   }
[10:58:45.825]                 }, immediateCondition = function(cond) {
[10:58:45.825]                   sendCondition <- ...future.makeSendCondition()
[10:58:45.825]                   sendCondition(cond)
[10:58:45.825]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.825]                   {
[10:58:45.825]                     inherits <- base::inherits
[10:58:45.825]                     invokeRestart <- base::invokeRestart
[10:58:45.825]                     is.null <- base::is.null
[10:58:45.825]                     muffled <- FALSE
[10:58:45.825]                     if (inherits(cond, "message")) {
[10:58:45.825]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:45.825]                       if (muffled) 
[10:58:45.825]                         invokeRestart("muffleMessage")
[10:58:45.825]                     }
[10:58:45.825]                     else if (inherits(cond, "warning")) {
[10:58:45.825]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:45.825]                       if (muffled) 
[10:58:45.825]                         invokeRestart("muffleWarning")
[10:58:45.825]                     }
[10:58:45.825]                     else if (inherits(cond, "condition")) {
[10:58:45.825]                       if (!is.null(pattern)) {
[10:58:45.825]                         computeRestarts <- base::computeRestarts
[10:58:45.825]                         grepl <- base::grepl
[10:58:45.825]                         restarts <- computeRestarts(cond)
[10:58:45.825]                         for (restart in restarts) {
[10:58:45.825]                           name <- restart$name
[10:58:45.825]                           if (is.null(name)) 
[10:58:45.825]                             next
[10:58:45.825]                           if (!grepl(pattern, name)) 
[10:58:45.825]                             next
[10:58:45.825]                           invokeRestart(restart)
[10:58:45.825]                           muffled <- TRUE
[10:58:45.825]                           break
[10:58:45.825]                         }
[10:58:45.825]                       }
[10:58:45.825]                     }
[10:58:45.825]                     invisible(muffled)
[10:58:45.825]                   }
[10:58:45.825]                   muffleCondition(cond)
[10:58:45.825]                 })
[10:58:45.825]             }))
[10:58:45.825]             future::FutureResult(value = ...future.value$value, 
[10:58:45.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.825]                   ...future.rng), globalenv = if (FALSE) 
[10:58:45.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:45.825]                     ...future.globalenv.names))
[10:58:45.825]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:45.825]         }, condition = base::local({
[10:58:45.825]             c <- base::c
[10:58:45.825]             inherits <- base::inherits
[10:58:45.825]             invokeRestart <- base::invokeRestart
[10:58:45.825]             length <- base::length
[10:58:45.825]             list <- base::list
[10:58:45.825]             seq.int <- base::seq.int
[10:58:45.825]             signalCondition <- base::signalCondition
[10:58:45.825]             sys.calls <- base::sys.calls
[10:58:45.825]             `[[` <- base::`[[`
[10:58:45.825]             `+` <- base::`+`
[10:58:45.825]             `<<-` <- base::`<<-`
[10:58:45.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:45.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:45.825]                   3L)]
[10:58:45.825]             }
[10:58:45.825]             function(cond) {
[10:58:45.825]                 is_error <- inherits(cond, "error")
[10:58:45.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:45.825]                   NULL)
[10:58:45.825]                 if (is_error) {
[10:58:45.825]                   sessionInformation <- function() {
[10:58:45.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:45.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:45.825]                       search = base::search(), system = base::Sys.info())
[10:58:45.825]                   }
[10:58:45.825]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:45.825]                     cond$call), session = sessionInformation(), 
[10:58:45.825]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:45.825]                   signalCondition(cond)
[10:58:45.825]                 }
[10:58:45.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:45.825]                 "immediateCondition"))) {
[10:58:45.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:45.825]                   ...future.conditions[[length(...future.conditions) + 
[10:58:45.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:45.825]                   if (TRUE && !signal) {
[10:58:45.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.825]                     {
[10:58:45.825]                       inherits <- base::inherits
[10:58:45.825]                       invokeRestart <- base::invokeRestart
[10:58:45.825]                       is.null <- base::is.null
[10:58:45.825]                       muffled <- FALSE
[10:58:45.825]                       if (inherits(cond, "message")) {
[10:58:45.825]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.825]                         if (muffled) 
[10:58:45.825]                           invokeRestart("muffleMessage")
[10:58:45.825]                       }
[10:58:45.825]                       else if (inherits(cond, "warning")) {
[10:58:45.825]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.825]                         if (muffled) 
[10:58:45.825]                           invokeRestart("muffleWarning")
[10:58:45.825]                       }
[10:58:45.825]                       else if (inherits(cond, "condition")) {
[10:58:45.825]                         if (!is.null(pattern)) {
[10:58:45.825]                           computeRestarts <- base::computeRestarts
[10:58:45.825]                           grepl <- base::grepl
[10:58:45.825]                           restarts <- computeRestarts(cond)
[10:58:45.825]                           for (restart in restarts) {
[10:58:45.825]                             name <- restart$name
[10:58:45.825]                             if (is.null(name)) 
[10:58:45.825]                               next
[10:58:45.825]                             if (!grepl(pattern, name)) 
[10:58:45.825]                               next
[10:58:45.825]                             invokeRestart(restart)
[10:58:45.825]                             muffled <- TRUE
[10:58:45.825]                             break
[10:58:45.825]                           }
[10:58:45.825]                         }
[10:58:45.825]                       }
[10:58:45.825]                       invisible(muffled)
[10:58:45.825]                     }
[10:58:45.825]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.825]                   }
[10:58:45.825]                 }
[10:58:45.825]                 else {
[10:58:45.825]                   if (TRUE) {
[10:58:45.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:45.825]                     {
[10:58:45.825]                       inherits <- base::inherits
[10:58:45.825]                       invokeRestart <- base::invokeRestart
[10:58:45.825]                       is.null <- base::is.null
[10:58:45.825]                       muffled <- FALSE
[10:58:45.825]                       if (inherits(cond, "message")) {
[10:58:45.825]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:45.825]                         if (muffled) 
[10:58:45.825]                           invokeRestart("muffleMessage")
[10:58:45.825]                       }
[10:58:45.825]                       else if (inherits(cond, "warning")) {
[10:58:45.825]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:45.825]                         if (muffled) 
[10:58:45.825]                           invokeRestart("muffleWarning")
[10:58:45.825]                       }
[10:58:45.825]                       else if (inherits(cond, "condition")) {
[10:58:45.825]                         if (!is.null(pattern)) {
[10:58:45.825]                           computeRestarts <- base::computeRestarts
[10:58:45.825]                           grepl <- base::grepl
[10:58:45.825]                           restarts <- computeRestarts(cond)
[10:58:45.825]                           for (restart in restarts) {
[10:58:45.825]                             name <- restart$name
[10:58:45.825]                             if (is.null(name)) 
[10:58:45.825]                               next
[10:58:45.825]                             if (!grepl(pattern, name)) 
[10:58:45.825]                               next
[10:58:45.825]                             invokeRestart(restart)
[10:58:45.825]                             muffled <- TRUE
[10:58:45.825]                             break
[10:58:45.825]                           }
[10:58:45.825]                         }
[10:58:45.825]                       }
[10:58:45.825]                       invisible(muffled)
[10:58:45.825]                     }
[10:58:45.825]                     muffleCondition(cond, pattern = "^muffle")
[10:58:45.825]                   }
[10:58:45.825]                 }
[10:58:45.825]             }
[10:58:45.825]         }))
[10:58:45.825]     }, error = function(ex) {
[10:58:45.825]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:45.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:45.825]                 ...future.rng), started = ...future.startTime, 
[10:58:45.825]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:45.825]             version = "1.8"), class = "FutureResult")
[10:58:45.825]     }, finally = {
[10:58:45.825]         if (!identical(...future.workdir, getwd())) 
[10:58:45.825]             setwd(...future.workdir)
[10:58:45.825]         {
[10:58:45.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:45.825]                 ...future.oldOptions$nwarnings <- NULL
[10:58:45.825]             }
[10:58:45.825]             base::options(...future.oldOptions)
[10:58:45.825]             if (.Platform$OS.type == "windows") {
[10:58:45.825]                 old_names <- names(...future.oldEnvVars)
[10:58:45.825]                 envs <- base::Sys.getenv()
[10:58:45.825]                 names <- names(envs)
[10:58:45.825]                 common <- intersect(names, old_names)
[10:58:45.825]                 added <- setdiff(names, old_names)
[10:58:45.825]                 removed <- setdiff(old_names, names)
[10:58:45.825]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:45.825]                   envs[common]]
[10:58:45.825]                 NAMES <- toupper(changed)
[10:58:45.825]                 args <- list()
[10:58:45.825]                 for (kk in seq_along(NAMES)) {
[10:58:45.825]                   name <- changed[[kk]]
[10:58:45.825]                   NAME <- NAMES[[kk]]
[10:58:45.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.825]                     next
[10:58:45.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.825]                 }
[10:58:45.825]                 NAMES <- toupper(added)
[10:58:45.825]                 for (kk in seq_along(NAMES)) {
[10:58:45.825]                   name <- added[[kk]]
[10:58:45.825]                   NAME <- NAMES[[kk]]
[10:58:45.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.825]                     next
[10:58:45.825]                   args[[name]] <- ""
[10:58:45.825]                 }
[10:58:45.825]                 NAMES <- toupper(removed)
[10:58:45.825]                 for (kk in seq_along(NAMES)) {
[10:58:45.825]                   name <- removed[[kk]]
[10:58:45.825]                   NAME <- NAMES[[kk]]
[10:58:45.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:45.825]                     next
[10:58:45.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:45.825]                 }
[10:58:45.825]                 if (length(args) > 0) 
[10:58:45.825]                   base::do.call(base::Sys.setenv, args = args)
[10:58:45.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:45.825]             }
[10:58:45.825]             else {
[10:58:45.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:45.825]             }
[10:58:45.825]             {
[10:58:45.825]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:45.825]                   0L) {
[10:58:45.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:45.825]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:45.825]                   base::options(opts)
[10:58:45.825]                 }
[10:58:45.825]                 {
[10:58:45.825]                   {
[10:58:45.825]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:45.825]                     NULL
[10:58:45.825]                   }
[10:58:45.825]                   options(future.plan = NULL)
[10:58:45.825]                   if (is.na(NA_character_)) 
[10:58:45.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:45.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:45.825]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:45.825]                     .init = FALSE)
[10:58:45.825]                 }
[10:58:45.825]             }
[10:58:45.825]         }
[10:58:45.825]     })
[10:58:45.825]     if (TRUE) {
[10:58:45.825]         base::sink(type = "output", split = FALSE)
[10:58:45.825]         if (TRUE) {
[10:58:45.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:45.825]         }
[10:58:45.825]         else {
[10:58:45.825]             ...future.result["stdout"] <- base::list(NULL)
[10:58:45.825]         }
[10:58:45.825]         base::close(...future.stdout)
[10:58:45.825]         ...future.stdout <- NULL
[10:58:45.825]     }
[10:58:45.825]     ...future.result$conditions <- ...future.conditions
[10:58:45.825]     ...future.result$finished <- base::Sys.time()
[10:58:45.825]     ...future.result
[10:58:45.825] }
[10:58:45.827] Exporting 5 global objects (2.20 KiB) to cluster node #2 ...
[10:58:45.827] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[10:58:45.828] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[10:58:45.828] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:45.828] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:45.828] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[10:58:45.829] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[10:58:45.829] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:45.829] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.829] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:45.830] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:45.830] Exporting 5 global objects (2.20 KiB) to cluster node #2 ... DONE
[10:58:45.830] MultisessionFuture started
[10:58:45.831] - Launch lazy future ... done
[10:58:45.831] run() for ‘MultisessionFuture’ ... done
[10:58:45.831] Created future:
[10:58:45.831] MultisessionFuture:
[10:58:45.831] Label: ‘future_by-2’
[10:58:45.831] Expression:
[10:58:45.831] {
[10:58:45.831]     do.call(function(...) {
[10:58:45.831]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:45.831]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:45.831]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:45.831]             on.exit(options(oopts), add = TRUE)
[10:58:45.831]         }
[10:58:45.831]         {
[10:58:45.831]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:45.831]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:45.831]                 ...future.FUN(...future.X_jj, ...)
[10:58:45.831]             })
[10:58:45.831]         }
[10:58:45.831]     }, args = future.call.arguments)
[10:58:45.831] }
[10:58:45.831] Lazy evaluation: FALSE
[10:58:45.831] Asynchronous evaluation: TRUE
[10:58:45.831] Local evaluation: TRUE
[10:58:45.831] Environment: 0x55974edbba10
[10:58:45.831] Capture standard output: TRUE
[10:58:45.831] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:45.831] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:45.831] Packages: <none>
[10:58:45.831] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:45.831] Resolved: FALSE
[10:58:45.831] Value: <not collected>
[10:58:45.831] Conditions captured: <none>
[10:58:45.831] Early signaling: FALSE
[10:58:45.831] Owner process: 193504ea-a735-69d0-63c9-63e14d76ef40
[10:58:45.831] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:45.842] Chunk #2 of 2 ... DONE
[10:58:45.842] Launching 2 futures (chunks) ... DONE
[10:58:45.843] Resolving 2 futures (chunks) ...
[10:58:45.843] resolve() on list ...
[10:58:45.843]  recursive: 0
[10:58:45.843]  length: 2
[10:58:45.843] 
[10:58:45.843] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.844] - Validating connection of MultisessionFuture
[10:58:45.844] - received message: FutureResult
[10:58:45.844] - Received FutureResult
[10:58:45.844] - Erased future from FutureRegistry
[10:58:45.844] result() for ClusterFuture ...
[10:58:45.844] - result already collected: FutureResult
[10:58:45.844] result() for ClusterFuture ... done
[10:58:45.844] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.844] Future #1
[10:58:45.844] result() for ClusterFuture ...
[10:58:45.845] - result already collected: FutureResult
[10:58:45.845] result() for ClusterFuture ... done
[10:58:45.845] result() for ClusterFuture ...
[10:58:45.845] - result already collected: FutureResult
[10:58:45.845] result() for ClusterFuture ... done
[10:58:45.845] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:45.845] - nx: 2
[10:58:45.845] - relay: TRUE
[10:58:45.845] - stdout: TRUE
[10:58:45.845] - signal: TRUE
[10:58:45.845] - resignal: FALSE
[10:58:45.845] - force: TRUE
[10:58:45.845] - relayed: [n=2] FALSE, FALSE
[10:58:45.846] - queued futures: [n=2] FALSE, FALSE
[10:58:45.846]  - until=1
[10:58:45.846]  - relaying element #1
[10:58:45.846] result() for ClusterFuture ...
[10:58:45.846] - result already collected: FutureResult
[10:58:45.846] result() for ClusterFuture ... done
[10:58:45.846] result() for ClusterFuture ...
[10:58:45.846] - result already collected: FutureResult
[10:58:45.846] result() for ClusterFuture ... done
[10:58:45.846] result() for ClusterFuture ...
[10:58:45.846] - result already collected: FutureResult
[10:58:45.846] result() for ClusterFuture ... done
[10:58:45.847] result() for ClusterFuture ...
[10:58:45.847] - result already collected: FutureResult
[10:58:45.847] result() for ClusterFuture ... done
[10:58:45.847] - relayed: [n=2] TRUE, FALSE
[10:58:45.847] - queued futures: [n=2] TRUE, FALSE
[10:58:45.847] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:45.847]  length: 1 (resolved future 1)
[10:58:45.873] receiveMessageFromWorker() for ClusterFuture ...
[10:58:45.873] - Validating connection of MultisessionFuture
[10:58:45.874] - received message: FutureResult
[10:58:45.874] - Received FutureResult
[10:58:45.874] - Erased future from FutureRegistry
[10:58:45.874] result() for ClusterFuture ...
[10:58:45.874] - result already collected: FutureResult
[10:58:45.874] result() for ClusterFuture ... done
[10:58:45.874] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:45.874] Future #2
[10:58:45.874] result() for ClusterFuture ...
[10:58:45.875] - result already collected: FutureResult
[10:58:45.875] result() for ClusterFuture ... done
[10:58:45.875] result() for ClusterFuture ...
[10:58:45.875] - result already collected: FutureResult
[10:58:45.875] result() for ClusterFuture ... done
[10:58:45.875] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:45.875] - nx: 2
[10:58:45.875] - relay: TRUE
[10:58:45.875] - stdout: TRUE
[10:58:45.875] - signal: TRUE
[10:58:45.875] - resignal: FALSE
[10:58:45.875] - force: TRUE
[10:58:45.875] - relayed: [n=2] TRUE, FALSE
[10:58:45.876] - queued futures: [n=2] TRUE, FALSE
[10:58:45.876]  - until=2
[10:58:45.876]  - relaying element #2
[10:58:45.876] result() for ClusterFuture ...
[10:58:45.876] - result already collected: FutureResult
[10:58:45.876] result() for ClusterFuture ... done
[10:58:45.876] result() for ClusterFuture ...
[10:58:45.876] - result already collected: FutureResult
[10:58:45.876] result() for ClusterFuture ... done
[10:58:45.876] result() for ClusterFuture ...
[10:58:45.876] - result already collected: FutureResult
[10:58:45.876] result() for ClusterFuture ... done
[10:58:45.877] result() for ClusterFuture ...
[10:58:45.877] - result already collected: FutureResult
[10:58:45.877] result() for ClusterFuture ... done
[10:58:45.877] - relayed: [n=2] TRUE, TRUE
[10:58:45.877] - queued futures: [n=2] TRUE, TRUE
[10:58:45.877] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:45.877]  length: 0 (resolved future 2)
[10:58:45.877] Relaying remaining futures
[10:58:45.877] signalConditionsASAP(NULL, pos=0) ...
[10:58:45.877] - nx: 2
[10:58:45.877] - relay: TRUE
[10:58:45.877] - stdout: TRUE
[10:58:45.877] - signal: TRUE
[10:58:45.878] - resignal: FALSE
[10:58:45.878] - force: TRUE
[10:58:45.878] - relayed: [n=2] TRUE, TRUE
[10:58:45.878] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:45.878] - relayed: [n=2] TRUE, TRUE
[10:58:45.878] - queued futures: [n=2] TRUE, TRUE
[10:58:45.878] signalConditionsASAP(NULL, pos=0) ... done
[10:58:45.878] resolve() on list ... DONE
[10:58:45.878] result() for ClusterFuture ...
[10:58:45.878] - result already collected: FutureResult
[10:58:45.878] result() for ClusterFuture ... done
[10:58:45.878] result() for ClusterFuture ...
[10:58:45.879] - result already collected: FutureResult
[10:58:45.879] result() for ClusterFuture ... done
[10:58:45.879] result() for ClusterFuture ...
[10:58:45.879] - result already collected: FutureResult
[10:58:45.879] result() for ClusterFuture ... done
[10:58:45.879] result() for ClusterFuture ...
[10:58:45.879] - result already collected: FutureResult
[10:58:45.879] result() for ClusterFuture ... done
[10:58:45.879]  - Number of value chunks collected: 2
[10:58:45.879] Resolving 2 futures (chunks) ... DONE
[10:58:45.879] Reducing values from 2 chunks ...
[10:58:45.879]  - Number of values collected after concatenation: 3
[10:58:45.880]  - Number of values expected: 3
[10:58:45.880] Reducing values from 2 chunks ... DONE
[10:58:45.880] future_lapply() ... DONE
[10:58:45.880] future_by_internal() ... DONE
[10:58:45.881] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[10:58:45.881] plan(): Setting new future strategy stack:
[10:58:45.882] List of future strategies:
[10:58:45.882] 1. FutureStrategy:
[10:58:45.882]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:45.882]    - tweaked: FALSE
[10:58:45.882]    - call: future::plan(oplan)
[10:58:45.882] plan(): nbrOfWorkers() = 1
> 
