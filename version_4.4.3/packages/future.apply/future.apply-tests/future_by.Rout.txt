
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:18:30.530] plan(): Setting new future strategy stack:
[10:18:30.530] List of future strategies:
[10:18:30.530] 1. sequential:
[10:18:30.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.530]    - tweaked: FALSE
[10:18:30.530]    - call: future::plan("sequential")
[10:18:30.544] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[10:18:30.605] plan(): Setting new future strategy stack:
[10:18:30.605] List of future strategies:
[10:18:30.605] 1. sequential:
[10:18:30.605]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.605]    - tweaked: FALSE
[10:18:30.605]    - call: plan(strategy)
[10:18:30.618] plan(): nbrOfWorkers() = 1
[10:18:30.618] future_by_internal() ...
[10:18:30.619] future_lapply() ...
[10:18:30.622] Number of chunks: 1
[10:18:30.622] getGlobalsAndPackagesXApply() ...
[10:18:30.623]  - future.globals: TRUE
[10:18:30.623] getGlobalsAndPackages() ...
[10:18:30.623] Searching for globals...
[10:18:30.625] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:30.625] Searching for globals ... DONE
[10:18:30.625] Resolving globals: FALSE
[10:18:30.626] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:30.627] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:30.627] - globals: [1] ‘FUN’
[10:18:30.627] 
[10:18:30.627] getGlobalsAndPackages() ... DONE
[10:18:30.627]  - globals found/used: [n=1] ‘FUN’
[10:18:30.627]  - needed namespaces: [n=0] 
[10:18:30.627] Finding globals ... DONE
[10:18:30.627]  - use_args: TRUE
[10:18:30.627]  - Getting '...' globals ...
[10:18:30.628] resolve() on list ...
[10:18:30.628]  recursive: 0
[10:18:30.628]  length: 1
[10:18:30.629]  elements: ‘...’
[10:18:30.629]  length: 0 (resolved future 1)
[10:18:30.629] resolve() on list ... DONE
[10:18:30.629]    - '...' content: [n=0] 
[10:18:30.629] List of 1
[10:18:30.629]  $ ...: list()
[10:18:30.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.629]  - attr(*, "where")=List of 1
[10:18:30.629]   ..$ ...:<environment: 0x5584485b7038> 
[10:18:30.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.629]  - attr(*, "resolved")= logi TRUE
[10:18:30.629]  - attr(*, "total_size")= num NA
[10:18:30.633]  - Getting '...' globals ... DONE
[10:18:30.633] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.633] List of 2
[10:18:30.633]  $ ...future.FUN:function (object, ...)  
[10:18:30.633]  $ ...          : list()
[10:18:30.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.633]  - attr(*, "where")=List of 2
[10:18:30.633]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.633]   ..$ ...          :<environment: 0x5584485b7038> 
[10:18:30.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.633]  - attr(*, "resolved")= logi FALSE
[10:18:30.633]  - attr(*, "total_size")= num 15670
[10:18:30.635] Packages to be attached in all futures: [n=0] 
[10:18:30.635] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.636] Number of futures (= number of chunks): 1
[10:18:30.636] Launching 1 futures (chunks) ...
[10:18:30.636] Chunk #1 of 1 ...
[10:18:30.636]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.636] getGlobalsAndPackages() ...
[10:18:30.636] Searching for globals...
[10:18:30.637] 
[10:18:30.637] Searching for globals ... DONE
[10:18:30.637] - globals: [0] <none>
[10:18:30.637] getGlobalsAndPackages() ... DONE
[10:18:30.637]    + additional globals found: [n=0] 
[10:18:30.637]    + additional namespaces needed: [n=0] 
[10:18:30.637]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:30.637]  - seeds: <none>
[10:18:30.638]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.638] getGlobalsAndPackages() ...
[10:18:30.638] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.638] Resolving globals: FALSE
[10:18:30.638] Tweak future expression to call with '...' arguments ...
[10:18:30.638] {
[10:18:30.638]     do.call(function(...) {
[10:18:30.638]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.638]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.638]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.638]             on.exit(options(oopts), add = TRUE)
[10:18:30.638]         }
[10:18:30.638]         {
[10:18:30.638]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.638]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.638]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.638]             })
[10:18:30.638]         }
[10:18:30.638]     }, args = future.call.arguments)
[10:18:30.638] }
[10:18:30.638] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.639] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.639] 
[10:18:30.639] getGlobalsAndPackages() ... DONE
[10:18:30.640] run() for ‘Future’ ...
[10:18:30.640] - state: ‘created’
[10:18:30.640] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:30.640] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.642] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:30.643]   - Field: ‘label’
[10:18:30.643]   - Field: ‘local’
[10:18:30.643]   - Field: ‘owner’
[10:18:30.643]   - Field: ‘envir’
[10:18:30.643]   - Field: ‘packages’
[10:18:30.643]   - Field: ‘gc’
[10:18:30.643]   - Field: ‘conditions’
[10:18:30.643]   - Field: ‘expr’
[10:18:30.643]   - Field: ‘uuid’
[10:18:30.643]   - Field: ‘seed’
[10:18:30.643]   - Field: ‘version’
[10:18:30.643]   - Field: ‘result’
[10:18:30.644]   - Field: ‘asynchronous’
[10:18:30.644]   - Field: ‘calls’
[10:18:30.644]   - Field: ‘globals’
[10:18:30.644]   - Field: ‘stdout’
[10:18:30.644]   - Field: ‘earlySignal’
[10:18:30.644]   - Field: ‘lazy’
[10:18:30.644]   - Field: ‘state’
[10:18:30.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:30.644] - Launch lazy future ...
[10:18:30.645] Packages needed by the future expression (n = 0): <none>
[10:18:30.645] Packages needed by future strategies (n = 0): <none>
[10:18:30.646] {
[10:18:30.646]     {
[10:18:30.646]         {
[10:18:30.646]             ...future.startTime <- base::Sys.time()
[10:18:30.646]             {
[10:18:30.646]                 {
[10:18:30.646]                   {
[10:18:30.646]                     base::local({
[10:18:30.646]                       has_future <- base::requireNamespace("future", 
[10:18:30.646]                         quietly = TRUE)
[10:18:30.646]                       if (has_future) {
[10:18:30.646]                         ns <- base::getNamespace("future")
[10:18:30.646]                         version <- ns[[".package"]][["version"]]
[10:18:30.646]                         if (is.null(version)) 
[10:18:30.646]                           version <- utils::packageVersion("future")
[10:18:30.646]                       }
[10:18:30.646]                       else {
[10:18:30.646]                         version <- NULL
[10:18:30.646]                       }
[10:18:30.646]                       if (!has_future || version < "1.8.0") {
[10:18:30.646]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.646]                           "", base::R.version$version.string), 
[10:18:30.646]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:30.646]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.646]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.646]                             "release", "version")], collapse = " "), 
[10:18:30.646]                           hostname = base::Sys.info()[["nodename"]])
[10:18:30.646]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.646]                           info)
[10:18:30.646]                         info <- base::paste(info, collapse = "; ")
[10:18:30.646]                         if (!has_future) {
[10:18:30.646]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.646]                             info)
[10:18:30.646]                         }
[10:18:30.646]                         else {
[10:18:30.646]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.646]                             info, version)
[10:18:30.646]                         }
[10:18:30.646]                         base::stop(msg)
[10:18:30.646]                       }
[10:18:30.646]                     })
[10:18:30.646]                   }
[10:18:30.646]                   ...future.strategy.old <- future::plan("list")
[10:18:30.646]                   options(future.plan = NULL)
[10:18:30.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.646]                 }
[10:18:30.646]                 ...future.workdir <- getwd()
[10:18:30.646]             }
[10:18:30.646]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.646]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.646]         }
[10:18:30.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.646]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:30.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.646]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.646]             base::names(...future.oldOptions))
[10:18:30.646]     }
[10:18:30.646]     if (FALSE) {
[10:18:30.646]     }
[10:18:30.646]     else {
[10:18:30.646]         if (TRUE) {
[10:18:30.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.646]                 open = "w")
[10:18:30.646]         }
[10:18:30.646]         else {
[10:18:30.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.646]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.646]         }
[10:18:30.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.646]             base::sink(type = "output", split = FALSE)
[10:18:30.646]             base::close(...future.stdout)
[10:18:30.646]         }, add = TRUE)
[10:18:30.646]     }
[10:18:30.646]     ...future.frame <- base::sys.nframe()
[10:18:30.646]     ...future.conditions <- base::list()
[10:18:30.646]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.646]     if (FALSE) {
[10:18:30.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.646]     }
[10:18:30.646]     ...future.result <- base::tryCatch({
[10:18:30.646]         base::withCallingHandlers({
[10:18:30.646]             ...future.value <- base::withVisible(base::local({
[10:18:30.646]                 do.call(function(...) {
[10:18:30.646]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.646]                   if (!identical(...future.globals.maxSize.org, 
[10:18:30.646]                     ...future.globals.maxSize)) {
[10:18:30.646]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.646]                     on.exit(options(oopts), add = TRUE)
[10:18:30.646]                   }
[10:18:30.646]                   {
[10:18:30.646]                     lapply(seq_along(...future.elements_ii), 
[10:18:30.646]                       FUN = function(jj) {
[10:18:30.646]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.646]                         ...future.FUN(...future.X_jj, ...)
[10:18:30.646]                       })
[10:18:30.646]                   }
[10:18:30.646]                 }, args = future.call.arguments)
[10:18:30.646]             }))
[10:18:30.646]             future::FutureResult(value = ...future.value$value, 
[10:18:30.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.646]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.646]                     ...future.globalenv.names))
[10:18:30.646]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.646]         }, condition = base::local({
[10:18:30.646]             c <- base::c
[10:18:30.646]             inherits <- base::inherits
[10:18:30.646]             invokeRestart <- base::invokeRestart
[10:18:30.646]             length <- base::length
[10:18:30.646]             list <- base::list
[10:18:30.646]             seq.int <- base::seq.int
[10:18:30.646]             signalCondition <- base::signalCondition
[10:18:30.646]             sys.calls <- base::sys.calls
[10:18:30.646]             `[[` <- base::`[[`
[10:18:30.646]             `+` <- base::`+`
[10:18:30.646]             `<<-` <- base::`<<-`
[10:18:30.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.646]                   3L)]
[10:18:30.646]             }
[10:18:30.646]             function(cond) {
[10:18:30.646]                 is_error <- inherits(cond, "error")
[10:18:30.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.646]                   NULL)
[10:18:30.646]                 if (is_error) {
[10:18:30.646]                   sessionInformation <- function() {
[10:18:30.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.646]                       search = base::search(), system = base::Sys.info())
[10:18:30.646]                   }
[10:18:30.646]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.646]                     cond$call), session = sessionInformation(), 
[10:18:30.646]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.646]                   signalCondition(cond)
[10:18:30.646]                 }
[10:18:30.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:30.646]                 "immediateCondition"))) {
[10:18:30.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.646]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.646]                   if (TRUE && !signal) {
[10:18:30.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.646]                     {
[10:18:30.646]                       inherits <- base::inherits
[10:18:30.646]                       invokeRestart <- base::invokeRestart
[10:18:30.646]                       is.null <- base::is.null
[10:18:30.646]                       muffled <- FALSE
[10:18:30.646]                       if (inherits(cond, "message")) {
[10:18:30.646]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.646]                         if (muffled) 
[10:18:30.646]                           invokeRestart("muffleMessage")
[10:18:30.646]                       }
[10:18:30.646]                       else if (inherits(cond, "warning")) {
[10:18:30.646]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.646]                         if (muffled) 
[10:18:30.646]                           invokeRestart("muffleWarning")
[10:18:30.646]                       }
[10:18:30.646]                       else if (inherits(cond, "condition")) {
[10:18:30.646]                         if (!is.null(pattern)) {
[10:18:30.646]                           computeRestarts <- base::computeRestarts
[10:18:30.646]                           grepl <- base::grepl
[10:18:30.646]                           restarts <- computeRestarts(cond)
[10:18:30.646]                           for (restart in restarts) {
[10:18:30.646]                             name <- restart$name
[10:18:30.646]                             if (is.null(name)) 
[10:18:30.646]                               next
[10:18:30.646]                             if (!grepl(pattern, name)) 
[10:18:30.646]                               next
[10:18:30.646]                             invokeRestart(restart)
[10:18:30.646]                             muffled <- TRUE
[10:18:30.646]                             break
[10:18:30.646]                           }
[10:18:30.646]                         }
[10:18:30.646]                       }
[10:18:30.646]                       invisible(muffled)
[10:18:30.646]                     }
[10:18:30.646]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.646]                   }
[10:18:30.646]                 }
[10:18:30.646]                 else {
[10:18:30.646]                   if (TRUE) {
[10:18:30.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.646]                     {
[10:18:30.646]                       inherits <- base::inherits
[10:18:30.646]                       invokeRestart <- base::invokeRestart
[10:18:30.646]                       is.null <- base::is.null
[10:18:30.646]                       muffled <- FALSE
[10:18:30.646]                       if (inherits(cond, "message")) {
[10:18:30.646]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.646]                         if (muffled) 
[10:18:30.646]                           invokeRestart("muffleMessage")
[10:18:30.646]                       }
[10:18:30.646]                       else if (inherits(cond, "warning")) {
[10:18:30.646]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.646]                         if (muffled) 
[10:18:30.646]                           invokeRestart("muffleWarning")
[10:18:30.646]                       }
[10:18:30.646]                       else if (inherits(cond, "condition")) {
[10:18:30.646]                         if (!is.null(pattern)) {
[10:18:30.646]                           computeRestarts <- base::computeRestarts
[10:18:30.646]                           grepl <- base::grepl
[10:18:30.646]                           restarts <- computeRestarts(cond)
[10:18:30.646]                           for (restart in restarts) {
[10:18:30.646]                             name <- restart$name
[10:18:30.646]                             if (is.null(name)) 
[10:18:30.646]                               next
[10:18:30.646]                             if (!grepl(pattern, name)) 
[10:18:30.646]                               next
[10:18:30.646]                             invokeRestart(restart)
[10:18:30.646]                             muffled <- TRUE
[10:18:30.646]                             break
[10:18:30.646]                           }
[10:18:30.646]                         }
[10:18:30.646]                       }
[10:18:30.646]                       invisible(muffled)
[10:18:30.646]                     }
[10:18:30.646]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.646]                   }
[10:18:30.646]                 }
[10:18:30.646]             }
[10:18:30.646]         }))
[10:18:30.646]     }, error = function(ex) {
[10:18:30.646]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.646]                 ...future.rng), started = ...future.startTime, 
[10:18:30.646]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.646]             version = "1.8"), class = "FutureResult")
[10:18:30.646]     }, finally = {
[10:18:30.646]         if (!identical(...future.workdir, getwd())) 
[10:18:30.646]             setwd(...future.workdir)
[10:18:30.646]         {
[10:18:30.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.646]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.646]             }
[10:18:30.646]             base::options(...future.oldOptions)
[10:18:30.646]             if (.Platform$OS.type == "windows") {
[10:18:30.646]                 old_names <- names(...future.oldEnvVars)
[10:18:30.646]                 envs <- base::Sys.getenv()
[10:18:30.646]                 names <- names(envs)
[10:18:30.646]                 common <- intersect(names, old_names)
[10:18:30.646]                 added <- setdiff(names, old_names)
[10:18:30.646]                 removed <- setdiff(old_names, names)
[10:18:30.646]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.646]                   envs[common]]
[10:18:30.646]                 NAMES <- toupper(changed)
[10:18:30.646]                 args <- list()
[10:18:30.646]                 for (kk in seq_along(NAMES)) {
[10:18:30.646]                   name <- changed[[kk]]
[10:18:30.646]                   NAME <- NAMES[[kk]]
[10:18:30.646]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.646]                     next
[10:18:30.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.646]                 }
[10:18:30.646]                 NAMES <- toupper(added)
[10:18:30.646]                 for (kk in seq_along(NAMES)) {
[10:18:30.646]                   name <- added[[kk]]
[10:18:30.646]                   NAME <- NAMES[[kk]]
[10:18:30.646]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.646]                     next
[10:18:30.646]                   args[[name]] <- ""
[10:18:30.646]                 }
[10:18:30.646]                 NAMES <- toupper(removed)
[10:18:30.646]                 for (kk in seq_along(NAMES)) {
[10:18:30.646]                   name <- removed[[kk]]
[10:18:30.646]                   NAME <- NAMES[[kk]]
[10:18:30.646]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.646]                     next
[10:18:30.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.646]                 }
[10:18:30.646]                 if (length(args) > 0) 
[10:18:30.646]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.646]             }
[10:18:30.646]             else {
[10:18:30.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.646]             }
[10:18:30.646]             {
[10:18:30.646]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.646]                   0L) {
[10:18:30.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.646]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.646]                   base::options(opts)
[10:18:30.646]                 }
[10:18:30.646]                 {
[10:18:30.646]                   {
[10:18:30.646]                     NULL
[10:18:30.646]                     RNGkind("Mersenne-Twister")
[10:18:30.646]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:30.646]                       inherits = FALSE)
[10:18:30.646]                   }
[10:18:30.646]                   options(future.plan = NULL)
[10:18:30.646]                   if (is.na(NA_character_)) 
[10:18:30.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.646]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.646]                     .init = FALSE)
[10:18:30.646]                 }
[10:18:30.646]             }
[10:18:30.646]         }
[10:18:30.646]     })
[10:18:30.646]     if (TRUE) {
[10:18:30.646]         base::sink(type = "output", split = FALSE)
[10:18:30.646]         if (TRUE) {
[10:18:30.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.646]         }
[10:18:30.646]         else {
[10:18:30.646]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.646]         }
[10:18:30.646]         base::close(...future.stdout)
[10:18:30.646]         ...future.stdout <- NULL
[10:18:30.646]     }
[10:18:30.646]     ...future.result$conditions <- ...future.conditions
[10:18:30.646]     ...future.result$finished <- base::Sys.time()
[10:18:30.646]     ...future.result
[10:18:30.646] }
[10:18:30.648] assign_globals() ...
[10:18:30.648] List of 5
[10:18:30.648]  $ ...future.FUN            :function (object, ...)  
[10:18:30.648]  $ future.call.arguments    : list()
[10:18:30.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.648]  $ ...future.elements_ii    :List of 3
[10:18:30.648]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:30.648]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:30.648]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.648]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:30.648]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:30.648]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.648]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:30.648]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:30.648]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.648]  $ ...future.seeds_ii       : NULL
[10:18:30.648]  $ ...future.globals.maxSize: NULL
[10:18:30.648]  - attr(*, "where")=List of 5
[10:18:30.648]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:30.648]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:30.648]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:30.648]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:30.648]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:30.648]  - attr(*, "resolved")= logi FALSE
[10:18:30.648]  - attr(*, "total_size")= num 15670
[10:18:30.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.648]  - attr(*, "already-done")= logi TRUE
[10:18:30.655] - copied ‘...future.FUN’ to environment
[10:18:30.655] - copied ‘future.call.arguments’ to environment
[10:18:30.655] - copied ‘...future.elements_ii’ to environment
[10:18:30.655] - copied ‘...future.seeds_ii’ to environment
[10:18:30.656] - copied ‘...future.globals.maxSize’ to environment
[10:18:30.656] assign_globals() ... done
[10:18:30.656] plan(): Setting new future strategy stack:
[10:18:30.656] List of future strategies:
[10:18:30.656] 1. sequential:
[10:18:30.656]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.656]    - tweaked: FALSE
[10:18:30.656]    - call: NULL
[10:18:30.656] plan(): nbrOfWorkers() = 1
[10:18:30.659] plan(): Setting new future strategy stack:
[10:18:30.659] List of future strategies:
[10:18:30.659] 1. sequential:
[10:18:30.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.659]    - tweaked: FALSE
[10:18:30.659]    - call: plan(strategy)
[10:18:30.659] plan(): nbrOfWorkers() = 1
[10:18:30.660] SequentialFuture started (and completed)
[10:18:30.660] - Launch lazy future ... done
[10:18:30.660] run() for ‘SequentialFuture’ ... done
[10:18:30.660] Created future:
[10:18:30.660] SequentialFuture:
[10:18:30.660] Label: ‘future_by-1’
[10:18:30.660] Expression:
[10:18:30.660] {
[10:18:30.660]     do.call(function(...) {
[10:18:30.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.660]             on.exit(options(oopts), add = TRUE)
[10:18:30.660]         }
[10:18:30.660]         {
[10:18:30.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.660]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.660]             })
[10:18:30.660]         }
[10:18:30.660]     }, args = future.call.arguments)
[10:18:30.660] }
[10:18:30.660] Lazy evaluation: FALSE
[10:18:30.660] Asynchronous evaluation: FALSE
[10:18:30.660] Local evaluation: TRUE
[10:18:30.660] Environment: R_GlobalEnv
[10:18:30.660] Capture standard output: TRUE
[10:18:30.660] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:30.660] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:30.660] Packages: <none>
[10:18:30.660] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:30.660] Resolved: TRUE
[10:18:30.660] Value: 1.16 KiB of class ‘list’
[10:18:30.660] Early signaling: FALSE
[10:18:30.660] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:30.660] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.661] Chunk #1 of 1 ... DONE
[10:18:30.662] Launching 1 futures (chunks) ... DONE
[10:18:30.662] Resolving 1 futures (chunks) ...
[10:18:30.662] resolve() on list ...
[10:18:30.662]  recursive: 0
[10:18:30.662]  length: 1
[10:18:30.662] 
[10:18:30.662] resolved() for ‘SequentialFuture’ ...
[10:18:30.662] - state: ‘finished’
[10:18:30.662] - run: TRUE
[10:18:30.662] - result: ‘FutureResult’
[10:18:30.663] resolved() for ‘SequentialFuture’ ... done
[10:18:30.663] Future #1
[10:18:30.663] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:30.663] - nx: 1
[10:18:30.663] - relay: TRUE
[10:18:30.663] - stdout: TRUE
[10:18:30.663] - signal: TRUE
[10:18:30.663] - resignal: FALSE
[10:18:30.663] - force: TRUE
[10:18:30.664] - relayed: [n=1] FALSE
[10:18:30.664] - queued futures: [n=1] FALSE
[10:18:30.664]  - until=1
[10:18:30.664]  - relaying element #1
[10:18:30.664] - relayed: [n=1] TRUE
[10:18:30.664] - queued futures: [n=1] TRUE
[10:18:30.664] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:30.664]  length: 0 (resolved future 1)
[10:18:30.664] Relaying remaining futures
[10:18:30.665] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.665] - nx: 1
[10:18:30.665] - relay: TRUE
[10:18:30.665] - stdout: TRUE
[10:18:30.665] - signal: TRUE
[10:18:30.665] - resignal: FALSE
[10:18:30.665] - force: TRUE
[10:18:30.665] - relayed: [n=1] TRUE
[10:18:30.665] - queued futures: [n=1] TRUE
 - flush all
[10:18:30.665] - relayed: [n=1] TRUE
[10:18:30.665] - queued futures: [n=1] TRUE
[10:18:30.665] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.666] resolve() on list ... DONE
[10:18:30.666]  - Number of value chunks collected: 1
[10:18:30.666] Resolving 1 futures (chunks) ... DONE
[10:18:30.666] Reducing values from 1 chunks ...
[10:18:30.666]  - Number of values collected after concatenation: 3
[10:18:30.666]  - Number of values expected: 3
[10:18:30.666] Reducing values from 1 chunks ... DONE
[10:18:30.666] future_lapply() ... DONE
[10:18:30.666] future_by_internal() ... DONE
[10:18:30.669] future_by_internal() ...
[10:18:30.669] future_lapply() ...
[10:18:30.670] Number of chunks: 1
[10:18:30.670] getGlobalsAndPackagesXApply() ...
[10:18:30.670]  - future.globals: TRUE
[10:18:30.670] getGlobalsAndPackages() ...
[10:18:30.670] Searching for globals...
[10:18:30.671] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:30.671] Searching for globals ... DONE
[10:18:30.671] Resolving globals: FALSE
[10:18:30.672] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:30.672] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:30.672] - globals: [1] ‘FUN’
[10:18:30.672] 
[10:18:30.672] getGlobalsAndPackages() ... DONE
[10:18:30.672]  - globals found/used: [n=1] ‘FUN’
[10:18:30.672]  - needed namespaces: [n=0] 
[10:18:30.673] Finding globals ... DONE
[10:18:30.673]  - use_args: TRUE
[10:18:30.673]  - Getting '...' globals ...
[10:18:30.673] resolve() on list ...
[10:18:30.673]  recursive: 0
[10:18:30.673]  length: 1
[10:18:30.673]  elements: ‘...’
[10:18:30.673]  length: 0 (resolved future 1)
[10:18:30.673] resolve() on list ... DONE
[10:18:30.674]    - '...' content: [n=1] ‘digits’
[10:18:30.674] List of 1
[10:18:30.674]  $ ...:List of 1
[10:18:30.674]   ..$ digits: int 2
[10:18:30.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.674]  - attr(*, "where")=List of 1
[10:18:30.674]   ..$ ...:<environment: 0x5584497b2a10> 
[10:18:30.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.674]  - attr(*, "resolved")= logi TRUE
[10:18:30.674]  - attr(*, "total_size")= num NA
[10:18:30.676]  - Getting '...' globals ... DONE
[10:18:30.676] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.677] List of 2
[10:18:30.677]  $ ...future.FUN:function (object, ...)  
[10:18:30.677]  $ ...          :List of 1
[10:18:30.677]   ..$ digits: int 2
[10:18:30.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.677]  - attr(*, "where")=List of 2
[10:18:30.677]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.677]   ..$ ...          :<environment: 0x5584497b2a10> 
[10:18:30.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.677]  - attr(*, "resolved")= logi FALSE
[10:18:30.677]  - attr(*, "total_size")= num 13284
[10:18:30.679] Packages to be attached in all futures: [n=0] 
[10:18:30.680] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.680] Number of futures (= number of chunks): 1
[10:18:30.680] Launching 1 futures (chunks) ...
[10:18:30.680] Chunk #1 of 1 ...
[10:18:30.680]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.680] getGlobalsAndPackages() ...
[10:18:30.680] Searching for globals...
[10:18:30.680] 
[10:18:30.681] Searching for globals ... DONE
[10:18:30.681] - globals: [0] <none>
[10:18:30.681] getGlobalsAndPackages() ... DONE
[10:18:30.681]    + additional globals found: [n=0] 
[10:18:30.681]    + additional namespaces needed: [n=0] 
[10:18:30.681]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:30.681]  - seeds: <none>
[10:18:30.681]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.681] getGlobalsAndPackages() ...
[10:18:30.681] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.681] Resolving globals: FALSE
[10:18:30.682] Tweak future expression to call with '...' arguments ...
[10:18:30.682] {
[10:18:30.682]     do.call(function(...) {
[10:18:30.682]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.682]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.682]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.682]             on.exit(options(oopts), add = TRUE)
[10:18:30.682]         }
[10:18:30.682]         {
[10:18:30.682]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.682]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.682]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.682]             })
[10:18:30.682]         }
[10:18:30.682]     }, args = future.call.arguments)
[10:18:30.682] }
[10:18:30.682] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.682] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.682] 
[10:18:30.682] getGlobalsAndPackages() ... DONE
[10:18:30.683] run() for ‘Future’ ...
[10:18:30.683] - state: ‘created’
[10:18:30.683] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:30.683] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.683] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:30.683]   - Field: ‘label’
[10:18:30.683]   - Field: ‘local’
[10:18:30.684]   - Field: ‘owner’
[10:18:30.684]   - Field: ‘envir’
[10:18:30.684]   - Field: ‘packages’
[10:18:30.684]   - Field: ‘gc’
[10:18:30.684]   - Field: ‘conditions’
[10:18:30.684]   - Field: ‘expr’
[10:18:30.684]   - Field: ‘uuid’
[10:18:30.684]   - Field: ‘seed’
[10:18:30.684]   - Field: ‘version’
[10:18:30.684]   - Field: ‘result’
[10:18:30.684]   - Field: ‘asynchronous’
[10:18:30.685]   - Field: ‘calls’
[10:18:30.685]   - Field: ‘globals’
[10:18:30.685]   - Field: ‘stdout’
[10:18:30.685]   - Field: ‘earlySignal’
[10:18:30.685]   - Field: ‘lazy’
[10:18:30.685]   - Field: ‘state’
[10:18:30.685] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:30.685] - Launch lazy future ...
[10:18:30.685] Packages needed by the future expression (n = 0): <none>
[10:18:30.685] Packages needed by future strategies (n = 0): <none>
[10:18:30.686] {
[10:18:30.686]     {
[10:18:30.686]         {
[10:18:30.686]             ...future.startTime <- base::Sys.time()
[10:18:30.686]             {
[10:18:30.686]                 {
[10:18:30.686]                   {
[10:18:30.686]                     base::local({
[10:18:30.686]                       has_future <- base::requireNamespace("future", 
[10:18:30.686]                         quietly = TRUE)
[10:18:30.686]                       if (has_future) {
[10:18:30.686]                         ns <- base::getNamespace("future")
[10:18:30.686]                         version <- ns[[".package"]][["version"]]
[10:18:30.686]                         if (is.null(version)) 
[10:18:30.686]                           version <- utils::packageVersion("future")
[10:18:30.686]                       }
[10:18:30.686]                       else {
[10:18:30.686]                         version <- NULL
[10:18:30.686]                       }
[10:18:30.686]                       if (!has_future || version < "1.8.0") {
[10:18:30.686]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.686]                           "", base::R.version$version.string), 
[10:18:30.686]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:30.686]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.686]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.686]                             "release", "version")], collapse = " "), 
[10:18:30.686]                           hostname = base::Sys.info()[["nodename"]])
[10:18:30.686]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.686]                           info)
[10:18:30.686]                         info <- base::paste(info, collapse = "; ")
[10:18:30.686]                         if (!has_future) {
[10:18:30.686]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.686]                             info)
[10:18:30.686]                         }
[10:18:30.686]                         else {
[10:18:30.686]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.686]                             info, version)
[10:18:30.686]                         }
[10:18:30.686]                         base::stop(msg)
[10:18:30.686]                       }
[10:18:30.686]                     })
[10:18:30.686]                   }
[10:18:30.686]                   ...future.strategy.old <- future::plan("list")
[10:18:30.686]                   options(future.plan = NULL)
[10:18:30.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.686]                 }
[10:18:30.686]                 ...future.workdir <- getwd()
[10:18:30.686]             }
[10:18:30.686]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.686]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.686]         }
[10:18:30.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:30.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.686]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.686]             base::names(...future.oldOptions))
[10:18:30.686]     }
[10:18:30.686]     if (FALSE) {
[10:18:30.686]     }
[10:18:30.686]     else {
[10:18:30.686]         if (TRUE) {
[10:18:30.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.686]                 open = "w")
[10:18:30.686]         }
[10:18:30.686]         else {
[10:18:30.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.686]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.686]         }
[10:18:30.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.686]             base::sink(type = "output", split = FALSE)
[10:18:30.686]             base::close(...future.stdout)
[10:18:30.686]         }, add = TRUE)
[10:18:30.686]     }
[10:18:30.686]     ...future.frame <- base::sys.nframe()
[10:18:30.686]     ...future.conditions <- base::list()
[10:18:30.686]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.686]     if (FALSE) {
[10:18:30.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.686]     }
[10:18:30.686]     ...future.result <- base::tryCatch({
[10:18:30.686]         base::withCallingHandlers({
[10:18:30.686]             ...future.value <- base::withVisible(base::local({
[10:18:30.686]                 do.call(function(...) {
[10:18:30.686]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.686]                   if (!identical(...future.globals.maxSize.org, 
[10:18:30.686]                     ...future.globals.maxSize)) {
[10:18:30.686]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.686]                     on.exit(options(oopts), add = TRUE)
[10:18:30.686]                   }
[10:18:30.686]                   {
[10:18:30.686]                     lapply(seq_along(...future.elements_ii), 
[10:18:30.686]                       FUN = function(jj) {
[10:18:30.686]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.686]                         ...future.FUN(...future.X_jj, ...)
[10:18:30.686]                       })
[10:18:30.686]                   }
[10:18:30.686]                 }, args = future.call.arguments)
[10:18:30.686]             }))
[10:18:30.686]             future::FutureResult(value = ...future.value$value, 
[10:18:30.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.686]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.686]                     ...future.globalenv.names))
[10:18:30.686]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.686]         }, condition = base::local({
[10:18:30.686]             c <- base::c
[10:18:30.686]             inherits <- base::inherits
[10:18:30.686]             invokeRestart <- base::invokeRestart
[10:18:30.686]             length <- base::length
[10:18:30.686]             list <- base::list
[10:18:30.686]             seq.int <- base::seq.int
[10:18:30.686]             signalCondition <- base::signalCondition
[10:18:30.686]             sys.calls <- base::sys.calls
[10:18:30.686]             `[[` <- base::`[[`
[10:18:30.686]             `+` <- base::`+`
[10:18:30.686]             `<<-` <- base::`<<-`
[10:18:30.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.686]                   3L)]
[10:18:30.686]             }
[10:18:30.686]             function(cond) {
[10:18:30.686]                 is_error <- inherits(cond, "error")
[10:18:30.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.686]                   NULL)
[10:18:30.686]                 if (is_error) {
[10:18:30.686]                   sessionInformation <- function() {
[10:18:30.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.686]                       search = base::search(), system = base::Sys.info())
[10:18:30.686]                   }
[10:18:30.686]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.686]                     cond$call), session = sessionInformation(), 
[10:18:30.686]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.686]                   signalCondition(cond)
[10:18:30.686]                 }
[10:18:30.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:30.686]                 "immediateCondition"))) {
[10:18:30.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.686]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.686]                   if (TRUE && !signal) {
[10:18:30.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.686]                     {
[10:18:30.686]                       inherits <- base::inherits
[10:18:30.686]                       invokeRestart <- base::invokeRestart
[10:18:30.686]                       is.null <- base::is.null
[10:18:30.686]                       muffled <- FALSE
[10:18:30.686]                       if (inherits(cond, "message")) {
[10:18:30.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.686]                         if (muffled) 
[10:18:30.686]                           invokeRestart("muffleMessage")
[10:18:30.686]                       }
[10:18:30.686]                       else if (inherits(cond, "warning")) {
[10:18:30.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.686]                         if (muffled) 
[10:18:30.686]                           invokeRestart("muffleWarning")
[10:18:30.686]                       }
[10:18:30.686]                       else if (inherits(cond, "condition")) {
[10:18:30.686]                         if (!is.null(pattern)) {
[10:18:30.686]                           computeRestarts <- base::computeRestarts
[10:18:30.686]                           grepl <- base::grepl
[10:18:30.686]                           restarts <- computeRestarts(cond)
[10:18:30.686]                           for (restart in restarts) {
[10:18:30.686]                             name <- restart$name
[10:18:30.686]                             if (is.null(name)) 
[10:18:30.686]                               next
[10:18:30.686]                             if (!grepl(pattern, name)) 
[10:18:30.686]                               next
[10:18:30.686]                             invokeRestart(restart)
[10:18:30.686]                             muffled <- TRUE
[10:18:30.686]                             break
[10:18:30.686]                           }
[10:18:30.686]                         }
[10:18:30.686]                       }
[10:18:30.686]                       invisible(muffled)
[10:18:30.686]                     }
[10:18:30.686]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.686]                   }
[10:18:30.686]                 }
[10:18:30.686]                 else {
[10:18:30.686]                   if (TRUE) {
[10:18:30.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.686]                     {
[10:18:30.686]                       inherits <- base::inherits
[10:18:30.686]                       invokeRestart <- base::invokeRestart
[10:18:30.686]                       is.null <- base::is.null
[10:18:30.686]                       muffled <- FALSE
[10:18:30.686]                       if (inherits(cond, "message")) {
[10:18:30.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.686]                         if (muffled) 
[10:18:30.686]                           invokeRestart("muffleMessage")
[10:18:30.686]                       }
[10:18:30.686]                       else if (inherits(cond, "warning")) {
[10:18:30.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.686]                         if (muffled) 
[10:18:30.686]                           invokeRestart("muffleWarning")
[10:18:30.686]                       }
[10:18:30.686]                       else if (inherits(cond, "condition")) {
[10:18:30.686]                         if (!is.null(pattern)) {
[10:18:30.686]                           computeRestarts <- base::computeRestarts
[10:18:30.686]                           grepl <- base::grepl
[10:18:30.686]                           restarts <- computeRestarts(cond)
[10:18:30.686]                           for (restart in restarts) {
[10:18:30.686]                             name <- restart$name
[10:18:30.686]                             if (is.null(name)) 
[10:18:30.686]                               next
[10:18:30.686]                             if (!grepl(pattern, name)) 
[10:18:30.686]                               next
[10:18:30.686]                             invokeRestart(restart)
[10:18:30.686]                             muffled <- TRUE
[10:18:30.686]                             break
[10:18:30.686]                           }
[10:18:30.686]                         }
[10:18:30.686]                       }
[10:18:30.686]                       invisible(muffled)
[10:18:30.686]                     }
[10:18:30.686]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.686]                   }
[10:18:30.686]                 }
[10:18:30.686]             }
[10:18:30.686]         }))
[10:18:30.686]     }, error = function(ex) {
[10:18:30.686]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.686]                 ...future.rng), started = ...future.startTime, 
[10:18:30.686]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.686]             version = "1.8"), class = "FutureResult")
[10:18:30.686]     }, finally = {
[10:18:30.686]         if (!identical(...future.workdir, getwd())) 
[10:18:30.686]             setwd(...future.workdir)
[10:18:30.686]         {
[10:18:30.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.686]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.686]             }
[10:18:30.686]             base::options(...future.oldOptions)
[10:18:30.686]             if (.Platform$OS.type == "windows") {
[10:18:30.686]                 old_names <- names(...future.oldEnvVars)
[10:18:30.686]                 envs <- base::Sys.getenv()
[10:18:30.686]                 names <- names(envs)
[10:18:30.686]                 common <- intersect(names, old_names)
[10:18:30.686]                 added <- setdiff(names, old_names)
[10:18:30.686]                 removed <- setdiff(old_names, names)
[10:18:30.686]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.686]                   envs[common]]
[10:18:30.686]                 NAMES <- toupper(changed)
[10:18:30.686]                 args <- list()
[10:18:30.686]                 for (kk in seq_along(NAMES)) {
[10:18:30.686]                   name <- changed[[kk]]
[10:18:30.686]                   NAME <- NAMES[[kk]]
[10:18:30.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.686]                     next
[10:18:30.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.686]                 }
[10:18:30.686]                 NAMES <- toupper(added)
[10:18:30.686]                 for (kk in seq_along(NAMES)) {
[10:18:30.686]                   name <- added[[kk]]
[10:18:30.686]                   NAME <- NAMES[[kk]]
[10:18:30.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.686]                     next
[10:18:30.686]                   args[[name]] <- ""
[10:18:30.686]                 }
[10:18:30.686]                 NAMES <- toupper(removed)
[10:18:30.686]                 for (kk in seq_along(NAMES)) {
[10:18:30.686]                   name <- removed[[kk]]
[10:18:30.686]                   NAME <- NAMES[[kk]]
[10:18:30.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.686]                     next
[10:18:30.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.686]                 }
[10:18:30.686]                 if (length(args) > 0) 
[10:18:30.686]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.686]             }
[10:18:30.686]             else {
[10:18:30.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.686]             }
[10:18:30.686]             {
[10:18:30.686]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.686]                   0L) {
[10:18:30.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.686]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.686]                   base::options(opts)
[10:18:30.686]                 }
[10:18:30.686]                 {
[10:18:30.686]                   {
[10:18:30.686]                     NULL
[10:18:30.686]                     RNGkind("Mersenne-Twister")
[10:18:30.686]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:30.686]                       inherits = FALSE)
[10:18:30.686]                   }
[10:18:30.686]                   options(future.plan = NULL)
[10:18:30.686]                   if (is.na(NA_character_)) 
[10:18:30.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.686]                     .init = FALSE)
[10:18:30.686]                 }
[10:18:30.686]             }
[10:18:30.686]         }
[10:18:30.686]     })
[10:18:30.686]     if (TRUE) {
[10:18:30.686]         base::sink(type = "output", split = FALSE)
[10:18:30.686]         if (TRUE) {
[10:18:30.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.686]         }
[10:18:30.686]         else {
[10:18:30.686]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.686]         }
[10:18:30.686]         base::close(...future.stdout)
[10:18:30.686]         ...future.stdout <- NULL
[10:18:30.686]     }
[10:18:30.686]     ...future.result$conditions <- ...future.conditions
[10:18:30.686]     ...future.result$finished <- base::Sys.time()
[10:18:30.686]     ...future.result
[10:18:30.686] }
[10:18:30.688] assign_globals() ...
[10:18:30.688] List of 5
[10:18:30.688]  $ ...future.FUN            :function (object, ...)  
[10:18:30.688]  $ future.call.arguments    :List of 1
[10:18:30.688]   ..$ digits: int 2
[10:18:30.688]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.688]  $ ...future.elements_ii    :List of 6
[10:18:30.688]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:18:30.688]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:18:30.688]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:18:30.688]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:18:30.688]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:18:30.688]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:18:30.688]  $ ...future.seeds_ii       : NULL
[10:18:30.688]  $ ...future.globals.maxSize: NULL
[10:18:30.688]  - attr(*, "where")=List of 5
[10:18:30.688]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:30.688]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:30.688]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:30.688]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:30.688]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:30.688]  - attr(*, "resolved")= logi FALSE
[10:18:30.688]  - attr(*, "total_size")= num 13284
[10:18:30.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.688]  - attr(*, "already-done")= logi TRUE
[10:18:30.696] - copied ‘...future.FUN’ to environment
[10:18:30.696] - copied ‘future.call.arguments’ to environment
[10:18:30.696] - copied ‘...future.elements_ii’ to environment
[10:18:30.696] - copied ‘...future.seeds_ii’ to environment
[10:18:30.696] - copied ‘...future.globals.maxSize’ to environment
[10:18:30.696] assign_globals() ... done
[10:18:30.696] plan(): Setting new future strategy stack:
[10:18:30.696] List of future strategies:
[10:18:30.696] 1. sequential:
[10:18:30.696]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.696]    - tweaked: FALSE
[10:18:30.696]    - call: NULL
[10:18:30.697] plan(): nbrOfWorkers() = 1
[10:18:30.698] plan(): Setting new future strategy stack:
[10:18:30.698] List of future strategies:
[10:18:30.698] 1. sequential:
[10:18:30.698]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.698]    - tweaked: FALSE
[10:18:30.698]    - call: plan(strategy)
[10:18:30.699] plan(): nbrOfWorkers() = 1
[10:18:30.699] SequentialFuture started (and completed)
[10:18:30.699] - Launch lazy future ... done
[10:18:30.699] run() for ‘SequentialFuture’ ... done
[10:18:30.699] Created future:
[10:18:30.699] SequentialFuture:
[10:18:30.699] Label: ‘future_by-1’
[10:18:30.699] Expression:
[10:18:30.699] {
[10:18:30.699]     do.call(function(...) {
[10:18:30.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.699]             on.exit(options(oopts), add = TRUE)
[10:18:30.699]         }
[10:18:30.699]         {
[10:18:30.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.699]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.699]             })
[10:18:30.699]         }
[10:18:30.699]     }, args = future.call.arguments)
[10:18:30.699] }
[10:18:30.699] Lazy evaluation: FALSE
[10:18:30.699] Asynchronous evaluation: FALSE
[10:18:30.699] Local evaluation: TRUE
[10:18:30.699] Environment: R_GlobalEnv
[10:18:30.699] Capture standard output: TRUE
[10:18:30.699] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:30.699] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:30.699] Packages: <none>
[10:18:30.699] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:30.699] Resolved: TRUE
[10:18:30.699] Value: 1.27 KiB of class ‘list’
[10:18:30.699] Early signaling: FALSE
[10:18:30.699] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:30.699] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.700] Chunk #1 of 1 ... DONE
[10:18:30.700] Launching 1 futures (chunks) ... DONE
[10:18:30.700] Resolving 1 futures (chunks) ...
[10:18:30.700] resolve() on list ...
[10:18:30.700]  recursive: 0
[10:18:30.701]  length: 1
[10:18:30.701] 
[10:18:30.701] resolved() for ‘SequentialFuture’ ...
[10:18:30.701] - state: ‘finished’
[10:18:30.701] - run: TRUE
[10:18:30.701] - result: ‘FutureResult’
[10:18:30.701] resolved() for ‘SequentialFuture’ ... done
[10:18:30.701] Future #1
[10:18:30.701] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:30.701] - nx: 1
[10:18:30.701] - relay: TRUE
[10:18:30.702] - stdout: TRUE
[10:18:30.702] - signal: TRUE
[10:18:30.702] - resignal: FALSE
[10:18:30.702] - force: TRUE
[10:18:30.702] - relayed: [n=1] FALSE
[10:18:30.702] - queued futures: [n=1] FALSE
[10:18:30.702]  - until=1
[10:18:30.702]  - relaying element #1
[10:18:30.702] - relayed: [n=1] TRUE
[10:18:30.702] - queued futures: [n=1] TRUE
[10:18:30.702] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:30.703]  length: 0 (resolved future 1)
[10:18:30.703] Relaying remaining futures
[10:18:30.703] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.703] - nx: 1
[10:18:30.703] - relay: TRUE
[10:18:30.703] - stdout: TRUE
[10:18:30.703] - signal: TRUE
[10:18:30.703] - resignal: FALSE
[10:18:30.703] - force: TRUE
[10:18:30.703] - relayed: [n=1] TRUE
[10:18:30.703] - queued futures: [n=1] TRUE
 - flush all
[10:18:30.703] - relayed: [n=1] TRUE
[10:18:30.704] - queued futures: [n=1] TRUE
[10:18:30.704] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.704] resolve() on list ... DONE
[10:18:30.704]  - Number of value chunks collected: 1
[10:18:30.704] Resolving 1 futures (chunks) ... DONE
[10:18:30.704] Reducing values from 1 chunks ...
[10:18:30.704]  - Number of values collected after concatenation: 6
[10:18:30.704]  - Number of values expected: 6
[10:18:30.704] Reducing values from 1 chunks ... DONE
[10:18:30.704] future_lapply() ... DONE
[10:18:30.704] future_by_internal() ... DONE
[10:18:30.707] future_by_internal() ...
[10:18:30.708] future_lapply() ...
[10:18:30.709] Number of chunks: 1
[10:18:30.709] getGlobalsAndPackagesXApply() ...
[10:18:30.709]  - future.globals: TRUE
[10:18:30.709] getGlobalsAndPackages() ...
[10:18:30.709] Searching for globals...
[10:18:30.712] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:30.712] Searching for globals ... DONE
[10:18:30.712] Resolving globals: FALSE
[10:18:30.713] The total size of the 1 globals is 762 bytes (762 bytes)
[10:18:30.713] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:18:30.713] - globals: [1] ‘FUN’
[10:18:30.713] - packages: [1] ‘stats’
[10:18:30.713] getGlobalsAndPackages() ... DONE
[10:18:30.713]  - globals found/used: [n=1] ‘FUN’
[10:18:30.713]  - needed namespaces: [n=1] ‘stats’
[10:18:30.714] Finding globals ... DONE
[10:18:30.714]  - use_args: TRUE
[10:18:30.714]  - Getting '...' globals ...
[10:18:30.714] resolve() on list ...
[10:18:30.714]  recursive: 0
[10:18:30.714]  length: 1
[10:18:30.714]  elements: ‘...’
[10:18:30.714]  length: 0 (resolved future 1)
[10:18:30.715] resolve() on list ... DONE
[10:18:30.715]    - '...' content: [n=1] ‘singular.ok’
[10:18:30.715] List of 1
[10:18:30.715]  $ ...:List of 1
[10:18:30.715]   ..$ singular.ok: logi FALSE
[10:18:30.715]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.715]  - attr(*, "where")=List of 1
[10:18:30.715]   ..$ ...:<environment: 0x55844a6c4098> 
[10:18:30.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.715]  - attr(*, "resolved")= logi TRUE
[10:18:30.715]  - attr(*, "total_size")= num NA
[10:18:30.717]  - Getting '...' globals ... DONE
[10:18:30.718] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.718] List of 2
[10:18:30.718]  $ ...future.FUN:function (x, ...)  
[10:18:30.718]  $ ...          :List of 1
[10:18:30.718]   ..$ singular.ok: logi FALSE
[10:18:30.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.718]  - attr(*, "where")=List of 2
[10:18:30.718]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.718]   ..$ ...          :<environment: 0x55844a6c4098> 
[10:18:30.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.718]  - attr(*, "resolved")= logi FALSE
[10:18:30.718]  - attr(*, "total_size")= num 19977
[10:18:30.721] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:30.721] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.721] Number of futures (= number of chunks): 1
[10:18:30.721] Launching 1 futures (chunks) ...
[10:18:30.721] Chunk #1 of 1 ...
[10:18:30.721]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.721] getGlobalsAndPackages() ...
[10:18:30.721] Searching for globals...
[10:18:30.722] 
[10:18:30.722] Searching for globals ... DONE
[10:18:30.722] - globals: [0] <none>
[10:18:30.722] getGlobalsAndPackages() ... DONE
[10:18:30.722]    + additional globals found: [n=0] 
[10:18:30.722]    + additional namespaces needed: [n=0] 
[10:18:30.722]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:30.722]  - seeds: <none>
[10:18:30.723]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.723] getGlobalsAndPackages() ...
[10:18:30.723] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.723] Resolving globals: FALSE
[10:18:30.723] Tweak future expression to call with '...' arguments ...
[10:18:30.723] {
[10:18:30.723]     do.call(function(...) {
[10:18:30.723]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.723]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.723]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.723]             on.exit(options(oopts), add = TRUE)
[10:18:30.723]         }
[10:18:30.723]         {
[10:18:30.723]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.723]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.723]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.723]             })
[10:18:30.723]         }
[10:18:30.723]     }, args = future.call.arguments)
[10:18:30.723] }
[10:18:30.723] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.724] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.724] 
[10:18:30.724] getGlobalsAndPackages() ... DONE
[10:18:30.724] run() for ‘Future’ ...
[10:18:30.724] - state: ‘created’
[10:18:30.724] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:30.725] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.725] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:30.725]   - Field: ‘label’
[10:18:30.725]   - Field: ‘local’
[10:18:30.725]   - Field: ‘owner’
[10:18:30.725]   - Field: ‘envir’
[10:18:30.725]   - Field: ‘packages’
[10:18:30.725]   - Field: ‘gc’
[10:18:30.725]   - Field: ‘conditions’
[10:18:30.725]   - Field: ‘expr’
[10:18:30.725]   - Field: ‘uuid’
[10:18:30.725]   - Field: ‘seed’
[10:18:30.726]   - Field: ‘version’
[10:18:30.726]   - Field: ‘result’
[10:18:30.726]   - Field: ‘asynchronous’
[10:18:30.726]   - Field: ‘calls’
[10:18:30.726]   - Field: ‘globals’
[10:18:30.726]   - Field: ‘stdout’
[10:18:30.726]   - Field: ‘earlySignal’
[10:18:30.726]   - Field: ‘lazy’
[10:18:30.726]   - Field: ‘state’
[10:18:30.726] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:30.726] - Launch lazy future ...
[10:18:30.727] Packages needed by the future expression (n = 1): ‘stats’
[10:18:30.727] Packages needed by future strategies (n = 0): <none>
[10:18:30.727] {
[10:18:30.727]     {
[10:18:30.727]         {
[10:18:30.727]             ...future.startTime <- base::Sys.time()
[10:18:30.727]             {
[10:18:30.727]                 {
[10:18:30.727]                   {
[10:18:30.727]                     {
[10:18:30.727]                       base::local({
[10:18:30.727]                         has_future <- base::requireNamespace("future", 
[10:18:30.727]                           quietly = TRUE)
[10:18:30.727]                         if (has_future) {
[10:18:30.727]                           ns <- base::getNamespace("future")
[10:18:30.727]                           version <- ns[[".package"]][["version"]]
[10:18:30.727]                           if (is.null(version)) 
[10:18:30.727]                             version <- utils::packageVersion("future")
[10:18:30.727]                         }
[10:18:30.727]                         else {
[10:18:30.727]                           version <- NULL
[10:18:30.727]                         }
[10:18:30.727]                         if (!has_future || version < "1.8.0") {
[10:18:30.727]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.727]                             "", base::R.version$version.string), 
[10:18:30.727]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:30.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.727]                               "release", "version")], collapse = " "), 
[10:18:30.727]                             hostname = base::Sys.info()[["nodename"]])
[10:18:30.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.727]                             info)
[10:18:30.727]                           info <- base::paste(info, collapse = "; ")
[10:18:30.727]                           if (!has_future) {
[10:18:30.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.727]                               info)
[10:18:30.727]                           }
[10:18:30.727]                           else {
[10:18:30.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.727]                               info, version)
[10:18:30.727]                           }
[10:18:30.727]                           base::stop(msg)
[10:18:30.727]                         }
[10:18:30.727]                       })
[10:18:30.727]                     }
[10:18:30.727]                     base::local({
[10:18:30.727]                       for (pkg in "stats") {
[10:18:30.727]                         base::loadNamespace(pkg)
[10:18:30.727]                         base::library(pkg, character.only = TRUE)
[10:18:30.727]                       }
[10:18:30.727]                     })
[10:18:30.727]                   }
[10:18:30.727]                   ...future.strategy.old <- future::plan("list")
[10:18:30.727]                   options(future.plan = NULL)
[10:18:30.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.727]                 }
[10:18:30.727]                 ...future.workdir <- getwd()
[10:18:30.727]             }
[10:18:30.727]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.727]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.727]         }
[10:18:30.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.727]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:30.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.727]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.727]             base::names(...future.oldOptions))
[10:18:30.727]     }
[10:18:30.727]     if (FALSE) {
[10:18:30.727]     }
[10:18:30.727]     else {
[10:18:30.727]         if (TRUE) {
[10:18:30.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.727]                 open = "w")
[10:18:30.727]         }
[10:18:30.727]         else {
[10:18:30.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.727]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.727]         }
[10:18:30.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.727]             base::sink(type = "output", split = FALSE)
[10:18:30.727]             base::close(...future.stdout)
[10:18:30.727]         }, add = TRUE)
[10:18:30.727]     }
[10:18:30.727]     ...future.frame <- base::sys.nframe()
[10:18:30.727]     ...future.conditions <- base::list()
[10:18:30.727]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.727]     if (FALSE) {
[10:18:30.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.727]     }
[10:18:30.727]     ...future.result <- base::tryCatch({
[10:18:30.727]         base::withCallingHandlers({
[10:18:30.727]             ...future.value <- base::withVisible(base::local({
[10:18:30.727]                 do.call(function(...) {
[10:18:30.727]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.727]                   if (!identical(...future.globals.maxSize.org, 
[10:18:30.727]                     ...future.globals.maxSize)) {
[10:18:30.727]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.727]                     on.exit(options(oopts), add = TRUE)
[10:18:30.727]                   }
[10:18:30.727]                   {
[10:18:30.727]                     lapply(seq_along(...future.elements_ii), 
[10:18:30.727]                       FUN = function(jj) {
[10:18:30.727]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.727]                         ...future.FUN(...future.X_jj, ...)
[10:18:30.727]                       })
[10:18:30.727]                   }
[10:18:30.727]                 }, args = future.call.arguments)
[10:18:30.727]             }))
[10:18:30.727]             future::FutureResult(value = ...future.value$value, 
[10:18:30.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.727]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.727]                     ...future.globalenv.names))
[10:18:30.727]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.727]         }, condition = base::local({
[10:18:30.727]             c <- base::c
[10:18:30.727]             inherits <- base::inherits
[10:18:30.727]             invokeRestart <- base::invokeRestart
[10:18:30.727]             length <- base::length
[10:18:30.727]             list <- base::list
[10:18:30.727]             seq.int <- base::seq.int
[10:18:30.727]             signalCondition <- base::signalCondition
[10:18:30.727]             sys.calls <- base::sys.calls
[10:18:30.727]             `[[` <- base::`[[`
[10:18:30.727]             `+` <- base::`+`
[10:18:30.727]             `<<-` <- base::`<<-`
[10:18:30.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.727]                   3L)]
[10:18:30.727]             }
[10:18:30.727]             function(cond) {
[10:18:30.727]                 is_error <- inherits(cond, "error")
[10:18:30.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.727]                   NULL)
[10:18:30.727]                 if (is_error) {
[10:18:30.727]                   sessionInformation <- function() {
[10:18:30.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.727]                       search = base::search(), system = base::Sys.info())
[10:18:30.727]                   }
[10:18:30.727]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.727]                     cond$call), session = sessionInformation(), 
[10:18:30.727]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.727]                   signalCondition(cond)
[10:18:30.727]                 }
[10:18:30.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:30.727]                 "immediateCondition"))) {
[10:18:30.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.727]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.727]                   if (TRUE && !signal) {
[10:18:30.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.727]                     {
[10:18:30.727]                       inherits <- base::inherits
[10:18:30.727]                       invokeRestart <- base::invokeRestart
[10:18:30.727]                       is.null <- base::is.null
[10:18:30.727]                       muffled <- FALSE
[10:18:30.727]                       if (inherits(cond, "message")) {
[10:18:30.727]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.727]                         if (muffled) 
[10:18:30.727]                           invokeRestart("muffleMessage")
[10:18:30.727]                       }
[10:18:30.727]                       else if (inherits(cond, "warning")) {
[10:18:30.727]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.727]                         if (muffled) 
[10:18:30.727]                           invokeRestart("muffleWarning")
[10:18:30.727]                       }
[10:18:30.727]                       else if (inherits(cond, "condition")) {
[10:18:30.727]                         if (!is.null(pattern)) {
[10:18:30.727]                           computeRestarts <- base::computeRestarts
[10:18:30.727]                           grepl <- base::grepl
[10:18:30.727]                           restarts <- computeRestarts(cond)
[10:18:30.727]                           for (restart in restarts) {
[10:18:30.727]                             name <- restart$name
[10:18:30.727]                             if (is.null(name)) 
[10:18:30.727]                               next
[10:18:30.727]                             if (!grepl(pattern, name)) 
[10:18:30.727]                               next
[10:18:30.727]                             invokeRestart(restart)
[10:18:30.727]                             muffled <- TRUE
[10:18:30.727]                             break
[10:18:30.727]                           }
[10:18:30.727]                         }
[10:18:30.727]                       }
[10:18:30.727]                       invisible(muffled)
[10:18:30.727]                     }
[10:18:30.727]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.727]                   }
[10:18:30.727]                 }
[10:18:30.727]                 else {
[10:18:30.727]                   if (TRUE) {
[10:18:30.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.727]                     {
[10:18:30.727]                       inherits <- base::inherits
[10:18:30.727]                       invokeRestart <- base::invokeRestart
[10:18:30.727]                       is.null <- base::is.null
[10:18:30.727]                       muffled <- FALSE
[10:18:30.727]                       if (inherits(cond, "message")) {
[10:18:30.727]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.727]                         if (muffled) 
[10:18:30.727]                           invokeRestart("muffleMessage")
[10:18:30.727]                       }
[10:18:30.727]                       else if (inherits(cond, "warning")) {
[10:18:30.727]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.727]                         if (muffled) 
[10:18:30.727]                           invokeRestart("muffleWarning")
[10:18:30.727]                       }
[10:18:30.727]                       else if (inherits(cond, "condition")) {
[10:18:30.727]                         if (!is.null(pattern)) {
[10:18:30.727]                           computeRestarts <- base::computeRestarts
[10:18:30.727]                           grepl <- base::grepl
[10:18:30.727]                           restarts <- computeRestarts(cond)
[10:18:30.727]                           for (restart in restarts) {
[10:18:30.727]                             name <- restart$name
[10:18:30.727]                             if (is.null(name)) 
[10:18:30.727]                               next
[10:18:30.727]                             if (!grepl(pattern, name)) 
[10:18:30.727]                               next
[10:18:30.727]                             invokeRestart(restart)
[10:18:30.727]                             muffled <- TRUE
[10:18:30.727]                             break
[10:18:30.727]                           }
[10:18:30.727]                         }
[10:18:30.727]                       }
[10:18:30.727]                       invisible(muffled)
[10:18:30.727]                     }
[10:18:30.727]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.727]                   }
[10:18:30.727]                 }
[10:18:30.727]             }
[10:18:30.727]         }))
[10:18:30.727]     }, error = function(ex) {
[10:18:30.727]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.727]                 ...future.rng), started = ...future.startTime, 
[10:18:30.727]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.727]             version = "1.8"), class = "FutureResult")
[10:18:30.727]     }, finally = {
[10:18:30.727]         if (!identical(...future.workdir, getwd())) 
[10:18:30.727]             setwd(...future.workdir)
[10:18:30.727]         {
[10:18:30.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.727]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.727]             }
[10:18:30.727]             base::options(...future.oldOptions)
[10:18:30.727]             if (.Platform$OS.type == "windows") {
[10:18:30.727]                 old_names <- names(...future.oldEnvVars)
[10:18:30.727]                 envs <- base::Sys.getenv()
[10:18:30.727]                 names <- names(envs)
[10:18:30.727]                 common <- intersect(names, old_names)
[10:18:30.727]                 added <- setdiff(names, old_names)
[10:18:30.727]                 removed <- setdiff(old_names, names)
[10:18:30.727]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.727]                   envs[common]]
[10:18:30.727]                 NAMES <- toupper(changed)
[10:18:30.727]                 args <- list()
[10:18:30.727]                 for (kk in seq_along(NAMES)) {
[10:18:30.727]                   name <- changed[[kk]]
[10:18:30.727]                   NAME <- NAMES[[kk]]
[10:18:30.727]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.727]                     next
[10:18:30.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.727]                 }
[10:18:30.727]                 NAMES <- toupper(added)
[10:18:30.727]                 for (kk in seq_along(NAMES)) {
[10:18:30.727]                   name <- added[[kk]]
[10:18:30.727]                   NAME <- NAMES[[kk]]
[10:18:30.727]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.727]                     next
[10:18:30.727]                   args[[name]] <- ""
[10:18:30.727]                 }
[10:18:30.727]                 NAMES <- toupper(removed)
[10:18:30.727]                 for (kk in seq_along(NAMES)) {
[10:18:30.727]                   name <- removed[[kk]]
[10:18:30.727]                   NAME <- NAMES[[kk]]
[10:18:30.727]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.727]                     next
[10:18:30.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.727]                 }
[10:18:30.727]                 if (length(args) > 0) 
[10:18:30.727]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.727]             }
[10:18:30.727]             else {
[10:18:30.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.727]             }
[10:18:30.727]             {
[10:18:30.727]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.727]                   0L) {
[10:18:30.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.727]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.727]                   base::options(opts)
[10:18:30.727]                 }
[10:18:30.727]                 {
[10:18:30.727]                   {
[10:18:30.727]                     NULL
[10:18:30.727]                     RNGkind("Mersenne-Twister")
[10:18:30.727]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:30.727]                       inherits = FALSE)
[10:18:30.727]                   }
[10:18:30.727]                   options(future.plan = NULL)
[10:18:30.727]                   if (is.na(NA_character_)) 
[10:18:30.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.727]                     .init = FALSE)
[10:18:30.727]                 }
[10:18:30.727]             }
[10:18:30.727]         }
[10:18:30.727]     })
[10:18:30.727]     if (TRUE) {
[10:18:30.727]         base::sink(type = "output", split = FALSE)
[10:18:30.727]         if (TRUE) {
[10:18:30.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.727]         }
[10:18:30.727]         else {
[10:18:30.727]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.727]         }
[10:18:30.727]         base::close(...future.stdout)
[10:18:30.727]         ...future.stdout <- NULL
[10:18:30.727]     }
[10:18:30.727]     ...future.result$conditions <- ...future.conditions
[10:18:30.727]     ...future.result$finished <- base::Sys.time()
[10:18:30.727]     ...future.result
[10:18:30.727] }
[10:18:30.729] assign_globals() ...
[10:18:30.729] List of 5
[10:18:30.729]  $ ...future.FUN            :function (x, ...)  
[10:18:30.729]  $ future.call.arguments    :List of 1
[10:18:30.729]   ..$ singular.ok: logi FALSE
[10:18:30.729]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.729]  $ ...future.elements_ii    :List of 3
[10:18:30.729]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.729]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:30.729]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.729]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:30.729]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.729]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:30.729]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.729]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:30.729]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.729]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:30.729]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.729]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:30.729]  $ ...future.seeds_ii       : NULL
[10:18:30.729]  $ ...future.globals.maxSize: NULL
[10:18:30.729]  - attr(*, "where")=List of 5
[10:18:30.729]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:30.729]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:30.729]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:30.729]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:30.729]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:30.729]  - attr(*, "resolved")= logi FALSE
[10:18:30.729]  - attr(*, "total_size")= num 19977
[10:18:30.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.729]  - attr(*, "already-done")= logi TRUE
[10:18:30.739] - reassign environment for ‘...future.FUN’
[10:18:30.739] - copied ‘...future.FUN’ to environment
[10:18:30.739] - copied ‘future.call.arguments’ to environment
[10:18:30.739] - copied ‘...future.elements_ii’ to environment
[10:18:30.739] - copied ‘...future.seeds_ii’ to environment
[10:18:30.740] - copied ‘...future.globals.maxSize’ to environment
[10:18:30.740] assign_globals() ... done
[10:18:30.740] plan(): Setting new future strategy stack:
[10:18:30.740] List of future strategies:
[10:18:30.740] 1. sequential:
[10:18:30.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.740]    - tweaked: FALSE
[10:18:30.740]    - call: NULL
[10:18:30.741] plan(): nbrOfWorkers() = 1
[10:18:30.743] plan(): Setting new future strategy stack:
[10:18:30.743] List of future strategies:
[10:18:30.743] 1. sequential:
[10:18:30.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.743]    - tweaked: FALSE
[10:18:30.743]    - call: plan(strategy)
[10:18:30.744] plan(): nbrOfWorkers() = 1
[10:18:30.744] SequentialFuture started (and completed)
[10:18:30.744] - Launch lazy future ... done
[10:18:30.744] run() for ‘SequentialFuture’ ... done
[10:18:30.744] Created future:
[10:18:30.744] SequentialFuture:
[10:18:30.744] Label: ‘future_by-1’
[10:18:30.744] Expression:
[10:18:30.744] {
[10:18:30.744]     do.call(function(...) {
[10:18:30.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.744]             on.exit(options(oopts), add = TRUE)
[10:18:30.744]         }
[10:18:30.744]         {
[10:18:30.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.744]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.744]             })
[10:18:30.744]         }
[10:18:30.744]     }, args = future.call.arguments)
[10:18:30.744] }
[10:18:30.744] Lazy evaluation: FALSE
[10:18:30.744] Asynchronous evaluation: FALSE
[10:18:30.744] Local evaluation: TRUE
[10:18:30.744] Environment: R_GlobalEnv
[10:18:30.744] Capture standard output: TRUE
[10:18:30.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:30.744] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:30.744] Packages: 1 packages (‘stats’)
[10:18:30.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:30.744] Resolved: TRUE
[10:18:30.744] Value: 77.05 KiB of class ‘list’
[10:18:30.744] Early signaling: FALSE
[10:18:30.744] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:30.744] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.746] Chunk #1 of 1 ... DONE
[10:18:30.746] Launching 1 futures (chunks) ... DONE
[10:18:30.746] Resolving 1 futures (chunks) ...
[10:18:30.746] resolve() on list ...
[10:18:30.746]  recursive: 0
[10:18:30.746]  length: 1
[10:18:30.746] 
[10:18:30.746] resolved() for ‘SequentialFuture’ ...
[10:18:30.746] - state: ‘finished’
[10:18:30.746] - run: TRUE
[10:18:30.747] - result: ‘FutureResult’
[10:18:30.747] resolved() for ‘SequentialFuture’ ... done
[10:18:30.747] Future #1
[10:18:30.747] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:30.747] - nx: 1
[10:18:30.747] - relay: TRUE
[10:18:30.747] - stdout: TRUE
[10:18:30.747] - signal: TRUE
[10:18:30.747] - resignal: FALSE
[10:18:30.747] - force: TRUE
[10:18:30.747] - relayed: [n=1] FALSE
[10:18:30.747] - queued futures: [n=1] FALSE
[10:18:30.748]  - until=1
[10:18:30.748]  - relaying element #1
[10:18:30.748] - relayed: [n=1] TRUE
[10:18:30.748] - queued futures: [n=1] TRUE
[10:18:30.748] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:30.748]  length: 0 (resolved future 1)
[10:18:30.748] Relaying remaining futures
[10:18:30.748] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.748] - nx: 1
[10:18:30.748] - relay: TRUE
[10:18:30.748] - stdout: TRUE
[10:18:30.749] - signal: TRUE
[10:18:30.749] - resignal: FALSE
[10:18:30.749] - force: TRUE
[10:18:30.749] - relayed: [n=1] TRUE
[10:18:30.749] - queued futures: [n=1] TRUE
 - flush all
[10:18:30.749] - relayed: [n=1] TRUE
[10:18:30.749] - queued futures: [n=1] TRUE
[10:18:30.749] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.749] resolve() on list ... DONE
[10:18:30.749]  - Number of value chunks collected: 1
[10:18:30.749] Resolving 1 futures (chunks) ... DONE
[10:18:30.750] Reducing values from 1 chunks ...
[10:18:30.750]  - Number of values collected after concatenation: 3
[10:18:30.750]  - Number of values expected: 3
[10:18:30.750] Reducing values from 1 chunks ... DONE
[10:18:30.750] future_lapply() ... DONE
[10:18:30.750] future_by_internal() ... DONE
[10:18:30.755] future_by_internal() ...
[10:18:30.756] future_lapply() ...
[10:18:30.756] Number of chunks: 1
[10:18:30.757] getGlobalsAndPackagesXApply() ...
[10:18:30.757]  - future.globals: TRUE
[10:18:30.757] getGlobalsAndPackages() ...
[10:18:30.757] Searching for globals...
[10:18:30.758] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:30.759] Searching for globals ... DONE
[10:18:30.759] Resolving globals: FALSE
[10:18:30.759] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:18:30.759] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:18:30.760] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:30.760] - packages: [1] ‘stats’
[10:18:30.760] getGlobalsAndPackages() ... DONE
[10:18:30.760]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:30.760]  - needed namespaces: [n=1] ‘stats’
[10:18:30.760] Finding globals ... DONE
[10:18:30.760]  - use_args: TRUE
[10:18:30.760]  - Getting '...' globals ...
[10:18:30.761] resolve() on list ...
[10:18:30.761]  recursive: 0
[10:18:30.761]  length: 1
[10:18:30.761]  elements: ‘...’
[10:18:30.761]  length: 0 (resolved future 1)
[10:18:30.761] resolve() on list ... DONE
[10:18:30.761]    - '...' content: [n=0] 
[10:18:30.761] List of 1
[10:18:30.761]  $ ...: list()
[10:18:30.761]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.761]  - attr(*, "where")=List of 1
[10:18:30.761]   ..$ ...:<environment: 0x558448bbdd30> 
[10:18:30.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.761]  - attr(*, "resolved")= logi TRUE
[10:18:30.761]  - attr(*, "total_size")= num NA
[10:18:30.764]  - Getting '...' globals ... DONE
[10:18:30.764] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:18:30.764] List of 4
[10:18:30.764]  $ ...future.FUN:function (x)  
[10:18:30.764]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:30.764]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:30.764]  $ ...          : list()
[10:18:30.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.764]  - attr(*, "where")=List of 4
[10:18:30.764]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.764]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:18:30.764]   ..$ wool         :<environment: R_EmptyEnv> 
[10:18:30.764]   ..$ ...          :<environment: 0x558448bbdd30> 
[10:18:30.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.764]  - attr(*, "resolved")= logi FALSE
[10:18:30.764]  - attr(*, "total_size")= num 18867
[10:18:30.767] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:30.768] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.768] Number of futures (= number of chunks): 1
[10:18:30.768] Launching 1 futures (chunks) ...
[10:18:30.768] Chunk #1 of 1 ...
[10:18:30.768]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.768] getGlobalsAndPackages() ...
[10:18:30.768] Searching for globals...
[10:18:30.769] 
[10:18:30.769] Searching for globals ... DONE
[10:18:30.769] - globals: [0] <none>
[10:18:30.769] getGlobalsAndPackages() ... DONE
[10:18:30.769]    + additional globals found: [n=0] 
[10:18:30.769]    + additional namespaces needed: [n=0] 
[10:18:30.769]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:30.769]  - seeds: <none>
[10:18:30.769]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.769] getGlobalsAndPackages() ...
[10:18:30.770] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.770] Resolving globals: FALSE
[10:18:30.770] Tweak future expression to call with '...' arguments ...
[10:18:30.770] {
[10:18:30.770]     do.call(function(...) {
[10:18:30.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.770]             on.exit(options(oopts), add = TRUE)
[10:18:30.770]         }
[10:18:30.770]         {
[10:18:30.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.770]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.770]             })
[10:18:30.770]         }
[10:18:30.770]     }, args = future.call.arguments)
[10:18:30.770] }
[10:18:30.770] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.771] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.771] 
[10:18:30.771] getGlobalsAndPackages() ... DONE
[10:18:30.771] run() for ‘Future’ ...
[10:18:30.771] - state: ‘created’
[10:18:30.771] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:30.771] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.772] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:30.772]   - Field: ‘label’
[10:18:30.772]   - Field: ‘local’
[10:18:30.772]   - Field: ‘owner’
[10:18:30.772]   - Field: ‘envir’
[10:18:30.772]   - Field: ‘packages’
[10:18:30.773]   - Field: ‘gc’
[10:18:30.774]   - Field: ‘conditions’
[10:18:30.774]   - Field: ‘expr’
[10:18:30.774]   - Field: ‘uuid’
[10:18:30.774]   - Field: ‘seed’
[10:18:30.774]   - Field: ‘version’
[10:18:30.774]   - Field: ‘result’
[10:18:30.774]   - Field: ‘asynchronous’
[10:18:30.774]   - Field: ‘calls’
[10:18:30.774]   - Field: ‘globals’
[10:18:30.774]   - Field: ‘stdout’
[10:18:30.774]   - Field: ‘earlySignal’
[10:18:30.775]   - Field: ‘lazy’
[10:18:30.775]   - Field: ‘state’
[10:18:30.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:30.775] - Launch lazy future ...
[10:18:30.775] Packages needed by the future expression (n = 1): ‘stats’
[10:18:30.775] Packages needed by future strategies (n = 0): <none>
[10:18:30.776] {
[10:18:30.776]     {
[10:18:30.776]         {
[10:18:30.776]             ...future.startTime <- base::Sys.time()
[10:18:30.776]             {
[10:18:30.776]                 {
[10:18:30.776]                   {
[10:18:30.776]                     {
[10:18:30.776]                       base::local({
[10:18:30.776]                         has_future <- base::requireNamespace("future", 
[10:18:30.776]                           quietly = TRUE)
[10:18:30.776]                         if (has_future) {
[10:18:30.776]                           ns <- base::getNamespace("future")
[10:18:30.776]                           version <- ns[[".package"]][["version"]]
[10:18:30.776]                           if (is.null(version)) 
[10:18:30.776]                             version <- utils::packageVersion("future")
[10:18:30.776]                         }
[10:18:30.776]                         else {
[10:18:30.776]                           version <- NULL
[10:18:30.776]                         }
[10:18:30.776]                         if (!has_future || version < "1.8.0") {
[10:18:30.776]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.776]                             "", base::R.version$version.string), 
[10:18:30.776]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:30.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.776]                               "release", "version")], collapse = " "), 
[10:18:30.776]                             hostname = base::Sys.info()[["nodename"]])
[10:18:30.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.776]                             info)
[10:18:30.776]                           info <- base::paste(info, collapse = "; ")
[10:18:30.776]                           if (!has_future) {
[10:18:30.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.776]                               info)
[10:18:30.776]                           }
[10:18:30.776]                           else {
[10:18:30.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.776]                               info, version)
[10:18:30.776]                           }
[10:18:30.776]                           base::stop(msg)
[10:18:30.776]                         }
[10:18:30.776]                       })
[10:18:30.776]                     }
[10:18:30.776]                     base::local({
[10:18:30.776]                       for (pkg in "stats") {
[10:18:30.776]                         base::loadNamespace(pkg)
[10:18:30.776]                         base::library(pkg, character.only = TRUE)
[10:18:30.776]                       }
[10:18:30.776]                     })
[10:18:30.776]                   }
[10:18:30.776]                   ...future.strategy.old <- future::plan("list")
[10:18:30.776]                   options(future.plan = NULL)
[10:18:30.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.776]                 }
[10:18:30.776]                 ...future.workdir <- getwd()
[10:18:30.776]             }
[10:18:30.776]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.776]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.776]         }
[10:18:30.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:30.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.776]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.776]             base::names(...future.oldOptions))
[10:18:30.776]     }
[10:18:30.776]     if (FALSE) {
[10:18:30.776]     }
[10:18:30.776]     else {
[10:18:30.776]         if (TRUE) {
[10:18:30.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.776]                 open = "w")
[10:18:30.776]         }
[10:18:30.776]         else {
[10:18:30.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.776]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.776]         }
[10:18:30.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.776]             base::sink(type = "output", split = FALSE)
[10:18:30.776]             base::close(...future.stdout)
[10:18:30.776]         }, add = TRUE)
[10:18:30.776]     }
[10:18:30.776]     ...future.frame <- base::sys.nframe()
[10:18:30.776]     ...future.conditions <- base::list()
[10:18:30.776]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.776]     if (FALSE) {
[10:18:30.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.776]     }
[10:18:30.776]     ...future.result <- base::tryCatch({
[10:18:30.776]         base::withCallingHandlers({
[10:18:30.776]             ...future.value <- base::withVisible(base::local({
[10:18:30.776]                 do.call(function(...) {
[10:18:30.776]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.776]                   if (!identical(...future.globals.maxSize.org, 
[10:18:30.776]                     ...future.globals.maxSize)) {
[10:18:30.776]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.776]                     on.exit(options(oopts), add = TRUE)
[10:18:30.776]                   }
[10:18:30.776]                   {
[10:18:30.776]                     lapply(seq_along(...future.elements_ii), 
[10:18:30.776]                       FUN = function(jj) {
[10:18:30.776]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.776]                         ...future.FUN(...future.X_jj, ...)
[10:18:30.776]                       })
[10:18:30.776]                   }
[10:18:30.776]                 }, args = future.call.arguments)
[10:18:30.776]             }))
[10:18:30.776]             future::FutureResult(value = ...future.value$value, 
[10:18:30.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.776]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.776]                     ...future.globalenv.names))
[10:18:30.776]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.776]         }, condition = base::local({
[10:18:30.776]             c <- base::c
[10:18:30.776]             inherits <- base::inherits
[10:18:30.776]             invokeRestart <- base::invokeRestart
[10:18:30.776]             length <- base::length
[10:18:30.776]             list <- base::list
[10:18:30.776]             seq.int <- base::seq.int
[10:18:30.776]             signalCondition <- base::signalCondition
[10:18:30.776]             sys.calls <- base::sys.calls
[10:18:30.776]             `[[` <- base::`[[`
[10:18:30.776]             `+` <- base::`+`
[10:18:30.776]             `<<-` <- base::`<<-`
[10:18:30.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.776]                   3L)]
[10:18:30.776]             }
[10:18:30.776]             function(cond) {
[10:18:30.776]                 is_error <- inherits(cond, "error")
[10:18:30.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.776]                   NULL)
[10:18:30.776]                 if (is_error) {
[10:18:30.776]                   sessionInformation <- function() {
[10:18:30.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.776]                       search = base::search(), system = base::Sys.info())
[10:18:30.776]                   }
[10:18:30.776]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.776]                     cond$call), session = sessionInformation(), 
[10:18:30.776]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.776]                   signalCondition(cond)
[10:18:30.776]                 }
[10:18:30.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:30.776]                 "immediateCondition"))) {
[10:18:30.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.776]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.776]                   if (TRUE && !signal) {
[10:18:30.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.776]                     {
[10:18:30.776]                       inherits <- base::inherits
[10:18:30.776]                       invokeRestart <- base::invokeRestart
[10:18:30.776]                       is.null <- base::is.null
[10:18:30.776]                       muffled <- FALSE
[10:18:30.776]                       if (inherits(cond, "message")) {
[10:18:30.776]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.776]                         if (muffled) 
[10:18:30.776]                           invokeRestart("muffleMessage")
[10:18:30.776]                       }
[10:18:30.776]                       else if (inherits(cond, "warning")) {
[10:18:30.776]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.776]                         if (muffled) 
[10:18:30.776]                           invokeRestart("muffleWarning")
[10:18:30.776]                       }
[10:18:30.776]                       else if (inherits(cond, "condition")) {
[10:18:30.776]                         if (!is.null(pattern)) {
[10:18:30.776]                           computeRestarts <- base::computeRestarts
[10:18:30.776]                           grepl <- base::grepl
[10:18:30.776]                           restarts <- computeRestarts(cond)
[10:18:30.776]                           for (restart in restarts) {
[10:18:30.776]                             name <- restart$name
[10:18:30.776]                             if (is.null(name)) 
[10:18:30.776]                               next
[10:18:30.776]                             if (!grepl(pattern, name)) 
[10:18:30.776]                               next
[10:18:30.776]                             invokeRestart(restart)
[10:18:30.776]                             muffled <- TRUE
[10:18:30.776]                             break
[10:18:30.776]                           }
[10:18:30.776]                         }
[10:18:30.776]                       }
[10:18:30.776]                       invisible(muffled)
[10:18:30.776]                     }
[10:18:30.776]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.776]                   }
[10:18:30.776]                 }
[10:18:30.776]                 else {
[10:18:30.776]                   if (TRUE) {
[10:18:30.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.776]                     {
[10:18:30.776]                       inherits <- base::inherits
[10:18:30.776]                       invokeRestart <- base::invokeRestart
[10:18:30.776]                       is.null <- base::is.null
[10:18:30.776]                       muffled <- FALSE
[10:18:30.776]                       if (inherits(cond, "message")) {
[10:18:30.776]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.776]                         if (muffled) 
[10:18:30.776]                           invokeRestart("muffleMessage")
[10:18:30.776]                       }
[10:18:30.776]                       else if (inherits(cond, "warning")) {
[10:18:30.776]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.776]                         if (muffled) 
[10:18:30.776]                           invokeRestart("muffleWarning")
[10:18:30.776]                       }
[10:18:30.776]                       else if (inherits(cond, "condition")) {
[10:18:30.776]                         if (!is.null(pattern)) {
[10:18:30.776]                           computeRestarts <- base::computeRestarts
[10:18:30.776]                           grepl <- base::grepl
[10:18:30.776]                           restarts <- computeRestarts(cond)
[10:18:30.776]                           for (restart in restarts) {
[10:18:30.776]                             name <- restart$name
[10:18:30.776]                             if (is.null(name)) 
[10:18:30.776]                               next
[10:18:30.776]                             if (!grepl(pattern, name)) 
[10:18:30.776]                               next
[10:18:30.776]                             invokeRestart(restart)
[10:18:30.776]                             muffled <- TRUE
[10:18:30.776]                             break
[10:18:30.776]                           }
[10:18:30.776]                         }
[10:18:30.776]                       }
[10:18:30.776]                       invisible(muffled)
[10:18:30.776]                     }
[10:18:30.776]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.776]                   }
[10:18:30.776]                 }
[10:18:30.776]             }
[10:18:30.776]         }))
[10:18:30.776]     }, error = function(ex) {
[10:18:30.776]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.776]                 ...future.rng), started = ...future.startTime, 
[10:18:30.776]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.776]             version = "1.8"), class = "FutureResult")
[10:18:30.776]     }, finally = {
[10:18:30.776]         if (!identical(...future.workdir, getwd())) 
[10:18:30.776]             setwd(...future.workdir)
[10:18:30.776]         {
[10:18:30.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.776]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.776]             }
[10:18:30.776]             base::options(...future.oldOptions)
[10:18:30.776]             if (.Platform$OS.type == "windows") {
[10:18:30.776]                 old_names <- names(...future.oldEnvVars)
[10:18:30.776]                 envs <- base::Sys.getenv()
[10:18:30.776]                 names <- names(envs)
[10:18:30.776]                 common <- intersect(names, old_names)
[10:18:30.776]                 added <- setdiff(names, old_names)
[10:18:30.776]                 removed <- setdiff(old_names, names)
[10:18:30.776]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.776]                   envs[common]]
[10:18:30.776]                 NAMES <- toupper(changed)
[10:18:30.776]                 args <- list()
[10:18:30.776]                 for (kk in seq_along(NAMES)) {
[10:18:30.776]                   name <- changed[[kk]]
[10:18:30.776]                   NAME <- NAMES[[kk]]
[10:18:30.776]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.776]                     next
[10:18:30.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.776]                 }
[10:18:30.776]                 NAMES <- toupper(added)
[10:18:30.776]                 for (kk in seq_along(NAMES)) {
[10:18:30.776]                   name <- added[[kk]]
[10:18:30.776]                   NAME <- NAMES[[kk]]
[10:18:30.776]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.776]                     next
[10:18:30.776]                   args[[name]] <- ""
[10:18:30.776]                 }
[10:18:30.776]                 NAMES <- toupper(removed)
[10:18:30.776]                 for (kk in seq_along(NAMES)) {
[10:18:30.776]                   name <- removed[[kk]]
[10:18:30.776]                   NAME <- NAMES[[kk]]
[10:18:30.776]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.776]                     next
[10:18:30.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.776]                 }
[10:18:30.776]                 if (length(args) > 0) 
[10:18:30.776]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.776]             }
[10:18:30.776]             else {
[10:18:30.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.776]             }
[10:18:30.776]             {
[10:18:30.776]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.776]                   0L) {
[10:18:30.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.776]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.776]                   base::options(opts)
[10:18:30.776]                 }
[10:18:30.776]                 {
[10:18:30.776]                   {
[10:18:30.776]                     NULL
[10:18:30.776]                     RNGkind("Mersenne-Twister")
[10:18:30.776]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:30.776]                       inherits = FALSE)
[10:18:30.776]                   }
[10:18:30.776]                   options(future.plan = NULL)
[10:18:30.776]                   if (is.na(NA_character_)) 
[10:18:30.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.776]                     .init = FALSE)
[10:18:30.776]                 }
[10:18:30.776]             }
[10:18:30.776]         }
[10:18:30.776]     })
[10:18:30.776]     if (TRUE) {
[10:18:30.776]         base::sink(type = "output", split = FALSE)
[10:18:30.776]         if (TRUE) {
[10:18:30.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.776]         }
[10:18:30.776]         else {
[10:18:30.776]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.776]         }
[10:18:30.776]         base::close(...future.stdout)
[10:18:30.776]         ...future.stdout <- NULL
[10:18:30.776]     }
[10:18:30.776]     ...future.result$conditions <- ...future.conditions
[10:18:30.776]     ...future.result$finished <- base::Sys.time()
[10:18:30.776]     ...future.result
[10:18:30.776] }
[10:18:30.777] assign_globals() ...
[10:18:30.778] List of 7
[10:18:30.778]  $ ...future.FUN            :function (x)  
[10:18:30.778]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:30.778]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:30.778]  $ future.call.arguments    : list()
[10:18:30.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.778]  $ ...future.elements_ii    :List of 3
[10:18:30.778]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.778]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:30.778]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.778]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:30.778]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.778]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:30.778]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.778]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:30.778]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.778]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:30.778]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.778]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:30.778]  $ ...future.seeds_ii       : NULL
[10:18:30.778]  $ ...future.globals.maxSize: NULL
[10:18:30.778]  - attr(*, "where")=List of 7
[10:18:30.778]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:30.778]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:18:30.778]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:18:30.778]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:30.778]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:30.778]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:30.778]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:30.778]  - attr(*, "resolved")= logi FALSE
[10:18:30.778]  - attr(*, "total_size")= num 18867
[10:18:30.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.778]  - attr(*, "already-done")= logi TRUE
[10:18:30.787] - reassign environment for ‘...future.FUN’
[10:18:30.787] - copied ‘...future.FUN’ to environment
[10:18:30.787] - copied ‘breaks’ to environment
[10:18:30.787] - copied ‘wool’ to environment
[10:18:30.787] - copied ‘future.call.arguments’ to environment
[10:18:30.787] - copied ‘...future.elements_ii’ to environment
[10:18:30.787] - copied ‘...future.seeds_ii’ to environment
[10:18:30.787] - copied ‘...future.globals.maxSize’ to environment
[10:18:30.787] assign_globals() ... done
[10:18:30.788] plan(): Setting new future strategy stack:
[10:18:30.788] List of future strategies:
[10:18:30.788] 1. sequential:
[10:18:30.788]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.788]    - tweaked: FALSE
[10:18:30.788]    - call: NULL
[10:18:30.788] plan(): nbrOfWorkers() = 1
[10:18:30.791] plan(): Setting new future strategy stack:
[10:18:30.791] List of future strategies:
[10:18:30.791] 1. sequential:
[10:18:30.791]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.791]    - tweaked: FALSE
[10:18:30.791]    - call: plan(strategy)
[10:18:30.792] plan(): nbrOfWorkers() = 1
[10:18:30.792] SequentialFuture started (and completed)
[10:18:30.792] - Launch lazy future ... done
[10:18:30.792] run() for ‘SequentialFuture’ ... done
[10:18:30.792] Created future:
[10:18:30.792] SequentialFuture:
[10:18:30.792] Label: ‘future_by-1’
[10:18:30.792] Expression:
[10:18:30.792] {
[10:18:30.792]     do.call(function(...) {
[10:18:30.792]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.792]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.792]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.792]             on.exit(options(oopts), add = TRUE)
[10:18:30.792]         }
[10:18:30.792]         {
[10:18:30.792]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.792]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.792]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.792]             })
[10:18:30.792]         }
[10:18:30.792]     }, args = future.call.arguments)
[10:18:30.792] }
[10:18:30.792] Lazy evaluation: FALSE
[10:18:30.792] Asynchronous evaluation: FALSE
[10:18:30.792] Local evaluation: TRUE
[10:18:30.792] Environment: 0x558448e0a840
[10:18:30.792] Capture standard output: TRUE
[10:18:30.792] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:30.792] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[10:18:30.792] Packages: 1 packages (‘stats’)
[10:18:30.792] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:30.792] Resolved: TRUE
[10:18:30.792] Value: 78.42 KiB of class ‘list’
[10:18:30.792] Early signaling: FALSE
[10:18:30.792] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:30.792] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.794] Chunk #1 of 1 ... DONE
[10:18:30.794] Launching 1 futures (chunks) ... DONE
[10:18:30.794] Resolving 1 futures (chunks) ...
[10:18:30.794] resolve() on list ...
[10:18:30.794]  recursive: 0
[10:18:30.796]  length: 1
[10:18:30.796] 
[10:18:30.796] resolved() for ‘SequentialFuture’ ...
[10:18:30.796] - state: ‘finished’
[10:18:30.796] - run: TRUE
[10:18:30.796] - result: ‘FutureResult’
[10:18:30.796] resolved() for ‘SequentialFuture’ ... done
[10:18:30.796] Future #1
[10:18:30.797] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:30.797] - nx: 1
[10:18:30.797] - relay: TRUE
[10:18:30.797] - stdout: TRUE
[10:18:30.797] - signal: TRUE
[10:18:30.797] - resignal: FALSE
[10:18:30.797] - force: TRUE
[10:18:30.797] - relayed: [n=1] FALSE
[10:18:30.797] - queued futures: [n=1] FALSE
[10:18:30.797]  - until=1
[10:18:30.797]  - relaying element #1
[10:18:30.798] - relayed: [n=1] TRUE
[10:18:30.798] - queued futures: [n=1] TRUE
[10:18:30.798] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:30.798]  length: 0 (resolved future 1)
[10:18:30.798] Relaying remaining futures
[10:18:30.798] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.798] - nx: 1
[10:18:30.798] - relay: TRUE
[10:18:30.798] - stdout: TRUE
[10:18:30.798] - signal: TRUE
[10:18:30.798] - resignal: FALSE
[10:18:30.798] - force: TRUE
[10:18:30.799] - relayed: [n=1] TRUE
[10:18:30.799] - queued futures: [n=1] TRUE
 - flush all
[10:18:30.799] - relayed: [n=1] TRUE
[10:18:30.799] - queued futures: [n=1] TRUE
[10:18:30.799] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.799] resolve() on list ... DONE
[10:18:30.799]  - Number of value chunks collected: 1
[10:18:30.799] Resolving 1 futures (chunks) ... DONE
[10:18:30.799] Reducing values from 1 chunks ...
[10:18:30.799]  - Number of values collected after concatenation: 3
[10:18:30.799]  - Number of values expected: 3
[10:18:30.800] Reducing values from 1 chunks ... DONE
[10:18:30.800] future_lapply() ... DONE
[10:18:30.800] future_by_internal() ... DONE
[10:18:30.800] future_by_internal() ...
[10:18:30.800] future_lapply() ...
[10:18:30.801] Number of chunks: 1
[10:18:30.801] getGlobalsAndPackagesXApply() ...
[10:18:30.801]  - future.globals: TRUE
[10:18:30.801] getGlobalsAndPackages() ...
[10:18:30.801] Searching for globals...
[10:18:30.802] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:30.802] Searching for globals ... DONE
[10:18:30.803] Resolving globals: FALSE
[10:18:30.803] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:30.803] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:30.803] - globals: [1] ‘FUN’
[10:18:30.803] 
[10:18:30.804] getGlobalsAndPackages() ... DONE
[10:18:30.804]  - globals found/used: [n=1] ‘FUN’
[10:18:30.804]  - needed namespaces: [n=0] 
[10:18:30.804] Finding globals ... DONE
[10:18:30.804]  - use_args: TRUE
[10:18:30.804]  - Getting '...' globals ...
[10:18:30.804] resolve() on list ...
[10:18:30.804]  recursive: 0
[10:18:30.804]  length: 1
[10:18:30.805]  elements: ‘...’
[10:18:30.805]  length: 0 (resolved future 1)
[10:18:30.805] resolve() on list ... DONE
[10:18:30.805]    - '...' content: [n=0] 
[10:18:30.805] List of 1
[10:18:30.805]  $ ...: list()
[10:18:30.805]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.805]  - attr(*, "where")=List of 1
[10:18:30.805]   ..$ ...:<environment: 0x558447fd2f60> 
[10:18:30.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.805]  - attr(*, "resolved")= logi TRUE
[10:18:30.805]  - attr(*, "total_size")= num NA
[10:18:30.807]  - Getting '...' globals ... DONE
[10:18:30.807] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.807] List of 2
[10:18:30.807]  $ ...future.FUN:function (object, ...)  
[10:18:30.807]  $ ...          : list()
[10:18:30.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.807]  - attr(*, "where")=List of 2
[10:18:30.807]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.807]   ..$ ...          :<environment: 0x558447fd2f60> 
[10:18:30.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.807]  - attr(*, "resolved")= logi FALSE
[10:18:30.807]  - attr(*, "total_size")= num 18709
[10:18:30.810] Packages to be attached in all futures: [n=0] 
[10:18:30.810] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.810] Number of futures (= number of chunks): 1
[10:18:30.810] Launching 1 futures (chunks) ...
[10:18:30.810] Chunk #1 of 1 ...
[10:18:30.811]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.811] getGlobalsAndPackages() ...
[10:18:30.811] Searching for globals...
[10:18:30.811] 
[10:18:30.811] Searching for globals ... DONE
[10:18:30.811] - globals: [0] <none>
[10:18:30.812] getGlobalsAndPackages() ... DONE
[10:18:30.812]    + additional globals found: [n=0] 
[10:18:30.812]    + additional namespaces needed: [n=0] 
[10:18:30.812]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:30.812]  - seeds: <none>
[10:18:30.812]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.812] getGlobalsAndPackages() ...
[10:18:30.812] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.812] Resolving globals: FALSE
[10:18:30.812] Tweak future expression to call with '...' arguments ...
[10:18:30.812] {
[10:18:30.812]     do.call(function(...) {
[10:18:30.812]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.812]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.812]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.812]             on.exit(options(oopts), add = TRUE)
[10:18:30.812]         }
[10:18:30.812]         {
[10:18:30.812]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.812]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.812]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.812]             })
[10:18:30.812]         }
[10:18:30.812]     }, args = future.call.arguments)
[10:18:30.812] }
[10:18:30.813] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.813] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.813] 
[10:18:30.813] getGlobalsAndPackages() ... DONE
[10:18:30.813] run() for ‘Future’ ...
[10:18:30.814] - state: ‘created’
[10:18:30.814] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:30.814] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.814] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:30.814]   - Field: ‘label’
[10:18:30.814]   - Field: ‘local’
[10:18:30.814]   - Field: ‘owner’
[10:18:30.814]   - Field: ‘envir’
[10:18:30.816]   - Field: ‘packages’
[10:18:30.816]   - Field: ‘gc’
[10:18:30.816]   - Field: ‘conditions’
[10:18:30.816]   - Field: ‘expr’
[10:18:30.816]   - Field: ‘uuid’
[10:18:30.816]   - Field: ‘seed’
[10:18:30.817]   - Field: ‘version’
[10:18:30.817]   - Field: ‘result’
[10:18:30.817]   - Field: ‘asynchronous’
[10:18:30.817]   - Field: ‘calls’
[10:18:30.817]   - Field: ‘globals’
[10:18:30.817]   - Field: ‘stdout’
[10:18:30.817]   - Field: ‘earlySignal’
[10:18:30.817]   - Field: ‘lazy’
[10:18:30.817]   - Field: ‘state’
[10:18:30.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:30.817] - Launch lazy future ...
[10:18:30.818] Packages needed by the future expression (n = 0): <none>
[10:18:30.818] Packages needed by future strategies (n = 0): <none>
[10:18:30.818] {
[10:18:30.818]     {
[10:18:30.818]         {
[10:18:30.818]             ...future.startTime <- base::Sys.time()
[10:18:30.818]             {
[10:18:30.818]                 {
[10:18:30.818]                   {
[10:18:30.818]                     base::local({
[10:18:30.818]                       has_future <- base::requireNamespace("future", 
[10:18:30.818]                         quietly = TRUE)
[10:18:30.818]                       if (has_future) {
[10:18:30.818]                         ns <- base::getNamespace("future")
[10:18:30.818]                         version <- ns[[".package"]][["version"]]
[10:18:30.818]                         if (is.null(version)) 
[10:18:30.818]                           version <- utils::packageVersion("future")
[10:18:30.818]                       }
[10:18:30.818]                       else {
[10:18:30.818]                         version <- NULL
[10:18:30.818]                       }
[10:18:30.818]                       if (!has_future || version < "1.8.0") {
[10:18:30.818]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.818]                           "", base::R.version$version.string), 
[10:18:30.818]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:30.818]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.818]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.818]                             "release", "version")], collapse = " "), 
[10:18:30.818]                           hostname = base::Sys.info()[["nodename"]])
[10:18:30.818]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.818]                           info)
[10:18:30.818]                         info <- base::paste(info, collapse = "; ")
[10:18:30.818]                         if (!has_future) {
[10:18:30.818]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.818]                             info)
[10:18:30.818]                         }
[10:18:30.818]                         else {
[10:18:30.818]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.818]                             info, version)
[10:18:30.818]                         }
[10:18:30.818]                         base::stop(msg)
[10:18:30.818]                       }
[10:18:30.818]                     })
[10:18:30.818]                   }
[10:18:30.818]                   ...future.strategy.old <- future::plan("list")
[10:18:30.818]                   options(future.plan = NULL)
[10:18:30.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.818]                 }
[10:18:30.818]                 ...future.workdir <- getwd()
[10:18:30.818]             }
[10:18:30.818]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.818]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.818]         }
[10:18:30.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.818]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:30.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.818]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.818]             base::names(...future.oldOptions))
[10:18:30.818]     }
[10:18:30.818]     if (FALSE) {
[10:18:30.818]     }
[10:18:30.818]     else {
[10:18:30.818]         if (TRUE) {
[10:18:30.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.818]                 open = "w")
[10:18:30.818]         }
[10:18:30.818]         else {
[10:18:30.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.818]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.818]         }
[10:18:30.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.818]             base::sink(type = "output", split = FALSE)
[10:18:30.818]             base::close(...future.stdout)
[10:18:30.818]         }, add = TRUE)
[10:18:30.818]     }
[10:18:30.818]     ...future.frame <- base::sys.nframe()
[10:18:30.818]     ...future.conditions <- base::list()
[10:18:30.818]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.818]     if (FALSE) {
[10:18:30.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.818]     }
[10:18:30.818]     ...future.result <- base::tryCatch({
[10:18:30.818]         base::withCallingHandlers({
[10:18:30.818]             ...future.value <- base::withVisible(base::local({
[10:18:30.818]                 do.call(function(...) {
[10:18:30.818]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.818]                   if (!identical(...future.globals.maxSize.org, 
[10:18:30.818]                     ...future.globals.maxSize)) {
[10:18:30.818]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.818]                     on.exit(options(oopts), add = TRUE)
[10:18:30.818]                   }
[10:18:30.818]                   {
[10:18:30.818]                     lapply(seq_along(...future.elements_ii), 
[10:18:30.818]                       FUN = function(jj) {
[10:18:30.818]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.818]                         ...future.FUN(...future.X_jj, ...)
[10:18:30.818]                       })
[10:18:30.818]                   }
[10:18:30.818]                 }, args = future.call.arguments)
[10:18:30.818]             }))
[10:18:30.818]             future::FutureResult(value = ...future.value$value, 
[10:18:30.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.818]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.818]                     ...future.globalenv.names))
[10:18:30.818]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.818]         }, condition = base::local({
[10:18:30.818]             c <- base::c
[10:18:30.818]             inherits <- base::inherits
[10:18:30.818]             invokeRestart <- base::invokeRestart
[10:18:30.818]             length <- base::length
[10:18:30.818]             list <- base::list
[10:18:30.818]             seq.int <- base::seq.int
[10:18:30.818]             signalCondition <- base::signalCondition
[10:18:30.818]             sys.calls <- base::sys.calls
[10:18:30.818]             `[[` <- base::`[[`
[10:18:30.818]             `+` <- base::`+`
[10:18:30.818]             `<<-` <- base::`<<-`
[10:18:30.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.818]                   3L)]
[10:18:30.818]             }
[10:18:30.818]             function(cond) {
[10:18:30.818]                 is_error <- inherits(cond, "error")
[10:18:30.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.818]                   NULL)
[10:18:30.818]                 if (is_error) {
[10:18:30.818]                   sessionInformation <- function() {
[10:18:30.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.818]                       search = base::search(), system = base::Sys.info())
[10:18:30.818]                   }
[10:18:30.818]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.818]                     cond$call), session = sessionInformation(), 
[10:18:30.818]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.818]                   signalCondition(cond)
[10:18:30.818]                 }
[10:18:30.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:30.818]                 "immediateCondition"))) {
[10:18:30.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.818]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.818]                   if (TRUE && !signal) {
[10:18:30.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.818]                     {
[10:18:30.818]                       inherits <- base::inherits
[10:18:30.818]                       invokeRestart <- base::invokeRestart
[10:18:30.818]                       is.null <- base::is.null
[10:18:30.818]                       muffled <- FALSE
[10:18:30.818]                       if (inherits(cond, "message")) {
[10:18:30.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.818]                         if (muffled) 
[10:18:30.818]                           invokeRestart("muffleMessage")
[10:18:30.818]                       }
[10:18:30.818]                       else if (inherits(cond, "warning")) {
[10:18:30.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.818]                         if (muffled) 
[10:18:30.818]                           invokeRestart("muffleWarning")
[10:18:30.818]                       }
[10:18:30.818]                       else if (inherits(cond, "condition")) {
[10:18:30.818]                         if (!is.null(pattern)) {
[10:18:30.818]                           computeRestarts <- base::computeRestarts
[10:18:30.818]                           grepl <- base::grepl
[10:18:30.818]                           restarts <- computeRestarts(cond)
[10:18:30.818]                           for (restart in restarts) {
[10:18:30.818]                             name <- restart$name
[10:18:30.818]                             if (is.null(name)) 
[10:18:30.818]                               next
[10:18:30.818]                             if (!grepl(pattern, name)) 
[10:18:30.818]                               next
[10:18:30.818]                             invokeRestart(restart)
[10:18:30.818]                             muffled <- TRUE
[10:18:30.818]                             break
[10:18:30.818]                           }
[10:18:30.818]                         }
[10:18:30.818]                       }
[10:18:30.818]                       invisible(muffled)
[10:18:30.818]                     }
[10:18:30.818]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.818]                   }
[10:18:30.818]                 }
[10:18:30.818]                 else {
[10:18:30.818]                   if (TRUE) {
[10:18:30.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.818]                     {
[10:18:30.818]                       inherits <- base::inherits
[10:18:30.818]                       invokeRestart <- base::invokeRestart
[10:18:30.818]                       is.null <- base::is.null
[10:18:30.818]                       muffled <- FALSE
[10:18:30.818]                       if (inherits(cond, "message")) {
[10:18:30.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.818]                         if (muffled) 
[10:18:30.818]                           invokeRestart("muffleMessage")
[10:18:30.818]                       }
[10:18:30.818]                       else if (inherits(cond, "warning")) {
[10:18:30.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.818]                         if (muffled) 
[10:18:30.818]                           invokeRestart("muffleWarning")
[10:18:30.818]                       }
[10:18:30.818]                       else if (inherits(cond, "condition")) {
[10:18:30.818]                         if (!is.null(pattern)) {
[10:18:30.818]                           computeRestarts <- base::computeRestarts
[10:18:30.818]                           grepl <- base::grepl
[10:18:30.818]                           restarts <- computeRestarts(cond)
[10:18:30.818]                           for (restart in restarts) {
[10:18:30.818]                             name <- restart$name
[10:18:30.818]                             if (is.null(name)) 
[10:18:30.818]                               next
[10:18:30.818]                             if (!grepl(pattern, name)) 
[10:18:30.818]                               next
[10:18:30.818]                             invokeRestart(restart)
[10:18:30.818]                             muffled <- TRUE
[10:18:30.818]                             break
[10:18:30.818]                           }
[10:18:30.818]                         }
[10:18:30.818]                       }
[10:18:30.818]                       invisible(muffled)
[10:18:30.818]                     }
[10:18:30.818]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.818]                   }
[10:18:30.818]                 }
[10:18:30.818]             }
[10:18:30.818]         }))
[10:18:30.818]     }, error = function(ex) {
[10:18:30.818]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.818]                 ...future.rng), started = ...future.startTime, 
[10:18:30.818]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.818]             version = "1.8"), class = "FutureResult")
[10:18:30.818]     }, finally = {
[10:18:30.818]         if (!identical(...future.workdir, getwd())) 
[10:18:30.818]             setwd(...future.workdir)
[10:18:30.818]         {
[10:18:30.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.818]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.818]             }
[10:18:30.818]             base::options(...future.oldOptions)
[10:18:30.818]             if (.Platform$OS.type == "windows") {
[10:18:30.818]                 old_names <- names(...future.oldEnvVars)
[10:18:30.818]                 envs <- base::Sys.getenv()
[10:18:30.818]                 names <- names(envs)
[10:18:30.818]                 common <- intersect(names, old_names)
[10:18:30.818]                 added <- setdiff(names, old_names)
[10:18:30.818]                 removed <- setdiff(old_names, names)
[10:18:30.818]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.818]                   envs[common]]
[10:18:30.818]                 NAMES <- toupper(changed)
[10:18:30.818]                 args <- list()
[10:18:30.818]                 for (kk in seq_along(NAMES)) {
[10:18:30.818]                   name <- changed[[kk]]
[10:18:30.818]                   NAME <- NAMES[[kk]]
[10:18:30.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.818]                     next
[10:18:30.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.818]                 }
[10:18:30.818]                 NAMES <- toupper(added)
[10:18:30.818]                 for (kk in seq_along(NAMES)) {
[10:18:30.818]                   name <- added[[kk]]
[10:18:30.818]                   NAME <- NAMES[[kk]]
[10:18:30.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.818]                     next
[10:18:30.818]                   args[[name]] <- ""
[10:18:30.818]                 }
[10:18:30.818]                 NAMES <- toupper(removed)
[10:18:30.818]                 for (kk in seq_along(NAMES)) {
[10:18:30.818]                   name <- removed[[kk]]
[10:18:30.818]                   NAME <- NAMES[[kk]]
[10:18:30.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.818]                     next
[10:18:30.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.818]                 }
[10:18:30.818]                 if (length(args) > 0) 
[10:18:30.818]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.818]             }
[10:18:30.818]             else {
[10:18:30.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.818]             }
[10:18:30.818]             {
[10:18:30.818]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.818]                   0L) {
[10:18:30.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.818]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.818]                   base::options(opts)
[10:18:30.818]                 }
[10:18:30.818]                 {
[10:18:30.818]                   {
[10:18:30.818]                     NULL
[10:18:30.818]                     RNGkind("Mersenne-Twister")
[10:18:30.818]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:30.818]                       inherits = FALSE)
[10:18:30.818]                   }
[10:18:30.818]                   options(future.plan = NULL)
[10:18:30.818]                   if (is.na(NA_character_)) 
[10:18:30.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.818]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.818]                     .init = FALSE)
[10:18:30.818]                 }
[10:18:30.818]             }
[10:18:30.818]         }
[10:18:30.818]     })
[10:18:30.818]     if (TRUE) {
[10:18:30.818]         base::sink(type = "output", split = FALSE)
[10:18:30.818]         if (TRUE) {
[10:18:30.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.818]         }
[10:18:30.818]         else {
[10:18:30.818]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.818]         }
[10:18:30.818]         base::close(...future.stdout)
[10:18:30.818]         ...future.stdout <- NULL
[10:18:30.818]     }
[10:18:30.818]     ...future.result$conditions <- ...future.conditions
[10:18:30.818]     ...future.result$finished <- base::Sys.time()
[10:18:30.818]     ...future.result
[10:18:30.818] }
[10:18:30.820] assign_globals() ...
[10:18:30.820] List of 5
[10:18:30.820]  $ ...future.FUN            :function (object, ...)  
[10:18:30.820]  $ future.call.arguments    : list()
[10:18:30.820]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.820]  $ ...future.elements_ii    :List of 3
[10:18:30.820]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.820]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:30.820]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.820]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:30.820]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.820]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:30.820]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.820]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:30.820]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.820]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:30.820]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.820]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:30.820]  $ ...future.seeds_ii       : NULL
[10:18:30.820]  $ ...future.globals.maxSize: NULL
[10:18:30.820]  - attr(*, "where")=List of 5
[10:18:30.820]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:30.820]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:30.820]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:30.820]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:30.820]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:30.820]  - attr(*, "resolved")= logi FALSE
[10:18:30.820]  - attr(*, "total_size")= num 18709
[10:18:30.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.820]  - attr(*, "already-done")= logi TRUE
[10:18:30.828] - copied ‘...future.FUN’ to environment
[10:18:30.828] - copied ‘future.call.arguments’ to environment
[10:18:30.828] - copied ‘...future.elements_ii’ to environment
[10:18:30.828] - copied ‘...future.seeds_ii’ to environment
[10:18:30.828] - copied ‘...future.globals.maxSize’ to environment
[10:18:30.829] assign_globals() ... done
[10:18:30.829] plan(): Setting new future strategy stack:
[10:18:30.829] List of future strategies:
[10:18:30.829] 1. sequential:
[10:18:30.829]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.829]    - tweaked: FALSE
[10:18:30.829]    - call: NULL
[10:18:30.829] plan(): nbrOfWorkers() = 1
[10:18:30.832] plan(): Setting new future strategy stack:
[10:18:30.832] List of future strategies:
[10:18:30.832] 1. sequential:
[10:18:30.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.832]    - tweaked: FALSE
[10:18:30.832]    - call: plan(strategy)
[10:18:30.832] plan(): nbrOfWorkers() = 1
[10:18:30.832] SequentialFuture started (and completed)
[10:18:30.832] - Launch lazy future ... done
[10:18:30.832] run() for ‘SequentialFuture’ ... done
[10:18:30.833] Created future:
[10:18:30.833] SequentialFuture:
[10:18:30.833] Label: ‘future_by-1’
[10:18:30.833] Expression:
[10:18:30.833] {
[10:18:30.833]     do.call(function(...) {
[10:18:30.833]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.833]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.833]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.833]             on.exit(options(oopts), add = TRUE)
[10:18:30.833]         }
[10:18:30.833]         {
[10:18:30.833]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.833]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.833]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.833]             })
[10:18:30.833]         }
[10:18:30.833]     }, args = future.call.arguments)
[10:18:30.833] }
[10:18:30.833] Lazy evaluation: FALSE
[10:18:30.833] Asynchronous evaluation: FALSE
[10:18:30.833] Local evaluation: TRUE
[10:18:30.833] Environment: 0x55844809a280
[10:18:30.833] Capture standard output: TRUE
[10:18:30.833] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:30.833] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:30.833] Packages: <none>
[10:18:30.833] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:30.833] Resolved: TRUE
[10:18:30.833] Value: 1.39 KiB of class ‘list’
[10:18:30.833] Early signaling: FALSE
[10:18:30.833] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:30.833] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.834] Chunk #1 of 1 ... DONE
[10:18:30.834] Launching 1 futures (chunks) ... DONE
[10:18:30.834] Resolving 1 futures (chunks) ...
[10:18:30.834] resolve() on list ...
[10:18:30.834]  recursive: 0
[10:18:30.834]  length: 1
[10:18:30.834] 
[10:18:30.834] resolved() for ‘SequentialFuture’ ...
[10:18:30.834] - state: ‘finished’
[10:18:30.834] - run: TRUE
[10:18:30.834] - result: ‘FutureResult’
[10:18:30.835] resolved() for ‘SequentialFuture’ ... done
[10:18:30.835] Future #1
[10:18:30.835] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:30.835] - nx: 1
[10:18:30.835] - relay: TRUE
[10:18:30.835] - stdout: TRUE
[10:18:30.835] - signal: TRUE
[10:18:30.835] - resignal: FALSE
[10:18:30.835] - force: TRUE
[10:18:30.835] - relayed: [n=1] FALSE
[10:18:30.835] - queued futures: [n=1] FALSE
[10:18:30.835]  - until=1
[10:18:30.836]  - relaying element #1
[10:18:30.836] - relayed: [n=1] TRUE
[10:18:30.836] - queued futures: [n=1] TRUE
[10:18:30.836] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:30.836]  length: 0 (resolved future 1)
[10:18:30.836] Relaying remaining futures
[10:18:30.838] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.838] - nx: 1
[10:18:30.838] - relay: TRUE
[10:18:30.838] - stdout: TRUE
[10:18:30.838] - signal: TRUE
[10:18:30.838] - resignal: FALSE
[10:18:30.838] - force: TRUE
[10:18:30.838] - relayed: [n=1] TRUE
[10:18:30.838] - queued futures: [n=1] TRUE
 - flush all
[10:18:30.838] - relayed: [n=1] TRUE
[10:18:30.839] - queued futures: [n=1] TRUE
[10:18:30.839] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.839] resolve() on list ... DONE
[10:18:30.839]  - Number of value chunks collected: 1
[10:18:30.839] Resolving 1 futures (chunks) ... DONE
[10:18:30.839] Reducing values from 1 chunks ...
[10:18:30.839]  - Number of values collected after concatenation: 3
[10:18:30.839]  - Number of values expected: 3
[10:18:30.839] Reducing values from 1 chunks ... DONE
[10:18:30.839] future_lapply() ... DONE
[10:18:30.839] future_by_internal() ... DONE
[10:18:30.841] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:18:30.842] future_lapply() ...
[10:18:30.842] Number of chunks: 1
[10:18:30.843] getGlobalsAndPackagesXApply() ...
[10:18:30.843]  - future.globals: TRUE
[10:18:30.843] getGlobalsAndPackages() ...
[10:18:30.843] Searching for globals...
[10:18:30.844] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:30.844] Searching for globals ... DONE
[10:18:30.844] Resolving globals: FALSE
[10:18:30.844] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:30.845] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:30.845] - globals: [1] ‘FUN’
[10:18:30.845] 
[10:18:30.845] getGlobalsAndPackages() ... DONE
[10:18:30.845]  - globals found/used: [n=1] ‘FUN’
[10:18:30.845]  - needed namespaces: [n=0] 
[10:18:30.845] Finding globals ... DONE
[10:18:30.845]  - use_args: TRUE
[10:18:30.846]  - Getting '...' globals ...
[10:18:30.846] resolve() on list ...
[10:18:30.846]  recursive: 0
[10:18:30.846]  length: 1
[10:18:30.846]  elements: ‘...’
[10:18:30.846]  length: 0 (resolved future 1)
[10:18:30.846] resolve() on list ... DONE
[10:18:30.846]    - '...' content: [n=0] 
[10:18:30.846] List of 1
[10:18:30.846]  $ ...: list()
[10:18:30.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.846]  - attr(*, "where")=List of 1
[10:18:30.846]   ..$ ...:<environment: 0x558448070290> 
[10:18:30.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.846]  - attr(*, "resolved")= logi TRUE
[10:18:30.846]  - attr(*, "total_size")= num NA
[10:18:30.849]  - Getting '...' globals ... DONE
[10:18:30.849] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.849] List of 2
[10:18:30.849]  $ ...future.FUN:function (object, ...)  
[10:18:30.849]  $ ...          : list()
[10:18:30.849]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.849]  - attr(*, "where")=List of 2
[10:18:30.849]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.849]   ..$ ...          :<environment: 0x558448070290> 
[10:18:30.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.849]  - attr(*, "resolved")= logi FALSE
[10:18:30.849]  - attr(*, "total_size")= num 18647
[10:18:30.852] Packages to be attached in all futures: [n=0] 
[10:18:30.852] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.852] Number of futures (= number of chunks): 1
[10:18:30.852] Launching 1 futures (chunks) ...
[10:18:30.852] Chunk #1 of 1 ...
[10:18:30.852]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.852] getGlobalsAndPackages() ...
[10:18:30.852] Searching for globals...
[10:18:30.853] 
[10:18:30.853] Searching for globals ... DONE
[10:18:30.853] - globals: [0] <none>
[10:18:30.853] getGlobalsAndPackages() ... DONE
[10:18:30.853]    + additional globals found: [n=0] 
[10:18:30.853]    + additional namespaces needed: [n=0] 
[10:18:30.853]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:30.854]  - seeds: <none>
[10:18:30.854]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.854] getGlobalsAndPackages() ...
[10:18:30.854] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.854] Resolving globals: FALSE
[10:18:30.854] Tweak future expression to call with '...' arguments ...
[10:18:30.854] {
[10:18:30.854]     do.call(function(...) {
[10:18:30.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.854]             on.exit(options(oopts), add = TRUE)
[10:18:30.854]         }
[10:18:30.854]         {
[10:18:30.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.854]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.854]             })
[10:18:30.854]         }
[10:18:30.854]     }, args = future.call.arguments)
[10:18:30.854] }
[10:18:30.854] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.855] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.855] 
[10:18:30.855] getGlobalsAndPackages() ... DONE
[10:18:30.855] run() for ‘Future’ ...
[10:18:30.855] - state: ‘created’
[10:18:30.855] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:30.856] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:30.856]   - Field: ‘label’
[10:18:30.856]   - Field: ‘local’
[10:18:30.856]   - Field: ‘owner’
[10:18:30.856]   - Field: ‘envir’
[10:18:30.856]   - Field: ‘packages’
[10:18:30.858]   - Field: ‘gc’
[10:18:30.858]   - Field: ‘conditions’
[10:18:30.858]   - Field: ‘expr’
[10:18:30.858]   - Field: ‘uuid’
[10:18:30.858]   - Field: ‘seed’
[10:18:30.859]   - Field: ‘version’
[10:18:30.859]   - Field: ‘result’
[10:18:30.859]   - Field: ‘asynchronous’
[10:18:30.859]   - Field: ‘calls’
[10:18:30.859]   - Field: ‘globals’
[10:18:30.859]   - Field: ‘stdout’
[10:18:30.859]   - Field: ‘earlySignal’
[10:18:30.859]   - Field: ‘lazy’
[10:18:30.859]   - Field: ‘state’
[10:18:30.859] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:30.859] - Launch lazy future ...
[10:18:30.860] Packages needed by the future expression (n = 0): <none>
[10:18:30.860] Packages needed by future strategies (n = 0): <none>
[10:18:30.860] {
[10:18:30.860]     {
[10:18:30.860]         {
[10:18:30.860]             ...future.startTime <- base::Sys.time()
[10:18:30.860]             {
[10:18:30.860]                 {
[10:18:30.860]                   {
[10:18:30.860]                     base::local({
[10:18:30.860]                       has_future <- base::requireNamespace("future", 
[10:18:30.860]                         quietly = TRUE)
[10:18:30.860]                       if (has_future) {
[10:18:30.860]                         ns <- base::getNamespace("future")
[10:18:30.860]                         version <- ns[[".package"]][["version"]]
[10:18:30.860]                         if (is.null(version)) 
[10:18:30.860]                           version <- utils::packageVersion("future")
[10:18:30.860]                       }
[10:18:30.860]                       else {
[10:18:30.860]                         version <- NULL
[10:18:30.860]                       }
[10:18:30.860]                       if (!has_future || version < "1.8.0") {
[10:18:30.860]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.860]                           "", base::R.version$version.string), 
[10:18:30.860]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:30.860]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.860]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.860]                             "release", "version")], collapse = " "), 
[10:18:30.860]                           hostname = base::Sys.info()[["nodename"]])
[10:18:30.860]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.860]                           info)
[10:18:30.860]                         info <- base::paste(info, collapse = "; ")
[10:18:30.860]                         if (!has_future) {
[10:18:30.860]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.860]                             info)
[10:18:30.860]                         }
[10:18:30.860]                         else {
[10:18:30.860]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.860]                             info, version)
[10:18:30.860]                         }
[10:18:30.860]                         base::stop(msg)
[10:18:30.860]                       }
[10:18:30.860]                     })
[10:18:30.860]                   }
[10:18:30.860]                   ...future.strategy.old <- future::plan("list")
[10:18:30.860]                   options(future.plan = NULL)
[10:18:30.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.860]                 }
[10:18:30.860]                 ...future.workdir <- getwd()
[10:18:30.860]             }
[10:18:30.860]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.860]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.860]         }
[10:18:30.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.860]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:30.860]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.860]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.860]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.860]             base::names(...future.oldOptions))
[10:18:30.860]     }
[10:18:30.860]     if (FALSE) {
[10:18:30.860]     }
[10:18:30.860]     else {
[10:18:30.860]         if (TRUE) {
[10:18:30.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.860]                 open = "w")
[10:18:30.860]         }
[10:18:30.860]         else {
[10:18:30.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.860]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.860]         }
[10:18:30.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.860]             base::sink(type = "output", split = FALSE)
[10:18:30.860]             base::close(...future.stdout)
[10:18:30.860]         }, add = TRUE)
[10:18:30.860]     }
[10:18:30.860]     ...future.frame <- base::sys.nframe()
[10:18:30.860]     ...future.conditions <- base::list()
[10:18:30.860]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.860]     if (FALSE) {
[10:18:30.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.860]     }
[10:18:30.860]     ...future.result <- base::tryCatch({
[10:18:30.860]         base::withCallingHandlers({
[10:18:30.860]             ...future.value <- base::withVisible(base::local({
[10:18:30.860]                 do.call(function(...) {
[10:18:30.860]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.860]                   if (!identical(...future.globals.maxSize.org, 
[10:18:30.860]                     ...future.globals.maxSize)) {
[10:18:30.860]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.860]                     on.exit(options(oopts), add = TRUE)
[10:18:30.860]                   }
[10:18:30.860]                   {
[10:18:30.860]                     lapply(seq_along(...future.elements_ii), 
[10:18:30.860]                       FUN = function(jj) {
[10:18:30.860]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.860]                         ...future.FUN(...future.X_jj, ...)
[10:18:30.860]                       })
[10:18:30.860]                   }
[10:18:30.860]                 }, args = future.call.arguments)
[10:18:30.860]             }))
[10:18:30.860]             future::FutureResult(value = ...future.value$value, 
[10:18:30.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.860]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.860]                     ...future.globalenv.names))
[10:18:30.860]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.860]         }, condition = base::local({
[10:18:30.860]             c <- base::c
[10:18:30.860]             inherits <- base::inherits
[10:18:30.860]             invokeRestart <- base::invokeRestart
[10:18:30.860]             length <- base::length
[10:18:30.860]             list <- base::list
[10:18:30.860]             seq.int <- base::seq.int
[10:18:30.860]             signalCondition <- base::signalCondition
[10:18:30.860]             sys.calls <- base::sys.calls
[10:18:30.860]             `[[` <- base::`[[`
[10:18:30.860]             `+` <- base::`+`
[10:18:30.860]             `<<-` <- base::`<<-`
[10:18:30.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.860]                   3L)]
[10:18:30.860]             }
[10:18:30.860]             function(cond) {
[10:18:30.860]                 is_error <- inherits(cond, "error")
[10:18:30.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.860]                   NULL)
[10:18:30.860]                 if (is_error) {
[10:18:30.860]                   sessionInformation <- function() {
[10:18:30.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.860]                       search = base::search(), system = base::Sys.info())
[10:18:30.860]                   }
[10:18:30.860]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.860]                     cond$call), session = sessionInformation(), 
[10:18:30.860]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.860]                   signalCondition(cond)
[10:18:30.860]                 }
[10:18:30.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:30.860]                 "immediateCondition"))) {
[10:18:30.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.860]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.860]                   if (TRUE && !signal) {
[10:18:30.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.860]                     {
[10:18:30.860]                       inherits <- base::inherits
[10:18:30.860]                       invokeRestart <- base::invokeRestart
[10:18:30.860]                       is.null <- base::is.null
[10:18:30.860]                       muffled <- FALSE
[10:18:30.860]                       if (inherits(cond, "message")) {
[10:18:30.860]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.860]                         if (muffled) 
[10:18:30.860]                           invokeRestart("muffleMessage")
[10:18:30.860]                       }
[10:18:30.860]                       else if (inherits(cond, "warning")) {
[10:18:30.860]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.860]                         if (muffled) 
[10:18:30.860]                           invokeRestart("muffleWarning")
[10:18:30.860]                       }
[10:18:30.860]                       else if (inherits(cond, "condition")) {
[10:18:30.860]                         if (!is.null(pattern)) {
[10:18:30.860]                           computeRestarts <- base::computeRestarts
[10:18:30.860]                           grepl <- base::grepl
[10:18:30.860]                           restarts <- computeRestarts(cond)
[10:18:30.860]                           for (restart in restarts) {
[10:18:30.860]                             name <- restart$name
[10:18:30.860]                             if (is.null(name)) 
[10:18:30.860]                               next
[10:18:30.860]                             if (!grepl(pattern, name)) 
[10:18:30.860]                               next
[10:18:30.860]                             invokeRestart(restart)
[10:18:30.860]                             muffled <- TRUE
[10:18:30.860]                             break
[10:18:30.860]                           }
[10:18:30.860]                         }
[10:18:30.860]                       }
[10:18:30.860]                       invisible(muffled)
[10:18:30.860]                     }
[10:18:30.860]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.860]                   }
[10:18:30.860]                 }
[10:18:30.860]                 else {
[10:18:30.860]                   if (TRUE) {
[10:18:30.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.860]                     {
[10:18:30.860]                       inherits <- base::inherits
[10:18:30.860]                       invokeRestart <- base::invokeRestart
[10:18:30.860]                       is.null <- base::is.null
[10:18:30.860]                       muffled <- FALSE
[10:18:30.860]                       if (inherits(cond, "message")) {
[10:18:30.860]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.860]                         if (muffled) 
[10:18:30.860]                           invokeRestart("muffleMessage")
[10:18:30.860]                       }
[10:18:30.860]                       else if (inherits(cond, "warning")) {
[10:18:30.860]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.860]                         if (muffled) 
[10:18:30.860]                           invokeRestart("muffleWarning")
[10:18:30.860]                       }
[10:18:30.860]                       else if (inherits(cond, "condition")) {
[10:18:30.860]                         if (!is.null(pattern)) {
[10:18:30.860]                           computeRestarts <- base::computeRestarts
[10:18:30.860]                           grepl <- base::grepl
[10:18:30.860]                           restarts <- computeRestarts(cond)
[10:18:30.860]                           for (restart in restarts) {
[10:18:30.860]                             name <- restart$name
[10:18:30.860]                             if (is.null(name)) 
[10:18:30.860]                               next
[10:18:30.860]                             if (!grepl(pattern, name)) 
[10:18:30.860]                               next
[10:18:30.860]                             invokeRestart(restart)
[10:18:30.860]                             muffled <- TRUE
[10:18:30.860]                             break
[10:18:30.860]                           }
[10:18:30.860]                         }
[10:18:30.860]                       }
[10:18:30.860]                       invisible(muffled)
[10:18:30.860]                     }
[10:18:30.860]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.860]                   }
[10:18:30.860]                 }
[10:18:30.860]             }
[10:18:30.860]         }))
[10:18:30.860]     }, error = function(ex) {
[10:18:30.860]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.860]                 ...future.rng), started = ...future.startTime, 
[10:18:30.860]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.860]             version = "1.8"), class = "FutureResult")
[10:18:30.860]     }, finally = {
[10:18:30.860]         if (!identical(...future.workdir, getwd())) 
[10:18:30.860]             setwd(...future.workdir)
[10:18:30.860]         {
[10:18:30.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.860]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.860]             }
[10:18:30.860]             base::options(...future.oldOptions)
[10:18:30.860]             if (.Platform$OS.type == "windows") {
[10:18:30.860]                 old_names <- names(...future.oldEnvVars)
[10:18:30.860]                 envs <- base::Sys.getenv()
[10:18:30.860]                 names <- names(envs)
[10:18:30.860]                 common <- intersect(names, old_names)
[10:18:30.860]                 added <- setdiff(names, old_names)
[10:18:30.860]                 removed <- setdiff(old_names, names)
[10:18:30.860]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.860]                   envs[common]]
[10:18:30.860]                 NAMES <- toupper(changed)
[10:18:30.860]                 args <- list()
[10:18:30.860]                 for (kk in seq_along(NAMES)) {
[10:18:30.860]                   name <- changed[[kk]]
[10:18:30.860]                   NAME <- NAMES[[kk]]
[10:18:30.860]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.860]                     next
[10:18:30.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.860]                 }
[10:18:30.860]                 NAMES <- toupper(added)
[10:18:30.860]                 for (kk in seq_along(NAMES)) {
[10:18:30.860]                   name <- added[[kk]]
[10:18:30.860]                   NAME <- NAMES[[kk]]
[10:18:30.860]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.860]                     next
[10:18:30.860]                   args[[name]] <- ""
[10:18:30.860]                 }
[10:18:30.860]                 NAMES <- toupper(removed)
[10:18:30.860]                 for (kk in seq_along(NAMES)) {
[10:18:30.860]                   name <- removed[[kk]]
[10:18:30.860]                   NAME <- NAMES[[kk]]
[10:18:30.860]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.860]                     next
[10:18:30.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.860]                 }
[10:18:30.860]                 if (length(args) > 0) 
[10:18:30.860]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.860]             }
[10:18:30.860]             else {
[10:18:30.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.860]             }
[10:18:30.860]             {
[10:18:30.860]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.860]                   0L) {
[10:18:30.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.860]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.860]                   base::options(opts)
[10:18:30.860]                 }
[10:18:30.860]                 {
[10:18:30.860]                   {
[10:18:30.860]                     NULL
[10:18:30.860]                     RNGkind("Mersenne-Twister")
[10:18:30.860]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:30.860]                       inherits = FALSE)
[10:18:30.860]                   }
[10:18:30.860]                   options(future.plan = NULL)
[10:18:30.860]                   if (is.na(NA_character_)) 
[10:18:30.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.860]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.860]                     .init = FALSE)
[10:18:30.860]                 }
[10:18:30.860]             }
[10:18:30.860]         }
[10:18:30.860]     })
[10:18:30.860]     if (TRUE) {
[10:18:30.860]         base::sink(type = "output", split = FALSE)
[10:18:30.860]         if (TRUE) {
[10:18:30.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.860]         }
[10:18:30.860]         else {
[10:18:30.860]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.860]         }
[10:18:30.860]         base::close(...future.stdout)
[10:18:30.860]         ...future.stdout <- NULL
[10:18:30.860]     }
[10:18:30.860]     ...future.result$conditions <- ...future.conditions
[10:18:30.860]     ...future.result$finished <- base::Sys.time()
[10:18:30.860]     ...future.result
[10:18:30.860] }
[10:18:30.862] assign_globals() ...
[10:18:30.862] List of 5
[10:18:30.862]  $ ...future.FUN            :function (object, ...)  
[10:18:30.862]  $ future.call.arguments    : list()
[10:18:30.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.862]  $ ...future.elements_ii    :List of 3
[10:18:30.862]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.862]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:30.862]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.862]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:30.862]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.862]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:30.862]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.862]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:30.862]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:30.862]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:30.862]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.862]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:30.862]  $ ...future.seeds_ii       : NULL
[10:18:30.862]  $ ...future.globals.maxSize: NULL
[10:18:30.862]  - attr(*, "where")=List of 5
[10:18:30.862]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:30.862]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:30.862]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:30.862]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:30.862]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:30.862]  - attr(*, "resolved")= logi FALSE
[10:18:30.862]  - attr(*, "total_size")= num 18647
[10:18:30.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.862]  - attr(*, "already-done")= logi TRUE
[10:18:30.870] - copied ‘...future.FUN’ to environment
[10:18:30.870] - copied ‘future.call.arguments’ to environment
[10:18:30.870] - copied ‘...future.elements_ii’ to environment
[10:18:30.870] - copied ‘...future.seeds_ii’ to environment
[10:18:30.871] - copied ‘...future.globals.maxSize’ to environment
[10:18:30.871] assign_globals() ... done
[10:18:30.871] plan(): Setting new future strategy stack:
[10:18:30.871] List of future strategies:
[10:18:30.871] 1. sequential:
[10:18:30.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.871]    - tweaked: FALSE
[10:18:30.871]    - call: NULL
[10:18:30.871] plan(): nbrOfWorkers() = 1
[10:18:30.874] plan(): Setting new future strategy stack:
[10:18:30.874] List of future strategies:
[10:18:30.874] 1. sequential:
[10:18:30.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.874]    - tweaked: FALSE
[10:18:30.874]    - call: plan(strategy)
[10:18:30.874] plan(): nbrOfWorkers() = 1
[10:18:30.874] SequentialFuture started (and completed)
[10:18:30.874] - Launch lazy future ... done
[10:18:30.875] run() for ‘SequentialFuture’ ... done
[10:18:30.875] Created future:
[10:18:30.875] SequentialFuture:
[10:18:30.875] Label: ‘future_by-1’
[10:18:30.875] Expression:
[10:18:30.875] {
[10:18:30.875]     do.call(function(...) {
[10:18:30.875]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.875]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.875]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.875]             on.exit(options(oopts), add = TRUE)
[10:18:30.875]         }
[10:18:30.875]         {
[10:18:30.875]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.875]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.875]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.875]             })
[10:18:30.875]         }
[10:18:30.875]     }, args = future.call.arguments)
[10:18:30.875] }
[10:18:30.875] Lazy evaluation: FALSE
[10:18:30.875] Asynchronous evaluation: FALSE
[10:18:30.875] Local evaluation: TRUE
[10:18:30.875] Environment: 0x5584489506a8
[10:18:30.875] Capture standard output: TRUE
[10:18:30.875] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:30.875] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:30.875] Packages: <none>
[10:18:30.875] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:30.875] Resolved: TRUE
[10:18:30.875] Value: 1.39 KiB of class ‘list’
[10:18:30.875] Early signaling: FALSE
[10:18:30.875] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:30.875] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.876] Chunk #1 of 1 ... DONE
[10:18:30.876] Launching 1 futures (chunks) ... DONE
[10:18:30.876] Resolving 1 futures (chunks) ...
[10:18:30.876] resolve() on list ...
[10:18:30.876]  recursive: 0
[10:18:30.876]  length: 1
[10:18:30.876] 
[10:18:30.876] resolved() for ‘SequentialFuture’ ...
[10:18:30.876] - state: ‘finished’
[10:18:30.876] - run: TRUE
[10:18:30.877] - result: ‘FutureResult’
[10:18:30.877] resolved() for ‘SequentialFuture’ ... done
[10:18:30.877] Future #1
[10:18:30.877] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:30.877] - nx: 1
[10:18:30.877] - relay: TRUE
[10:18:30.877] - stdout: TRUE
[10:18:30.877] - signal: TRUE
[10:18:30.877] - resignal: FALSE
[10:18:30.877] - force: TRUE
[10:18:30.877] - relayed: [n=1] FALSE
[10:18:30.878] - queued futures: [n=1] FALSE
[10:18:30.878]  - until=1
[10:18:30.878]  - relaying element #1
[10:18:30.878] - relayed: [n=1] TRUE
[10:18:30.878] - queued futures: [n=1] TRUE
[10:18:30.880] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:30.880]  length: 0 (resolved future 1)
[10:18:30.880] Relaying remaining futures
[10:18:30.880] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.880] - nx: 1
[10:18:30.880] - relay: TRUE
[10:18:30.880] - stdout: TRUE
[10:18:30.880] - signal: TRUE
[10:18:30.880] - resignal: FALSE
[10:18:30.880] - force: TRUE
[10:18:30.881] - relayed: [n=1] TRUE
[10:18:30.881] - queued futures: [n=1] TRUE
 - flush all
[10:18:30.881] - relayed: [n=1] TRUE
[10:18:30.881] - queued futures: [n=1] TRUE
[10:18:30.881] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.881] resolve() on list ... DONE
[10:18:30.881]  - Number of value chunks collected: 1
[10:18:30.881] Resolving 1 futures (chunks) ... DONE
[10:18:30.881] Reducing values from 1 chunks ...
[10:18:30.881]  - Number of values collected after concatenation: 3
[10:18:30.881]  - Number of values expected: 3
[10:18:30.882] Reducing values from 1 chunks ... DONE
[10:18:30.882] future_lapply() ... DONE
[10:18:30.882] future_by_internal() ... DONE
[10:18:30.883] future_by_internal() ...
- plan('multicore') ...
[10:18:30.883] plan(): Setting new future strategy stack:
[10:18:30.883] List of future strategies:
[10:18:30.883] 1. multicore:
[10:18:30.883]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:30.883]    - tweaked: FALSE
[10:18:30.883]    - call: plan(strategy)
[10:18:30.885] plan(): nbrOfWorkers() = 1
[10:18:30.885] future_by_internal() ...
[10:18:30.886] future_lapply() ...
[10:18:30.887] Number of chunks: 1
[10:18:30.887] getGlobalsAndPackagesXApply() ...
[10:18:30.887]  - future.globals: TRUE
[10:18:30.888] getGlobalsAndPackages() ...
[10:18:30.888] Searching for globals...
[10:18:30.889] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:30.889] Searching for globals ... DONE
[10:18:30.889] Resolving globals: FALSE
[10:18:30.889] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:30.890] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:30.890] - globals: [1] ‘FUN’
[10:18:30.890] 
[10:18:30.890] getGlobalsAndPackages() ... DONE
[10:18:30.890]  - globals found/used: [n=1] ‘FUN’
[10:18:30.890]  - needed namespaces: [n=0] 
[10:18:30.890] Finding globals ... DONE
[10:18:30.890]  - use_args: TRUE
[10:18:30.890]  - Getting '...' globals ...
[10:18:30.891] resolve() on list ...
[10:18:30.891]  recursive: 0
[10:18:30.891]  length: 1
[10:18:30.891]  elements: ‘...’
[10:18:30.891]  length: 0 (resolved future 1)
[10:18:30.891] resolve() on list ... DONE
[10:18:30.891]    - '...' content: [n=0] 
[10:18:30.891] List of 1
[10:18:30.891]  $ ...: list()
[10:18:30.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.891]  - attr(*, "where")=List of 1
[10:18:30.891]   ..$ ...:<environment: 0x558447f875e8> 
[10:18:30.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.891]  - attr(*, "resolved")= logi TRUE
[10:18:30.891]  - attr(*, "total_size")= num NA
[10:18:30.894]  - Getting '...' globals ... DONE
[10:18:30.894] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.894] List of 2
[10:18:30.894]  $ ...future.FUN:function (object, ...)  
[10:18:30.894]  $ ...          : list()
[10:18:30.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.894]  - attr(*, "where")=List of 2
[10:18:30.894]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.894]   ..$ ...          :<environment: 0x558447f875e8> 
[10:18:30.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.894]  - attr(*, "resolved")= logi FALSE
[10:18:30.894]  - attr(*, "total_size")= num 15670
[10:18:30.896] Packages to be attached in all futures: [n=0] 
[10:18:30.897] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.897] Number of futures (= number of chunks): 1
[10:18:30.897] Launching 1 futures (chunks) ...
[10:18:30.897] Chunk #1 of 1 ...
[10:18:30.897]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.897] getGlobalsAndPackages() ...
[10:18:30.897] Searching for globals...
[10:18:30.898] 
[10:18:30.898] Searching for globals ... DONE
[10:18:30.898] - globals: [0] <none>
[10:18:30.898] getGlobalsAndPackages() ... DONE
[10:18:30.898]    + additional globals found: [n=0] 
[10:18:30.899]    + additional namespaces needed: [n=0] 
[10:18:30.899]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:30.899]  - seeds: <none>
[10:18:30.899]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.899] getGlobalsAndPackages() ...
[10:18:30.899] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.899] Resolving globals: FALSE
[10:18:30.899] Tweak future expression to call with '...' arguments ...
[10:18:30.899] {
[10:18:30.899]     do.call(function(...) {
[10:18:30.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.899]             on.exit(options(oopts), add = TRUE)
[10:18:30.899]         }
[10:18:30.899]         {
[10:18:30.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.899]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.899]             })
[10:18:30.899]         }
[10:18:30.899]     }, args = future.call.arguments)
[10:18:30.899] }
[10:18:30.900] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.902] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.902] 
[10:18:30.902] getGlobalsAndPackages() ... DONE
[10:18:30.902] run() for ‘Future’ ...
[10:18:30.903] - state: ‘created’
[10:18:30.903] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:30.904] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:30.905]   - Field: ‘label’
[10:18:30.905]   - Field: ‘local’
[10:18:30.905]   - Field: ‘owner’
[10:18:30.905]   - Field: ‘envir’
[10:18:30.905]   - Field: ‘packages’
[10:18:30.905]   - Field: ‘gc’
[10:18:30.905]   - Field: ‘conditions’
[10:18:30.905]   - Field: ‘expr’
[10:18:30.905]   - Field: ‘uuid’
[10:18:30.905]   - Field: ‘seed’
[10:18:30.906]   - Field: ‘version’
[10:18:30.906]   - Field: ‘result’
[10:18:30.906]   - Field: ‘asynchronous’
[10:18:30.906]   - Field: ‘calls’
[10:18:30.906]   - Field: ‘globals’
[10:18:30.906]   - Field: ‘stdout’
[10:18:30.906]   - Field: ‘earlySignal’
[10:18:30.906]   - Field: ‘lazy’
[10:18:30.906]   - Field: ‘state’
[10:18:30.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:30.906] - Launch lazy future ...
[10:18:30.907] Packages needed by the future expression (n = 0): <none>
[10:18:30.907] Packages needed by future strategies (n = 0): <none>
[10:18:30.907] {
[10:18:30.907]     {
[10:18:30.907]         {
[10:18:30.907]             ...future.startTime <- base::Sys.time()
[10:18:30.907]             {
[10:18:30.907]                 {
[10:18:30.907]                   {
[10:18:30.907]                     base::local({
[10:18:30.907]                       has_future <- base::requireNamespace("future", 
[10:18:30.907]                         quietly = TRUE)
[10:18:30.907]                       if (has_future) {
[10:18:30.907]                         ns <- base::getNamespace("future")
[10:18:30.907]                         version <- ns[[".package"]][["version"]]
[10:18:30.907]                         if (is.null(version)) 
[10:18:30.907]                           version <- utils::packageVersion("future")
[10:18:30.907]                       }
[10:18:30.907]                       else {
[10:18:30.907]                         version <- NULL
[10:18:30.907]                       }
[10:18:30.907]                       if (!has_future || version < "1.8.0") {
[10:18:30.907]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.907]                           "", base::R.version$version.string), 
[10:18:30.907]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:30.907]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.907]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.907]                             "release", "version")], collapse = " "), 
[10:18:30.907]                           hostname = base::Sys.info()[["nodename"]])
[10:18:30.907]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.907]                           info)
[10:18:30.907]                         info <- base::paste(info, collapse = "; ")
[10:18:30.907]                         if (!has_future) {
[10:18:30.907]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.907]                             info)
[10:18:30.907]                         }
[10:18:30.907]                         else {
[10:18:30.907]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.907]                             info, version)
[10:18:30.907]                         }
[10:18:30.907]                         base::stop(msg)
[10:18:30.907]                       }
[10:18:30.907]                     })
[10:18:30.907]                   }
[10:18:30.907]                   ...future.strategy.old <- future::plan("list")
[10:18:30.907]                   options(future.plan = NULL)
[10:18:30.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.907]                 }
[10:18:30.907]                 ...future.workdir <- getwd()
[10:18:30.907]             }
[10:18:30.907]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.907]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.907]         }
[10:18:30.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.907]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:30.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.907]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.907]             base::names(...future.oldOptions))
[10:18:30.907]     }
[10:18:30.907]     if (FALSE) {
[10:18:30.907]     }
[10:18:30.907]     else {
[10:18:30.907]         if (TRUE) {
[10:18:30.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.907]                 open = "w")
[10:18:30.907]         }
[10:18:30.907]         else {
[10:18:30.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.907]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.907]         }
[10:18:30.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.907]             base::sink(type = "output", split = FALSE)
[10:18:30.907]             base::close(...future.stdout)
[10:18:30.907]         }, add = TRUE)
[10:18:30.907]     }
[10:18:30.907]     ...future.frame <- base::sys.nframe()
[10:18:30.907]     ...future.conditions <- base::list()
[10:18:30.907]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.907]     if (FALSE) {
[10:18:30.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.907]     }
[10:18:30.907]     ...future.result <- base::tryCatch({
[10:18:30.907]         base::withCallingHandlers({
[10:18:30.907]             ...future.value <- base::withVisible(base::local({
[10:18:30.907]                 do.call(function(...) {
[10:18:30.907]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.907]                   if (!identical(...future.globals.maxSize.org, 
[10:18:30.907]                     ...future.globals.maxSize)) {
[10:18:30.907]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.907]                     on.exit(options(oopts), add = TRUE)
[10:18:30.907]                   }
[10:18:30.907]                   {
[10:18:30.907]                     lapply(seq_along(...future.elements_ii), 
[10:18:30.907]                       FUN = function(jj) {
[10:18:30.907]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.907]                         ...future.FUN(...future.X_jj, ...)
[10:18:30.907]                       })
[10:18:30.907]                   }
[10:18:30.907]                 }, args = future.call.arguments)
[10:18:30.907]             }))
[10:18:30.907]             future::FutureResult(value = ...future.value$value, 
[10:18:30.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.907]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.907]                     ...future.globalenv.names))
[10:18:30.907]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.907]         }, condition = base::local({
[10:18:30.907]             c <- base::c
[10:18:30.907]             inherits <- base::inherits
[10:18:30.907]             invokeRestart <- base::invokeRestart
[10:18:30.907]             length <- base::length
[10:18:30.907]             list <- base::list
[10:18:30.907]             seq.int <- base::seq.int
[10:18:30.907]             signalCondition <- base::signalCondition
[10:18:30.907]             sys.calls <- base::sys.calls
[10:18:30.907]             `[[` <- base::`[[`
[10:18:30.907]             `+` <- base::`+`
[10:18:30.907]             `<<-` <- base::`<<-`
[10:18:30.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.907]                   3L)]
[10:18:30.907]             }
[10:18:30.907]             function(cond) {
[10:18:30.907]                 is_error <- inherits(cond, "error")
[10:18:30.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.907]                   NULL)
[10:18:30.907]                 if (is_error) {
[10:18:30.907]                   sessionInformation <- function() {
[10:18:30.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.907]                       search = base::search(), system = base::Sys.info())
[10:18:30.907]                   }
[10:18:30.907]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.907]                     cond$call), session = sessionInformation(), 
[10:18:30.907]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.907]                   signalCondition(cond)
[10:18:30.907]                 }
[10:18:30.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:30.907]                 "immediateCondition"))) {
[10:18:30.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.907]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.907]                   if (TRUE && !signal) {
[10:18:30.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.907]                     {
[10:18:30.907]                       inherits <- base::inherits
[10:18:30.907]                       invokeRestart <- base::invokeRestart
[10:18:30.907]                       is.null <- base::is.null
[10:18:30.907]                       muffled <- FALSE
[10:18:30.907]                       if (inherits(cond, "message")) {
[10:18:30.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.907]                         if (muffled) 
[10:18:30.907]                           invokeRestart("muffleMessage")
[10:18:30.907]                       }
[10:18:30.907]                       else if (inherits(cond, "warning")) {
[10:18:30.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.907]                         if (muffled) 
[10:18:30.907]                           invokeRestart("muffleWarning")
[10:18:30.907]                       }
[10:18:30.907]                       else if (inherits(cond, "condition")) {
[10:18:30.907]                         if (!is.null(pattern)) {
[10:18:30.907]                           computeRestarts <- base::computeRestarts
[10:18:30.907]                           grepl <- base::grepl
[10:18:30.907]                           restarts <- computeRestarts(cond)
[10:18:30.907]                           for (restart in restarts) {
[10:18:30.907]                             name <- restart$name
[10:18:30.907]                             if (is.null(name)) 
[10:18:30.907]                               next
[10:18:30.907]                             if (!grepl(pattern, name)) 
[10:18:30.907]                               next
[10:18:30.907]                             invokeRestart(restart)
[10:18:30.907]                             muffled <- TRUE
[10:18:30.907]                             break
[10:18:30.907]                           }
[10:18:30.907]                         }
[10:18:30.907]                       }
[10:18:30.907]                       invisible(muffled)
[10:18:30.907]                     }
[10:18:30.907]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.907]                   }
[10:18:30.907]                 }
[10:18:30.907]                 else {
[10:18:30.907]                   if (TRUE) {
[10:18:30.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.907]                     {
[10:18:30.907]                       inherits <- base::inherits
[10:18:30.907]                       invokeRestart <- base::invokeRestart
[10:18:30.907]                       is.null <- base::is.null
[10:18:30.907]                       muffled <- FALSE
[10:18:30.907]                       if (inherits(cond, "message")) {
[10:18:30.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.907]                         if (muffled) 
[10:18:30.907]                           invokeRestart("muffleMessage")
[10:18:30.907]                       }
[10:18:30.907]                       else if (inherits(cond, "warning")) {
[10:18:30.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.907]                         if (muffled) 
[10:18:30.907]                           invokeRestart("muffleWarning")
[10:18:30.907]                       }
[10:18:30.907]                       else if (inherits(cond, "condition")) {
[10:18:30.907]                         if (!is.null(pattern)) {
[10:18:30.907]                           computeRestarts <- base::computeRestarts
[10:18:30.907]                           grepl <- base::grepl
[10:18:30.907]                           restarts <- computeRestarts(cond)
[10:18:30.907]                           for (restart in restarts) {
[10:18:30.907]                             name <- restart$name
[10:18:30.907]                             if (is.null(name)) 
[10:18:30.907]                               next
[10:18:30.907]                             if (!grepl(pattern, name)) 
[10:18:30.907]                               next
[10:18:30.907]                             invokeRestart(restart)
[10:18:30.907]                             muffled <- TRUE
[10:18:30.907]                             break
[10:18:30.907]                           }
[10:18:30.907]                         }
[10:18:30.907]                       }
[10:18:30.907]                       invisible(muffled)
[10:18:30.907]                     }
[10:18:30.907]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.907]                   }
[10:18:30.907]                 }
[10:18:30.907]             }
[10:18:30.907]         }))
[10:18:30.907]     }, error = function(ex) {
[10:18:30.907]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.907]                 ...future.rng), started = ...future.startTime, 
[10:18:30.907]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.907]             version = "1.8"), class = "FutureResult")
[10:18:30.907]     }, finally = {
[10:18:30.907]         if (!identical(...future.workdir, getwd())) 
[10:18:30.907]             setwd(...future.workdir)
[10:18:30.907]         {
[10:18:30.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.907]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.907]             }
[10:18:30.907]             base::options(...future.oldOptions)
[10:18:30.907]             if (.Platform$OS.type == "windows") {
[10:18:30.907]                 old_names <- names(...future.oldEnvVars)
[10:18:30.907]                 envs <- base::Sys.getenv()
[10:18:30.907]                 names <- names(envs)
[10:18:30.907]                 common <- intersect(names, old_names)
[10:18:30.907]                 added <- setdiff(names, old_names)
[10:18:30.907]                 removed <- setdiff(old_names, names)
[10:18:30.907]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.907]                   envs[common]]
[10:18:30.907]                 NAMES <- toupper(changed)
[10:18:30.907]                 args <- list()
[10:18:30.907]                 for (kk in seq_along(NAMES)) {
[10:18:30.907]                   name <- changed[[kk]]
[10:18:30.907]                   NAME <- NAMES[[kk]]
[10:18:30.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.907]                     next
[10:18:30.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.907]                 }
[10:18:30.907]                 NAMES <- toupper(added)
[10:18:30.907]                 for (kk in seq_along(NAMES)) {
[10:18:30.907]                   name <- added[[kk]]
[10:18:30.907]                   NAME <- NAMES[[kk]]
[10:18:30.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.907]                     next
[10:18:30.907]                   args[[name]] <- ""
[10:18:30.907]                 }
[10:18:30.907]                 NAMES <- toupper(removed)
[10:18:30.907]                 for (kk in seq_along(NAMES)) {
[10:18:30.907]                   name <- removed[[kk]]
[10:18:30.907]                   NAME <- NAMES[[kk]]
[10:18:30.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.907]                     next
[10:18:30.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.907]                 }
[10:18:30.907]                 if (length(args) > 0) 
[10:18:30.907]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.907]             }
[10:18:30.907]             else {
[10:18:30.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.907]             }
[10:18:30.907]             {
[10:18:30.907]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.907]                   0L) {
[10:18:30.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.907]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.907]                   base::options(opts)
[10:18:30.907]                 }
[10:18:30.907]                 {
[10:18:30.907]                   {
[10:18:30.907]                     NULL
[10:18:30.907]                     RNGkind("Mersenne-Twister")
[10:18:30.907]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:30.907]                       inherits = FALSE)
[10:18:30.907]                   }
[10:18:30.907]                   options(future.plan = NULL)
[10:18:30.907]                   if (is.na(NA_character_)) 
[10:18:30.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.907]                     .init = FALSE)
[10:18:30.907]                 }
[10:18:30.907]             }
[10:18:30.907]         }
[10:18:30.907]     })
[10:18:30.907]     if (TRUE) {
[10:18:30.907]         base::sink(type = "output", split = FALSE)
[10:18:30.907]         if (TRUE) {
[10:18:30.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.907]         }
[10:18:30.907]         else {
[10:18:30.907]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.907]         }
[10:18:30.907]         base::close(...future.stdout)
[10:18:30.907]         ...future.stdout <- NULL
[10:18:30.907]     }
[10:18:30.907]     ...future.result$conditions <- ...future.conditions
[10:18:30.907]     ...future.result$finished <- base::Sys.time()
[10:18:30.907]     ...future.result
[10:18:30.907] }
[10:18:30.909] assign_globals() ...
[10:18:30.909] List of 5
[10:18:30.909]  $ ...future.FUN            :function (object, ...)  
[10:18:30.909]  $ future.call.arguments    : list()
[10:18:30.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.909]  $ ...future.elements_ii    :List of 3
[10:18:30.909]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:30.909]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:30.909]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.909]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:30.909]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:30.909]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.909]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:30.909]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:30.909]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:30.909]  $ ...future.seeds_ii       : NULL
[10:18:30.909]  $ ...future.globals.maxSize: NULL
[10:18:30.909]  - attr(*, "where")=List of 5
[10:18:30.909]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:30.909]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:30.909]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:30.909]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:30.909]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:30.909]  - attr(*, "resolved")= logi FALSE
[10:18:30.909]  - attr(*, "total_size")= num 15670
[10:18:30.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.909]  - attr(*, "already-done")= logi TRUE
[10:18:30.916] - copied ‘...future.FUN’ to environment
[10:18:30.917] - copied ‘future.call.arguments’ to environment
[10:18:30.917] - copied ‘...future.elements_ii’ to environment
[10:18:30.917] - copied ‘...future.seeds_ii’ to environment
[10:18:30.917] - copied ‘...future.globals.maxSize’ to environment
[10:18:30.917] assign_globals() ... done
[10:18:30.917] plan(): Setting new future strategy stack:
[10:18:30.917] List of future strategies:
[10:18:30.917] 1. sequential:
[10:18:30.917]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.917]    - tweaked: FALSE
[10:18:30.917]    - call: NULL
[10:18:30.918] plan(): nbrOfWorkers() = 1
[10:18:30.920] plan(): Setting new future strategy stack:
[10:18:30.920] List of future strategies:
[10:18:30.920] 1. multicore:
[10:18:30.920]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:30.920]    - tweaked: FALSE
[10:18:30.920]    - call: plan(strategy)
[10:18:30.922] plan(): nbrOfWorkers() = 1
[10:18:30.922] SequentialFuture started (and completed)
[10:18:30.922] - Launch lazy future ... done
[10:18:30.922] run() for ‘SequentialFuture’ ... done
[10:18:30.922] Created future:
[10:18:30.922] SequentialFuture:
[10:18:30.922] Label: ‘future_by-1’
[10:18:30.922] Expression:
[10:18:30.922] {
[10:18:30.922]     do.call(function(...) {
[10:18:30.922]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.922]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.922]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.922]             on.exit(options(oopts), add = TRUE)
[10:18:30.922]         }
[10:18:30.922]         {
[10:18:30.922]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.922]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.922]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.922]             })
[10:18:30.922]         }
[10:18:30.922]     }, args = future.call.arguments)
[10:18:30.922] }
[10:18:30.922] Lazy evaluation: FALSE
[10:18:30.922] Asynchronous evaluation: FALSE
[10:18:30.922] Local evaluation: TRUE
[10:18:30.922] Environment: R_GlobalEnv
[10:18:30.922] Capture standard output: TRUE
[10:18:30.922] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:30.922] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:30.922] Packages: <none>
[10:18:30.922] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:30.922] Resolved: TRUE
[10:18:30.922] Value: 1.16 KiB of class ‘list’
[10:18:30.922] Early signaling: FALSE
[10:18:30.922] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:30.922] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.923] Chunk #1 of 1 ... DONE
[10:18:30.923] Launching 1 futures (chunks) ... DONE
[10:18:30.923] Resolving 1 futures (chunks) ...
[10:18:30.923] resolve() on list ...
[10:18:30.924]  recursive: 0
[10:18:30.924]  length: 1
[10:18:30.924] 
[10:18:30.924] resolved() for ‘SequentialFuture’ ...
[10:18:30.926] - state: ‘finished’
[10:18:30.926] - run: TRUE
[10:18:30.926] - result: ‘FutureResult’
[10:18:30.926] resolved() for ‘SequentialFuture’ ... done
[10:18:30.926] Future #1
[10:18:30.926] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:30.927] - nx: 1
[10:18:30.927] - relay: TRUE
[10:18:30.927] - stdout: TRUE
[10:18:30.927] - signal: TRUE
[10:18:30.927] - resignal: FALSE
[10:18:30.927] - force: TRUE
[10:18:30.927] - relayed: [n=1] FALSE
[10:18:30.927] - queued futures: [n=1] FALSE
[10:18:30.927]  - until=1
[10:18:30.927]  - relaying element #1
[10:18:30.928] - relayed: [n=1] TRUE
[10:18:30.928] - queued futures: [n=1] TRUE
[10:18:30.928] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:30.928]  length: 0 (resolved future 1)
[10:18:30.928] Relaying remaining futures
[10:18:30.928] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.928] - nx: 1
[10:18:30.928] - relay: TRUE
[10:18:30.928] - stdout: TRUE
[10:18:30.928] - signal: TRUE
[10:18:30.928] - resignal: FALSE
[10:18:30.928] - force: TRUE
[10:18:30.929] - relayed: [n=1] TRUE
[10:18:30.929] - queued futures: [n=1] TRUE
 - flush all
[10:18:30.929] - relayed: [n=1] TRUE
[10:18:30.929] - queued futures: [n=1] TRUE
[10:18:30.929] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.929] resolve() on list ... DONE
[10:18:30.929]  - Number of value chunks collected: 1
[10:18:30.929] Resolving 1 futures (chunks) ... DONE
[10:18:30.929] Reducing values from 1 chunks ...
[10:18:30.929]  - Number of values collected after concatenation: 3
[10:18:30.929]  - Number of values expected: 3
[10:18:30.930] Reducing values from 1 chunks ... DONE
[10:18:30.930] future_lapply() ... DONE
[10:18:30.930] future_by_internal() ... DONE
[10:18:30.930] future_by_internal() ...
[10:18:30.930] future_lapply() ...
[10:18:30.932] Number of chunks: 1
[10:18:30.932] getGlobalsAndPackagesXApply() ...
[10:18:30.932]  - future.globals: TRUE
[10:18:30.933] getGlobalsAndPackages() ...
[10:18:30.933] Searching for globals...
[10:18:30.934] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:30.934] Searching for globals ... DONE
[10:18:30.934] Resolving globals: FALSE
[10:18:30.934] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:30.935] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:30.935] - globals: [1] ‘FUN’
[10:18:30.935] 
[10:18:30.935] getGlobalsAndPackages() ... DONE
[10:18:30.935]  - globals found/used: [n=1] ‘FUN’
[10:18:30.935]  - needed namespaces: [n=0] 
[10:18:30.935] Finding globals ... DONE
[10:18:30.935]  - use_args: TRUE
[10:18:30.936]  - Getting '...' globals ...
[10:18:30.936] resolve() on list ...
[10:18:30.936]  recursive: 0
[10:18:30.936]  length: 1
[10:18:30.936]  elements: ‘...’
[10:18:30.936]  length: 0 (resolved future 1)
[10:18:30.936] resolve() on list ... DONE
[10:18:30.936]    - '...' content: [n=1] ‘digits’
[10:18:30.937] List of 1
[10:18:30.937]  $ ...:List of 1
[10:18:30.937]   ..$ digits: int 2
[10:18:30.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.937]  - attr(*, "where")=List of 1
[10:18:30.937]   ..$ ...:<environment: 0x558448099400> 
[10:18:30.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.937]  - attr(*, "resolved")= logi TRUE
[10:18:30.937]  - attr(*, "total_size")= num NA
[10:18:30.939]  - Getting '...' globals ... DONE
[10:18:30.940] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.940] List of 2
[10:18:30.940]  $ ...future.FUN:function (object, ...)  
[10:18:30.940]  $ ...          :List of 1
[10:18:30.940]   ..$ digits: int 2
[10:18:30.940]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.940]  - attr(*, "where")=List of 2
[10:18:30.940]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.940]   ..$ ...          :<environment: 0x558448099400> 
[10:18:30.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.940]  - attr(*, "resolved")= logi FALSE
[10:18:30.940]  - attr(*, "total_size")= num 13284
[10:18:30.943] Packages to be attached in all futures: [n=0] 
[10:18:30.943] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.943] Number of futures (= number of chunks): 1
[10:18:30.943] Launching 1 futures (chunks) ...
[10:18:30.943] Chunk #1 of 1 ...
[10:18:30.943]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.944] getGlobalsAndPackages() ...
[10:18:30.944] Searching for globals...
[10:18:30.944] 
[10:18:30.944] Searching for globals ... DONE
[10:18:30.944] - globals: [0] <none>
[10:18:30.944] getGlobalsAndPackages() ... DONE
[10:18:30.944]    + additional globals found: [n=0] 
[10:18:30.944]    + additional namespaces needed: [n=0] 
[10:18:30.944]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:30.944]  - seeds: <none>
[10:18:30.945]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.945] getGlobalsAndPackages() ...
[10:18:30.945] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.945] Resolving globals: FALSE
[10:18:30.945] Tweak future expression to call with '...' arguments ...
[10:18:30.945] {
[10:18:30.945]     do.call(function(...) {
[10:18:30.945]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.945]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.945]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.945]             on.exit(options(oopts), add = TRUE)
[10:18:30.945]         }
[10:18:30.945]         {
[10:18:30.945]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.945]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.945]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.945]             })
[10:18:30.945]         }
[10:18:30.945]     }, args = future.call.arguments)
[10:18:30.945] }
[10:18:30.945] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.948] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.948] 
[10:18:30.948] getGlobalsAndPackages() ... DONE
[10:18:30.948] run() for ‘Future’ ...
[10:18:30.949] - state: ‘created’
[10:18:30.949] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:30.950] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.951] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:30.951]   - Field: ‘label’
[10:18:30.951]   - Field: ‘local’
[10:18:30.951]   - Field: ‘owner’
[10:18:30.951]   - Field: ‘envir’
[10:18:30.951]   - Field: ‘packages’
[10:18:30.951]   - Field: ‘gc’
[10:18:30.951]   - Field: ‘conditions’
[10:18:30.951]   - Field: ‘expr’
[10:18:30.951]   - Field: ‘uuid’
[10:18:30.952]   - Field: ‘seed’
[10:18:30.952]   - Field: ‘version’
[10:18:30.952]   - Field: ‘result’
[10:18:30.952]   - Field: ‘asynchronous’
[10:18:30.952]   - Field: ‘calls’
[10:18:30.952]   - Field: ‘globals’
[10:18:30.952]   - Field: ‘stdout’
[10:18:30.952]   - Field: ‘earlySignal’
[10:18:30.952]   - Field: ‘lazy’
[10:18:30.952]   - Field: ‘state’
[10:18:30.952] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:30.953] - Launch lazy future ...
[10:18:30.953] Packages needed by the future expression (n = 0): <none>
[10:18:30.953] Packages needed by future strategies (n = 0): <none>
[10:18:30.953] {
[10:18:30.953]     {
[10:18:30.953]         {
[10:18:30.953]             ...future.startTime <- base::Sys.time()
[10:18:30.953]             {
[10:18:30.953]                 {
[10:18:30.953]                   {
[10:18:30.953]                     base::local({
[10:18:30.953]                       has_future <- base::requireNamespace("future", 
[10:18:30.953]                         quietly = TRUE)
[10:18:30.953]                       if (has_future) {
[10:18:30.953]                         ns <- base::getNamespace("future")
[10:18:30.953]                         version <- ns[[".package"]][["version"]]
[10:18:30.953]                         if (is.null(version)) 
[10:18:30.953]                           version <- utils::packageVersion("future")
[10:18:30.953]                       }
[10:18:30.953]                       else {
[10:18:30.953]                         version <- NULL
[10:18:30.953]                       }
[10:18:30.953]                       if (!has_future || version < "1.8.0") {
[10:18:30.953]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.953]                           "", base::R.version$version.string), 
[10:18:30.953]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:30.953]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.953]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.953]                             "release", "version")], collapse = " "), 
[10:18:30.953]                           hostname = base::Sys.info()[["nodename"]])
[10:18:30.953]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.953]                           info)
[10:18:30.953]                         info <- base::paste(info, collapse = "; ")
[10:18:30.953]                         if (!has_future) {
[10:18:30.953]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.953]                             info)
[10:18:30.953]                         }
[10:18:30.953]                         else {
[10:18:30.953]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.953]                             info, version)
[10:18:30.953]                         }
[10:18:30.953]                         base::stop(msg)
[10:18:30.953]                       }
[10:18:30.953]                     })
[10:18:30.953]                   }
[10:18:30.953]                   ...future.strategy.old <- future::plan("list")
[10:18:30.953]                   options(future.plan = NULL)
[10:18:30.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.953]                 }
[10:18:30.953]                 ...future.workdir <- getwd()
[10:18:30.953]             }
[10:18:30.953]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.953]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.953]         }
[10:18:30.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.953]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:30.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.953]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.953]             base::names(...future.oldOptions))
[10:18:30.953]     }
[10:18:30.953]     if (FALSE) {
[10:18:30.953]     }
[10:18:30.953]     else {
[10:18:30.953]         if (TRUE) {
[10:18:30.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.953]                 open = "w")
[10:18:30.953]         }
[10:18:30.953]         else {
[10:18:30.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.953]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.953]         }
[10:18:30.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.953]             base::sink(type = "output", split = FALSE)
[10:18:30.953]             base::close(...future.stdout)
[10:18:30.953]         }, add = TRUE)
[10:18:30.953]     }
[10:18:30.953]     ...future.frame <- base::sys.nframe()
[10:18:30.953]     ...future.conditions <- base::list()
[10:18:30.953]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.953]     if (FALSE) {
[10:18:30.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.953]     }
[10:18:30.953]     ...future.result <- base::tryCatch({
[10:18:30.953]         base::withCallingHandlers({
[10:18:30.953]             ...future.value <- base::withVisible(base::local({
[10:18:30.953]                 do.call(function(...) {
[10:18:30.953]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.953]                   if (!identical(...future.globals.maxSize.org, 
[10:18:30.953]                     ...future.globals.maxSize)) {
[10:18:30.953]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.953]                     on.exit(options(oopts), add = TRUE)
[10:18:30.953]                   }
[10:18:30.953]                   {
[10:18:30.953]                     lapply(seq_along(...future.elements_ii), 
[10:18:30.953]                       FUN = function(jj) {
[10:18:30.953]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.953]                         ...future.FUN(...future.X_jj, ...)
[10:18:30.953]                       })
[10:18:30.953]                   }
[10:18:30.953]                 }, args = future.call.arguments)
[10:18:30.953]             }))
[10:18:30.953]             future::FutureResult(value = ...future.value$value, 
[10:18:30.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.953]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.953]                     ...future.globalenv.names))
[10:18:30.953]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.953]         }, condition = base::local({
[10:18:30.953]             c <- base::c
[10:18:30.953]             inherits <- base::inherits
[10:18:30.953]             invokeRestart <- base::invokeRestart
[10:18:30.953]             length <- base::length
[10:18:30.953]             list <- base::list
[10:18:30.953]             seq.int <- base::seq.int
[10:18:30.953]             signalCondition <- base::signalCondition
[10:18:30.953]             sys.calls <- base::sys.calls
[10:18:30.953]             `[[` <- base::`[[`
[10:18:30.953]             `+` <- base::`+`
[10:18:30.953]             `<<-` <- base::`<<-`
[10:18:30.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.953]                   3L)]
[10:18:30.953]             }
[10:18:30.953]             function(cond) {
[10:18:30.953]                 is_error <- inherits(cond, "error")
[10:18:30.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.953]                   NULL)
[10:18:30.953]                 if (is_error) {
[10:18:30.953]                   sessionInformation <- function() {
[10:18:30.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.953]                       search = base::search(), system = base::Sys.info())
[10:18:30.953]                   }
[10:18:30.953]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.953]                     cond$call), session = sessionInformation(), 
[10:18:30.953]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.953]                   signalCondition(cond)
[10:18:30.953]                 }
[10:18:30.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:30.953]                 "immediateCondition"))) {
[10:18:30.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.953]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.953]                   if (TRUE && !signal) {
[10:18:30.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.953]                     {
[10:18:30.953]                       inherits <- base::inherits
[10:18:30.953]                       invokeRestart <- base::invokeRestart
[10:18:30.953]                       is.null <- base::is.null
[10:18:30.953]                       muffled <- FALSE
[10:18:30.953]                       if (inherits(cond, "message")) {
[10:18:30.953]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.953]                         if (muffled) 
[10:18:30.953]                           invokeRestart("muffleMessage")
[10:18:30.953]                       }
[10:18:30.953]                       else if (inherits(cond, "warning")) {
[10:18:30.953]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.953]                         if (muffled) 
[10:18:30.953]                           invokeRestart("muffleWarning")
[10:18:30.953]                       }
[10:18:30.953]                       else if (inherits(cond, "condition")) {
[10:18:30.953]                         if (!is.null(pattern)) {
[10:18:30.953]                           computeRestarts <- base::computeRestarts
[10:18:30.953]                           grepl <- base::grepl
[10:18:30.953]                           restarts <- computeRestarts(cond)
[10:18:30.953]                           for (restart in restarts) {
[10:18:30.953]                             name <- restart$name
[10:18:30.953]                             if (is.null(name)) 
[10:18:30.953]                               next
[10:18:30.953]                             if (!grepl(pattern, name)) 
[10:18:30.953]                               next
[10:18:30.953]                             invokeRestart(restart)
[10:18:30.953]                             muffled <- TRUE
[10:18:30.953]                             break
[10:18:30.953]                           }
[10:18:30.953]                         }
[10:18:30.953]                       }
[10:18:30.953]                       invisible(muffled)
[10:18:30.953]                     }
[10:18:30.953]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.953]                   }
[10:18:30.953]                 }
[10:18:30.953]                 else {
[10:18:30.953]                   if (TRUE) {
[10:18:30.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.953]                     {
[10:18:30.953]                       inherits <- base::inherits
[10:18:30.953]                       invokeRestart <- base::invokeRestart
[10:18:30.953]                       is.null <- base::is.null
[10:18:30.953]                       muffled <- FALSE
[10:18:30.953]                       if (inherits(cond, "message")) {
[10:18:30.953]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.953]                         if (muffled) 
[10:18:30.953]                           invokeRestart("muffleMessage")
[10:18:30.953]                       }
[10:18:30.953]                       else if (inherits(cond, "warning")) {
[10:18:30.953]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.953]                         if (muffled) 
[10:18:30.953]                           invokeRestart("muffleWarning")
[10:18:30.953]                       }
[10:18:30.953]                       else if (inherits(cond, "condition")) {
[10:18:30.953]                         if (!is.null(pattern)) {
[10:18:30.953]                           computeRestarts <- base::computeRestarts
[10:18:30.953]                           grepl <- base::grepl
[10:18:30.953]                           restarts <- computeRestarts(cond)
[10:18:30.953]                           for (restart in restarts) {
[10:18:30.953]                             name <- restart$name
[10:18:30.953]                             if (is.null(name)) 
[10:18:30.953]                               next
[10:18:30.953]                             if (!grepl(pattern, name)) 
[10:18:30.953]                               next
[10:18:30.953]                             invokeRestart(restart)
[10:18:30.953]                             muffled <- TRUE
[10:18:30.953]                             break
[10:18:30.953]                           }
[10:18:30.953]                         }
[10:18:30.953]                       }
[10:18:30.953]                       invisible(muffled)
[10:18:30.953]                     }
[10:18:30.953]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.953]                   }
[10:18:30.953]                 }
[10:18:30.953]             }
[10:18:30.953]         }))
[10:18:30.953]     }, error = function(ex) {
[10:18:30.953]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.953]                 ...future.rng), started = ...future.startTime, 
[10:18:30.953]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.953]             version = "1.8"), class = "FutureResult")
[10:18:30.953]     }, finally = {
[10:18:30.953]         if (!identical(...future.workdir, getwd())) 
[10:18:30.953]             setwd(...future.workdir)
[10:18:30.953]         {
[10:18:30.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.953]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.953]             }
[10:18:30.953]             base::options(...future.oldOptions)
[10:18:30.953]             if (.Platform$OS.type == "windows") {
[10:18:30.953]                 old_names <- names(...future.oldEnvVars)
[10:18:30.953]                 envs <- base::Sys.getenv()
[10:18:30.953]                 names <- names(envs)
[10:18:30.953]                 common <- intersect(names, old_names)
[10:18:30.953]                 added <- setdiff(names, old_names)
[10:18:30.953]                 removed <- setdiff(old_names, names)
[10:18:30.953]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.953]                   envs[common]]
[10:18:30.953]                 NAMES <- toupper(changed)
[10:18:30.953]                 args <- list()
[10:18:30.953]                 for (kk in seq_along(NAMES)) {
[10:18:30.953]                   name <- changed[[kk]]
[10:18:30.953]                   NAME <- NAMES[[kk]]
[10:18:30.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.953]                     next
[10:18:30.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.953]                 }
[10:18:30.953]                 NAMES <- toupper(added)
[10:18:30.953]                 for (kk in seq_along(NAMES)) {
[10:18:30.953]                   name <- added[[kk]]
[10:18:30.953]                   NAME <- NAMES[[kk]]
[10:18:30.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.953]                     next
[10:18:30.953]                   args[[name]] <- ""
[10:18:30.953]                 }
[10:18:30.953]                 NAMES <- toupper(removed)
[10:18:30.953]                 for (kk in seq_along(NAMES)) {
[10:18:30.953]                   name <- removed[[kk]]
[10:18:30.953]                   NAME <- NAMES[[kk]]
[10:18:30.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.953]                     next
[10:18:30.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.953]                 }
[10:18:30.953]                 if (length(args) > 0) 
[10:18:30.953]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.953]             }
[10:18:30.953]             else {
[10:18:30.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.953]             }
[10:18:30.953]             {
[10:18:30.953]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.953]                   0L) {
[10:18:30.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.953]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.953]                   base::options(opts)
[10:18:30.953]                 }
[10:18:30.953]                 {
[10:18:30.953]                   {
[10:18:30.953]                     NULL
[10:18:30.953]                     RNGkind("Mersenne-Twister")
[10:18:30.953]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:30.953]                       inherits = FALSE)
[10:18:30.953]                   }
[10:18:30.953]                   options(future.plan = NULL)
[10:18:30.953]                   if (is.na(NA_character_)) 
[10:18:30.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.953]                     .init = FALSE)
[10:18:30.953]                 }
[10:18:30.953]             }
[10:18:30.953]         }
[10:18:30.953]     })
[10:18:30.953]     if (TRUE) {
[10:18:30.953]         base::sink(type = "output", split = FALSE)
[10:18:30.953]         if (TRUE) {
[10:18:30.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.953]         }
[10:18:30.953]         else {
[10:18:30.953]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.953]         }
[10:18:30.953]         base::close(...future.stdout)
[10:18:30.953]         ...future.stdout <- NULL
[10:18:30.953]     }
[10:18:30.953]     ...future.result$conditions <- ...future.conditions
[10:18:30.953]     ...future.result$finished <- base::Sys.time()
[10:18:30.953]     ...future.result
[10:18:30.953] }
[10:18:30.955] assign_globals() ...
[10:18:30.955] List of 5
[10:18:30.955]  $ ...future.FUN            :function (object, ...)  
[10:18:30.955]  $ future.call.arguments    :List of 1
[10:18:30.955]   ..$ digits: int 2
[10:18:30.955]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.955]  $ ...future.elements_ii    :List of 6
[10:18:30.955]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:18:30.955]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:18:30.955]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:18:30.955]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:18:30.955]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:18:30.955]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:18:30.955]  $ ...future.seeds_ii       : NULL
[10:18:30.955]  $ ...future.globals.maxSize: NULL
[10:18:30.955]  - attr(*, "where")=List of 5
[10:18:30.955]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:30.955]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:30.955]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:30.955]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:30.955]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:30.955]  - attr(*, "resolved")= logi FALSE
[10:18:30.955]  - attr(*, "total_size")= num 13284
[10:18:30.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.955]  - attr(*, "already-done")= logi TRUE
[10:18:30.962] - copied ‘...future.FUN’ to environment
[10:18:30.962] - copied ‘future.call.arguments’ to environment
[10:18:30.962] - copied ‘...future.elements_ii’ to environment
[10:18:30.962] - copied ‘...future.seeds_ii’ to environment
[10:18:30.962] - copied ‘...future.globals.maxSize’ to environment
[10:18:30.963] assign_globals() ... done
[10:18:30.963] plan(): Setting new future strategy stack:
[10:18:30.963] List of future strategies:
[10:18:30.963] 1. sequential:
[10:18:30.963]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.963]    - tweaked: FALSE
[10:18:30.963]    - call: NULL
[10:18:30.963] plan(): nbrOfWorkers() = 1
[10:18:30.965] plan(): Setting new future strategy stack:
[10:18:30.965] List of future strategies:
[10:18:30.965] 1. multicore:
[10:18:30.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:30.965]    - tweaked: FALSE
[10:18:30.965]    - call: plan(strategy)
[10:18:30.967] plan(): nbrOfWorkers() = 1
[10:18:30.967] SequentialFuture started (and completed)
[10:18:30.967] - Launch lazy future ... done
[10:18:30.967] run() for ‘SequentialFuture’ ... done
[10:18:30.967] Created future:
[10:18:30.967] SequentialFuture:
[10:18:30.967] Label: ‘future_by-1’
[10:18:30.967] Expression:
[10:18:30.967] {
[10:18:30.967]     do.call(function(...) {
[10:18:30.967]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.967]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.967]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.967]             on.exit(options(oopts), add = TRUE)
[10:18:30.967]         }
[10:18:30.967]         {
[10:18:30.967]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.967]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.967]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.967]             })
[10:18:30.967]         }
[10:18:30.967]     }, args = future.call.arguments)
[10:18:30.967] }
[10:18:30.967] Lazy evaluation: FALSE
[10:18:30.967] Asynchronous evaluation: FALSE
[10:18:30.967] Local evaluation: TRUE
[10:18:30.967] Environment: R_GlobalEnv
[10:18:30.967] Capture standard output: TRUE
[10:18:30.967] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:30.967] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:30.967] Packages: <none>
[10:18:30.967] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:30.967] Resolved: TRUE
[10:18:30.967] Value: 1.27 KiB of class ‘list’
[10:18:30.967] Early signaling: FALSE
[10:18:30.967] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:30.967] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:30.968] Chunk #1 of 1 ... DONE
[10:18:30.968] Launching 1 futures (chunks) ... DONE
[10:18:30.969] Resolving 1 futures (chunks) ...
[10:18:30.969] resolve() on list ...
[10:18:30.969]  recursive: 0
[10:18:30.969]  length: 1
[10:18:30.969] 
[10:18:30.969] resolved() for ‘SequentialFuture’ ...
[10:18:30.969] - state: ‘finished’
[10:18:30.969] - run: TRUE
[10:18:30.969] - result: ‘FutureResult’
[10:18:30.969] resolved() for ‘SequentialFuture’ ... done
[10:18:30.969] Future #1
[10:18:30.970] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:30.970] - nx: 1
[10:18:30.970] - relay: TRUE
[10:18:30.970] - stdout: TRUE
[10:18:30.970] - signal: TRUE
[10:18:30.970] - resignal: FALSE
[10:18:30.972] - force: TRUE
[10:18:30.972] - relayed: [n=1] FALSE
[10:18:30.972] - queued futures: [n=1] FALSE
[10:18:30.973]  - until=1
[10:18:30.973]  - relaying element #1
[10:18:30.973] - relayed: [n=1] TRUE
[10:18:30.973] - queued futures: [n=1] TRUE
[10:18:30.973] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:30.973]  length: 0 (resolved future 1)
[10:18:30.973] Relaying remaining futures
[10:18:30.973] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.973] - nx: 1
[10:18:30.973] - relay: TRUE
[10:18:30.974] - stdout: TRUE
[10:18:30.974] - signal: TRUE
[10:18:30.974] - resignal: FALSE
[10:18:30.974] - force: TRUE
[10:18:30.974] - relayed: [n=1] TRUE
[10:18:30.974] - queued futures: [n=1] TRUE
 - flush all
[10:18:30.974] - relayed: [n=1] TRUE
[10:18:30.974] - queued futures: [n=1] TRUE
[10:18:30.974] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.974] resolve() on list ... DONE
[10:18:30.974]  - Number of value chunks collected: 1
[10:18:30.975] Resolving 1 futures (chunks) ... DONE
[10:18:30.975] Reducing values from 1 chunks ...
[10:18:30.975]  - Number of values collected after concatenation: 6
[10:18:30.975]  - Number of values expected: 6
[10:18:30.975] Reducing values from 1 chunks ... DONE
[10:18:30.975] future_lapply() ... DONE
[10:18:30.975] future_by_internal() ... DONE
[10:18:30.976] future_by_internal() ...
[10:18:30.977] future_lapply() ...
[10:18:30.979] Number of chunks: 1
[10:18:30.979] getGlobalsAndPackagesXApply() ...
[10:18:30.979]  - future.globals: TRUE
[10:18:30.979] getGlobalsAndPackages() ...
[10:18:30.979] Searching for globals...
[10:18:30.981] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:30.981] Searching for globals ... DONE
[10:18:30.981] Resolving globals: FALSE
[10:18:30.982] The total size of the 1 globals is 762 bytes (762 bytes)
[10:18:30.982] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:18:30.982] - globals: [1] ‘FUN’
[10:18:30.982] - packages: [1] ‘stats’
[10:18:30.982] getGlobalsAndPackages() ... DONE
[10:18:30.983]  - globals found/used: [n=1] ‘FUN’
[10:18:30.983]  - needed namespaces: [n=1] ‘stats’
[10:18:30.983] Finding globals ... DONE
[10:18:30.983]  - use_args: TRUE
[10:18:30.983]  - Getting '...' globals ...
[10:18:30.983] resolve() on list ...
[10:18:30.983]  recursive: 0
[10:18:30.983]  length: 1
[10:18:30.983]  elements: ‘...’
[10:18:30.984]  length: 0 (resolved future 1)
[10:18:30.984] resolve() on list ... DONE
[10:18:30.984]    - '...' content: [n=1] ‘singular.ok’
[10:18:30.984] List of 1
[10:18:30.984]  $ ...:List of 1
[10:18:30.984]   ..$ singular.ok: logi FALSE
[10:18:30.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.984]  - attr(*, "where")=List of 1
[10:18:30.984]   ..$ ...:<environment: 0x558448024f70> 
[10:18:30.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.984]  - attr(*, "resolved")= logi TRUE
[10:18:30.984]  - attr(*, "total_size")= num NA
[10:18:30.987]  - Getting '...' globals ... DONE
[10:18:30.987] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.987] List of 2
[10:18:30.987]  $ ...future.FUN:function (x, ...)  
[10:18:30.987]  $ ...          :List of 1
[10:18:30.987]   ..$ singular.ok: logi FALSE
[10:18:30.987]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.987]  - attr(*, "where")=List of 2
[10:18:30.987]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.987]   ..$ ...          :<environment: 0x558448024f70> 
[10:18:30.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.987]  - attr(*, "resolved")= logi FALSE
[10:18:30.987]  - attr(*, "total_size")= num 19977
[10:18:30.990] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:30.990] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.991] Number of futures (= number of chunks): 1
[10:18:30.991] Launching 1 futures (chunks) ...
[10:18:30.991] Chunk #1 of 1 ...
[10:18:30.991]  - Finding globals in 'X' for chunk #1 ...
[10:18:30.991] getGlobalsAndPackages() ...
[10:18:30.991] Searching for globals...
[10:18:31.026] 
[10:18:31.026] Searching for globals ... DONE
[10:18:31.026] - globals: [0] <none>
[10:18:31.026] getGlobalsAndPackages() ... DONE
[10:18:31.026]    + additional globals found: [n=0] 
[10:18:31.026]    + additional namespaces needed: [n=0] 
[10:18:31.026]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.027]  - seeds: <none>
[10:18:31.027]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.027] getGlobalsAndPackages() ...
[10:18:31.027] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.027] Resolving globals: FALSE
[10:18:31.027] Tweak future expression to call with '...' arguments ...
[10:18:31.027] {
[10:18:31.027]     do.call(function(...) {
[10:18:31.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.027]             on.exit(options(oopts), add = TRUE)
[10:18:31.027]         }
[10:18:31.027]         {
[10:18:31.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.027]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.027]             })
[10:18:31.027]         }
[10:18:31.027]     }, args = future.call.arguments)
[10:18:31.027] }
[10:18:31.028] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.028] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.028] 
[10:18:31.028] getGlobalsAndPackages() ... DONE
[10:18:31.028] run() for ‘Future’ ...
[10:18:31.029] - state: ‘created’
[10:18:31.029] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.031]   - Field: ‘label’
[10:18:31.031]   - Field: ‘local’
[10:18:31.031]   - Field: ‘owner’
[10:18:31.031]   - Field: ‘envir’
[10:18:31.031]   - Field: ‘packages’
[10:18:31.031]   - Field: ‘gc’
[10:18:31.031]   - Field: ‘conditions’
[10:18:31.031]   - Field: ‘expr’
[10:18:31.031]   - Field: ‘uuid’
[10:18:31.031]   - Field: ‘seed’
[10:18:31.032]   - Field: ‘version’
[10:18:31.032]   - Field: ‘result’
[10:18:31.032]   - Field: ‘asynchronous’
[10:18:31.032]   - Field: ‘calls’
[10:18:31.032]   - Field: ‘globals’
[10:18:31.032]   - Field: ‘stdout’
[10:18:31.032]   - Field: ‘earlySignal’
[10:18:31.032]   - Field: ‘lazy’
[10:18:31.032]   - Field: ‘state’
[10:18:31.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.032] - Launch lazy future ...
[10:18:31.033] Packages needed by the future expression (n = 1): ‘stats’
[10:18:31.033] Packages needed by future strategies (n = 0): <none>
[10:18:31.033] {
[10:18:31.033]     {
[10:18:31.033]         {
[10:18:31.033]             ...future.startTime <- base::Sys.time()
[10:18:31.033]             {
[10:18:31.033]                 {
[10:18:31.033]                   {
[10:18:31.033]                     {
[10:18:31.033]                       base::local({
[10:18:31.033]                         has_future <- base::requireNamespace("future", 
[10:18:31.033]                           quietly = TRUE)
[10:18:31.033]                         if (has_future) {
[10:18:31.033]                           ns <- base::getNamespace("future")
[10:18:31.033]                           version <- ns[[".package"]][["version"]]
[10:18:31.033]                           if (is.null(version)) 
[10:18:31.033]                             version <- utils::packageVersion("future")
[10:18:31.033]                         }
[10:18:31.033]                         else {
[10:18:31.033]                           version <- NULL
[10:18:31.033]                         }
[10:18:31.033]                         if (!has_future || version < "1.8.0") {
[10:18:31.033]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.033]                             "", base::R.version$version.string), 
[10:18:31.033]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.033]                               "release", "version")], collapse = " "), 
[10:18:31.033]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.033]                             info)
[10:18:31.033]                           info <- base::paste(info, collapse = "; ")
[10:18:31.033]                           if (!has_future) {
[10:18:31.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.033]                               info)
[10:18:31.033]                           }
[10:18:31.033]                           else {
[10:18:31.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.033]                               info, version)
[10:18:31.033]                           }
[10:18:31.033]                           base::stop(msg)
[10:18:31.033]                         }
[10:18:31.033]                       })
[10:18:31.033]                     }
[10:18:31.033]                     base::local({
[10:18:31.033]                       for (pkg in "stats") {
[10:18:31.033]                         base::loadNamespace(pkg)
[10:18:31.033]                         base::library(pkg, character.only = TRUE)
[10:18:31.033]                       }
[10:18:31.033]                     })
[10:18:31.033]                   }
[10:18:31.033]                   ...future.strategy.old <- future::plan("list")
[10:18:31.033]                   options(future.plan = NULL)
[10:18:31.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.033]                 }
[10:18:31.033]                 ...future.workdir <- getwd()
[10:18:31.033]             }
[10:18:31.033]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.033]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.033]         }
[10:18:31.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.033]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.033]             base::names(...future.oldOptions))
[10:18:31.033]     }
[10:18:31.033]     if (FALSE) {
[10:18:31.033]     }
[10:18:31.033]     else {
[10:18:31.033]         if (TRUE) {
[10:18:31.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.033]                 open = "w")
[10:18:31.033]         }
[10:18:31.033]         else {
[10:18:31.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.033]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.033]         }
[10:18:31.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.033]             base::sink(type = "output", split = FALSE)
[10:18:31.033]             base::close(...future.stdout)
[10:18:31.033]         }, add = TRUE)
[10:18:31.033]     }
[10:18:31.033]     ...future.frame <- base::sys.nframe()
[10:18:31.033]     ...future.conditions <- base::list()
[10:18:31.033]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.033]     if (FALSE) {
[10:18:31.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.033]     }
[10:18:31.033]     ...future.result <- base::tryCatch({
[10:18:31.033]         base::withCallingHandlers({
[10:18:31.033]             ...future.value <- base::withVisible(base::local({
[10:18:31.033]                 do.call(function(...) {
[10:18:31.033]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.033]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.033]                     ...future.globals.maxSize)) {
[10:18:31.033]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.033]                     on.exit(options(oopts), add = TRUE)
[10:18:31.033]                   }
[10:18:31.033]                   {
[10:18:31.033]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.033]                       FUN = function(jj) {
[10:18:31.033]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.033]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.033]                       })
[10:18:31.033]                   }
[10:18:31.033]                 }, args = future.call.arguments)
[10:18:31.033]             }))
[10:18:31.033]             future::FutureResult(value = ...future.value$value, 
[10:18:31.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.033]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.033]                     ...future.globalenv.names))
[10:18:31.033]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.033]         }, condition = base::local({
[10:18:31.033]             c <- base::c
[10:18:31.033]             inherits <- base::inherits
[10:18:31.033]             invokeRestart <- base::invokeRestart
[10:18:31.033]             length <- base::length
[10:18:31.033]             list <- base::list
[10:18:31.033]             seq.int <- base::seq.int
[10:18:31.033]             signalCondition <- base::signalCondition
[10:18:31.033]             sys.calls <- base::sys.calls
[10:18:31.033]             `[[` <- base::`[[`
[10:18:31.033]             `+` <- base::`+`
[10:18:31.033]             `<<-` <- base::`<<-`
[10:18:31.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.033]                   3L)]
[10:18:31.033]             }
[10:18:31.033]             function(cond) {
[10:18:31.033]                 is_error <- inherits(cond, "error")
[10:18:31.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.033]                   NULL)
[10:18:31.033]                 if (is_error) {
[10:18:31.033]                   sessionInformation <- function() {
[10:18:31.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.033]                       search = base::search(), system = base::Sys.info())
[10:18:31.033]                   }
[10:18:31.033]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.033]                     cond$call), session = sessionInformation(), 
[10:18:31.033]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.033]                   signalCondition(cond)
[10:18:31.033]                 }
[10:18:31.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.033]                 "immediateCondition"))) {
[10:18:31.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.033]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.033]                   if (TRUE && !signal) {
[10:18:31.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.033]                     {
[10:18:31.033]                       inherits <- base::inherits
[10:18:31.033]                       invokeRestart <- base::invokeRestart
[10:18:31.033]                       is.null <- base::is.null
[10:18:31.033]                       muffled <- FALSE
[10:18:31.033]                       if (inherits(cond, "message")) {
[10:18:31.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.033]                         if (muffled) 
[10:18:31.033]                           invokeRestart("muffleMessage")
[10:18:31.033]                       }
[10:18:31.033]                       else if (inherits(cond, "warning")) {
[10:18:31.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.033]                         if (muffled) 
[10:18:31.033]                           invokeRestart("muffleWarning")
[10:18:31.033]                       }
[10:18:31.033]                       else if (inherits(cond, "condition")) {
[10:18:31.033]                         if (!is.null(pattern)) {
[10:18:31.033]                           computeRestarts <- base::computeRestarts
[10:18:31.033]                           grepl <- base::grepl
[10:18:31.033]                           restarts <- computeRestarts(cond)
[10:18:31.033]                           for (restart in restarts) {
[10:18:31.033]                             name <- restart$name
[10:18:31.033]                             if (is.null(name)) 
[10:18:31.033]                               next
[10:18:31.033]                             if (!grepl(pattern, name)) 
[10:18:31.033]                               next
[10:18:31.033]                             invokeRestart(restart)
[10:18:31.033]                             muffled <- TRUE
[10:18:31.033]                             break
[10:18:31.033]                           }
[10:18:31.033]                         }
[10:18:31.033]                       }
[10:18:31.033]                       invisible(muffled)
[10:18:31.033]                     }
[10:18:31.033]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.033]                   }
[10:18:31.033]                 }
[10:18:31.033]                 else {
[10:18:31.033]                   if (TRUE) {
[10:18:31.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.033]                     {
[10:18:31.033]                       inherits <- base::inherits
[10:18:31.033]                       invokeRestart <- base::invokeRestart
[10:18:31.033]                       is.null <- base::is.null
[10:18:31.033]                       muffled <- FALSE
[10:18:31.033]                       if (inherits(cond, "message")) {
[10:18:31.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.033]                         if (muffled) 
[10:18:31.033]                           invokeRestart("muffleMessage")
[10:18:31.033]                       }
[10:18:31.033]                       else if (inherits(cond, "warning")) {
[10:18:31.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.033]                         if (muffled) 
[10:18:31.033]                           invokeRestart("muffleWarning")
[10:18:31.033]                       }
[10:18:31.033]                       else if (inherits(cond, "condition")) {
[10:18:31.033]                         if (!is.null(pattern)) {
[10:18:31.033]                           computeRestarts <- base::computeRestarts
[10:18:31.033]                           grepl <- base::grepl
[10:18:31.033]                           restarts <- computeRestarts(cond)
[10:18:31.033]                           for (restart in restarts) {
[10:18:31.033]                             name <- restart$name
[10:18:31.033]                             if (is.null(name)) 
[10:18:31.033]                               next
[10:18:31.033]                             if (!grepl(pattern, name)) 
[10:18:31.033]                               next
[10:18:31.033]                             invokeRestart(restart)
[10:18:31.033]                             muffled <- TRUE
[10:18:31.033]                             break
[10:18:31.033]                           }
[10:18:31.033]                         }
[10:18:31.033]                       }
[10:18:31.033]                       invisible(muffled)
[10:18:31.033]                     }
[10:18:31.033]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.033]                   }
[10:18:31.033]                 }
[10:18:31.033]             }
[10:18:31.033]         }))
[10:18:31.033]     }, error = function(ex) {
[10:18:31.033]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.033]                 ...future.rng), started = ...future.startTime, 
[10:18:31.033]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.033]             version = "1.8"), class = "FutureResult")
[10:18:31.033]     }, finally = {
[10:18:31.033]         if (!identical(...future.workdir, getwd())) 
[10:18:31.033]             setwd(...future.workdir)
[10:18:31.033]         {
[10:18:31.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.033]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.033]             }
[10:18:31.033]             base::options(...future.oldOptions)
[10:18:31.033]             if (.Platform$OS.type == "windows") {
[10:18:31.033]                 old_names <- names(...future.oldEnvVars)
[10:18:31.033]                 envs <- base::Sys.getenv()
[10:18:31.033]                 names <- names(envs)
[10:18:31.033]                 common <- intersect(names, old_names)
[10:18:31.033]                 added <- setdiff(names, old_names)
[10:18:31.033]                 removed <- setdiff(old_names, names)
[10:18:31.033]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.033]                   envs[common]]
[10:18:31.033]                 NAMES <- toupper(changed)
[10:18:31.033]                 args <- list()
[10:18:31.033]                 for (kk in seq_along(NAMES)) {
[10:18:31.033]                   name <- changed[[kk]]
[10:18:31.033]                   NAME <- NAMES[[kk]]
[10:18:31.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.033]                     next
[10:18:31.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.033]                 }
[10:18:31.033]                 NAMES <- toupper(added)
[10:18:31.033]                 for (kk in seq_along(NAMES)) {
[10:18:31.033]                   name <- added[[kk]]
[10:18:31.033]                   NAME <- NAMES[[kk]]
[10:18:31.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.033]                     next
[10:18:31.033]                   args[[name]] <- ""
[10:18:31.033]                 }
[10:18:31.033]                 NAMES <- toupper(removed)
[10:18:31.033]                 for (kk in seq_along(NAMES)) {
[10:18:31.033]                   name <- removed[[kk]]
[10:18:31.033]                   NAME <- NAMES[[kk]]
[10:18:31.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.033]                     next
[10:18:31.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.033]                 }
[10:18:31.033]                 if (length(args) > 0) 
[10:18:31.033]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.033]             }
[10:18:31.033]             else {
[10:18:31.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.033]             }
[10:18:31.033]             {
[10:18:31.033]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.033]                   0L) {
[10:18:31.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.033]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.033]                   base::options(opts)
[10:18:31.033]                 }
[10:18:31.033]                 {
[10:18:31.033]                   {
[10:18:31.033]                     NULL
[10:18:31.033]                     RNGkind("Mersenne-Twister")
[10:18:31.033]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.033]                       inherits = FALSE)
[10:18:31.033]                   }
[10:18:31.033]                   options(future.plan = NULL)
[10:18:31.033]                   if (is.na(NA_character_)) 
[10:18:31.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.033]                     .init = FALSE)
[10:18:31.033]                 }
[10:18:31.033]             }
[10:18:31.033]         }
[10:18:31.033]     })
[10:18:31.033]     if (TRUE) {
[10:18:31.033]         base::sink(type = "output", split = FALSE)
[10:18:31.033]         if (TRUE) {
[10:18:31.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.033]         }
[10:18:31.033]         else {
[10:18:31.033]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.033]         }
[10:18:31.033]         base::close(...future.stdout)
[10:18:31.033]         ...future.stdout <- NULL
[10:18:31.033]     }
[10:18:31.033]     ...future.result$conditions <- ...future.conditions
[10:18:31.033]     ...future.result$finished <- base::Sys.time()
[10:18:31.033]     ...future.result
[10:18:31.033] }
[10:18:31.035] assign_globals() ...
[10:18:31.035] List of 5
[10:18:31.035]  $ ...future.FUN            :function (x, ...)  
[10:18:31.035]  $ future.call.arguments    :List of 1
[10:18:31.035]   ..$ singular.ok: logi FALSE
[10:18:31.035]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.035]  $ ...future.elements_ii    :List of 3
[10:18:31.035]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.035]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.035]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.035]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.035]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.035]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.035]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.035]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.035]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.035]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.035]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.035]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.035]  $ ...future.seeds_ii       : NULL
[10:18:31.035]  $ ...future.globals.maxSize: NULL
[10:18:31.035]  - attr(*, "where")=List of 5
[10:18:31.035]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.035]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.035]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.035]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.035]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.035]  - attr(*, "resolved")= logi FALSE
[10:18:31.035]  - attr(*, "total_size")= num 19977
[10:18:31.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.035]  - attr(*, "already-done")= logi TRUE
[10:18:31.044] - reassign environment for ‘...future.FUN’
[10:18:31.044] - copied ‘...future.FUN’ to environment
[10:18:31.044] - copied ‘future.call.arguments’ to environment
[10:18:31.044] - copied ‘...future.elements_ii’ to environment
[10:18:31.045] - copied ‘...future.seeds_ii’ to environment
[10:18:31.045] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.045] assign_globals() ... done
[10:18:31.045] plan(): Setting new future strategy stack:
[10:18:31.045] List of future strategies:
[10:18:31.045] 1. sequential:
[10:18:31.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.045]    - tweaked: FALSE
[10:18:31.045]    - call: NULL
[10:18:31.046] plan(): nbrOfWorkers() = 1
[10:18:31.049] plan(): Setting new future strategy stack:
[10:18:31.049] List of future strategies:
[10:18:31.049] 1. multicore:
[10:18:31.049]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:31.049]    - tweaked: FALSE
[10:18:31.049]    - call: plan(strategy)
[10:18:31.052] plan(): nbrOfWorkers() = 1
[10:18:31.052] SequentialFuture started (and completed)
[10:18:31.052] - Launch lazy future ... done
[10:18:31.052] run() for ‘SequentialFuture’ ... done
[10:18:31.052] Created future:
[10:18:31.052] SequentialFuture:
[10:18:31.052] Label: ‘future_by-1’
[10:18:31.052] Expression:
[10:18:31.052] {
[10:18:31.052]     do.call(function(...) {
[10:18:31.052]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.052]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.052]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.052]             on.exit(options(oopts), add = TRUE)
[10:18:31.052]         }
[10:18:31.052]         {
[10:18:31.052]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.052]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.052]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.052]             })
[10:18:31.052]         }
[10:18:31.052]     }, args = future.call.arguments)
[10:18:31.052] }
[10:18:31.052] Lazy evaluation: FALSE
[10:18:31.052] Asynchronous evaluation: FALSE
[10:18:31.052] Local evaluation: TRUE
[10:18:31.052] Environment: R_GlobalEnv
[10:18:31.052] Capture standard output: TRUE
[10:18:31.052] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.052] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.052] Packages: 1 packages (‘stats’)
[10:18:31.052] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.052] Resolved: TRUE
[10:18:31.052] Value: 81.44 KiB of class ‘list’
[10:18:31.052] Early signaling: FALSE
[10:18:31.052] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.052] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.054] Chunk #1 of 1 ... DONE
[10:18:31.054] Launching 1 futures (chunks) ... DONE
[10:18:31.054] Resolving 1 futures (chunks) ...
[10:18:31.054] resolve() on list ...
[10:18:31.054]  recursive: 0
[10:18:31.054]  length: 1
[10:18:31.055] 
[10:18:31.055] resolved() for ‘SequentialFuture’ ...
[10:18:31.055] - state: ‘finished’
[10:18:31.055] - run: TRUE
[10:18:31.055] - result: ‘FutureResult’
[10:18:31.055] resolved() for ‘SequentialFuture’ ... done
[10:18:31.055] Future #1
[10:18:31.055] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.055] - nx: 1
[10:18:31.055] - relay: TRUE
[10:18:31.055] - stdout: TRUE
[10:18:31.056] - signal: TRUE
[10:18:31.056] - resignal: FALSE
[10:18:31.056] - force: TRUE
[10:18:31.056] - relayed: [n=1] FALSE
[10:18:31.056] - queued futures: [n=1] FALSE
[10:18:31.056]  - until=1
[10:18:31.056]  - relaying element #1
[10:18:31.056] - relayed: [n=1] TRUE
[10:18:31.056] - queued futures: [n=1] TRUE
[10:18:31.056] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.057]  length: 0 (resolved future 1)
[10:18:31.057] Relaying remaining futures
[10:18:31.057] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.057] - nx: 1
[10:18:31.057] - relay: TRUE
[10:18:31.057] - stdout: TRUE
[10:18:31.057] - signal: TRUE
[10:18:31.057] - resignal: FALSE
[10:18:31.057] - force: TRUE
[10:18:31.057] - relayed: [n=1] TRUE
[10:18:31.057] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.057] - relayed: [n=1] TRUE
[10:18:31.058] - queued futures: [n=1] TRUE
[10:18:31.058] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.058] resolve() on list ... DONE
[10:18:31.058]  - Number of value chunks collected: 1
[10:18:31.058] Resolving 1 futures (chunks) ... DONE
[10:18:31.058] Reducing values from 1 chunks ...
[10:18:31.058]  - Number of values collected after concatenation: 3
[10:18:31.058]  - Number of values expected: 3
[10:18:31.058] Reducing values from 1 chunks ... DONE
[10:18:31.058] future_lapply() ... DONE
[10:18:31.058] future_by_internal() ... DONE
[10:18:31.062] future_by_internal() ...
[10:18:31.063] future_lapply() ...
[10:18:31.065] Number of chunks: 1
[10:18:31.065] getGlobalsAndPackagesXApply() ...
[10:18:31.065]  - future.globals: TRUE
[10:18:31.065] getGlobalsAndPackages() ...
[10:18:31.065] Searching for globals...
[10:18:31.067] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:31.067] Searching for globals ... DONE
[10:18:31.067] Resolving globals: FALSE
[10:18:31.067] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:18:31.068] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:18:31.068] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:31.068] - packages: [1] ‘stats’
[10:18:31.068] getGlobalsAndPackages() ... DONE
[10:18:31.068]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:31.068]  - needed namespaces: [n=1] ‘stats’
[10:18:31.068] Finding globals ... DONE
[10:18:31.068]  - use_args: TRUE
[10:18:31.068]  - Getting '...' globals ...
[10:18:31.069] resolve() on list ...
[10:18:31.069]  recursive: 0
[10:18:31.069]  length: 1
[10:18:31.069]  elements: ‘...’
[10:18:31.069]  length: 0 (resolved future 1)
[10:18:31.069] resolve() on list ... DONE
[10:18:31.069]    - '...' content: [n=0] 
[10:18:31.069] List of 1
[10:18:31.069]  $ ...: list()
[10:18:31.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.069]  - attr(*, "where")=List of 1
[10:18:31.069]   ..$ ...:<environment: 0x55844a23b470> 
[10:18:31.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.069]  - attr(*, "resolved")= logi TRUE
[10:18:31.069]  - attr(*, "total_size")= num NA
[10:18:31.073]  - Getting '...' globals ... DONE
[10:18:31.073] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:18:31.073] List of 4
[10:18:31.073]  $ ...future.FUN:function (x)  
[10:18:31.073]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:31.073]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.073]  $ ...          : list()
[10:18:31.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.073]  - attr(*, "where")=List of 4
[10:18:31.073]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.073]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:18:31.073]   ..$ wool         :<environment: R_EmptyEnv> 
[10:18:31.073]   ..$ ...          :<environment: 0x55844a23b470> 
[10:18:31.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.073]  - attr(*, "resolved")= logi FALSE
[10:18:31.073]  - attr(*, "total_size")= num 18867
[10:18:31.077] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:31.077] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.078] Number of futures (= number of chunks): 1
[10:18:31.078] Launching 1 futures (chunks) ...
[10:18:31.078] Chunk #1 of 1 ...
[10:18:31.078]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.078] getGlobalsAndPackages() ...
[10:18:31.078] Searching for globals...
[10:18:31.078] 
[10:18:31.079] Searching for globals ... DONE
[10:18:31.079] - globals: [0] <none>
[10:18:31.079] getGlobalsAndPackages() ... DONE
[10:18:31.079]    + additional globals found: [n=0] 
[10:18:31.079]    + additional namespaces needed: [n=0] 
[10:18:31.079]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.079]  - seeds: <none>
[10:18:31.079]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.079] getGlobalsAndPackages() ...
[10:18:31.079] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.079] Resolving globals: FALSE
[10:18:31.080] Tweak future expression to call with '...' arguments ...
[10:18:31.080] {
[10:18:31.080]     do.call(function(...) {
[10:18:31.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.080]             on.exit(options(oopts), add = TRUE)
[10:18:31.080]         }
[10:18:31.080]         {
[10:18:31.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.080]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.080]             })
[10:18:31.080]         }
[10:18:31.080]     }, args = future.call.arguments)
[10:18:31.080] }
[10:18:31.080] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.080] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.080] 
[10:18:31.080] getGlobalsAndPackages() ... DONE
[10:18:31.081] run() for ‘Future’ ...
[10:18:31.081] - state: ‘created’
[10:18:31.081] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.083] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.083] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.083]   - Field: ‘label’
[10:18:31.083]   - Field: ‘local’
[10:18:31.083]   - Field: ‘owner’
[10:18:31.083]   - Field: ‘envir’
[10:18:31.083]   - Field: ‘packages’
[10:18:31.083]   - Field: ‘gc’
[10:18:31.083]   - Field: ‘conditions’
[10:18:31.083]   - Field: ‘expr’
[10:18:31.084]   - Field: ‘uuid’
[10:18:31.084]   - Field: ‘seed’
[10:18:31.084]   - Field: ‘version’
[10:18:31.084]   - Field: ‘result’
[10:18:31.084]   - Field: ‘asynchronous’
[10:18:31.084]   - Field: ‘calls’
[10:18:31.084]   - Field: ‘globals’
[10:18:31.084]   - Field: ‘stdout’
[10:18:31.084]   - Field: ‘earlySignal’
[10:18:31.084]   - Field: ‘lazy’
[10:18:31.084]   - Field: ‘state’
[10:18:31.084] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.085] - Launch lazy future ...
[10:18:31.085] Packages needed by the future expression (n = 1): ‘stats’
[10:18:31.085] Packages needed by future strategies (n = 0): <none>
[10:18:31.085] {
[10:18:31.085]     {
[10:18:31.085]         {
[10:18:31.085]             ...future.startTime <- base::Sys.time()
[10:18:31.085]             {
[10:18:31.085]                 {
[10:18:31.085]                   {
[10:18:31.085]                     {
[10:18:31.085]                       base::local({
[10:18:31.085]                         has_future <- base::requireNamespace("future", 
[10:18:31.085]                           quietly = TRUE)
[10:18:31.085]                         if (has_future) {
[10:18:31.085]                           ns <- base::getNamespace("future")
[10:18:31.085]                           version <- ns[[".package"]][["version"]]
[10:18:31.085]                           if (is.null(version)) 
[10:18:31.085]                             version <- utils::packageVersion("future")
[10:18:31.085]                         }
[10:18:31.085]                         else {
[10:18:31.085]                           version <- NULL
[10:18:31.085]                         }
[10:18:31.085]                         if (!has_future || version < "1.8.0") {
[10:18:31.085]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.085]                             "", base::R.version$version.string), 
[10:18:31.085]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.085]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.085]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.085]                               "release", "version")], collapse = " "), 
[10:18:31.085]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.085]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.085]                             info)
[10:18:31.085]                           info <- base::paste(info, collapse = "; ")
[10:18:31.085]                           if (!has_future) {
[10:18:31.085]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.085]                               info)
[10:18:31.085]                           }
[10:18:31.085]                           else {
[10:18:31.085]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.085]                               info, version)
[10:18:31.085]                           }
[10:18:31.085]                           base::stop(msg)
[10:18:31.085]                         }
[10:18:31.085]                       })
[10:18:31.085]                     }
[10:18:31.085]                     base::local({
[10:18:31.085]                       for (pkg in "stats") {
[10:18:31.085]                         base::loadNamespace(pkg)
[10:18:31.085]                         base::library(pkg, character.only = TRUE)
[10:18:31.085]                       }
[10:18:31.085]                     })
[10:18:31.085]                   }
[10:18:31.085]                   ...future.strategy.old <- future::plan("list")
[10:18:31.085]                   options(future.plan = NULL)
[10:18:31.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.085]                 }
[10:18:31.085]                 ...future.workdir <- getwd()
[10:18:31.085]             }
[10:18:31.085]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.085]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.085]         }
[10:18:31.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.085]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.085]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.085]             base::names(...future.oldOptions))
[10:18:31.085]     }
[10:18:31.085]     if (FALSE) {
[10:18:31.085]     }
[10:18:31.085]     else {
[10:18:31.085]         if (TRUE) {
[10:18:31.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.085]                 open = "w")
[10:18:31.085]         }
[10:18:31.085]         else {
[10:18:31.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.085]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.085]         }
[10:18:31.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.085]             base::sink(type = "output", split = FALSE)
[10:18:31.085]             base::close(...future.stdout)
[10:18:31.085]         }, add = TRUE)
[10:18:31.085]     }
[10:18:31.085]     ...future.frame <- base::sys.nframe()
[10:18:31.085]     ...future.conditions <- base::list()
[10:18:31.085]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.085]     if (FALSE) {
[10:18:31.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.085]     }
[10:18:31.085]     ...future.result <- base::tryCatch({
[10:18:31.085]         base::withCallingHandlers({
[10:18:31.085]             ...future.value <- base::withVisible(base::local({
[10:18:31.085]                 do.call(function(...) {
[10:18:31.085]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.085]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.085]                     ...future.globals.maxSize)) {
[10:18:31.085]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.085]                     on.exit(options(oopts), add = TRUE)
[10:18:31.085]                   }
[10:18:31.085]                   {
[10:18:31.085]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.085]                       FUN = function(jj) {
[10:18:31.085]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.085]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.085]                       })
[10:18:31.085]                   }
[10:18:31.085]                 }, args = future.call.arguments)
[10:18:31.085]             }))
[10:18:31.085]             future::FutureResult(value = ...future.value$value, 
[10:18:31.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.085]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.085]                     ...future.globalenv.names))
[10:18:31.085]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.085]         }, condition = base::local({
[10:18:31.085]             c <- base::c
[10:18:31.085]             inherits <- base::inherits
[10:18:31.085]             invokeRestart <- base::invokeRestart
[10:18:31.085]             length <- base::length
[10:18:31.085]             list <- base::list
[10:18:31.085]             seq.int <- base::seq.int
[10:18:31.085]             signalCondition <- base::signalCondition
[10:18:31.085]             sys.calls <- base::sys.calls
[10:18:31.085]             `[[` <- base::`[[`
[10:18:31.085]             `+` <- base::`+`
[10:18:31.085]             `<<-` <- base::`<<-`
[10:18:31.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.085]                   3L)]
[10:18:31.085]             }
[10:18:31.085]             function(cond) {
[10:18:31.085]                 is_error <- inherits(cond, "error")
[10:18:31.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.085]                   NULL)
[10:18:31.085]                 if (is_error) {
[10:18:31.085]                   sessionInformation <- function() {
[10:18:31.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.085]                       search = base::search(), system = base::Sys.info())
[10:18:31.085]                   }
[10:18:31.085]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.085]                     cond$call), session = sessionInformation(), 
[10:18:31.085]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.085]                   signalCondition(cond)
[10:18:31.085]                 }
[10:18:31.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.085]                 "immediateCondition"))) {
[10:18:31.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.085]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.085]                   if (TRUE && !signal) {
[10:18:31.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.085]                     {
[10:18:31.085]                       inherits <- base::inherits
[10:18:31.085]                       invokeRestart <- base::invokeRestart
[10:18:31.085]                       is.null <- base::is.null
[10:18:31.085]                       muffled <- FALSE
[10:18:31.085]                       if (inherits(cond, "message")) {
[10:18:31.085]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.085]                         if (muffled) 
[10:18:31.085]                           invokeRestart("muffleMessage")
[10:18:31.085]                       }
[10:18:31.085]                       else if (inherits(cond, "warning")) {
[10:18:31.085]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.085]                         if (muffled) 
[10:18:31.085]                           invokeRestart("muffleWarning")
[10:18:31.085]                       }
[10:18:31.085]                       else if (inherits(cond, "condition")) {
[10:18:31.085]                         if (!is.null(pattern)) {
[10:18:31.085]                           computeRestarts <- base::computeRestarts
[10:18:31.085]                           grepl <- base::grepl
[10:18:31.085]                           restarts <- computeRestarts(cond)
[10:18:31.085]                           for (restart in restarts) {
[10:18:31.085]                             name <- restart$name
[10:18:31.085]                             if (is.null(name)) 
[10:18:31.085]                               next
[10:18:31.085]                             if (!grepl(pattern, name)) 
[10:18:31.085]                               next
[10:18:31.085]                             invokeRestart(restart)
[10:18:31.085]                             muffled <- TRUE
[10:18:31.085]                             break
[10:18:31.085]                           }
[10:18:31.085]                         }
[10:18:31.085]                       }
[10:18:31.085]                       invisible(muffled)
[10:18:31.085]                     }
[10:18:31.085]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.085]                   }
[10:18:31.085]                 }
[10:18:31.085]                 else {
[10:18:31.085]                   if (TRUE) {
[10:18:31.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.085]                     {
[10:18:31.085]                       inherits <- base::inherits
[10:18:31.085]                       invokeRestart <- base::invokeRestart
[10:18:31.085]                       is.null <- base::is.null
[10:18:31.085]                       muffled <- FALSE
[10:18:31.085]                       if (inherits(cond, "message")) {
[10:18:31.085]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.085]                         if (muffled) 
[10:18:31.085]                           invokeRestart("muffleMessage")
[10:18:31.085]                       }
[10:18:31.085]                       else if (inherits(cond, "warning")) {
[10:18:31.085]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.085]                         if (muffled) 
[10:18:31.085]                           invokeRestart("muffleWarning")
[10:18:31.085]                       }
[10:18:31.085]                       else if (inherits(cond, "condition")) {
[10:18:31.085]                         if (!is.null(pattern)) {
[10:18:31.085]                           computeRestarts <- base::computeRestarts
[10:18:31.085]                           grepl <- base::grepl
[10:18:31.085]                           restarts <- computeRestarts(cond)
[10:18:31.085]                           for (restart in restarts) {
[10:18:31.085]                             name <- restart$name
[10:18:31.085]                             if (is.null(name)) 
[10:18:31.085]                               next
[10:18:31.085]                             if (!grepl(pattern, name)) 
[10:18:31.085]                               next
[10:18:31.085]                             invokeRestart(restart)
[10:18:31.085]                             muffled <- TRUE
[10:18:31.085]                             break
[10:18:31.085]                           }
[10:18:31.085]                         }
[10:18:31.085]                       }
[10:18:31.085]                       invisible(muffled)
[10:18:31.085]                     }
[10:18:31.085]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.085]                   }
[10:18:31.085]                 }
[10:18:31.085]             }
[10:18:31.085]         }))
[10:18:31.085]     }, error = function(ex) {
[10:18:31.085]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.085]                 ...future.rng), started = ...future.startTime, 
[10:18:31.085]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.085]             version = "1.8"), class = "FutureResult")
[10:18:31.085]     }, finally = {
[10:18:31.085]         if (!identical(...future.workdir, getwd())) 
[10:18:31.085]             setwd(...future.workdir)
[10:18:31.085]         {
[10:18:31.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.085]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.085]             }
[10:18:31.085]             base::options(...future.oldOptions)
[10:18:31.085]             if (.Platform$OS.type == "windows") {
[10:18:31.085]                 old_names <- names(...future.oldEnvVars)
[10:18:31.085]                 envs <- base::Sys.getenv()
[10:18:31.085]                 names <- names(envs)
[10:18:31.085]                 common <- intersect(names, old_names)
[10:18:31.085]                 added <- setdiff(names, old_names)
[10:18:31.085]                 removed <- setdiff(old_names, names)
[10:18:31.085]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.085]                   envs[common]]
[10:18:31.085]                 NAMES <- toupper(changed)
[10:18:31.085]                 args <- list()
[10:18:31.085]                 for (kk in seq_along(NAMES)) {
[10:18:31.085]                   name <- changed[[kk]]
[10:18:31.085]                   NAME <- NAMES[[kk]]
[10:18:31.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.085]                     next
[10:18:31.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.085]                 }
[10:18:31.085]                 NAMES <- toupper(added)
[10:18:31.085]                 for (kk in seq_along(NAMES)) {
[10:18:31.085]                   name <- added[[kk]]
[10:18:31.085]                   NAME <- NAMES[[kk]]
[10:18:31.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.085]                     next
[10:18:31.085]                   args[[name]] <- ""
[10:18:31.085]                 }
[10:18:31.085]                 NAMES <- toupper(removed)
[10:18:31.085]                 for (kk in seq_along(NAMES)) {
[10:18:31.085]                   name <- removed[[kk]]
[10:18:31.085]                   NAME <- NAMES[[kk]]
[10:18:31.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.085]                     next
[10:18:31.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.085]                 }
[10:18:31.085]                 if (length(args) > 0) 
[10:18:31.085]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.085]             }
[10:18:31.085]             else {
[10:18:31.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.085]             }
[10:18:31.085]             {
[10:18:31.085]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.085]                   0L) {
[10:18:31.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.085]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.085]                   base::options(opts)
[10:18:31.085]                 }
[10:18:31.085]                 {
[10:18:31.085]                   {
[10:18:31.085]                     NULL
[10:18:31.085]                     RNGkind("Mersenne-Twister")
[10:18:31.085]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.085]                       inherits = FALSE)
[10:18:31.085]                   }
[10:18:31.085]                   options(future.plan = NULL)
[10:18:31.085]                   if (is.na(NA_character_)) 
[10:18:31.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.085]                     .init = FALSE)
[10:18:31.085]                 }
[10:18:31.085]             }
[10:18:31.085]         }
[10:18:31.085]     })
[10:18:31.085]     if (TRUE) {
[10:18:31.085]         base::sink(type = "output", split = FALSE)
[10:18:31.085]         if (TRUE) {
[10:18:31.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.085]         }
[10:18:31.085]         else {
[10:18:31.085]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.085]         }
[10:18:31.085]         base::close(...future.stdout)
[10:18:31.085]         ...future.stdout <- NULL
[10:18:31.085]     }
[10:18:31.085]     ...future.result$conditions <- ...future.conditions
[10:18:31.085]     ...future.result$finished <- base::Sys.time()
[10:18:31.085]     ...future.result
[10:18:31.085] }
[10:18:31.087] assign_globals() ...
[10:18:31.087] List of 7
[10:18:31.087]  $ ...future.FUN            :function (x)  
[10:18:31.087]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:31.087]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.087]  $ future.call.arguments    : list()
[10:18:31.087]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.087]  $ ...future.elements_ii    :List of 3
[10:18:31.087]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.087]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.087]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.087]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.087]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.087]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.087]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.087]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.087]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.087]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.087]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.087]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.087]  $ ...future.seeds_ii       : NULL
[10:18:31.087]  $ ...future.globals.maxSize: NULL
[10:18:31.087]  - attr(*, "where")=List of 7
[10:18:31.087]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.087]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:18:31.087]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:18:31.087]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.087]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.087]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.087]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.087]  - attr(*, "resolved")= logi FALSE
[10:18:31.087]  - attr(*, "total_size")= num 18867
[10:18:31.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.087]  - attr(*, "already-done")= logi TRUE
[10:18:31.098] - reassign environment for ‘...future.FUN’
[10:18:31.098] - copied ‘...future.FUN’ to environment
[10:18:31.099] - copied ‘breaks’ to environment
[10:18:31.099] - copied ‘wool’ to environment
[10:18:31.099] - copied ‘future.call.arguments’ to environment
[10:18:31.099] - copied ‘...future.elements_ii’ to environment
[10:18:31.099] - copied ‘...future.seeds_ii’ to environment
[10:18:31.099] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.099] assign_globals() ... done
[10:18:31.099] plan(): Setting new future strategy stack:
[10:18:31.100] List of future strategies:
[10:18:31.100] 1. sequential:
[10:18:31.100]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.100]    - tweaked: FALSE
[10:18:31.100]    - call: NULL
[10:18:31.100] plan(): nbrOfWorkers() = 1
[10:18:31.103] plan(): Setting new future strategy stack:
[10:18:31.103] List of future strategies:
[10:18:31.103] 1. multicore:
[10:18:31.103]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:31.103]    - tweaked: FALSE
[10:18:31.103]    - call: plan(strategy)
[10:18:31.105] plan(): nbrOfWorkers() = 1
[10:18:31.105] SequentialFuture started (and completed)
[10:18:31.105] - Launch lazy future ... done
[10:18:31.105] run() for ‘SequentialFuture’ ... done
[10:18:31.105] Created future:
[10:18:31.105] SequentialFuture:
[10:18:31.105] Label: ‘future_by-1’
[10:18:31.105] Expression:
[10:18:31.105] {
[10:18:31.105]     do.call(function(...) {
[10:18:31.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.105]             on.exit(options(oopts), add = TRUE)
[10:18:31.105]         }
[10:18:31.105]         {
[10:18:31.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.105]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.105]             })
[10:18:31.105]         }
[10:18:31.105]     }, args = future.call.arguments)
[10:18:31.105] }
[10:18:31.105] Lazy evaluation: FALSE
[10:18:31.105] Asynchronous evaluation: FALSE
[10:18:31.105] Local evaluation: TRUE
[10:18:31.105] Environment: 0x55844a204cb0
[10:18:31.105] Capture standard output: TRUE
[10:18:31.105] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.105] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[10:18:31.105] Packages: 1 packages (‘stats’)
[10:18:31.105] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.105] Resolved: TRUE
[10:18:31.105] Value: 82.82 KiB of class ‘list’
[10:18:31.105] Early signaling: FALSE
[10:18:31.105] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.105] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.107] Chunk #1 of 1 ... DONE
[10:18:31.107] Launching 1 futures (chunks) ... DONE
[10:18:31.107] Resolving 1 futures (chunks) ...
[10:18:31.107] resolve() on list ...
[10:18:31.107]  recursive: 0
[10:18:31.107]  length: 1
[10:18:31.107] 
[10:18:31.107] resolved() for ‘SequentialFuture’ ...
[10:18:31.107] - state: ‘finished’
[10:18:31.107] - run: TRUE
[10:18:31.108] - result: ‘FutureResult’
[10:18:31.108] resolved() for ‘SequentialFuture’ ... done
[10:18:31.108] Future #1
[10:18:31.108] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.108] - nx: 1
[10:18:31.108] - relay: TRUE
[10:18:31.108] - stdout: TRUE
[10:18:31.108] - signal: TRUE
[10:18:31.108] - resignal: FALSE
[10:18:31.108] - force: TRUE
[10:18:31.108] - relayed: [n=1] FALSE
[10:18:31.108] - queued futures: [n=1] FALSE
[10:18:31.109]  - until=1
[10:18:31.109]  - relaying element #1
[10:18:31.109] - relayed: [n=1] TRUE
[10:18:31.109] - queued futures: [n=1] TRUE
[10:18:31.109] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.109]  length: 0 (resolved future 1)
[10:18:31.109] Relaying remaining futures
[10:18:31.109] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.109] - nx: 1
[10:18:31.109] - relay: TRUE
[10:18:31.110] - stdout: TRUE
[10:18:31.110] - signal: TRUE
[10:18:31.110] - resignal: FALSE
[10:18:31.110] - force: TRUE
[10:18:31.110] - relayed: [n=1] TRUE
[10:18:31.110] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.110] - relayed: [n=1] TRUE
[10:18:31.110] - queued futures: [n=1] TRUE
[10:18:31.110] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.110] resolve() on list ... DONE
[10:18:31.110]  - Number of value chunks collected: 1
[10:18:31.111] Resolving 1 futures (chunks) ... DONE
[10:18:31.111] Reducing values from 1 chunks ...
[10:18:31.111]  - Number of values collected after concatenation: 3
[10:18:31.111]  - Number of values expected: 3
[10:18:31.111] Reducing values from 1 chunks ... DONE
[10:18:31.111] future_lapply() ... DONE
[10:18:31.111] future_by_internal() ... DONE
[10:18:31.111] future_by_internal() ...
[10:18:31.112] future_lapply() ...
[10:18:31.113] Number of chunks: 1
[10:18:31.114] getGlobalsAndPackagesXApply() ...
[10:18:31.114]  - future.globals: TRUE
[10:18:31.114] getGlobalsAndPackages() ...
[10:18:31.114] Searching for globals...
[10:18:31.115] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.115] Searching for globals ... DONE
[10:18:31.115] Resolving globals: FALSE
[10:18:31.115] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.116] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.116] - globals: [1] ‘FUN’
[10:18:31.116] 
[10:18:31.116] getGlobalsAndPackages() ... DONE
[10:18:31.116]  - globals found/used: [n=1] ‘FUN’
[10:18:31.116]  - needed namespaces: [n=0] 
[10:18:31.116] Finding globals ... DONE
[10:18:31.116]  - use_args: TRUE
[10:18:31.116]  - Getting '...' globals ...
[10:18:31.117] resolve() on list ...
[10:18:31.117]  recursive: 0
[10:18:31.117]  length: 1
[10:18:31.117]  elements: ‘...’
[10:18:31.117]  length: 0 (resolved future 1)
[10:18:31.117] resolve() on list ... DONE
[10:18:31.117]    - '...' content: [n=0] 
[10:18:31.117] List of 1
[10:18:31.117]  $ ...: list()
[10:18:31.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.117]  - attr(*, "where")=List of 1
[10:18:31.117]   ..$ ...:<environment: 0x55844a470d80> 
[10:18:31.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.117]  - attr(*, "resolved")= logi TRUE
[10:18:31.117]  - attr(*, "total_size")= num NA
[10:18:31.121]  - Getting '...' globals ... DONE
[10:18:31.122] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.122] List of 2
[10:18:31.122]  $ ...future.FUN:function (object, ...)  
[10:18:31.122]  $ ...          : list()
[10:18:31.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.122]  - attr(*, "where")=List of 2
[10:18:31.122]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.122]   ..$ ...          :<environment: 0x55844a470d80> 
[10:18:31.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.122]  - attr(*, "resolved")= logi FALSE
[10:18:31.122]  - attr(*, "total_size")= num 19278
[10:18:31.124] Packages to be attached in all futures: [n=0] 
[10:18:31.124] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.124] Number of futures (= number of chunks): 1
[10:18:31.125] Launching 1 futures (chunks) ...
[10:18:31.125] Chunk #1 of 1 ...
[10:18:31.125]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.125] getGlobalsAndPackages() ...
[10:18:31.125] Searching for globals...
[10:18:31.125] 
[10:18:31.126] Searching for globals ... DONE
[10:18:31.126] - globals: [0] <none>
[10:18:31.126] getGlobalsAndPackages() ... DONE
[10:18:31.126]    + additional globals found: [n=0] 
[10:18:31.126]    + additional namespaces needed: [n=0] 
[10:18:31.126]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.126]  - seeds: <none>
[10:18:31.126]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.126] getGlobalsAndPackages() ...
[10:18:31.126] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.126] Resolving globals: FALSE
[10:18:31.127] Tweak future expression to call with '...' arguments ...
[10:18:31.127] {
[10:18:31.127]     do.call(function(...) {
[10:18:31.127]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.127]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.127]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.127]             on.exit(options(oopts), add = TRUE)
[10:18:31.127]         }
[10:18:31.127]         {
[10:18:31.127]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.127]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.127]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.127]             })
[10:18:31.127]         }
[10:18:31.127]     }, args = future.call.arguments)
[10:18:31.127] }
[10:18:31.127] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.127] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.127] 
[10:18:31.127] getGlobalsAndPackages() ... DONE
[10:18:31.128] run() for ‘Future’ ...
[10:18:31.128] - state: ‘created’
[10:18:31.128] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.130] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.130] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.130]   - Field: ‘label’
[10:18:31.130]   - Field: ‘local’
[10:18:31.130]   - Field: ‘owner’
[10:18:31.130]   - Field: ‘envir’
[10:18:31.130]   - Field: ‘packages’
[10:18:31.130]   - Field: ‘gc’
[10:18:31.130]   - Field: ‘conditions’
[10:18:31.130]   - Field: ‘expr’
[10:18:31.131]   - Field: ‘uuid’
[10:18:31.131]   - Field: ‘seed’
[10:18:31.131]   - Field: ‘version’
[10:18:31.131]   - Field: ‘result’
[10:18:31.131]   - Field: ‘asynchronous’
[10:18:31.131]   - Field: ‘calls’
[10:18:31.131]   - Field: ‘globals’
[10:18:31.131]   - Field: ‘stdout’
[10:18:31.131]   - Field: ‘earlySignal’
[10:18:31.131]   - Field: ‘lazy’
[10:18:31.131]   - Field: ‘state’
[10:18:31.131] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.132] - Launch lazy future ...
[10:18:31.132] Packages needed by the future expression (n = 0): <none>
[10:18:31.132] Packages needed by future strategies (n = 0): <none>
[10:18:31.132] {
[10:18:31.132]     {
[10:18:31.132]         {
[10:18:31.132]             ...future.startTime <- base::Sys.time()
[10:18:31.132]             {
[10:18:31.132]                 {
[10:18:31.132]                   {
[10:18:31.132]                     base::local({
[10:18:31.132]                       has_future <- base::requireNamespace("future", 
[10:18:31.132]                         quietly = TRUE)
[10:18:31.132]                       if (has_future) {
[10:18:31.132]                         ns <- base::getNamespace("future")
[10:18:31.132]                         version <- ns[[".package"]][["version"]]
[10:18:31.132]                         if (is.null(version)) 
[10:18:31.132]                           version <- utils::packageVersion("future")
[10:18:31.132]                       }
[10:18:31.132]                       else {
[10:18:31.132]                         version <- NULL
[10:18:31.132]                       }
[10:18:31.132]                       if (!has_future || version < "1.8.0") {
[10:18:31.132]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.132]                           "", base::R.version$version.string), 
[10:18:31.132]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.132]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.132]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.132]                             "release", "version")], collapse = " "), 
[10:18:31.132]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.132]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.132]                           info)
[10:18:31.132]                         info <- base::paste(info, collapse = "; ")
[10:18:31.132]                         if (!has_future) {
[10:18:31.132]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.132]                             info)
[10:18:31.132]                         }
[10:18:31.132]                         else {
[10:18:31.132]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.132]                             info, version)
[10:18:31.132]                         }
[10:18:31.132]                         base::stop(msg)
[10:18:31.132]                       }
[10:18:31.132]                     })
[10:18:31.132]                   }
[10:18:31.132]                   ...future.strategy.old <- future::plan("list")
[10:18:31.132]                   options(future.plan = NULL)
[10:18:31.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.132]                 }
[10:18:31.132]                 ...future.workdir <- getwd()
[10:18:31.132]             }
[10:18:31.132]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.132]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.132]         }
[10:18:31.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.132]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.132]             base::names(...future.oldOptions))
[10:18:31.132]     }
[10:18:31.132]     if (FALSE) {
[10:18:31.132]     }
[10:18:31.132]     else {
[10:18:31.132]         if (TRUE) {
[10:18:31.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.132]                 open = "w")
[10:18:31.132]         }
[10:18:31.132]         else {
[10:18:31.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.132]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.132]         }
[10:18:31.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.132]             base::sink(type = "output", split = FALSE)
[10:18:31.132]             base::close(...future.stdout)
[10:18:31.132]         }, add = TRUE)
[10:18:31.132]     }
[10:18:31.132]     ...future.frame <- base::sys.nframe()
[10:18:31.132]     ...future.conditions <- base::list()
[10:18:31.132]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.132]     if (FALSE) {
[10:18:31.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.132]     }
[10:18:31.132]     ...future.result <- base::tryCatch({
[10:18:31.132]         base::withCallingHandlers({
[10:18:31.132]             ...future.value <- base::withVisible(base::local({
[10:18:31.132]                 do.call(function(...) {
[10:18:31.132]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.132]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.132]                     ...future.globals.maxSize)) {
[10:18:31.132]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.132]                     on.exit(options(oopts), add = TRUE)
[10:18:31.132]                   }
[10:18:31.132]                   {
[10:18:31.132]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.132]                       FUN = function(jj) {
[10:18:31.132]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.132]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.132]                       })
[10:18:31.132]                   }
[10:18:31.132]                 }, args = future.call.arguments)
[10:18:31.132]             }))
[10:18:31.132]             future::FutureResult(value = ...future.value$value, 
[10:18:31.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.132]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.132]                     ...future.globalenv.names))
[10:18:31.132]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.132]         }, condition = base::local({
[10:18:31.132]             c <- base::c
[10:18:31.132]             inherits <- base::inherits
[10:18:31.132]             invokeRestart <- base::invokeRestart
[10:18:31.132]             length <- base::length
[10:18:31.132]             list <- base::list
[10:18:31.132]             seq.int <- base::seq.int
[10:18:31.132]             signalCondition <- base::signalCondition
[10:18:31.132]             sys.calls <- base::sys.calls
[10:18:31.132]             `[[` <- base::`[[`
[10:18:31.132]             `+` <- base::`+`
[10:18:31.132]             `<<-` <- base::`<<-`
[10:18:31.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.132]                   3L)]
[10:18:31.132]             }
[10:18:31.132]             function(cond) {
[10:18:31.132]                 is_error <- inherits(cond, "error")
[10:18:31.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.132]                   NULL)
[10:18:31.132]                 if (is_error) {
[10:18:31.132]                   sessionInformation <- function() {
[10:18:31.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.132]                       search = base::search(), system = base::Sys.info())
[10:18:31.132]                   }
[10:18:31.132]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.132]                     cond$call), session = sessionInformation(), 
[10:18:31.132]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.132]                   signalCondition(cond)
[10:18:31.132]                 }
[10:18:31.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.132]                 "immediateCondition"))) {
[10:18:31.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.132]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.132]                   if (TRUE && !signal) {
[10:18:31.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.132]                     {
[10:18:31.132]                       inherits <- base::inherits
[10:18:31.132]                       invokeRestart <- base::invokeRestart
[10:18:31.132]                       is.null <- base::is.null
[10:18:31.132]                       muffled <- FALSE
[10:18:31.132]                       if (inherits(cond, "message")) {
[10:18:31.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.132]                         if (muffled) 
[10:18:31.132]                           invokeRestart("muffleMessage")
[10:18:31.132]                       }
[10:18:31.132]                       else if (inherits(cond, "warning")) {
[10:18:31.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.132]                         if (muffled) 
[10:18:31.132]                           invokeRestart("muffleWarning")
[10:18:31.132]                       }
[10:18:31.132]                       else if (inherits(cond, "condition")) {
[10:18:31.132]                         if (!is.null(pattern)) {
[10:18:31.132]                           computeRestarts <- base::computeRestarts
[10:18:31.132]                           grepl <- base::grepl
[10:18:31.132]                           restarts <- computeRestarts(cond)
[10:18:31.132]                           for (restart in restarts) {
[10:18:31.132]                             name <- restart$name
[10:18:31.132]                             if (is.null(name)) 
[10:18:31.132]                               next
[10:18:31.132]                             if (!grepl(pattern, name)) 
[10:18:31.132]                               next
[10:18:31.132]                             invokeRestart(restart)
[10:18:31.132]                             muffled <- TRUE
[10:18:31.132]                             break
[10:18:31.132]                           }
[10:18:31.132]                         }
[10:18:31.132]                       }
[10:18:31.132]                       invisible(muffled)
[10:18:31.132]                     }
[10:18:31.132]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.132]                   }
[10:18:31.132]                 }
[10:18:31.132]                 else {
[10:18:31.132]                   if (TRUE) {
[10:18:31.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.132]                     {
[10:18:31.132]                       inherits <- base::inherits
[10:18:31.132]                       invokeRestart <- base::invokeRestart
[10:18:31.132]                       is.null <- base::is.null
[10:18:31.132]                       muffled <- FALSE
[10:18:31.132]                       if (inherits(cond, "message")) {
[10:18:31.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.132]                         if (muffled) 
[10:18:31.132]                           invokeRestart("muffleMessage")
[10:18:31.132]                       }
[10:18:31.132]                       else if (inherits(cond, "warning")) {
[10:18:31.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.132]                         if (muffled) 
[10:18:31.132]                           invokeRestart("muffleWarning")
[10:18:31.132]                       }
[10:18:31.132]                       else if (inherits(cond, "condition")) {
[10:18:31.132]                         if (!is.null(pattern)) {
[10:18:31.132]                           computeRestarts <- base::computeRestarts
[10:18:31.132]                           grepl <- base::grepl
[10:18:31.132]                           restarts <- computeRestarts(cond)
[10:18:31.132]                           for (restart in restarts) {
[10:18:31.132]                             name <- restart$name
[10:18:31.132]                             if (is.null(name)) 
[10:18:31.132]                               next
[10:18:31.132]                             if (!grepl(pattern, name)) 
[10:18:31.132]                               next
[10:18:31.132]                             invokeRestart(restart)
[10:18:31.132]                             muffled <- TRUE
[10:18:31.132]                             break
[10:18:31.132]                           }
[10:18:31.132]                         }
[10:18:31.132]                       }
[10:18:31.132]                       invisible(muffled)
[10:18:31.132]                     }
[10:18:31.132]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.132]                   }
[10:18:31.132]                 }
[10:18:31.132]             }
[10:18:31.132]         }))
[10:18:31.132]     }, error = function(ex) {
[10:18:31.132]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.132]                 ...future.rng), started = ...future.startTime, 
[10:18:31.132]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.132]             version = "1.8"), class = "FutureResult")
[10:18:31.132]     }, finally = {
[10:18:31.132]         if (!identical(...future.workdir, getwd())) 
[10:18:31.132]             setwd(...future.workdir)
[10:18:31.132]         {
[10:18:31.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.132]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.132]             }
[10:18:31.132]             base::options(...future.oldOptions)
[10:18:31.132]             if (.Platform$OS.type == "windows") {
[10:18:31.132]                 old_names <- names(...future.oldEnvVars)
[10:18:31.132]                 envs <- base::Sys.getenv()
[10:18:31.132]                 names <- names(envs)
[10:18:31.132]                 common <- intersect(names, old_names)
[10:18:31.132]                 added <- setdiff(names, old_names)
[10:18:31.132]                 removed <- setdiff(old_names, names)
[10:18:31.132]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.132]                   envs[common]]
[10:18:31.132]                 NAMES <- toupper(changed)
[10:18:31.132]                 args <- list()
[10:18:31.132]                 for (kk in seq_along(NAMES)) {
[10:18:31.132]                   name <- changed[[kk]]
[10:18:31.132]                   NAME <- NAMES[[kk]]
[10:18:31.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.132]                     next
[10:18:31.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.132]                 }
[10:18:31.132]                 NAMES <- toupper(added)
[10:18:31.132]                 for (kk in seq_along(NAMES)) {
[10:18:31.132]                   name <- added[[kk]]
[10:18:31.132]                   NAME <- NAMES[[kk]]
[10:18:31.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.132]                     next
[10:18:31.132]                   args[[name]] <- ""
[10:18:31.132]                 }
[10:18:31.132]                 NAMES <- toupper(removed)
[10:18:31.132]                 for (kk in seq_along(NAMES)) {
[10:18:31.132]                   name <- removed[[kk]]
[10:18:31.132]                   NAME <- NAMES[[kk]]
[10:18:31.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.132]                     next
[10:18:31.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.132]                 }
[10:18:31.132]                 if (length(args) > 0) 
[10:18:31.132]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.132]             }
[10:18:31.132]             else {
[10:18:31.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.132]             }
[10:18:31.132]             {
[10:18:31.132]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.132]                   0L) {
[10:18:31.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.132]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.132]                   base::options(opts)
[10:18:31.132]                 }
[10:18:31.132]                 {
[10:18:31.132]                   {
[10:18:31.132]                     NULL
[10:18:31.132]                     RNGkind("Mersenne-Twister")
[10:18:31.132]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.132]                       inherits = FALSE)
[10:18:31.132]                   }
[10:18:31.132]                   options(future.plan = NULL)
[10:18:31.132]                   if (is.na(NA_character_)) 
[10:18:31.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.132]                     .init = FALSE)
[10:18:31.132]                 }
[10:18:31.132]             }
[10:18:31.132]         }
[10:18:31.132]     })
[10:18:31.132]     if (TRUE) {
[10:18:31.132]         base::sink(type = "output", split = FALSE)
[10:18:31.132]         if (TRUE) {
[10:18:31.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.132]         }
[10:18:31.132]         else {
[10:18:31.132]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.132]         }
[10:18:31.132]         base::close(...future.stdout)
[10:18:31.132]         ...future.stdout <- NULL
[10:18:31.132]     }
[10:18:31.132]     ...future.result$conditions <- ...future.conditions
[10:18:31.132]     ...future.result$finished <- base::Sys.time()
[10:18:31.132]     ...future.result
[10:18:31.132] }
[10:18:31.134] assign_globals() ...
[10:18:31.134] List of 5
[10:18:31.134]  $ ...future.FUN            :function (object, ...)  
[10:18:31.134]  $ future.call.arguments    : list()
[10:18:31.134]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.134]  $ ...future.elements_ii    :List of 3
[10:18:31.134]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.134]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.134]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.134]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.134]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.134]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.134]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.134]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.134]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.134]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.134]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.134]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.134]  $ ...future.seeds_ii       : NULL
[10:18:31.134]  $ ...future.globals.maxSize: NULL
[10:18:31.134]  - attr(*, "where")=List of 5
[10:18:31.134]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.134]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.134]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.134]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.134]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.134]  - attr(*, "resolved")= logi FALSE
[10:18:31.134]  - attr(*, "total_size")= num 19278
[10:18:31.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.134]  - attr(*, "already-done")= logi TRUE
[10:18:31.144] - copied ‘...future.FUN’ to environment
[10:18:31.144] - copied ‘future.call.arguments’ to environment
[10:18:31.144] - copied ‘...future.elements_ii’ to environment
[10:18:31.144] - copied ‘...future.seeds_ii’ to environment
[10:18:31.144] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.144] assign_globals() ... done
[10:18:31.145] plan(): Setting new future strategy stack:
[10:18:31.145] List of future strategies:
[10:18:31.145] 1. sequential:
[10:18:31.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.145]    - tweaked: FALSE
[10:18:31.145]    - call: NULL
[10:18:31.145] plan(): nbrOfWorkers() = 1
[10:18:31.147] plan(): Setting new future strategy stack:
[10:18:31.148] List of future strategies:
[10:18:31.148] 1. multicore:
[10:18:31.148]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:31.148]    - tweaked: FALSE
[10:18:31.148]    - call: plan(strategy)
[10:18:31.149] plan(): nbrOfWorkers() = 1
[10:18:31.149] SequentialFuture started (and completed)
[10:18:31.149] - Launch lazy future ... done
[10:18:31.150] run() for ‘SequentialFuture’ ... done
[10:18:31.150] Created future:
[10:18:31.150] SequentialFuture:
[10:18:31.150] Label: ‘future_by-1’
[10:18:31.150] Expression:
[10:18:31.150] {
[10:18:31.150]     do.call(function(...) {
[10:18:31.150]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.150]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.150]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.150]             on.exit(options(oopts), add = TRUE)
[10:18:31.150]         }
[10:18:31.150]         {
[10:18:31.150]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.150]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.150]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.150]             })
[10:18:31.150]         }
[10:18:31.150]     }, args = future.call.arguments)
[10:18:31.150] }
[10:18:31.150] Lazy evaluation: FALSE
[10:18:31.150] Asynchronous evaluation: FALSE
[10:18:31.150] Local evaluation: TRUE
[10:18:31.150] Environment: 0x55844a445a58
[10:18:31.150] Capture standard output: TRUE
[10:18:31.150] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.150] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.150] Packages: <none>
[10:18:31.150] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.150] Resolved: TRUE
[10:18:31.150] Value: 1.39 KiB of class ‘list’
[10:18:31.150] Early signaling: FALSE
[10:18:31.150] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.150] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.151] Chunk #1 of 1 ... DONE
[10:18:31.151] Launching 1 futures (chunks) ... DONE
[10:18:31.151] Resolving 1 futures (chunks) ...
[10:18:31.151] resolve() on list ...
[10:18:31.151]  recursive: 0
[10:18:31.151]  length: 1
[10:18:31.151] 
[10:18:31.151] resolved() for ‘SequentialFuture’ ...
[10:18:31.151] - state: ‘finished’
[10:18:31.151] - run: TRUE
[10:18:31.152] - result: ‘FutureResult’
[10:18:31.152] resolved() for ‘SequentialFuture’ ... done
[10:18:31.152] Future #1
[10:18:31.152] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.152] - nx: 1
[10:18:31.152] - relay: TRUE
[10:18:31.152] - stdout: TRUE
[10:18:31.152] - signal: TRUE
[10:18:31.152] - resignal: FALSE
[10:18:31.152] - force: TRUE
[10:18:31.152] - relayed: [n=1] FALSE
[10:18:31.153] - queued futures: [n=1] FALSE
[10:18:31.153]  - until=1
[10:18:31.153]  - relaying element #1
[10:18:31.153] - relayed: [n=1] TRUE
[10:18:31.153] - queued futures: [n=1] TRUE
[10:18:31.153] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.153]  length: 0 (resolved future 1)
[10:18:31.153] Relaying remaining futures
[10:18:31.153] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.153] - nx: 1
[10:18:31.154] - relay: TRUE
[10:18:31.154] - stdout: TRUE
[10:18:31.154] - signal: TRUE
[10:18:31.154] - resignal: FALSE
[10:18:31.154] - force: TRUE
[10:18:31.154] - relayed: [n=1] TRUE
[10:18:31.154] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.154] - relayed: [n=1] TRUE
[10:18:31.154] - queued futures: [n=1] TRUE
[10:18:31.154] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.154] resolve() on list ... DONE
[10:18:31.155]  - Number of value chunks collected: 1
[10:18:31.155] Resolving 1 futures (chunks) ... DONE
[10:18:31.155] Reducing values from 1 chunks ...
[10:18:31.155]  - Number of values collected after concatenation: 3
[10:18:31.155]  - Number of values expected: 3
[10:18:31.155] Reducing values from 1 chunks ... DONE
[10:18:31.155] future_lapply() ... DONE
[10:18:31.155] future_by_internal() ... DONE
[10:18:31.156] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:18:31.156] future_lapply() ...
[10:18:31.158] Number of chunks: 1
[10:18:31.158] getGlobalsAndPackagesXApply() ...
[10:18:31.158]  - future.globals: TRUE
[10:18:31.158] getGlobalsAndPackages() ...
[10:18:31.158] Searching for globals...
[10:18:31.159] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.160] Searching for globals ... DONE
[10:18:31.160] Resolving globals: FALSE
[10:18:31.160] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.160] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.160] - globals: [1] ‘FUN’
[10:18:31.161] 
[10:18:31.161] getGlobalsAndPackages() ... DONE
[10:18:31.161]  - globals found/used: [n=1] ‘FUN’
[10:18:31.161]  - needed namespaces: [n=0] 
[10:18:31.161] Finding globals ... DONE
[10:18:31.161]  - use_args: TRUE
[10:18:31.161]  - Getting '...' globals ...
[10:18:31.161] resolve() on list ...
[10:18:31.161]  recursive: 0
[10:18:31.162]  length: 1
[10:18:31.162]  elements: ‘...’
[10:18:31.162]  length: 0 (resolved future 1)
[10:18:31.162] resolve() on list ... DONE
[10:18:31.162]    - '...' content: [n=0] 
[10:18:31.162] List of 1
[10:18:31.162]  $ ...: list()
[10:18:31.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.162]  - attr(*, "where")=List of 1
[10:18:31.162]   ..$ ...:<environment: 0x55844a2e7678> 
[10:18:31.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.162]  - attr(*, "resolved")= logi TRUE
[10:18:31.162]  - attr(*, "total_size")= num NA
[10:18:31.166]  - Getting '...' globals ... DONE
[10:18:31.166] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.166] List of 2
[10:18:31.166]  $ ...future.FUN:function (object, ...)  
[10:18:31.166]  $ ...          : list()
[10:18:31.166]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.166]  - attr(*, "where")=List of 2
[10:18:31.166]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.166]   ..$ ...          :<environment: 0x55844a2e7678> 
[10:18:31.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.166]  - attr(*, "resolved")= logi FALSE
[10:18:31.166]  - attr(*, "total_size")= num 18647
[10:18:31.169] Packages to be attached in all futures: [n=0] 
[10:18:31.169] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.169] Number of futures (= number of chunks): 1
[10:18:31.169] Launching 1 futures (chunks) ...
[10:18:31.169] Chunk #1 of 1 ...
[10:18:31.170]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.170] getGlobalsAndPackages() ...
[10:18:31.170] Searching for globals...
[10:18:31.170] 
[10:18:31.170] Searching for globals ... DONE
[10:18:31.170] - globals: [0] <none>
[10:18:31.170] getGlobalsAndPackages() ... DONE
[10:18:31.171]    + additional globals found: [n=0] 
[10:18:31.171]    + additional namespaces needed: [n=0] 
[10:18:31.171]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.171]  - seeds: <none>
[10:18:31.171]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.171] getGlobalsAndPackages() ...
[10:18:31.171] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.171] Resolving globals: FALSE
[10:18:31.171] Tweak future expression to call with '...' arguments ...
[10:18:31.171] {
[10:18:31.171]     do.call(function(...) {
[10:18:31.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.171]             on.exit(options(oopts), add = TRUE)
[10:18:31.171]         }
[10:18:31.171]         {
[10:18:31.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.171]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.171]             })
[10:18:31.171]         }
[10:18:31.171]     }, args = future.call.arguments)
[10:18:31.171] }
[10:18:31.172] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.172] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.172] 
[10:18:31.172] getGlobalsAndPackages() ... DONE
[10:18:31.172] run() for ‘Future’ ...
[10:18:31.173] - state: ‘created’
[10:18:31.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.174] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.175]   - Field: ‘label’
[10:18:31.175]   - Field: ‘local’
[10:18:31.175]   - Field: ‘owner’
[10:18:31.175]   - Field: ‘envir’
[10:18:31.175]   - Field: ‘packages’
[10:18:31.175]   - Field: ‘gc’
[10:18:31.175]   - Field: ‘conditions’
[10:18:31.175]   - Field: ‘expr’
[10:18:31.175]   - Field: ‘uuid’
[10:18:31.175]   - Field: ‘seed’
[10:18:31.175]   - Field: ‘version’
[10:18:31.176]   - Field: ‘result’
[10:18:31.176]   - Field: ‘asynchronous’
[10:18:31.176]   - Field: ‘calls’
[10:18:31.176]   - Field: ‘globals’
[10:18:31.176]   - Field: ‘stdout’
[10:18:31.176]   - Field: ‘earlySignal’
[10:18:31.176]   - Field: ‘lazy’
[10:18:31.176]   - Field: ‘state’
[10:18:31.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.176] - Launch lazy future ...
[10:18:31.177] Packages needed by the future expression (n = 0): <none>
[10:18:31.177] Packages needed by future strategies (n = 0): <none>
[10:18:31.177] {
[10:18:31.177]     {
[10:18:31.177]         {
[10:18:31.177]             ...future.startTime <- base::Sys.time()
[10:18:31.177]             {
[10:18:31.177]                 {
[10:18:31.177]                   {
[10:18:31.177]                     base::local({
[10:18:31.177]                       has_future <- base::requireNamespace("future", 
[10:18:31.177]                         quietly = TRUE)
[10:18:31.177]                       if (has_future) {
[10:18:31.177]                         ns <- base::getNamespace("future")
[10:18:31.177]                         version <- ns[[".package"]][["version"]]
[10:18:31.177]                         if (is.null(version)) 
[10:18:31.177]                           version <- utils::packageVersion("future")
[10:18:31.177]                       }
[10:18:31.177]                       else {
[10:18:31.177]                         version <- NULL
[10:18:31.177]                       }
[10:18:31.177]                       if (!has_future || version < "1.8.0") {
[10:18:31.177]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.177]                           "", base::R.version$version.string), 
[10:18:31.177]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.177]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.177]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.177]                             "release", "version")], collapse = " "), 
[10:18:31.177]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.177]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.177]                           info)
[10:18:31.177]                         info <- base::paste(info, collapse = "; ")
[10:18:31.177]                         if (!has_future) {
[10:18:31.177]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.177]                             info)
[10:18:31.177]                         }
[10:18:31.177]                         else {
[10:18:31.177]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.177]                             info, version)
[10:18:31.177]                         }
[10:18:31.177]                         base::stop(msg)
[10:18:31.177]                       }
[10:18:31.177]                     })
[10:18:31.177]                   }
[10:18:31.177]                   ...future.strategy.old <- future::plan("list")
[10:18:31.177]                   options(future.plan = NULL)
[10:18:31.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.177]                 }
[10:18:31.177]                 ...future.workdir <- getwd()
[10:18:31.177]             }
[10:18:31.177]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.177]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.177]         }
[10:18:31.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.177]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.177]             base::names(...future.oldOptions))
[10:18:31.177]     }
[10:18:31.177]     if (FALSE) {
[10:18:31.177]     }
[10:18:31.177]     else {
[10:18:31.177]         if (TRUE) {
[10:18:31.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.177]                 open = "w")
[10:18:31.177]         }
[10:18:31.177]         else {
[10:18:31.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.177]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.177]         }
[10:18:31.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.177]             base::sink(type = "output", split = FALSE)
[10:18:31.177]             base::close(...future.stdout)
[10:18:31.177]         }, add = TRUE)
[10:18:31.177]     }
[10:18:31.177]     ...future.frame <- base::sys.nframe()
[10:18:31.177]     ...future.conditions <- base::list()
[10:18:31.177]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.177]     if (FALSE) {
[10:18:31.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.177]     }
[10:18:31.177]     ...future.result <- base::tryCatch({
[10:18:31.177]         base::withCallingHandlers({
[10:18:31.177]             ...future.value <- base::withVisible(base::local({
[10:18:31.177]                 do.call(function(...) {
[10:18:31.177]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.177]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.177]                     ...future.globals.maxSize)) {
[10:18:31.177]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.177]                     on.exit(options(oopts), add = TRUE)
[10:18:31.177]                   }
[10:18:31.177]                   {
[10:18:31.177]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.177]                       FUN = function(jj) {
[10:18:31.177]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.177]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.177]                       })
[10:18:31.177]                   }
[10:18:31.177]                 }, args = future.call.arguments)
[10:18:31.177]             }))
[10:18:31.177]             future::FutureResult(value = ...future.value$value, 
[10:18:31.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.177]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.177]                     ...future.globalenv.names))
[10:18:31.177]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.177]         }, condition = base::local({
[10:18:31.177]             c <- base::c
[10:18:31.177]             inherits <- base::inherits
[10:18:31.177]             invokeRestart <- base::invokeRestart
[10:18:31.177]             length <- base::length
[10:18:31.177]             list <- base::list
[10:18:31.177]             seq.int <- base::seq.int
[10:18:31.177]             signalCondition <- base::signalCondition
[10:18:31.177]             sys.calls <- base::sys.calls
[10:18:31.177]             `[[` <- base::`[[`
[10:18:31.177]             `+` <- base::`+`
[10:18:31.177]             `<<-` <- base::`<<-`
[10:18:31.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.177]                   3L)]
[10:18:31.177]             }
[10:18:31.177]             function(cond) {
[10:18:31.177]                 is_error <- inherits(cond, "error")
[10:18:31.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.177]                   NULL)
[10:18:31.177]                 if (is_error) {
[10:18:31.177]                   sessionInformation <- function() {
[10:18:31.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.177]                       search = base::search(), system = base::Sys.info())
[10:18:31.177]                   }
[10:18:31.177]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.177]                     cond$call), session = sessionInformation(), 
[10:18:31.177]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.177]                   signalCondition(cond)
[10:18:31.177]                 }
[10:18:31.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.177]                 "immediateCondition"))) {
[10:18:31.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.177]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.177]                   if (TRUE && !signal) {
[10:18:31.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.177]                     {
[10:18:31.177]                       inherits <- base::inherits
[10:18:31.177]                       invokeRestart <- base::invokeRestart
[10:18:31.177]                       is.null <- base::is.null
[10:18:31.177]                       muffled <- FALSE
[10:18:31.177]                       if (inherits(cond, "message")) {
[10:18:31.177]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.177]                         if (muffled) 
[10:18:31.177]                           invokeRestart("muffleMessage")
[10:18:31.177]                       }
[10:18:31.177]                       else if (inherits(cond, "warning")) {
[10:18:31.177]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.177]                         if (muffled) 
[10:18:31.177]                           invokeRestart("muffleWarning")
[10:18:31.177]                       }
[10:18:31.177]                       else if (inherits(cond, "condition")) {
[10:18:31.177]                         if (!is.null(pattern)) {
[10:18:31.177]                           computeRestarts <- base::computeRestarts
[10:18:31.177]                           grepl <- base::grepl
[10:18:31.177]                           restarts <- computeRestarts(cond)
[10:18:31.177]                           for (restart in restarts) {
[10:18:31.177]                             name <- restart$name
[10:18:31.177]                             if (is.null(name)) 
[10:18:31.177]                               next
[10:18:31.177]                             if (!grepl(pattern, name)) 
[10:18:31.177]                               next
[10:18:31.177]                             invokeRestart(restart)
[10:18:31.177]                             muffled <- TRUE
[10:18:31.177]                             break
[10:18:31.177]                           }
[10:18:31.177]                         }
[10:18:31.177]                       }
[10:18:31.177]                       invisible(muffled)
[10:18:31.177]                     }
[10:18:31.177]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.177]                   }
[10:18:31.177]                 }
[10:18:31.177]                 else {
[10:18:31.177]                   if (TRUE) {
[10:18:31.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.177]                     {
[10:18:31.177]                       inherits <- base::inherits
[10:18:31.177]                       invokeRestart <- base::invokeRestart
[10:18:31.177]                       is.null <- base::is.null
[10:18:31.177]                       muffled <- FALSE
[10:18:31.177]                       if (inherits(cond, "message")) {
[10:18:31.177]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.177]                         if (muffled) 
[10:18:31.177]                           invokeRestart("muffleMessage")
[10:18:31.177]                       }
[10:18:31.177]                       else if (inherits(cond, "warning")) {
[10:18:31.177]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.177]                         if (muffled) 
[10:18:31.177]                           invokeRestart("muffleWarning")
[10:18:31.177]                       }
[10:18:31.177]                       else if (inherits(cond, "condition")) {
[10:18:31.177]                         if (!is.null(pattern)) {
[10:18:31.177]                           computeRestarts <- base::computeRestarts
[10:18:31.177]                           grepl <- base::grepl
[10:18:31.177]                           restarts <- computeRestarts(cond)
[10:18:31.177]                           for (restart in restarts) {
[10:18:31.177]                             name <- restart$name
[10:18:31.177]                             if (is.null(name)) 
[10:18:31.177]                               next
[10:18:31.177]                             if (!grepl(pattern, name)) 
[10:18:31.177]                               next
[10:18:31.177]                             invokeRestart(restart)
[10:18:31.177]                             muffled <- TRUE
[10:18:31.177]                             break
[10:18:31.177]                           }
[10:18:31.177]                         }
[10:18:31.177]                       }
[10:18:31.177]                       invisible(muffled)
[10:18:31.177]                     }
[10:18:31.177]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.177]                   }
[10:18:31.177]                 }
[10:18:31.177]             }
[10:18:31.177]         }))
[10:18:31.177]     }, error = function(ex) {
[10:18:31.177]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.177]                 ...future.rng), started = ...future.startTime, 
[10:18:31.177]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.177]             version = "1.8"), class = "FutureResult")
[10:18:31.177]     }, finally = {
[10:18:31.177]         if (!identical(...future.workdir, getwd())) 
[10:18:31.177]             setwd(...future.workdir)
[10:18:31.177]         {
[10:18:31.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.177]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.177]             }
[10:18:31.177]             base::options(...future.oldOptions)
[10:18:31.177]             if (.Platform$OS.type == "windows") {
[10:18:31.177]                 old_names <- names(...future.oldEnvVars)
[10:18:31.177]                 envs <- base::Sys.getenv()
[10:18:31.177]                 names <- names(envs)
[10:18:31.177]                 common <- intersect(names, old_names)
[10:18:31.177]                 added <- setdiff(names, old_names)
[10:18:31.177]                 removed <- setdiff(old_names, names)
[10:18:31.177]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.177]                   envs[common]]
[10:18:31.177]                 NAMES <- toupper(changed)
[10:18:31.177]                 args <- list()
[10:18:31.177]                 for (kk in seq_along(NAMES)) {
[10:18:31.177]                   name <- changed[[kk]]
[10:18:31.177]                   NAME <- NAMES[[kk]]
[10:18:31.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.177]                     next
[10:18:31.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.177]                 }
[10:18:31.177]                 NAMES <- toupper(added)
[10:18:31.177]                 for (kk in seq_along(NAMES)) {
[10:18:31.177]                   name <- added[[kk]]
[10:18:31.177]                   NAME <- NAMES[[kk]]
[10:18:31.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.177]                     next
[10:18:31.177]                   args[[name]] <- ""
[10:18:31.177]                 }
[10:18:31.177]                 NAMES <- toupper(removed)
[10:18:31.177]                 for (kk in seq_along(NAMES)) {
[10:18:31.177]                   name <- removed[[kk]]
[10:18:31.177]                   NAME <- NAMES[[kk]]
[10:18:31.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.177]                     next
[10:18:31.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.177]                 }
[10:18:31.177]                 if (length(args) > 0) 
[10:18:31.177]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.177]             }
[10:18:31.177]             else {
[10:18:31.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.177]             }
[10:18:31.177]             {
[10:18:31.177]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.177]                   0L) {
[10:18:31.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.177]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.177]                   base::options(opts)
[10:18:31.177]                 }
[10:18:31.177]                 {
[10:18:31.177]                   {
[10:18:31.177]                     NULL
[10:18:31.177]                     RNGkind("Mersenne-Twister")
[10:18:31.177]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.177]                       inherits = FALSE)
[10:18:31.177]                   }
[10:18:31.177]                   options(future.plan = NULL)
[10:18:31.177]                   if (is.na(NA_character_)) 
[10:18:31.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.177]                     .init = FALSE)
[10:18:31.177]                 }
[10:18:31.177]             }
[10:18:31.177]         }
[10:18:31.177]     })
[10:18:31.177]     if (TRUE) {
[10:18:31.177]         base::sink(type = "output", split = FALSE)
[10:18:31.177]         if (TRUE) {
[10:18:31.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.177]         }
[10:18:31.177]         else {
[10:18:31.177]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.177]         }
[10:18:31.177]         base::close(...future.stdout)
[10:18:31.177]         ...future.stdout <- NULL
[10:18:31.177]     }
[10:18:31.177]     ...future.result$conditions <- ...future.conditions
[10:18:31.177]     ...future.result$finished <- base::Sys.time()
[10:18:31.177]     ...future.result
[10:18:31.177] }
[10:18:31.179] assign_globals() ...
[10:18:31.179] List of 5
[10:18:31.179]  $ ...future.FUN            :function (object, ...)  
[10:18:31.179]  $ future.call.arguments    : list()
[10:18:31.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.179]  $ ...future.elements_ii    :List of 3
[10:18:31.179]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.179]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.179]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.179]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.179]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.179]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.179]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.179]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.179]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.179]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.179]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.179]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.179]  $ ...future.seeds_ii       : NULL
[10:18:31.179]  $ ...future.globals.maxSize: NULL
[10:18:31.179]  - attr(*, "where")=List of 5
[10:18:31.179]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.179]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.179]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.179]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.179]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.179]  - attr(*, "resolved")= logi FALSE
[10:18:31.179]  - attr(*, "total_size")= num 18647
[10:18:31.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.179]  - attr(*, "already-done")= logi TRUE
[10:18:31.190] - copied ‘...future.FUN’ to environment
[10:18:31.190] - copied ‘future.call.arguments’ to environment
[10:18:31.190] - copied ‘...future.elements_ii’ to environment
[10:18:31.190] - copied ‘...future.seeds_ii’ to environment
[10:18:31.190] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.190] assign_globals() ... done
[10:18:31.190] plan(): Setting new future strategy stack:
[10:18:31.190] List of future strategies:
[10:18:31.190] 1. sequential:
[10:18:31.190]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.190]    - tweaked: FALSE
[10:18:31.190]    - call: NULL
[10:18:31.191] plan(): nbrOfWorkers() = 1
[10:18:31.193] plan(): Setting new future strategy stack:
[10:18:31.193] List of future strategies:
[10:18:31.193] 1. multicore:
[10:18:31.193]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:31.193]    - tweaked: FALSE
[10:18:31.193]    - call: plan(strategy)
[10:18:31.195] plan(): nbrOfWorkers() = 1
[10:18:31.195] SequentialFuture started (and completed)
[10:18:31.195] - Launch lazy future ... done
[10:18:31.195] run() for ‘SequentialFuture’ ... done
[10:18:31.196] Created future:
[10:18:31.196] SequentialFuture:
[10:18:31.196] Label: ‘future_by-1’
[10:18:31.196] Expression:
[10:18:31.196] {
[10:18:31.196]     do.call(function(...) {
[10:18:31.196]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.196]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.196]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.196]             on.exit(options(oopts), add = TRUE)
[10:18:31.196]         }
[10:18:31.196]         {
[10:18:31.196]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.196]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.196]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.196]             })
[10:18:31.196]         }
[10:18:31.196]     }, args = future.call.arguments)
[10:18:31.196] }
[10:18:31.196] Lazy evaluation: FALSE
[10:18:31.196] Asynchronous evaluation: FALSE
[10:18:31.196] Local evaluation: TRUE
[10:18:31.196] Environment: 0x55844a29b960
[10:18:31.196] Capture standard output: TRUE
[10:18:31.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.196] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.196] Packages: <none>
[10:18:31.196] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.196] Resolved: TRUE
[10:18:31.196] Value: 1.39 KiB of class ‘list’
[10:18:31.196] Early signaling: FALSE
[10:18:31.196] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.196] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.197] Chunk #1 of 1 ... DONE
[10:18:31.197] Launching 1 futures (chunks) ... DONE
[10:18:31.197] Resolving 1 futures (chunks) ...
[10:18:31.197] resolve() on list ...
[10:18:31.197]  recursive: 0
[10:18:31.197]  length: 1
[10:18:31.197] 
[10:18:31.197] resolved() for ‘SequentialFuture’ ...
[10:18:31.197] - state: ‘finished’
[10:18:31.197] - run: TRUE
[10:18:31.198] - result: ‘FutureResult’
[10:18:31.198] resolved() for ‘SequentialFuture’ ... done
[10:18:31.198] Future #1
[10:18:31.198] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.198] - nx: 1
[10:18:31.198] - relay: TRUE
[10:18:31.198] - stdout: TRUE
[10:18:31.198] - signal: TRUE
[10:18:31.198] - resignal: FALSE
[10:18:31.198] - force: TRUE
[10:18:31.198] - relayed: [n=1] FALSE
[10:18:31.199] - queued futures: [n=1] FALSE
[10:18:31.199]  - until=1
[10:18:31.199]  - relaying element #1
[10:18:31.199] - relayed: [n=1] TRUE
[10:18:31.199] - queued futures: [n=1] TRUE
[10:18:31.199] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.199]  length: 0 (resolved future 1)
[10:18:31.199] Relaying remaining futures
[10:18:31.199] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.199] - nx: 1
[10:18:31.200] - relay: TRUE
[10:18:31.200] - stdout: TRUE
[10:18:31.200] - signal: TRUE
[10:18:31.200] - resignal: FALSE
[10:18:31.200] - force: TRUE
[10:18:31.200] - relayed: [n=1] TRUE
[10:18:31.200] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.200] - relayed: [n=1] TRUE
[10:18:31.200] - queued futures: [n=1] TRUE
[10:18:31.200] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.200] resolve() on list ... DONE
[10:18:31.201]  - Number of value chunks collected: 1
[10:18:31.201] Resolving 1 futures (chunks) ... DONE
[10:18:31.201] Reducing values from 1 chunks ...
[10:18:31.201]  - Number of values collected after concatenation: 3
[10:18:31.201]  - Number of values expected: 3
[10:18:31.201] Reducing values from 1 chunks ... DONE
[10:18:31.201] future_lapply() ... DONE
[10:18:31.201] future_by_internal() ... DONE
[10:18:31.202] future_by_internal() ...
- plan('multisession') ...
[10:18:31.203] plan(): Setting new future strategy stack:
[10:18:31.203] List of future strategies:
[10:18:31.203] 1. multisession:
[10:18:31.203]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.203]    - tweaked: FALSE
[10:18:31.203]    - call: plan(strategy)
[10:18:31.203] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:18:31.203] multisession:
[10:18:31.203] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.203] - tweaked: FALSE
[10:18:31.203] - call: plan(strategy)
[10:18:31.205] getGlobalsAndPackages() ...
[10:18:31.205] Not searching for globals
[10:18:31.205] - globals: [0] <none>
[10:18:31.205] getGlobalsAndPackages() ... DONE
[10:18:31.205] Packages needed by the future expression (n = 0): <none>
[10:18:31.206] Packages needed by future strategies (n = 0): <none>
[10:18:31.206] {
[10:18:31.206]     {
[10:18:31.206]         {
[10:18:31.206]             ...future.startTime <- base::Sys.time()
[10:18:31.206]             {
[10:18:31.206]                 {
[10:18:31.206]                   {
[10:18:31.206]                     base::local({
[10:18:31.206]                       has_future <- base::requireNamespace("future", 
[10:18:31.206]                         quietly = TRUE)
[10:18:31.206]                       if (has_future) {
[10:18:31.206]                         ns <- base::getNamespace("future")
[10:18:31.206]                         version <- ns[[".package"]][["version"]]
[10:18:31.206]                         if (is.null(version)) 
[10:18:31.206]                           version <- utils::packageVersion("future")
[10:18:31.206]                       }
[10:18:31.206]                       else {
[10:18:31.206]                         version <- NULL
[10:18:31.206]                       }
[10:18:31.206]                       if (!has_future || version < "1.8.0") {
[10:18:31.206]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.206]                           "", base::R.version$version.string), 
[10:18:31.206]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.206]                             "release", "version")], collapse = " "), 
[10:18:31.206]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.206]                           info)
[10:18:31.206]                         info <- base::paste(info, collapse = "; ")
[10:18:31.206]                         if (!has_future) {
[10:18:31.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.206]                             info)
[10:18:31.206]                         }
[10:18:31.206]                         else {
[10:18:31.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.206]                             info, version)
[10:18:31.206]                         }
[10:18:31.206]                         base::stop(msg)
[10:18:31.206]                       }
[10:18:31.206]                     })
[10:18:31.206]                   }
[10:18:31.206]                   ...future.strategy.old <- future::plan("list")
[10:18:31.206]                   options(future.plan = NULL)
[10:18:31.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.206]                 }
[10:18:31.206]                 ...future.workdir <- getwd()
[10:18:31.206]             }
[10:18:31.206]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.206]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.206]         }
[10:18:31.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.206]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.206]             base::names(...future.oldOptions))
[10:18:31.206]     }
[10:18:31.206]     if (FALSE) {
[10:18:31.206]     }
[10:18:31.206]     else {
[10:18:31.206]         if (TRUE) {
[10:18:31.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.206]                 open = "w")
[10:18:31.206]         }
[10:18:31.206]         else {
[10:18:31.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.206]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.206]         }
[10:18:31.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.206]             base::sink(type = "output", split = FALSE)
[10:18:31.206]             base::close(...future.stdout)
[10:18:31.206]         }, add = TRUE)
[10:18:31.206]     }
[10:18:31.206]     ...future.frame <- base::sys.nframe()
[10:18:31.206]     ...future.conditions <- base::list()
[10:18:31.206]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.206]     if (FALSE) {
[10:18:31.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.206]     }
[10:18:31.206]     ...future.result <- base::tryCatch({
[10:18:31.206]         base::withCallingHandlers({
[10:18:31.206]             ...future.value <- base::withVisible(base::local(NA))
[10:18:31.206]             future::FutureResult(value = ...future.value$value, 
[10:18:31.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.206]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.206]                     ...future.globalenv.names))
[10:18:31.206]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.206]         }, condition = base::local({
[10:18:31.206]             c <- base::c
[10:18:31.206]             inherits <- base::inherits
[10:18:31.206]             invokeRestart <- base::invokeRestart
[10:18:31.206]             length <- base::length
[10:18:31.206]             list <- base::list
[10:18:31.206]             seq.int <- base::seq.int
[10:18:31.206]             signalCondition <- base::signalCondition
[10:18:31.206]             sys.calls <- base::sys.calls
[10:18:31.206]             `[[` <- base::`[[`
[10:18:31.206]             `+` <- base::`+`
[10:18:31.206]             `<<-` <- base::`<<-`
[10:18:31.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.206]                   3L)]
[10:18:31.206]             }
[10:18:31.206]             function(cond) {
[10:18:31.206]                 is_error <- inherits(cond, "error")
[10:18:31.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.206]                   NULL)
[10:18:31.206]                 if (is_error) {
[10:18:31.206]                   sessionInformation <- function() {
[10:18:31.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.206]                       search = base::search(), system = base::Sys.info())
[10:18:31.206]                   }
[10:18:31.206]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.206]                     cond$call), session = sessionInformation(), 
[10:18:31.206]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.206]                   signalCondition(cond)
[10:18:31.206]                 }
[10:18:31.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.206]                 "immediateCondition"))) {
[10:18:31.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.206]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.206]                   if (TRUE && !signal) {
[10:18:31.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.206]                     {
[10:18:31.206]                       inherits <- base::inherits
[10:18:31.206]                       invokeRestart <- base::invokeRestart
[10:18:31.206]                       is.null <- base::is.null
[10:18:31.206]                       muffled <- FALSE
[10:18:31.206]                       if (inherits(cond, "message")) {
[10:18:31.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.206]                         if (muffled) 
[10:18:31.206]                           invokeRestart("muffleMessage")
[10:18:31.206]                       }
[10:18:31.206]                       else if (inherits(cond, "warning")) {
[10:18:31.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.206]                         if (muffled) 
[10:18:31.206]                           invokeRestart("muffleWarning")
[10:18:31.206]                       }
[10:18:31.206]                       else if (inherits(cond, "condition")) {
[10:18:31.206]                         if (!is.null(pattern)) {
[10:18:31.206]                           computeRestarts <- base::computeRestarts
[10:18:31.206]                           grepl <- base::grepl
[10:18:31.206]                           restarts <- computeRestarts(cond)
[10:18:31.206]                           for (restart in restarts) {
[10:18:31.206]                             name <- restart$name
[10:18:31.206]                             if (is.null(name)) 
[10:18:31.206]                               next
[10:18:31.206]                             if (!grepl(pattern, name)) 
[10:18:31.206]                               next
[10:18:31.206]                             invokeRestart(restart)
[10:18:31.206]                             muffled <- TRUE
[10:18:31.206]                             break
[10:18:31.206]                           }
[10:18:31.206]                         }
[10:18:31.206]                       }
[10:18:31.206]                       invisible(muffled)
[10:18:31.206]                     }
[10:18:31.206]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.206]                   }
[10:18:31.206]                 }
[10:18:31.206]                 else {
[10:18:31.206]                   if (TRUE) {
[10:18:31.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.206]                     {
[10:18:31.206]                       inherits <- base::inherits
[10:18:31.206]                       invokeRestart <- base::invokeRestart
[10:18:31.206]                       is.null <- base::is.null
[10:18:31.206]                       muffled <- FALSE
[10:18:31.206]                       if (inherits(cond, "message")) {
[10:18:31.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.206]                         if (muffled) 
[10:18:31.206]                           invokeRestart("muffleMessage")
[10:18:31.206]                       }
[10:18:31.206]                       else if (inherits(cond, "warning")) {
[10:18:31.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.206]                         if (muffled) 
[10:18:31.206]                           invokeRestart("muffleWarning")
[10:18:31.206]                       }
[10:18:31.206]                       else if (inherits(cond, "condition")) {
[10:18:31.206]                         if (!is.null(pattern)) {
[10:18:31.206]                           computeRestarts <- base::computeRestarts
[10:18:31.206]                           grepl <- base::grepl
[10:18:31.206]                           restarts <- computeRestarts(cond)
[10:18:31.206]                           for (restart in restarts) {
[10:18:31.206]                             name <- restart$name
[10:18:31.206]                             if (is.null(name)) 
[10:18:31.206]                               next
[10:18:31.206]                             if (!grepl(pattern, name)) 
[10:18:31.206]                               next
[10:18:31.206]                             invokeRestart(restart)
[10:18:31.206]                             muffled <- TRUE
[10:18:31.206]                             break
[10:18:31.206]                           }
[10:18:31.206]                         }
[10:18:31.206]                       }
[10:18:31.206]                       invisible(muffled)
[10:18:31.206]                     }
[10:18:31.206]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.206]                   }
[10:18:31.206]                 }
[10:18:31.206]             }
[10:18:31.206]         }))
[10:18:31.206]     }, error = function(ex) {
[10:18:31.206]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.206]                 ...future.rng), started = ...future.startTime, 
[10:18:31.206]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.206]             version = "1.8"), class = "FutureResult")
[10:18:31.206]     }, finally = {
[10:18:31.206]         if (!identical(...future.workdir, getwd())) 
[10:18:31.206]             setwd(...future.workdir)
[10:18:31.206]         {
[10:18:31.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.206]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.206]             }
[10:18:31.206]             base::options(...future.oldOptions)
[10:18:31.206]             if (.Platform$OS.type == "windows") {
[10:18:31.206]                 old_names <- names(...future.oldEnvVars)
[10:18:31.206]                 envs <- base::Sys.getenv()
[10:18:31.206]                 names <- names(envs)
[10:18:31.206]                 common <- intersect(names, old_names)
[10:18:31.206]                 added <- setdiff(names, old_names)
[10:18:31.206]                 removed <- setdiff(old_names, names)
[10:18:31.206]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.206]                   envs[common]]
[10:18:31.206]                 NAMES <- toupper(changed)
[10:18:31.206]                 args <- list()
[10:18:31.206]                 for (kk in seq_along(NAMES)) {
[10:18:31.206]                   name <- changed[[kk]]
[10:18:31.206]                   NAME <- NAMES[[kk]]
[10:18:31.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.206]                     next
[10:18:31.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.206]                 }
[10:18:31.206]                 NAMES <- toupper(added)
[10:18:31.206]                 for (kk in seq_along(NAMES)) {
[10:18:31.206]                   name <- added[[kk]]
[10:18:31.206]                   NAME <- NAMES[[kk]]
[10:18:31.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.206]                     next
[10:18:31.206]                   args[[name]] <- ""
[10:18:31.206]                 }
[10:18:31.206]                 NAMES <- toupper(removed)
[10:18:31.206]                 for (kk in seq_along(NAMES)) {
[10:18:31.206]                   name <- removed[[kk]]
[10:18:31.206]                   NAME <- NAMES[[kk]]
[10:18:31.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.206]                     next
[10:18:31.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.206]                 }
[10:18:31.206]                 if (length(args) > 0) 
[10:18:31.206]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.206]             }
[10:18:31.206]             else {
[10:18:31.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.206]             }
[10:18:31.206]             {
[10:18:31.206]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.206]                   0L) {
[10:18:31.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.206]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.206]                   base::options(opts)
[10:18:31.206]                 }
[10:18:31.206]                 {
[10:18:31.206]                   {
[10:18:31.206]                     NULL
[10:18:31.206]                     RNGkind("Mersenne-Twister")
[10:18:31.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.206]                       inherits = FALSE)
[10:18:31.206]                   }
[10:18:31.206]                   options(future.plan = NULL)
[10:18:31.206]                   if (is.na(NA_character_)) 
[10:18:31.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.206]                     .init = FALSE)
[10:18:31.206]                 }
[10:18:31.206]             }
[10:18:31.206]         }
[10:18:31.206]     })
[10:18:31.206]     if (TRUE) {
[10:18:31.206]         base::sink(type = "output", split = FALSE)
[10:18:31.206]         if (TRUE) {
[10:18:31.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.206]         }
[10:18:31.206]         else {
[10:18:31.206]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.206]         }
[10:18:31.206]         base::close(...future.stdout)
[10:18:31.206]         ...future.stdout <- NULL
[10:18:31.206]     }
[10:18:31.206]     ...future.result$conditions <- ...future.conditions
[10:18:31.206]     ...future.result$finished <- base::Sys.time()
[10:18:31.206]     ...future.result
[10:18:31.206] }
[10:18:31.208] plan(): Setting new future strategy stack:
[10:18:31.208] List of future strategies:
[10:18:31.208] 1. sequential:
[10:18:31.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.208]    - tweaked: FALSE
[10:18:31.208]    - call: NULL
[10:18:31.208] plan(): nbrOfWorkers() = 1
[10:18:31.209] plan(): Setting new future strategy stack:
[10:18:31.209] List of future strategies:
[10:18:31.209] 1. multisession:
[10:18:31.209]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.209]    - tweaked: FALSE
[10:18:31.209]    - call: plan(strategy)
[10:18:31.211] plan(): nbrOfWorkers() = 1
[10:18:31.211] SequentialFuture started (and completed)
[10:18:31.211] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:18:31.212] plan(): nbrOfWorkers() = 1
[10:18:31.213] future_by_internal() ...
[10:18:31.213] future_lapply() ...
[10:18:31.216] Number of chunks: 1
[10:18:31.216] getGlobalsAndPackagesXApply() ...
[10:18:31.217]  - future.globals: TRUE
[10:18:31.217] getGlobalsAndPackages() ...
[10:18:31.217] Searching for globals...
[10:18:31.218] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.218] Searching for globals ... DONE
[10:18:31.218] Resolving globals: FALSE
[10:18:31.219] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.219] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.219] - globals: [1] ‘FUN’
[10:18:31.219] 
[10:18:31.219] getGlobalsAndPackages() ... DONE
[10:18:31.219]  - globals found/used: [n=1] ‘FUN’
[10:18:31.219]  - needed namespaces: [n=0] 
[10:18:31.219] Finding globals ... DONE
[10:18:31.220]  - use_args: TRUE
[10:18:31.220]  - Getting '...' globals ...
[10:18:31.220] resolve() on list ...
[10:18:31.220]  recursive: 0
[10:18:31.220]  length: 1
[10:18:31.220]  elements: ‘...’
[10:18:31.220]  length: 0 (resolved future 1)
[10:18:31.220] resolve() on list ... DONE
[10:18:31.221]    - '...' content: [n=0] 
[10:18:31.221] List of 1
[10:18:31.221]  $ ...: list()
[10:18:31.221]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.221]  - attr(*, "where")=List of 1
[10:18:31.221]   ..$ ...:<environment: 0x55844a7ba610> 
[10:18:31.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.221]  - attr(*, "resolved")= logi TRUE
[10:18:31.221]  - attr(*, "total_size")= num NA
[10:18:31.223]  - Getting '...' globals ... DONE
[10:18:31.223] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.223] List of 2
[10:18:31.223]  $ ...future.FUN:function (object, ...)  
[10:18:31.223]  $ ...          : list()
[10:18:31.223]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.223]  - attr(*, "where")=List of 2
[10:18:31.223]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.223]   ..$ ...          :<environment: 0x55844a7ba610> 
[10:18:31.223]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.223]  - attr(*, "resolved")= logi FALSE
[10:18:31.223]  - attr(*, "total_size")= num 15670
[10:18:31.226] Packages to be attached in all futures: [n=0] 
[10:18:31.226] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.226] Number of futures (= number of chunks): 1
[10:18:31.226] Launching 1 futures (chunks) ...
[10:18:31.226] Chunk #1 of 1 ...
[10:18:31.227]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.227] getGlobalsAndPackages() ...
[10:18:31.227] Searching for globals...
[10:18:31.227] 
[10:18:31.227] Searching for globals ... DONE
[10:18:31.227] - globals: [0] <none>
[10:18:31.227] getGlobalsAndPackages() ... DONE
[10:18:31.228]    + additional globals found: [n=0] 
[10:18:31.228]    + additional namespaces needed: [n=0] 
[10:18:31.228]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.228]  - seeds: <none>
[10:18:31.228]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.228] getGlobalsAndPackages() ...
[10:18:31.228] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.228] Resolving globals: FALSE
[10:18:31.228] Tweak future expression to call with '...' arguments ...
[10:18:31.228] {
[10:18:31.228]     do.call(function(...) {
[10:18:31.228]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.228]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.228]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.228]             on.exit(options(oopts), add = TRUE)
[10:18:31.228]         }
[10:18:31.228]         {
[10:18:31.228]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.228]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.228]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.228]             })
[10:18:31.228]         }
[10:18:31.228]     }, args = future.call.arguments)
[10:18:31.228] }
[10:18:31.229] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.229] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.229] 
[10:18:31.229] getGlobalsAndPackages() ... DONE
[10:18:31.230] run() for ‘Future’ ...
[10:18:31.230] - state: ‘created’
[10:18:31.230] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.231] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.231]   - Field: ‘label’
[10:18:31.232]   - Field: ‘local’
[10:18:31.232]   - Field: ‘owner’
[10:18:31.232]   - Field: ‘envir’
[10:18:31.232]   - Field: ‘packages’
[10:18:31.232]   - Field: ‘gc’
[10:18:31.232]   - Field: ‘conditions’
[10:18:31.232]   - Field: ‘expr’
[10:18:31.232]   - Field: ‘uuid’
[10:18:31.232]   - Field: ‘seed’
[10:18:31.232]   - Field: ‘version’
[10:18:31.232]   - Field: ‘result’
[10:18:31.232]   - Field: ‘asynchronous’
[10:18:31.233]   - Field: ‘calls’
[10:18:31.233]   - Field: ‘globals’
[10:18:31.233]   - Field: ‘stdout’
[10:18:31.233]   - Field: ‘earlySignal’
[10:18:31.233]   - Field: ‘lazy’
[10:18:31.233]   - Field: ‘state’
[10:18:31.233] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.233] - Launch lazy future ...
[10:18:31.233] Packages needed by the future expression (n = 0): <none>
[10:18:31.233] Packages needed by future strategies (n = 0): <none>
[10:18:31.234] {
[10:18:31.234]     {
[10:18:31.234]         {
[10:18:31.234]             ...future.startTime <- base::Sys.time()
[10:18:31.234]             {
[10:18:31.234]                 {
[10:18:31.234]                   {
[10:18:31.234]                     base::local({
[10:18:31.234]                       has_future <- base::requireNamespace("future", 
[10:18:31.234]                         quietly = TRUE)
[10:18:31.234]                       if (has_future) {
[10:18:31.234]                         ns <- base::getNamespace("future")
[10:18:31.234]                         version <- ns[[".package"]][["version"]]
[10:18:31.234]                         if (is.null(version)) 
[10:18:31.234]                           version <- utils::packageVersion("future")
[10:18:31.234]                       }
[10:18:31.234]                       else {
[10:18:31.234]                         version <- NULL
[10:18:31.234]                       }
[10:18:31.234]                       if (!has_future || version < "1.8.0") {
[10:18:31.234]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.234]                           "", base::R.version$version.string), 
[10:18:31.234]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.234]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.234]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.234]                             "release", "version")], collapse = " "), 
[10:18:31.234]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.234]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.234]                           info)
[10:18:31.234]                         info <- base::paste(info, collapse = "; ")
[10:18:31.234]                         if (!has_future) {
[10:18:31.234]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.234]                             info)
[10:18:31.234]                         }
[10:18:31.234]                         else {
[10:18:31.234]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.234]                             info, version)
[10:18:31.234]                         }
[10:18:31.234]                         base::stop(msg)
[10:18:31.234]                       }
[10:18:31.234]                     })
[10:18:31.234]                   }
[10:18:31.234]                   ...future.strategy.old <- future::plan("list")
[10:18:31.234]                   options(future.plan = NULL)
[10:18:31.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.234]                 }
[10:18:31.234]                 ...future.workdir <- getwd()
[10:18:31.234]             }
[10:18:31.234]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.234]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.234]         }
[10:18:31.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.234]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.234]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.234]             base::names(...future.oldOptions))
[10:18:31.234]     }
[10:18:31.234]     if (FALSE) {
[10:18:31.234]     }
[10:18:31.234]     else {
[10:18:31.234]         if (TRUE) {
[10:18:31.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.234]                 open = "w")
[10:18:31.234]         }
[10:18:31.234]         else {
[10:18:31.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.234]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.234]         }
[10:18:31.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.234]             base::sink(type = "output", split = FALSE)
[10:18:31.234]             base::close(...future.stdout)
[10:18:31.234]         }, add = TRUE)
[10:18:31.234]     }
[10:18:31.234]     ...future.frame <- base::sys.nframe()
[10:18:31.234]     ...future.conditions <- base::list()
[10:18:31.234]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.234]     if (FALSE) {
[10:18:31.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.234]     }
[10:18:31.234]     ...future.result <- base::tryCatch({
[10:18:31.234]         base::withCallingHandlers({
[10:18:31.234]             ...future.value <- base::withVisible(base::local({
[10:18:31.234]                 do.call(function(...) {
[10:18:31.234]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.234]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.234]                     ...future.globals.maxSize)) {
[10:18:31.234]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.234]                     on.exit(options(oopts), add = TRUE)
[10:18:31.234]                   }
[10:18:31.234]                   {
[10:18:31.234]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.234]                       FUN = function(jj) {
[10:18:31.234]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.234]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.234]                       })
[10:18:31.234]                   }
[10:18:31.234]                 }, args = future.call.arguments)
[10:18:31.234]             }))
[10:18:31.234]             future::FutureResult(value = ...future.value$value, 
[10:18:31.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.234]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.234]                     ...future.globalenv.names))
[10:18:31.234]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.234]         }, condition = base::local({
[10:18:31.234]             c <- base::c
[10:18:31.234]             inherits <- base::inherits
[10:18:31.234]             invokeRestart <- base::invokeRestart
[10:18:31.234]             length <- base::length
[10:18:31.234]             list <- base::list
[10:18:31.234]             seq.int <- base::seq.int
[10:18:31.234]             signalCondition <- base::signalCondition
[10:18:31.234]             sys.calls <- base::sys.calls
[10:18:31.234]             `[[` <- base::`[[`
[10:18:31.234]             `+` <- base::`+`
[10:18:31.234]             `<<-` <- base::`<<-`
[10:18:31.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.234]                   3L)]
[10:18:31.234]             }
[10:18:31.234]             function(cond) {
[10:18:31.234]                 is_error <- inherits(cond, "error")
[10:18:31.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.234]                   NULL)
[10:18:31.234]                 if (is_error) {
[10:18:31.234]                   sessionInformation <- function() {
[10:18:31.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.234]                       search = base::search(), system = base::Sys.info())
[10:18:31.234]                   }
[10:18:31.234]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.234]                     cond$call), session = sessionInformation(), 
[10:18:31.234]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.234]                   signalCondition(cond)
[10:18:31.234]                 }
[10:18:31.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.234]                 "immediateCondition"))) {
[10:18:31.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.234]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.234]                   if (TRUE && !signal) {
[10:18:31.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.234]                     {
[10:18:31.234]                       inherits <- base::inherits
[10:18:31.234]                       invokeRestart <- base::invokeRestart
[10:18:31.234]                       is.null <- base::is.null
[10:18:31.234]                       muffled <- FALSE
[10:18:31.234]                       if (inherits(cond, "message")) {
[10:18:31.234]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.234]                         if (muffled) 
[10:18:31.234]                           invokeRestart("muffleMessage")
[10:18:31.234]                       }
[10:18:31.234]                       else if (inherits(cond, "warning")) {
[10:18:31.234]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.234]                         if (muffled) 
[10:18:31.234]                           invokeRestart("muffleWarning")
[10:18:31.234]                       }
[10:18:31.234]                       else if (inherits(cond, "condition")) {
[10:18:31.234]                         if (!is.null(pattern)) {
[10:18:31.234]                           computeRestarts <- base::computeRestarts
[10:18:31.234]                           grepl <- base::grepl
[10:18:31.234]                           restarts <- computeRestarts(cond)
[10:18:31.234]                           for (restart in restarts) {
[10:18:31.234]                             name <- restart$name
[10:18:31.234]                             if (is.null(name)) 
[10:18:31.234]                               next
[10:18:31.234]                             if (!grepl(pattern, name)) 
[10:18:31.234]                               next
[10:18:31.234]                             invokeRestart(restart)
[10:18:31.234]                             muffled <- TRUE
[10:18:31.234]                             break
[10:18:31.234]                           }
[10:18:31.234]                         }
[10:18:31.234]                       }
[10:18:31.234]                       invisible(muffled)
[10:18:31.234]                     }
[10:18:31.234]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.234]                   }
[10:18:31.234]                 }
[10:18:31.234]                 else {
[10:18:31.234]                   if (TRUE) {
[10:18:31.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.234]                     {
[10:18:31.234]                       inherits <- base::inherits
[10:18:31.234]                       invokeRestart <- base::invokeRestart
[10:18:31.234]                       is.null <- base::is.null
[10:18:31.234]                       muffled <- FALSE
[10:18:31.234]                       if (inherits(cond, "message")) {
[10:18:31.234]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.234]                         if (muffled) 
[10:18:31.234]                           invokeRestart("muffleMessage")
[10:18:31.234]                       }
[10:18:31.234]                       else if (inherits(cond, "warning")) {
[10:18:31.234]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.234]                         if (muffled) 
[10:18:31.234]                           invokeRestart("muffleWarning")
[10:18:31.234]                       }
[10:18:31.234]                       else if (inherits(cond, "condition")) {
[10:18:31.234]                         if (!is.null(pattern)) {
[10:18:31.234]                           computeRestarts <- base::computeRestarts
[10:18:31.234]                           grepl <- base::grepl
[10:18:31.234]                           restarts <- computeRestarts(cond)
[10:18:31.234]                           for (restart in restarts) {
[10:18:31.234]                             name <- restart$name
[10:18:31.234]                             if (is.null(name)) 
[10:18:31.234]                               next
[10:18:31.234]                             if (!grepl(pattern, name)) 
[10:18:31.234]                               next
[10:18:31.234]                             invokeRestart(restart)
[10:18:31.234]                             muffled <- TRUE
[10:18:31.234]                             break
[10:18:31.234]                           }
[10:18:31.234]                         }
[10:18:31.234]                       }
[10:18:31.234]                       invisible(muffled)
[10:18:31.234]                     }
[10:18:31.234]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.234]                   }
[10:18:31.234]                 }
[10:18:31.234]             }
[10:18:31.234]         }))
[10:18:31.234]     }, error = function(ex) {
[10:18:31.234]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.234]                 ...future.rng), started = ...future.startTime, 
[10:18:31.234]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.234]             version = "1.8"), class = "FutureResult")
[10:18:31.234]     }, finally = {
[10:18:31.234]         if (!identical(...future.workdir, getwd())) 
[10:18:31.234]             setwd(...future.workdir)
[10:18:31.234]         {
[10:18:31.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.234]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.234]             }
[10:18:31.234]             base::options(...future.oldOptions)
[10:18:31.234]             if (.Platform$OS.type == "windows") {
[10:18:31.234]                 old_names <- names(...future.oldEnvVars)
[10:18:31.234]                 envs <- base::Sys.getenv()
[10:18:31.234]                 names <- names(envs)
[10:18:31.234]                 common <- intersect(names, old_names)
[10:18:31.234]                 added <- setdiff(names, old_names)
[10:18:31.234]                 removed <- setdiff(old_names, names)
[10:18:31.234]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.234]                   envs[common]]
[10:18:31.234]                 NAMES <- toupper(changed)
[10:18:31.234]                 args <- list()
[10:18:31.234]                 for (kk in seq_along(NAMES)) {
[10:18:31.234]                   name <- changed[[kk]]
[10:18:31.234]                   NAME <- NAMES[[kk]]
[10:18:31.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.234]                     next
[10:18:31.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.234]                 }
[10:18:31.234]                 NAMES <- toupper(added)
[10:18:31.234]                 for (kk in seq_along(NAMES)) {
[10:18:31.234]                   name <- added[[kk]]
[10:18:31.234]                   NAME <- NAMES[[kk]]
[10:18:31.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.234]                     next
[10:18:31.234]                   args[[name]] <- ""
[10:18:31.234]                 }
[10:18:31.234]                 NAMES <- toupper(removed)
[10:18:31.234]                 for (kk in seq_along(NAMES)) {
[10:18:31.234]                   name <- removed[[kk]]
[10:18:31.234]                   NAME <- NAMES[[kk]]
[10:18:31.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.234]                     next
[10:18:31.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.234]                 }
[10:18:31.234]                 if (length(args) > 0) 
[10:18:31.234]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.234]             }
[10:18:31.234]             else {
[10:18:31.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.234]             }
[10:18:31.234]             {
[10:18:31.234]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.234]                   0L) {
[10:18:31.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.234]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.234]                   base::options(opts)
[10:18:31.234]                 }
[10:18:31.234]                 {
[10:18:31.234]                   {
[10:18:31.234]                     NULL
[10:18:31.234]                     RNGkind("Mersenne-Twister")
[10:18:31.234]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.234]                       inherits = FALSE)
[10:18:31.234]                   }
[10:18:31.234]                   options(future.plan = NULL)
[10:18:31.234]                   if (is.na(NA_character_)) 
[10:18:31.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.234]                     .init = FALSE)
[10:18:31.234]                 }
[10:18:31.234]             }
[10:18:31.234]         }
[10:18:31.234]     })
[10:18:31.234]     if (TRUE) {
[10:18:31.234]         base::sink(type = "output", split = FALSE)
[10:18:31.234]         if (TRUE) {
[10:18:31.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.234]         }
[10:18:31.234]         else {
[10:18:31.234]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.234]         }
[10:18:31.234]         base::close(...future.stdout)
[10:18:31.234]         ...future.stdout <- NULL
[10:18:31.234]     }
[10:18:31.234]     ...future.result$conditions <- ...future.conditions
[10:18:31.234]     ...future.result$finished <- base::Sys.time()
[10:18:31.234]     ...future.result
[10:18:31.234] }
[10:18:31.236] assign_globals() ...
[10:18:31.236] List of 5
[10:18:31.236]  $ ...future.FUN            :function (object, ...)  
[10:18:31.236]  $ future.call.arguments    : list()
[10:18:31.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.236]  $ ...future.elements_ii    :List of 3
[10:18:31.236]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.236]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.236]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.236]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.236]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.236]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.236]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.236]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.236]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.236]  $ ...future.seeds_ii       : NULL
[10:18:31.236]  $ ...future.globals.maxSize: NULL
[10:18:31.236]  - attr(*, "where")=List of 5
[10:18:31.236]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.236]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.236]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.236]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.236]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.236]  - attr(*, "resolved")= logi FALSE
[10:18:31.236]  - attr(*, "total_size")= num 15670
[10:18:31.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.236]  - attr(*, "already-done")= logi TRUE
[10:18:31.245] - copied ‘...future.FUN’ to environment
[10:18:31.246] - copied ‘future.call.arguments’ to environment
[10:18:31.246] - copied ‘...future.elements_ii’ to environment
[10:18:31.246] - copied ‘...future.seeds_ii’ to environment
[10:18:31.246] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.246] assign_globals() ... done
[10:18:31.246] plan(): Setting new future strategy stack:
[10:18:31.246] List of future strategies:
[10:18:31.246] 1. sequential:
[10:18:31.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.246]    - tweaked: FALSE
[10:18:31.246]    - call: NULL
[10:18:31.247] plan(): nbrOfWorkers() = 1
[10:18:31.249] plan(): Setting new future strategy stack:
[10:18:31.249] List of future strategies:
[10:18:31.249] 1. multisession:
[10:18:31.249]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.249]    - tweaked: FALSE
[10:18:31.249]    - call: plan(strategy)
[10:18:31.251] plan(): nbrOfWorkers() = 1
[10:18:31.251] SequentialFuture started (and completed)
[10:18:31.251] - Launch lazy future ... done
[10:18:31.251] run() for ‘SequentialFuture’ ... done
[10:18:31.251] Created future:
[10:18:31.251] SequentialFuture:
[10:18:31.251] Label: ‘future_by-1’
[10:18:31.251] Expression:
[10:18:31.251] {
[10:18:31.251]     do.call(function(...) {
[10:18:31.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.251]             on.exit(options(oopts), add = TRUE)
[10:18:31.251]         }
[10:18:31.251]         {
[10:18:31.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.251]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.251]             })
[10:18:31.251]         }
[10:18:31.251]     }, args = future.call.arguments)
[10:18:31.251] }
[10:18:31.251] Lazy evaluation: FALSE
[10:18:31.251] Asynchronous evaluation: FALSE
[10:18:31.251] Local evaluation: TRUE
[10:18:31.251] Environment: R_GlobalEnv
[10:18:31.251] Capture standard output: TRUE
[10:18:31.251] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.251] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.251] Packages: <none>
[10:18:31.251] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.251] Resolved: TRUE
[10:18:31.251] Value: 1.16 KiB of class ‘list’
[10:18:31.251] Early signaling: FALSE
[10:18:31.251] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.251] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.252] Chunk #1 of 1 ... DONE
[10:18:31.252] Launching 1 futures (chunks) ... DONE
[10:18:31.252] Resolving 1 futures (chunks) ...
[10:18:31.252] resolve() on list ...
[10:18:31.252]  recursive: 0
[10:18:31.253]  length: 1
[10:18:31.253] 
[10:18:31.253] resolved() for ‘SequentialFuture’ ...
[10:18:31.253] - state: ‘finished’
[10:18:31.253] - run: TRUE
[10:18:31.253] - result: ‘FutureResult’
[10:18:31.253] resolved() for ‘SequentialFuture’ ... done
[10:18:31.253] Future #1
[10:18:31.253] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.253] - nx: 1
[10:18:31.254] - relay: TRUE
[10:18:31.254] - stdout: TRUE
[10:18:31.254] - signal: TRUE
[10:18:31.254] - resignal: FALSE
[10:18:31.254] - force: TRUE
[10:18:31.254] - relayed: [n=1] FALSE
[10:18:31.254] - queued futures: [n=1] FALSE
[10:18:31.254]  - until=1
[10:18:31.254]  - relaying element #1
[10:18:31.254] - relayed: [n=1] TRUE
[10:18:31.254] - queued futures: [n=1] TRUE
[10:18:31.255] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.255]  length: 0 (resolved future 1)
[10:18:31.255] Relaying remaining futures
[10:18:31.255] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.255] - nx: 1
[10:18:31.255] - relay: TRUE
[10:18:31.255] - stdout: TRUE
[10:18:31.255] - signal: TRUE
[10:18:31.255] - resignal: FALSE
[10:18:31.255] - force: TRUE
[10:18:31.255] - relayed: [n=1] TRUE
[10:18:31.255] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.256] - relayed: [n=1] TRUE
[10:18:31.256] - queued futures: [n=1] TRUE
[10:18:31.256] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.256] resolve() on list ... DONE
[10:18:31.256]  - Number of value chunks collected: 1
[10:18:31.256] Resolving 1 futures (chunks) ... DONE
[10:18:31.256] Reducing values from 1 chunks ...
[10:18:31.256]  - Number of values collected after concatenation: 3
[10:18:31.256]  - Number of values expected: 3
[10:18:31.256] Reducing values from 1 chunks ... DONE
[10:18:31.256] future_lapply() ... DONE
[10:18:31.257] future_by_internal() ... DONE
[10:18:31.257] future_by_internal() ...
[10:18:31.257] future_lapply() ...
[10:18:31.259] Number of chunks: 1
[10:18:31.259] getGlobalsAndPackagesXApply() ...
[10:18:31.259]  - future.globals: TRUE
[10:18:31.259] getGlobalsAndPackages() ...
[10:18:31.259] Searching for globals...
[10:18:31.260] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.261] Searching for globals ... DONE
[10:18:31.261] Resolving globals: FALSE
[10:18:31.263] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.263] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.263] - globals: [1] ‘FUN’
[10:18:31.263] 
[10:18:31.264] getGlobalsAndPackages() ... DONE
[10:18:31.264]  - globals found/used: [n=1] ‘FUN’
[10:18:31.264]  - needed namespaces: [n=0] 
[10:18:31.264] Finding globals ... DONE
[10:18:31.264]  - use_args: TRUE
[10:18:31.264]  - Getting '...' globals ...
[10:18:31.264] resolve() on list ...
[10:18:31.265]  recursive: 0
[10:18:31.265]  length: 1
[10:18:31.265]  elements: ‘...’
[10:18:31.265]  length: 0 (resolved future 1)
[10:18:31.265] resolve() on list ... DONE
[10:18:31.265]    - '...' content: [n=1] ‘digits’
[10:18:31.265] List of 1
[10:18:31.265]  $ ...:List of 1
[10:18:31.265]   ..$ digits: int 2
[10:18:31.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.265]  - attr(*, "where")=List of 1
[10:18:31.265]   ..$ ...:<environment: 0x55844a5e1f00> 
[10:18:31.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.265]  - attr(*, "resolved")= logi TRUE
[10:18:31.265]  - attr(*, "total_size")= num NA
[10:18:31.268]  - Getting '...' globals ... DONE
[10:18:31.268] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.268] List of 2
[10:18:31.268]  $ ...future.FUN:function (object, ...)  
[10:18:31.268]  $ ...          :List of 1
[10:18:31.268]   ..$ digits: int 2
[10:18:31.268]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.268]  - attr(*, "where")=List of 2
[10:18:31.268]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.268]   ..$ ...          :<environment: 0x55844a5e1f00> 
[10:18:31.268]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.268]  - attr(*, "resolved")= logi FALSE
[10:18:31.268]  - attr(*, "total_size")= num 13284
[10:18:31.271] Packages to be attached in all futures: [n=0] 
[10:18:31.271] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.272] Number of futures (= number of chunks): 1
[10:18:31.272] Launching 1 futures (chunks) ...
[10:18:31.272] Chunk #1 of 1 ...
[10:18:31.272]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.272] getGlobalsAndPackages() ...
[10:18:31.272] Searching for globals...
[10:18:31.272] 
[10:18:31.272] Searching for globals ... DONE
[10:18:31.272] - globals: [0] <none>
[10:18:31.273] getGlobalsAndPackages() ... DONE
[10:18:31.273]    + additional globals found: [n=0] 
[10:18:31.273]    + additional namespaces needed: [n=0] 
[10:18:31.273]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.273]  - seeds: <none>
[10:18:31.273]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.273] getGlobalsAndPackages() ...
[10:18:31.273] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.273] Resolving globals: FALSE
[10:18:31.273] Tweak future expression to call with '...' arguments ...
[10:18:31.273] {
[10:18:31.273]     do.call(function(...) {
[10:18:31.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.273]             on.exit(options(oopts), add = TRUE)
[10:18:31.273]         }
[10:18:31.273]         {
[10:18:31.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.273]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.273]             })
[10:18:31.273]         }
[10:18:31.273]     }, args = future.call.arguments)
[10:18:31.273] }
[10:18:31.274] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.274] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.274] 
[10:18:31.274] getGlobalsAndPackages() ... DONE
[10:18:31.275] run() for ‘Future’ ...
[10:18:31.275] - state: ‘created’
[10:18:31.275] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.276] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.276]   - Field: ‘label’
[10:18:31.277]   - Field: ‘local’
[10:18:31.277]   - Field: ‘owner’
[10:18:31.277]   - Field: ‘envir’
[10:18:31.277]   - Field: ‘packages’
[10:18:31.277]   - Field: ‘gc’
[10:18:31.277]   - Field: ‘conditions’
[10:18:31.277]   - Field: ‘expr’
[10:18:31.277]   - Field: ‘uuid’
[10:18:31.277]   - Field: ‘seed’
[10:18:31.277]   - Field: ‘version’
[10:18:31.277]   - Field: ‘result’
[10:18:31.278]   - Field: ‘asynchronous’
[10:18:31.278]   - Field: ‘calls’
[10:18:31.278]   - Field: ‘globals’
[10:18:31.278]   - Field: ‘stdout’
[10:18:31.278]   - Field: ‘earlySignal’
[10:18:31.278]   - Field: ‘lazy’
[10:18:31.278]   - Field: ‘state’
[10:18:31.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.278] - Launch lazy future ...
[10:18:31.278] Packages needed by the future expression (n = 0): <none>
[10:18:31.279] Packages needed by future strategies (n = 0): <none>
[10:18:31.279] {
[10:18:31.279]     {
[10:18:31.279]         {
[10:18:31.279]             ...future.startTime <- base::Sys.time()
[10:18:31.279]             {
[10:18:31.279]                 {
[10:18:31.279]                   {
[10:18:31.279]                     base::local({
[10:18:31.279]                       has_future <- base::requireNamespace("future", 
[10:18:31.279]                         quietly = TRUE)
[10:18:31.279]                       if (has_future) {
[10:18:31.279]                         ns <- base::getNamespace("future")
[10:18:31.279]                         version <- ns[[".package"]][["version"]]
[10:18:31.279]                         if (is.null(version)) 
[10:18:31.279]                           version <- utils::packageVersion("future")
[10:18:31.279]                       }
[10:18:31.279]                       else {
[10:18:31.279]                         version <- NULL
[10:18:31.279]                       }
[10:18:31.279]                       if (!has_future || version < "1.8.0") {
[10:18:31.279]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.279]                           "", base::R.version$version.string), 
[10:18:31.279]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.279]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.279]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.279]                             "release", "version")], collapse = " "), 
[10:18:31.279]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.279]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.279]                           info)
[10:18:31.279]                         info <- base::paste(info, collapse = "; ")
[10:18:31.279]                         if (!has_future) {
[10:18:31.279]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.279]                             info)
[10:18:31.279]                         }
[10:18:31.279]                         else {
[10:18:31.279]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.279]                             info, version)
[10:18:31.279]                         }
[10:18:31.279]                         base::stop(msg)
[10:18:31.279]                       }
[10:18:31.279]                     })
[10:18:31.279]                   }
[10:18:31.279]                   ...future.strategy.old <- future::plan("list")
[10:18:31.279]                   options(future.plan = NULL)
[10:18:31.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.279]                 }
[10:18:31.279]                 ...future.workdir <- getwd()
[10:18:31.279]             }
[10:18:31.279]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.279]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.279]         }
[10:18:31.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.279]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.279]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.279]             base::names(...future.oldOptions))
[10:18:31.279]     }
[10:18:31.279]     if (FALSE) {
[10:18:31.279]     }
[10:18:31.279]     else {
[10:18:31.279]         if (TRUE) {
[10:18:31.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.279]                 open = "w")
[10:18:31.279]         }
[10:18:31.279]         else {
[10:18:31.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.279]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.279]         }
[10:18:31.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.279]             base::sink(type = "output", split = FALSE)
[10:18:31.279]             base::close(...future.stdout)
[10:18:31.279]         }, add = TRUE)
[10:18:31.279]     }
[10:18:31.279]     ...future.frame <- base::sys.nframe()
[10:18:31.279]     ...future.conditions <- base::list()
[10:18:31.279]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.279]     if (FALSE) {
[10:18:31.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.279]     }
[10:18:31.279]     ...future.result <- base::tryCatch({
[10:18:31.279]         base::withCallingHandlers({
[10:18:31.279]             ...future.value <- base::withVisible(base::local({
[10:18:31.279]                 do.call(function(...) {
[10:18:31.279]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.279]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.279]                     ...future.globals.maxSize)) {
[10:18:31.279]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.279]                     on.exit(options(oopts), add = TRUE)
[10:18:31.279]                   }
[10:18:31.279]                   {
[10:18:31.279]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.279]                       FUN = function(jj) {
[10:18:31.279]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.279]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.279]                       })
[10:18:31.279]                   }
[10:18:31.279]                 }, args = future.call.arguments)
[10:18:31.279]             }))
[10:18:31.279]             future::FutureResult(value = ...future.value$value, 
[10:18:31.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.279]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.279]                     ...future.globalenv.names))
[10:18:31.279]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.279]         }, condition = base::local({
[10:18:31.279]             c <- base::c
[10:18:31.279]             inherits <- base::inherits
[10:18:31.279]             invokeRestart <- base::invokeRestart
[10:18:31.279]             length <- base::length
[10:18:31.279]             list <- base::list
[10:18:31.279]             seq.int <- base::seq.int
[10:18:31.279]             signalCondition <- base::signalCondition
[10:18:31.279]             sys.calls <- base::sys.calls
[10:18:31.279]             `[[` <- base::`[[`
[10:18:31.279]             `+` <- base::`+`
[10:18:31.279]             `<<-` <- base::`<<-`
[10:18:31.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.279]                   3L)]
[10:18:31.279]             }
[10:18:31.279]             function(cond) {
[10:18:31.279]                 is_error <- inherits(cond, "error")
[10:18:31.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.279]                   NULL)
[10:18:31.279]                 if (is_error) {
[10:18:31.279]                   sessionInformation <- function() {
[10:18:31.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.279]                       search = base::search(), system = base::Sys.info())
[10:18:31.279]                   }
[10:18:31.279]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.279]                     cond$call), session = sessionInformation(), 
[10:18:31.279]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.279]                   signalCondition(cond)
[10:18:31.279]                 }
[10:18:31.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.279]                 "immediateCondition"))) {
[10:18:31.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.279]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.279]                   if (TRUE && !signal) {
[10:18:31.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.279]                     {
[10:18:31.279]                       inherits <- base::inherits
[10:18:31.279]                       invokeRestart <- base::invokeRestart
[10:18:31.279]                       is.null <- base::is.null
[10:18:31.279]                       muffled <- FALSE
[10:18:31.279]                       if (inherits(cond, "message")) {
[10:18:31.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.279]                         if (muffled) 
[10:18:31.279]                           invokeRestart("muffleMessage")
[10:18:31.279]                       }
[10:18:31.279]                       else if (inherits(cond, "warning")) {
[10:18:31.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.279]                         if (muffled) 
[10:18:31.279]                           invokeRestart("muffleWarning")
[10:18:31.279]                       }
[10:18:31.279]                       else if (inherits(cond, "condition")) {
[10:18:31.279]                         if (!is.null(pattern)) {
[10:18:31.279]                           computeRestarts <- base::computeRestarts
[10:18:31.279]                           grepl <- base::grepl
[10:18:31.279]                           restarts <- computeRestarts(cond)
[10:18:31.279]                           for (restart in restarts) {
[10:18:31.279]                             name <- restart$name
[10:18:31.279]                             if (is.null(name)) 
[10:18:31.279]                               next
[10:18:31.279]                             if (!grepl(pattern, name)) 
[10:18:31.279]                               next
[10:18:31.279]                             invokeRestart(restart)
[10:18:31.279]                             muffled <- TRUE
[10:18:31.279]                             break
[10:18:31.279]                           }
[10:18:31.279]                         }
[10:18:31.279]                       }
[10:18:31.279]                       invisible(muffled)
[10:18:31.279]                     }
[10:18:31.279]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.279]                   }
[10:18:31.279]                 }
[10:18:31.279]                 else {
[10:18:31.279]                   if (TRUE) {
[10:18:31.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.279]                     {
[10:18:31.279]                       inherits <- base::inherits
[10:18:31.279]                       invokeRestart <- base::invokeRestart
[10:18:31.279]                       is.null <- base::is.null
[10:18:31.279]                       muffled <- FALSE
[10:18:31.279]                       if (inherits(cond, "message")) {
[10:18:31.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.279]                         if (muffled) 
[10:18:31.279]                           invokeRestart("muffleMessage")
[10:18:31.279]                       }
[10:18:31.279]                       else if (inherits(cond, "warning")) {
[10:18:31.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.279]                         if (muffled) 
[10:18:31.279]                           invokeRestart("muffleWarning")
[10:18:31.279]                       }
[10:18:31.279]                       else if (inherits(cond, "condition")) {
[10:18:31.279]                         if (!is.null(pattern)) {
[10:18:31.279]                           computeRestarts <- base::computeRestarts
[10:18:31.279]                           grepl <- base::grepl
[10:18:31.279]                           restarts <- computeRestarts(cond)
[10:18:31.279]                           for (restart in restarts) {
[10:18:31.279]                             name <- restart$name
[10:18:31.279]                             if (is.null(name)) 
[10:18:31.279]                               next
[10:18:31.279]                             if (!grepl(pattern, name)) 
[10:18:31.279]                               next
[10:18:31.279]                             invokeRestart(restart)
[10:18:31.279]                             muffled <- TRUE
[10:18:31.279]                             break
[10:18:31.279]                           }
[10:18:31.279]                         }
[10:18:31.279]                       }
[10:18:31.279]                       invisible(muffled)
[10:18:31.279]                     }
[10:18:31.279]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.279]                   }
[10:18:31.279]                 }
[10:18:31.279]             }
[10:18:31.279]         }))
[10:18:31.279]     }, error = function(ex) {
[10:18:31.279]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.279]                 ...future.rng), started = ...future.startTime, 
[10:18:31.279]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.279]             version = "1.8"), class = "FutureResult")
[10:18:31.279]     }, finally = {
[10:18:31.279]         if (!identical(...future.workdir, getwd())) 
[10:18:31.279]             setwd(...future.workdir)
[10:18:31.279]         {
[10:18:31.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.279]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.279]             }
[10:18:31.279]             base::options(...future.oldOptions)
[10:18:31.279]             if (.Platform$OS.type == "windows") {
[10:18:31.279]                 old_names <- names(...future.oldEnvVars)
[10:18:31.279]                 envs <- base::Sys.getenv()
[10:18:31.279]                 names <- names(envs)
[10:18:31.279]                 common <- intersect(names, old_names)
[10:18:31.279]                 added <- setdiff(names, old_names)
[10:18:31.279]                 removed <- setdiff(old_names, names)
[10:18:31.279]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.279]                   envs[common]]
[10:18:31.279]                 NAMES <- toupper(changed)
[10:18:31.279]                 args <- list()
[10:18:31.279]                 for (kk in seq_along(NAMES)) {
[10:18:31.279]                   name <- changed[[kk]]
[10:18:31.279]                   NAME <- NAMES[[kk]]
[10:18:31.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.279]                     next
[10:18:31.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.279]                 }
[10:18:31.279]                 NAMES <- toupper(added)
[10:18:31.279]                 for (kk in seq_along(NAMES)) {
[10:18:31.279]                   name <- added[[kk]]
[10:18:31.279]                   NAME <- NAMES[[kk]]
[10:18:31.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.279]                     next
[10:18:31.279]                   args[[name]] <- ""
[10:18:31.279]                 }
[10:18:31.279]                 NAMES <- toupper(removed)
[10:18:31.279]                 for (kk in seq_along(NAMES)) {
[10:18:31.279]                   name <- removed[[kk]]
[10:18:31.279]                   NAME <- NAMES[[kk]]
[10:18:31.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.279]                     next
[10:18:31.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.279]                 }
[10:18:31.279]                 if (length(args) > 0) 
[10:18:31.279]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.279]             }
[10:18:31.279]             else {
[10:18:31.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.279]             }
[10:18:31.279]             {
[10:18:31.279]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.279]                   0L) {
[10:18:31.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.279]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.279]                   base::options(opts)
[10:18:31.279]                 }
[10:18:31.279]                 {
[10:18:31.279]                   {
[10:18:31.279]                     NULL
[10:18:31.279]                     RNGkind("Mersenne-Twister")
[10:18:31.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.279]                       inherits = FALSE)
[10:18:31.279]                   }
[10:18:31.279]                   options(future.plan = NULL)
[10:18:31.279]                   if (is.na(NA_character_)) 
[10:18:31.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.279]                     .init = FALSE)
[10:18:31.279]                 }
[10:18:31.279]             }
[10:18:31.279]         }
[10:18:31.279]     })
[10:18:31.279]     if (TRUE) {
[10:18:31.279]         base::sink(type = "output", split = FALSE)
[10:18:31.279]         if (TRUE) {
[10:18:31.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.279]         }
[10:18:31.279]         else {
[10:18:31.279]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.279]         }
[10:18:31.279]         base::close(...future.stdout)
[10:18:31.279]         ...future.stdout <- NULL
[10:18:31.279]     }
[10:18:31.279]     ...future.result$conditions <- ...future.conditions
[10:18:31.279]     ...future.result$finished <- base::Sys.time()
[10:18:31.279]     ...future.result
[10:18:31.279] }
[10:18:31.281] assign_globals() ...
[10:18:31.281] List of 5
[10:18:31.281]  $ ...future.FUN            :function (object, ...)  
[10:18:31.281]  $ future.call.arguments    :List of 1
[10:18:31.281]   ..$ digits: int 2
[10:18:31.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.281]  $ ...future.elements_ii    :List of 6
[10:18:31.281]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:18:31.281]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:18:31.281]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:18:31.281]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:18:31.281]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:18:31.281]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:18:31.281]  $ ...future.seeds_ii       : NULL
[10:18:31.281]  $ ...future.globals.maxSize: NULL
[10:18:31.281]  - attr(*, "where")=List of 5
[10:18:31.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.281]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.281]  - attr(*, "resolved")= logi FALSE
[10:18:31.281]  - attr(*, "total_size")= num 13284
[10:18:31.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.281]  - attr(*, "already-done")= logi TRUE
[10:18:31.289] - copied ‘...future.FUN’ to environment
[10:18:31.289] - copied ‘future.call.arguments’ to environment
[10:18:31.290] - copied ‘...future.elements_ii’ to environment
[10:18:31.290] - copied ‘...future.seeds_ii’ to environment
[10:18:31.290] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.290] assign_globals() ... done
[10:18:31.290] plan(): Setting new future strategy stack:
[10:18:31.290] List of future strategies:
[10:18:31.290] 1. sequential:
[10:18:31.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.290]    - tweaked: FALSE
[10:18:31.290]    - call: NULL
[10:18:31.291] plan(): nbrOfWorkers() = 1
[10:18:31.292] plan(): Setting new future strategy stack:
[10:18:31.292] List of future strategies:
[10:18:31.292] 1. multisession:
[10:18:31.292]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.292]    - tweaked: FALSE
[10:18:31.292]    - call: plan(strategy)
[10:18:31.294] plan(): nbrOfWorkers() = 1
[10:18:31.294] SequentialFuture started (and completed)
[10:18:31.294] - Launch lazy future ... done
[10:18:31.294] run() for ‘SequentialFuture’ ... done
[10:18:31.294] Created future:
[10:18:31.294] SequentialFuture:
[10:18:31.294] Label: ‘future_by-1’
[10:18:31.294] Expression:
[10:18:31.294] {
[10:18:31.294]     do.call(function(...) {
[10:18:31.294]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.294]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.294]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.294]             on.exit(options(oopts), add = TRUE)
[10:18:31.294]         }
[10:18:31.294]         {
[10:18:31.294]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.294]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.294]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.294]             })
[10:18:31.294]         }
[10:18:31.294]     }, args = future.call.arguments)
[10:18:31.294] }
[10:18:31.294] Lazy evaluation: FALSE
[10:18:31.294] Asynchronous evaluation: FALSE
[10:18:31.294] Local evaluation: TRUE
[10:18:31.294] Environment: R_GlobalEnv
[10:18:31.294] Capture standard output: TRUE
[10:18:31.294] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.294] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.294] Packages: <none>
[10:18:31.294] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.294] Resolved: TRUE
[10:18:31.294] Value: 1.27 KiB of class ‘list’
[10:18:31.294] Early signaling: FALSE
[10:18:31.294] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.294] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.295] Chunk #1 of 1 ... DONE
[10:18:31.295] Launching 1 futures (chunks) ... DONE
[10:18:31.295] Resolving 1 futures (chunks) ...
[10:18:31.295] resolve() on list ...
[10:18:31.295]  recursive: 0
[10:18:31.296]  length: 1
[10:18:31.296] 
[10:18:31.296] resolved() for ‘SequentialFuture’ ...
[10:18:31.296] - state: ‘finished’
[10:18:31.296] - run: TRUE
[10:18:31.296] - result: ‘FutureResult’
[10:18:31.296] resolved() for ‘SequentialFuture’ ... done
[10:18:31.296] Future #1
[10:18:31.296] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.296] - nx: 1
[10:18:31.297] - relay: TRUE
[10:18:31.297] - stdout: TRUE
[10:18:31.297] - signal: TRUE
[10:18:31.297] - resignal: FALSE
[10:18:31.297] - force: TRUE
[10:18:31.297] - relayed: [n=1] FALSE
[10:18:31.297] - queued futures: [n=1] FALSE
[10:18:31.297]  - until=1
[10:18:31.297]  - relaying element #1
[10:18:31.297] - relayed: [n=1] TRUE
[10:18:31.297] - queued futures: [n=1] TRUE
[10:18:31.298] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.298]  length: 0 (resolved future 1)
[10:18:31.298] Relaying remaining futures
[10:18:31.298] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.298] - nx: 1
[10:18:31.298] - relay: TRUE
[10:18:31.298] - stdout: TRUE
[10:18:31.298] - signal: TRUE
[10:18:31.298] - resignal: FALSE
[10:18:31.298] - force: TRUE
[10:18:31.298] - relayed: [n=1] TRUE
[10:18:31.298] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.299] - relayed: [n=1] TRUE
[10:18:31.299] - queued futures: [n=1] TRUE
[10:18:31.299] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.299] resolve() on list ... DONE
[10:18:31.299]  - Number of value chunks collected: 1
[10:18:31.299] Resolving 1 futures (chunks) ... DONE
[10:18:31.299] Reducing values from 1 chunks ...
[10:18:31.299]  - Number of values collected after concatenation: 6
[10:18:31.299]  - Number of values expected: 6
[10:18:31.299] Reducing values from 1 chunks ... DONE
[10:18:31.299] future_lapply() ... DONE
[10:18:31.300] future_by_internal() ... DONE
[10:18:31.301] future_by_internal() ...
[10:18:31.301] future_lapply() ...
[10:18:31.303] Number of chunks: 1
[10:18:31.303] getGlobalsAndPackagesXApply() ...
[10:18:31.303]  - future.globals: TRUE
[10:18:31.303] getGlobalsAndPackages() ...
[10:18:31.303] Searching for globals...
[10:18:31.305] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:31.307] Searching for globals ... DONE
[10:18:31.307] Resolving globals: FALSE
[10:18:31.307] The total size of the 1 globals is 762 bytes (762 bytes)
[10:18:31.308] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:18:31.308] - globals: [1] ‘FUN’
[10:18:31.308] - packages: [1] ‘stats’
[10:18:31.308] getGlobalsAndPackages() ... DONE
[10:18:31.308]  - globals found/used: [n=1] ‘FUN’
[10:18:31.308]  - needed namespaces: [n=1] ‘stats’
[10:18:31.309] Finding globals ... DONE
[10:18:31.309]  - use_args: TRUE
[10:18:31.309]  - Getting '...' globals ...
[10:18:31.309] resolve() on list ...
[10:18:31.309]  recursive: 0
[10:18:31.309]  length: 1
[10:18:31.309]  elements: ‘...’
[10:18:31.310]  length: 0 (resolved future 1)
[10:18:31.310] resolve() on list ... DONE
[10:18:31.310]    - '...' content: [n=1] ‘singular.ok’
[10:18:31.310] List of 1
[10:18:31.310]  $ ...:List of 1
[10:18:31.310]   ..$ singular.ok: logi FALSE
[10:18:31.310]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.310]  - attr(*, "where")=List of 1
[10:18:31.310]   ..$ ...:<environment: 0x55844a4c5688> 
[10:18:31.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.310]  - attr(*, "resolved")= logi TRUE
[10:18:31.310]  - attr(*, "total_size")= num NA
[10:18:31.313]  - Getting '...' globals ... DONE
[10:18:31.313] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.313] List of 2
[10:18:31.313]  $ ...future.FUN:function (x, ...)  
[10:18:31.313]  $ ...          :List of 1
[10:18:31.313]   ..$ singular.ok: logi FALSE
[10:18:31.313]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.313]  - attr(*, "where")=List of 2
[10:18:31.313]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.313]   ..$ ...          :<environment: 0x55844a4c5688> 
[10:18:31.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.313]  - attr(*, "resolved")= logi FALSE
[10:18:31.313]  - attr(*, "total_size")= num 19977
[10:18:31.316] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:31.316] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.316] Number of futures (= number of chunks): 1
[10:18:31.317] Launching 1 futures (chunks) ...
[10:18:31.317] Chunk #1 of 1 ...
[10:18:31.317]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.317] getGlobalsAndPackages() ...
[10:18:31.317] Searching for globals...
[10:18:31.317] 
[10:18:31.318] Searching for globals ... DONE
[10:18:31.318] - globals: [0] <none>
[10:18:31.318] getGlobalsAndPackages() ... DONE
[10:18:31.318]    + additional globals found: [n=0] 
[10:18:31.318]    + additional namespaces needed: [n=0] 
[10:18:31.318]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.318]  - seeds: <none>
[10:18:31.318]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.318] getGlobalsAndPackages() ...
[10:18:31.318] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.318] Resolving globals: FALSE
[10:18:31.319] Tweak future expression to call with '...' arguments ...
[10:18:31.319] {
[10:18:31.319]     do.call(function(...) {
[10:18:31.319]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.319]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.319]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.319]             on.exit(options(oopts), add = TRUE)
[10:18:31.319]         }
[10:18:31.319]         {
[10:18:31.319]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.319]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.319]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.319]             })
[10:18:31.319]         }
[10:18:31.319]     }, args = future.call.arguments)
[10:18:31.319] }
[10:18:31.319] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.319] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.319] 
[10:18:31.319] getGlobalsAndPackages() ... DONE
[10:18:31.320] run() for ‘Future’ ...
[10:18:31.320] - state: ‘created’
[10:18:31.320] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.322] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.322]   - Field: ‘label’
[10:18:31.322]   - Field: ‘local’
[10:18:31.322]   - Field: ‘owner’
[10:18:31.322]   - Field: ‘envir’
[10:18:31.322]   - Field: ‘packages’
[10:18:31.322]   - Field: ‘gc’
[10:18:31.322]   - Field: ‘conditions’
[10:18:31.322]   - Field: ‘expr’
[10:18:31.322]   - Field: ‘uuid’
[10:18:31.323]   - Field: ‘seed’
[10:18:31.323]   - Field: ‘version’
[10:18:31.323]   - Field: ‘result’
[10:18:31.323]   - Field: ‘asynchronous’
[10:18:31.323]   - Field: ‘calls’
[10:18:31.323]   - Field: ‘globals’
[10:18:31.323]   - Field: ‘stdout’
[10:18:31.323]   - Field: ‘earlySignal’
[10:18:31.323]   - Field: ‘lazy’
[10:18:31.323]   - Field: ‘state’
[10:18:31.323] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.324] - Launch lazy future ...
[10:18:31.324] Packages needed by the future expression (n = 1): ‘stats’
[10:18:31.324] Packages needed by future strategies (n = 0): <none>
[10:18:31.324] {
[10:18:31.324]     {
[10:18:31.324]         {
[10:18:31.324]             ...future.startTime <- base::Sys.time()
[10:18:31.324]             {
[10:18:31.324]                 {
[10:18:31.324]                   {
[10:18:31.324]                     {
[10:18:31.324]                       base::local({
[10:18:31.324]                         has_future <- base::requireNamespace("future", 
[10:18:31.324]                           quietly = TRUE)
[10:18:31.324]                         if (has_future) {
[10:18:31.324]                           ns <- base::getNamespace("future")
[10:18:31.324]                           version <- ns[[".package"]][["version"]]
[10:18:31.324]                           if (is.null(version)) 
[10:18:31.324]                             version <- utils::packageVersion("future")
[10:18:31.324]                         }
[10:18:31.324]                         else {
[10:18:31.324]                           version <- NULL
[10:18:31.324]                         }
[10:18:31.324]                         if (!has_future || version < "1.8.0") {
[10:18:31.324]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.324]                             "", base::R.version$version.string), 
[10:18:31.324]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.324]                               "release", "version")], collapse = " "), 
[10:18:31.324]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.324]                             info)
[10:18:31.324]                           info <- base::paste(info, collapse = "; ")
[10:18:31.324]                           if (!has_future) {
[10:18:31.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.324]                               info)
[10:18:31.324]                           }
[10:18:31.324]                           else {
[10:18:31.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.324]                               info, version)
[10:18:31.324]                           }
[10:18:31.324]                           base::stop(msg)
[10:18:31.324]                         }
[10:18:31.324]                       })
[10:18:31.324]                     }
[10:18:31.324]                     base::local({
[10:18:31.324]                       for (pkg in "stats") {
[10:18:31.324]                         base::loadNamespace(pkg)
[10:18:31.324]                         base::library(pkg, character.only = TRUE)
[10:18:31.324]                       }
[10:18:31.324]                     })
[10:18:31.324]                   }
[10:18:31.324]                   ...future.strategy.old <- future::plan("list")
[10:18:31.324]                   options(future.plan = NULL)
[10:18:31.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.324]                 }
[10:18:31.324]                 ...future.workdir <- getwd()
[10:18:31.324]             }
[10:18:31.324]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.324]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.324]         }
[10:18:31.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.324]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.324]             base::names(...future.oldOptions))
[10:18:31.324]     }
[10:18:31.324]     if (FALSE) {
[10:18:31.324]     }
[10:18:31.324]     else {
[10:18:31.324]         if (TRUE) {
[10:18:31.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.324]                 open = "w")
[10:18:31.324]         }
[10:18:31.324]         else {
[10:18:31.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.324]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.324]         }
[10:18:31.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.324]             base::sink(type = "output", split = FALSE)
[10:18:31.324]             base::close(...future.stdout)
[10:18:31.324]         }, add = TRUE)
[10:18:31.324]     }
[10:18:31.324]     ...future.frame <- base::sys.nframe()
[10:18:31.324]     ...future.conditions <- base::list()
[10:18:31.324]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.324]     if (FALSE) {
[10:18:31.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.324]     }
[10:18:31.324]     ...future.result <- base::tryCatch({
[10:18:31.324]         base::withCallingHandlers({
[10:18:31.324]             ...future.value <- base::withVisible(base::local({
[10:18:31.324]                 do.call(function(...) {
[10:18:31.324]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.324]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.324]                     ...future.globals.maxSize)) {
[10:18:31.324]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.324]                     on.exit(options(oopts), add = TRUE)
[10:18:31.324]                   }
[10:18:31.324]                   {
[10:18:31.324]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.324]                       FUN = function(jj) {
[10:18:31.324]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.324]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.324]                       })
[10:18:31.324]                   }
[10:18:31.324]                 }, args = future.call.arguments)
[10:18:31.324]             }))
[10:18:31.324]             future::FutureResult(value = ...future.value$value, 
[10:18:31.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.324]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.324]                     ...future.globalenv.names))
[10:18:31.324]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.324]         }, condition = base::local({
[10:18:31.324]             c <- base::c
[10:18:31.324]             inherits <- base::inherits
[10:18:31.324]             invokeRestart <- base::invokeRestart
[10:18:31.324]             length <- base::length
[10:18:31.324]             list <- base::list
[10:18:31.324]             seq.int <- base::seq.int
[10:18:31.324]             signalCondition <- base::signalCondition
[10:18:31.324]             sys.calls <- base::sys.calls
[10:18:31.324]             `[[` <- base::`[[`
[10:18:31.324]             `+` <- base::`+`
[10:18:31.324]             `<<-` <- base::`<<-`
[10:18:31.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.324]                   3L)]
[10:18:31.324]             }
[10:18:31.324]             function(cond) {
[10:18:31.324]                 is_error <- inherits(cond, "error")
[10:18:31.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.324]                   NULL)
[10:18:31.324]                 if (is_error) {
[10:18:31.324]                   sessionInformation <- function() {
[10:18:31.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.324]                       search = base::search(), system = base::Sys.info())
[10:18:31.324]                   }
[10:18:31.324]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.324]                     cond$call), session = sessionInformation(), 
[10:18:31.324]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.324]                   signalCondition(cond)
[10:18:31.324]                 }
[10:18:31.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.324]                 "immediateCondition"))) {
[10:18:31.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.324]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.324]                   if (TRUE && !signal) {
[10:18:31.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.324]                     {
[10:18:31.324]                       inherits <- base::inherits
[10:18:31.324]                       invokeRestart <- base::invokeRestart
[10:18:31.324]                       is.null <- base::is.null
[10:18:31.324]                       muffled <- FALSE
[10:18:31.324]                       if (inherits(cond, "message")) {
[10:18:31.324]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.324]                         if (muffled) 
[10:18:31.324]                           invokeRestart("muffleMessage")
[10:18:31.324]                       }
[10:18:31.324]                       else if (inherits(cond, "warning")) {
[10:18:31.324]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.324]                         if (muffled) 
[10:18:31.324]                           invokeRestart("muffleWarning")
[10:18:31.324]                       }
[10:18:31.324]                       else if (inherits(cond, "condition")) {
[10:18:31.324]                         if (!is.null(pattern)) {
[10:18:31.324]                           computeRestarts <- base::computeRestarts
[10:18:31.324]                           grepl <- base::grepl
[10:18:31.324]                           restarts <- computeRestarts(cond)
[10:18:31.324]                           for (restart in restarts) {
[10:18:31.324]                             name <- restart$name
[10:18:31.324]                             if (is.null(name)) 
[10:18:31.324]                               next
[10:18:31.324]                             if (!grepl(pattern, name)) 
[10:18:31.324]                               next
[10:18:31.324]                             invokeRestart(restart)
[10:18:31.324]                             muffled <- TRUE
[10:18:31.324]                             break
[10:18:31.324]                           }
[10:18:31.324]                         }
[10:18:31.324]                       }
[10:18:31.324]                       invisible(muffled)
[10:18:31.324]                     }
[10:18:31.324]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.324]                   }
[10:18:31.324]                 }
[10:18:31.324]                 else {
[10:18:31.324]                   if (TRUE) {
[10:18:31.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.324]                     {
[10:18:31.324]                       inherits <- base::inherits
[10:18:31.324]                       invokeRestart <- base::invokeRestart
[10:18:31.324]                       is.null <- base::is.null
[10:18:31.324]                       muffled <- FALSE
[10:18:31.324]                       if (inherits(cond, "message")) {
[10:18:31.324]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.324]                         if (muffled) 
[10:18:31.324]                           invokeRestart("muffleMessage")
[10:18:31.324]                       }
[10:18:31.324]                       else if (inherits(cond, "warning")) {
[10:18:31.324]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.324]                         if (muffled) 
[10:18:31.324]                           invokeRestart("muffleWarning")
[10:18:31.324]                       }
[10:18:31.324]                       else if (inherits(cond, "condition")) {
[10:18:31.324]                         if (!is.null(pattern)) {
[10:18:31.324]                           computeRestarts <- base::computeRestarts
[10:18:31.324]                           grepl <- base::grepl
[10:18:31.324]                           restarts <- computeRestarts(cond)
[10:18:31.324]                           for (restart in restarts) {
[10:18:31.324]                             name <- restart$name
[10:18:31.324]                             if (is.null(name)) 
[10:18:31.324]                               next
[10:18:31.324]                             if (!grepl(pattern, name)) 
[10:18:31.324]                               next
[10:18:31.324]                             invokeRestart(restart)
[10:18:31.324]                             muffled <- TRUE
[10:18:31.324]                             break
[10:18:31.324]                           }
[10:18:31.324]                         }
[10:18:31.324]                       }
[10:18:31.324]                       invisible(muffled)
[10:18:31.324]                     }
[10:18:31.324]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.324]                   }
[10:18:31.324]                 }
[10:18:31.324]             }
[10:18:31.324]         }))
[10:18:31.324]     }, error = function(ex) {
[10:18:31.324]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.324]                 ...future.rng), started = ...future.startTime, 
[10:18:31.324]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.324]             version = "1.8"), class = "FutureResult")
[10:18:31.324]     }, finally = {
[10:18:31.324]         if (!identical(...future.workdir, getwd())) 
[10:18:31.324]             setwd(...future.workdir)
[10:18:31.324]         {
[10:18:31.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.324]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.324]             }
[10:18:31.324]             base::options(...future.oldOptions)
[10:18:31.324]             if (.Platform$OS.type == "windows") {
[10:18:31.324]                 old_names <- names(...future.oldEnvVars)
[10:18:31.324]                 envs <- base::Sys.getenv()
[10:18:31.324]                 names <- names(envs)
[10:18:31.324]                 common <- intersect(names, old_names)
[10:18:31.324]                 added <- setdiff(names, old_names)
[10:18:31.324]                 removed <- setdiff(old_names, names)
[10:18:31.324]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.324]                   envs[common]]
[10:18:31.324]                 NAMES <- toupper(changed)
[10:18:31.324]                 args <- list()
[10:18:31.324]                 for (kk in seq_along(NAMES)) {
[10:18:31.324]                   name <- changed[[kk]]
[10:18:31.324]                   NAME <- NAMES[[kk]]
[10:18:31.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.324]                     next
[10:18:31.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.324]                 }
[10:18:31.324]                 NAMES <- toupper(added)
[10:18:31.324]                 for (kk in seq_along(NAMES)) {
[10:18:31.324]                   name <- added[[kk]]
[10:18:31.324]                   NAME <- NAMES[[kk]]
[10:18:31.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.324]                     next
[10:18:31.324]                   args[[name]] <- ""
[10:18:31.324]                 }
[10:18:31.324]                 NAMES <- toupper(removed)
[10:18:31.324]                 for (kk in seq_along(NAMES)) {
[10:18:31.324]                   name <- removed[[kk]]
[10:18:31.324]                   NAME <- NAMES[[kk]]
[10:18:31.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.324]                     next
[10:18:31.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.324]                 }
[10:18:31.324]                 if (length(args) > 0) 
[10:18:31.324]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.324]             }
[10:18:31.324]             else {
[10:18:31.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.324]             }
[10:18:31.324]             {
[10:18:31.324]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.324]                   0L) {
[10:18:31.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.324]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.324]                   base::options(opts)
[10:18:31.324]                 }
[10:18:31.324]                 {
[10:18:31.324]                   {
[10:18:31.324]                     NULL
[10:18:31.324]                     RNGkind("Mersenne-Twister")
[10:18:31.324]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.324]                       inherits = FALSE)
[10:18:31.324]                   }
[10:18:31.324]                   options(future.plan = NULL)
[10:18:31.324]                   if (is.na(NA_character_)) 
[10:18:31.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.324]                     .init = FALSE)
[10:18:31.324]                 }
[10:18:31.324]             }
[10:18:31.324]         }
[10:18:31.324]     })
[10:18:31.324]     if (TRUE) {
[10:18:31.324]         base::sink(type = "output", split = FALSE)
[10:18:31.324]         if (TRUE) {
[10:18:31.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.324]         }
[10:18:31.324]         else {
[10:18:31.324]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.324]         }
[10:18:31.324]         base::close(...future.stdout)
[10:18:31.324]         ...future.stdout <- NULL
[10:18:31.324]     }
[10:18:31.324]     ...future.result$conditions <- ...future.conditions
[10:18:31.324]     ...future.result$finished <- base::Sys.time()
[10:18:31.324]     ...future.result
[10:18:31.324] }
[10:18:31.326] assign_globals() ...
[10:18:31.326] List of 5
[10:18:31.326]  $ ...future.FUN            :function (x, ...)  
[10:18:31.326]  $ future.call.arguments    :List of 1
[10:18:31.326]   ..$ singular.ok: logi FALSE
[10:18:31.326]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.326]  $ ...future.elements_ii    :List of 3
[10:18:31.326]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.326]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.326]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.326]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.326]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.326]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.326]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.326]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.326]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.326]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.326]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.326]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.326]  $ ...future.seeds_ii       : NULL
[10:18:31.326]  $ ...future.globals.maxSize: NULL
[10:18:31.326]  - attr(*, "where")=List of 5
[10:18:31.326]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.326]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.326]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.326]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.326]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.326]  - attr(*, "resolved")= logi FALSE
[10:18:31.326]  - attr(*, "total_size")= num 19977
[10:18:31.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.326]  - attr(*, "already-done")= logi TRUE
[10:18:31.338] - reassign environment for ‘...future.FUN’
[10:18:31.338] - copied ‘...future.FUN’ to environment
[10:18:31.338] - copied ‘future.call.arguments’ to environment
[10:18:31.338] - copied ‘...future.elements_ii’ to environment
[10:18:31.338] - copied ‘...future.seeds_ii’ to environment
[10:18:31.338] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.339] assign_globals() ... done
[10:18:31.339] plan(): Setting new future strategy stack:
[10:18:31.339] List of future strategies:
[10:18:31.339] 1. sequential:
[10:18:31.339]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.339]    - tweaked: FALSE
[10:18:31.339]    - call: NULL
[10:18:31.340] plan(): nbrOfWorkers() = 1
[10:18:31.343] plan(): Setting new future strategy stack:
[10:18:31.343] List of future strategies:
[10:18:31.343] 1. multisession:
[10:18:31.343]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.343]    - tweaked: FALSE
[10:18:31.343]    - call: plan(strategy)
[10:18:31.345] plan(): nbrOfWorkers() = 1
[10:18:31.345] SequentialFuture started (and completed)
[10:18:31.345] - Launch lazy future ... done
[10:18:31.345] run() for ‘SequentialFuture’ ... done
[10:18:31.345] Created future:
[10:18:31.345] SequentialFuture:
[10:18:31.345] Label: ‘future_by-1’
[10:18:31.345] Expression:
[10:18:31.345] {
[10:18:31.345]     do.call(function(...) {
[10:18:31.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.345]             on.exit(options(oopts), add = TRUE)
[10:18:31.345]         }
[10:18:31.345]         {
[10:18:31.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.345]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.345]             })
[10:18:31.345]         }
[10:18:31.345]     }, args = future.call.arguments)
[10:18:31.345] }
[10:18:31.345] Lazy evaluation: FALSE
[10:18:31.345] Asynchronous evaluation: FALSE
[10:18:31.345] Local evaluation: TRUE
[10:18:31.345] Environment: R_GlobalEnv
[10:18:31.345] Capture standard output: TRUE
[10:18:31.345] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.345] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.345] Packages: 1 packages (‘stats’)
[10:18:31.345] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.345] Resolved: TRUE
[10:18:31.345] Value: 81.13 KiB of class ‘list’
[10:18:31.345] Early signaling: FALSE
[10:18:31.345] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.345] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.347] Chunk #1 of 1 ... DONE
[10:18:31.347] Launching 1 futures (chunks) ... DONE
[10:18:31.347] Resolving 1 futures (chunks) ...
[10:18:31.347] resolve() on list ...
[10:18:31.347]  recursive: 0
[10:18:31.347]  length: 1
[10:18:31.347] 
[10:18:31.347] resolved() for ‘SequentialFuture’ ...
[10:18:31.348] - state: ‘finished’
[10:18:31.348] - run: TRUE
[10:18:31.348] - result: ‘FutureResult’
[10:18:31.348] resolved() for ‘SequentialFuture’ ... done
[10:18:31.348] Future #1
[10:18:31.348] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.348] - nx: 1
[10:18:31.348] - relay: TRUE
[10:18:31.348] - stdout: TRUE
[10:18:31.348] - signal: TRUE
[10:18:31.348] - resignal: FALSE
[10:18:31.349] - force: TRUE
[10:18:31.349] - relayed: [n=1] FALSE
[10:18:31.349] - queued futures: [n=1] FALSE
[10:18:31.349]  - until=1
[10:18:31.349]  - relaying element #1
[10:18:31.349] - relayed: [n=1] TRUE
[10:18:31.349] - queued futures: [n=1] TRUE
[10:18:31.349] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.349]  length: 0 (resolved future 1)
[10:18:31.350] Relaying remaining futures
[10:18:31.350] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.350] - nx: 1
[10:18:31.350] - relay: TRUE
[10:18:31.350] - stdout: TRUE
[10:18:31.350] - signal: TRUE
[10:18:31.350] - resignal: FALSE
[10:18:31.350] - force: TRUE
[10:18:31.350] - relayed: [n=1] TRUE
[10:18:31.350] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.350] - relayed: [n=1] TRUE
[10:18:31.350] - queued futures: [n=1] TRUE
[10:18:31.351] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.351] resolve() on list ... DONE
[10:18:31.351]  - Number of value chunks collected: 1
[10:18:31.351] Resolving 1 futures (chunks) ... DONE
[10:18:31.351] Reducing values from 1 chunks ...
[10:18:31.351]  - Number of values collected after concatenation: 3
[10:18:31.351]  - Number of values expected: 3
[10:18:31.351] Reducing values from 1 chunks ... DONE
[10:18:31.351] future_lapply() ... DONE
[10:18:31.351] future_by_internal() ... DONE
[10:18:31.358] future_by_internal() ...
[10:18:31.358] future_lapply() ...
[10:18:31.361] Number of chunks: 1
[10:18:31.361] getGlobalsAndPackagesXApply() ...
[10:18:31.361]  - future.globals: TRUE
[10:18:31.361] getGlobalsAndPackages() ...
[10:18:31.361] Searching for globals...
[10:18:31.363] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:31.363] Searching for globals ... DONE
[10:18:31.363] Resolving globals: FALSE
[10:18:31.364] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:18:31.364] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:18:31.364] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:31.364] - packages: [1] ‘stats’
[10:18:31.365] getGlobalsAndPackages() ... DONE
[10:18:31.365]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:31.365]  - needed namespaces: [n=1] ‘stats’
[10:18:31.365] Finding globals ... DONE
[10:18:31.365]  - use_args: TRUE
[10:18:31.365]  - Getting '...' globals ...
[10:18:31.365] resolve() on list ...
[10:18:31.365]  recursive: 0
[10:18:31.366]  length: 1
[10:18:31.366]  elements: ‘...’
[10:18:31.366]  length: 0 (resolved future 1)
[10:18:31.366] resolve() on list ... DONE
[10:18:31.366]    - '...' content: [n=0] 
[10:18:31.366] List of 1
[10:18:31.366]  $ ...: list()
[10:18:31.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.366]  - attr(*, "where")=List of 1
[10:18:31.366]   ..$ ...:<environment: 0x5584480d6600> 
[10:18:31.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.366]  - attr(*, "resolved")= logi TRUE
[10:18:31.366]  - attr(*, "total_size")= num NA
[10:18:31.369]  - Getting '...' globals ... DONE
[10:18:31.369] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:18:31.369] List of 4
[10:18:31.369]  $ ...future.FUN:function (x)  
[10:18:31.369]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:31.369]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.369]  $ ...          : list()
[10:18:31.369]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.369]  - attr(*, "where")=List of 4
[10:18:31.369]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.369]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:18:31.369]   ..$ wool         :<environment: R_EmptyEnv> 
[10:18:31.369]   ..$ ...          :<environment: 0x5584480d6600> 
[10:18:31.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.369]  - attr(*, "resolved")= logi FALSE
[10:18:31.369]  - attr(*, "total_size")= num 18867
[10:18:31.375] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:31.375] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.375] Number of futures (= number of chunks): 1
[10:18:31.375] Launching 1 futures (chunks) ...
[10:18:31.376] Chunk #1 of 1 ...
[10:18:31.376]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.376] getGlobalsAndPackages() ...
[10:18:31.376] Searching for globals...
[10:18:31.377] 
[10:18:31.377] Searching for globals ... DONE
[10:18:31.377] - globals: [0] <none>
[10:18:31.377] getGlobalsAndPackages() ... DONE
[10:18:31.377]    + additional globals found: [n=0] 
[10:18:31.377]    + additional namespaces needed: [n=0] 
[10:18:31.377]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.377]  - seeds: <none>
[10:18:31.377]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.377] getGlobalsAndPackages() ...
[10:18:31.377] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.378] Resolving globals: FALSE
[10:18:31.378] Tweak future expression to call with '...' arguments ...
[10:18:31.378] {
[10:18:31.378]     do.call(function(...) {
[10:18:31.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.378]             on.exit(options(oopts), add = TRUE)
[10:18:31.378]         }
[10:18:31.378]         {
[10:18:31.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.378]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.378]             })
[10:18:31.378]         }
[10:18:31.378]     }, args = future.call.arguments)
[10:18:31.378] }
[10:18:31.378] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.378] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.379] 
[10:18:31.379] getGlobalsAndPackages() ... DONE
[10:18:31.379] run() for ‘Future’ ...
[10:18:31.379] - state: ‘created’
[10:18:31.379] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.381] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.381]   - Field: ‘label’
[10:18:31.381]   - Field: ‘local’
[10:18:31.381]   - Field: ‘owner’
[10:18:31.381]   - Field: ‘envir’
[10:18:31.382]   - Field: ‘packages’
[10:18:31.382]   - Field: ‘gc’
[10:18:31.382]   - Field: ‘conditions’
[10:18:31.382]   - Field: ‘expr’
[10:18:31.382]   - Field: ‘uuid’
[10:18:31.382]   - Field: ‘seed’
[10:18:31.382]   - Field: ‘version’
[10:18:31.382]   - Field: ‘result’
[10:18:31.382]   - Field: ‘asynchronous’
[10:18:31.382]   - Field: ‘calls’
[10:18:31.382]   - Field: ‘globals’
[10:18:31.383]   - Field: ‘stdout’
[10:18:31.383]   - Field: ‘earlySignal’
[10:18:31.383]   - Field: ‘lazy’
[10:18:31.383]   - Field: ‘state’
[10:18:31.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.383] - Launch lazy future ...
[10:18:31.383] Packages needed by the future expression (n = 1): ‘stats’
[10:18:31.383] Packages needed by future strategies (n = 0): <none>
[10:18:31.384] {
[10:18:31.384]     {
[10:18:31.384]         {
[10:18:31.384]             ...future.startTime <- base::Sys.time()
[10:18:31.384]             {
[10:18:31.384]                 {
[10:18:31.384]                   {
[10:18:31.384]                     {
[10:18:31.384]                       base::local({
[10:18:31.384]                         has_future <- base::requireNamespace("future", 
[10:18:31.384]                           quietly = TRUE)
[10:18:31.384]                         if (has_future) {
[10:18:31.384]                           ns <- base::getNamespace("future")
[10:18:31.384]                           version <- ns[[".package"]][["version"]]
[10:18:31.384]                           if (is.null(version)) 
[10:18:31.384]                             version <- utils::packageVersion("future")
[10:18:31.384]                         }
[10:18:31.384]                         else {
[10:18:31.384]                           version <- NULL
[10:18:31.384]                         }
[10:18:31.384]                         if (!has_future || version < "1.8.0") {
[10:18:31.384]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.384]                             "", base::R.version$version.string), 
[10:18:31.384]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.384]                               "release", "version")], collapse = " "), 
[10:18:31.384]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.384]                             info)
[10:18:31.384]                           info <- base::paste(info, collapse = "; ")
[10:18:31.384]                           if (!has_future) {
[10:18:31.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.384]                               info)
[10:18:31.384]                           }
[10:18:31.384]                           else {
[10:18:31.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.384]                               info, version)
[10:18:31.384]                           }
[10:18:31.384]                           base::stop(msg)
[10:18:31.384]                         }
[10:18:31.384]                       })
[10:18:31.384]                     }
[10:18:31.384]                     base::local({
[10:18:31.384]                       for (pkg in "stats") {
[10:18:31.384]                         base::loadNamespace(pkg)
[10:18:31.384]                         base::library(pkg, character.only = TRUE)
[10:18:31.384]                       }
[10:18:31.384]                     })
[10:18:31.384]                   }
[10:18:31.384]                   ...future.strategy.old <- future::plan("list")
[10:18:31.384]                   options(future.plan = NULL)
[10:18:31.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.384]                 }
[10:18:31.384]                 ...future.workdir <- getwd()
[10:18:31.384]             }
[10:18:31.384]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.384]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.384]         }
[10:18:31.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.384]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.384]             base::names(...future.oldOptions))
[10:18:31.384]     }
[10:18:31.384]     if (FALSE) {
[10:18:31.384]     }
[10:18:31.384]     else {
[10:18:31.384]         if (TRUE) {
[10:18:31.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.384]                 open = "w")
[10:18:31.384]         }
[10:18:31.384]         else {
[10:18:31.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.384]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.384]         }
[10:18:31.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.384]             base::sink(type = "output", split = FALSE)
[10:18:31.384]             base::close(...future.stdout)
[10:18:31.384]         }, add = TRUE)
[10:18:31.384]     }
[10:18:31.384]     ...future.frame <- base::sys.nframe()
[10:18:31.384]     ...future.conditions <- base::list()
[10:18:31.384]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.384]     if (FALSE) {
[10:18:31.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.384]     }
[10:18:31.384]     ...future.result <- base::tryCatch({
[10:18:31.384]         base::withCallingHandlers({
[10:18:31.384]             ...future.value <- base::withVisible(base::local({
[10:18:31.384]                 do.call(function(...) {
[10:18:31.384]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.384]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.384]                     ...future.globals.maxSize)) {
[10:18:31.384]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.384]                     on.exit(options(oopts), add = TRUE)
[10:18:31.384]                   }
[10:18:31.384]                   {
[10:18:31.384]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.384]                       FUN = function(jj) {
[10:18:31.384]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.384]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.384]                       })
[10:18:31.384]                   }
[10:18:31.384]                 }, args = future.call.arguments)
[10:18:31.384]             }))
[10:18:31.384]             future::FutureResult(value = ...future.value$value, 
[10:18:31.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.384]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.384]                     ...future.globalenv.names))
[10:18:31.384]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.384]         }, condition = base::local({
[10:18:31.384]             c <- base::c
[10:18:31.384]             inherits <- base::inherits
[10:18:31.384]             invokeRestart <- base::invokeRestart
[10:18:31.384]             length <- base::length
[10:18:31.384]             list <- base::list
[10:18:31.384]             seq.int <- base::seq.int
[10:18:31.384]             signalCondition <- base::signalCondition
[10:18:31.384]             sys.calls <- base::sys.calls
[10:18:31.384]             `[[` <- base::`[[`
[10:18:31.384]             `+` <- base::`+`
[10:18:31.384]             `<<-` <- base::`<<-`
[10:18:31.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.384]                   3L)]
[10:18:31.384]             }
[10:18:31.384]             function(cond) {
[10:18:31.384]                 is_error <- inherits(cond, "error")
[10:18:31.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.384]                   NULL)
[10:18:31.384]                 if (is_error) {
[10:18:31.384]                   sessionInformation <- function() {
[10:18:31.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.384]                       search = base::search(), system = base::Sys.info())
[10:18:31.384]                   }
[10:18:31.384]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.384]                     cond$call), session = sessionInformation(), 
[10:18:31.384]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.384]                   signalCondition(cond)
[10:18:31.384]                 }
[10:18:31.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.384]                 "immediateCondition"))) {
[10:18:31.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.384]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.384]                   if (TRUE && !signal) {
[10:18:31.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.384]                     {
[10:18:31.384]                       inherits <- base::inherits
[10:18:31.384]                       invokeRestart <- base::invokeRestart
[10:18:31.384]                       is.null <- base::is.null
[10:18:31.384]                       muffled <- FALSE
[10:18:31.384]                       if (inherits(cond, "message")) {
[10:18:31.384]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.384]                         if (muffled) 
[10:18:31.384]                           invokeRestart("muffleMessage")
[10:18:31.384]                       }
[10:18:31.384]                       else if (inherits(cond, "warning")) {
[10:18:31.384]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.384]                         if (muffled) 
[10:18:31.384]                           invokeRestart("muffleWarning")
[10:18:31.384]                       }
[10:18:31.384]                       else if (inherits(cond, "condition")) {
[10:18:31.384]                         if (!is.null(pattern)) {
[10:18:31.384]                           computeRestarts <- base::computeRestarts
[10:18:31.384]                           grepl <- base::grepl
[10:18:31.384]                           restarts <- computeRestarts(cond)
[10:18:31.384]                           for (restart in restarts) {
[10:18:31.384]                             name <- restart$name
[10:18:31.384]                             if (is.null(name)) 
[10:18:31.384]                               next
[10:18:31.384]                             if (!grepl(pattern, name)) 
[10:18:31.384]                               next
[10:18:31.384]                             invokeRestart(restart)
[10:18:31.384]                             muffled <- TRUE
[10:18:31.384]                             break
[10:18:31.384]                           }
[10:18:31.384]                         }
[10:18:31.384]                       }
[10:18:31.384]                       invisible(muffled)
[10:18:31.384]                     }
[10:18:31.384]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.384]                   }
[10:18:31.384]                 }
[10:18:31.384]                 else {
[10:18:31.384]                   if (TRUE) {
[10:18:31.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.384]                     {
[10:18:31.384]                       inherits <- base::inherits
[10:18:31.384]                       invokeRestart <- base::invokeRestart
[10:18:31.384]                       is.null <- base::is.null
[10:18:31.384]                       muffled <- FALSE
[10:18:31.384]                       if (inherits(cond, "message")) {
[10:18:31.384]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.384]                         if (muffled) 
[10:18:31.384]                           invokeRestart("muffleMessage")
[10:18:31.384]                       }
[10:18:31.384]                       else if (inherits(cond, "warning")) {
[10:18:31.384]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.384]                         if (muffled) 
[10:18:31.384]                           invokeRestart("muffleWarning")
[10:18:31.384]                       }
[10:18:31.384]                       else if (inherits(cond, "condition")) {
[10:18:31.384]                         if (!is.null(pattern)) {
[10:18:31.384]                           computeRestarts <- base::computeRestarts
[10:18:31.384]                           grepl <- base::grepl
[10:18:31.384]                           restarts <- computeRestarts(cond)
[10:18:31.384]                           for (restart in restarts) {
[10:18:31.384]                             name <- restart$name
[10:18:31.384]                             if (is.null(name)) 
[10:18:31.384]                               next
[10:18:31.384]                             if (!grepl(pattern, name)) 
[10:18:31.384]                               next
[10:18:31.384]                             invokeRestart(restart)
[10:18:31.384]                             muffled <- TRUE
[10:18:31.384]                             break
[10:18:31.384]                           }
[10:18:31.384]                         }
[10:18:31.384]                       }
[10:18:31.384]                       invisible(muffled)
[10:18:31.384]                     }
[10:18:31.384]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.384]                   }
[10:18:31.384]                 }
[10:18:31.384]             }
[10:18:31.384]         }))
[10:18:31.384]     }, error = function(ex) {
[10:18:31.384]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.384]                 ...future.rng), started = ...future.startTime, 
[10:18:31.384]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.384]             version = "1.8"), class = "FutureResult")
[10:18:31.384]     }, finally = {
[10:18:31.384]         if (!identical(...future.workdir, getwd())) 
[10:18:31.384]             setwd(...future.workdir)
[10:18:31.384]         {
[10:18:31.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.384]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.384]             }
[10:18:31.384]             base::options(...future.oldOptions)
[10:18:31.384]             if (.Platform$OS.type == "windows") {
[10:18:31.384]                 old_names <- names(...future.oldEnvVars)
[10:18:31.384]                 envs <- base::Sys.getenv()
[10:18:31.384]                 names <- names(envs)
[10:18:31.384]                 common <- intersect(names, old_names)
[10:18:31.384]                 added <- setdiff(names, old_names)
[10:18:31.384]                 removed <- setdiff(old_names, names)
[10:18:31.384]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.384]                   envs[common]]
[10:18:31.384]                 NAMES <- toupper(changed)
[10:18:31.384]                 args <- list()
[10:18:31.384]                 for (kk in seq_along(NAMES)) {
[10:18:31.384]                   name <- changed[[kk]]
[10:18:31.384]                   NAME <- NAMES[[kk]]
[10:18:31.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.384]                     next
[10:18:31.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.384]                 }
[10:18:31.384]                 NAMES <- toupper(added)
[10:18:31.384]                 for (kk in seq_along(NAMES)) {
[10:18:31.384]                   name <- added[[kk]]
[10:18:31.384]                   NAME <- NAMES[[kk]]
[10:18:31.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.384]                     next
[10:18:31.384]                   args[[name]] <- ""
[10:18:31.384]                 }
[10:18:31.384]                 NAMES <- toupper(removed)
[10:18:31.384]                 for (kk in seq_along(NAMES)) {
[10:18:31.384]                   name <- removed[[kk]]
[10:18:31.384]                   NAME <- NAMES[[kk]]
[10:18:31.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.384]                     next
[10:18:31.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.384]                 }
[10:18:31.384]                 if (length(args) > 0) 
[10:18:31.384]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.384]             }
[10:18:31.384]             else {
[10:18:31.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.384]             }
[10:18:31.384]             {
[10:18:31.384]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.384]                   0L) {
[10:18:31.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.384]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.384]                   base::options(opts)
[10:18:31.384]                 }
[10:18:31.384]                 {
[10:18:31.384]                   {
[10:18:31.384]                     NULL
[10:18:31.384]                     RNGkind("Mersenne-Twister")
[10:18:31.384]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.384]                       inherits = FALSE)
[10:18:31.384]                   }
[10:18:31.384]                   options(future.plan = NULL)
[10:18:31.384]                   if (is.na(NA_character_)) 
[10:18:31.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.384]                     .init = FALSE)
[10:18:31.384]                 }
[10:18:31.384]             }
[10:18:31.384]         }
[10:18:31.384]     })
[10:18:31.384]     if (TRUE) {
[10:18:31.384]         base::sink(type = "output", split = FALSE)
[10:18:31.384]         if (TRUE) {
[10:18:31.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.384]         }
[10:18:31.384]         else {
[10:18:31.384]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.384]         }
[10:18:31.384]         base::close(...future.stdout)
[10:18:31.384]         ...future.stdout <- NULL
[10:18:31.384]     }
[10:18:31.384]     ...future.result$conditions <- ...future.conditions
[10:18:31.384]     ...future.result$finished <- base::Sys.time()
[10:18:31.384]     ...future.result
[10:18:31.384] }
[10:18:31.386] assign_globals() ...
[10:18:31.386] List of 7
[10:18:31.386]  $ ...future.FUN            :function (x)  
[10:18:31.386]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:31.386]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.386]  $ future.call.arguments    : list()
[10:18:31.386]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.386]  $ ...future.elements_ii    :List of 3
[10:18:31.386]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.386]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.386]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.386]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.386]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.386]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.386]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.386]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.386]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.386]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.386]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.386]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.386]  $ ...future.seeds_ii       : NULL
[10:18:31.386]  $ ...future.globals.maxSize: NULL
[10:18:31.386]  - attr(*, "where")=List of 7
[10:18:31.386]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.386]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:18:31.386]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:18:31.386]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.386]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.386]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.386]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.386]  - attr(*, "resolved")= logi FALSE
[10:18:31.386]  - attr(*, "total_size")= num 18867
[10:18:31.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.386]  - attr(*, "already-done")= logi TRUE
[10:18:31.398] - reassign environment for ‘...future.FUN’
[10:18:31.398] - copied ‘...future.FUN’ to environment
[10:18:31.398] - copied ‘breaks’ to environment
[10:18:31.398] - copied ‘wool’ to environment
[10:18:31.398] - copied ‘future.call.arguments’ to environment
[10:18:31.398] - copied ‘...future.elements_ii’ to environment
[10:18:31.398] - copied ‘...future.seeds_ii’ to environment
[10:18:31.398] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.399] assign_globals() ... done
[10:18:31.399] plan(): Setting new future strategy stack:
[10:18:31.399] List of future strategies:
[10:18:31.399] 1. sequential:
[10:18:31.399]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.399]    - tweaked: FALSE
[10:18:31.399]    - call: NULL
[10:18:31.400] plan(): nbrOfWorkers() = 1
[10:18:31.403] plan(): Setting new future strategy stack:
[10:18:31.403] List of future strategies:
[10:18:31.403] 1. multisession:
[10:18:31.403]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.403]    - tweaked: FALSE
[10:18:31.403]    - call: plan(strategy)
[10:18:31.404] plan(): nbrOfWorkers() = 1
[10:18:31.404] SequentialFuture started (and completed)
[10:18:31.405] - Launch lazy future ... done
[10:18:31.405] run() for ‘SequentialFuture’ ... done
[10:18:31.405] Created future:
[10:18:31.405] SequentialFuture:
[10:18:31.405] Label: ‘future_by-1’
[10:18:31.405] Expression:
[10:18:31.405] {
[10:18:31.405]     do.call(function(...) {
[10:18:31.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.405]             on.exit(options(oopts), add = TRUE)
[10:18:31.405]         }
[10:18:31.405]         {
[10:18:31.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.405]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.405]             })
[10:18:31.405]         }
[10:18:31.405]     }, args = future.call.arguments)
[10:18:31.405] }
[10:18:31.405] Lazy evaluation: FALSE
[10:18:31.405] Asynchronous evaluation: FALSE
[10:18:31.405] Local evaluation: TRUE
[10:18:31.405] Environment: 0x5584485a8dc8
[10:18:31.405] Capture standard output: TRUE
[10:18:31.405] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.405] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[10:18:31.405] Packages: 1 packages (‘stats’)
[10:18:31.405] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.405] Resolved: TRUE
[10:18:31.405] Value: 82.51 KiB of class ‘list’
[10:18:31.405] Early signaling: FALSE
[10:18:31.405] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.405] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.406] Chunk #1 of 1 ... DONE
[10:18:31.406] Launching 1 futures (chunks) ... DONE
[10:18:31.407] Resolving 1 futures (chunks) ...
[10:18:31.407] resolve() on list ...
[10:18:31.407]  recursive: 0
[10:18:31.407]  length: 1
[10:18:31.407] 
[10:18:31.407] resolved() for ‘SequentialFuture’ ...
[10:18:31.407] - state: ‘finished’
[10:18:31.407] - run: TRUE
[10:18:31.407] - result: ‘FutureResult’
[10:18:31.407] resolved() for ‘SequentialFuture’ ... done
[10:18:31.407] Future #1
[10:18:31.408] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.408] - nx: 1
[10:18:31.408] - relay: TRUE
[10:18:31.408] - stdout: TRUE
[10:18:31.408] - signal: TRUE
[10:18:31.408] - resignal: FALSE
[10:18:31.408] - force: TRUE
[10:18:31.408] - relayed: [n=1] FALSE
[10:18:31.408] - queued futures: [n=1] FALSE
[10:18:31.408]  - until=1
[10:18:31.408]  - relaying element #1
[10:18:31.409] - relayed: [n=1] TRUE
[10:18:31.409] - queued futures: [n=1] TRUE
[10:18:31.409] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.409]  length: 0 (resolved future 1)
[10:18:31.409] Relaying remaining futures
[10:18:31.409] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.409] - nx: 1
[10:18:31.409] - relay: TRUE
[10:18:31.409] - stdout: TRUE
[10:18:31.409] - signal: TRUE
[10:18:31.409] - resignal: FALSE
[10:18:31.410] - force: TRUE
[10:18:31.410] - relayed: [n=1] TRUE
[10:18:31.410] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.410] - relayed: [n=1] TRUE
[10:18:31.410] - queued futures: [n=1] TRUE
[10:18:31.410] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.410] resolve() on list ... DONE
[10:18:31.410]  - Number of value chunks collected: 1
[10:18:31.410] Resolving 1 futures (chunks) ... DONE
[10:18:31.410] Reducing values from 1 chunks ...
[10:18:31.411]  - Number of values collected after concatenation: 3
[10:18:31.411]  - Number of values expected: 3
[10:18:31.411] Reducing values from 1 chunks ... DONE
[10:18:31.411] future_lapply() ... DONE
[10:18:31.411] future_by_internal() ... DONE
[10:18:31.411] future_by_internal() ...
[10:18:31.412] future_lapply() ...
[10:18:31.413] Number of chunks: 1
[10:18:31.413] getGlobalsAndPackagesXApply() ...
[10:18:31.414]  - future.globals: TRUE
[10:18:31.414] getGlobalsAndPackages() ...
[10:18:31.414] Searching for globals...
[10:18:31.415] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.415] Searching for globals ... DONE
[10:18:31.415] Resolving globals: FALSE
[10:18:31.415] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.416] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.416] - globals: [1] ‘FUN’
[10:18:31.416] 
[10:18:31.416] getGlobalsAndPackages() ... DONE
[10:18:31.416]  - globals found/used: [n=1] ‘FUN’
[10:18:31.416]  - needed namespaces: [n=0] 
[10:18:31.416] Finding globals ... DONE
[10:18:31.416]  - use_args: TRUE
[10:18:31.416]  - Getting '...' globals ...
[10:18:31.417] resolve() on list ...
[10:18:31.417]  recursive: 0
[10:18:31.417]  length: 1
[10:18:31.417]  elements: ‘...’
[10:18:31.417]  length: 0 (resolved future 1)
[10:18:31.417] resolve() on list ... DONE
[10:18:31.417]    - '...' content: [n=0] 
[10:18:31.417] List of 1
[10:18:31.417]  $ ...: list()
[10:18:31.417]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.417]  - attr(*, "where")=List of 1
[10:18:31.417]   ..$ ...:<environment: 0x55844a3993a0> 
[10:18:31.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.417]  - attr(*, "resolved")= logi TRUE
[10:18:31.417]  - attr(*, "total_size")= num NA
[10:18:31.422]  - Getting '...' globals ... DONE
[10:18:31.422] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.422] List of 2
[10:18:31.422]  $ ...future.FUN:function (object, ...)  
[10:18:31.422]  $ ...          : list()
[10:18:31.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.422]  - attr(*, "where")=List of 2
[10:18:31.422]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.422]   ..$ ...          :<environment: 0x55844a3993a0> 
[10:18:31.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.422]  - attr(*, "resolved")= logi FALSE
[10:18:31.422]  - attr(*, "total_size")= num 19278
[10:18:31.425] Packages to be attached in all futures: [n=0] 
[10:18:31.425] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.425] Number of futures (= number of chunks): 1
[10:18:31.425] Launching 1 futures (chunks) ...
[10:18:31.425] Chunk #1 of 1 ...
[10:18:31.425]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.425] getGlobalsAndPackages() ...
[10:18:31.426] Searching for globals...
[10:18:31.426] 
[10:18:31.426] Searching for globals ... DONE
[10:18:31.426] - globals: [0] <none>
[10:18:31.426] getGlobalsAndPackages() ... DONE
[10:18:31.426]    + additional globals found: [n=0] 
[10:18:31.426]    + additional namespaces needed: [n=0] 
[10:18:31.427]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.427]  - seeds: <none>
[10:18:31.427]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.427] getGlobalsAndPackages() ...
[10:18:31.427] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.427] Resolving globals: FALSE
[10:18:31.427] Tweak future expression to call with '...' arguments ...
[10:18:31.427] {
[10:18:31.427]     do.call(function(...) {
[10:18:31.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.427]             on.exit(options(oopts), add = TRUE)
[10:18:31.427]         }
[10:18:31.427]         {
[10:18:31.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.427]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.427]             })
[10:18:31.427]         }
[10:18:31.427]     }, args = future.call.arguments)
[10:18:31.427] }
[10:18:31.428] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.428] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.428] 
[10:18:31.428] getGlobalsAndPackages() ... DONE
[10:18:31.428] run() for ‘Future’ ...
[10:18:31.428] - state: ‘created’
[10:18:31.429] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.430] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.430] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.430]   - Field: ‘label’
[10:18:31.430]   - Field: ‘local’
[10:18:31.430]   - Field: ‘owner’
[10:18:31.431]   - Field: ‘envir’
[10:18:31.431]   - Field: ‘packages’
[10:18:31.431]   - Field: ‘gc’
[10:18:31.431]   - Field: ‘conditions’
[10:18:31.431]   - Field: ‘expr’
[10:18:31.431]   - Field: ‘uuid’
[10:18:31.431]   - Field: ‘seed’
[10:18:31.431]   - Field: ‘version’
[10:18:31.431]   - Field: ‘result’
[10:18:31.431]   - Field: ‘asynchronous’
[10:18:31.431]   - Field: ‘calls’
[10:18:31.432]   - Field: ‘globals’
[10:18:31.432]   - Field: ‘stdout’
[10:18:31.432]   - Field: ‘earlySignal’
[10:18:31.432]   - Field: ‘lazy’
[10:18:31.432]   - Field: ‘state’
[10:18:31.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.432] - Launch lazy future ...
[10:18:31.432] Packages needed by the future expression (n = 0): <none>
[10:18:31.432] Packages needed by future strategies (n = 0): <none>
[10:18:31.433] {
[10:18:31.433]     {
[10:18:31.433]         {
[10:18:31.433]             ...future.startTime <- base::Sys.time()
[10:18:31.433]             {
[10:18:31.433]                 {
[10:18:31.433]                   {
[10:18:31.433]                     base::local({
[10:18:31.433]                       has_future <- base::requireNamespace("future", 
[10:18:31.433]                         quietly = TRUE)
[10:18:31.433]                       if (has_future) {
[10:18:31.433]                         ns <- base::getNamespace("future")
[10:18:31.433]                         version <- ns[[".package"]][["version"]]
[10:18:31.433]                         if (is.null(version)) 
[10:18:31.433]                           version <- utils::packageVersion("future")
[10:18:31.433]                       }
[10:18:31.433]                       else {
[10:18:31.433]                         version <- NULL
[10:18:31.433]                       }
[10:18:31.433]                       if (!has_future || version < "1.8.0") {
[10:18:31.433]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.433]                           "", base::R.version$version.string), 
[10:18:31.433]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.433]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.433]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.433]                             "release", "version")], collapse = " "), 
[10:18:31.433]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.433]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.433]                           info)
[10:18:31.433]                         info <- base::paste(info, collapse = "; ")
[10:18:31.433]                         if (!has_future) {
[10:18:31.433]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.433]                             info)
[10:18:31.433]                         }
[10:18:31.433]                         else {
[10:18:31.433]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.433]                             info, version)
[10:18:31.433]                         }
[10:18:31.433]                         base::stop(msg)
[10:18:31.433]                       }
[10:18:31.433]                     })
[10:18:31.433]                   }
[10:18:31.433]                   ...future.strategy.old <- future::plan("list")
[10:18:31.433]                   options(future.plan = NULL)
[10:18:31.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.433]                 }
[10:18:31.433]                 ...future.workdir <- getwd()
[10:18:31.433]             }
[10:18:31.433]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.433]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.433]         }
[10:18:31.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.433]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.433]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.433]             base::names(...future.oldOptions))
[10:18:31.433]     }
[10:18:31.433]     if (FALSE) {
[10:18:31.433]     }
[10:18:31.433]     else {
[10:18:31.433]         if (TRUE) {
[10:18:31.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.433]                 open = "w")
[10:18:31.433]         }
[10:18:31.433]         else {
[10:18:31.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.433]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.433]         }
[10:18:31.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.433]             base::sink(type = "output", split = FALSE)
[10:18:31.433]             base::close(...future.stdout)
[10:18:31.433]         }, add = TRUE)
[10:18:31.433]     }
[10:18:31.433]     ...future.frame <- base::sys.nframe()
[10:18:31.433]     ...future.conditions <- base::list()
[10:18:31.433]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.433]     if (FALSE) {
[10:18:31.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.433]     }
[10:18:31.433]     ...future.result <- base::tryCatch({
[10:18:31.433]         base::withCallingHandlers({
[10:18:31.433]             ...future.value <- base::withVisible(base::local({
[10:18:31.433]                 do.call(function(...) {
[10:18:31.433]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.433]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.433]                     ...future.globals.maxSize)) {
[10:18:31.433]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.433]                     on.exit(options(oopts), add = TRUE)
[10:18:31.433]                   }
[10:18:31.433]                   {
[10:18:31.433]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.433]                       FUN = function(jj) {
[10:18:31.433]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.433]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.433]                       })
[10:18:31.433]                   }
[10:18:31.433]                 }, args = future.call.arguments)
[10:18:31.433]             }))
[10:18:31.433]             future::FutureResult(value = ...future.value$value, 
[10:18:31.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.433]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.433]                     ...future.globalenv.names))
[10:18:31.433]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.433]         }, condition = base::local({
[10:18:31.433]             c <- base::c
[10:18:31.433]             inherits <- base::inherits
[10:18:31.433]             invokeRestart <- base::invokeRestart
[10:18:31.433]             length <- base::length
[10:18:31.433]             list <- base::list
[10:18:31.433]             seq.int <- base::seq.int
[10:18:31.433]             signalCondition <- base::signalCondition
[10:18:31.433]             sys.calls <- base::sys.calls
[10:18:31.433]             `[[` <- base::`[[`
[10:18:31.433]             `+` <- base::`+`
[10:18:31.433]             `<<-` <- base::`<<-`
[10:18:31.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.433]                   3L)]
[10:18:31.433]             }
[10:18:31.433]             function(cond) {
[10:18:31.433]                 is_error <- inherits(cond, "error")
[10:18:31.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.433]                   NULL)
[10:18:31.433]                 if (is_error) {
[10:18:31.433]                   sessionInformation <- function() {
[10:18:31.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.433]                       search = base::search(), system = base::Sys.info())
[10:18:31.433]                   }
[10:18:31.433]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.433]                     cond$call), session = sessionInformation(), 
[10:18:31.433]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.433]                   signalCondition(cond)
[10:18:31.433]                 }
[10:18:31.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.433]                 "immediateCondition"))) {
[10:18:31.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.433]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.433]                   if (TRUE && !signal) {
[10:18:31.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.433]                     {
[10:18:31.433]                       inherits <- base::inherits
[10:18:31.433]                       invokeRestart <- base::invokeRestart
[10:18:31.433]                       is.null <- base::is.null
[10:18:31.433]                       muffled <- FALSE
[10:18:31.433]                       if (inherits(cond, "message")) {
[10:18:31.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.433]                         if (muffled) 
[10:18:31.433]                           invokeRestart("muffleMessage")
[10:18:31.433]                       }
[10:18:31.433]                       else if (inherits(cond, "warning")) {
[10:18:31.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.433]                         if (muffled) 
[10:18:31.433]                           invokeRestart("muffleWarning")
[10:18:31.433]                       }
[10:18:31.433]                       else if (inherits(cond, "condition")) {
[10:18:31.433]                         if (!is.null(pattern)) {
[10:18:31.433]                           computeRestarts <- base::computeRestarts
[10:18:31.433]                           grepl <- base::grepl
[10:18:31.433]                           restarts <- computeRestarts(cond)
[10:18:31.433]                           for (restart in restarts) {
[10:18:31.433]                             name <- restart$name
[10:18:31.433]                             if (is.null(name)) 
[10:18:31.433]                               next
[10:18:31.433]                             if (!grepl(pattern, name)) 
[10:18:31.433]                               next
[10:18:31.433]                             invokeRestart(restart)
[10:18:31.433]                             muffled <- TRUE
[10:18:31.433]                             break
[10:18:31.433]                           }
[10:18:31.433]                         }
[10:18:31.433]                       }
[10:18:31.433]                       invisible(muffled)
[10:18:31.433]                     }
[10:18:31.433]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.433]                   }
[10:18:31.433]                 }
[10:18:31.433]                 else {
[10:18:31.433]                   if (TRUE) {
[10:18:31.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.433]                     {
[10:18:31.433]                       inherits <- base::inherits
[10:18:31.433]                       invokeRestart <- base::invokeRestart
[10:18:31.433]                       is.null <- base::is.null
[10:18:31.433]                       muffled <- FALSE
[10:18:31.433]                       if (inherits(cond, "message")) {
[10:18:31.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.433]                         if (muffled) 
[10:18:31.433]                           invokeRestart("muffleMessage")
[10:18:31.433]                       }
[10:18:31.433]                       else if (inherits(cond, "warning")) {
[10:18:31.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.433]                         if (muffled) 
[10:18:31.433]                           invokeRestart("muffleWarning")
[10:18:31.433]                       }
[10:18:31.433]                       else if (inherits(cond, "condition")) {
[10:18:31.433]                         if (!is.null(pattern)) {
[10:18:31.433]                           computeRestarts <- base::computeRestarts
[10:18:31.433]                           grepl <- base::grepl
[10:18:31.433]                           restarts <- computeRestarts(cond)
[10:18:31.433]                           for (restart in restarts) {
[10:18:31.433]                             name <- restart$name
[10:18:31.433]                             if (is.null(name)) 
[10:18:31.433]                               next
[10:18:31.433]                             if (!grepl(pattern, name)) 
[10:18:31.433]                               next
[10:18:31.433]                             invokeRestart(restart)
[10:18:31.433]                             muffled <- TRUE
[10:18:31.433]                             break
[10:18:31.433]                           }
[10:18:31.433]                         }
[10:18:31.433]                       }
[10:18:31.433]                       invisible(muffled)
[10:18:31.433]                     }
[10:18:31.433]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.433]                   }
[10:18:31.433]                 }
[10:18:31.433]             }
[10:18:31.433]         }))
[10:18:31.433]     }, error = function(ex) {
[10:18:31.433]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.433]                 ...future.rng), started = ...future.startTime, 
[10:18:31.433]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.433]             version = "1.8"), class = "FutureResult")
[10:18:31.433]     }, finally = {
[10:18:31.433]         if (!identical(...future.workdir, getwd())) 
[10:18:31.433]             setwd(...future.workdir)
[10:18:31.433]         {
[10:18:31.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.433]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.433]             }
[10:18:31.433]             base::options(...future.oldOptions)
[10:18:31.433]             if (.Platform$OS.type == "windows") {
[10:18:31.433]                 old_names <- names(...future.oldEnvVars)
[10:18:31.433]                 envs <- base::Sys.getenv()
[10:18:31.433]                 names <- names(envs)
[10:18:31.433]                 common <- intersect(names, old_names)
[10:18:31.433]                 added <- setdiff(names, old_names)
[10:18:31.433]                 removed <- setdiff(old_names, names)
[10:18:31.433]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.433]                   envs[common]]
[10:18:31.433]                 NAMES <- toupper(changed)
[10:18:31.433]                 args <- list()
[10:18:31.433]                 for (kk in seq_along(NAMES)) {
[10:18:31.433]                   name <- changed[[kk]]
[10:18:31.433]                   NAME <- NAMES[[kk]]
[10:18:31.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.433]                     next
[10:18:31.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.433]                 }
[10:18:31.433]                 NAMES <- toupper(added)
[10:18:31.433]                 for (kk in seq_along(NAMES)) {
[10:18:31.433]                   name <- added[[kk]]
[10:18:31.433]                   NAME <- NAMES[[kk]]
[10:18:31.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.433]                     next
[10:18:31.433]                   args[[name]] <- ""
[10:18:31.433]                 }
[10:18:31.433]                 NAMES <- toupper(removed)
[10:18:31.433]                 for (kk in seq_along(NAMES)) {
[10:18:31.433]                   name <- removed[[kk]]
[10:18:31.433]                   NAME <- NAMES[[kk]]
[10:18:31.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.433]                     next
[10:18:31.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.433]                 }
[10:18:31.433]                 if (length(args) > 0) 
[10:18:31.433]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.433]             }
[10:18:31.433]             else {
[10:18:31.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.433]             }
[10:18:31.433]             {
[10:18:31.433]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.433]                   0L) {
[10:18:31.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.433]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.433]                   base::options(opts)
[10:18:31.433]                 }
[10:18:31.433]                 {
[10:18:31.433]                   {
[10:18:31.433]                     NULL
[10:18:31.433]                     RNGkind("Mersenne-Twister")
[10:18:31.433]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.433]                       inherits = FALSE)
[10:18:31.433]                   }
[10:18:31.433]                   options(future.plan = NULL)
[10:18:31.433]                   if (is.na(NA_character_)) 
[10:18:31.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.433]                     .init = FALSE)
[10:18:31.433]                 }
[10:18:31.433]             }
[10:18:31.433]         }
[10:18:31.433]     })
[10:18:31.433]     if (TRUE) {
[10:18:31.433]         base::sink(type = "output", split = FALSE)
[10:18:31.433]         if (TRUE) {
[10:18:31.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.433]         }
[10:18:31.433]         else {
[10:18:31.433]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.433]         }
[10:18:31.433]         base::close(...future.stdout)
[10:18:31.433]         ...future.stdout <- NULL
[10:18:31.433]     }
[10:18:31.433]     ...future.result$conditions <- ...future.conditions
[10:18:31.433]     ...future.result$finished <- base::Sys.time()
[10:18:31.433]     ...future.result
[10:18:31.433] }
[10:18:31.435] assign_globals() ...
[10:18:31.435] List of 5
[10:18:31.435]  $ ...future.FUN            :function (object, ...)  
[10:18:31.435]  $ future.call.arguments    : list()
[10:18:31.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.435]  $ ...future.elements_ii    :List of 3
[10:18:31.435]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.435]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.435]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.435]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.435]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.435]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.435]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.435]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.435]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.435]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.435]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.435]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.435]  $ ...future.seeds_ii       : NULL
[10:18:31.435]  $ ...future.globals.maxSize: NULL
[10:18:31.435]  - attr(*, "where")=List of 5
[10:18:31.435]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.435]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.435]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.435]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.435]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.435]  - attr(*, "resolved")= logi FALSE
[10:18:31.435]  - attr(*, "total_size")= num 19278
[10:18:31.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.435]  - attr(*, "already-done")= logi TRUE
[10:18:31.447] - copied ‘...future.FUN’ to environment
[10:18:31.447] - copied ‘future.call.arguments’ to environment
[10:18:31.447] - copied ‘...future.elements_ii’ to environment
[10:18:31.448] - copied ‘...future.seeds_ii’ to environment
[10:18:31.448] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.448] assign_globals() ... done
[10:18:31.448] plan(): Setting new future strategy stack:
[10:18:31.448] List of future strategies:
[10:18:31.448] 1. sequential:
[10:18:31.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.448]    - tweaked: FALSE
[10:18:31.448]    - call: NULL
[10:18:31.449] plan(): nbrOfWorkers() = 1
[10:18:31.452] plan(): Setting new future strategy stack:
[10:18:31.452] List of future strategies:
[10:18:31.452] 1. multisession:
[10:18:31.452]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.452]    - tweaked: FALSE
[10:18:31.452]    - call: plan(strategy)
[10:18:31.454] plan(): nbrOfWorkers() = 1
[10:18:31.455] SequentialFuture started (and completed)
[10:18:31.455] - Launch lazy future ... done
[10:18:31.455] run() for ‘SequentialFuture’ ... done
[10:18:31.455] Created future:
[10:18:31.455] SequentialFuture:
[10:18:31.455] Label: ‘future_by-1’
[10:18:31.455] Expression:
[10:18:31.455] {
[10:18:31.455]     do.call(function(...) {
[10:18:31.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.455]             on.exit(options(oopts), add = TRUE)
[10:18:31.455]         }
[10:18:31.455]         {
[10:18:31.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.455]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.455]             })
[10:18:31.455]         }
[10:18:31.455]     }, args = future.call.arguments)
[10:18:31.455] }
[10:18:31.455] Lazy evaluation: FALSE
[10:18:31.455] Asynchronous evaluation: FALSE
[10:18:31.455] Local evaluation: TRUE
[10:18:31.455] Environment: 0x55844a2b3f58
[10:18:31.455] Capture standard output: TRUE
[10:18:31.455] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.455] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.455] Packages: <none>
[10:18:31.455] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.455] Resolved: TRUE
[10:18:31.455] Value: 1.39 KiB of class ‘list’
[10:18:31.455] Early signaling: FALSE
[10:18:31.455] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.455] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.457] Chunk #1 of 1 ... DONE
[10:18:31.457] Launching 1 futures (chunks) ... DONE
[10:18:31.457] Resolving 1 futures (chunks) ...
[10:18:31.457] resolve() on list ...
[10:18:31.457]  recursive: 0
[10:18:31.457]  length: 1
[10:18:31.457] 
[10:18:31.458] resolved() for ‘SequentialFuture’ ...
[10:18:31.458] - state: ‘finished’
[10:18:31.458] - run: TRUE
[10:18:31.458] - result: ‘FutureResult’
[10:18:31.458] resolved() for ‘SequentialFuture’ ... done
[10:18:31.458] Future #1
[10:18:31.459] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.459] - nx: 1
[10:18:31.459] - relay: TRUE
[10:18:31.459] - stdout: TRUE
[10:18:31.459] - signal: TRUE
[10:18:31.459] - resignal: FALSE
[10:18:31.459] - force: TRUE
[10:18:31.459] - relayed: [n=1] FALSE
[10:18:31.459] - queued futures: [n=1] FALSE
[10:18:31.460]  - until=1
[10:18:31.460]  - relaying element #1
[10:18:31.460] - relayed: [n=1] TRUE
[10:18:31.460] - queued futures: [n=1] TRUE
[10:18:31.460] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.460]  length: 0 (resolved future 1)
[10:18:31.461] Relaying remaining futures
[10:18:31.461] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.461] - nx: 1
[10:18:31.461] - relay: TRUE
[10:18:31.461] - stdout: TRUE
[10:18:31.461] - signal: TRUE
[10:18:31.461] - resignal: FALSE
[10:18:31.461] - force: TRUE
[10:18:31.462] - relayed: [n=1] TRUE
[10:18:31.462] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.462] - relayed: [n=1] TRUE
[10:18:31.462] - queued futures: [n=1] TRUE
[10:18:31.462] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.462] resolve() on list ... DONE
[10:18:31.462]  - Number of value chunks collected: 1
[10:18:31.463] Resolving 1 futures (chunks) ... DONE
[10:18:31.463] Reducing values from 1 chunks ...
[10:18:31.463]  - Number of values collected after concatenation: 3
[10:18:31.463]  - Number of values expected: 3
[10:18:31.463] Reducing values from 1 chunks ... DONE
[10:18:31.463] future_lapply() ... DONE
[10:18:31.463] future_by_internal() ... DONE
[10:18:31.465] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:18:31.465] future_lapply() ...
[10:18:31.468] Number of chunks: 1
[10:18:31.468] getGlobalsAndPackagesXApply() ...
[10:18:31.468]  - future.globals: TRUE
[10:18:31.468] getGlobalsAndPackages() ...
[10:18:31.468] Searching for globals...
[10:18:31.472] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.472] Searching for globals ... DONE
[10:18:31.472] Resolving globals: FALSE
[10:18:31.473] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.473] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.473] - globals: [1] ‘FUN’
[10:18:31.474] 
[10:18:31.474] getGlobalsAndPackages() ... DONE
[10:18:31.474]  - globals found/used: [n=1] ‘FUN’
[10:18:31.474]  - needed namespaces: [n=0] 
[10:18:31.474] Finding globals ... DONE
[10:18:31.474]  - use_args: TRUE
[10:18:31.474]  - Getting '...' globals ...
[10:18:31.475] resolve() on list ...
[10:18:31.475]  recursive: 0
[10:18:31.475]  length: 1
[10:18:31.475]  elements: ‘...’
[10:18:31.475]  length: 0 (resolved future 1)
[10:18:31.476] resolve() on list ... DONE
[10:18:31.476]    - '...' content: [n=0] 
[10:18:31.476] List of 1
[10:18:31.476]  $ ...: list()
[10:18:31.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.476]  - attr(*, "where")=List of 1
[10:18:31.476]   ..$ ...:<environment: 0x55844a5da028> 
[10:18:31.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.476]  - attr(*, "resolved")= logi TRUE
[10:18:31.476]  - attr(*, "total_size")= num NA
[10:18:31.478]  - Getting '...' globals ... DONE
[10:18:31.478] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.478] List of 2
[10:18:31.478]  $ ...future.FUN:function (object, ...)  
[10:18:31.478]  $ ...          : list()
[10:18:31.478]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.478]  - attr(*, "where")=List of 2
[10:18:31.478]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.478]   ..$ ...          :<environment: 0x55844a5da028> 
[10:18:31.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.478]  - attr(*, "resolved")= logi FALSE
[10:18:31.478]  - attr(*, "total_size")= num 18647
[10:18:31.481] Packages to be attached in all futures: [n=0] 
[10:18:31.481] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.482] Number of futures (= number of chunks): 1
[10:18:31.482] Launching 1 futures (chunks) ...
[10:18:31.482] Chunk #1 of 1 ...
[10:18:31.482]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.482] getGlobalsAndPackages() ...
[10:18:31.482] Searching for globals...
[10:18:31.483] 
[10:18:31.483] Searching for globals ... DONE
[10:18:31.483] - globals: [0] <none>
[10:18:31.483] getGlobalsAndPackages() ... DONE
[10:18:31.483]    + additional globals found: [n=0] 
[10:18:31.483]    + additional namespaces needed: [n=0] 
[10:18:31.483]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.483]  - seeds: <none>
[10:18:31.483]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.484] getGlobalsAndPackages() ...
[10:18:31.484] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.484] Resolving globals: FALSE
[10:18:31.484] Tweak future expression to call with '...' arguments ...
[10:18:31.484] {
[10:18:31.484]     do.call(function(...) {
[10:18:31.484]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.484]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.484]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.484]             on.exit(options(oopts), add = TRUE)
[10:18:31.484]         }
[10:18:31.484]         {
[10:18:31.484]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.484]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.484]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.484]             })
[10:18:31.484]         }
[10:18:31.484]     }, args = future.call.arguments)
[10:18:31.484] }
[10:18:31.484] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.485] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.485] 
[10:18:31.485] getGlobalsAndPackages() ... DONE
[10:18:31.485] run() for ‘Future’ ...
[10:18:31.485] - state: ‘created’
[10:18:31.485] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.487] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.487] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.487]   - Field: ‘label’
[10:18:31.487]   - Field: ‘local’
[10:18:31.487]   - Field: ‘owner’
[10:18:31.488]   - Field: ‘envir’
[10:18:31.488]   - Field: ‘packages’
[10:18:31.488]   - Field: ‘gc’
[10:18:31.488]   - Field: ‘conditions’
[10:18:31.488]   - Field: ‘expr’
[10:18:31.488]   - Field: ‘uuid’
[10:18:31.488]   - Field: ‘seed’
[10:18:31.488]   - Field: ‘version’
[10:18:31.488]   - Field: ‘result’
[10:18:31.488]   - Field: ‘asynchronous’
[10:18:31.488]   - Field: ‘calls’
[10:18:31.489]   - Field: ‘globals’
[10:18:31.489]   - Field: ‘stdout’
[10:18:31.489]   - Field: ‘earlySignal’
[10:18:31.489]   - Field: ‘lazy’
[10:18:31.489]   - Field: ‘state’
[10:18:31.489] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.489] - Launch lazy future ...
[10:18:31.489] Packages needed by the future expression (n = 0): <none>
[10:18:31.489] Packages needed by future strategies (n = 0): <none>
[10:18:31.490] {
[10:18:31.490]     {
[10:18:31.490]         {
[10:18:31.490]             ...future.startTime <- base::Sys.time()
[10:18:31.490]             {
[10:18:31.490]                 {
[10:18:31.490]                   {
[10:18:31.490]                     base::local({
[10:18:31.490]                       has_future <- base::requireNamespace("future", 
[10:18:31.490]                         quietly = TRUE)
[10:18:31.490]                       if (has_future) {
[10:18:31.490]                         ns <- base::getNamespace("future")
[10:18:31.490]                         version <- ns[[".package"]][["version"]]
[10:18:31.490]                         if (is.null(version)) 
[10:18:31.490]                           version <- utils::packageVersion("future")
[10:18:31.490]                       }
[10:18:31.490]                       else {
[10:18:31.490]                         version <- NULL
[10:18:31.490]                       }
[10:18:31.490]                       if (!has_future || version < "1.8.0") {
[10:18:31.490]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.490]                           "", base::R.version$version.string), 
[10:18:31.490]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.490]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.490]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.490]                             "release", "version")], collapse = " "), 
[10:18:31.490]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.490]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.490]                           info)
[10:18:31.490]                         info <- base::paste(info, collapse = "; ")
[10:18:31.490]                         if (!has_future) {
[10:18:31.490]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.490]                             info)
[10:18:31.490]                         }
[10:18:31.490]                         else {
[10:18:31.490]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.490]                             info, version)
[10:18:31.490]                         }
[10:18:31.490]                         base::stop(msg)
[10:18:31.490]                       }
[10:18:31.490]                     })
[10:18:31.490]                   }
[10:18:31.490]                   ...future.strategy.old <- future::plan("list")
[10:18:31.490]                   options(future.plan = NULL)
[10:18:31.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.490]                 }
[10:18:31.490]                 ...future.workdir <- getwd()
[10:18:31.490]             }
[10:18:31.490]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.490]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.490]         }
[10:18:31.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.490]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.490]             base::names(...future.oldOptions))
[10:18:31.490]     }
[10:18:31.490]     if (FALSE) {
[10:18:31.490]     }
[10:18:31.490]     else {
[10:18:31.490]         if (TRUE) {
[10:18:31.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.490]                 open = "w")
[10:18:31.490]         }
[10:18:31.490]         else {
[10:18:31.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.490]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.490]         }
[10:18:31.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.490]             base::sink(type = "output", split = FALSE)
[10:18:31.490]             base::close(...future.stdout)
[10:18:31.490]         }, add = TRUE)
[10:18:31.490]     }
[10:18:31.490]     ...future.frame <- base::sys.nframe()
[10:18:31.490]     ...future.conditions <- base::list()
[10:18:31.490]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.490]     if (FALSE) {
[10:18:31.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.490]     }
[10:18:31.490]     ...future.result <- base::tryCatch({
[10:18:31.490]         base::withCallingHandlers({
[10:18:31.490]             ...future.value <- base::withVisible(base::local({
[10:18:31.490]                 do.call(function(...) {
[10:18:31.490]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.490]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.490]                     ...future.globals.maxSize)) {
[10:18:31.490]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.490]                     on.exit(options(oopts), add = TRUE)
[10:18:31.490]                   }
[10:18:31.490]                   {
[10:18:31.490]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.490]                       FUN = function(jj) {
[10:18:31.490]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.490]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.490]                       })
[10:18:31.490]                   }
[10:18:31.490]                 }, args = future.call.arguments)
[10:18:31.490]             }))
[10:18:31.490]             future::FutureResult(value = ...future.value$value, 
[10:18:31.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.490]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.490]                     ...future.globalenv.names))
[10:18:31.490]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.490]         }, condition = base::local({
[10:18:31.490]             c <- base::c
[10:18:31.490]             inherits <- base::inherits
[10:18:31.490]             invokeRestart <- base::invokeRestart
[10:18:31.490]             length <- base::length
[10:18:31.490]             list <- base::list
[10:18:31.490]             seq.int <- base::seq.int
[10:18:31.490]             signalCondition <- base::signalCondition
[10:18:31.490]             sys.calls <- base::sys.calls
[10:18:31.490]             `[[` <- base::`[[`
[10:18:31.490]             `+` <- base::`+`
[10:18:31.490]             `<<-` <- base::`<<-`
[10:18:31.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.490]                   3L)]
[10:18:31.490]             }
[10:18:31.490]             function(cond) {
[10:18:31.490]                 is_error <- inherits(cond, "error")
[10:18:31.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.490]                   NULL)
[10:18:31.490]                 if (is_error) {
[10:18:31.490]                   sessionInformation <- function() {
[10:18:31.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.490]                       search = base::search(), system = base::Sys.info())
[10:18:31.490]                   }
[10:18:31.490]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.490]                     cond$call), session = sessionInformation(), 
[10:18:31.490]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.490]                   signalCondition(cond)
[10:18:31.490]                 }
[10:18:31.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.490]                 "immediateCondition"))) {
[10:18:31.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.490]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.490]                   if (TRUE && !signal) {
[10:18:31.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.490]                     {
[10:18:31.490]                       inherits <- base::inherits
[10:18:31.490]                       invokeRestart <- base::invokeRestart
[10:18:31.490]                       is.null <- base::is.null
[10:18:31.490]                       muffled <- FALSE
[10:18:31.490]                       if (inherits(cond, "message")) {
[10:18:31.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.490]                         if (muffled) 
[10:18:31.490]                           invokeRestart("muffleMessage")
[10:18:31.490]                       }
[10:18:31.490]                       else if (inherits(cond, "warning")) {
[10:18:31.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.490]                         if (muffled) 
[10:18:31.490]                           invokeRestart("muffleWarning")
[10:18:31.490]                       }
[10:18:31.490]                       else if (inherits(cond, "condition")) {
[10:18:31.490]                         if (!is.null(pattern)) {
[10:18:31.490]                           computeRestarts <- base::computeRestarts
[10:18:31.490]                           grepl <- base::grepl
[10:18:31.490]                           restarts <- computeRestarts(cond)
[10:18:31.490]                           for (restart in restarts) {
[10:18:31.490]                             name <- restart$name
[10:18:31.490]                             if (is.null(name)) 
[10:18:31.490]                               next
[10:18:31.490]                             if (!grepl(pattern, name)) 
[10:18:31.490]                               next
[10:18:31.490]                             invokeRestart(restart)
[10:18:31.490]                             muffled <- TRUE
[10:18:31.490]                             break
[10:18:31.490]                           }
[10:18:31.490]                         }
[10:18:31.490]                       }
[10:18:31.490]                       invisible(muffled)
[10:18:31.490]                     }
[10:18:31.490]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.490]                   }
[10:18:31.490]                 }
[10:18:31.490]                 else {
[10:18:31.490]                   if (TRUE) {
[10:18:31.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.490]                     {
[10:18:31.490]                       inherits <- base::inherits
[10:18:31.490]                       invokeRestart <- base::invokeRestart
[10:18:31.490]                       is.null <- base::is.null
[10:18:31.490]                       muffled <- FALSE
[10:18:31.490]                       if (inherits(cond, "message")) {
[10:18:31.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.490]                         if (muffled) 
[10:18:31.490]                           invokeRestart("muffleMessage")
[10:18:31.490]                       }
[10:18:31.490]                       else if (inherits(cond, "warning")) {
[10:18:31.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.490]                         if (muffled) 
[10:18:31.490]                           invokeRestart("muffleWarning")
[10:18:31.490]                       }
[10:18:31.490]                       else if (inherits(cond, "condition")) {
[10:18:31.490]                         if (!is.null(pattern)) {
[10:18:31.490]                           computeRestarts <- base::computeRestarts
[10:18:31.490]                           grepl <- base::grepl
[10:18:31.490]                           restarts <- computeRestarts(cond)
[10:18:31.490]                           for (restart in restarts) {
[10:18:31.490]                             name <- restart$name
[10:18:31.490]                             if (is.null(name)) 
[10:18:31.490]                               next
[10:18:31.490]                             if (!grepl(pattern, name)) 
[10:18:31.490]                               next
[10:18:31.490]                             invokeRestart(restart)
[10:18:31.490]                             muffled <- TRUE
[10:18:31.490]                             break
[10:18:31.490]                           }
[10:18:31.490]                         }
[10:18:31.490]                       }
[10:18:31.490]                       invisible(muffled)
[10:18:31.490]                     }
[10:18:31.490]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.490]                   }
[10:18:31.490]                 }
[10:18:31.490]             }
[10:18:31.490]         }))
[10:18:31.490]     }, error = function(ex) {
[10:18:31.490]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.490]                 ...future.rng), started = ...future.startTime, 
[10:18:31.490]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.490]             version = "1.8"), class = "FutureResult")
[10:18:31.490]     }, finally = {
[10:18:31.490]         if (!identical(...future.workdir, getwd())) 
[10:18:31.490]             setwd(...future.workdir)
[10:18:31.490]         {
[10:18:31.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.490]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.490]             }
[10:18:31.490]             base::options(...future.oldOptions)
[10:18:31.490]             if (.Platform$OS.type == "windows") {
[10:18:31.490]                 old_names <- names(...future.oldEnvVars)
[10:18:31.490]                 envs <- base::Sys.getenv()
[10:18:31.490]                 names <- names(envs)
[10:18:31.490]                 common <- intersect(names, old_names)
[10:18:31.490]                 added <- setdiff(names, old_names)
[10:18:31.490]                 removed <- setdiff(old_names, names)
[10:18:31.490]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.490]                   envs[common]]
[10:18:31.490]                 NAMES <- toupper(changed)
[10:18:31.490]                 args <- list()
[10:18:31.490]                 for (kk in seq_along(NAMES)) {
[10:18:31.490]                   name <- changed[[kk]]
[10:18:31.490]                   NAME <- NAMES[[kk]]
[10:18:31.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.490]                     next
[10:18:31.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.490]                 }
[10:18:31.490]                 NAMES <- toupper(added)
[10:18:31.490]                 for (kk in seq_along(NAMES)) {
[10:18:31.490]                   name <- added[[kk]]
[10:18:31.490]                   NAME <- NAMES[[kk]]
[10:18:31.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.490]                     next
[10:18:31.490]                   args[[name]] <- ""
[10:18:31.490]                 }
[10:18:31.490]                 NAMES <- toupper(removed)
[10:18:31.490]                 for (kk in seq_along(NAMES)) {
[10:18:31.490]                   name <- removed[[kk]]
[10:18:31.490]                   NAME <- NAMES[[kk]]
[10:18:31.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.490]                     next
[10:18:31.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.490]                 }
[10:18:31.490]                 if (length(args) > 0) 
[10:18:31.490]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.490]             }
[10:18:31.490]             else {
[10:18:31.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.490]             }
[10:18:31.490]             {
[10:18:31.490]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.490]                   0L) {
[10:18:31.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.490]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.490]                   base::options(opts)
[10:18:31.490]                 }
[10:18:31.490]                 {
[10:18:31.490]                   {
[10:18:31.490]                     NULL
[10:18:31.490]                     RNGkind("Mersenne-Twister")
[10:18:31.490]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.490]                       inherits = FALSE)
[10:18:31.490]                   }
[10:18:31.490]                   options(future.plan = NULL)
[10:18:31.490]                   if (is.na(NA_character_)) 
[10:18:31.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.490]                     .init = FALSE)
[10:18:31.490]                 }
[10:18:31.490]             }
[10:18:31.490]         }
[10:18:31.490]     })
[10:18:31.490]     if (TRUE) {
[10:18:31.490]         base::sink(type = "output", split = FALSE)
[10:18:31.490]         if (TRUE) {
[10:18:31.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.490]         }
[10:18:31.490]         else {
[10:18:31.490]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.490]         }
[10:18:31.490]         base::close(...future.stdout)
[10:18:31.490]         ...future.stdout <- NULL
[10:18:31.490]     }
[10:18:31.490]     ...future.result$conditions <- ...future.conditions
[10:18:31.490]     ...future.result$finished <- base::Sys.time()
[10:18:31.490]     ...future.result
[10:18:31.490] }
[10:18:31.492] assign_globals() ...
[10:18:31.492] List of 5
[10:18:31.492]  $ ...future.FUN            :function (object, ...)  
[10:18:31.492]  $ future.call.arguments    : list()
[10:18:31.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.492]  $ ...future.elements_ii    :List of 3
[10:18:31.492]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.492]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.492]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.492]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.492]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.492]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.492]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.492]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.492]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.492]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.492]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.492]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.492]  $ ...future.seeds_ii       : NULL
[10:18:31.492]  $ ...future.globals.maxSize: NULL
[10:18:31.492]  - attr(*, "where")=List of 5
[10:18:31.492]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.492]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.492]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.492]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.492]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.492]  - attr(*, "resolved")= logi FALSE
[10:18:31.492]  - attr(*, "total_size")= num 18647
[10:18:31.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.492]  - attr(*, "already-done")= logi TRUE
[10:18:31.503] - copied ‘...future.FUN’ to environment
[10:18:31.503] - copied ‘future.call.arguments’ to environment
[10:18:31.503] - copied ‘...future.elements_ii’ to environment
[10:18:31.503] - copied ‘...future.seeds_ii’ to environment
[10:18:31.503] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.503] assign_globals() ... done
[10:18:31.504] plan(): Setting new future strategy stack:
[10:18:31.504] List of future strategies:
[10:18:31.504] 1. sequential:
[10:18:31.504]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.504]    - tweaked: FALSE
[10:18:31.504]    - call: NULL
[10:18:31.504] plan(): nbrOfWorkers() = 1
[10:18:31.507] plan(): Setting new future strategy stack:
[10:18:31.507] List of future strategies:
[10:18:31.507] 1. multisession:
[10:18:31.507]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:31.507]    - tweaked: FALSE
[10:18:31.507]    - call: plan(strategy)
[10:18:31.509] plan(): nbrOfWorkers() = 1
[10:18:31.509] SequentialFuture started (and completed)
[10:18:31.509] - Launch lazy future ... done
[10:18:31.509] run() for ‘SequentialFuture’ ... done
[10:18:31.509] Created future:
[10:18:31.509] SequentialFuture:
[10:18:31.509] Label: ‘future_by-1’
[10:18:31.509] Expression:
[10:18:31.509] {
[10:18:31.509]     do.call(function(...) {
[10:18:31.509]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.509]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.509]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.509]             on.exit(options(oopts), add = TRUE)
[10:18:31.509]         }
[10:18:31.509]         {
[10:18:31.509]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.509]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.509]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.509]             })
[10:18:31.509]         }
[10:18:31.509]     }, args = future.call.arguments)
[10:18:31.509] }
[10:18:31.509] Lazy evaluation: FALSE
[10:18:31.509] Asynchronous evaluation: FALSE
[10:18:31.509] Local evaluation: TRUE
[10:18:31.509] Environment: 0x55844a569bd0
[10:18:31.509] Capture standard output: TRUE
[10:18:31.509] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.509] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.509] Packages: <none>
[10:18:31.509] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.509] Resolved: TRUE
[10:18:31.509] Value: 1.39 KiB of class ‘list’
[10:18:31.509] Early signaling: FALSE
[10:18:31.509] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.509] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.510] Chunk #1 of 1 ... DONE
[10:18:31.510] Launching 1 futures (chunks) ... DONE
[10:18:31.510] Resolving 1 futures (chunks) ...
[10:18:31.511] resolve() on list ...
[10:18:31.511]  recursive: 0
[10:18:31.511]  length: 1
[10:18:31.511] 
[10:18:31.511] resolved() for ‘SequentialFuture’ ...
[10:18:31.511] - state: ‘finished’
[10:18:31.511] - run: TRUE
[10:18:31.511] - result: ‘FutureResult’
[10:18:31.511] resolved() for ‘SequentialFuture’ ... done
[10:18:31.511] Future #1
[10:18:31.512] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.512] - nx: 1
[10:18:31.512] - relay: TRUE
[10:18:31.512] - stdout: TRUE
[10:18:31.512] - signal: TRUE
[10:18:31.512] - resignal: FALSE
[10:18:31.512] - force: TRUE
[10:18:31.512] - relayed: [n=1] FALSE
[10:18:31.512] - queued futures: [n=1] FALSE
[10:18:31.512]  - until=1
[10:18:31.512]  - relaying element #1
[10:18:31.513] - relayed: [n=1] TRUE
[10:18:31.513] - queued futures: [n=1] TRUE
[10:18:31.513] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.513]  length: 0 (resolved future 1)
[10:18:31.513] Relaying remaining futures
[10:18:31.513] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.513] - nx: 1
[10:18:31.513] - relay: TRUE
[10:18:31.513] - stdout: TRUE
[10:18:31.513] - signal: TRUE
[10:18:31.514] - resignal: FALSE
[10:18:31.514] - force: TRUE
[10:18:31.514] - relayed: [n=1] TRUE
[10:18:31.514] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.514] - relayed: [n=1] TRUE
[10:18:31.514] - queued futures: [n=1] TRUE
[10:18:31.514] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.514] resolve() on list ... DONE
[10:18:31.514]  - Number of value chunks collected: 1
[10:18:31.514] Resolving 1 futures (chunks) ... DONE
[10:18:31.515] Reducing values from 1 chunks ...
[10:18:31.515]  - Number of values collected after concatenation: 3
[10:18:31.518]  - Number of values expected: 3
[10:18:31.518] Reducing values from 1 chunks ... DONE
[10:18:31.518] future_lapply() ... DONE
[10:18:31.519] future_by_internal() ... DONE
[10:18:31.520] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[10:18:31.521] plan(): Setting new future strategy stack:
[10:18:31.521] List of future strategies:
[10:18:31.521] 1. sequential:
[10:18:31.521]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.521]    - tweaked: FALSE
[10:18:31.521]    - call: plan(strategy)
[10:18:31.521] plan(): nbrOfWorkers() = 1
[10:18:31.522] future_by_internal() ...
[10:18:31.522] future_lapply() ...
[10:18:31.523] Number of chunks: 1
[10:18:31.523] getGlobalsAndPackagesXApply() ...
[10:18:31.523]  - future.globals: TRUE
[10:18:31.523] getGlobalsAndPackages() ...
[10:18:31.523] Searching for globals...
[10:18:31.524] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.524] Searching for globals ... DONE
[10:18:31.525] Resolving globals: FALSE
[10:18:31.525] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.525] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.525] - globals: [1] ‘FUN’
[10:18:31.525] 
[10:18:31.526] getGlobalsAndPackages() ... DONE
[10:18:31.526]  - globals found/used: [n=1] ‘FUN’
[10:18:31.526]  - needed namespaces: [n=0] 
[10:18:31.526] Finding globals ... DONE
[10:18:31.526]  - use_args: TRUE
[10:18:31.526]  - Getting '...' globals ...
[10:18:31.526] resolve() on list ...
[10:18:31.526]  recursive: 0
[10:18:31.527]  length: 1
[10:18:31.527]  elements: ‘...’
[10:18:31.527]  length: 0 (resolved future 1)
[10:18:31.527] resolve() on list ... DONE
[10:18:31.527]    - '...' content: [n=0] 
[10:18:31.527] List of 1
[10:18:31.527]  $ ...: list()
[10:18:31.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.527]  - attr(*, "where")=List of 1
[10:18:31.527]   ..$ ...:<environment: 0x55844a26d920> 
[10:18:31.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.527]  - attr(*, "resolved")= logi TRUE
[10:18:31.527]  - attr(*, "total_size")= num NA
[10:18:31.530]  - Getting '...' globals ... DONE
[10:18:31.530] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.530] List of 2
[10:18:31.530]  $ ...future.FUN:function (object, ...)  
[10:18:31.530]  $ ...          : list()
[10:18:31.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.530]  - attr(*, "where")=List of 2
[10:18:31.530]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.530]   ..$ ...          :<environment: 0x55844a26d920> 
[10:18:31.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.530]  - attr(*, "resolved")= logi FALSE
[10:18:31.530]  - attr(*, "total_size")= num 15670
[10:18:31.533] Packages to be attached in all futures: [n=0] 
[10:18:31.533] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.533] Number of futures (= number of chunks): 1
[10:18:31.534] Launching 1 futures (chunks) ...
[10:18:31.534] Chunk #1 of 1 ...
[10:18:31.534]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.534] getGlobalsAndPackages() ...
[10:18:31.534] Searching for globals...
[10:18:31.534] 
[10:18:31.534] Searching for globals ... DONE
[10:18:31.535] - globals: [0] <none>
[10:18:31.535] getGlobalsAndPackages() ... DONE
[10:18:31.535]    + additional globals found: [n=0] 
[10:18:31.535]    + additional namespaces needed: [n=0] 
[10:18:31.535]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.535]  - seeds: <none>
[10:18:31.535]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.535] getGlobalsAndPackages() ...
[10:18:31.535] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.535] Resolving globals: FALSE
[10:18:31.535] Tweak future expression to call with '...' arguments ...
[10:18:31.536] {
[10:18:31.536]     do.call(function(...) {
[10:18:31.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.536]             on.exit(options(oopts), add = TRUE)
[10:18:31.536]         }
[10:18:31.536]         {
[10:18:31.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.536]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.536]             })
[10:18:31.536]         }
[10:18:31.536]     }, args = future.call.arguments)
[10:18:31.536] }
[10:18:31.536] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.536] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.536] 
[10:18:31.536] getGlobalsAndPackages() ... DONE
[10:18:31.537] run() for ‘Future’ ...
[10:18:31.537] - state: ‘created’
[10:18:31.537] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:31.537] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.537]   - Field: ‘label’
[10:18:31.537]   - Field: ‘local’
[10:18:31.538]   - Field: ‘owner’
[10:18:31.538]   - Field: ‘envir’
[10:18:31.538]   - Field: ‘packages’
[10:18:31.538]   - Field: ‘gc’
[10:18:31.538]   - Field: ‘conditions’
[10:18:31.538]   - Field: ‘expr’
[10:18:31.538]   - Field: ‘uuid’
[10:18:31.538]   - Field: ‘seed’
[10:18:31.538]   - Field: ‘version’
[10:18:31.538]   - Field: ‘result’
[10:18:31.538]   - Field: ‘asynchronous’
[10:18:31.538]   - Field: ‘calls’
[10:18:31.539]   - Field: ‘globals’
[10:18:31.539]   - Field: ‘stdout’
[10:18:31.539]   - Field: ‘earlySignal’
[10:18:31.539]   - Field: ‘lazy’
[10:18:31.539]   - Field: ‘state’
[10:18:31.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.539] - Launch lazy future ...
[10:18:31.539] Packages needed by the future expression (n = 0): <none>
[10:18:31.539] Packages needed by future strategies (n = 0): <none>
[10:18:31.540] {
[10:18:31.540]     {
[10:18:31.540]         {
[10:18:31.540]             ...future.startTime <- base::Sys.time()
[10:18:31.540]             {
[10:18:31.540]                 {
[10:18:31.540]                   {
[10:18:31.540]                     base::local({
[10:18:31.540]                       has_future <- base::requireNamespace("future", 
[10:18:31.540]                         quietly = TRUE)
[10:18:31.540]                       if (has_future) {
[10:18:31.540]                         ns <- base::getNamespace("future")
[10:18:31.540]                         version <- ns[[".package"]][["version"]]
[10:18:31.540]                         if (is.null(version)) 
[10:18:31.540]                           version <- utils::packageVersion("future")
[10:18:31.540]                       }
[10:18:31.540]                       else {
[10:18:31.540]                         version <- NULL
[10:18:31.540]                       }
[10:18:31.540]                       if (!has_future || version < "1.8.0") {
[10:18:31.540]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.540]                           "", base::R.version$version.string), 
[10:18:31.540]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.540]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.540]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.540]                             "release", "version")], collapse = " "), 
[10:18:31.540]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.540]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.540]                           info)
[10:18:31.540]                         info <- base::paste(info, collapse = "; ")
[10:18:31.540]                         if (!has_future) {
[10:18:31.540]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.540]                             info)
[10:18:31.540]                         }
[10:18:31.540]                         else {
[10:18:31.540]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.540]                             info, version)
[10:18:31.540]                         }
[10:18:31.540]                         base::stop(msg)
[10:18:31.540]                       }
[10:18:31.540]                     })
[10:18:31.540]                   }
[10:18:31.540]                   ...future.strategy.old <- future::plan("list")
[10:18:31.540]                   options(future.plan = NULL)
[10:18:31.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.540]                 }
[10:18:31.540]                 ...future.workdir <- getwd()
[10:18:31.540]             }
[10:18:31.540]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.540]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.540]         }
[10:18:31.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.540]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.540]             base::names(...future.oldOptions))
[10:18:31.540]     }
[10:18:31.540]     if (FALSE) {
[10:18:31.540]     }
[10:18:31.540]     else {
[10:18:31.540]         if (TRUE) {
[10:18:31.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.540]                 open = "w")
[10:18:31.540]         }
[10:18:31.540]         else {
[10:18:31.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.540]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.540]         }
[10:18:31.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.540]             base::sink(type = "output", split = FALSE)
[10:18:31.540]             base::close(...future.stdout)
[10:18:31.540]         }, add = TRUE)
[10:18:31.540]     }
[10:18:31.540]     ...future.frame <- base::sys.nframe()
[10:18:31.540]     ...future.conditions <- base::list()
[10:18:31.540]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.540]     if (FALSE) {
[10:18:31.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.540]     }
[10:18:31.540]     ...future.result <- base::tryCatch({
[10:18:31.540]         base::withCallingHandlers({
[10:18:31.540]             ...future.value <- base::withVisible(base::local({
[10:18:31.540]                 do.call(function(...) {
[10:18:31.540]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.540]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.540]                     ...future.globals.maxSize)) {
[10:18:31.540]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.540]                     on.exit(options(oopts), add = TRUE)
[10:18:31.540]                   }
[10:18:31.540]                   {
[10:18:31.540]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.540]                       FUN = function(jj) {
[10:18:31.540]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.540]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.540]                       })
[10:18:31.540]                   }
[10:18:31.540]                 }, args = future.call.arguments)
[10:18:31.540]             }))
[10:18:31.540]             future::FutureResult(value = ...future.value$value, 
[10:18:31.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.540]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.540]                     ...future.globalenv.names))
[10:18:31.540]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.540]         }, condition = base::local({
[10:18:31.540]             c <- base::c
[10:18:31.540]             inherits <- base::inherits
[10:18:31.540]             invokeRestart <- base::invokeRestart
[10:18:31.540]             length <- base::length
[10:18:31.540]             list <- base::list
[10:18:31.540]             seq.int <- base::seq.int
[10:18:31.540]             signalCondition <- base::signalCondition
[10:18:31.540]             sys.calls <- base::sys.calls
[10:18:31.540]             `[[` <- base::`[[`
[10:18:31.540]             `+` <- base::`+`
[10:18:31.540]             `<<-` <- base::`<<-`
[10:18:31.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.540]                   3L)]
[10:18:31.540]             }
[10:18:31.540]             function(cond) {
[10:18:31.540]                 is_error <- inherits(cond, "error")
[10:18:31.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.540]                   NULL)
[10:18:31.540]                 if (is_error) {
[10:18:31.540]                   sessionInformation <- function() {
[10:18:31.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.540]                       search = base::search(), system = base::Sys.info())
[10:18:31.540]                   }
[10:18:31.540]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.540]                     cond$call), session = sessionInformation(), 
[10:18:31.540]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.540]                   signalCondition(cond)
[10:18:31.540]                 }
[10:18:31.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.540]                 "immediateCondition"))) {
[10:18:31.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.540]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.540]                   if (TRUE && !signal) {
[10:18:31.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.540]                     {
[10:18:31.540]                       inherits <- base::inherits
[10:18:31.540]                       invokeRestart <- base::invokeRestart
[10:18:31.540]                       is.null <- base::is.null
[10:18:31.540]                       muffled <- FALSE
[10:18:31.540]                       if (inherits(cond, "message")) {
[10:18:31.540]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.540]                         if (muffled) 
[10:18:31.540]                           invokeRestart("muffleMessage")
[10:18:31.540]                       }
[10:18:31.540]                       else if (inherits(cond, "warning")) {
[10:18:31.540]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.540]                         if (muffled) 
[10:18:31.540]                           invokeRestart("muffleWarning")
[10:18:31.540]                       }
[10:18:31.540]                       else if (inherits(cond, "condition")) {
[10:18:31.540]                         if (!is.null(pattern)) {
[10:18:31.540]                           computeRestarts <- base::computeRestarts
[10:18:31.540]                           grepl <- base::grepl
[10:18:31.540]                           restarts <- computeRestarts(cond)
[10:18:31.540]                           for (restart in restarts) {
[10:18:31.540]                             name <- restart$name
[10:18:31.540]                             if (is.null(name)) 
[10:18:31.540]                               next
[10:18:31.540]                             if (!grepl(pattern, name)) 
[10:18:31.540]                               next
[10:18:31.540]                             invokeRestart(restart)
[10:18:31.540]                             muffled <- TRUE
[10:18:31.540]                             break
[10:18:31.540]                           }
[10:18:31.540]                         }
[10:18:31.540]                       }
[10:18:31.540]                       invisible(muffled)
[10:18:31.540]                     }
[10:18:31.540]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.540]                   }
[10:18:31.540]                 }
[10:18:31.540]                 else {
[10:18:31.540]                   if (TRUE) {
[10:18:31.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.540]                     {
[10:18:31.540]                       inherits <- base::inherits
[10:18:31.540]                       invokeRestart <- base::invokeRestart
[10:18:31.540]                       is.null <- base::is.null
[10:18:31.540]                       muffled <- FALSE
[10:18:31.540]                       if (inherits(cond, "message")) {
[10:18:31.540]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.540]                         if (muffled) 
[10:18:31.540]                           invokeRestart("muffleMessage")
[10:18:31.540]                       }
[10:18:31.540]                       else if (inherits(cond, "warning")) {
[10:18:31.540]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.540]                         if (muffled) 
[10:18:31.540]                           invokeRestart("muffleWarning")
[10:18:31.540]                       }
[10:18:31.540]                       else if (inherits(cond, "condition")) {
[10:18:31.540]                         if (!is.null(pattern)) {
[10:18:31.540]                           computeRestarts <- base::computeRestarts
[10:18:31.540]                           grepl <- base::grepl
[10:18:31.540]                           restarts <- computeRestarts(cond)
[10:18:31.540]                           for (restart in restarts) {
[10:18:31.540]                             name <- restart$name
[10:18:31.540]                             if (is.null(name)) 
[10:18:31.540]                               next
[10:18:31.540]                             if (!grepl(pattern, name)) 
[10:18:31.540]                               next
[10:18:31.540]                             invokeRestart(restart)
[10:18:31.540]                             muffled <- TRUE
[10:18:31.540]                             break
[10:18:31.540]                           }
[10:18:31.540]                         }
[10:18:31.540]                       }
[10:18:31.540]                       invisible(muffled)
[10:18:31.540]                     }
[10:18:31.540]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.540]                   }
[10:18:31.540]                 }
[10:18:31.540]             }
[10:18:31.540]         }))
[10:18:31.540]     }, error = function(ex) {
[10:18:31.540]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.540]                 ...future.rng), started = ...future.startTime, 
[10:18:31.540]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.540]             version = "1.8"), class = "FutureResult")
[10:18:31.540]     }, finally = {
[10:18:31.540]         if (!identical(...future.workdir, getwd())) 
[10:18:31.540]             setwd(...future.workdir)
[10:18:31.540]         {
[10:18:31.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.540]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.540]             }
[10:18:31.540]             base::options(...future.oldOptions)
[10:18:31.540]             if (.Platform$OS.type == "windows") {
[10:18:31.540]                 old_names <- names(...future.oldEnvVars)
[10:18:31.540]                 envs <- base::Sys.getenv()
[10:18:31.540]                 names <- names(envs)
[10:18:31.540]                 common <- intersect(names, old_names)
[10:18:31.540]                 added <- setdiff(names, old_names)
[10:18:31.540]                 removed <- setdiff(old_names, names)
[10:18:31.540]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.540]                   envs[common]]
[10:18:31.540]                 NAMES <- toupper(changed)
[10:18:31.540]                 args <- list()
[10:18:31.540]                 for (kk in seq_along(NAMES)) {
[10:18:31.540]                   name <- changed[[kk]]
[10:18:31.540]                   NAME <- NAMES[[kk]]
[10:18:31.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.540]                     next
[10:18:31.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.540]                 }
[10:18:31.540]                 NAMES <- toupper(added)
[10:18:31.540]                 for (kk in seq_along(NAMES)) {
[10:18:31.540]                   name <- added[[kk]]
[10:18:31.540]                   NAME <- NAMES[[kk]]
[10:18:31.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.540]                     next
[10:18:31.540]                   args[[name]] <- ""
[10:18:31.540]                 }
[10:18:31.540]                 NAMES <- toupper(removed)
[10:18:31.540]                 for (kk in seq_along(NAMES)) {
[10:18:31.540]                   name <- removed[[kk]]
[10:18:31.540]                   NAME <- NAMES[[kk]]
[10:18:31.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.540]                     next
[10:18:31.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.540]                 }
[10:18:31.540]                 if (length(args) > 0) 
[10:18:31.540]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.540]             }
[10:18:31.540]             else {
[10:18:31.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.540]             }
[10:18:31.540]             {
[10:18:31.540]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.540]                   0L) {
[10:18:31.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.540]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.540]                   base::options(opts)
[10:18:31.540]                 }
[10:18:31.540]                 {
[10:18:31.540]                   {
[10:18:31.540]                     NULL
[10:18:31.540]                     RNGkind("Mersenne-Twister")
[10:18:31.540]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.540]                       inherits = FALSE)
[10:18:31.540]                   }
[10:18:31.540]                   options(future.plan = NULL)
[10:18:31.540]                   if (is.na(NA_character_)) 
[10:18:31.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.540]                     .init = FALSE)
[10:18:31.540]                 }
[10:18:31.540]             }
[10:18:31.540]         }
[10:18:31.540]     })
[10:18:31.540]     if (TRUE) {
[10:18:31.540]         base::sink(type = "output", split = FALSE)
[10:18:31.540]         if (TRUE) {
[10:18:31.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.540]         }
[10:18:31.540]         else {
[10:18:31.540]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.540]         }
[10:18:31.540]         base::close(...future.stdout)
[10:18:31.540]         ...future.stdout <- NULL
[10:18:31.540]     }
[10:18:31.540]     ...future.result$conditions <- ...future.conditions
[10:18:31.540]     ...future.result$finished <- base::Sys.time()
[10:18:31.540]     ...future.result
[10:18:31.540] }
[10:18:31.542] assign_globals() ...
[10:18:31.542] List of 5
[10:18:31.542]  $ ...future.FUN            :function (object, ...)  
[10:18:31.542]  $ future.call.arguments    : list()
[10:18:31.542]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.542]  $ ...future.elements_ii    :List of 3
[10:18:31.542]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.542]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.542]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.542]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.542]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.542]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.542]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.542]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.542]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.542]  $ ...future.seeds_ii       : NULL
[10:18:31.542]  $ ...future.globals.maxSize: NULL
[10:18:31.542]  - attr(*, "where")=List of 5
[10:18:31.542]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.542]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.542]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.542]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.542]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.542]  - attr(*, "resolved")= logi FALSE
[10:18:31.542]  - attr(*, "total_size")= num 15670
[10:18:31.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.542]  - attr(*, "already-done")= logi TRUE
[10:18:31.551] - copied ‘...future.FUN’ to environment
[10:18:31.552] - copied ‘future.call.arguments’ to environment
[10:18:31.552] - copied ‘...future.elements_ii’ to environment
[10:18:31.552] - copied ‘...future.seeds_ii’ to environment
[10:18:31.552] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.552] assign_globals() ... done
[10:18:31.552] plan(): Setting new future strategy stack:
[10:18:31.552] List of future strategies:
[10:18:31.552] 1. sequential:
[10:18:31.552]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.552]    - tweaked: FALSE
[10:18:31.552]    - call: NULL
[10:18:31.553] plan(): nbrOfWorkers() = 1
[10:18:31.555] plan(): Setting new future strategy stack:
[10:18:31.555] List of future strategies:
[10:18:31.555] 1. sequential:
[10:18:31.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.555]    - tweaked: FALSE
[10:18:31.555]    - call: plan(strategy)
[10:18:31.555] plan(): nbrOfWorkers() = 1
[10:18:31.555] SequentialFuture started (and completed)
[10:18:31.556] - Launch lazy future ... done
[10:18:31.556] run() for ‘SequentialFuture’ ... done
[10:18:31.556] Created future:
[10:18:31.556] SequentialFuture:
[10:18:31.556] Label: ‘future_by-1’
[10:18:31.556] Expression:
[10:18:31.556] {
[10:18:31.556]     do.call(function(...) {
[10:18:31.556]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.556]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.556]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.556]             on.exit(options(oopts), add = TRUE)
[10:18:31.556]         }
[10:18:31.556]         {
[10:18:31.556]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.556]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.556]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.556]             })
[10:18:31.556]         }
[10:18:31.556]     }, args = future.call.arguments)
[10:18:31.556] }
[10:18:31.556] Lazy evaluation: FALSE
[10:18:31.556] Asynchronous evaluation: FALSE
[10:18:31.556] Local evaluation: TRUE
[10:18:31.556] Environment: R_GlobalEnv
[10:18:31.556] Capture standard output: TRUE
[10:18:31.556] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.556] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.556] Packages: <none>
[10:18:31.556] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.556] Resolved: TRUE
[10:18:31.556] Value: 1.16 KiB of class ‘list’
[10:18:31.556] Early signaling: FALSE
[10:18:31.556] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.556] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.557] Chunk #1 of 1 ... DONE
[10:18:31.557] Launching 1 futures (chunks) ... DONE
[10:18:31.557] Resolving 1 futures (chunks) ...
[10:18:31.557] resolve() on list ...
[10:18:31.557]  recursive: 0
[10:18:31.557]  length: 1
[10:18:31.557] 
[10:18:31.557] resolved() for ‘SequentialFuture’ ...
[10:18:31.557] - state: ‘finished’
[10:18:31.557] - run: TRUE
[10:18:31.557] - result: ‘FutureResult’
[10:18:31.558] resolved() for ‘SequentialFuture’ ... done
[10:18:31.558] Future #1
[10:18:31.558] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.558] - nx: 1
[10:18:31.558] - relay: TRUE
[10:18:31.558] - stdout: TRUE
[10:18:31.558] - signal: TRUE
[10:18:31.558] - resignal: FALSE
[10:18:31.558] - force: TRUE
[10:18:31.558] - relayed: [n=1] FALSE
[10:18:31.558] - queued futures: [n=1] FALSE
[10:18:31.559]  - until=1
[10:18:31.559]  - relaying element #1
[10:18:31.559] - relayed: [n=1] TRUE
[10:18:31.559] - queued futures: [n=1] TRUE
[10:18:31.559] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.559]  length: 0 (resolved future 1)
[10:18:31.559] Relaying remaining futures
[10:18:31.559] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.559] - nx: 1
[10:18:31.559] - relay: TRUE
[10:18:31.559] - stdout: TRUE
[10:18:31.560] - signal: TRUE
[10:18:31.560] - resignal: FALSE
[10:18:31.560] - force: TRUE
[10:18:31.560] - relayed: [n=1] TRUE
[10:18:31.560] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.560] - relayed: [n=1] TRUE
[10:18:31.560] - queued futures: [n=1] TRUE
[10:18:31.560] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.560] resolve() on list ... DONE
[10:18:31.560]  - Number of value chunks collected: 1
[10:18:31.560] Resolving 1 futures (chunks) ... DONE
[10:18:31.560] Reducing values from 1 chunks ...
[10:18:31.561]  - Number of values collected after concatenation: 3
[10:18:31.561]  - Number of values expected: 3
[10:18:31.561] Reducing values from 1 chunks ... DONE
[10:18:31.561] future_lapply() ... DONE
[10:18:31.561] future_by_internal() ... DONE
[10:18:31.561] future_by_internal() ...
[10:18:31.561] future_lapply() ...
[10:18:31.562] Number of chunks: 1
[10:18:31.562] getGlobalsAndPackagesXApply() ...
[10:18:31.562]  - future.globals: TRUE
[10:18:31.562] getGlobalsAndPackages() ...
[10:18:31.562] Searching for globals...
[10:18:31.563] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.564] Searching for globals ... DONE
[10:18:31.564] Resolving globals: FALSE
[10:18:31.566] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.566] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.566] - globals: [1] ‘FUN’
[10:18:31.566] 
[10:18:31.566] getGlobalsAndPackages() ... DONE
[10:18:31.566]  - globals found/used: [n=1] ‘FUN’
[10:18:31.566]  - needed namespaces: [n=0] 
[10:18:31.567] Finding globals ... DONE
[10:18:31.567]  - use_args: TRUE
[10:18:31.567]  - Getting '...' globals ...
[10:18:31.567] resolve() on list ...
[10:18:31.567]  recursive: 0
[10:18:31.567]  length: 1
[10:18:31.567]  elements: ‘...’
[10:18:31.567]  length: 0 (resolved future 1)
[10:18:31.568] resolve() on list ... DONE
[10:18:31.568]    - '...' content: [n=1] ‘digits’
[10:18:31.568] List of 1
[10:18:31.568]  $ ...:List of 1
[10:18:31.568]   ..$ digits: int 2
[10:18:31.568]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.568]  - attr(*, "where")=List of 1
[10:18:31.568]   ..$ ...:<environment: 0x55844a56c270> 
[10:18:31.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.568]  - attr(*, "resolved")= logi TRUE
[10:18:31.568]  - attr(*, "total_size")= num NA
[10:18:31.571]  - Getting '...' globals ... DONE
[10:18:31.571] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.571] List of 2
[10:18:31.571]  $ ...future.FUN:function (object, ...)  
[10:18:31.571]  $ ...          :List of 1
[10:18:31.571]   ..$ digits: int 2
[10:18:31.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.571]  - attr(*, "where")=List of 2
[10:18:31.571]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.571]   ..$ ...          :<environment: 0x55844a56c270> 
[10:18:31.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.571]  - attr(*, "resolved")= logi FALSE
[10:18:31.571]  - attr(*, "total_size")= num 13284
[10:18:31.574] Packages to be attached in all futures: [n=0] 
[10:18:31.574] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.574] Number of futures (= number of chunks): 1
[10:18:31.574] Launching 1 futures (chunks) ...
[10:18:31.574] Chunk #1 of 1 ...
[10:18:31.575]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.575] getGlobalsAndPackages() ...
[10:18:31.575] Searching for globals...
[10:18:31.575] 
[10:18:31.575] Searching for globals ... DONE
[10:18:31.575] - globals: [0] <none>
[10:18:31.575] getGlobalsAndPackages() ... DONE
[10:18:31.575]    + additional globals found: [n=0] 
[10:18:31.575]    + additional namespaces needed: [n=0] 
[10:18:31.575]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.576]  - seeds: <none>
[10:18:31.576]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.576] getGlobalsAndPackages() ...
[10:18:31.576] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.576] Resolving globals: FALSE
[10:18:31.576] Tweak future expression to call with '...' arguments ...
[10:18:31.576] {
[10:18:31.576]     do.call(function(...) {
[10:18:31.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.576]             on.exit(options(oopts), add = TRUE)
[10:18:31.576]         }
[10:18:31.576]         {
[10:18:31.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.576]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.576]             })
[10:18:31.576]         }
[10:18:31.576]     }, args = future.call.arguments)
[10:18:31.576] }
[10:18:31.576] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.577] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.577] 
[10:18:31.577] getGlobalsAndPackages() ... DONE
[10:18:31.577] run() for ‘Future’ ...
[10:18:31.577] - state: ‘created’
[10:18:31.577] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:31.578] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.578]   - Field: ‘label’
[10:18:31.578]   - Field: ‘local’
[10:18:31.578]   - Field: ‘owner’
[10:18:31.578]   - Field: ‘envir’
[10:18:31.578]   - Field: ‘packages’
[10:18:31.578]   - Field: ‘gc’
[10:18:31.578]   - Field: ‘conditions’
[10:18:31.578]   - Field: ‘expr’
[10:18:31.579]   - Field: ‘uuid’
[10:18:31.579]   - Field: ‘seed’
[10:18:31.579]   - Field: ‘version’
[10:18:31.579]   - Field: ‘result’
[10:18:31.579]   - Field: ‘asynchronous’
[10:18:31.579]   - Field: ‘calls’
[10:18:31.579]   - Field: ‘globals’
[10:18:31.579]   - Field: ‘stdout’
[10:18:31.579]   - Field: ‘earlySignal’
[10:18:31.579]   - Field: ‘lazy’
[10:18:31.579]   - Field: ‘state’
[10:18:31.579] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.580] - Launch lazy future ...
[10:18:31.580] Packages needed by the future expression (n = 0): <none>
[10:18:31.580] Packages needed by future strategies (n = 0): <none>
[10:18:31.580] {
[10:18:31.580]     {
[10:18:31.580]         {
[10:18:31.580]             ...future.startTime <- base::Sys.time()
[10:18:31.580]             {
[10:18:31.580]                 {
[10:18:31.580]                   {
[10:18:31.580]                     base::local({
[10:18:31.580]                       has_future <- base::requireNamespace("future", 
[10:18:31.580]                         quietly = TRUE)
[10:18:31.580]                       if (has_future) {
[10:18:31.580]                         ns <- base::getNamespace("future")
[10:18:31.580]                         version <- ns[[".package"]][["version"]]
[10:18:31.580]                         if (is.null(version)) 
[10:18:31.580]                           version <- utils::packageVersion("future")
[10:18:31.580]                       }
[10:18:31.580]                       else {
[10:18:31.580]                         version <- NULL
[10:18:31.580]                       }
[10:18:31.580]                       if (!has_future || version < "1.8.0") {
[10:18:31.580]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.580]                           "", base::R.version$version.string), 
[10:18:31.580]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.580]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.580]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.580]                             "release", "version")], collapse = " "), 
[10:18:31.580]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.580]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.580]                           info)
[10:18:31.580]                         info <- base::paste(info, collapse = "; ")
[10:18:31.580]                         if (!has_future) {
[10:18:31.580]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.580]                             info)
[10:18:31.580]                         }
[10:18:31.580]                         else {
[10:18:31.580]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.580]                             info, version)
[10:18:31.580]                         }
[10:18:31.580]                         base::stop(msg)
[10:18:31.580]                       }
[10:18:31.580]                     })
[10:18:31.580]                   }
[10:18:31.580]                   ...future.strategy.old <- future::plan("list")
[10:18:31.580]                   options(future.plan = NULL)
[10:18:31.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.580]                 }
[10:18:31.580]                 ...future.workdir <- getwd()
[10:18:31.580]             }
[10:18:31.580]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.580]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.580]         }
[10:18:31.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.580]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.580]             base::names(...future.oldOptions))
[10:18:31.580]     }
[10:18:31.580]     if (FALSE) {
[10:18:31.580]     }
[10:18:31.580]     else {
[10:18:31.580]         if (TRUE) {
[10:18:31.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.580]                 open = "w")
[10:18:31.580]         }
[10:18:31.580]         else {
[10:18:31.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.580]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.580]         }
[10:18:31.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.580]             base::sink(type = "output", split = FALSE)
[10:18:31.580]             base::close(...future.stdout)
[10:18:31.580]         }, add = TRUE)
[10:18:31.580]     }
[10:18:31.580]     ...future.frame <- base::sys.nframe()
[10:18:31.580]     ...future.conditions <- base::list()
[10:18:31.580]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.580]     if (FALSE) {
[10:18:31.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.580]     }
[10:18:31.580]     ...future.result <- base::tryCatch({
[10:18:31.580]         base::withCallingHandlers({
[10:18:31.580]             ...future.value <- base::withVisible(base::local({
[10:18:31.580]                 do.call(function(...) {
[10:18:31.580]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.580]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.580]                     ...future.globals.maxSize)) {
[10:18:31.580]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.580]                     on.exit(options(oopts), add = TRUE)
[10:18:31.580]                   }
[10:18:31.580]                   {
[10:18:31.580]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.580]                       FUN = function(jj) {
[10:18:31.580]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.580]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.580]                       })
[10:18:31.580]                   }
[10:18:31.580]                 }, args = future.call.arguments)
[10:18:31.580]             }))
[10:18:31.580]             future::FutureResult(value = ...future.value$value, 
[10:18:31.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.580]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.580]                     ...future.globalenv.names))
[10:18:31.580]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.580]         }, condition = base::local({
[10:18:31.580]             c <- base::c
[10:18:31.580]             inherits <- base::inherits
[10:18:31.580]             invokeRestart <- base::invokeRestart
[10:18:31.580]             length <- base::length
[10:18:31.580]             list <- base::list
[10:18:31.580]             seq.int <- base::seq.int
[10:18:31.580]             signalCondition <- base::signalCondition
[10:18:31.580]             sys.calls <- base::sys.calls
[10:18:31.580]             `[[` <- base::`[[`
[10:18:31.580]             `+` <- base::`+`
[10:18:31.580]             `<<-` <- base::`<<-`
[10:18:31.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.580]                   3L)]
[10:18:31.580]             }
[10:18:31.580]             function(cond) {
[10:18:31.580]                 is_error <- inherits(cond, "error")
[10:18:31.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.580]                   NULL)
[10:18:31.580]                 if (is_error) {
[10:18:31.580]                   sessionInformation <- function() {
[10:18:31.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.580]                       search = base::search(), system = base::Sys.info())
[10:18:31.580]                   }
[10:18:31.580]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.580]                     cond$call), session = sessionInformation(), 
[10:18:31.580]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.580]                   signalCondition(cond)
[10:18:31.580]                 }
[10:18:31.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.580]                 "immediateCondition"))) {
[10:18:31.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.580]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.580]                   if (TRUE && !signal) {
[10:18:31.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.580]                     {
[10:18:31.580]                       inherits <- base::inherits
[10:18:31.580]                       invokeRestart <- base::invokeRestart
[10:18:31.580]                       is.null <- base::is.null
[10:18:31.580]                       muffled <- FALSE
[10:18:31.580]                       if (inherits(cond, "message")) {
[10:18:31.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.580]                         if (muffled) 
[10:18:31.580]                           invokeRestart("muffleMessage")
[10:18:31.580]                       }
[10:18:31.580]                       else if (inherits(cond, "warning")) {
[10:18:31.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.580]                         if (muffled) 
[10:18:31.580]                           invokeRestart("muffleWarning")
[10:18:31.580]                       }
[10:18:31.580]                       else if (inherits(cond, "condition")) {
[10:18:31.580]                         if (!is.null(pattern)) {
[10:18:31.580]                           computeRestarts <- base::computeRestarts
[10:18:31.580]                           grepl <- base::grepl
[10:18:31.580]                           restarts <- computeRestarts(cond)
[10:18:31.580]                           for (restart in restarts) {
[10:18:31.580]                             name <- restart$name
[10:18:31.580]                             if (is.null(name)) 
[10:18:31.580]                               next
[10:18:31.580]                             if (!grepl(pattern, name)) 
[10:18:31.580]                               next
[10:18:31.580]                             invokeRestart(restart)
[10:18:31.580]                             muffled <- TRUE
[10:18:31.580]                             break
[10:18:31.580]                           }
[10:18:31.580]                         }
[10:18:31.580]                       }
[10:18:31.580]                       invisible(muffled)
[10:18:31.580]                     }
[10:18:31.580]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.580]                   }
[10:18:31.580]                 }
[10:18:31.580]                 else {
[10:18:31.580]                   if (TRUE) {
[10:18:31.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.580]                     {
[10:18:31.580]                       inherits <- base::inherits
[10:18:31.580]                       invokeRestart <- base::invokeRestart
[10:18:31.580]                       is.null <- base::is.null
[10:18:31.580]                       muffled <- FALSE
[10:18:31.580]                       if (inherits(cond, "message")) {
[10:18:31.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.580]                         if (muffled) 
[10:18:31.580]                           invokeRestart("muffleMessage")
[10:18:31.580]                       }
[10:18:31.580]                       else if (inherits(cond, "warning")) {
[10:18:31.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.580]                         if (muffled) 
[10:18:31.580]                           invokeRestart("muffleWarning")
[10:18:31.580]                       }
[10:18:31.580]                       else if (inherits(cond, "condition")) {
[10:18:31.580]                         if (!is.null(pattern)) {
[10:18:31.580]                           computeRestarts <- base::computeRestarts
[10:18:31.580]                           grepl <- base::grepl
[10:18:31.580]                           restarts <- computeRestarts(cond)
[10:18:31.580]                           for (restart in restarts) {
[10:18:31.580]                             name <- restart$name
[10:18:31.580]                             if (is.null(name)) 
[10:18:31.580]                               next
[10:18:31.580]                             if (!grepl(pattern, name)) 
[10:18:31.580]                               next
[10:18:31.580]                             invokeRestart(restart)
[10:18:31.580]                             muffled <- TRUE
[10:18:31.580]                             break
[10:18:31.580]                           }
[10:18:31.580]                         }
[10:18:31.580]                       }
[10:18:31.580]                       invisible(muffled)
[10:18:31.580]                     }
[10:18:31.580]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.580]                   }
[10:18:31.580]                 }
[10:18:31.580]             }
[10:18:31.580]         }))
[10:18:31.580]     }, error = function(ex) {
[10:18:31.580]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.580]                 ...future.rng), started = ...future.startTime, 
[10:18:31.580]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.580]             version = "1.8"), class = "FutureResult")
[10:18:31.580]     }, finally = {
[10:18:31.580]         if (!identical(...future.workdir, getwd())) 
[10:18:31.580]             setwd(...future.workdir)
[10:18:31.580]         {
[10:18:31.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.580]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.580]             }
[10:18:31.580]             base::options(...future.oldOptions)
[10:18:31.580]             if (.Platform$OS.type == "windows") {
[10:18:31.580]                 old_names <- names(...future.oldEnvVars)
[10:18:31.580]                 envs <- base::Sys.getenv()
[10:18:31.580]                 names <- names(envs)
[10:18:31.580]                 common <- intersect(names, old_names)
[10:18:31.580]                 added <- setdiff(names, old_names)
[10:18:31.580]                 removed <- setdiff(old_names, names)
[10:18:31.580]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.580]                   envs[common]]
[10:18:31.580]                 NAMES <- toupper(changed)
[10:18:31.580]                 args <- list()
[10:18:31.580]                 for (kk in seq_along(NAMES)) {
[10:18:31.580]                   name <- changed[[kk]]
[10:18:31.580]                   NAME <- NAMES[[kk]]
[10:18:31.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.580]                     next
[10:18:31.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.580]                 }
[10:18:31.580]                 NAMES <- toupper(added)
[10:18:31.580]                 for (kk in seq_along(NAMES)) {
[10:18:31.580]                   name <- added[[kk]]
[10:18:31.580]                   NAME <- NAMES[[kk]]
[10:18:31.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.580]                     next
[10:18:31.580]                   args[[name]] <- ""
[10:18:31.580]                 }
[10:18:31.580]                 NAMES <- toupper(removed)
[10:18:31.580]                 for (kk in seq_along(NAMES)) {
[10:18:31.580]                   name <- removed[[kk]]
[10:18:31.580]                   NAME <- NAMES[[kk]]
[10:18:31.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.580]                     next
[10:18:31.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.580]                 }
[10:18:31.580]                 if (length(args) > 0) 
[10:18:31.580]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.580]             }
[10:18:31.580]             else {
[10:18:31.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.580]             }
[10:18:31.580]             {
[10:18:31.580]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.580]                   0L) {
[10:18:31.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.580]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.580]                   base::options(opts)
[10:18:31.580]                 }
[10:18:31.580]                 {
[10:18:31.580]                   {
[10:18:31.580]                     NULL
[10:18:31.580]                     RNGkind("Mersenne-Twister")
[10:18:31.580]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.580]                       inherits = FALSE)
[10:18:31.580]                   }
[10:18:31.580]                   options(future.plan = NULL)
[10:18:31.580]                   if (is.na(NA_character_)) 
[10:18:31.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.580]                     .init = FALSE)
[10:18:31.580]                 }
[10:18:31.580]             }
[10:18:31.580]         }
[10:18:31.580]     })
[10:18:31.580]     if (TRUE) {
[10:18:31.580]         base::sink(type = "output", split = FALSE)
[10:18:31.580]         if (TRUE) {
[10:18:31.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.580]         }
[10:18:31.580]         else {
[10:18:31.580]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.580]         }
[10:18:31.580]         base::close(...future.stdout)
[10:18:31.580]         ...future.stdout <- NULL
[10:18:31.580]     }
[10:18:31.580]     ...future.result$conditions <- ...future.conditions
[10:18:31.580]     ...future.result$finished <- base::Sys.time()
[10:18:31.580]     ...future.result
[10:18:31.580] }
[10:18:31.582] assign_globals() ...
[10:18:31.582] List of 5
[10:18:31.582]  $ ...future.FUN            :function (object, ...)  
[10:18:31.582]  $ future.call.arguments    :List of 1
[10:18:31.582]   ..$ digits: int 2
[10:18:31.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.582]  $ ...future.elements_ii    :List of 6
[10:18:31.582]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:18:31.582]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:18:31.582]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:18:31.582]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:18:31.582]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:18:31.582]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:18:31.582]  $ ...future.seeds_ii       : NULL
[10:18:31.582]  $ ...future.globals.maxSize: NULL
[10:18:31.582]  - attr(*, "where")=List of 5
[10:18:31.582]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.582]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.582]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.582]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.582]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.582]  - attr(*, "resolved")= logi FALSE
[10:18:31.582]  - attr(*, "total_size")= num 13284
[10:18:31.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.582]  - attr(*, "already-done")= logi TRUE
[10:18:31.590] - copied ‘...future.FUN’ to environment
[10:18:31.590] - copied ‘future.call.arguments’ to environment
[10:18:31.591] - copied ‘...future.elements_ii’ to environment
[10:18:31.591] - copied ‘...future.seeds_ii’ to environment
[10:18:31.591] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.591] assign_globals() ... done
[10:18:31.591] plan(): Setting new future strategy stack:
[10:18:31.591] List of future strategies:
[10:18:31.591] 1. sequential:
[10:18:31.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.591]    - tweaked: FALSE
[10:18:31.591]    - call: NULL
[10:18:31.592] plan(): nbrOfWorkers() = 1
[10:18:31.593] plan(): Setting new future strategy stack:
[10:18:31.593] List of future strategies:
[10:18:31.593] 1. sequential:
[10:18:31.593]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.593]    - tweaked: FALSE
[10:18:31.593]    - call: plan(strategy)
[10:18:31.594] plan(): nbrOfWorkers() = 1
[10:18:31.594] SequentialFuture started (and completed)
[10:18:31.594] - Launch lazy future ... done
[10:18:31.594] run() for ‘SequentialFuture’ ... done
[10:18:31.594] Created future:
[10:18:31.594] SequentialFuture:
[10:18:31.594] Label: ‘future_by-1’
[10:18:31.594] Expression:
[10:18:31.594] {
[10:18:31.594]     do.call(function(...) {
[10:18:31.594]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.594]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.594]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.594]             on.exit(options(oopts), add = TRUE)
[10:18:31.594]         }
[10:18:31.594]         {
[10:18:31.594]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.594]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.594]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.594]             })
[10:18:31.594]         }
[10:18:31.594]     }, args = future.call.arguments)
[10:18:31.594] }
[10:18:31.594] Lazy evaluation: FALSE
[10:18:31.594] Asynchronous evaluation: FALSE
[10:18:31.594] Local evaluation: TRUE
[10:18:31.594] Environment: R_GlobalEnv
[10:18:31.594] Capture standard output: TRUE
[10:18:31.594] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.594] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.594] Packages: <none>
[10:18:31.594] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.594] Resolved: TRUE
[10:18:31.594] Value: 1.27 KiB of class ‘list’
[10:18:31.594] Early signaling: FALSE
[10:18:31.594] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.594] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.595] Chunk #1 of 1 ... DONE
[10:18:31.595] Launching 1 futures (chunks) ... DONE
[10:18:31.595] Resolving 1 futures (chunks) ...
[10:18:31.595] resolve() on list ...
[10:18:31.595]  recursive: 0
[10:18:31.595]  length: 1
[10:18:31.595] 
[10:18:31.596] resolved() for ‘SequentialFuture’ ...
[10:18:31.596] - state: ‘finished’
[10:18:31.596] - run: TRUE
[10:18:31.596] - result: ‘FutureResult’
[10:18:31.596] resolved() for ‘SequentialFuture’ ... done
[10:18:31.596] Future #1
[10:18:31.596] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.596] - nx: 1
[10:18:31.596] - relay: TRUE
[10:18:31.596] - stdout: TRUE
[10:18:31.596] - signal: TRUE
[10:18:31.597] - resignal: FALSE
[10:18:31.597] - force: TRUE
[10:18:31.597] - relayed: [n=1] FALSE
[10:18:31.597] - queued futures: [n=1] FALSE
[10:18:31.597]  - until=1
[10:18:31.597]  - relaying element #1
[10:18:31.597] - relayed: [n=1] TRUE
[10:18:31.597] - queued futures: [n=1] TRUE
[10:18:31.597] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.597]  length: 0 (resolved future 1)
[10:18:31.597] Relaying remaining futures
[10:18:31.598] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.598] - nx: 1
[10:18:31.598] - relay: TRUE
[10:18:31.598] - stdout: TRUE
[10:18:31.598] - signal: TRUE
[10:18:31.598] - resignal: FALSE
[10:18:31.598] - force: TRUE
[10:18:31.598] - relayed: [n=1] TRUE
[10:18:31.598] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.598] - relayed: [n=1] TRUE
[10:18:31.598] - queued futures: [n=1] TRUE
[10:18:31.598] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.599] resolve() on list ... DONE
[10:18:31.599]  - Number of value chunks collected: 1
[10:18:31.599] Resolving 1 futures (chunks) ... DONE
[10:18:31.599] Reducing values from 1 chunks ...
[10:18:31.599]  - Number of values collected after concatenation: 6
[10:18:31.599]  - Number of values expected: 6
[10:18:31.599] Reducing values from 1 chunks ... DONE
[10:18:31.599] future_lapply() ... DONE
[10:18:31.599] future_by_internal() ... DONE
[10:18:31.600] future_by_internal() ...
[10:18:31.601] future_lapply() ...
[10:18:31.601] Number of chunks: 1
[10:18:31.602] getGlobalsAndPackagesXApply() ...
[10:18:31.602]  - future.globals: TRUE
[10:18:31.602] getGlobalsAndPackages() ...
[10:18:31.602] Searching for globals...
[10:18:31.603] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:31.603] Searching for globals ... DONE
[10:18:31.603] Resolving globals: FALSE
[10:18:31.604] The total size of the 1 globals is 762 bytes (762 bytes)
[10:18:31.604] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:18:31.604] - globals: [1] ‘FUN’
[10:18:31.604] - packages: [1] ‘stats’
[10:18:31.605] getGlobalsAndPackages() ... DONE
[10:18:31.605]  - globals found/used: [n=1] ‘FUN’
[10:18:31.605]  - needed namespaces: [n=1] ‘stats’
[10:18:31.605] Finding globals ... DONE
[10:18:31.605]  - use_args: TRUE
[10:18:31.605]  - Getting '...' globals ...
[10:18:31.605] resolve() on list ...
[10:18:31.605]  recursive: 0
[10:18:31.605]  length: 1
[10:18:31.606]  elements: ‘...’
[10:18:31.606]  length: 0 (resolved future 1)
[10:18:31.606] resolve() on list ... DONE
[10:18:31.606]    - '...' content: [n=1] ‘singular.ok’
[10:18:31.606] List of 1
[10:18:31.606]  $ ...:List of 1
[10:18:31.606]   ..$ singular.ok: logi FALSE
[10:18:31.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.606]  - attr(*, "where")=List of 1
[10:18:31.606]   ..$ ...:<environment: 0x55844a10f9b0> 
[10:18:31.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.606]  - attr(*, "resolved")= logi TRUE
[10:18:31.606]  - attr(*, "total_size")= num NA
[10:18:31.610]  - Getting '...' globals ... DONE
[10:18:31.611] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.611] List of 2
[10:18:31.611]  $ ...future.FUN:function (x, ...)  
[10:18:31.611]  $ ...          :List of 1
[10:18:31.611]   ..$ singular.ok: logi FALSE
[10:18:31.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.611]  - attr(*, "where")=List of 2
[10:18:31.611]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.611]   ..$ ...          :<environment: 0x55844a10f9b0> 
[10:18:31.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.611]  - attr(*, "resolved")= logi FALSE
[10:18:31.611]  - attr(*, "total_size")= num 19977
[10:18:31.614] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:31.614] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.614] Number of futures (= number of chunks): 1
[10:18:31.614] Launching 1 futures (chunks) ...
[10:18:31.614] Chunk #1 of 1 ...
[10:18:31.614]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.615] getGlobalsAndPackages() ...
[10:18:31.615] Searching for globals...
[10:18:31.615] 
[10:18:31.615] Searching for globals ... DONE
[10:18:31.615] - globals: [0] <none>
[10:18:31.615] getGlobalsAndPackages() ... DONE
[10:18:31.615]    + additional globals found: [n=0] 
[10:18:31.616]    + additional namespaces needed: [n=0] 
[10:18:31.616]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.616]  - seeds: <none>
[10:18:31.616]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.616] getGlobalsAndPackages() ...
[10:18:31.616] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.616] Resolving globals: FALSE
[10:18:31.616] Tweak future expression to call with '...' arguments ...
[10:18:31.616] {
[10:18:31.616]     do.call(function(...) {
[10:18:31.616]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.616]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.616]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.616]             on.exit(options(oopts), add = TRUE)
[10:18:31.616]         }
[10:18:31.616]         {
[10:18:31.616]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.616]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.616]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.616]             })
[10:18:31.616]         }
[10:18:31.616]     }, args = future.call.arguments)
[10:18:31.616] }
[10:18:31.617] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.617] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.617] 
[10:18:31.617] getGlobalsAndPackages() ... DONE
[10:18:31.617] run() for ‘Future’ ...
[10:18:31.617] - state: ‘created’
[10:18:31.618] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:31.618] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.618]   - Field: ‘label’
[10:18:31.618]   - Field: ‘local’
[10:18:31.618]   - Field: ‘owner’
[10:18:31.618]   - Field: ‘envir’
[10:18:31.618]   - Field: ‘packages’
[10:18:31.618]   - Field: ‘gc’
[10:18:31.619]   - Field: ‘conditions’
[10:18:31.619]   - Field: ‘expr’
[10:18:31.619]   - Field: ‘uuid’
[10:18:31.619]   - Field: ‘seed’
[10:18:31.619]   - Field: ‘version’
[10:18:31.619]   - Field: ‘result’
[10:18:31.619]   - Field: ‘asynchronous’
[10:18:31.619]   - Field: ‘calls’
[10:18:31.619]   - Field: ‘globals’
[10:18:31.619]   - Field: ‘stdout’
[10:18:31.619]   - Field: ‘earlySignal’
[10:18:31.620]   - Field: ‘lazy’
[10:18:31.620]   - Field: ‘state’
[10:18:31.620] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.620] - Launch lazy future ...
[10:18:31.620] Packages needed by the future expression (n = 1): ‘stats’
[10:18:31.620] Packages needed by future strategies (n = 0): <none>
[10:18:31.621] {
[10:18:31.621]     {
[10:18:31.621]         {
[10:18:31.621]             ...future.startTime <- base::Sys.time()
[10:18:31.621]             {
[10:18:31.621]                 {
[10:18:31.621]                   {
[10:18:31.621]                     {
[10:18:31.621]                       base::local({
[10:18:31.621]                         has_future <- base::requireNamespace("future", 
[10:18:31.621]                           quietly = TRUE)
[10:18:31.621]                         if (has_future) {
[10:18:31.621]                           ns <- base::getNamespace("future")
[10:18:31.621]                           version <- ns[[".package"]][["version"]]
[10:18:31.621]                           if (is.null(version)) 
[10:18:31.621]                             version <- utils::packageVersion("future")
[10:18:31.621]                         }
[10:18:31.621]                         else {
[10:18:31.621]                           version <- NULL
[10:18:31.621]                         }
[10:18:31.621]                         if (!has_future || version < "1.8.0") {
[10:18:31.621]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.621]                             "", base::R.version$version.string), 
[10:18:31.621]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.621]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.621]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.621]                               "release", "version")], collapse = " "), 
[10:18:31.621]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.621]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.621]                             info)
[10:18:31.621]                           info <- base::paste(info, collapse = "; ")
[10:18:31.621]                           if (!has_future) {
[10:18:31.621]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.621]                               info)
[10:18:31.621]                           }
[10:18:31.621]                           else {
[10:18:31.621]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.621]                               info, version)
[10:18:31.621]                           }
[10:18:31.621]                           base::stop(msg)
[10:18:31.621]                         }
[10:18:31.621]                       })
[10:18:31.621]                     }
[10:18:31.621]                     base::local({
[10:18:31.621]                       for (pkg in "stats") {
[10:18:31.621]                         base::loadNamespace(pkg)
[10:18:31.621]                         base::library(pkg, character.only = TRUE)
[10:18:31.621]                       }
[10:18:31.621]                     })
[10:18:31.621]                   }
[10:18:31.621]                   ...future.strategy.old <- future::plan("list")
[10:18:31.621]                   options(future.plan = NULL)
[10:18:31.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.621]                 }
[10:18:31.621]                 ...future.workdir <- getwd()
[10:18:31.621]             }
[10:18:31.621]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.621]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.621]         }
[10:18:31.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.621]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.621]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.621]             base::names(...future.oldOptions))
[10:18:31.621]     }
[10:18:31.621]     if (FALSE) {
[10:18:31.621]     }
[10:18:31.621]     else {
[10:18:31.621]         if (TRUE) {
[10:18:31.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.621]                 open = "w")
[10:18:31.621]         }
[10:18:31.621]         else {
[10:18:31.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.621]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.621]         }
[10:18:31.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.621]             base::sink(type = "output", split = FALSE)
[10:18:31.621]             base::close(...future.stdout)
[10:18:31.621]         }, add = TRUE)
[10:18:31.621]     }
[10:18:31.621]     ...future.frame <- base::sys.nframe()
[10:18:31.621]     ...future.conditions <- base::list()
[10:18:31.621]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.621]     if (FALSE) {
[10:18:31.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.621]     }
[10:18:31.621]     ...future.result <- base::tryCatch({
[10:18:31.621]         base::withCallingHandlers({
[10:18:31.621]             ...future.value <- base::withVisible(base::local({
[10:18:31.621]                 do.call(function(...) {
[10:18:31.621]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.621]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.621]                     ...future.globals.maxSize)) {
[10:18:31.621]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.621]                     on.exit(options(oopts), add = TRUE)
[10:18:31.621]                   }
[10:18:31.621]                   {
[10:18:31.621]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.621]                       FUN = function(jj) {
[10:18:31.621]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.621]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.621]                       })
[10:18:31.621]                   }
[10:18:31.621]                 }, args = future.call.arguments)
[10:18:31.621]             }))
[10:18:31.621]             future::FutureResult(value = ...future.value$value, 
[10:18:31.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.621]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.621]                     ...future.globalenv.names))
[10:18:31.621]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.621]         }, condition = base::local({
[10:18:31.621]             c <- base::c
[10:18:31.621]             inherits <- base::inherits
[10:18:31.621]             invokeRestart <- base::invokeRestart
[10:18:31.621]             length <- base::length
[10:18:31.621]             list <- base::list
[10:18:31.621]             seq.int <- base::seq.int
[10:18:31.621]             signalCondition <- base::signalCondition
[10:18:31.621]             sys.calls <- base::sys.calls
[10:18:31.621]             `[[` <- base::`[[`
[10:18:31.621]             `+` <- base::`+`
[10:18:31.621]             `<<-` <- base::`<<-`
[10:18:31.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.621]                   3L)]
[10:18:31.621]             }
[10:18:31.621]             function(cond) {
[10:18:31.621]                 is_error <- inherits(cond, "error")
[10:18:31.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.621]                   NULL)
[10:18:31.621]                 if (is_error) {
[10:18:31.621]                   sessionInformation <- function() {
[10:18:31.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.621]                       search = base::search(), system = base::Sys.info())
[10:18:31.621]                   }
[10:18:31.621]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.621]                     cond$call), session = sessionInformation(), 
[10:18:31.621]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.621]                   signalCondition(cond)
[10:18:31.621]                 }
[10:18:31.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.621]                 "immediateCondition"))) {
[10:18:31.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.621]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.621]                   if (TRUE && !signal) {
[10:18:31.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.621]                     {
[10:18:31.621]                       inherits <- base::inherits
[10:18:31.621]                       invokeRestart <- base::invokeRestart
[10:18:31.621]                       is.null <- base::is.null
[10:18:31.621]                       muffled <- FALSE
[10:18:31.621]                       if (inherits(cond, "message")) {
[10:18:31.621]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.621]                         if (muffled) 
[10:18:31.621]                           invokeRestart("muffleMessage")
[10:18:31.621]                       }
[10:18:31.621]                       else if (inherits(cond, "warning")) {
[10:18:31.621]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.621]                         if (muffled) 
[10:18:31.621]                           invokeRestart("muffleWarning")
[10:18:31.621]                       }
[10:18:31.621]                       else if (inherits(cond, "condition")) {
[10:18:31.621]                         if (!is.null(pattern)) {
[10:18:31.621]                           computeRestarts <- base::computeRestarts
[10:18:31.621]                           grepl <- base::grepl
[10:18:31.621]                           restarts <- computeRestarts(cond)
[10:18:31.621]                           for (restart in restarts) {
[10:18:31.621]                             name <- restart$name
[10:18:31.621]                             if (is.null(name)) 
[10:18:31.621]                               next
[10:18:31.621]                             if (!grepl(pattern, name)) 
[10:18:31.621]                               next
[10:18:31.621]                             invokeRestart(restart)
[10:18:31.621]                             muffled <- TRUE
[10:18:31.621]                             break
[10:18:31.621]                           }
[10:18:31.621]                         }
[10:18:31.621]                       }
[10:18:31.621]                       invisible(muffled)
[10:18:31.621]                     }
[10:18:31.621]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.621]                   }
[10:18:31.621]                 }
[10:18:31.621]                 else {
[10:18:31.621]                   if (TRUE) {
[10:18:31.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.621]                     {
[10:18:31.621]                       inherits <- base::inherits
[10:18:31.621]                       invokeRestart <- base::invokeRestart
[10:18:31.621]                       is.null <- base::is.null
[10:18:31.621]                       muffled <- FALSE
[10:18:31.621]                       if (inherits(cond, "message")) {
[10:18:31.621]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.621]                         if (muffled) 
[10:18:31.621]                           invokeRestart("muffleMessage")
[10:18:31.621]                       }
[10:18:31.621]                       else if (inherits(cond, "warning")) {
[10:18:31.621]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.621]                         if (muffled) 
[10:18:31.621]                           invokeRestart("muffleWarning")
[10:18:31.621]                       }
[10:18:31.621]                       else if (inherits(cond, "condition")) {
[10:18:31.621]                         if (!is.null(pattern)) {
[10:18:31.621]                           computeRestarts <- base::computeRestarts
[10:18:31.621]                           grepl <- base::grepl
[10:18:31.621]                           restarts <- computeRestarts(cond)
[10:18:31.621]                           for (restart in restarts) {
[10:18:31.621]                             name <- restart$name
[10:18:31.621]                             if (is.null(name)) 
[10:18:31.621]                               next
[10:18:31.621]                             if (!grepl(pattern, name)) 
[10:18:31.621]                               next
[10:18:31.621]                             invokeRestart(restart)
[10:18:31.621]                             muffled <- TRUE
[10:18:31.621]                             break
[10:18:31.621]                           }
[10:18:31.621]                         }
[10:18:31.621]                       }
[10:18:31.621]                       invisible(muffled)
[10:18:31.621]                     }
[10:18:31.621]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.621]                   }
[10:18:31.621]                 }
[10:18:31.621]             }
[10:18:31.621]         }))
[10:18:31.621]     }, error = function(ex) {
[10:18:31.621]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.621]                 ...future.rng), started = ...future.startTime, 
[10:18:31.621]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.621]             version = "1.8"), class = "FutureResult")
[10:18:31.621]     }, finally = {
[10:18:31.621]         if (!identical(...future.workdir, getwd())) 
[10:18:31.621]             setwd(...future.workdir)
[10:18:31.621]         {
[10:18:31.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.621]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.621]             }
[10:18:31.621]             base::options(...future.oldOptions)
[10:18:31.621]             if (.Platform$OS.type == "windows") {
[10:18:31.621]                 old_names <- names(...future.oldEnvVars)
[10:18:31.621]                 envs <- base::Sys.getenv()
[10:18:31.621]                 names <- names(envs)
[10:18:31.621]                 common <- intersect(names, old_names)
[10:18:31.621]                 added <- setdiff(names, old_names)
[10:18:31.621]                 removed <- setdiff(old_names, names)
[10:18:31.621]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.621]                   envs[common]]
[10:18:31.621]                 NAMES <- toupper(changed)
[10:18:31.621]                 args <- list()
[10:18:31.621]                 for (kk in seq_along(NAMES)) {
[10:18:31.621]                   name <- changed[[kk]]
[10:18:31.621]                   NAME <- NAMES[[kk]]
[10:18:31.621]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.621]                     next
[10:18:31.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.621]                 }
[10:18:31.621]                 NAMES <- toupper(added)
[10:18:31.621]                 for (kk in seq_along(NAMES)) {
[10:18:31.621]                   name <- added[[kk]]
[10:18:31.621]                   NAME <- NAMES[[kk]]
[10:18:31.621]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.621]                     next
[10:18:31.621]                   args[[name]] <- ""
[10:18:31.621]                 }
[10:18:31.621]                 NAMES <- toupper(removed)
[10:18:31.621]                 for (kk in seq_along(NAMES)) {
[10:18:31.621]                   name <- removed[[kk]]
[10:18:31.621]                   NAME <- NAMES[[kk]]
[10:18:31.621]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.621]                     next
[10:18:31.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.621]                 }
[10:18:31.621]                 if (length(args) > 0) 
[10:18:31.621]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.621]             }
[10:18:31.621]             else {
[10:18:31.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.621]             }
[10:18:31.621]             {
[10:18:31.621]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.621]                   0L) {
[10:18:31.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.621]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.621]                   base::options(opts)
[10:18:31.621]                 }
[10:18:31.621]                 {
[10:18:31.621]                   {
[10:18:31.621]                     NULL
[10:18:31.621]                     RNGkind("Mersenne-Twister")
[10:18:31.621]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.621]                       inherits = FALSE)
[10:18:31.621]                   }
[10:18:31.621]                   options(future.plan = NULL)
[10:18:31.621]                   if (is.na(NA_character_)) 
[10:18:31.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.621]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.621]                     .init = FALSE)
[10:18:31.621]                 }
[10:18:31.621]             }
[10:18:31.621]         }
[10:18:31.621]     })
[10:18:31.621]     if (TRUE) {
[10:18:31.621]         base::sink(type = "output", split = FALSE)
[10:18:31.621]         if (TRUE) {
[10:18:31.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.621]         }
[10:18:31.621]         else {
[10:18:31.621]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.621]         }
[10:18:31.621]         base::close(...future.stdout)
[10:18:31.621]         ...future.stdout <- NULL
[10:18:31.621]     }
[10:18:31.621]     ...future.result$conditions <- ...future.conditions
[10:18:31.621]     ...future.result$finished <- base::Sys.time()
[10:18:31.621]     ...future.result
[10:18:31.621] }
[10:18:31.622] assign_globals() ...
[10:18:31.622] List of 5
[10:18:31.622]  $ ...future.FUN            :function (x, ...)  
[10:18:31.622]  $ future.call.arguments    :List of 1
[10:18:31.622]   ..$ singular.ok: logi FALSE
[10:18:31.622]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.622]  $ ...future.elements_ii    :List of 3
[10:18:31.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.622]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.622]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.622]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.622]  $ ...future.seeds_ii       : NULL
[10:18:31.622]  $ ...future.globals.maxSize: NULL
[10:18:31.622]  - attr(*, "where")=List of 5
[10:18:31.622]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.622]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.622]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.622]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.622]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.622]  - attr(*, "resolved")= logi FALSE
[10:18:31.622]  - attr(*, "total_size")= num 19977
[10:18:31.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.622]  - attr(*, "already-done")= logi TRUE
[10:18:31.633] - reassign environment for ‘...future.FUN’
[10:18:31.633] - copied ‘...future.FUN’ to environment
[10:18:31.633] - copied ‘future.call.arguments’ to environment
[10:18:31.633] - copied ‘...future.elements_ii’ to environment
[10:18:31.634] - copied ‘...future.seeds_ii’ to environment
[10:18:31.634] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.634] assign_globals() ... done
[10:18:31.634] plan(): Setting new future strategy stack:
[10:18:31.634] List of future strategies:
[10:18:31.634] 1. sequential:
[10:18:31.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.634]    - tweaked: FALSE
[10:18:31.634]    - call: NULL
[10:18:31.635] plan(): nbrOfWorkers() = 1
[10:18:31.638] plan(): Setting new future strategy stack:
[10:18:31.638] List of future strategies:
[10:18:31.638] 1. sequential:
[10:18:31.638]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.638]    - tweaked: FALSE
[10:18:31.638]    - call: plan(strategy)
[10:18:31.638] plan(): nbrOfWorkers() = 1
[10:18:31.638] SequentialFuture started (and completed)
[10:18:31.638] - Launch lazy future ... done
[10:18:31.639] run() for ‘SequentialFuture’ ... done
[10:18:31.639] Created future:
[10:18:31.639] SequentialFuture:
[10:18:31.639] Label: ‘future_by-1’
[10:18:31.639] Expression:
[10:18:31.639] {
[10:18:31.639]     do.call(function(...) {
[10:18:31.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.639]             on.exit(options(oopts), add = TRUE)
[10:18:31.639]         }
[10:18:31.639]         {
[10:18:31.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.639]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.639]             })
[10:18:31.639]         }
[10:18:31.639]     }, args = future.call.arguments)
[10:18:31.639] }
[10:18:31.639] Lazy evaluation: FALSE
[10:18:31.639] Asynchronous evaluation: FALSE
[10:18:31.639] Local evaluation: TRUE
[10:18:31.639] Environment: R_GlobalEnv
[10:18:31.639] Capture standard output: TRUE
[10:18:31.639] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.639] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.639] Packages: 1 packages (‘stats’)
[10:18:31.639] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.639] Resolved: TRUE
[10:18:31.639] Value: 77.05 KiB of class ‘list’
[10:18:31.639] Early signaling: FALSE
[10:18:31.639] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.639] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.640] Chunk #1 of 1 ... DONE
[10:18:31.640] Launching 1 futures (chunks) ... DONE
[10:18:31.640] Resolving 1 futures (chunks) ...
[10:18:31.640] resolve() on list ...
[10:18:31.640]  recursive: 0
[10:18:31.640]  length: 1
[10:18:31.640] 
[10:18:31.641] resolved() for ‘SequentialFuture’ ...
[10:18:31.641] - state: ‘finished’
[10:18:31.641] - run: TRUE
[10:18:31.641] - result: ‘FutureResult’
[10:18:31.641] resolved() for ‘SequentialFuture’ ... done
[10:18:31.641] Future #1
[10:18:31.641] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.641] - nx: 1
[10:18:31.641] - relay: TRUE
[10:18:31.641] - stdout: TRUE
[10:18:31.641] - signal: TRUE
[10:18:31.642] - resignal: FALSE
[10:18:31.642] - force: TRUE
[10:18:31.642] - relayed: [n=1] FALSE
[10:18:31.642] - queued futures: [n=1] FALSE
[10:18:31.642]  - until=1
[10:18:31.642]  - relaying element #1
[10:18:31.642] - relayed: [n=1] TRUE
[10:18:31.642] - queued futures: [n=1] TRUE
[10:18:31.642] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.643]  length: 0 (resolved future 1)
[10:18:31.643] Relaying remaining futures
[10:18:31.643] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.643] - nx: 1
[10:18:31.643] - relay: TRUE
[10:18:31.643] - stdout: TRUE
[10:18:31.643] - signal: TRUE
[10:18:31.643] - resignal: FALSE
[10:18:31.643] - force: TRUE
[10:18:31.643] - relayed: [n=1] TRUE
[10:18:31.643] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.643] - relayed: [n=1] TRUE
[10:18:31.644] - queued futures: [n=1] TRUE
[10:18:31.644] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.644] resolve() on list ... DONE
[10:18:31.644]  - Number of value chunks collected: 1
[10:18:31.644] Resolving 1 futures (chunks) ... DONE
[10:18:31.644] Reducing values from 1 chunks ...
[10:18:31.644]  - Number of values collected after concatenation: 3
[10:18:31.644]  - Number of values expected: 3
[10:18:31.644] Reducing values from 1 chunks ... DONE
[10:18:31.644] future_lapply() ... DONE
[10:18:31.644] future_by_internal() ... DONE
[10:18:31.650] future_by_internal() ...
[10:18:31.650] future_lapply() ...
[10:18:31.651] Number of chunks: 1
[10:18:31.651] getGlobalsAndPackagesXApply() ...
[10:18:31.651]  - future.globals: TRUE
[10:18:31.652] getGlobalsAndPackages() ...
[10:18:31.652] Searching for globals...
[10:18:31.654] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:31.654] Searching for globals ... DONE
[10:18:31.654] Resolving globals: FALSE
[10:18:31.654] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:18:31.655] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:18:31.655] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:31.655] - packages: [1] ‘stats’
[10:18:31.655] getGlobalsAndPackages() ... DONE
[10:18:31.655]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:31.655]  - needed namespaces: [n=1] ‘stats’
[10:18:31.655] Finding globals ... DONE
[10:18:31.656]  - use_args: TRUE
[10:18:31.656]  - Getting '...' globals ...
[10:18:31.656] resolve() on list ...
[10:18:31.656]  recursive: 0
[10:18:31.656]  length: 1
[10:18:31.656]  elements: ‘...’
[10:18:31.656]  length: 0 (resolved future 1)
[10:18:31.656] resolve() on list ... DONE
[10:18:31.656]    - '...' content: [n=0] 
[10:18:31.657] List of 1
[10:18:31.657]  $ ...: list()
[10:18:31.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.657]  - attr(*, "where")=List of 1
[10:18:31.657]   ..$ ...:<environment: 0x55844ab0e438> 
[10:18:31.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.657]  - attr(*, "resolved")= logi TRUE
[10:18:31.657]  - attr(*, "total_size")= num NA
[10:18:31.659]  - Getting '...' globals ... DONE
[10:18:31.659] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:18:31.659] List of 4
[10:18:31.659]  $ ...future.FUN:function (x)  
[10:18:31.659]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:31.659]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.659]  $ ...          : list()
[10:18:31.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.659]  - attr(*, "where")=List of 4
[10:18:31.659]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.659]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:18:31.659]   ..$ wool         :<environment: R_EmptyEnv> 
[10:18:31.659]   ..$ ...          :<environment: 0x55844ab0e438> 
[10:18:31.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.659]  - attr(*, "resolved")= logi FALSE
[10:18:31.659]  - attr(*, "total_size")= num 18867
[10:18:31.663] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:31.663] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.663] Number of futures (= number of chunks): 1
[10:18:31.663] Launching 1 futures (chunks) ...
[10:18:31.664] Chunk #1 of 1 ...
[10:18:31.664]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.664] getGlobalsAndPackages() ...
[10:18:31.664] Searching for globals...
[10:18:31.664] 
[10:18:31.664] Searching for globals ... DONE
[10:18:31.665] - globals: [0] <none>
[10:18:31.665] getGlobalsAndPackages() ... DONE
[10:18:31.665]    + additional globals found: [n=0] 
[10:18:31.665]    + additional namespaces needed: [n=0] 
[10:18:31.665]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.665]  - seeds: <none>
[10:18:31.665]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.665] getGlobalsAndPackages() ...
[10:18:31.665] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.665] Resolving globals: FALSE
[10:18:31.665] Tweak future expression to call with '...' arguments ...
[10:18:31.666] {
[10:18:31.666]     do.call(function(...) {
[10:18:31.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.666]             on.exit(options(oopts), add = TRUE)
[10:18:31.666]         }
[10:18:31.666]         {
[10:18:31.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.666]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.666]             })
[10:18:31.666]         }
[10:18:31.666]     }, args = future.call.arguments)
[10:18:31.666] }
[10:18:31.666] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.666] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.666] 
[10:18:31.666] getGlobalsAndPackages() ... DONE
[10:18:31.667] run() for ‘Future’ ...
[10:18:31.667] - state: ‘created’
[10:18:31.667] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:31.667] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.667]   - Field: ‘label’
[10:18:31.667]   - Field: ‘local’
[10:18:31.668]   - Field: ‘owner’
[10:18:31.668]   - Field: ‘envir’
[10:18:31.668]   - Field: ‘packages’
[10:18:31.668]   - Field: ‘gc’
[10:18:31.668]   - Field: ‘conditions’
[10:18:31.668]   - Field: ‘expr’
[10:18:31.668]   - Field: ‘uuid’
[10:18:31.668]   - Field: ‘seed’
[10:18:31.668]   - Field: ‘version’
[10:18:31.668]   - Field: ‘result’
[10:18:31.668]   - Field: ‘asynchronous’
[10:18:31.668]   - Field: ‘calls’
[10:18:31.669]   - Field: ‘globals’
[10:18:31.669]   - Field: ‘stdout’
[10:18:31.669]   - Field: ‘earlySignal’
[10:18:31.669]   - Field: ‘lazy’
[10:18:31.669]   - Field: ‘state’
[10:18:31.669] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.671] - Launch lazy future ...
[10:18:31.671] Packages needed by the future expression (n = 1): ‘stats’
[10:18:31.671] Packages needed by future strategies (n = 0): <none>
[10:18:31.672] {
[10:18:31.672]     {
[10:18:31.672]         {
[10:18:31.672]             ...future.startTime <- base::Sys.time()
[10:18:31.672]             {
[10:18:31.672]                 {
[10:18:31.672]                   {
[10:18:31.672]                     {
[10:18:31.672]                       base::local({
[10:18:31.672]                         has_future <- base::requireNamespace("future", 
[10:18:31.672]                           quietly = TRUE)
[10:18:31.672]                         if (has_future) {
[10:18:31.672]                           ns <- base::getNamespace("future")
[10:18:31.672]                           version <- ns[[".package"]][["version"]]
[10:18:31.672]                           if (is.null(version)) 
[10:18:31.672]                             version <- utils::packageVersion("future")
[10:18:31.672]                         }
[10:18:31.672]                         else {
[10:18:31.672]                           version <- NULL
[10:18:31.672]                         }
[10:18:31.672]                         if (!has_future || version < "1.8.0") {
[10:18:31.672]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.672]                             "", base::R.version$version.string), 
[10:18:31.672]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.672]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.672]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.672]                               "release", "version")], collapse = " "), 
[10:18:31.672]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.672]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.672]                             info)
[10:18:31.672]                           info <- base::paste(info, collapse = "; ")
[10:18:31.672]                           if (!has_future) {
[10:18:31.672]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.672]                               info)
[10:18:31.672]                           }
[10:18:31.672]                           else {
[10:18:31.672]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.672]                               info, version)
[10:18:31.672]                           }
[10:18:31.672]                           base::stop(msg)
[10:18:31.672]                         }
[10:18:31.672]                       })
[10:18:31.672]                     }
[10:18:31.672]                     base::local({
[10:18:31.672]                       for (pkg in "stats") {
[10:18:31.672]                         base::loadNamespace(pkg)
[10:18:31.672]                         base::library(pkg, character.only = TRUE)
[10:18:31.672]                       }
[10:18:31.672]                     })
[10:18:31.672]                   }
[10:18:31.672]                   ...future.strategy.old <- future::plan("list")
[10:18:31.672]                   options(future.plan = NULL)
[10:18:31.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.672]                 }
[10:18:31.672]                 ...future.workdir <- getwd()
[10:18:31.672]             }
[10:18:31.672]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.672]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.672]         }
[10:18:31.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.672]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.672]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.672]             base::names(...future.oldOptions))
[10:18:31.672]     }
[10:18:31.672]     if (FALSE) {
[10:18:31.672]     }
[10:18:31.672]     else {
[10:18:31.672]         if (TRUE) {
[10:18:31.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.672]                 open = "w")
[10:18:31.672]         }
[10:18:31.672]         else {
[10:18:31.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.672]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.672]         }
[10:18:31.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.672]             base::sink(type = "output", split = FALSE)
[10:18:31.672]             base::close(...future.stdout)
[10:18:31.672]         }, add = TRUE)
[10:18:31.672]     }
[10:18:31.672]     ...future.frame <- base::sys.nframe()
[10:18:31.672]     ...future.conditions <- base::list()
[10:18:31.672]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.672]     if (FALSE) {
[10:18:31.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.672]     }
[10:18:31.672]     ...future.result <- base::tryCatch({
[10:18:31.672]         base::withCallingHandlers({
[10:18:31.672]             ...future.value <- base::withVisible(base::local({
[10:18:31.672]                 do.call(function(...) {
[10:18:31.672]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.672]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.672]                     ...future.globals.maxSize)) {
[10:18:31.672]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.672]                     on.exit(options(oopts), add = TRUE)
[10:18:31.672]                   }
[10:18:31.672]                   {
[10:18:31.672]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.672]                       FUN = function(jj) {
[10:18:31.672]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.672]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.672]                       })
[10:18:31.672]                   }
[10:18:31.672]                 }, args = future.call.arguments)
[10:18:31.672]             }))
[10:18:31.672]             future::FutureResult(value = ...future.value$value, 
[10:18:31.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.672]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.672]                     ...future.globalenv.names))
[10:18:31.672]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.672]         }, condition = base::local({
[10:18:31.672]             c <- base::c
[10:18:31.672]             inherits <- base::inherits
[10:18:31.672]             invokeRestart <- base::invokeRestart
[10:18:31.672]             length <- base::length
[10:18:31.672]             list <- base::list
[10:18:31.672]             seq.int <- base::seq.int
[10:18:31.672]             signalCondition <- base::signalCondition
[10:18:31.672]             sys.calls <- base::sys.calls
[10:18:31.672]             `[[` <- base::`[[`
[10:18:31.672]             `+` <- base::`+`
[10:18:31.672]             `<<-` <- base::`<<-`
[10:18:31.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.672]                   3L)]
[10:18:31.672]             }
[10:18:31.672]             function(cond) {
[10:18:31.672]                 is_error <- inherits(cond, "error")
[10:18:31.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.672]                   NULL)
[10:18:31.672]                 if (is_error) {
[10:18:31.672]                   sessionInformation <- function() {
[10:18:31.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.672]                       search = base::search(), system = base::Sys.info())
[10:18:31.672]                   }
[10:18:31.672]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.672]                     cond$call), session = sessionInformation(), 
[10:18:31.672]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.672]                   signalCondition(cond)
[10:18:31.672]                 }
[10:18:31.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.672]                 "immediateCondition"))) {
[10:18:31.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.672]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.672]                   if (TRUE && !signal) {
[10:18:31.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.672]                     {
[10:18:31.672]                       inherits <- base::inherits
[10:18:31.672]                       invokeRestart <- base::invokeRestart
[10:18:31.672]                       is.null <- base::is.null
[10:18:31.672]                       muffled <- FALSE
[10:18:31.672]                       if (inherits(cond, "message")) {
[10:18:31.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.672]                         if (muffled) 
[10:18:31.672]                           invokeRestart("muffleMessage")
[10:18:31.672]                       }
[10:18:31.672]                       else if (inherits(cond, "warning")) {
[10:18:31.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.672]                         if (muffled) 
[10:18:31.672]                           invokeRestart("muffleWarning")
[10:18:31.672]                       }
[10:18:31.672]                       else if (inherits(cond, "condition")) {
[10:18:31.672]                         if (!is.null(pattern)) {
[10:18:31.672]                           computeRestarts <- base::computeRestarts
[10:18:31.672]                           grepl <- base::grepl
[10:18:31.672]                           restarts <- computeRestarts(cond)
[10:18:31.672]                           for (restart in restarts) {
[10:18:31.672]                             name <- restart$name
[10:18:31.672]                             if (is.null(name)) 
[10:18:31.672]                               next
[10:18:31.672]                             if (!grepl(pattern, name)) 
[10:18:31.672]                               next
[10:18:31.672]                             invokeRestart(restart)
[10:18:31.672]                             muffled <- TRUE
[10:18:31.672]                             break
[10:18:31.672]                           }
[10:18:31.672]                         }
[10:18:31.672]                       }
[10:18:31.672]                       invisible(muffled)
[10:18:31.672]                     }
[10:18:31.672]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.672]                   }
[10:18:31.672]                 }
[10:18:31.672]                 else {
[10:18:31.672]                   if (TRUE) {
[10:18:31.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.672]                     {
[10:18:31.672]                       inherits <- base::inherits
[10:18:31.672]                       invokeRestart <- base::invokeRestart
[10:18:31.672]                       is.null <- base::is.null
[10:18:31.672]                       muffled <- FALSE
[10:18:31.672]                       if (inherits(cond, "message")) {
[10:18:31.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.672]                         if (muffled) 
[10:18:31.672]                           invokeRestart("muffleMessage")
[10:18:31.672]                       }
[10:18:31.672]                       else if (inherits(cond, "warning")) {
[10:18:31.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.672]                         if (muffled) 
[10:18:31.672]                           invokeRestart("muffleWarning")
[10:18:31.672]                       }
[10:18:31.672]                       else if (inherits(cond, "condition")) {
[10:18:31.672]                         if (!is.null(pattern)) {
[10:18:31.672]                           computeRestarts <- base::computeRestarts
[10:18:31.672]                           grepl <- base::grepl
[10:18:31.672]                           restarts <- computeRestarts(cond)
[10:18:31.672]                           for (restart in restarts) {
[10:18:31.672]                             name <- restart$name
[10:18:31.672]                             if (is.null(name)) 
[10:18:31.672]                               next
[10:18:31.672]                             if (!grepl(pattern, name)) 
[10:18:31.672]                               next
[10:18:31.672]                             invokeRestart(restart)
[10:18:31.672]                             muffled <- TRUE
[10:18:31.672]                             break
[10:18:31.672]                           }
[10:18:31.672]                         }
[10:18:31.672]                       }
[10:18:31.672]                       invisible(muffled)
[10:18:31.672]                     }
[10:18:31.672]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.672]                   }
[10:18:31.672]                 }
[10:18:31.672]             }
[10:18:31.672]         }))
[10:18:31.672]     }, error = function(ex) {
[10:18:31.672]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.672]                 ...future.rng), started = ...future.startTime, 
[10:18:31.672]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.672]             version = "1.8"), class = "FutureResult")
[10:18:31.672]     }, finally = {
[10:18:31.672]         if (!identical(...future.workdir, getwd())) 
[10:18:31.672]             setwd(...future.workdir)
[10:18:31.672]         {
[10:18:31.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.672]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.672]             }
[10:18:31.672]             base::options(...future.oldOptions)
[10:18:31.672]             if (.Platform$OS.type == "windows") {
[10:18:31.672]                 old_names <- names(...future.oldEnvVars)
[10:18:31.672]                 envs <- base::Sys.getenv()
[10:18:31.672]                 names <- names(envs)
[10:18:31.672]                 common <- intersect(names, old_names)
[10:18:31.672]                 added <- setdiff(names, old_names)
[10:18:31.672]                 removed <- setdiff(old_names, names)
[10:18:31.672]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.672]                   envs[common]]
[10:18:31.672]                 NAMES <- toupper(changed)
[10:18:31.672]                 args <- list()
[10:18:31.672]                 for (kk in seq_along(NAMES)) {
[10:18:31.672]                   name <- changed[[kk]]
[10:18:31.672]                   NAME <- NAMES[[kk]]
[10:18:31.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.672]                     next
[10:18:31.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.672]                 }
[10:18:31.672]                 NAMES <- toupper(added)
[10:18:31.672]                 for (kk in seq_along(NAMES)) {
[10:18:31.672]                   name <- added[[kk]]
[10:18:31.672]                   NAME <- NAMES[[kk]]
[10:18:31.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.672]                     next
[10:18:31.672]                   args[[name]] <- ""
[10:18:31.672]                 }
[10:18:31.672]                 NAMES <- toupper(removed)
[10:18:31.672]                 for (kk in seq_along(NAMES)) {
[10:18:31.672]                   name <- removed[[kk]]
[10:18:31.672]                   NAME <- NAMES[[kk]]
[10:18:31.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.672]                     next
[10:18:31.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.672]                 }
[10:18:31.672]                 if (length(args) > 0) 
[10:18:31.672]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.672]             }
[10:18:31.672]             else {
[10:18:31.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.672]             }
[10:18:31.672]             {
[10:18:31.672]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.672]                   0L) {
[10:18:31.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.672]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.672]                   base::options(opts)
[10:18:31.672]                 }
[10:18:31.672]                 {
[10:18:31.672]                   {
[10:18:31.672]                     NULL
[10:18:31.672]                     RNGkind("Mersenne-Twister")
[10:18:31.672]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.672]                       inherits = FALSE)
[10:18:31.672]                   }
[10:18:31.672]                   options(future.plan = NULL)
[10:18:31.672]                   if (is.na(NA_character_)) 
[10:18:31.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.672]                     .init = FALSE)
[10:18:31.672]                 }
[10:18:31.672]             }
[10:18:31.672]         }
[10:18:31.672]     })
[10:18:31.672]     if (TRUE) {
[10:18:31.672]         base::sink(type = "output", split = FALSE)
[10:18:31.672]         if (TRUE) {
[10:18:31.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.672]         }
[10:18:31.672]         else {
[10:18:31.672]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.672]         }
[10:18:31.672]         base::close(...future.stdout)
[10:18:31.672]         ...future.stdout <- NULL
[10:18:31.672]     }
[10:18:31.672]     ...future.result$conditions <- ...future.conditions
[10:18:31.672]     ...future.result$finished <- base::Sys.time()
[10:18:31.672]     ...future.result
[10:18:31.672] }
[10:18:31.674] assign_globals() ...
[10:18:31.674] List of 7
[10:18:31.674]  $ ...future.FUN            :function (x)  
[10:18:31.674]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:31.674]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.674]  $ future.call.arguments    : list()
[10:18:31.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.674]  $ ...future.elements_ii    :List of 3
[10:18:31.674]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.674]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.674]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.674]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.674]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.674]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.674]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.674]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.674]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.674]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.674]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.674]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.674]  $ ...future.seeds_ii       : NULL
[10:18:31.674]  $ ...future.globals.maxSize: NULL
[10:18:31.674]  - attr(*, "where")=List of 7
[10:18:31.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.674]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:18:31.674]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:18:31.674]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.674]  - attr(*, "resolved")= logi FALSE
[10:18:31.674]  - attr(*, "total_size")= num 18867
[10:18:31.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.674]  - attr(*, "already-done")= logi TRUE
[10:18:31.683] - reassign environment for ‘...future.FUN’
[10:18:31.684] - copied ‘...future.FUN’ to environment
[10:18:31.684] - copied ‘breaks’ to environment
[10:18:31.684] - copied ‘wool’ to environment
[10:18:31.684] - copied ‘future.call.arguments’ to environment
[10:18:31.684] - copied ‘...future.elements_ii’ to environment
[10:18:31.684] - copied ‘...future.seeds_ii’ to environment
[10:18:31.684] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.684] assign_globals() ... done
[10:18:31.685] plan(): Setting new future strategy stack:
[10:18:31.685] List of future strategies:
[10:18:31.685] 1. sequential:
[10:18:31.685]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.685]    - tweaked: FALSE
[10:18:31.685]    - call: NULL
[10:18:31.685] plan(): nbrOfWorkers() = 1
[10:18:31.688] plan(): Setting new future strategy stack:
[10:18:31.688] List of future strategies:
[10:18:31.688] 1. sequential:
[10:18:31.688]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.688]    - tweaked: FALSE
[10:18:31.688]    - call: plan(strategy)
[10:18:31.689] plan(): nbrOfWorkers() = 1
[10:18:31.689] SequentialFuture started (and completed)
[10:18:31.689] - Launch lazy future ... done
[10:18:31.689] run() for ‘SequentialFuture’ ... done
[10:18:31.689] Created future:
[10:18:31.689] SequentialFuture:
[10:18:31.689] Label: ‘future_by-1’
[10:18:31.689] Expression:
[10:18:31.689] {
[10:18:31.689]     do.call(function(...) {
[10:18:31.689]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.689]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.689]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.689]             on.exit(options(oopts), add = TRUE)
[10:18:31.689]         }
[10:18:31.689]         {
[10:18:31.689]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.689]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.689]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.689]             })
[10:18:31.689]         }
[10:18:31.689]     }, args = future.call.arguments)
[10:18:31.689] }
[10:18:31.689] Lazy evaluation: FALSE
[10:18:31.689] Asynchronous evaluation: FALSE
[10:18:31.689] Local evaluation: TRUE
[10:18:31.689] Environment: 0x558449771ae8
[10:18:31.689] Capture standard output: TRUE
[10:18:31.689] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.689] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[10:18:31.689] Packages: 1 packages (‘stats’)
[10:18:31.689] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.689] Resolved: TRUE
[10:18:31.689] Value: 78.42 KiB of class ‘list’
[10:18:31.689] Early signaling: FALSE
[10:18:31.689] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.689] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.691] Chunk #1 of 1 ... DONE
[10:18:31.691] Launching 1 futures (chunks) ... DONE
[10:18:31.691] Resolving 1 futures (chunks) ...
[10:18:31.691] resolve() on list ...
[10:18:31.691]  recursive: 0
[10:18:31.691]  length: 1
[10:18:31.691] 
[10:18:31.691] resolved() for ‘SequentialFuture’ ...
[10:18:31.691] - state: ‘finished’
[10:18:31.691] - run: TRUE
[10:18:31.691] - result: ‘FutureResult’
[10:18:31.692] resolved() for ‘SequentialFuture’ ... done
[10:18:31.692] Future #1
[10:18:31.692] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.693] - nx: 1
[10:18:31.693] - relay: TRUE
[10:18:31.694] - stdout: TRUE
[10:18:31.694] - signal: TRUE
[10:18:31.694] - resignal: FALSE
[10:18:31.694] - force: TRUE
[10:18:31.694] - relayed: [n=1] FALSE
[10:18:31.694] - queued futures: [n=1] FALSE
[10:18:31.694]  - until=1
[10:18:31.694]  - relaying element #1
[10:18:31.694] - relayed: [n=1] TRUE
[10:18:31.695] - queued futures: [n=1] TRUE
[10:18:31.695] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.695]  length: 0 (resolved future 1)
[10:18:31.695] Relaying remaining futures
[10:18:31.695] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.695] - nx: 1
[10:18:31.695] - relay: TRUE
[10:18:31.695] - stdout: TRUE
[10:18:31.695] - signal: TRUE
[10:18:31.695] - resignal: FALSE
[10:18:31.695] - force: TRUE
[10:18:31.696] - relayed: [n=1] TRUE
[10:18:31.696] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.696] - relayed: [n=1] TRUE
[10:18:31.696] - queued futures: [n=1] TRUE
[10:18:31.696] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.696] resolve() on list ... DONE
[10:18:31.696]  - Number of value chunks collected: 1
[10:18:31.696] Resolving 1 futures (chunks) ... DONE
[10:18:31.696] Reducing values from 1 chunks ...
[10:18:31.697]  - Number of values collected after concatenation: 3
[10:18:31.697]  - Number of values expected: 3
[10:18:31.697] Reducing values from 1 chunks ... DONE
[10:18:31.697] future_lapply() ... DONE
[10:18:31.697] future_by_internal() ... DONE
[10:18:31.697] future_by_internal() ...
[10:18:31.698] future_lapply() ...
[10:18:31.698] Number of chunks: 1
[10:18:31.698] getGlobalsAndPackagesXApply() ...
[10:18:31.698]  - future.globals: TRUE
[10:18:31.699] getGlobalsAndPackages() ...
[10:18:31.699] Searching for globals...
[10:18:31.700] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.700] Searching for globals ... DONE
[10:18:31.700] Resolving globals: FALSE
[10:18:31.700] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.701] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.701] - globals: [1] ‘FUN’
[10:18:31.701] 
[10:18:31.701] getGlobalsAndPackages() ... DONE
[10:18:31.701]  - globals found/used: [n=1] ‘FUN’
[10:18:31.701]  - needed namespaces: [n=0] 
[10:18:31.701] Finding globals ... DONE
[10:18:31.701]  - use_args: TRUE
[10:18:31.701]  - Getting '...' globals ...
[10:18:31.702] resolve() on list ...
[10:18:31.702]  recursive: 0
[10:18:31.702]  length: 1
[10:18:31.702]  elements: ‘...’
[10:18:31.702]  length: 0 (resolved future 1)
[10:18:31.702] resolve() on list ... DONE
[10:18:31.702]    - '...' content: [n=0] 
[10:18:31.702] List of 1
[10:18:31.702]  $ ...: list()
[10:18:31.702]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.702]  - attr(*, "where")=List of 1
[10:18:31.702]   ..$ ...:<environment: 0x55844a7398c0> 
[10:18:31.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.702]  - attr(*, "resolved")= logi TRUE
[10:18:31.702]  - attr(*, "total_size")= num NA
[10:18:31.705]  - Getting '...' globals ... DONE
[10:18:31.705] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.705] List of 2
[10:18:31.705]  $ ...future.FUN:function (object, ...)  
[10:18:31.705]  $ ...          : list()
[10:18:31.705]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.705]  - attr(*, "where")=List of 2
[10:18:31.705]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.705]   ..$ ...          :<environment: 0x55844a7398c0> 
[10:18:31.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.705]  - attr(*, "resolved")= logi FALSE
[10:18:31.705]  - attr(*, "total_size")= num 19278
[10:18:31.707] Packages to be attached in all futures: [n=0] 
[10:18:31.708] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.708] Number of futures (= number of chunks): 1
[10:18:31.708] Launching 1 futures (chunks) ...
[10:18:31.708] Chunk #1 of 1 ...
[10:18:31.708]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.708] getGlobalsAndPackages() ...
[10:18:31.708] Searching for globals...
[10:18:31.709] 
[10:18:31.709] Searching for globals ... DONE
[10:18:31.709] - globals: [0] <none>
[10:18:31.709] getGlobalsAndPackages() ... DONE
[10:18:31.709]    + additional globals found: [n=0] 
[10:18:31.709]    + additional namespaces needed: [n=0] 
[10:18:31.709]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.709]  - seeds: <none>
[10:18:31.709]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.709] getGlobalsAndPackages() ...
[10:18:31.710] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.710] Resolving globals: FALSE
[10:18:31.710] Tweak future expression to call with '...' arguments ...
[10:18:31.710] {
[10:18:31.710]     do.call(function(...) {
[10:18:31.710]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.710]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.710]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.710]             on.exit(options(oopts), add = TRUE)
[10:18:31.710]         }
[10:18:31.710]         {
[10:18:31.710]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.710]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.710]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.710]             })
[10:18:31.710]         }
[10:18:31.710]     }, args = future.call.arguments)
[10:18:31.710] }
[10:18:31.710] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.710] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.711] 
[10:18:31.711] getGlobalsAndPackages() ... DONE
[10:18:31.711] run() for ‘Future’ ...
[10:18:31.711] - state: ‘created’
[10:18:31.711] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:31.711] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.712]   - Field: ‘label’
[10:18:31.712]   - Field: ‘local’
[10:18:31.712]   - Field: ‘owner’
[10:18:31.712]   - Field: ‘envir’
[10:18:31.712]   - Field: ‘packages’
[10:18:31.712]   - Field: ‘gc’
[10:18:31.712]   - Field: ‘conditions’
[10:18:31.714]   - Field: ‘expr’
[10:18:31.714]   - Field: ‘uuid’
[10:18:31.714]   - Field: ‘seed’
[10:18:31.714]   - Field: ‘version’
[10:18:31.714]   - Field: ‘result’
[10:18:31.715]   - Field: ‘asynchronous’
[10:18:31.715]   - Field: ‘calls’
[10:18:31.715]   - Field: ‘globals’
[10:18:31.715]   - Field: ‘stdout’
[10:18:31.715]   - Field: ‘earlySignal’
[10:18:31.715]   - Field: ‘lazy’
[10:18:31.715]   - Field: ‘state’
[10:18:31.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.715] - Launch lazy future ...
[10:18:31.716] Packages needed by the future expression (n = 0): <none>
[10:18:31.716] Packages needed by future strategies (n = 0): <none>
[10:18:31.716] {
[10:18:31.716]     {
[10:18:31.716]         {
[10:18:31.716]             ...future.startTime <- base::Sys.time()
[10:18:31.716]             {
[10:18:31.716]                 {
[10:18:31.716]                   {
[10:18:31.716]                     base::local({
[10:18:31.716]                       has_future <- base::requireNamespace("future", 
[10:18:31.716]                         quietly = TRUE)
[10:18:31.716]                       if (has_future) {
[10:18:31.716]                         ns <- base::getNamespace("future")
[10:18:31.716]                         version <- ns[[".package"]][["version"]]
[10:18:31.716]                         if (is.null(version)) 
[10:18:31.716]                           version <- utils::packageVersion("future")
[10:18:31.716]                       }
[10:18:31.716]                       else {
[10:18:31.716]                         version <- NULL
[10:18:31.716]                       }
[10:18:31.716]                       if (!has_future || version < "1.8.0") {
[10:18:31.716]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.716]                           "", base::R.version$version.string), 
[10:18:31.716]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.716]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.716]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.716]                             "release", "version")], collapse = " "), 
[10:18:31.716]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.716]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.716]                           info)
[10:18:31.716]                         info <- base::paste(info, collapse = "; ")
[10:18:31.716]                         if (!has_future) {
[10:18:31.716]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.716]                             info)
[10:18:31.716]                         }
[10:18:31.716]                         else {
[10:18:31.716]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.716]                             info, version)
[10:18:31.716]                         }
[10:18:31.716]                         base::stop(msg)
[10:18:31.716]                       }
[10:18:31.716]                     })
[10:18:31.716]                   }
[10:18:31.716]                   ...future.strategy.old <- future::plan("list")
[10:18:31.716]                   options(future.plan = NULL)
[10:18:31.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.716]                 }
[10:18:31.716]                 ...future.workdir <- getwd()
[10:18:31.716]             }
[10:18:31.716]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.716]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.716]         }
[10:18:31.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.716]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.716]             base::names(...future.oldOptions))
[10:18:31.716]     }
[10:18:31.716]     if (FALSE) {
[10:18:31.716]     }
[10:18:31.716]     else {
[10:18:31.716]         if (TRUE) {
[10:18:31.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.716]                 open = "w")
[10:18:31.716]         }
[10:18:31.716]         else {
[10:18:31.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.716]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.716]         }
[10:18:31.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.716]             base::sink(type = "output", split = FALSE)
[10:18:31.716]             base::close(...future.stdout)
[10:18:31.716]         }, add = TRUE)
[10:18:31.716]     }
[10:18:31.716]     ...future.frame <- base::sys.nframe()
[10:18:31.716]     ...future.conditions <- base::list()
[10:18:31.716]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.716]     if (FALSE) {
[10:18:31.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.716]     }
[10:18:31.716]     ...future.result <- base::tryCatch({
[10:18:31.716]         base::withCallingHandlers({
[10:18:31.716]             ...future.value <- base::withVisible(base::local({
[10:18:31.716]                 do.call(function(...) {
[10:18:31.716]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.716]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.716]                     ...future.globals.maxSize)) {
[10:18:31.716]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.716]                     on.exit(options(oopts), add = TRUE)
[10:18:31.716]                   }
[10:18:31.716]                   {
[10:18:31.716]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.716]                       FUN = function(jj) {
[10:18:31.716]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.716]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.716]                       })
[10:18:31.716]                   }
[10:18:31.716]                 }, args = future.call.arguments)
[10:18:31.716]             }))
[10:18:31.716]             future::FutureResult(value = ...future.value$value, 
[10:18:31.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.716]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.716]                     ...future.globalenv.names))
[10:18:31.716]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.716]         }, condition = base::local({
[10:18:31.716]             c <- base::c
[10:18:31.716]             inherits <- base::inherits
[10:18:31.716]             invokeRestart <- base::invokeRestart
[10:18:31.716]             length <- base::length
[10:18:31.716]             list <- base::list
[10:18:31.716]             seq.int <- base::seq.int
[10:18:31.716]             signalCondition <- base::signalCondition
[10:18:31.716]             sys.calls <- base::sys.calls
[10:18:31.716]             `[[` <- base::`[[`
[10:18:31.716]             `+` <- base::`+`
[10:18:31.716]             `<<-` <- base::`<<-`
[10:18:31.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.716]                   3L)]
[10:18:31.716]             }
[10:18:31.716]             function(cond) {
[10:18:31.716]                 is_error <- inherits(cond, "error")
[10:18:31.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.716]                   NULL)
[10:18:31.716]                 if (is_error) {
[10:18:31.716]                   sessionInformation <- function() {
[10:18:31.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.716]                       search = base::search(), system = base::Sys.info())
[10:18:31.716]                   }
[10:18:31.716]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.716]                     cond$call), session = sessionInformation(), 
[10:18:31.716]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.716]                   signalCondition(cond)
[10:18:31.716]                 }
[10:18:31.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.716]                 "immediateCondition"))) {
[10:18:31.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.716]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.716]                   if (TRUE && !signal) {
[10:18:31.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.716]                     {
[10:18:31.716]                       inherits <- base::inherits
[10:18:31.716]                       invokeRestart <- base::invokeRestart
[10:18:31.716]                       is.null <- base::is.null
[10:18:31.716]                       muffled <- FALSE
[10:18:31.716]                       if (inherits(cond, "message")) {
[10:18:31.716]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.716]                         if (muffled) 
[10:18:31.716]                           invokeRestart("muffleMessage")
[10:18:31.716]                       }
[10:18:31.716]                       else if (inherits(cond, "warning")) {
[10:18:31.716]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.716]                         if (muffled) 
[10:18:31.716]                           invokeRestart("muffleWarning")
[10:18:31.716]                       }
[10:18:31.716]                       else if (inherits(cond, "condition")) {
[10:18:31.716]                         if (!is.null(pattern)) {
[10:18:31.716]                           computeRestarts <- base::computeRestarts
[10:18:31.716]                           grepl <- base::grepl
[10:18:31.716]                           restarts <- computeRestarts(cond)
[10:18:31.716]                           for (restart in restarts) {
[10:18:31.716]                             name <- restart$name
[10:18:31.716]                             if (is.null(name)) 
[10:18:31.716]                               next
[10:18:31.716]                             if (!grepl(pattern, name)) 
[10:18:31.716]                               next
[10:18:31.716]                             invokeRestart(restart)
[10:18:31.716]                             muffled <- TRUE
[10:18:31.716]                             break
[10:18:31.716]                           }
[10:18:31.716]                         }
[10:18:31.716]                       }
[10:18:31.716]                       invisible(muffled)
[10:18:31.716]                     }
[10:18:31.716]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.716]                   }
[10:18:31.716]                 }
[10:18:31.716]                 else {
[10:18:31.716]                   if (TRUE) {
[10:18:31.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.716]                     {
[10:18:31.716]                       inherits <- base::inherits
[10:18:31.716]                       invokeRestart <- base::invokeRestart
[10:18:31.716]                       is.null <- base::is.null
[10:18:31.716]                       muffled <- FALSE
[10:18:31.716]                       if (inherits(cond, "message")) {
[10:18:31.716]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.716]                         if (muffled) 
[10:18:31.716]                           invokeRestart("muffleMessage")
[10:18:31.716]                       }
[10:18:31.716]                       else if (inherits(cond, "warning")) {
[10:18:31.716]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.716]                         if (muffled) 
[10:18:31.716]                           invokeRestart("muffleWarning")
[10:18:31.716]                       }
[10:18:31.716]                       else if (inherits(cond, "condition")) {
[10:18:31.716]                         if (!is.null(pattern)) {
[10:18:31.716]                           computeRestarts <- base::computeRestarts
[10:18:31.716]                           grepl <- base::grepl
[10:18:31.716]                           restarts <- computeRestarts(cond)
[10:18:31.716]                           for (restart in restarts) {
[10:18:31.716]                             name <- restart$name
[10:18:31.716]                             if (is.null(name)) 
[10:18:31.716]                               next
[10:18:31.716]                             if (!grepl(pattern, name)) 
[10:18:31.716]                               next
[10:18:31.716]                             invokeRestart(restart)
[10:18:31.716]                             muffled <- TRUE
[10:18:31.716]                             break
[10:18:31.716]                           }
[10:18:31.716]                         }
[10:18:31.716]                       }
[10:18:31.716]                       invisible(muffled)
[10:18:31.716]                     }
[10:18:31.716]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.716]                   }
[10:18:31.716]                 }
[10:18:31.716]             }
[10:18:31.716]         }))
[10:18:31.716]     }, error = function(ex) {
[10:18:31.716]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.716]                 ...future.rng), started = ...future.startTime, 
[10:18:31.716]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.716]             version = "1.8"), class = "FutureResult")
[10:18:31.716]     }, finally = {
[10:18:31.716]         if (!identical(...future.workdir, getwd())) 
[10:18:31.716]             setwd(...future.workdir)
[10:18:31.716]         {
[10:18:31.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.716]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.716]             }
[10:18:31.716]             base::options(...future.oldOptions)
[10:18:31.716]             if (.Platform$OS.type == "windows") {
[10:18:31.716]                 old_names <- names(...future.oldEnvVars)
[10:18:31.716]                 envs <- base::Sys.getenv()
[10:18:31.716]                 names <- names(envs)
[10:18:31.716]                 common <- intersect(names, old_names)
[10:18:31.716]                 added <- setdiff(names, old_names)
[10:18:31.716]                 removed <- setdiff(old_names, names)
[10:18:31.716]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.716]                   envs[common]]
[10:18:31.716]                 NAMES <- toupper(changed)
[10:18:31.716]                 args <- list()
[10:18:31.716]                 for (kk in seq_along(NAMES)) {
[10:18:31.716]                   name <- changed[[kk]]
[10:18:31.716]                   NAME <- NAMES[[kk]]
[10:18:31.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.716]                     next
[10:18:31.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.716]                 }
[10:18:31.716]                 NAMES <- toupper(added)
[10:18:31.716]                 for (kk in seq_along(NAMES)) {
[10:18:31.716]                   name <- added[[kk]]
[10:18:31.716]                   NAME <- NAMES[[kk]]
[10:18:31.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.716]                     next
[10:18:31.716]                   args[[name]] <- ""
[10:18:31.716]                 }
[10:18:31.716]                 NAMES <- toupper(removed)
[10:18:31.716]                 for (kk in seq_along(NAMES)) {
[10:18:31.716]                   name <- removed[[kk]]
[10:18:31.716]                   NAME <- NAMES[[kk]]
[10:18:31.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.716]                     next
[10:18:31.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.716]                 }
[10:18:31.716]                 if (length(args) > 0) 
[10:18:31.716]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.716]             }
[10:18:31.716]             else {
[10:18:31.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.716]             }
[10:18:31.716]             {
[10:18:31.716]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.716]                   0L) {
[10:18:31.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.716]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.716]                   base::options(opts)
[10:18:31.716]                 }
[10:18:31.716]                 {
[10:18:31.716]                   {
[10:18:31.716]                     NULL
[10:18:31.716]                     RNGkind("Mersenne-Twister")
[10:18:31.716]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.716]                       inherits = FALSE)
[10:18:31.716]                   }
[10:18:31.716]                   options(future.plan = NULL)
[10:18:31.716]                   if (is.na(NA_character_)) 
[10:18:31.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.716]                     .init = FALSE)
[10:18:31.716]                 }
[10:18:31.716]             }
[10:18:31.716]         }
[10:18:31.716]     })
[10:18:31.716]     if (TRUE) {
[10:18:31.716]         base::sink(type = "output", split = FALSE)
[10:18:31.716]         if (TRUE) {
[10:18:31.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.716]         }
[10:18:31.716]         else {
[10:18:31.716]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.716]         }
[10:18:31.716]         base::close(...future.stdout)
[10:18:31.716]         ...future.stdout <- NULL
[10:18:31.716]     }
[10:18:31.716]     ...future.result$conditions <- ...future.conditions
[10:18:31.716]     ...future.result$finished <- base::Sys.time()
[10:18:31.716]     ...future.result
[10:18:31.716] }
[10:18:31.718] assign_globals() ...
[10:18:31.718] List of 5
[10:18:31.718]  $ ...future.FUN            :function (object, ...)  
[10:18:31.718]  $ future.call.arguments    : list()
[10:18:31.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.718]  $ ...future.elements_ii    :List of 3
[10:18:31.718]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.718]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.718]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.718]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.718]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.718]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.718]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.718]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.718]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.718]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.718]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.718]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.718]  $ ...future.seeds_ii       : NULL
[10:18:31.718]  $ ...future.globals.maxSize: NULL
[10:18:31.718]  - attr(*, "where")=List of 5
[10:18:31.718]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.718]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.718]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.718]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.718]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.718]  - attr(*, "resolved")= logi FALSE
[10:18:31.718]  - attr(*, "total_size")= num 19278
[10:18:31.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.718]  - attr(*, "already-done")= logi TRUE
[10:18:31.727] - copied ‘...future.FUN’ to environment
[10:18:31.727] - copied ‘future.call.arguments’ to environment
[10:18:31.727] - copied ‘...future.elements_ii’ to environment
[10:18:31.727] - copied ‘...future.seeds_ii’ to environment
[10:18:31.728] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.728] assign_globals() ... done
[10:18:31.728] plan(): Setting new future strategy stack:
[10:18:31.728] List of future strategies:
[10:18:31.728] 1. sequential:
[10:18:31.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.728]    - tweaked: FALSE
[10:18:31.728]    - call: NULL
[10:18:31.728] plan(): nbrOfWorkers() = 1
[10:18:31.731] plan(): Setting new future strategy stack:
[10:18:31.731] List of future strategies:
[10:18:31.731] 1. sequential:
[10:18:31.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.731]    - tweaked: FALSE
[10:18:31.731]    - call: plan(strategy)
[10:18:31.731] plan(): nbrOfWorkers() = 1
[10:18:31.732] SequentialFuture started (and completed)
[10:18:31.732] - Launch lazy future ... done
[10:18:31.732] run() for ‘SequentialFuture’ ... done
[10:18:31.732] Created future:
[10:18:31.732] SequentialFuture:
[10:18:31.732] Label: ‘future_by-1’
[10:18:31.732] Expression:
[10:18:31.732] {
[10:18:31.732]     do.call(function(...) {
[10:18:31.732]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.732]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.732]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.732]             on.exit(options(oopts), add = TRUE)
[10:18:31.732]         }
[10:18:31.732]         {
[10:18:31.732]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.732]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.732]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.732]             })
[10:18:31.732]         }
[10:18:31.732]     }, args = future.call.arguments)
[10:18:31.732] }
[10:18:31.732] Lazy evaluation: FALSE
[10:18:31.732] Asynchronous evaluation: FALSE
[10:18:31.732] Local evaluation: TRUE
[10:18:31.732] Environment: 0x55844a63bb90
[10:18:31.732] Capture standard output: TRUE
[10:18:31.732] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.732] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.732] Packages: <none>
[10:18:31.732] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.732] Resolved: TRUE
[10:18:31.732] Value: 1.39 KiB of class ‘list’
[10:18:31.732] Early signaling: FALSE
[10:18:31.732] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.732] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.733] Chunk #1 of 1 ... DONE
[10:18:31.733] Launching 1 futures (chunks) ... DONE
[10:18:31.733] Resolving 1 futures (chunks) ...
[10:18:31.733] resolve() on list ...
[10:18:31.733]  recursive: 0
[10:18:31.733]  length: 1
[10:18:31.734] 
[10:18:31.734] resolved() for ‘SequentialFuture’ ...
[10:18:31.734] - state: ‘finished’
[10:18:31.734] - run: TRUE
[10:18:31.734] - result: ‘FutureResult’
[10:18:31.734] resolved() for ‘SequentialFuture’ ... done
[10:18:31.734] Future #1
[10:18:31.734] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.734] - nx: 1
[10:18:31.734] - relay: TRUE
[10:18:31.735] - stdout: TRUE
[10:18:31.735] - signal: TRUE
[10:18:31.735] - resignal: FALSE
[10:18:31.735] - force: TRUE
[10:18:31.735] - relayed: [n=1] FALSE
[10:18:31.735] - queued futures: [n=1] FALSE
[10:18:31.735]  - until=1
[10:18:31.735]  - relaying element #1
[10:18:31.735] - relayed: [n=1] TRUE
[10:18:31.735] - queued futures: [n=1] TRUE
[10:18:31.737] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.738]  length: 0 (resolved future 1)
[10:18:31.738] Relaying remaining futures
[10:18:31.738] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.738] - nx: 1
[10:18:31.738] - relay: TRUE
[10:18:31.738] - stdout: TRUE
[10:18:31.738] - signal: TRUE
[10:18:31.738] - resignal: FALSE
[10:18:31.739] - force: TRUE
[10:18:31.739] - relayed: [n=1] TRUE
[10:18:31.739] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.739] - relayed: [n=1] TRUE
[10:18:31.739] - queued futures: [n=1] TRUE
[10:18:31.739] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.739] resolve() on list ... DONE
[10:18:31.739]  - Number of value chunks collected: 1
[10:18:31.740] Resolving 1 futures (chunks) ... DONE
[10:18:31.740] Reducing values from 1 chunks ...
[10:18:31.740]  - Number of values collected after concatenation: 3
[10:18:31.740]  - Number of values expected: 3
[10:18:31.740] Reducing values from 1 chunks ... DONE
[10:18:31.740] future_lapply() ... DONE
[10:18:31.740] future_by_internal() ... DONE
[10:18:31.741] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:18:31.742] future_lapply() ...
[10:18:31.743] Number of chunks: 1
[10:18:31.743] getGlobalsAndPackagesXApply() ...
[10:18:31.743]  - future.globals: TRUE
[10:18:31.743] getGlobalsAndPackages() ...
[10:18:31.743] Searching for globals...
[10:18:31.744] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.744] Searching for globals ... DONE
[10:18:31.745] Resolving globals: FALSE
[10:18:31.745] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.745] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.745] - globals: [1] ‘FUN’
[10:18:31.746] 
[10:18:31.746] getGlobalsAndPackages() ... DONE
[10:18:31.746]  - globals found/used: [n=1] ‘FUN’
[10:18:31.746]  - needed namespaces: [n=0] 
[10:18:31.746] Finding globals ... DONE
[10:18:31.746]  - use_args: TRUE
[10:18:31.746]  - Getting '...' globals ...
[10:18:31.746] resolve() on list ...
[10:18:31.747]  recursive: 0
[10:18:31.747]  length: 1
[10:18:31.747]  elements: ‘...’
[10:18:31.747]  length: 0 (resolved future 1)
[10:18:31.747] resolve() on list ... DONE
[10:18:31.747]    - '...' content: [n=0] 
[10:18:31.747] List of 1
[10:18:31.747]  $ ...: list()
[10:18:31.747]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.747]  - attr(*, "where")=List of 1
[10:18:31.747]   ..$ ...:<environment: 0x55844ab22f70> 
[10:18:31.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.747]  - attr(*, "resolved")= logi TRUE
[10:18:31.747]  - attr(*, "total_size")= num NA
[10:18:31.750]  - Getting '...' globals ... DONE
[10:18:31.750] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.750] List of 2
[10:18:31.750]  $ ...future.FUN:function (object, ...)  
[10:18:31.750]  $ ...          : list()
[10:18:31.750]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.750]  - attr(*, "where")=List of 2
[10:18:31.750]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.750]   ..$ ...          :<environment: 0x55844ab22f70> 
[10:18:31.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.750]  - attr(*, "resolved")= logi FALSE
[10:18:31.750]  - attr(*, "total_size")= num 18647
[10:18:31.753] Packages to be attached in all futures: [n=0] 
[10:18:31.753] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.753] Number of futures (= number of chunks): 1
[10:18:31.753] Launching 1 futures (chunks) ...
[10:18:31.753] Chunk #1 of 1 ...
[10:18:31.753]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.754] getGlobalsAndPackages() ...
[10:18:31.754] Searching for globals...
[10:18:31.754] 
[10:18:31.754] Searching for globals ... DONE
[10:18:31.754] - globals: [0] <none>
[10:18:31.754] getGlobalsAndPackages() ... DONE
[10:18:31.755]    + additional globals found: [n=0] 
[10:18:31.755]    + additional namespaces needed: [n=0] 
[10:18:31.755]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.755]  - seeds: <none>
[10:18:31.755]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.755] getGlobalsAndPackages() ...
[10:18:31.755] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.755] Resolving globals: FALSE
[10:18:31.755] Tweak future expression to call with '...' arguments ...
[10:18:31.755] {
[10:18:31.755]     do.call(function(...) {
[10:18:31.755]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.755]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.755]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.755]             on.exit(options(oopts), add = TRUE)
[10:18:31.755]         }
[10:18:31.755]         {
[10:18:31.755]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.755]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.755]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.755]             })
[10:18:31.755]         }
[10:18:31.755]     }, args = future.call.arguments)
[10:18:31.755] }
[10:18:31.756] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.756] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.756] 
[10:18:31.756] getGlobalsAndPackages() ... DONE
[10:18:31.757] run() for ‘Future’ ...
[10:18:31.757] - state: ‘created’
[10:18:31.757] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:31.757] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.757] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:31.757]   - Field: ‘label’
[10:18:31.758]   - Field: ‘local’
[10:18:31.758]   - Field: ‘owner’
[10:18:31.758]   - Field: ‘envir’
[10:18:31.758]   - Field: ‘packages’
[10:18:31.758]   - Field: ‘gc’
[10:18:31.758]   - Field: ‘conditions’
[10:18:31.758]   - Field: ‘expr’
[10:18:31.758]   - Field: ‘uuid’
[10:18:31.758]   - Field: ‘seed’
[10:18:31.761]   - Field: ‘version’
[10:18:31.761]   - Field: ‘result’
[10:18:31.761]   - Field: ‘asynchronous’
[10:18:31.761]   - Field: ‘calls’
[10:18:31.761]   - Field: ‘globals’
[10:18:31.761]   - Field: ‘stdout’
[10:18:31.761]   - Field: ‘earlySignal’
[10:18:31.761]   - Field: ‘lazy’
[10:18:31.762]   - Field: ‘state’
[10:18:31.762] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:31.762] - Launch lazy future ...
[10:18:31.762] Packages needed by the future expression (n = 0): <none>
[10:18:31.762] Packages needed by future strategies (n = 0): <none>
[10:18:31.763] {
[10:18:31.763]     {
[10:18:31.763]         {
[10:18:31.763]             ...future.startTime <- base::Sys.time()
[10:18:31.763]             {
[10:18:31.763]                 {
[10:18:31.763]                   {
[10:18:31.763]                     base::local({
[10:18:31.763]                       has_future <- base::requireNamespace("future", 
[10:18:31.763]                         quietly = TRUE)
[10:18:31.763]                       if (has_future) {
[10:18:31.763]                         ns <- base::getNamespace("future")
[10:18:31.763]                         version <- ns[[".package"]][["version"]]
[10:18:31.763]                         if (is.null(version)) 
[10:18:31.763]                           version <- utils::packageVersion("future")
[10:18:31.763]                       }
[10:18:31.763]                       else {
[10:18:31.763]                         version <- NULL
[10:18:31.763]                       }
[10:18:31.763]                       if (!has_future || version < "1.8.0") {
[10:18:31.763]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.763]                           "", base::R.version$version.string), 
[10:18:31.763]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:31.763]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.763]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.763]                             "release", "version")], collapse = " "), 
[10:18:31.763]                           hostname = base::Sys.info()[["nodename"]])
[10:18:31.763]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.763]                           info)
[10:18:31.763]                         info <- base::paste(info, collapse = "; ")
[10:18:31.763]                         if (!has_future) {
[10:18:31.763]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.763]                             info)
[10:18:31.763]                         }
[10:18:31.763]                         else {
[10:18:31.763]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.763]                             info, version)
[10:18:31.763]                         }
[10:18:31.763]                         base::stop(msg)
[10:18:31.763]                       }
[10:18:31.763]                     })
[10:18:31.763]                   }
[10:18:31.763]                   ...future.strategy.old <- future::plan("list")
[10:18:31.763]                   options(future.plan = NULL)
[10:18:31.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.763]                 }
[10:18:31.763]                 ...future.workdir <- getwd()
[10:18:31.763]             }
[10:18:31.763]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.763]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.763]         }
[10:18:31.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:31.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.763]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.763]             base::names(...future.oldOptions))
[10:18:31.763]     }
[10:18:31.763]     if (FALSE) {
[10:18:31.763]     }
[10:18:31.763]     else {
[10:18:31.763]         if (TRUE) {
[10:18:31.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.763]                 open = "w")
[10:18:31.763]         }
[10:18:31.763]         else {
[10:18:31.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.763]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.763]         }
[10:18:31.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.763]             base::sink(type = "output", split = FALSE)
[10:18:31.763]             base::close(...future.stdout)
[10:18:31.763]         }, add = TRUE)
[10:18:31.763]     }
[10:18:31.763]     ...future.frame <- base::sys.nframe()
[10:18:31.763]     ...future.conditions <- base::list()
[10:18:31.763]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.763]     if (FALSE) {
[10:18:31.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.763]     }
[10:18:31.763]     ...future.result <- base::tryCatch({
[10:18:31.763]         base::withCallingHandlers({
[10:18:31.763]             ...future.value <- base::withVisible(base::local({
[10:18:31.763]                 do.call(function(...) {
[10:18:31.763]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.763]                   if (!identical(...future.globals.maxSize.org, 
[10:18:31.763]                     ...future.globals.maxSize)) {
[10:18:31.763]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.763]                     on.exit(options(oopts), add = TRUE)
[10:18:31.763]                   }
[10:18:31.763]                   {
[10:18:31.763]                     lapply(seq_along(...future.elements_ii), 
[10:18:31.763]                       FUN = function(jj) {
[10:18:31.763]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.763]                         ...future.FUN(...future.X_jj, ...)
[10:18:31.763]                       })
[10:18:31.763]                   }
[10:18:31.763]                 }, args = future.call.arguments)
[10:18:31.763]             }))
[10:18:31.763]             future::FutureResult(value = ...future.value$value, 
[10:18:31.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.763]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.763]                     ...future.globalenv.names))
[10:18:31.763]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.763]         }, condition = base::local({
[10:18:31.763]             c <- base::c
[10:18:31.763]             inherits <- base::inherits
[10:18:31.763]             invokeRestart <- base::invokeRestart
[10:18:31.763]             length <- base::length
[10:18:31.763]             list <- base::list
[10:18:31.763]             seq.int <- base::seq.int
[10:18:31.763]             signalCondition <- base::signalCondition
[10:18:31.763]             sys.calls <- base::sys.calls
[10:18:31.763]             `[[` <- base::`[[`
[10:18:31.763]             `+` <- base::`+`
[10:18:31.763]             `<<-` <- base::`<<-`
[10:18:31.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.763]                   3L)]
[10:18:31.763]             }
[10:18:31.763]             function(cond) {
[10:18:31.763]                 is_error <- inherits(cond, "error")
[10:18:31.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.763]                   NULL)
[10:18:31.763]                 if (is_error) {
[10:18:31.763]                   sessionInformation <- function() {
[10:18:31.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.763]                       search = base::search(), system = base::Sys.info())
[10:18:31.763]                   }
[10:18:31.763]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.763]                     cond$call), session = sessionInformation(), 
[10:18:31.763]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.763]                   signalCondition(cond)
[10:18:31.763]                 }
[10:18:31.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.763]                 "immediateCondition"))) {
[10:18:31.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.763]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.763]                   if (TRUE && !signal) {
[10:18:31.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.763]                     {
[10:18:31.763]                       inherits <- base::inherits
[10:18:31.763]                       invokeRestart <- base::invokeRestart
[10:18:31.763]                       is.null <- base::is.null
[10:18:31.763]                       muffled <- FALSE
[10:18:31.763]                       if (inherits(cond, "message")) {
[10:18:31.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.763]                         if (muffled) 
[10:18:31.763]                           invokeRestart("muffleMessage")
[10:18:31.763]                       }
[10:18:31.763]                       else if (inherits(cond, "warning")) {
[10:18:31.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.763]                         if (muffled) 
[10:18:31.763]                           invokeRestart("muffleWarning")
[10:18:31.763]                       }
[10:18:31.763]                       else if (inherits(cond, "condition")) {
[10:18:31.763]                         if (!is.null(pattern)) {
[10:18:31.763]                           computeRestarts <- base::computeRestarts
[10:18:31.763]                           grepl <- base::grepl
[10:18:31.763]                           restarts <- computeRestarts(cond)
[10:18:31.763]                           for (restart in restarts) {
[10:18:31.763]                             name <- restart$name
[10:18:31.763]                             if (is.null(name)) 
[10:18:31.763]                               next
[10:18:31.763]                             if (!grepl(pattern, name)) 
[10:18:31.763]                               next
[10:18:31.763]                             invokeRestart(restart)
[10:18:31.763]                             muffled <- TRUE
[10:18:31.763]                             break
[10:18:31.763]                           }
[10:18:31.763]                         }
[10:18:31.763]                       }
[10:18:31.763]                       invisible(muffled)
[10:18:31.763]                     }
[10:18:31.763]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.763]                   }
[10:18:31.763]                 }
[10:18:31.763]                 else {
[10:18:31.763]                   if (TRUE) {
[10:18:31.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.763]                     {
[10:18:31.763]                       inherits <- base::inherits
[10:18:31.763]                       invokeRestart <- base::invokeRestart
[10:18:31.763]                       is.null <- base::is.null
[10:18:31.763]                       muffled <- FALSE
[10:18:31.763]                       if (inherits(cond, "message")) {
[10:18:31.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.763]                         if (muffled) 
[10:18:31.763]                           invokeRestart("muffleMessage")
[10:18:31.763]                       }
[10:18:31.763]                       else if (inherits(cond, "warning")) {
[10:18:31.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.763]                         if (muffled) 
[10:18:31.763]                           invokeRestart("muffleWarning")
[10:18:31.763]                       }
[10:18:31.763]                       else if (inherits(cond, "condition")) {
[10:18:31.763]                         if (!is.null(pattern)) {
[10:18:31.763]                           computeRestarts <- base::computeRestarts
[10:18:31.763]                           grepl <- base::grepl
[10:18:31.763]                           restarts <- computeRestarts(cond)
[10:18:31.763]                           for (restart in restarts) {
[10:18:31.763]                             name <- restart$name
[10:18:31.763]                             if (is.null(name)) 
[10:18:31.763]                               next
[10:18:31.763]                             if (!grepl(pattern, name)) 
[10:18:31.763]                               next
[10:18:31.763]                             invokeRestart(restart)
[10:18:31.763]                             muffled <- TRUE
[10:18:31.763]                             break
[10:18:31.763]                           }
[10:18:31.763]                         }
[10:18:31.763]                       }
[10:18:31.763]                       invisible(muffled)
[10:18:31.763]                     }
[10:18:31.763]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.763]                   }
[10:18:31.763]                 }
[10:18:31.763]             }
[10:18:31.763]         }))
[10:18:31.763]     }, error = function(ex) {
[10:18:31.763]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.763]                 ...future.rng), started = ...future.startTime, 
[10:18:31.763]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.763]             version = "1.8"), class = "FutureResult")
[10:18:31.763]     }, finally = {
[10:18:31.763]         if (!identical(...future.workdir, getwd())) 
[10:18:31.763]             setwd(...future.workdir)
[10:18:31.763]         {
[10:18:31.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.763]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.763]             }
[10:18:31.763]             base::options(...future.oldOptions)
[10:18:31.763]             if (.Platform$OS.type == "windows") {
[10:18:31.763]                 old_names <- names(...future.oldEnvVars)
[10:18:31.763]                 envs <- base::Sys.getenv()
[10:18:31.763]                 names <- names(envs)
[10:18:31.763]                 common <- intersect(names, old_names)
[10:18:31.763]                 added <- setdiff(names, old_names)
[10:18:31.763]                 removed <- setdiff(old_names, names)
[10:18:31.763]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.763]                   envs[common]]
[10:18:31.763]                 NAMES <- toupper(changed)
[10:18:31.763]                 args <- list()
[10:18:31.763]                 for (kk in seq_along(NAMES)) {
[10:18:31.763]                   name <- changed[[kk]]
[10:18:31.763]                   NAME <- NAMES[[kk]]
[10:18:31.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.763]                     next
[10:18:31.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.763]                 }
[10:18:31.763]                 NAMES <- toupper(added)
[10:18:31.763]                 for (kk in seq_along(NAMES)) {
[10:18:31.763]                   name <- added[[kk]]
[10:18:31.763]                   NAME <- NAMES[[kk]]
[10:18:31.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.763]                     next
[10:18:31.763]                   args[[name]] <- ""
[10:18:31.763]                 }
[10:18:31.763]                 NAMES <- toupper(removed)
[10:18:31.763]                 for (kk in seq_along(NAMES)) {
[10:18:31.763]                   name <- removed[[kk]]
[10:18:31.763]                   NAME <- NAMES[[kk]]
[10:18:31.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.763]                     next
[10:18:31.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.763]                 }
[10:18:31.763]                 if (length(args) > 0) 
[10:18:31.763]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.763]             }
[10:18:31.763]             else {
[10:18:31.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.763]             }
[10:18:31.763]             {
[10:18:31.763]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.763]                   0L) {
[10:18:31.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.763]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.763]                   base::options(opts)
[10:18:31.763]                 }
[10:18:31.763]                 {
[10:18:31.763]                   {
[10:18:31.763]                     NULL
[10:18:31.763]                     RNGkind("Mersenne-Twister")
[10:18:31.763]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:31.763]                       inherits = FALSE)
[10:18:31.763]                   }
[10:18:31.763]                   options(future.plan = NULL)
[10:18:31.763]                   if (is.na(NA_character_)) 
[10:18:31.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.763]                     .init = FALSE)
[10:18:31.763]                 }
[10:18:31.763]             }
[10:18:31.763]         }
[10:18:31.763]     })
[10:18:31.763]     if (TRUE) {
[10:18:31.763]         base::sink(type = "output", split = FALSE)
[10:18:31.763]         if (TRUE) {
[10:18:31.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.763]         }
[10:18:31.763]         else {
[10:18:31.763]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.763]         }
[10:18:31.763]         base::close(...future.stdout)
[10:18:31.763]         ...future.stdout <- NULL
[10:18:31.763]     }
[10:18:31.763]     ...future.result$conditions <- ...future.conditions
[10:18:31.763]     ...future.result$finished <- base::Sys.time()
[10:18:31.763]     ...future.result
[10:18:31.763] }
[10:18:31.765] assign_globals() ...
[10:18:31.765] List of 5
[10:18:31.765]  $ ...future.FUN            :function (object, ...)  
[10:18:31.765]  $ future.call.arguments    : list()
[10:18:31.765]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.765]  $ ...future.elements_ii    :List of 3
[10:18:31.765]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.765]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.765]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.765]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:31.765]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.765]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.765]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.765]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:31.765]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:31.765]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.765]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.765]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:31.765]  $ ...future.seeds_ii       : NULL
[10:18:31.765]  $ ...future.globals.maxSize: NULL
[10:18:31.765]  - attr(*, "where")=List of 5
[10:18:31.765]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.765]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.765]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.765]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.765]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.765]  - attr(*, "resolved")= logi FALSE
[10:18:31.765]  - attr(*, "total_size")= num 18647
[10:18:31.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.765]  - attr(*, "already-done")= logi TRUE
[10:18:31.775] - copied ‘...future.FUN’ to environment
[10:18:31.775] - copied ‘future.call.arguments’ to environment
[10:18:31.775] - copied ‘...future.elements_ii’ to environment
[10:18:31.775] - copied ‘...future.seeds_ii’ to environment
[10:18:31.775] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.775] assign_globals() ... done
[10:18:31.775] plan(): Setting new future strategy stack:
[10:18:31.776] List of future strategies:
[10:18:31.776] 1. sequential:
[10:18:31.776]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.776]    - tweaked: FALSE
[10:18:31.776]    - call: NULL
[10:18:31.776] plan(): nbrOfWorkers() = 1
[10:18:31.779] plan(): Setting new future strategy stack:
[10:18:31.779] List of future strategies:
[10:18:31.779] 1. sequential:
[10:18:31.779]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.779]    - tweaked: FALSE
[10:18:31.779]    - call: plan(strategy)
[10:18:31.779] plan(): nbrOfWorkers() = 1
[10:18:31.779] SequentialFuture started (and completed)
[10:18:31.780] - Launch lazy future ... done
[10:18:31.780] run() for ‘SequentialFuture’ ... done
[10:18:31.780] Created future:
[10:18:31.780] SequentialFuture:
[10:18:31.780] Label: ‘future_by-1’
[10:18:31.780] Expression:
[10:18:31.780] {
[10:18:31.780]     do.call(function(...) {
[10:18:31.780]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.780]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.780]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.780]             on.exit(options(oopts), add = TRUE)
[10:18:31.780]         }
[10:18:31.780]         {
[10:18:31.780]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.780]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.780]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.780]             })
[10:18:31.780]         }
[10:18:31.780]     }, args = future.call.arguments)
[10:18:31.780] }
[10:18:31.780] Lazy evaluation: FALSE
[10:18:31.780] Asynchronous evaluation: FALSE
[10:18:31.780] Local evaluation: TRUE
[10:18:31.780] Environment: 0x558449768de0
[10:18:31.780] Capture standard output: TRUE
[10:18:31.780] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.780] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.780] Packages: <none>
[10:18:31.780] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.780] Resolved: TRUE
[10:18:31.780] Value: 1.39 KiB of class ‘list’
[10:18:31.780] Early signaling: FALSE
[10:18:31.780] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.780] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:31.781] Chunk #1 of 1 ... DONE
[10:18:31.781] Launching 1 futures (chunks) ... DONE
[10:18:31.781] Resolving 1 futures (chunks) ...
[10:18:31.781] resolve() on list ...
[10:18:31.781]  recursive: 0
[10:18:31.781]  length: 1
[10:18:31.781] 
[10:18:31.782] resolved() for ‘SequentialFuture’ ...
[10:18:31.782] - state: ‘finished’
[10:18:31.782] - run: TRUE
[10:18:31.782] - result: ‘FutureResult’
[10:18:31.782] resolved() for ‘SequentialFuture’ ... done
[10:18:31.782] Future #1
[10:18:31.782] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:31.782] - nx: 1
[10:18:31.782] - relay: TRUE
[10:18:31.782] - stdout: TRUE
[10:18:31.783] - signal: TRUE
[10:18:31.783] - resignal: FALSE
[10:18:31.783] - force: TRUE
[10:18:31.783] - relayed: [n=1] FALSE
[10:18:31.783] - queued futures: [n=1] FALSE
[10:18:31.783]  - until=1
[10:18:31.783]  - relaying element #1
[10:18:31.783] - relayed: [n=1] TRUE
[10:18:31.783] - queued futures: [n=1] TRUE
[10:18:31.786] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:31.786]  length: 0 (resolved future 1)
[10:18:31.786] Relaying remaining futures
[10:18:31.786] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.786] - nx: 1
[10:18:31.786] - relay: TRUE
[10:18:31.786] - stdout: TRUE
[10:18:31.786] - signal: TRUE
[10:18:31.786] - resignal: FALSE
[10:18:31.787] - force: TRUE
[10:18:31.787] - relayed: [n=1] TRUE
[10:18:31.787] - queued futures: [n=1] TRUE
 - flush all
[10:18:31.787] - relayed: [n=1] TRUE
[10:18:31.787] - queued futures: [n=1] TRUE
[10:18:31.787] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.787] resolve() on list ... DONE
[10:18:31.788]  - Number of value chunks collected: 1
[10:18:31.788] Resolving 1 futures (chunks) ... DONE
[10:18:31.788] Reducing values from 1 chunks ...
[10:18:31.788]  - Number of values collected after concatenation: 3
[10:18:31.788]  - Number of values expected: 3
[10:18:31.788] Reducing values from 1 chunks ... DONE
[10:18:31.788] future_lapply() ... DONE
[10:18:31.788] future_by_internal() ... DONE
[10:18:31.790] future_by_internal() ...
- plan('multicore') ...
[10:18:31.790] plan(): Setting new future strategy stack:
[10:18:31.790] List of future strategies:
[10:18:31.790] 1. multicore:
[10:18:31.790]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:31.790]    - tweaked: FALSE
[10:18:31.790]    - call: plan(strategy)
[10:18:31.792] plan(): nbrOfWorkers() = 2
[10:18:31.792] future_by_internal() ...
[10:18:31.793] future_lapply() ...
[10:18:31.796] Number of chunks: 2
[10:18:31.796] getGlobalsAndPackagesXApply() ...
[10:18:31.796]  - future.globals: TRUE
[10:18:31.796] getGlobalsAndPackages() ...
[10:18:31.796] Searching for globals...
[10:18:31.797] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.797] Searching for globals ... DONE
[10:18:31.797] Resolving globals: FALSE
[10:18:31.798] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.798] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.798] - globals: [1] ‘FUN’
[10:18:31.798] 
[10:18:31.798] getGlobalsAndPackages() ... DONE
[10:18:31.798]  - globals found/used: [n=1] ‘FUN’
[10:18:31.799]  - needed namespaces: [n=0] 
[10:18:31.799] Finding globals ... DONE
[10:18:31.799]  - use_args: TRUE
[10:18:31.799]  - Getting '...' globals ...
[10:18:31.799] resolve() on list ...
[10:18:31.799]  recursive: 0
[10:18:31.799]  length: 1
[10:18:31.799]  elements: ‘...’
[10:18:31.800]  length: 0 (resolved future 1)
[10:18:31.800] resolve() on list ... DONE
[10:18:31.800]    - '...' content: [n=0] 
[10:18:31.800] List of 1
[10:18:31.800]  $ ...: list()
[10:18:31.800]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.800]  - attr(*, "where")=List of 1
[10:18:31.800]   ..$ ...:<environment: 0x5584496fbc90> 
[10:18:31.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.800]  - attr(*, "resolved")= logi TRUE
[10:18:31.800]  - attr(*, "total_size")= num NA
[10:18:31.802]  - Getting '...' globals ... DONE
[10:18:31.803] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.803] List of 2
[10:18:31.803]  $ ...future.FUN:function (object, ...)  
[10:18:31.803]  $ ...          : list()
[10:18:31.803]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.803]  - attr(*, "where")=List of 2
[10:18:31.803]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.803]   ..$ ...          :<environment: 0x5584496fbc90> 
[10:18:31.803]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.803]  - attr(*, "resolved")= logi FALSE
[10:18:31.803]  - attr(*, "total_size")= num 15670
[10:18:31.805] Packages to be attached in all futures: [n=0] 
[10:18:31.806] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.806] Number of futures (= number of chunks): 2
[10:18:31.806] Launching 2 futures (chunks) ...
[10:18:31.806] Chunk #1 of 2 ...
[10:18:31.806]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.806] getGlobalsAndPackages() ...
[10:18:31.806] Searching for globals...
[10:18:31.807] 
[10:18:31.807] Searching for globals ... DONE
[10:18:31.807] - globals: [0] <none>
[10:18:31.807] getGlobalsAndPackages() ... DONE
[10:18:31.807]    + additional globals found: [n=0] 
[10:18:31.807]    + additional namespaces needed: [n=0] 
[10:18:31.807]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.807]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:31.807]  - seeds: <none>
[10:18:31.807]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.810] getGlobalsAndPackages() ...
[10:18:31.810] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.810] Resolving globals: FALSE
[10:18:31.810] Tweak future expression to call with '...' arguments ...
[10:18:31.810] {
[10:18:31.810]     do.call(function(...) {
[10:18:31.810]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.810]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.810]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.810]             on.exit(options(oopts), add = TRUE)
[10:18:31.810]         }
[10:18:31.810]         {
[10:18:31.810]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.810]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.810]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.810]             })
[10:18:31.810]         }
[10:18:31.810]     }, args = future.call.arguments)
[10:18:31.810] }
[10:18:31.811] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.811] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.811] 
[10:18:31.811] getGlobalsAndPackages() ... DONE
[10:18:31.812] run() for ‘Future’ ...
[10:18:31.812] - state: ‘created’
[10:18:31.812] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.814] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:31.814] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:31.815]   - Field: ‘label’
[10:18:31.815]   - Field: ‘local’
[10:18:31.815]   - Field: ‘owner’
[10:18:31.815]   - Field: ‘envir’
[10:18:31.815]   - Field: ‘workers’
[10:18:31.815]   - Field: ‘packages’
[10:18:31.815]   - Field: ‘gc’
[10:18:31.815]   - Field: ‘job’
[10:18:31.815]   - Field: ‘conditions’
[10:18:31.816]   - Field: ‘expr’
[10:18:31.816]   - Field: ‘uuid’
[10:18:31.816]   - Field: ‘seed’
[10:18:31.816]   - Field: ‘version’
[10:18:31.816]   - Field: ‘result’
[10:18:31.816]   - Field: ‘asynchronous’
[10:18:31.816]   - Field: ‘calls’
[10:18:31.816]   - Field: ‘globals’
[10:18:31.816]   - Field: ‘stdout’
[10:18:31.816]   - Field: ‘earlySignal’
[10:18:31.816]   - Field: ‘lazy’
[10:18:31.817]   - Field: ‘state’
[10:18:31.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:31.817] - Launch lazy future ...
[10:18:31.818] Packages needed by the future expression (n = 0): <none>
[10:18:31.818] Packages needed by future strategies (n = 0): <none>
[10:18:31.818] {
[10:18:31.818]     {
[10:18:31.818]         {
[10:18:31.818]             ...future.startTime <- base::Sys.time()
[10:18:31.818]             {
[10:18:31.818]                 {
[10:18:31.818]                   {
[10:18:31.818]                     {
[10:18:31.818]                       base::local({
[10:18:31.818]                         has_future <- base::requireNamespace("future", 
[10:18:31.818]                           quietly = TRUE)
[10:18:31.818]                         if (has_future) {
[10:18:31.818]                           ns <- base::getNamespace("future")
[10:18:31.818]                           version <- ns[[".package"]][["version"]]
[10:18:31.818]                           if (is.null(version)) 
[10:18:31.818]                             version <- utils::packageVersion("future")
[10:18:31.818]                         }
[10:18:31.818]                         else {
[10:18:31.818]                           version <- NULL
[10:18:31.818]                         }
[10:18:31.818]                         if (!has_future || version < "1.8.0") {
[10:18:31.818]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.818]                             "", base::R.version$version.string), 
[10:18:31.818]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.818]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.818]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.818]                               "release", "version")], collapse = " "), 
[10:18:31.818]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.818]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.818]                             info)
[10:18:31.818]                           info <- base::paste(info, collapse = "; ")
[10:18:31.818]                           if (!has_future) {
[10:18:31.818]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.818]                               info)
[10:18:31.818]                           }
[10:18:31.818]                           else {
[10:18:31.818]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.818]                               info, version)
[10:18:31.818]                           }
[10:18:31.818]                           base::stop(msg)
[10:18:31.818]                         }
[10:18:31.818]                       })
[10:18:31.818]                     }
[10:18:31.818]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:31.818]                     base::options(mc.cores = 1L)
[10:18:31.818]                   }
[10:18:31.818]                   ...future.strategy.old <- future::plan("list")
[10:18:31.818]                   options(future.plan = NULL)
[10:18:31.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.818]                 }
[10:18:31.818]                 ...future.workdir <- getwd()
[10:18:31.818]             }
[10:18:31.818]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.818]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.818]         }
[10:18:31.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.818]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:31.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.818]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.818]             base::names(...future.oldOptions))
[10:18:31.818]     }
[10:18:31.818]     if (FALSE) {
[10:18:31.818]     }
[10:18:31.818]     else {
[10:18:31.818]         if (TRUE) {
[10:18:31.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.818]                 open = "w")
[10:18:31.818]         }
[10:18:31.818]         else {
[10:18:31.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.818]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.818]         }
[10:18:31.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.818]             base::sink(type = "output", split = FALSE)
[10:18:31.818]             base::close(...future.stdout)
[10:18:31.818]         }, add = TRUE)
[10:18:31.818]     }
[10:18:31.818]     ...future.frame <- base::sys.nframe()
[10:18:31.818]     ...future.conditions <- base::list()
[10:18:31.818]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.818]     if (FALSE) {
[10:18:31.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.818]     }
[10:18:31.818]     ...future.result <- base::tryCatch({
[10:18:31.818]         base::withCallingHandlers({
[10:18:31.818]             ...future.value <- base::withVisible(base::local({
[10:18:31.818]                 withCallingHandlers({
[10:18:31.818]                   {
[10:18:31.818]                     do.call(function(...) {
[10:18:31.818]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.818]                       if (!identical(...future.globals.maxSize.org, 
[10:18:31.818]                         ...future.globals.maxSize)) {
[10:18:31.818]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.818]                         on.exit(options(oopts), add = TRUE)
[10:18:31.818]                       }
[10:18:31.818]                       {
[10:18:31.818]                         lapply(seq_along(...future.elements_ii), 
[10:18:31.818]                           FUN = function(jj) {
[10:18:31.818]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.818]                             ...future.FUN(...future.X_jj, ...)
[10:18:31.818]                           })
[10:18:31.818]                       }
[10:18:31.818]                     }, args = future.call.arguments)
[10:18:31.818]                   }
[10:18:31.818]                 }, immediateCondition = function(cond) {
[10:18:31.818]                   save_rds <- function (object, pathname, ...) 
[10:18:31.818]                   {
[10:18:31.818]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:31.818]                     if (file_test("-f", pathname_tmp)) {
[10:18:31.818]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.818]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:31.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.818]                         fi_tmp[["mtime"]])
[10:18:31.818]                     }
[10:18:31.818]                     tryCatch({
[10:18:31.818]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:31.818]                     }, error = function(ex) {
[10:18:31.818]                       msg <- conditionMessage(ex)
[10:18:31.818]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.818]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:31.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.818]                         fi_tmp[["mtime"]], msg)
[10:18:31.818]                       ex$message <- msg
[10:18:31.818]                       stop(ex)
[10:18:31.818]                     })
[10:18:31.818]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:31.818]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:31.818]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:31.818]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.818]                       fi <- file.info(pathname)
[10:18:31.818]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:31.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.818]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:31.818]                         fi[["size"]], fi[["mtime"]])
[10:18:31.818]                       stop(msg)
[10:18:31.818]                     }
[10:18:31.818]                     invisible(pathname)
[10:18:31.818]                   }
[10:18:31.818]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:31.818]                     rootPath = tempdir()) 
[10:18:31.818]                   {
[10:18:31.818]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:31.818]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:31.818]                       tmpdir = path, fileext = ".rds")
[10:18:31.818]                     save_rds(obj, file)
[10:18:31.818]                   }
[10:18:31.818]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:31.818]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.818]                   {
[10:18:31.818]                     inherits <- base::inherits
[10:18:31.818]                     invokeRestart <- base::invokeRestart
[10:18:31.818]                     is.null <- base::is.null
[10:18:31.818]                     muffled <- FALSE
[10:18:31.818]                     if (inherits(cond, "message")) {
[10:18:31.818]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:31.818]                       if (muffled) 
[10:18:31.818]                         invokeRestart("muffleMessage")
[10:18:31.818]                     }
[10:18:31.818]                     else if (inherits(cond, "warning")) {
[10:18:31.818]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:31.818]                       if (muffled) 
[10:18:31.818]                         invokeRestart("muffleWarning")
[10:18:31.818]                     }
[10:18:31.818]                     else if (inherits(cond, "condition")) {
[10:18:31.818]                       if (!is.null(pattern)) {
[10:18:31.818]                         computeRestarts <- base::computeRestarts
[10:18:31.818]                         grepl <- base::grepl
[10:18:31.818]                         restarts <- computeRestarts(cond)
[10:18:31.818]                         for (restart in restarts) {
[10:18:31.818]                           name <- restart$name
[10:18:31.818]                           if (is.null(name)) 
[10:18:31.818]                             next
[10:18:31.818]                           if (!grepl(pattern, name)) 
[10:18:31.818]                             next
[10:18:31.818]                           invokeRestart(restart)
[10:18:31.818]                           muffled <- TRUE
[10:18:31.818]                           break
[10:18:31.818]                         }
[10:18:31.818]                       }
[10:18:31.818]                     }
[10:18:31.818]                     invisible(muffled)
[10:18:31.818]                   }
[10:18:31.818]                   muffleCondition(cond)
[10:18:31.818]                 })
[10:18:31.818]             }))
[10:18:31.818]             future::FutureResult(value = ...future.value$value, 
[10:18:31.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.818]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.818]                     ...future.globalenv.names))
[10:18:31.818]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.818]         }, condition = base::local({
[10:18:31.818]             c <- base::c
[10:18:31.818]             inherits <- base::inherits
[10:18:31.818]             invokeRestart <- base::invokeRestart
[10:18:31.818]             length <- base::length
[10:18:31.818]             list <- base::list
[10:18:31.818]             seq.int <- base::seq.int
[10:18:31.818]             signalCondition <- base::signalCondition
[10:18:31.818]             sys.calls <- base::sys.calls
[10:18:31.818]             `[[` <- base::`[[`
[10:18:31.818]             `+` <- base::`+`
[10:18:31.818]             `<<-` <- base::`<<-`
[10:18:31.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.818]                   3L)]
[10:18:31.818]             }
[10:18:31.818]             function(cond) {
[10:18:31.818]                 is_error <- inherits(cond, "error")
[10:18:31.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.818]                   NULL)
[10:18:31.818]                 if (is_error) {
[10:18:31.818]                   sessionInformation <- function() {
[10:18:31.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.818]                       search = base::search(), system = base::Sys.info())
[10:18:31.818]                   }
[10:18:31.818]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.818]                     cond$call), session = sessionInformation(), 
[10:18:31.818]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.818]                   signalCondition(cond)
[10:18:31.818]                 }
[10:18:31.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.818]                 "immediateCondition"))) {
[10:18:31.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.818]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.818]                   if (TRUE && !signal) {
[10:18:31.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.818]                     {
[10:18:31.818]                       inherits <- base::inherits
[10:18:31.818]                       invokeRestart <- base::invokeRestart
[10:18:31.818]                       is.null <- base::is.null
[10:18:31.818]                       muffled <- FALSE
[10:18:31.818]                       if (inherits(cond, "message")) {
[10:18:31.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.818]                         if (muffled) 
[10:18:31.818]                           invokeRestart("muffleMessage")
[10:18:31.818]                       }
[10:18:31.818]                       else if (inherits(cond, "warning")) {
[10:18:31.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.818]                         if (muffled) 
[10:18:31.818]                           invokeRestart("muffleWarning")
[10:18:31.818]                       }
[10:18:31.818]                       else if (inherits(cond, "condition")) {
[10:18:31.818]                         if (!is.null(pattern)) {
[10:18:31.818]                           computeRestarts <- base::computeRestarts
[10:18:31.818]                           grepl <- base::grepl
[10:18:31.818]                           restarts <- computeRestarts(cond)
[10:18:31.818]                           for (restart in restarts) {
[10:18:31.818]                             name <- restart$name
[10:18:31.818]                             if (is.null(name)) 
[10:18:31.818]                               next
[10:18:31.818]                             if (!grepl(pattern, name)) 
[10:18:31.818]                               next
[10:18:31.818]                             invokeRestart(restart)
[10:18:31.818]                             muffled <- TRUE
[10:18:31.818]                             break
[10:18:31.818]                           }
[10:18:31.818]                         }
[10:18:31.818]                       }
[10:18:31.818]                       invisible(muffled)
[10:18:31.818]                     }
[10:18:31.818]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.818]                   }
[10:18:31.818]                 }
[10:18:31.818]                 else {
[10:18:31.818]                   if (TRUE) {
[10:18:31.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.818]                     {
[10:18:31.818]                       inherits <- base::inherits
[10:18:31.818]                       invokeRestart <- base::invokeRestart
[10:18:31.818]                       is.null <- base::is.null
[10:18:31.818]                       muffled <- FALSE
[10:18:31.818]                       if (inherits(cond, "message")) {
[10:18:31.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.818]                         if (muffled) 
[10:18:31.818]                           invokeRestart("muffleMessage")
[10:18:31.818]                       }
[10:18:31.818]                       else if (inherits(cond, "warning")) {
[10:18:31.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.818]                         if (muffled) 
[10:18:31.818]                           invokeRestart("muffleWarning")
[10:18:31.818]                       }
[10:18:31.818]                       else if (inherits(cond, "condition")) {
[10:18:31.818]                         if (!is.null(pattern)) {
[10:18:31.818]                           computeRestarts <- base::computeRestarts
[10:18:31.818]                           grepl <- base::grepl
[10:18:31.818]                           restarts <- computeRestarts(cond)
[10:18:31.818]                           for (restart in restarts) {
[10:18:31.818]                             name <- restart$name
[10:18:31.818]                             if (is.null(name)) 
[10:18:31.818]                               next
[10:18:31.818]                             if (!grepl(pattern, name)) 
[10:18:31.818]                               next
[10:18:31.818]                             invokeRestart(restart)
[10:18:31.818]                             muffled <- TRUE
[10:18:31.818]                             break
[10:18:31.818]                           }
[10:18:31.818]                         }
[10:18:31.818]                       }
[10:18:31.818]                       invisible(muffled)
[10:18:31.818]                     }
[10:18:31.818]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.818]                   }
[10:18:31.818]                 }
[10:18:31.818]             }
[10:18:31.818]         }))
[10:18:31.818]     }, error = function(ex) {
[10:18:31.818]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.818]                 ...future.rng), started = ...future.startTime, 
[10:18:31.818]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.818]             version = "1.8"), class = "FutureResult")
[10:18:31.818]     }, finally = {
[10:18:31.818]         if (!identical(...future.workdir, getwd())) 
[10:18:31.818]             setwd(...future.workdir)
[10:18:31.818]         {
[10:18:31.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.818]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.818]             }
[10:18:31.818]             base::options(...future.oldOptions)
[10:18:31.818]             if (.Platform$OS.type == "windows") {
[10:18:31.818]                 old_names <- names(...future.oldEnvVars)
[10:18:31.818]                 envs <- base::Sys.getenv()
[10:18:31.818]                 names <- names(envs)
[10:18:31.818]                 common <- intersect(names, old_names)
[10:18:31.818]                 added <- setdiff(names, old_names)
[10:18:31.818]                 removed <- setdiff(old_names, names)
[10:18:31.818]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.818]                   envs[common]]
[10:18:31.818]                 NAMES <- toupper(changed)
[10:18:31.818]                 args <- list()
[10:18:31.818]                 for (kk in seq_along(NAMES)) {
[10:18:31.818]                   name <- changed[[kk]]
[10:18:31.818]                   NAME <- NAMES[[kk]]
[10:18:31.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.818]                     next
[10:18:31.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.818]                 }
[10:18:31.818]                 NAMES <- toupper(added)
[10:18:31.818]                 for (kk in seq_along(NAMES)) {
[10:18:31.818]                   name <- added[[kk]]
[10:18:31.818]                   NAME <- NAMES[[kk]]
[10:18:31.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.818]                     next
[10:18:31.818]                   args[[name]] <- ""
[10:18:31.818]                 }
[10:18:31.818]                 NAMES <- toupper(removed)
[10:18:31.818]                 for (kk in seq_along(NAMES)) {
[10:18:31.818]                   name <- removed[[kk]]
[10:18:31.818]                   NAME <- NAMES[[kk]]
[10:18:31.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.818]                     next
[10:18:31.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.818]                 }
[10:18:31.818]                 if (length(args) > 0) 
[10:18:31.818]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.818]             }
[10:18:31.818]             else {
[10:18:31.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.818]             }
[10:18:31.818]             {
[10:18:31.818]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.818]                   0L) {
[10:18:31.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.818]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.818]                   base::options(opts)
[10:18:31.818]                 }
[10:18:31.818]                 {
[10:18:31.818]                   {
[10:18:31.818]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:31.818]                     NULL
[10:18:31.818]                   }
[10:18:31.818]                   options(future.plan = NULL)
[10:18:31.818]                   if (is.na(NA_character_)) 
[10:18:31.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.818]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.818]                     .init = FALSE)
[10:18:31.818]                 }
[10:18:31.818]             }
[10:18:31.818]         }
[10:18:31.818]     })
[10:18:31.818]     if (TRUE) {
[10:18:31.818]         base::sink(type = "output", split = FALSE)
[10:18:31.818]         if (TRUE) {
[10:18:31.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.818]         }
[10:18:31.818]         else {
[10:18:31.818]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.818]         }
[10:18:31.818]         base::close(...future.stdout)
[10:18:31.818]         ...future.stdout <- NULL
[10:18:31.818]     }
[10:18:31.818]     ...future.result$conditions <- ...future.conditions
[10:18:31.818]     ...future.result$finished <- base::Sys.time()
[10:18:31.818]     ...future.result
[10:18:31.818] }
[10:18:31.821] assign_globals() ...
[10:18:31.821] List of 5
[10:18:31.821]  $ ...future.FUN            :function (object, ...)  
[10:18:31.821]  $ future.call.arguments    : list()
[10:18:31.821]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.821]  $ ...future.elements_ii    :List of 1
[10:18:31.821]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.821]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:31.821]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.821]  $ ...future.seeds_ii       : NULL
[10:18:31.821]  $ ...future.globals.maxSize: NULL
[10:18:31.821]  - attr(*, "where")=List of 5
[10:18:31.821]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.821]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.821]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.821]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.821]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.821]  - attr(*, "resolved")= logi FALSE
[10:18:31.821]  - attr(*, "total_size")= num 15670
[10:18:31.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.821]  - attr(*, "already-done")= logi TRUE
[10:18:31.827] - copied ‘...future.FUN’ to environment
[10:18:31.827] - copied ‘future.call.arguments’ to environment
[10:18:31.827] - copied ‘...future.elements_ii’ to environment
[10:18:31.827] - copied ‘...future.seeds_ii’ to environment
[10:18:31.827] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.827] assign_globals() ... done
[10:18:31.827] requestCore(): workers = 2
[10:18:31.831] MulticoreFuture started
[10:18:31.831] - Launch lazy future ... done
[10:18:31.831] plan(): Setting new future strategy stack:
[10:18:31.831] run() for ‘MulticoreFuture’ ... done
[10:18:31.832] Created future:
[10:18:31.832] List of future strategies:
[10:18:31.832] 1. sequential:
[10:18:31.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.832]    - tweaked: FALSE
[10:18:31.832]    - call: NULL
[10:18:31.833] plan(): nbrOfWorkers() = 1
[10:18:31.836] plan(): Setting new future strategy stack:
[10:18:31.836] List of future strategies:
[10:18:31.836] 1. multicore:
[10:18:31.836]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:31.836]    - tweaked: FALSE
[10:18:31.836]    - call: plan(strategy)
[10:18:31.839] plan(): nbrOfWorkers() = 2
[10:18:31.832] MulticoreFuture:
[10:18:31.832] Label: ‘future_by-1’
[10:18:31.832] Expression:
[10:18:31.832] {
[10:18:31.832]     do.call(function(...) {
[10:18:31.832]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.832]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.832]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.832]             on.exit(options(oopts), add = TRUE)
[10:18:31.832]         }
[10:18:31.832]         {
[10:18:31.832]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.832]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.832]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.832]             })
[10:18:31.832]         }
[10:18:31.832]     }, args = future.call.arguments)
[10:18:31.832] }
[10:18:31.832] Lazy evaluation: FALSE
[10:18:31.832] Asynchronous evaluation: TRUE
[10:18:31.832] Local evaluation: TRUE
[10:18:31.832] Environment: R_GlobalEnv
[10:18:31.832] Capture standard output: TRUE
[10:18:31.832] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.832] Globals: 5 objects totaling 996 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 564 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.832] Packages: <none>
[10:18:31.832] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.832] Resolved: TRUE
[10:18:31.832] Value: <not collected>
[10:18:31.832] Conditions captured: <none>
[10:18:31.832] Early signaling: FALSE
[10:18:31.832] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.832] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:31.841] Chunk #1 of 2 ... DONE
[10:18:31.841] Chunk #2 of 2 ...
[10:18:31.841]  - Finding globals in 'X' for chunk #2 ...
[10:18:31.841] getGlobalsAndPackages() ...
[10:18:31.841] Searching for globals...
[10:18:31.842] 
[10:18:31.843] Searching for globals ... DONE
[10:18:31.843] - globals: [0] <none>
[10:18:31.843] getGlobalsAndPackages() ... DONE
[10:18:31.843]    + additional globals found: [n=0] 
[10:18:31.843]    + additional namespaces needed: [n=0] 
[10:18:31.843]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:31.843]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:31.843]  - seeds: <none>
[10:18:31.844]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.844] getGlobalsAndPackages() ...
[10:18:31.844] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.844] Resolving globals: FALSE
[10:18:31.845] Tweak future expression to call with '...' arguments ...
[10:18:31.845] {
[10:18:31.845]     do.call(function(...) {
[10:18:31.845]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.845]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.845]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.845]             on.exit(options(oopts), add = TRUE)
[10:18:31.845]         }
[10:18:31.845]         {
[10:18:31.845]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.845]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.845]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.845]             })
[10:18:31.845]         }
[10:18:31.845]     }, args = future.call.arguments)
[10:18:31.845] }
[10:18:31.845] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.846] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.846] 
[10:18:31.846] getGlobalsAndPackages() ... DONE
[10:18:31.847] run() for ‘Future’ ...
[10:18:31.847] - state: ‘created’
[10:18:31.847] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.859] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:31.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:31.859]   - Field: ‘label’
[10:18:31.860]   - Field: ‘local’
[10:18:31.860]   - Field: ‘owner’
[10:18:31.860]   - Field: ‘envir’
[10:18:31.861]   - Field: ‘workers’
[10:18:31.861]   - Field: ‘packages’
[10:18:31.861]   - Field: ‘gc’
[10:18:31.861]   - Field: ‘job’
[10:18:31.862]   - Field: ‘conditions’
[10:18:31.862]   - Field: ‘expr’
[10:18:31.862]   - Field: ‘uuid’
[10:18:31.862]   - Field: ‘seed’
[10:18:31.863]   - Field: ‘version’
[10:18:31.863]   - Field: ‘result’
[10:18:31.863]   - Field: ‘asynchronous’
[10:18:31.864]   - Field: ‘calls’
[10:18:31.864]   - Field: ‘globals’
[10:18:31.864]   - Field: ‘stdout’
[10:18:31.865]   - Field: ‘earlySignal’
[10:18:31.865]   - Field: ‘lazy’
[10:18:31.865]   - Field: ‘state’
[10:18:31.865] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:31.865] - Launch lazy future ...
[10:18:31.866] Packages needed by the future expression (n = 0): <none>
[10:18:31.866] Packages needed by future strategies (n = 0): <none>
[10:18:31.867] {
[10:18:31.867]     {
[10:18:31.867]         {
[10:18:31.867]             ...future.startTime <- base::Sys.time()
[10:18:31.867]             {
[10:18:31.867]                 {
[10:18:31.867]                   {
[10:18:31.867]                     {
[10:18:31.867]                       base::local({
[10:18:31.867]                         has_future <- base::requireNamespace("future", 
[10:18:31.867]                           quietly = TRUE)
[10:18:31.867]                         if (has_future) {
[10:18:31.867]                           ns <- base::getNamespace("future")
[10:18:31.867]                           version <- ns[[".package"]][["version"]]
[10:18:31.867]                           if (is.null(version)) 
[10:18:31.867]                             version <- utils::packageVersion("future")
[10:18:31.867]                         }
[10:18:31.867]                         else {
[10:18:31.867]                           version <- NULL
[10:18:31.867]                         }
[10:18:31.867]                         if (!has_future || version < "1.8.0") {
[10:18:31.867]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.867]                             "", base::R.version$version.string), 
[10:18:31.867]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.867]                               "release", "version")], collapse = " "), 
[10:18:31.867]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.867]                             info)
[10:18:31.867]                           info <- base::paste(info, collapse = "; ")
[10:18:31.867]                           if (!has_future) {
[10:18:31.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.867]                               info)
[10:18:31.867]                           }
[10:18:31.867]                           else {
[10:18:31.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.867]                               info, version)
[10:18:31.867]                           }
[10:18:31.867]                           base::stop(msg)
[10:18:31.867]                         }
[10:18:31.867]                       })
[10:18:31.867]                     }
[10:18:31.867]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:31.867]                     base::options(mc.cores = 1L)
[10:18:31.867]                   }
[10:18:31.867]                   ...future.strategy.old <- future::plan("list")
[10:18:31.867]                   options(future.plan = NULL)
[10:18:31.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.867]                 }
[10:18:31.867]                 ...future.workdir <- getwd()
[10:18:31.867]             }
[10:18:31.867]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.867]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.867]         }
[10:18:31.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.867]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:31.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.867]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.867]             base::names(...future.oldOptions))
[10:18:31.867]     }
[10:18:31.867]     if (FALSE) {
[10:18:31.867]     }
[10:18:31.867]     else {
[10:18:31.867]         if (TRUE) {
[10:18:31.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.867]                 open = "w")
[10:18:31.867]         }
[10:18:31.867]         else {
[10:18:31.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.867]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.867]         }
[10:18:31.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.867]             base::sink(type = "output", split = FALSE)
[10:18:31.867]             base::close(...future.stdout)
[10:18:31.867]         }, add = TRUE)
[10:18:31.867]     }
[10:18:31.867]     ...future.frame <- base::sys.nframe()
[10:18:31.867]     ...future.conditions <- base::list()
[10:18:31.867]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.867]     if (FALSE) {
[10:18:31.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.867]     }
[10:18:31.867]     ...future.result <- base::tryCatch({
[10:18:31.867]         base::withCallingHandlers({
[10:18:31.867]             ...future.value <- base::withVisible(base::local({
[10:18:31.867]                 withCallingHandlers({
[10:18:31.867]                   {
[10:18:31.867]                     do.call(function(...) {
[10:18:31.867]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.867]                       if (!identical(...future.globals.maxSize.org, 
[10:18:31.867]                         ...future.globals.maxSize)) {
[10:18:31.867]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.867]                         on.exit(options(oopts), add = TRUE)
[10:18:31.867]                       }
[10:18:31.867]                       {
[10:18:31.867]                         lapply(seq_along(...future.elements_ii), 
[10:18:31.867]                           FUN = function(jj) {
[10:18:31.867]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.867]                             ...future.FUN(...future.X_jj, ...)
[10:18:31.867]                           })
[10:18:31.867]                       }
[10:18:31.867]                     }, args = future.call.arguments)
[10:18:31.867]                   }
[10:18:31.867]                 }, immediateCondition = function(cond) {
[10:18:31.867]                   save_rds <- function (object, pathname, ...) 
[10:18:31.867]                   {
[10:18:31.867]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:31.867]                     if (file_test("-f", pathname_tmp)) {
[10:18:31.867]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.867]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:31.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.867]                         fi_tmp[["mtime"]])
[10:18:31.867]                     }
[10:18:31.867]                     tryCatch({
[10:18:31.867]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:31.867]                     }, error = function(ex) {
[10:18:31.867]                       msg <- conditionMessage(ex)
[10:18:31.867]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.867]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:31.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.867]                         fi_tmp[["mtime"]], msg)
[10:18:31.867]                       ex$message <- msg
[10:18:31.867]                       stop(ex)
[10:18:31.867]                     })
[10:18:31.867]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:31.867]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:31.867]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:31.867]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.867]                       fi <- file.info(pathname)
[10:18:31.867]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:31.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.867]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:31.867]                         fi[["size"]], fi[["mtime"]])
[10:18:31.867]                       stop(msg)
[10:18:31.867]                     }
[10:18:31.867]                     invisible(pathname)
[10:18:31.867]                   }
[10:18:31.867]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:31.867]                     rootPath = tempdir()) 
[10:18:31.867]                   {
[10:18:31.867]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:31.867]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:31.867]                       tmpdir = path, fileext = ".rds")
[10:18:31.867]                     save_rds(obj, file)
[10:18:31.867]                   }
[10:18:31.867]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:31.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.867]                   {
[10:18:31.867]                     inherits <- base::inherits
[10:18:31.867]                     invokeRestart <- base::invokeRestart
[10:18:31.867]                     is.null <- base::is.null
[10:18:31.867]                     muffled <- FALSE
[10:18:31.867]                     if (inherits(cond, "message")) {
[10:18:31.867]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:31.867]                       if (muffled) 
[10:18:31.867]                         invokeRestart("muffleMessage")
[10:18:31.867]                     }
[10:18:31.867]                     else if (inherits(cond, "warning")) {
[10:18:31.867]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:31.867]                       if (muffled) 
[10:18:31.867]                         invokeRestart("muffleWarning")
[10:18:31.867]                     }
[10:18:31.867]                     else if (inherits(cond, "condition")) {
[10:18:31.867]                       if (!is.null(pattern)) {
[10:18:31.867]                         computeRestarts <- base::computeRestarts
[10:18:31.867]                         grepl <- base::grepl
[10:18:31.867]                         restarts <- computeRestarts(cond)
[10:18:31.867]                         for (restart in restarts) {
[10:18:31.867]                           name <- restart$name
[10:18:31.867]                           if (is.null(name)) 
[10:18:31.867]                             next
[10:18:31.867]                           if (!grepl(pattern, name)) 
[10:18:31.867]                             next
[10:18:31.867]                           invokeRestart(restart)
[10:18:31.867]                           muffled <- TRUE
[10:18:31.867]                           break
[10:18:31.867]                         }
[10:18:31.867]                       }
[10:18:31.867]                     }
[10:18:31.867]                     invisible(muffled)
[10:18:31.867]                   }
[10:18:31.867]                   muffleCondition(cond)
[10:18:31.867]                 })
[10:18:31.867]             }))
[10:18:31.867]             future::FutureResult(value = ...future.value$value, 
[10:18:31.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.867]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.867]                     ...future.globalenv.names))
[10:18:31.867]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.867]         }, condition = base::local({
[10:18:31.867]             c <- base::c
[10:18:31.867]             inherits <- base::inherits
[10:18:31.867]             invokeRestart <- base::invokeRestart
[10:18:31.867]             length <- base::length
[10:18:31.867]             list <- base::list
[10:18:31.867]             seq.int <- base::seq.int
[10:18:31.867]             signalCondition <- base::signalCondition
[10:18:31.867]             sys.calls <- base::sys.calls
[10:18:31.867]             `[[` <- base::`[[`
[10:18:31.867]             `+` <- base::`+`
[10:18:31.867]             `<<-` <- base::`<<-`
[10:18:31.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.867]                   3L)]
[10:18:31.867]             }
[10:18:31.867]             function(cond) {
[10:18:31.867]                 is_error <- inherits(cond, "error")
[10:18:31.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.867]                   NULL)
[10:18:31.867]                 if (is_error) {
[10:18:31.867]                   sessionInformation <- function() {
[10:18:31.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.867]                       search = base::search(), system = base::Sys.info())
[10:18:31.867]                   }
[10:18:31.867]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.867]                     cond$call), session = sessionInformation(), 
[10:18:31.867]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.867]                   signalCondition(cond)
[10:18:31.867]                 }
[10:18:31.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.867]                 "immediateCondition"))) {
[10:18:31.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.867]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.867]                   if (TRUE && !signal) {
[10:18:31.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.867]                     {
[10:18:31.867]                       inherits <- base::inherits
[10:18:31.867]                       invokeRestart <- base::invokeRestart
[10:18:31.867]                       is.null <- base::is.null
[10:18:31.867]                       muffled <- FALSE
[10:18:31.867]                       if (inherits(cond, "message")) {
[10:18:31.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.867]                         if (muffled) 
[10:18:31.867]                           invokeRestart("muffleMessage")
[10:18:31.867]                       }
[10:18:31.867]                       else if (inherits(cond, "warning")) {
[10:18:31.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.867]                         if (muffled) 
[10:18:31.867]                           invokeRestart("muffleWarning")
[10:18:31.867]                       }
[10:18:31.867]                       else if (inherits(cond, "condition")) {
[10:18:31.867]                         if (!is.null(pattern)) {
[10:18:31.867]                           computeRestarts <- base::computeRestarts
[10:18:31.867]                           grepl <- base::grepl
[10:18:31.867]                           restarts <- computeRestarts(cond)
[10:18:31.867]                           for (restart in restarts) {
[10:18:31.867]                             name <- restart$name
[10:18:31.867]                             if (is.null(name)) 
[10:18:31.867]                               next
[10:18:31.867]                             if (!grepl(pattern, name)) 
[10:18:31.867]                               next
[10:18:31.867]                             invokeRestart(restart)
[10:18:31.867]                             muffled <- TRUE
[10:18:31.867]                             break
[10:18:31.867]                           }
[10:18:31.867]                         }
[10:18:31.867]                       }
[10:18:31.867]                       invisible(muffled)
[10:18:31.867]                     }
[10:18:31.867]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.867]                   }
[10:18:31.867]                 }
[10:18:31.867]                 else {
[10:18:31.867]                   if (TRUE) {
[10:18:31.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.867]                     {
[10:18:31.867]                       inherits <- base::inherits
[10:18:31.867]                       invokeRestart <- base::invokeRestart
[10:18:31.867]                       is.null <- base::is.null
[10:18:31.867]                       muffled <- FALSE
[10:18:31.867]                       if (inherits(cond, "message")) {
[10:18:31.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.867]                         if (muffled) 
[10:18:31.867]                           invokeRestart("muffleMessage")
[10:18:31.867]                       }
[10:18:31.867]                       else if (inherits(cond, "warning")) {
[10:18:31.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.867]                         if (muffled) 
[10:18:31.867]                           invokeRestart("muffleWarning")
[10:18:31.867]                       }
[10:18:31.867]                       else if (inherits(cond, "condition")) {
[10:18:31.867]                         if (!is.null(pattern)) {
[10:18:31.867]                           computeRestarts <- base::computeRestarts
[10:18:31.867]                           grepl <- base::grepl
[10:18:31.867]                           restarts <- computeRestarts(cond)
[10:18:31.867]                           for (restart in restarts) {
[10:18:31.867]                             name <- restart$name
[10:18:31.867]                             if (is.null(name)) 
[10:18:31.867]                               next
[10:18:31.867]                             if (!grepl(pattern, name)) 
[10:18:31.867]                               next
[10:18:31.867]                             invokeRestart(restart)
[10:18:31.867]                             muffled <- TRUE
[10:18:31.867]                             break
[10:18:31.867]                           }
[10:18:31.867]                         }
[10:18:31.867]                       }
[10:18:31.867]                       invisible(muffled)
[10:18:31.867]                     }
[10:18:31.867]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.867]                   }
[10:18:31.867]                 }
[10:18:31.867]             }
[10:18:31.867]         }))
[10:18:31.867]     }, error = function(ex) {
[10:18:31.867]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.867]                 ...future.rng), started = ...future.startTime, 
[10:18:31.867]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.867]             version = "1.8"), class = "FutureResult")
[10:18:31.867]     }, finally = {
[10:18:31.867]         if (!identical(...future.workdir, getwd())) 
[10:18:31.867]             setwd(...future.workdir)
[10:18:31.867]         {
[10:18:31.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.867]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.867]             }
[10:18:31.867]             base::options(...future.oldOptions)
[10:18:31.867]             if (.Platform$OS.type == "windows") {
[10:18:31.867]                 old_names <- names(...future.oldEnvVars)
[10:18:31.867]                 envs <- base::Sys.getenv()
[10:18:31.867]                 names <- names(envs)
[10:18:31.867]                 common <- intersect(names, old_names)
[10:18:31.867]                 added <- setdiff(names, old_names)
[10:18:31.867]                 removed <- setdiff(old_names, names)
[10:18:31.867]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.867]                   envs[common]]
[10:18:31.867]                 NAMES <- toupper(changed)
[10:18:31.867]                 args <- list()
[10:18:31.867]                 for (kk in seq_along(NAMES)) {
[10:18:31.867]                   name <- changed[[kk]]
[10:18:31.867]                   NAME <- NAMES[[kk]]
[10:18:31.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.867]                     next
[10:18:31.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.867]                 }
[10:18:31.867]                 NAMES <- toupper(added)
[10:18:31.867]                 for (kk in seq_along(NAMES)) {
[10:18:31.867]                   name <- added[[kk]]
[10:18:31.867]                   NAME <- NAMES[[kk]]
[10:18:31.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.867]                     next
[10:18:31.867]                   args[[name]] <- ""
[10:18:31.867]                 }
[10:18:31.867]                 NAMES <- toupper(removed)
[10:18:31.867]                 for (kk in seq_along(NAMES)) {
[10:18:31.867]                   name <- removed[[kk]]
[10:18:31.867]                   NAME <- NAMES[[kk]]
[10:18:31.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.867]                     next
[10:18:31.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.867]                 }
[10:18:31.867]                 if (length(args) > 0) 
[10:18:31.867]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.867]             }
[10:18:31.867]             else {
[10:18:31.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.867]             }
[10:18:31.867]             {
[10:18:31.867]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.867]                   0L) {
[10:18:31.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.867]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.867]                   base::options(opts)
[10:18:31.867]                 }
[10:18:31.867]                 {
[10:18:31.867]                   {
[10:18:31.867]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:31.867]                     NULL
[10:18:31.867]                   }
[10:18:31.867]                   options(future.plan = NULL)
[10:18:31.867]                   if (is.na(NA_character_)) 
[10:18:31.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.867]                     .init = FALSE)
[10:18:31.867]                 }
[10:18:31.867]             }
[10:18:31.867]         }
[10:18:31.867]     })
[10:18:31.867]     if (TRUE) {
[10:18:31.867]         base::sink(type = "output", split = FALSE)
[10:18:31.867]         if (TRUE) {
[10:18:31.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.867]         }
[10:18:31.867]         else {
[10:18:31.867]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.867]         }
[10:18:31.867]         base::close(...future.stdout)
[10:18:31.867]         ...future.stdout <- NULL
[10:18:31.867]     }
[10:18:31.867]     ...future.result$conditions <- ...future.conditions
[10:18:31.867]     ...future.result$finished <- base::Sys.time()
[10:18:31.867]     ...future.result
[10:18:31.867] }
[10:18:31.870] assign_globals() ...
[10:18:31.870] List of 5
[10:18:31.870]  $ ...future.FUN            :function (object, ...)  
[10:18:31.870]  $ future.call.arguments    : list()
[10:18:31.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.870]  $ ...future.elements_ii    :List of 2
[10:18:31.870]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.870]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:31.870]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.870]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:18:31.870]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:31.870]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:31.870]  $ ...future.seeds_ii       : NULL
[10:18:31.870]  $ ...future.globals.maxSize: NULL
[10:18:31.870]  - attr(*, "where")=List of 5
[10:18:31.870]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.870]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.870]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.870]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.870]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.870]  - attr(*, "resolved")= logi FALSE
[10:18:31.870]  - attr(*, "total_size")= num 15670
[10:18:31.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.870]  - attr(*, "already-done")= logi TRUE
[10:18:31.881] - copied ‘...future.FUN’ to environment
[10:18:31.881] - copied ‘future.call.arguments’ to environment
[10:18:31.881] - copied ‘...future.elements_ii’ to environment
[10:18:31.881] - copied ‘...future.seeds_ii’ to environment
[10:18:31.881] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.881] assign_globals() ... done
[10:18:31.882] requestCore(): workers = 2
[10:18:31.887] MulticoreFuture started
[10:18:31.888] - Launch lazy future ... done
[10:18:31.888] run() for ‘MulticoreFuture’ ... done
[10:18:31.888] plan(): Setting new future strategy stack:
[10:18:31.888] Created future:
[10:18:31.888] List of future strategies:
[10:18:31.888] 1. sequential:
[10:18:31.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.888]    - tweaked: FALSE
[10:18:31.888]    - call: NULL
[10:18:31.889] plan(): nbrOfWorkers() = 1
[10:18:31.893] plan(): Setting new future strategy stack:
[10:18:31.893] List of future strategies:
[10:18:31.893] 1. multicore:
[10:18:31.893]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:31.893]    - tweaked: FALSE
[10:18:31.893]    - call: plan(strategy)
[10:18:31.889] MulticoreFuture:
[10:18:31.889] Label: ‘future_by-2’
[10:18:31.889] Expression:
[10:18:31.889] {
[10:18:31.889]     do.call(function(...) {
[10:18:31.889]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.889]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.889]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.889]             on.exit(options(oopts), add = TRUE)
[10:18:31.889]         }
[10:18:31.889]         {
[10:18:31.889]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.889]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.889]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.889]             })
[10:18:31.889]         }
[10:18:31.889]     }, args = future.call.arguments)
[10:18:31.889] }
[10:18:31.889] Lazy evaluation: FALSE
[10:18:31.889] Asynchronous evaluation: TRUE
[10:18:31.889] Local evaluation: TRUE
[10:18:31.889] Environment: R_GlobalEnv
[10:18:31.889] Capture standard output: TRUE
[10:18:31.889] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.889] Globals: 5 objects totaling 1.44 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.02 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.889] Packages: <none>
[10:18:31.889] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.889] Resolved: FALSE
[10:18:31.889] Value: <not collected>
[10:18:31.889] Conditions captured: <none>
[10:18:31.889] Early signaling: FALSE
[10:18:31.889] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.889] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:31.902] Chunk #2 of 2 ... DONE
[10:18:31.902] Launching 2 futures (chunks) ... DONE
[10:18:31.902] Resolving 2 futures (chunks) ...
[10:18:31.902] resolve() on list ...
[10:18:31.902]  recursive: 0
[10:18:31.902] plan(): nbrOfWorkers() = 2
[10:18:31.903]  length: 2
[10:18:31.903] 
[10:18:31.903] Future #1
[10:18:31.904] result() for MulticoreFuture ...
[10:18:31.908] result() for MulticoreFuture ...
[10:18:31.908] result() for MulticoreFuture ... done
[10:18:31.908] result() for MulticoreFuture ... done
[10:18:31.909] result() for MulticoreFuture ...
[10:18:31.909] result() for MulticoreFuture ... done
[10:18:31.909] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:31.909] - nx: 2
[10:18:31.909] - relay: TRUE
[10:18:31.910] - stdout: TRUE
[10:18:31.910] - signal: TRUE
[10:18:31.910] - resignal: FALSE
[10:18:31.911] - force: TRUE
[10:18:31.911] - relayed: [n=2] FALSE, FALSE
[10:18:31.911] - queued futures: [n=2] FALSE, FALSE
[10:18:31.911]  - until=1
[10:18:31.912]  - relaying element #1
[10:18:31.912] result() for MulticoreFuture ...
[10:18:31.912] result() for MulticoreFuture ... done
[10:18:31.912] result() for MulticoreFuture ...
[10:18:31.912] result() for MulticoreFuture ... done
[10:18:31.913] result() for MulticoreFuture ...
[10:18:31.913] result() for MulticoreFuture ... done
[10:18:31.913] result() for MulticoreFuture ...
[10:18:31.914] result() for MulticoreFuture ... done
[10:18:31.914] - relayed: [n=2] TRUE, FALSE
[10:18:31.914] - queued futures: [n=2] TRUE, FALSE
[10:18:31.914] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:31.915]  length: 1 (resolved future 1)
[10:18:31.915] Future #2
[10:18:31.915] result() for MulticoreFuture ...
[10:18:31.916] result() for MulticoreFuture ...
[10:18:31.916] result() for MulticoreFuture ... done
[10:18:31.917] result() for MulticoreFuture ... done
[10:18:31.917] result() for MulticoreFuture ...
[10:18:31.917] result() for MulticoreFuture ... done
[10:18:31.917] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:31.918] - nx: 2
[10:18:31.918] - relay: TRUE
[10:18:31.918] - stdout: TRUE
[10:18:31.918] - signal: TRUE
[10:18:31.918] - resignal: FALSE
[10:18:31.918] - force: TRUE
[10:18:31.919] - relayed: [n=2] TRUE, FALSE
[10:18:31.919] - queued futures: [n=2] TRUE, FALSE
[10:18:31.919]  - until=2
[10:18:31.919]  - relaying element #2
[10:18:31.919] result() for MulticoreFuture ...
[10:18:31.919] result() for MulticoreFuture ... done
[10:18:31.919] result() for MulticoreFuture ...
[10:18:31.920] result() for MulticoreFuture ... done
[10:18:31.920] result() for MulticoreFuture ...
[10:18:31.920] result() for MulticoreFuture ... done
[10:18:31.920] result() for MulticoreFuture ...
[10:18:31.920] result() for MulticoreFuture ... done
[10:18:31.920] - relayed: [n=2] TRUE, TRUE
[10:18:31.921] - queued futures: [n=2] TRUE, TRUE
[10:18:31.921] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:31.921]  length: 0 (resolved future 2)
[10:18:31.921] Relaying remaining futures
[10:18:31.921] signalConditionsASAP(NULL, pos=0) ...
[10:18:31.921] - nx: 2
[10:18:31.921] - relay: TRUE
[10:18:31.921] - stdout: TRUE
[10:18:31.921] - signal: TRUE
[10:18:31.921] - resignal: FALSE
[10:18:31.922] - force: TRUE
[10:18:31.922] - relayed: [n=2] TRUE, TRUE
[10:18:31.922] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:31.922] - relayed: [n=2] TRUE, TRUE
[10:18:31.922] - queued futures: [n=2] TRUE, TRUE
[10:18:31.922] signalConditionsASAP(NULL, pos=0) ... done
[10:18:31.922] resolve() on list ... DONE
[10:18:31.922] result() for MulticoreFuture ...
[10:18:31.922] result() for MulticoreFuture ... done
[10:18:31.923] result() for MulticoreFuture ...
[10:18:31.923] result() for MulticoreFuture ... done
[10:18:31.923] result() for MulticoreFuture ...
[10:18:31.923] result() for MulticoreFuture ... done
[10:18:31.923] result() for MulticoreFuture ...
[10:18:31.923] result() for MulticoreFuture ... done
[10:18:31.923]  - Number of value chunks collected: 2
[10:18:31.923] Resolving 2 futures (chunks) ... DONE
[10:18:31.923] Reducing values from 2 chunks ...
[10:18:31.923]  - Number of values collected after concatenation: 3
[10:18:31.924]  - Number of values expected: 3
[10:18:31.924] Reducing values from 2 chunks ... DONE
[10:18:31.924] future_lapply() ... DONE
[10:18:31.924] future_by_internal() ... DONE
[10:18:31.924] future_by_internal() ...
[10:18:31.925] future_lapply() ...
[10:18:31.927] Number of chunks: 2
[10:18:31.927] getGlobalsAndPackagesXApply() ...
[10:18:31.927]  - future.globals: TRUE
[10:18:31.928] getGlobalsAndPackages() ...
[10:18:31.928] Searching for globals...
[10:18:31.929] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:31.929] Searching for globals ... DONE
[10:18:31.929] Resolving globals: FALSE
[10:18:31.930] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:31.930] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:31.930] - globals: [1] ‘FUN’
[10:18:31.930] 
[10:18:31.930] getGlobalsAndPackages() ... DONE
[10:18:31.930]  - globals found/used: [n=1] ‘FUN’
[10:18:31.930]  - needed namespaces: [n=0] 
[10:18:31.931] Finding globals ... DONE
[10:18:31.931]  - use_args: TRUE
[10:18:31.931]  - Getting '...' globals ...
[10:18:31.931] resolve() on list ...
[10:18:31.931]  recursive: 0
[10:18:31.931]  length: 1
[10:18:31.931]  elements: ‘...’
[10:18:31.932]  length: 0 (resolved future 1)
[10:18:31.932] resolve() on list ... DONE
[10:18:31.932]    - '...' content: [n=1] ‘digits’
[10:18:31.932] List of 1
[10:18:31.932]  $ ...:List of 1
[10:18:31.932]   ..$ digits: int 2
[10:18:31.932]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.932]  - attr(*, "where")=List of 1
[10:18:31.932]   ..$ ...:<environment: 0x558447f03f38> 
[10:18:31.932]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.932]  - attr(*, "resolved")= logi TRUE
[10:18:31.932]  - attr(*, "total_size")= num NA
[10:18:31.937]  - Getting '...' globals ... DONE
[10:18:31.937] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:31.937] List of 2
[10:18:31.937]  $ ...future.FUN:function (object, ...)  
[10:18:31.937]  $ ...          :List of 1
[10:18:31.937]   ..$ digits: int 2
[10:18:31.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.937]  - attr(*, "where")=List of 2
[10:18:31.937]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:31.937]   ..$ ...          :<environment: 0x558447f03f38> 
[10:18:31.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.937]  - attr(*, "resolved")= logi FALSE
[10:18:31.937]  - attr(*, "total_size")= num 13284
[10:18:31.941] Packages to be attached in all futures: [n=0] 
[10:18:31.941] getGlobalsAndPackagesXApply() ... DONE
[10:18:31.941] Number of futures (= number of chunks): 2
[10:18:31.941] Launching 2 futures (chunks) ...
[10:18:31.941] Chunk #1 of 2 ...
[10:18:31.941]  - Finding globals in 'X' for chunk #1 ...
[10:18:31.941] getGlobalsAndPackages() ...
[10:18:31.942] Searching for globals...
[10:18:31.942] 
[10:18:31.942] Searching for globals ... DONE
[10:18:31.942] - globals: [0] <none>
[10:18:31.942] getGlobalsAndPackages() ... DONE
[10:18:31.942]    + additional globals found: [n=0] 
[10:18:31.942]    + additional namespaces needed: [n=0] 
[10:18:31.942]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:31.943]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:31.943]  - seeds: <none>
[10:18:31.943]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.943] getGlobalsAndPackages() ...
[10:18:31.943] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.943] Resolving globals: FALSE
[10:18:31.943] Tweak future expression to call with '...' arguments ...
[10:18:31.943] {
[10:18:31.943]     do.call(function(...) {
[10:18:31.943]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.943]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.943]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.943]             on.exit(options(oopts), add = TRUE)
[10:18:31.943]         }
[10:18:31.943]         {
[10:18:31.943]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.943]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.943]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.943]             })
[10:18:31.943]         }
[10:18:31.943]     }, args = future.call.arguments)
[10:18:31.943] }
[10:18:31.944] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.944] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.944] 
[10:18:31.944] getGlobalsAndPackages() ... DONE
[10:18:31.945] run() for ‘Future’ ...
[10:18:31.945] - state: ‘created’
[10:18:31.945] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.947] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:31.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:31.947]   - Field: ‘label’
[10:18:31.947]   - Field: ‘local’
[10:18:31.947]   - Field: ‘owner’
[10:18:31.947]   - Field: ‘envir’
[10:18:31.947]   - Field: ‘workers’
[10:18:31.947]   - Field: ‘packages’
[10:18:31.948]   - Field: ‘gc’
[10:18:31.948]   - Field: ‘job’
[10:18:31.948]   - Field: ‘conditions’
[10:18:31.948]   - Field: ‘expr’
[10:18:31.948]   - Field: ‘uuid’
[10:18:31.948]   - Field: ‘seed’
[10:18:31.948]   - Field: ‘version’
[10:18:31.948]   - Field: ‘result’
[10:18:31.948]   - Field: ‘asynchronous’
[10:18:31.948]   - Field: ‘calls’
[10:18:31.949]   - Field: ‘globals’
[10:18:31.949]   - Field: ‘stdout’
[10:18:31.949]   - Field: ‘earlySignal’
[10:18:31.949]   - Field: ‘lazy’
[10:18:31.949]   - Field: ‘state’
[10:18:31.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:31.949] - Launch lazy future ...
[10:18:31.949] Packages needed by the future expression (n = 0): <none>
[10:18:31.949] Packages needed by future strategies (n = 0): <none>
[10:18:31.950] {
[10:18:31.950]     {
[10:18:31.950]         {
[10:18:31.950]             ...future.startTime <- base::Sys.time()
[10:18:31.950]             {
[10:18:31.950]                 {
[10:18:31.950]                   {
[10:18:31.950]                     {
[10:18:31.950]                       base::local({
[10:18:31.950]                         has_future <- base::requireNamespace("future", 
[10:18:31.950]                           quietly = TRUE)
[10:18:31.950]                         if (has_future) {
[10:18:31.950]                           ns <- base::getNamespace("future")
[10:18:31.950]                           version <- ns[[".package"]][["version"]]
[10:18:31.950]                           if (is.null(version)) 
[10:18:31.950]                             version <- utils::packageVersion("future")
[10:18:31.950]                         }
[10:18:31.950]                         else {
[10:18:31.950]                           version <- NULL
[10:18:31.950]                         }
[10:18:31.950]                         if (!has_future || version < "1.8.0") {
[10:18:31.950]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.950]                             "", base::R.version$version.string), 
[10:18:31.950]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.950]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.950]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.950]                               "release", "version")], collapse = " "), 
[10:18:31.950]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.950]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.950]                             info)
[10:18:31.950]                           info <- base::paste(info, collapse = "; ")
[10:18:31.950]                           if (!has_future) {
[10:18:31.950]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.950]                               info)
[10:18:31.950]                           }
[10:18:31.950]                           else {
[10:18:31.950]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.950]                               info, version)
[10:18:31.950]                           }
[10:18:31.950]                           base::stop(msg)
[10:18:31.950]                         }
[10:18:31.950]                       })
[10:18:31.950]                     }
[10:18:31.950]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:31.950]                     base::options(mc.cores = 1L)
[10:18:31.950]                   }
[10:18:31.950]                   ...future.strategy.old <- future::plan("list")
[10:18:31.950]                   options(future.plan = NULL)
[10:18:31.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.950]                 }
[10:18:31.950]                 ...future.workdir <- getwd()
[10:18:31.950]             }
[10:18:31.950]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.950]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.950]         }
[10:18:31.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.950]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:31.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.950]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.950]             base::names(...future.oldOptions))
[10:18:31.950]     }
[10:18:31.950]     if (FALSE) {
[10:18:31.950]     }
[10:18:31.950]     else {
[10:18:31.950]         if (TRUE) {
[10:18:31.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.950]                 open = "w")
[10:18:31.950]         }
[10:18:31.950]         else {
[10:18:31.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.950]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.950]         }
[10:18:31.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.950]             base::sink(type = "output", split = FALSE)
[10:18:31.950]             base::close(...future.stdout)
[10:18:31.950]         }, add = TRUE)
[10:18:31.950]     }
[10:18:31.950]     ...future.frame <- base::sys.nframe()
[10:18:31.950]     ...future.conditions <- base::list()
[10:18:31.950]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.950]     if (FALSE) {
[10:18:31.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.950]     }
[10:18:31.950]     ...future.result <- base::tryCatch({
[10:18:31.950]         base::withCallingHandlers({
[10:18:31.950]             ...future.value <- base::withVisible(base::local({
[10:18:31.950]                 withCallingHandlers({
[10:18:31.950]                   {
[10:18:31.950]                     do.call(function(...) {
[10:18:31.950]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.950]                       if (!identical(...future.globals.maxSize.org, 
[10:18:31.950]                         ...future.globals.maxSize)) {
[10:18:31.950]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.950]                         on.exit(options(oopts), add = TRUE)
[10:18:31.950]                       }
[10:18:31.950]                       {
[10:18:31.950]                         lapply(seq_along(...future.elements_ii), 
[10:18:31.950]                           FUN = function(jj) {
[10:18:31.950]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.950]                             ...future.FUN(...future.X_jj, ...)
[10:18:31.950]                           })
[10:18:31.950]                       }
[10:18:31.950]                     }, args = future.call.arguments)
[10:18:31.950]                   }
[10:18:31.950]                 }, immediateCondition = function(cond) {
[10:18:31.950]                   save_rds <- function (object, pathname, ...) 
[10:18:31.950]                   {
[10:18:31.950]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:31.950]                     if (file_test("-f", pathname_tmp)) {
[10:18:31.950]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.950]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:31.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.950]                         fi_tmp[["mtime"]])
[10:18:31.950]                     }
[10:18:31.950]                     tryCatch({
[10:18:31.950]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:31.950]                     }, error = function(ex) {
[10:18:31.950]                       msg <- conditionMessage(ex)
[10:18:31.950]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.950]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:31.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.950]                         fi_tmp[["mtime"]], msg)
[10:18:31.950]                       ex$message <- msg
[10:18:31.950]                       stop(ex)
[10:18:31.950]                     })
[10:18:31.950]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:31.950]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:31.950]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:31.950]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.950]                       fi <- file.info(pathname)
[10:18:31.950]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:31.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.950]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:31.950]                         fi[["size"]], fi[["mtime"]])
[10:18:31.950]                       stop(msg)
[10:18:31.950]                     }
[10:18:31.950]                     invisible(pathname)
[10:18:31.950]                   }
[10:18:31.950]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:31.950]                     rootPath = tempdir()) 
[10:18:31.950]                   {
[10:18:31.950]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:31.950]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:31.950]                       tmpdir = path, fileext = ".rds")
[10:18:31.950]                     save_rds(obj, file)
[10:18:31.950]                   }
[10:18:31.950]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:31.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.950]                   {
[10:18:31.950]                     inherits <- base::inherits
[10:18:31.950]                     invokeRestart <- base::invokeRestart
[10:18:31.950]                     is.null <- base::is.null
[10:18:31.950]                     muffled <- FALSE
[10:18:31.950]                     if (inherits(cond, "message")) {
[10:18:31.950]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:31.950]                       if (muffled) 
[10:18:31.950]                         invokeRestart("muffleMessage")
[10:18:31.950]                     }
[10:18:31.950]                     else if (inherits(cond, "warning")) {
[10:18:31.950]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:31.950]                       if (muffled) 
[10:18:31.950]                         invokeRestart("muffleWarning")
[10:18:31.950]                     }
[10:18:31.950]                     else if (inherits(cond, "condition")) {
[10:18:31.950]                       if (!is.null(pattern)) {
[10:18:31.950]                         computeRestarts <- base::computeRestarts
[10:18:31.950]                         grepl <- base::grepl
[10:18:31.950]                         restarts <- computeRestarts(cond)
[10:18:31.950]                         for (restart in restarts) {
[10:18:31.950]                           name <- restart$name
[10:18:31.950]                           if (is.null(name)) 
[10:18:31.950]                             next
[10:18:31.950]                           if (!grepl(pattern, name)) 
[10:18:31.950]                             next
[10:18:31.950]                           invokeRestart(restart)
[10:18:31.950]                           muffled <- TRUE
[10:18:31.950]                           break
[10:18:31.950]                         }
[10:18:31.950]                       }
[10:18:31.950]                     }
[10:18:31.950]                     invisible(muffled)
[10:18:31.950]                   }
[10:18:31.950]                   muffleCondition(cond)
[10:18:31.950]                 })
[10:18:31.950]             }))
[10:18:31.950]             future::FutureResult(value = ...future.value$value, 
[10:18:31.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.950]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.950]                     ...future.globalenv.names))
[10:18:31.950]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.950]         }, condition = base::local({
[10:18:31.950]             c <- base::c
[10:18:31.950]             inherits <- base::inherits
[10:18:31.950]             invokeRestart <- base::invokeRestart
[10:18:31.950]             length <- base::length
[10:18:31.950]             list <- base::list
[10:18:31.950]             seq.int <- base::seq.int
[10:18:31.950]             signalCondition <- base::signalCondition
[10:18:31.950]             sys.calls <- base::sys.calls
[10:18:31.950]             `[[` <- base::`[[`
[10:18:31.950]             `+` <- base::`+`
[10:18:31.950]             `<<-` <- base::`<<-`
[10:18:31.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.950]                   3L)]
[10:18:31.950]             }
[10:18:31.950]             function(cond) {
[10:18:31.950]                 is_error <- inherits(cond, "error")
[10:18:31.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.950]                   NULL)
[10:18:31.950]                 if (is_error) {
[10:18:31.950]                   sessionInformation <- function() {
[10:18:31.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.950]                       search = base::search(), system = base::Sys.info())
[10:18:31.950]                   }
[10:18:31.950]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.950]                     cond$call), session = sessionInformation(), 
[10:18:31.950]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.950]                   signalCondition(cond)
[10:18:31.950]                 }
[10:18:31.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.950]                 "immediateCondition"))) {
[10:18:31.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.950]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.950]                   if (TRUE && !signal) {
[10:18:31.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.950]                     {
[10:18:31.950]                       inherits <- base::inherits
[10:18:31.950]                       invokeRestart <- base::invokeRestart
[10:18:31.950]                       is.null <- base::is.null
[10:18:31.950]                       muffled <- FALSE
[10:18:31.950]                       if (inherits(cond, "message")) {
[10:18:31.950]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.950]                         if (muffled) 
[10:18:31.950]                           invokeRestart("muffleMessage")
[10:18:31.950]                       }
[10:18:31.950]                       else if (inherits(cond, "warning")) {
[10:18:31.950]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.950]                         if (muffled) 
[10:18:31.950]                           invokeRestart("muffleWarning")
[10:18:31.950]                       }
[10:18:31.950]                       else if (inherits(cond, "condition")) {
[10:18:31.950]                         if (!is.null(pattern)) {
[10:18:31.950]                           computeRestarts <- base::computeRestarts
[10:18:31.950]                           grepl <- base::grepl
[10:18:31.950]                           restarts <- computeRestarts(cond)
[10:18:31.950]                           for (restart in restarts) {
[10:18:31.950]                             name <- restart$name
[10:18:31.950]                             if (is.null(name)) 
[10:18:31.950]                               next
[10:18:31.950]                             if (!grepl(pattern, name)) 
[10:18:31.950]                               next
[10:18:31.950]                             invokeRestart(restart)
[10:18:31.950]                             muffled <- TRUE
[10:18:31.950]                             break
[10:18:31.950]                           }
[10:18:31.950]                         }
[10:18:31.950]                       }
[10:18:31.950]                       invisible(muffled)
[10:18:31.950]                     }
[10:18:31.950]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.950]                   }
[10:18:31.950]                 }
[10:18:31.950]                 else {
[10:18:31.950]                   if (TRUE) {
[10:18:31.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.950]                     {
[10:18:31.950]                       inherits <- base::inherits
[10:18:31.950]                       invokeRestart <- base::invokeRestart
[10:18:31.950]                       is.null <- base::is.null
[10:18:31.950]                       muffled <- FALSE
[10:18:31.950]                       if (inherits(cond, "message")) {
[10:18:31.950]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.950]                         if (muffled) 
[10:18:31.950]                           invokeRestart("muffleMessage")
[10:18:31.950]                       }
[10:18:31.950]                       else if (inherits(cond, "warning")) {
[10:18:31.950]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.950]                         if (muffled) 
[10:18:31.950]                           invokeRestart("muffleWarning")
[10:18:31.950]                       }
[10:18:31.950]                       else if (inherits(cond, "condition")) {
[10:18:31.950]                         if (!is.null(pattern)) {
[10:18:31.950]                           computeRestarts <- base::computeRestarts
[10:18:31.950]                           grepl <- base::grepl
[10:18:31.950]                           restarts <- computeRestarts(cond)
[10:18:31.950]                           for (restart in restarts) {
[10:18:31.950]                             name <- restart$name
[10:18:31.950]                             if (is.null(name)) 
[10:18:31.950]                               next
[10:18:31.950]                             if (!grepl(pattern, name)) 
[10:18:31.950]                               next
[10:18:31.950]                             invokeRestart(restart)
[10:18:31.950]                             muffled <- TRUE
[10:18:31.950]                             break
[10:18:31.950]                           }
[10:18:31.950]                         }
[10:18:31.950]                       }
[10:18:31.950]                       invisible(muffled)
[10:18:31.950]                     }
[10:18:31.950]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.950]                   }
[10:18:31.950]                 }
[10:18:31.950]             }
[10:18:31.950]         }))
[10:18:31.950]     }, error = function(ex) {
[10:18:31.950]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.950]                 ...future.rng), started = ...future.startTime, 
[10:18:31.950]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.950]             version = "1.8"), class = "FutureResult")
[10:18:31.950]     }, finally = {
[10:18:31.950]         if (!identical(...future.workdir, getwd())) 
[10:18:31.950]             setwd(...future.workdir)
[10:18:31.950]         {
[10:18:31.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.950]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.950]             }
[10:18:31.950]             base::options(...future.oldOptions)
[10:18:31.950]             if (.Platform$OS.type == "windows") {
[10:18:31.950]                 old_names <- names(...future.oldEnvVars)
[10:18:31.950]                 envs <- base::Sys.getenv()
[10:18:31.950]                 names <- names(envs)
[10:18:31.950]                 common <- intersect(names, old_names)
[10:18:31.950]                 added <- setdiff(names, old_names)
[10:18:31.950]                 removed <- setdiff(old_names, names)
[10:18:31.950]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.950]                   envs[common]]
[10:18:31.950]                 NAMES <- toupper(changed)
[10:18:31.950]                 args <- list()
[10:18:31.950]                 for (kk in seq_along(NAMES)) {
[10:18:31.950]                   name <- changed[[kk]]
[10:18:31.950]                   NAME <- NAMES[[kk]]
[10:18:31.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.950]                     next
[10:18:31.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.950]                 }
[10:18:31.950]                 NAMES <- toupper(added)
[10:18:31.950]                 for (kk in seq_along(NAMES)) {
[10:18:31.950]                   name <- added[[kk]]
[10:18:31.950]                   NAME <- NAMES[[kk]]
[10:18:31.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.950]                     next
[10:18:31.950]                   args[[name]] <- ""
[10:18:31.950]                 }
[10:18:31.950]                 NAMES <- toupper(removed)
[10:18:31.950]                 for (kk in seq_along(NAMES)) {
[10:18:31.950]                   name <- removed[[kk]]
[10:18:31.950]                   NAME <- NAMES[[kk]]
[10:18:31.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.950]                     next
[10:18:31.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.950]                 }
[10:18:31.950]                 if (length(args) > 0) 
[10:18:31.950]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.950]             }
[10:18:31.950]             else {
[10:18:31.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.950]             }
[10:18:31.950]             {
[10:18:31.950]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.950]                   0L) {
[10:18:31.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.950]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.950]                   base::options(opts)
[10:18:31.950]                 }
[10:18:31.950]                 {
[10:18:31.950]                   {
[10:18:31.950]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:31.950]                     NULL
[10:18:31.950]                   }
[10:18:31.950]                   options(future.plan = NULL)
[10:18:31.950]                   if (is.na(NA_character_)) 
[10:18:31.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.950]                     .init = FALSE)
[10:18:31.950]                 }
[10:18:31.950]             }
[10:18:31.950]         }
[10:18:31.950]     })
[10:18:31.950]     if (TRUE) {
[10:18:31.950]         base::sink(type = "output", split = FALSE)
[10:18:31.950]         if (TRUE) {
[10:18:31.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.950]         }
[10:18:31.950]         else {
[10:18:31.950]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.950]         }
[10:18:31.950]         base::close(...future.stdout)
[10:18:31.950]         ...future.stdout <- NULL
[10:18:31.950]     }
[10:18:31.950]     ...future.result$conditions <- ...future.conditions
[10:18:31.950]     ...future.result$finished <- base::Sys.time()
[10:18:31.950]     ...future.result
[10:18:31.950] }
[10:18:31.952] assign_globals() ...
[10:18:31.953] List of 5
[10:18:31.953]  $ ...future.FUN            :function (object, ...)  
[10:18:31.953]  $ future.call.arguments    :List of 1
[10:18:31.953]   ..$ digits: int 2
[10:18:31.953]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.953]  $ ...future.elements_ii    :List of 3
[10:18:31.953]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:18:31.953]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:18:31.953]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:18:31.953]  $ ...future.seeds_ii       : NULL
[10:18:31.953]  $ ...future.globals.maxSize: NULL
[10:18:31.953]  - attr(*, "where")=List of 5
[10:18:31.953]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.953]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.953]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.953]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.953]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.953]  - attr(*, "resolved")= logi FALSE
[10:18:31.953]  - attr(*, "total_size")= num 13284
[10:18:31.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.953]  - attr(*, "already-done")= logi TRUE
[10:18:31.960] - copied ‘...future.FUN’ to environment
[10:18:31.961] - copied ‘future.call.arguments’ to environment
[10:18:31.961] - copied ‘...future.elements_ii’ to environment
[10:18:31.961] - copied ‘...future.seeds_ii’ to environment
[10:18:31.961] - copied ‘...future.globals.maxSize’ to environment
[10:18:31.961] assign_globals() ... done
[10:18:31.961] requestCore(): workers = 2
[10:18:31.964] MulticoreFuture started
[10:18:31.965] - Launch lazy future ... done
[10:18:31.965] plan(): Setting new future strategy stack:
[10:18:31.965] run() for ‘MulticoreFuture’ ... done
[10:18:31.966] Created future:
[10:18:31.966] List of future strategies:
[10:18:31.966] 1. sequential:
[10:18:31.966]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:31.966]    - tweaked: FALSE
[10:18:31.966]    - call: NULL
[10:18:31.968] plan(): nbrOfWorkers() = 1
[10:18:31.972] plan(): Setting new future strategy stack:
[10:18:31.973] List of future strategies:
[10:18:31.973] 1. multicore:
[10:18:31.973]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:31.973]    - tweaked: FALSE
[10:18:31.973]    - call: plan(strategy)
[10:18:31.976] plan(): nbrOfWorkers() = 2
[10:18:31.967] MulticoreFuture:
[10:18:31.967] Label: ‘future_by-1’
[10:18:31.967] Expression:
[10:18:31.967] {
[10:18:31.967]     do.call(function(...) {
[10:18:31.967]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.967]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.967]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.967]             on.exit(options(oopts), add = TRUE)
[10:18:31.967]         }
[10:18:31.967]         {
[10:18:31.967]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.967]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.967]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.967]             })
[10:18:31.967]         }
[10:18:31.967]     }, args = future.call.arguments)
[10:18:31.967] }
[10:18:31.967] Lazy evaluation: FALSE
[10:18:31.967] Asynchronous evaluation: TRUE
[10:18:31.967] Local evaluation: TRUE
[10:18:31.967] Environment: R_GlobalEnv
[10:18:31.967] Capture standard output: TRUE
[10:18:31.967] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:31.967] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:31.967] Packages: <none>
[10:18:31.967] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:31.967] Resolved: TRUE
[10:18:31.967] Value: <not collected>
[10:18:31.967] Conditions captured: <none>
[10:18:31.967] Early signaling: FALSE
[10:18:31.967] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:31.967] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:31.978] Chunk #1 of 2 ... DONE
[10:18:31.978] Chunk #2 of 2 ...
[10:18:31.978]  - Finding globals in 'X' for chunk #2 ...
[10:18:31.978] getGlobalsAndPackages() ...
[10:18:31.979] Searching for globals...
[10:18:31.979] 
[10:18:31.980] Searching for globals ... DONE
[10:18:31.980] - globals: [0] <none>
[10:18:31.980] getGlobalsAndPackages() ... DONE
[10:18:31.980]    + additional globals found: [n=0] 
[10:18:31.980]    + additional namespaces needed: [n=0] 
[10:18:31.980]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:31.980]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:31.981]  - seeds: <none>
[10:18:31.981]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.981] getGlobalsAndPackages() ...
[10:18:31.981] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.981] Resolving globals: FALSE
[10:18:31.981] Tweak future expression to call with '...' arguments ...
[10:18:31.982] {
[10:18:31.982]     do.call(function(...) {
[10:18:31.982]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.982]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:31.982]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.982]             on.exit(options(oopts), add = TRUE)
[10:18:31.982]         }
[10:18:31.982]         {
[10:18:31.982]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:31.982]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.982]                 ...future.FUN(...future.X_jj, ...)
[10:18:31.982]             })
[10:18:31.982]         }
[10:18:31.982]     }, args = future.call.arguments)
[10:18:31.982] }
[10:18:31.982] Tweak future expression to call with '...' arguments ... DONE
[10:18:31.983] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:31.983] 
[10:18:31.984] getGlobalsAndPackages() ... DONE
[10:18:31.984] run() for ‘Future’ ...
[10:18:31.985] - state: ‘created’
[10:18:31.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:31.988] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:31.988] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:31.988]   - Field: ‘label’
[10:18:31.989]   - Field: ‘local’
[10:18:31.989]   - Field: ‘owner’
[10:18:31.989]   - Field: ‘envir’
[10:18:31.989]   - Field: ‘workers’
[10:18:31.989]   - Field: ‘packages’
[10:18:31.989]   - Field: ‘gc’
[10:18:31.989]   - Field: ‘job’
[10:18:31.990]   - Field: ‘conditions’
[10:18:31.990]   - Field: ‘expr’
[10:18:31.990]   - Field: ‘uuid’
[10:18:31.990]   - Field: ‘seed’
[10:18:31.990]   - Field: ‘version’
[10:18:31.990]   - Field: ‘result’
[10:18:31.991]   - Field: ‘asynchronous’
[10:18:31.991]   - Field: ‘calls’
[10:18:31.991]   - Field: ‘globals’
[10:18:31.991]   - Field: ‘stdout’
[10:18:31.991]   - Field: ‘earlySignal’
[10:18:31.991]   - Field: ‘lazy’
[10:18:31.992]   - Field: ‘state’
[10:18:31.992] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:31.992] - Launch lazy future ...
[10:18:31.992] Packages needed by the future expression (n = 0): <none>
[10:18:31.992] Packages needed by future strategies (n = 0): <none>
[10:18:31.993] {
[10:18:31.993]     {
[10:18:31.993]         {
[10:18:31.993]             ...future.startTime <- base::Sys.time()
[10:18:31.993]             {
[10:18:31.993]                 {
[10:18:31.993]                   {
[10:18:31.993]                     {
[10:18:31.993]                       base::local({
[10:18:31.993]                         has_future <- base::requireNamespace("future", 
[10:18:31.993]                           quietly = TRUE)
[10:18:31.993]                         if (has_future) {
[10:18:31.993]                           ns <- base::getNamespace("future")
[10:18:31.993]                           version <- ns[[".package"]][["version"]]
[10:18:31.993]                           if (is.null(version)) 
[10:18:31.993]                             version <- utils::packageVersion("future")
[10:18:31.993]                         }
[10:18:31.993]                         else {
[10:18:31.993]                           version <- NULL
[10:18:31.993]                         }
[10:18:31.993]                         if (!has_future || version < "1.8.0") {
[10:18:31.993]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:31.993]                             "", base::R.version$version.string), 
[10:18:31.993]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:31.993]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:31.993]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:31.993]                               "release", "version")], collapse = " "), 
[10:18:31.993]                             hostname = base::Sys.info()[["nodename"]])
[10:18:31.993]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:31.993]                             info)
[10:18:31.993]                           info <- base::paste(info, collapse = "; ")
[10:18:31.993]                           if (!has_future) {
[10:18:31.993]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:31.993]                               info)
[10:18:31.993]                           }
[10:18:31.993]                           else {
[10:18:31.993]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:31.993]                               info, version)
[10:18:31.993]                           }
[10:18:31.993]                           base::stop(msg)
[10:18:31.993]                         }
[10:18:31.993]                       })
[10:18:31.993]                     }
[10:18:31.993]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:31.993]                     base::options(mc.cores = 1L)
[10:18:31.993]                   }
[10:18:31.993]                   ...future.strategy.old <- future::plan("list")
[10:18:31.993]                   options(future.plan = NULL)
[10:18:31.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:31.993]                 }
[10:18:31.993]                 ...future.workdir <- getwd()
[10:18:31.993]             }
[10:18:31.993]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:31.993]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:31.993]         }
[10:18:31.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:31.993]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:31.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:31.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:31.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:31.993]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:31.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:31.993]             base::names(...future.oldOptions))
[10:18:31.993]     }
[10:18:31.993]     if (FALSE) {
[10:18:31.993]     }
[10:18:31.993]     else {
[10:18:31.993]         if (TRUE) {
[10:18:31.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:31.993]                 open = "w")
[10:18:31.993]         }
[10:18:31.993]         else {
[10:18:31.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:31.993]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:31.993]         }
[10:18:31.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:31.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:31.993]             base::sink(type = "output", split = FALSE)
[10:18:31.993]             base::close(...future.stdout)
[10:18:31.993]         }, add = TRUE)
[10:18:31.993]     }
[10:18:31.993]     ...future.frame <- base::sys.nframe()
[10:18:31.993]     ...future.conditions <- base::list()
[10:18:31.993]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:31.993]     if (FALSE) {
[10:18:31.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:31.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:31.993]     }
[10:18:31.993]     ...future.result <- base::tryCatch({
[10:18:31.993]         base::withCallingHandlers({
[10:18:31.993]             ...future.value <- base::withVisible(base::local({
[10:18:31.993]                 withCallingHandlers({
[10:18:31.993]                   {
[10:18:31.993]                     do.call(function(...) {
[10:18:31.993]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:31.993]                       if (!identical(...future.globals.maxSize.org, 
[10:18:31.993]                         ...future.globals.maxSize)) {
[10:18:31.993]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:31.993]                         on.exit(options(oopts), add = TRUE)
[10:18:31.993]                       }
[10:18:31.993]                       {
[10:18:31.993]                         lapply(seq_along(...future.elements_ii), 
[10:18:31.993]                           FUN = function(jj) {
[10:18:31.993]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:31.993]                             ...future.FUN(...future.X_jj, ...)
[10:18:31.993]                           })
[10:18:31.993]                       }
[10:18:31.993]                     }, args = future.call.arguments)
[10:18:31.993]                   }
[10:18:31.993]                 }, immediateCondition = function(cond) {
[10:18:31.993]                   save_rds <- function (object, pathname, ...) 
[10:18:31.993]                   {
[10:18:31.993]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:31.993]                     if (file_test("-f", pathname_tmp)) {
[10:18:31.993]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.993]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:31.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.993]                         fi_tmp[["mtime"]])
[10:18:31.993]                     }
[10:18:31.993]                     tryCatch({
[10:18:31.993]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:31.993]                     }, error = function(ex) {
[10:18:31.993]                       msg <- conditionMessage(ex)
[10:18:31.993]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.993]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:31.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.993]                         fi_tmp[["mtime"]], msg)
[10:18:31.993]                       ex$message <- msg
[10:18:31.993]                       stop(ex)
[10:18:31.993]                     })
[10:18:31.993]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:31.993]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:31.993]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:31.993]                       fi_tmp <- file.info(pathname_tmp)
[10:18:31.993]                       fi <- file.info(pathname)
[10:18:31.993]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:31.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:31.993]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:31.993]                         fi[["size"]], fi[["mtime"]])
[10:18:31.993]                       stop(msg)
[10:18:31.993]                     }
[10:18:31.993]                     invisible(pathname)
[10:18:31.993]                   }
[10:18:31.993]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:31.993]                     rootPath = tempdir()) 
[10:18:31.993]                   {
[10:18:31.993]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:31.993]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:31.993]                       tmpdir = path, fileext = ".rds")
[10:18:31.993]                     save_rds(obj, file)
[10:18:31.993]                   }
[10:18:31.993]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:31.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.993]                   {
[10:18:31.993]                     inherits <- base::inherits
[10:18:31.993]                     invokeRestart <- base::invokeRestart
[10:18:31.993]                     is.null <- base::is.null
[10:18:31.993]                     muffled <- FALSE
[10:18:31.993]                     if (inherits(cond, "message")) {
[10:18:31.993]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:31.993]                       if (muffled) 
[10:18:31.993]                         invokeRestart("muffleMessage")
[10:18:31.993]                     }
[10:18:31.993]                     else if (inherits(cond, "warning")) {
[10:18:31.993]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:31.993]                       if (muffled) 
[10:18:31.993]                         invokeRestart("muffleWarning")
[10:18:31.993]                     }
[10:18:31.993]                     else if (inherits(cond, "condition")) {
[10:18:31.993]                       if (!is.null(pattern)) {
[10:18:31.993]                         computeRestarts <- base::computeRestarts
[10:18:31.993]                         grepl <- base::grepl
[10:18:31.993]                         restarts <- computeRestarts(cond)
[10:18:31.993]                         for (restart in restarts) {
[10:18:31.993]                           name <- restart$name
[10:18:31.993]                           if (is.null(name)) 
[10:18:31.993]                             next
[10:18:31.993]                           if (!grepl(pattern, name)) 
[10:18:31.993]                             next
[10:18:31.993]                           invokeRestart(restart)
[10:18:31.993]                           muffled <- TRUE
[10:18:31.993]                           break
[10:18:31.993]                         }
[10:18:31.993]                       }
[10:18:31.993]                     }
[10:18:31.993]                     invisible(muffled)
[10:18:31.993]                   }
[10:18:31.993]                   muffleCondition(cond)
[10:18:31.993]                 })
[10:18:31.993]             }))
[10:18:31.993]             future::FutureResult(value = ...future.value$value, 
[10:18:31.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.993]                   ...future.rng), globalenv = if (FALSE) 
[10:18:31.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:31.993]                     ...future.globalenv.names))
[10:18:31.993]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:31.993]         }, condition = base::local({
[10:18:31.993]             c <- base::c
[10:18:31.993]             inherits <- base::inherits
[10:18:31.993]             invokeRestart <- base::invokeRestart
[10:18:31.993]             length <- base::length
[10:18:31.993]             list <- base::list
[10:18:31.993]             seq.int <- base::seq.int
[10:18:31.993]             signalCondition <- base::signalCondition
[10:18:31.993]             sys.calls <- base::sys.calls
[10:18:31.993]             `[[` <- base::`[[`
[10:18:31.993]             `+` <- base::`+`
[10:18:31.993]             `<<-` <- base::`<<-`
[10:18:31.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:31.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:31.993]                   3L)]
[10:18:31.993]             }
[10:18:31.993]             function(cond) {
[10:18:31.993]                 is_error <- inherits(cond, "error")
[10:18:31.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:31.993]                   NULL)
[10:18:31.993]                 if (is_error) {
[10:18:31.993]                   sessionInformation <- function() {
[10:18:31.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:31.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:31.993]                       search = base::search(), system = base::Sys.info())
[10:18:31.993]                   }
[10:18:31.993]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:31.993]                     cond$call), session = sessionInformation(), 
[10:18:31.993]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:31.993]                   signalCondition(cond)
[10:18:31.993]                 }
[10:18:31.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:31.993]                 "immediateCondition"))) {
[10:18:31.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:31.993]                   ...future.conditions[[length(...future.conditions) + 
[10:18:31.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:31.993]                   if (TRUE && !signal) {
[10:18:31.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.993]                     {
[10:18:31.993]                       inherits <- base::inherits
[10:18:31.993]                       invokeRestart <- base::invokeRestart
[10:18:31.993]                       is.null <- base::is.null
[10:18:31.993]                       muffled <- FALSE
[10:18:31.993]                       if (inherits(cond, "message")) {
[10:18:31.993]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.993]                         if (muffled) 
[10:18:31.993]                           invokeRestart("muffleMessage")
[10:18:31.993]                       }
[10:18:31.993]                       else if (inherits(cond, "warning")) {
[10:18:31.993]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.993]                         if (muffled) 
[10:18:31.993]                           invokeRestart("muffleWarning")
[10:18:31.993]                       }
[10:18:31.993]                       else if (inherits(cond, "condition")) {
[10:18:31.993]                         if (!is.null(pattern)) {
[10:18:31.993]                           computeRestarts <- base::computeRestarts
[10:18:31.993]                           grepl <- base::grepl
[10:18:31.993]                           restarts <- computeRestarts(cond)
[10:18:31.993]                           for (restart in restarts) {
[10:18:31.993]                             name <- restart$name
[10:18:31.993]                             if (is.null(name)) 
[10:18:31.993]                               next
[10:18:31.993]                             if (!grepl(pattern, name)) 
[10:18:31.993]                               next
[10:18:31.993]                             invokeRestart(restart)
[10:18:31.993]                             muffled <- TRUE
[10:18:31.993]                             break
[10:18:31.993]                           }
[10:18:31.993]                         }
[10:18:31.993]                       }
[10:18:31.993]                       invisible(muffled)
[10:18:31.993]                     }
[10:18:31.993]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.993]                   }
[10:18:31.993]                 }
[10:18:31.993]                 else {
[10:18:31.993]                   if (TRUE) {
[10:18:31.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:31.993]                     {
[10:18:31.993]                       inherits <- base::inherits
[10:18:31.993]                       invokeRestart <- base::invokeRestart
[10:18:31.993]                       is.null <- base::is.null
[10:18:31.993]                       muffled <- FALSE
[10:18:31.993]                       if (inherits(cond, "message")) {
[10:18:31.993]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:31.993]                         if (muffled) 
[10:18:31.993]                           invokeRestart("muffleMessage")
[10:18:31.993]                       }
[10:18:31.993]                       else if (inherits(cond, "warning")) {
[10:18:31.993]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:31.993]                         if (muffled) 
[10:18:31.993]                           invokeRestart("muffleWarning")
[10:18:31.993]                       }
[10:18:31.993]                       else if (inherits(cond, "condition")) {
[10:18:31.993]                         if (!is.null(pattern)) {
[10:18:31.993]                           computeRestarts <- base::computeRestarts
[10:18:31.993]                           grepl <- base::grepl
[10:18:31.993]                           restarts <- computeRestarts(cond)
[10:18:31.993]                           for (restart in restarts) {
[10:18:31.993]                             name <- restart$name
[10:18:31.993]                             if (is.null(name)) 
[10:18:31.993]                               next
[10:18:31.993]                             if (!grepl(pattern, name)) 
[10:18:31.993]                               next
[10:18:31.993]                             invokeRestart(restart)
[10:18:31.993]                             muffled <- TRUE
[10:18:31.993]                             break
[10:18:31.993]                           }
[10:18:31.993]                         }
[10:18:31.993]                       }
[10:18:31.993]                       invisible(muffled)
[10:18:31.993]                     }
[10:18:31.993]                     muffleCondition(cond, pattern = "^muffle")
[10:18:31.993]                   }
[10:18:31.993]                 }
[10:18:31.993]             }
[10:18:31.993]         }))
[10:18:31.993]     }, error = function(ex) {
[10:18:31.993]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:31.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:31.993]                 ...future.rng), started = ...future.startTime, 
[10:18:31.993]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:31.993]             version = "1.8"), class = "FutureResult")
[10:18:31.993]     }, finally = {
[10:18:31.993]         if (!identical(...future.workdir, getwd())) 
[10:18:31.993]             setwd(...future.workdir)
[10:18:31.993]         {
[10:18:31.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:31.993]                 ...future.oldOptions$nwarnings <- NULL
[10:18:31.993]             }
[10:18:31.993]             base::options(...future.oldOptions)
[10:18:31.993]             if (.Platform$OS.type == "windows") {
[10:18:31.993]                 old_names <- names(...future.oldEnvVars)
[10:18:31.993]                 envs <- base::Sys.getenv()
[10:18:31.993]                 names <- names(envs)
[10:18:31.993]                 common <- intersect(names, old_names)
[10:18:31.993]                 added <- setdiff(names, old_names)
[10:18:31.993]                 removed <- setdiff(old_names, names)
[10:18:31.993]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:31.993]                   envs[common]]
[10:18:31.993]                 NAMES <- toupper(changed)
[10:18:31.993]                 args <- list()
[10:18:31.993]                 for (kk in seq_along(NAMES)) {
[10:18:31.993]                   name <- changed[[kk]]
[10:18:31.993]                   NAME <- NAMES[[kk]]
[10:18:31.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.993]                     next
[10:18:31.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.993]                 }
[10:18:31.993]                 NAMES <- toupper(added)
[10:18:31.993]                 for (kk in seq_along(NAMES)) {
[10:18:31.993]                   name <- added[[kk]]
[10:18:31.993]                   NAME <- NAMES[[kk]]
[10:18:31.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.993]                     next
[10:18:31.993]                   args[[name]] <- ""
[10:18:31.993]                 }
[10:18:31.993]                 NAMES <- toupper(removed)
[10:18:31.993]                 for (kk in seq_along(NAMES)) {
[10:18:31.993]                   name <- removed[[kk]]
[10:18:31.993]                   NAME <- NAMES[[kk]]
[10:18:31.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:31.993]                     next
[10:18:31.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:31.993]                 }
[10:18:31.993]                 if (length(args) > 0) 
[10:18:31.993]                   base::do.call(base::Sys.setenv, args = args)
[10:18:31.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:31.993]             }
[10:18:31.993]             else {
[10:18:31.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:31.993]             }
[10:18:31.993]             {
[10:18:31.993]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:31.993]                   0L) {
[10:18:31.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:31.993]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:31.993]                   base::options(opts)
[10:18:31.993]                 }
[10:18:31.993]                 {
[10:18:31.993]                   {
[10:18:31.993]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:31.993]                     NULL
[10:18:31.993]                   }
[10:18:31.993]                   options(future.plan = NULL)
[10:18:31.993]                   if (is.na(NA_character_)) 
[10:18:31.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:31.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:31.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:31.993]                     .init = FALSE)
[10:18:31.993]                 }
[10:18:31.993]             }
[10:18:31.993]         }
[10:18:31.993]     })
[10:18:31.993]     if (TRUE) {
[10:18:31.993]         base::sink(type = "output", split = FALSE)
[10:18:31.993]         if (TRUE) {
[10:18:31.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:31.993]         }
[10:18:31.993]         else {
[10:18:31.993]             ...future.result["stdout"] <- base::list(NULL)
[10:18:31.993]         }
[10:18:31.993]         base::close(...future.stdout)
[10:18:31.993]         ...future.stdout <- NULL
[10:18:31.993]     }
[10:18:31.993]     ...future.result$conditions <- ...future.conditions
[10:18:31.993]     ...future.result$finished <- base::Sys.time()
[10:18:31.993]     ...future.result
[10:18:31.993] }
[10:18:31.997] assign_globals() ...
[10:18:31.997] List of 5
[10:18:31.997]  $ ...future.FUN            :function (object, ...)  
[10:18:31.997]  $ future.call.arguments    :List of 1
[10:18:31.997]   ..$ digits: int 2
[10:18:31.997]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:31.997]  $ ...future.elements_ii    :List of 3
[10:18:31.997]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:18:31.997]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:18:31.997]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:18:31.997]  $ ...future.seeds_ii       : NULL
[10:18:31.997]  $ ...future.globals.maxSize: NULL
[10:18:31.997]  - attr(*, "where")=List of 5
[10:18:31.997]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:31.997]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:31.997]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:31.997]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:31.997]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:31.997]  - attr(*, "resolved")= logi FALSE
[10:18:31.997]  - attr(*, "total_size")= num 13284
[10:18:31.997]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:31.997]  - attr(*, "already-done")= logi TRUE
[10:18:32.010] - copied ‘...future.FUN’ to environment
[10:18:32.010] - copied ‘future.call.arguments’ to environment
[10:18:32.010] - copied ‘...future.elements_ii’ to environment
[10:18:32.010] - copied ‘...future.seeds_ii’ to environment
[10:18:32.010] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.010] assign_globals() ... done
[10:18:32.010] requestCore(): workers = 2
[10:18:32.013] MulticoreFuture started
[10:18:32.014] - Launch lazy future ... done
[10:18:32.014] plan(): Setting new future strategy stack:
[10:18:32.014] run() for ‘MulticoreFuture’ ... done
[10:18:32.015] Created future:
[10:18:32.015] List of future strategies:
[10:18:32.015] 1. sequential:
[10:18:32.015]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.015]    - tweaked: FALSE
[10:18:32.015]    - call: NULL
[10:18:32.017] plan(): nbrOfWorkers() = 1
[10:18:32.021] plan(): Setting new future strategy stack:
[10:18:32.021] List of future strategies:
[10:18:32.021] 1. multicore:
[10:18:32.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.021]    - tweaked: FALSE
[10:18:32.021]    - call: plan(strategy)
[10:18:32.026] plan(): nbrOfWorkers() = 2
[10:18:32.015] MulticoreFuture:
[10:18:32.015] Label: ‘future_by-2’
[10:18:32.015] Expression:
[10:18:32.015] {
[10:18:32.015]     do.call(function(...) {
[10:18:32.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.015]             on.exit(options(oopts), add = TRUE)
[10:18:32.015]         }
[10:18:32.015]         {
[10:18:32.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.015]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.015]             })
[10:18:32.015]         }
[10:18:32.015]     }, args = future.call.arguments)
[10:18:32.015] }
[10:18:32.015] Lazy evaluation: FALSE
[10:18:32.015] Asynchronous evaluation: TRUE
[10:18:32.015] Local evaluation: TRUE
[10:18:32.015] Environment: R_GlobalEnv
[10:18:32.015] Capture standard output: TRUE
[10:18:32.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.015] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:32.015] Packages: <none>
[10:18:32.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.015] Resolved: TRUE
[10:18:32.015] Value: <not collected>
[10:18:32.015] Conditions captured: <none>
[10:18:32.015] Early signaling: FALSE
[10:18:32.015] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.015] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.027] Chunk #2 of 2 ... DONE
[10:18:32.027] Launching 2 futures (chunks) ... DONE
[10:18:32.027] Resolving 2 futures (chunks) ...
[10:18:32.028] resolve() on list ...
[10:18:32.028]  recursive: 0
[10:18:32.028]  length: 2
[10:18:32.028] 
[10:18:32.029] Future #1
[10:18:32.029] result() for MulticoreFuture ...
[10:18:32.030] result() for MulticoreFuture ...
[10:18:32.030] result() for MulticoreFuture ... done
[10:18:32.030] result() for MulticoreFuture ... done
[10:18:32.030] result() for MulticoreFuture ...
[10:18:32.031] result() for MulticoreFuture ... done
[10:18:32.031] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:32.031] - nx: 2
[10:18:32.031] - relay: TRUE
[10:18:32.031] - stdout: TRUE
[10:18:32.032] - signal: TRUE
[10:18:32.032] - resignal: FALSE
[10:18:32.032] - force: TRUE
[10:18:32.032] - relayed: [n=2] FALSE, FALSE
[10:18:32.033] - queued futures: [n=2] FALSE, FALSE
[10:18:32.033]  - until=1
[10:18:32.033]  - relaying element #1
[10:18:32.033] result() for MulticoreFuture ...
[10:18:32.033] result() for MulticoreFuture ... done
[10:18:32.033] result() for MulticoreFuture ...
[10:18:32.034] result() for MulticoreFuture ... done
[10:18:32.034] result() for MulticoreFuture ...
[10:18:32.034] result() for MulticoreFuture ... done
[10:18:32.034] result() for MulticoreFuture ...
[10:18:32.035] result() for MulticoreFuture ... done
[10:18:32.035] - relayed: [n=2] TRUE, FALSE
[10:18:32.035] - queued futures: [n=2] TRUE, FALSE
[10:18:32.035] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:32.035]  length: 1 (resolved future 1)
[10:18:32.035] Future #2
[10:18:32.035] result() for MulticoreFuture ...
[10:18:32.036] result() for MulticoreFuture ...
[10:18:32.036] result() for MulticoreFuture ... done
[10:18:32.036] result() for MulticoreFuture ... done
[10:18:32.037] result() for MulticoreFuture ...
[10:18:32.037] result() for MulticoreFuture ... done
[10:18:32.037] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:32.037] - nx: 2
[10:18:32.037] - relay: TRUE
[10:18:32.037] - stdout: TRUE
[10:18:32.038] - signal: TRUE
[10:18:32.038] - resignal: FALSE
[10:18:32.038] - force: TRUE
[10:18:32.038] - relayed: [n=2] TRUE, FALSE
[10:18:32.038] - queued futures: [n=2] TRUE, FALSE
[10:18:32.038]  - until=2
[10:18:32.038]  - relaying element #2
[10:18:32.038] result() for MulticoreFuture ...
[10:18:32.038] result() for MulticoreFuture ... done
[10:18:32.039] result() for MulticoreFuture ...
[10:18:32.039] result() for MulticoreFuture ... done
[10:18:32.039] result() for MulticoreFuture ...
[10:18:32.039] result() for MulticoreFuture ... done
[10:18:32.039] result() for MulticoreFuture ...
[10:18:32.039] result() for MulticoreFuture ... done
[10:18:32.039] - relayed: [n=2] TRUE, TRUE
[10:18:32.039] - queued futures: [n=2] TRUE, TRUE
[10:18:32.039] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:32.040]  length: 0 (resolved future 2)
[10:18:32.040] Relaying remaining futures
[10:18:32.040] signalConditionsASAP(NULL, pos=0) ...
[10:18:32.040] - nx: 2
[10:18:32.040] - relay: TRUE
[10:18:32.040] - stdout: TRUE
[10:18:32.040] - signal: TRUE
[10:18:32.040] - resignal: FALSE
[10:18:32.040] - force: TRUE
[10:18:32.040] - relayed: [n=2] TRUE, TRUE
[10:18:32.040] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:32.041] - relayed: [n=2] TRUE, TRUE
[10:18:32.041] - queued futures: [n=2] TRUE, TRUE
[10:18:32.041] signalConditionsASAP(NULL, pos=0) ... done
[10:18:32.041] resolve() on list ... DONE
[10:18:32.041] result() for MulticoreFuture ...
[10:18:32.041] result() for MulticoreFuture ... done
[10:18:32.041] result() for MulticoreFuture ...
[10:18:32.041] result() for MulticoreFuture ... done
[10:18:32.041] result() for MulticoreFuture ...
[10:18:32.042] result() for MulticoreFuture ... done
[10:18:32.042] result() for MulticoreFuture ...
[10:18:32.042] result() for MulticoreFuture ... done
[10:18:32.042]  - Number of value chunks collected: 2
[10:18:32.042] Resolving 2 futures (chunks) ... DONE
[10:18:32.042] Reducing values from 2 chunks ...
[10:18:32.042]  - Number of values collected after concatenation: 6
[10:18:32.042]  - Number of values expected: 6
[10:18:32.042] Reducing values from 2 chunks ... DONE
[10:18:32.042] future_lapply() ... DONE
[10:18:32.043] future_by_internal() ... DONE
[10:18:32.044] future_by_internal() ...
[10:18:32.044] future_lapply() ...
[10:18:32.047] Number of chunks: 2
[10:18:32.047] getGlobalsAndPackagesXApply() ...
[10:18:32.048]  - future.globals: TRUE
[10:18:32.048] getGlobalsAndPackages() ...
[10:18:32.048] Searching for globals...
[10:18:32.049] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:32.050] Searching for globals ... DONE
[10:18:32.050] Resolving globals: FALSE
[10:18:32.052] The total size of the 1 globals is 762 bytes (762 bytes)
[10:18:32.053] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:18:32.053] - globals: [1] ‘FUN’
[10:18:32.053] - packages: [1] ‘stats’
[10:18:32.053] getGlobalsAndPackages() ... DONE
[10:18:32.053]  - globals found/used: [n=1] ‘FUN’
[10:18:32.053]  - needed namespaces: [n=1] ‘stats’
[10:18:32.053] Finding globals ... DONE
[10:18:32.053]  - use_args: TRUE
[10:18:32.054]  - Getting '...' globals ...
[10:18:32.054] resolve() on list ...
[10:18:32.054]  recursive: 0
[10:18:32.054]  length: 1
[10:18:32.054]  elements: ‘...’
[10:18:32.054]  length: 0 (resolved future 1)
[10:18:32.055] resolve() on list ... DONE
[10:18:32.055]    - '...' content: [n=1] ‘singular.ok’
[10:18:32.055] List of 1
[10:18:32.055]  $ ...:List of 1
[10:18:32.055]   ..$ singular.ok: logi FALSE
[10:18:32.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.055]  - attr(*, "where")=List of 1
[10:18:32.055]   ..$ ...:<environment: 0x55844a11bf08> 
[10:18:32.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.055]  - attr(*, "resolved")= logi TRUE
[10:18:32.055]  - attr(*, "total_size")= num NA
[10:18:32.058]  - Getting '...' globals ... DONE
[10:18:32.058] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:32.059] List of 2
[10:18:32.059]  $ ...future.FUN:function (x, ...)  
[10:18:32.059]  $ ...          :List of 1
[10:18:32.059]   ..$ singular.ok: logi FALSE
[10:18:32.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.059]  - attr(*, "where")=List of 2
[10:18:32.059]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:32.059]   ..$ ...          :<environment: 0x55844a11bf08> 
[10:18:32.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.059]  - attr(*, "resolved")= logi FALSE
[10:18:32.059]  - attr(*, "total_size")= num 19977
[10:18:32.062] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:32.062] getGlobalsAndPackagesXApply() ... DONE
[10:18:32.062] Number of futures (= number of chunks): 2
[10:18:32.062] Launching 2 futures (chunks) ...
[10:18:32.062] Chunk #1 of 2 ...
[10:18:32.062]  - Finding globals in 'X' for chunk #1 ...
[10:18:32.062] getGlobalsAndPackages() ...
[10:18:32.063] Searching for globals...
[10:18:32.063] 
[10:18:32.063] Searching for globals ... DONE
[10:18:32.063] - globals: [0] <none>
[10:18:32.063] getGlobalsAndPackages() ... DONE
[10:18:32.063]    + additional globals found: [n=0] 
[10:18:32.063]    + additional namespaces needed: [n=0] 
[10:18:32.064]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:32.064]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:32.064]  - seeds: <none>
[10:18:32.064]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.064] getGlobalsAndPackages() ...
[10:18:32.064] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.064] Resolving globals: FALSE
[10:18:32.064] Tweak future expression to call with '...' arguments ...
[10:18:32.064] {
[10:18:32.064]     do.call(function(...) {
[10:18:32.064]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.064]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.064]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.064]             on.exit(options(oopts), add = TRUE)
[10:18:32.064]         }
[10:18:32.064]         {
[10:18:32.064]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.064]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.064]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.064]             })
[10:18:32.064]         }
[10:18:32.064]     }, args = future.call.arguments)
[10:18:32.064] }
[10:18:32.065] Tweak future expression to call with '...' arguments ... DONE
[10:18:32.065] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.065] 
[10:18:32.065] getGlobalsAndPackages() ... DONE
[10:18:32.066] run() for ‘Future’ ...
[10:18:32.066] - state: ‘created’
[10:18:32.066] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:32.068] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:32.068]   - Field: ‘label’
[10:18:32.068]   - Field: ‘local’
[10:18:32.068]   - Field: ‘owner’
[10:18:32.068]   - Field: ‘envir’
[10:18:32.068]   - Field: ‘workers’
[10:18:32.068]   - Field: ‘packages’
[10:18:32.069]   - Field: ‘gc’
[10:18:32.069]   - Field: ‘job’
[10:18:32.069]   - Field: ‘conditions’
[10:18:32.069]   - Field: ‘expr’
[10:18:32.069]   - Field: ‘uuid’
[10:18:32.069]   - Field: ‘seed’
[10:18:32.069]   - Field: ‘version’
[10:18:32.069]   - Field: ‘result’
[10:18:32.069]   - Field: ‘asynchronous’
[10:18:32.069]   - Field: ‘calls’
[10:18:32.069]   - Field: ‘globals’
[10:18:32.070]   - Field: ‘stdout’
[10:18:32.070]   - Field: ‘earlySignal’
[10:18:32.070]   - Field: ‘lazy’
[10:18:32.070]   - Field: ‘state’
[10:18:32.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:32.070] - Launch lazy future ...
[10:18:32.070] Packages needed by the future expression (n = 1): ‘stats’
[10:18:32.070] Packages needed by future strategies (n = 0): <none>
[10:18:32.071] {
[10:18:32.071]     {
[10:18:32.071]         {
[10:18:32.071]             ...future.startTime <- base::Sys.time()
[10:18:32.071]             {
[10:18:32.071]                 {
[10:18:32.071]                   {
[10:18:32.071]                     {
[10:18:32.071]                       {
[10:18:32.071]                         base::local({
[10:18:32.071]                           has_future <- base::requireNamespace("future", 
[10:18:32.071]                             quietly = TRUE)
[10:18:32.071]                           if (has_future) {
[10:18:32.071]                             ns <- base::getNamespace("future")
[10:18:32.071]                             version <- ns[[".package"]][["version"]]
[10:18:32.071]                             if (is.null(version)) 
[10:18:32.071]                               version <- utils::packageVersion("future")
[10:18:32.071]                           }
[10:18:32.071]                           else {
[10:18:32.071]                             version <- NULL
[10:18:32.071]                           }
[10:18:32.071]                           if (!has_future || version < "1.8.0") {
[10:18:32.071]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:32.071]                               "", base::R.version$version.string), 
[10:18:32.071]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:32.071]                                 base::R.version$platform, 8 * 
[10:18:32.071]                                   base::.Machine$sizeof.pointer), 
[10:18:32.071]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:32.071]                                 "release", "version")], collapse = " "), 
[10:18:32.071]                               hostname = base::Sys.info()[["nodename"]])
[10:18:32.071]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:32.071]                               info)
[10:18:32.071]                             info <- base::paste(info, collapse = "; ")
[10:18:32.071]                             if (!has_future) {
[10:18:32.071]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:32.071]                                 info)
[10:18:32.071]                             }
[10:18:32.071]                             else {
[10:18:32.071]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:32.071]                                 info, version)
[10:18:32.071]                             }
[10:18:32.071]                             base::stop(msg)
[10:18:32.071]                           }
[10:18:32.071]                         })
[10:18:32.071]                       }
[10:18:32.071]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:32.071]                       base::options(mc.cores = 1L)
[10:18:32.071]                     }
[10:18:32.071]                     base::local({
[10:18:32.071]                       for (pkg in "stats") {
[10:18:32.071]                         base::loadNamespace(pkg)
[10:18:32.071]                         base::library(pkg, character.only = TRUE)
[10:18:32.071]                       }
[10:18:32.071]                     })
[10:18:32.071]                   }
[10:18:32.071]                   ...future.strategy.old <- future::plan("list")
[10:18:32.071]                   options(future.plan = NULL)
[10:18:32.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:32.071]                 }
[10:18:32.071]                 ...future.workdir <- getwd()
[10:18:32.071]             }
[10:18:32.071]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:32.071]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:32.071]         }
[10:18:32.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:32.071]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:32.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:32.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:32.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:32.071]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:32.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:32.071]             base::names(...future.oldOptions))
[10:18:32.071]     }
[10:18:32.071]     if (FALSE) {
[10:18:32.071]     }
[10:18:32.071]     else {
[10:18:32.071]         if (TRUE) {
[10:18:32.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:32.071]                 open = "w")
[10:18:32.071]         }
[10:18:32.071]         else {
[10:18:32.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:32.071]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:32.071]         }
[10:18:32.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:32.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:32.071]             base::sink(type = "output", split = FALSE)
[10:18:32.071]             base::close(...future.stdout)
[10:18:32.071]         }, add = TRUE)
[10:18:32.071]     }
[10:18:32.071]     ...future.frame <- base::sys.nframe()
[10:18:32.071]     ...future.conditions <- base::list()
[10:18:32.071]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:32.071]     if (FALSE) {
[10:18:32.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:32.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:32.071]     }
[10:18:32.071]     ...future.result <- base::tryCatch({
[10:18:32.071]         base::withCallingHandlers({
[10:18:32.071]             ...future.value <- base::withVisible(base::local({
[10:18:32.071]                 withCallingHandlers({
[10:18:32.071]                   {
[10:18:32.071]                     do.call(function(...) {
[10:18:32.071]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.071]                       if (!identical(...future.globals.maxSize.org, 
[10:18:32.071]                         ...future.globals.maxSize)) {
[10:18:32.071]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.071]                         on.exit(options(oopts), add = TRUE)
[10:18:32.071]                       }
[10:18:32.071]                       {
[10:18:32.071]                         lapply(seq_along(...future.elements_ii), 
[10:18:32.071]                           FUN = function(jj) {
[10:18:32.071]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.071]                             ...future.FUN(...future.X_jj, ...)
[10:18:32.071]                           })
[10:18:32.071]                       }
[10:18:32.071]                     }, args = future.call.arguments)
[10:18:32.071]                   }
[10:18:32.071]                 }, immediateCondition = function(cond) {
[10:18:32.071]                   save_rds <- function (object, pathname, ...) 
[10:18:32.071]                   {
[10:18:32.071]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:32.071]                     if (file_test("-f", pathname_tmp)) {
[10:18:32.071]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.071]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:32.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.071]                         fi_tmp[["mtime"]])
[10:18:32.071]                     }
[10:18:32.071]                     tryCatch({
[10:18:32.071]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:32.071]                     }, error = function(ex) {
[10:18:32.071]                       msg <- conditionMessage(ex)
[10:18:32.071]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.071]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:32.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.071]                         fi_tmp[["mtime"]], msg)
[10:18:32.071]                       ex$message <- msg
[10:18:32.071]                       stop(ex)
[10:18:32.071]                     })
[10:18:32.071]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:32.071]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:32.071]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:32.071]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.071]                       fi <- file.info(pathname)
[10:18:32.071]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:32.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.071]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:32.071]                         fi[["size"]], fi[["mtime"]])
[10:18:32.071]                       stop(msg)
[10:18:32.071]                     }
[10:18:32.071]                     invisible(pathname)
[10:18:32.071]                   }
[10:18:32.071]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:32.071]                     rootPath = tempdir()) 
[10:18:32.071]                   {
[10:18:32.071]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:32.071]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:32.071]                       tmpdir = path, fileext = ".rds")
[10:18:32.071]                     save_rds(obj, file)
[10:18:32.071]                   }
[10:18:32.071]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:32.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.071]                   {
[10:18:32.071]                     inherits <- base::inherits
[10:18:32.071]                     invokeRestart <- base::invokeRestart
[10:18:32.071]                     is.null <- base::is.null
[10:18:32.071]                     muffled <- FALSE
[10:18:32.071]                     if (inherits(cond, "message")) {
[10:18:32.071]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:32.071]                       if (muffled) 
[10:18:32.071]                         invokeRestart("muffleMessage")
[10:18:32.071]                     }
[10:18:32.071]                     else if (inherits(cond, "warning")) {
[10:18:32.071]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:32.071]                       if (muffled) 
[10:18:32.071]                         invokeRestart("muffleWarning")
[10:18:32.071]                     }
[10:18:32.071]                     else if (inherits(cond, "condition")) {
[10:18:32.071]                       if (!is.null(pattern)) {
[10:18:32.071]                         computeRestarts <- base::computeRestarts
[10:18:32.071]                         grepl <- base::grepl
[10:18:32.071]                         restarts <- computeRestarts(cond)
[10:18:32.071]                         for (restart in restarts) {
[10:18:32.071]                           name <- restart$name
[10:18:32.071]                           if (is.null(name)) 
[10:18:32.071]                             next
[10:18:32.071]                           if (!grepl(pattern, name)) 
[10:18:32.071]                             next
[10:18:32.071]                           invokeRestart(restart)
[10:18:32.071]                           muffled <- TRUE
[10:18:32.071]                           break
[10:18:32.071]                         }
[10:18:32.071]                       }
[10:18:32.071]                     }
[10:18:32.071]                     invisible(muffled)
[10:18:32.071]                   }
[10:18:32.071]                   muffleCondition(cond)
[10:18:32.071]                 })
[10:18:32.071]             }))
[10:18:32.071]             future::FutureResult(value = ...future.value$value, 
[10:18:32.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.071]                   ...future.rng), globalenv = if (FALSE) 
[10:18:32.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:32.071]                     ...future.globalenv.names))
[10:18:32.071]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:32.071]         }, condition = base::local({
[10:18:32.071]             c <- base::c
[10:18:32.071]             inherits <- base::inherits
[10:18:32.071]             invokeRestart <- base::invokeRestart
[10:18:32.071]             length <- base::length
[10:18:32.071]             list <- base::list
[10:18:32.071]             seq.int <- base::seq.int
[10:18:32.071]             signalCondition <- base::signalCondition
[10:18:32.071]             sys.calls <- base::sys.calls
[10:18:32.071]             `[[` <- base::`[[`
[10:18:32.071]             `+` <- base::`+`
[10:18:32.071]             `<<-` <- base::`<<-`
[10:18:32.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:32.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:32.071]                   3L)]
[10:18:32.071]             }
[10:18:32.071]             function(cond) {
[10:18:32.071]                 is_error <- inherits(cond, "error")
[10:18:32.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:32.071]                   NULL)
[10:18:32.071]                 if (is_error) {
[10:18:32.071]                   sessionInformation <- function() {
[10:18:32.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:32.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:32.071]                       search = base::search(), system = base::Sys.info())
[10:18:32.071]                   }
[10:18:32.071]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:32.071]                     cond$call), session = sessionInformation(), 
[10:18:32.071]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:32.071]                   signalCondition(cond)
[10:18:32.071]                 }
[10:18:32.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:32.071]                 "immediateCondition"))) {
[10:18:32.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:32.071]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:32.071]                   if (TRUE && !signal) {
[10:18:32.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.071]                     {
[10:18:32.071]                       inherits <- base::inherits
[10:18:32.071]                       invokeRestart <- base::invokeRestart
[10:18:32.071]                       is.null <- base::is.null
[10:18:32.071]                       muffled <- FALSE
[10:18:32.071]                       if (inherits(cond, "message")) {
[10:18:32.071]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.071]                         if (muffled) 
[10:18:32.071]                           invokeRestart("muffleMessage")
[10:18:32.071]                       }
[10:18:32.071]                       else if (inherits(cond, "warning")) {
[10:18:32.071]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.071]                         if (muffled) 
[10:18:32.071]                           invokeRestart("muffleWarning")
[10:18:32.071]                       }
[10:18:32.071]                       else if (inherits(cond, "condition")) {
[10:18:32.071]                         if (!is.null(pattern)) {
[10:18:32.071]                           computeRestarts <- base::computeRestarts
[10:18:32.071]                           grepl <- base::grepl
[10:18:32.071]                           restarts <- computeRestarts(cond)
[10:18:32.071]                           for (restart in restarts) {
[10:18:32.071]                             name <- restart$name
[10:18:32.071]                             if (is.null(name)) 
[10:18:32.071]                               next
[10:18:32.071]                             if (!grepl(pattern, name)) 
[10:18:32.071]                               next
[10:18:32.071]                             invokeRestart(restart)
[10:18:32.071]                             muffled <- TRUE
[10:18:32.071]                             break
[10:18:32.071]                           }
[10:18:32.071]                         }
[10:18:32.071]                       }
[10:18:32.071]                       invisible(muffled)
[10:18:32.071]                     }
[10:18:32.071]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.071]                   }
[10:18:32.071]                 }
[10:18:32.071]                 else {
[10:18:32.071]                   if (TRUE) {
[10:18:32.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.071]                     {
[10:18:32.071]                       inherits <- base::inherits
[10:18:32.071]                       invokeRestart <- base::invokeRestart
[10:18:32.071]                       is.null <- base::is.null
[10:18:32.071]                       muffled <- FALSE
[10:18:32.071]                       if (inherits(cond, "message")) {
[10:18:32.071]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.071]                         if (muffled) 
[10:18:32.071]                           invokeRestart("muffleMessage")
[10:18:32.071]                       }
[10:18:32.071]                       else if (inherits(cond, "warning")) {
[10:18:32.071]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.071]                         if (muffled) 
[10:18:32.071]                           invokeRestart("muffleWarning")
[10:18:32.071]                       }
[10:18:32.071]                       else if (inherits(cond, "condition")) {
[10:18:32.071]                         if (!is.null(pattern)) {
[10:18:32.071]                           computeRestarts <- base::computeRestarts
[10:18:32.071]                           grepl <- base::grepl
[10:18:32.071]                           restarts <- computeRestarts(cond)
[10:18:32.071]                           for (restart in restarts) {
[10:18:32.071]                             name <- restart$name
[10:18:32.071]                             if (is.null(name)) 
[10:18:32.071]                               next
[10:18:32.071]                             if (!grepl(pattern, name)) 
[10:18:32.071]                               next
[10:18:32.071]                             invokeRestart(restart)
[10:18:32.071]                             muffled <- TRUE
[10:18:32.071]                             break
[10:18:32.071]                           }
[10:18:32.071]                         }
[10:18:32.071]                       }
[10:18:32.071]                       invisible(muffled)
[10:18:32.071]                     }
[10:18:32.071]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.071]                   }
[10:18:32.071]                 }
[10:18:32.071]             }
[10:18:32.071]         }))
[10:18:32.071]     }, error = function(ex) {
[10:18:32.071]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:32.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.071]                 ...future.rng), started = ...future.startTime, 
[10:18:32.071]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:32.071]             version = "1.8"), class = "FutureResult")
[10:18:32.071]     }, finally = {
[10:18:32.071]         if (!identical(...future.workdir, getwd())) 
[10:18:32.071]             setwd(...future.workdir)
[10:18:32.071]         {
[10:18:32.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:32.071]                 ...future.oldOptions$nwarnings <- NULL
[10:18:32.071]             }
[10:18:32.071]             base::options(...future.oldOptions)
[10:18:32.071]             if (.Platform$OS.type == "windows") {
[10:18:32.071]                 old_names <- names(...future.oldEnvVars)
[10:18:32.071]                 envs <- base::Sys.getenv()
[10:18:32.071]                 names <- names(envs)
[10:18:32.071]                 common <- intersect(names, old_names)
[10:18:32.071]                 added <- setdiff(names, old_names)
[10:18:32.071]                 removed <- setdiff(old_names, names)
[10:18:32.071]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:32.071]                   envs[common]]
[10:18:32.071]                 NAMES <- toupper(changed)
[10:18:32.071]                 args <- list()
[10:18:32.071]                 for (kk in seq_along(NAMES)) {
[10:18:32.071]                   name <- changed[[kk]]
[10:18:32.071]                   NAME <- NAMES[[kk]]
[10:18:32.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.071]                     next
[10:18:32.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.071]                 }
[10:18:32.071]                 NAMES <- toupper(added)
[10:18:32.071]                 for (kk in seq_along(NAMES)) {
[10:18:32.071]                   name <- added[[kk]]
[10:18:32.071]                   NAME <- NAMES[[kk]]
[10:18:32.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.071]                     next
[10:18:32.071]                   args[[name]] <- ""
[10:18:32.071]                 }
[10:18:32.071]                 NAMES <- toupper(removed)
[10:18:32.071]                 for (kk in seq_along(NAMES)) {
[10:18:32.071]                   name <- removed[[kk]]
[10:18:32.071]                   NAME <- NAMES[[kk]]
[10:18:32.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.071]                     next
[10:18:32.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.071]                 }
[10:18:32.071]                 if (length(args) > 0) 
[10:18:32.071]                   base::do.call(base::Sys.setenv, args = args)
[10:18:32.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:32.071]             }
[10:18:32.071]             else {
[10:18:32.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:32.071]             }
[10:18:32.071]             {
[10:18:32.071]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:32.071]                   0L) {
[10:18:32.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:32.071]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:32.071]                   base::options(opts)
[10:18:32.071]                 }
[10:18:32.071]                 {
[10:18:32.071]                   {
[10:18:32.071]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:32.071]                     NULL
[10:18:32.071]                   }
[10:18:32.071]                   options(future.plan = NULL)
[10:18:32.071]                   if (is.na(NA_character_)) 
[10:18:32.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:32.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:32.071]                     .init = FALSE)
[10:18:32.071]                 }
[10:18:32.071]             }
[10:18:32.071]         }
[10:18:32.071]     })
[10:18:32.071]     if (TRUE) {
[10:18:32.071]         base::sink(type = "output", split = FALSE)
[10:18:32.071]         if (TRUE) {
[10:18:32.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:32.071]         }
[10:18:32.071]         else {
[10:18:32.071]             ...future.result["stdout"] <- base::list(NULL)
[10:18:32.071]         }
[10:18:32.071]         base::close(...future.stdout)
[10:18:32.071]         ...future.stdout <- NULL
[10:18:32.071]     }
[10:18:32.071]     ...future.result$conditions <- ...future.conditions
[10:18:32.071]     ...future.result$finished <- base::Sys.time()
[10:18:32.071]     ...future.result
[10:18:32.071] }
[10:18:32.074] assign_globals() ...
[10:18:32.074] List of 5
[10:18:32.074]  $ ...future.FUN            :function (x, ...)  
[10:18:32.074]  $ future.call.arguments    :List of 1
[10:18:32.074]   ..$ singular.ok: logi FALSE
[10:18:32.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.074]  $ ...future.elements_ii    :List of 1
[10:18:32.074]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.074]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:32.074]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.074]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:32.074]  $ ...future.seeds_ii       : NULL
[10:18:32.074]  $ ...future.globals.maxSize: NULL
[10:18:32.074]  - attr(*, "where")=List of 5
[10:18:32.074]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:32.074]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:32.074]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:32.074]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:32.074]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:32.074]  - attr(*, "resolved")= logi FALSE
[10:18:32.074]  - attr(*, "total_size")= num 19977
[10:18:32.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.074]  - attr(*, "already-done")= logi TRUE
[10:18:32.083] - reassign environment for ‘...future.FUN’
[10:18:32.084] - copied ‘...future.FUN’ to environment
[10:18:32.084] - copied ‘future.call.arguments’ to environment
[10:18:32.084] - copied ‘...future.elements_ii’ to environment
[10:18:32.084] - copied ‘...future.seeds_ii’ to environment
[10:18:32.084] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.084] assign_globals() ... done
[10:18:32.084] requestCore(): workers = 2
[10:18:32.087] MulticoreFuture started
[10:18:32.087] - Launch lazy future ... done
[10:18:32.088] run() for ‘MulticoreFuture’ ... done
[10:18:32.088] Created future:
[10:18:32.088] plan(): Setting new future strategy stack:
[10:18:32.089] List of future strategies:
[10:18:32.089] 1. sequential:
[10:18:32.089]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.089]    - tweaked: FALSE
[10:18:32.089]    - call: NULL
[10:18:32.090] plan(): nbrOfWorkers() = 1
[10:18:32.094] plan(): Setting new future strategy stack:
[10:18:32.095] List of future strategies:
[10:18:32.095] 1. multicore:
[10:18:32.095]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.095]    - tweaked: FALSE
[10:18:32.095]    - call: plan(strategy)
[10:18:32.098] plan(): nbrOfWorkers() = 2
[10:18:32.088] MulticoreFuture:
[10:18:32.088] Label: ‘future_by-1’
[10:18:32.088] Expression:
[10:18:32.088] {
[10:18:32.088]     do.call(function(...) {
[10:18:32.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.088]             on.exit(options(oopts), add = TRUE)
[10:18:32.088]         }
[10:18:32.088]         {
[10:18:32.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.088]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.088]             })
[10:18:32.088]         }
[10:18:32.088]     }, args = future.call.arguments)
[10:18:32.088] }
[10:18:32.088] Lazy evaluation: FALSE
[10:18:32.088] Asynchronous evaluation: TRUE
[10:18:32.088] Local evaluation: TRUE
[10:18:32.088] Environment: R_GlobalEnv
[10:18:32.088] Capture standard output: TRUE
[10:18:32.088] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.088] Globals: 5 objects totaling 1.67 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:32.088] Packages: 1 packages (‘stats’)
[10:18:32.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.088] Resolved: TRUE
[10:18:32.088] Value: <not collected>
[10:18:32.088] Conditions captured: <none>
[10:18:32.088] Early signaling: FALSE
[10:18:32.088] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.088] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.100] Chunk #1 of 2 ... DONE
[10:18:32.100] Chunk #2 of 2 ...
[10:18:32.100]  - Finding globals in 'X' for chunk #2 ...
[10:18:32.100] getGlobalsAndPackages() ...
[10:18:32.100] Searching for globals...
[10:18:32.101] 
[10:18:32.102] Searching for globals ... DONE
[10:18:32.102] - globals: [0] <none>
[10:18:32.102] getGlobalsAndPackages() ... DONE
[10:18:32.102]    + additional globals found: [n=0] 
[10:18:32.102]    + additional namespaces needed: [n=0] 
[10:18:32.102]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:32.102]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:32.102]  - seeds: <none>
[10:18:32.103]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.103] getGlobalsAndPackages() ...
[10:18:32.103] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.103] Resolving globals: FALSE
[10:18:32.103] Tweak future expression to call with '...' arguments ...
[10:18:32.103] {
[10:18:32.103]     do.call(function(...) {
[10:18:32.103]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.103]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.103]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.103]             on.exit(options(oopts), add = TRUE)
[10:18:32.103]         }
[10:18:32.103]         {
[10:18:32.103]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.103]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.103]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.103]             })
[10:18:32.103]         }
[10:18:32.103]     }, args = future.call.arguments)
[10:18:32.103] }
[10:18:32.104] Tweak future expression to call with '...' arguments ... DONE
[10:18:32.104] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.104] 
[10:18:32.105] getGlobalsAndPackages() ... DONE
[10:18:32.105] run() for ‘Future’ ...
[10:18:32.105] - state: ‘created’
[10:18:32.106] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:32.108] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:32.109]   - Field: ‘label’
[10:18:32.109]   - Field: ‘local’
[10:18:32.109]   - Field: ‘owner’
[10:18:32.109]   - Field: ‘envir’
[10:18:32.109]   - Field: ‘workers’
[10:18:32.109]   - Field: ‘packages’
[10:18:32.110]   - Field: ‘gc’
[10:18:32.110]   - Field: ‘job’
[10:18:32.110]   - Field: ‘conditions’
[10:18:32.110]   - Field: ‘expr’
[10:18:32.110]   - Field: ‘uuid’
[10:18:32.110]   - Field: ‘seed’
[10:18:32.110]   - Field: ‘version’
[10:18:32.111]   - Field: ‘result’
[10:18:32.111]   - Field: ‘asynchronous’
[10:18:32.111]   - Field: ‘calls’
[10:18:32.111]   - Field: ‘globals’
[10:18:32.111]   - Field: ‘stdout’
[10:18:32.111]   - Field: ‘earlySignal’
[10:18:32.111]   - Field: ‘lazy’
[10:18:32.112]   - Field: ‘state’
[10:18:32.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:32.112] - Launch lazy future ...
[10:18:32.112] Packages needed by the future expression (n = 1): ‘stats’
[10:18:32.113] Packages needed by future strategies (n = 0): <none>
[10:18:32.113] {
[10:18:32.113]     {
[10:18:32.113]         {
[10:18:32.113]             ...future.startTime <- base::Sys.time()
[10:18:32.113]             {
[10:18:32.113]                 {
[10:18:32.113]                   {
[10:18:32.113]                     {
[10:18:32.113]                       {
[10:18:32.113]                         base::local({
[10:18:32.113]                           has_future <- base::requireNamespace("future", 
[10:18:32.113]                             quietly = TRUE)
[10:18:32.113]                           if (has_future) {
[10:18:32.113]                             ns <- base::getNamespace("future")
[10:18:32.113]                             version <- ns[[".package"]][["version"]]
[10:18:32.113]                             if (is.null(version)) 
[10:18:32.113]                               version <- utils::packageVersion("future")
[10:18:32.113]                           }
[10:18:32.113]                           else {
[10:18:32.113]                             version <- NULL
[10:18:32.113]                           }
[10:18:32.113]                           if (!has_future || version < "1.8.0") {
[10:18:32.113]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:32.113]                               "", base::R.version$version.string), 
[10:18:32.113]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:32.113]                                 base::R.version$platform, 8 * 
[10:18:32.113]                                   base::.Machine$sizeof.pointer), 
[10:18:32.113]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:32.113]                                 "release", "version")], collapse = " "), 
[10:18:32.113]                               hostname = base::Sys.info()[["nodename"]])
[10:18:32.113]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:32.113]                               info)
[10:18:32.113]                             info <- base::paste(info, collapse = "; ")
[10:18:32.113]                             if (!has_future) {
[10:18:32.113]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:32.113]                                 info)
[10:18:32.113]                             }
[10:18:32.113]                             else {
[10:18:32.113]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:32.113]                                 info, version)
[10:18:32.113]                             }
[10:18:32.113]                             base::stop(msg)
[10:18:32.113]                           }
[10:18:32.113]                         })
[10:18:32.113]                       }
[10:18:32.113]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:32.113]                       base::options(mc.cores = 1L)
[10:18:32.113]                     }
[10:18:32.113]                     base::local({
[10:18:32.113]                       for (pkg in "stats") {
[10:18:32.113]                         base::loadNamespace(pkg)
[10:18:32.113]                         base::library(pkg, character.only = TRUE)
[10:18:32.113]                       }
[10:18:32.113]                     })
[10:18:32.113]                   }
[10:18:32.113]                   ...future.strategy.old <- future::plan("list")
[10:18:32.113]                   options(future.plan = NULL)
[10:18:32.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:32.113]                 }
[10:18:32.113]                 ...future.workdir <- getwd()
[10:18:32.113]             }
[10:18:32.113]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:32.113]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:32.113]         }
[10:18:32.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:32.113]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:32.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:32.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:32.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:32.113]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:32.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:32.113]             base::names(...future.oldOptions))
[10:18:32.113]     }
[10:18:32.113]     if (FALSE) {
[10:18:32.113]     }
[10:18:32.113]     else {
[10:18:32.113]         if (TRUE) {
[10:18:32.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:32.113]                 open = "w")
[10:18:32.113]         }
[10:18:32.113]         else {
[10:18:32.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:32.113]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:32.113]         }
[10:18:32.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:32.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:32.113]             base::sink(type = "output", split = FALSE)
[10:18:32.113]             base::close(...future.stdout)
[10:18:32.113]         }, add = TRUE)
[10:18:32.113]     }
[10:18:32.113]     ...future.frame <- base::sys.nframe()
[10:18:32.113]     ...future.conditions <- base::list()
[10:18:32.113]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:32.113]     if (FALSE) {
[10:18:32.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:32.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:32.113]     }
[10:18:32.113]     ...future.result <- base::tryCatch({
[10:18:32.113]         base::withCallingHandlers({
[10:18:32.113]             ...future.value <- base::withVisible(base::local({
[10:18:32.113]                 withCallingHandlers({
[10:18:32.113]                   {
[10:18:32.113]                     do.call(function(...) {
[10:18:32.113]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.113]                       if (!identical(...future.globals.maxSize.org, 
[10:18:32.113]                         ...future.globals.maxSize)) {
[10:18:32.113]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.113]                         on.exit(options(oopts), add = TRUE)
[10:18:32.113]                       }
[10:18:32.113]                       {
[10:18:32.113]                         lapply(seq_along(...future.elements_ii), 
[10:18:32.113]                           FUN = function(jj) {
[10:18:32.113]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.113]                             ...future.FUN(...future.X_jj, ...)
[10:18:32.113]                           })
[10:18:32.113]                       }
[10:18:32.113]                     }, args = future.call.arguments)
[10:18:32.113]                   }
[10:18:32.113]                 }, immediateCondition = function(cond) {
[10:18:32.113]                   save_rds <- function (object, pathname, ...) 
[10:18:32.113]                   {
[10:18:32.113]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:32.113]                     if (file_test("-f", pathname_tmp)) {
[10:18:32.113]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.113]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:32.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.113]                         fi_tmp[["mtime"]])
[10:18:32.113]                     }
[10:18:32.113]                     tryCatch({
[10:18:32.113]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:32.113]                     }, error = function(ex) {
[10:18:32.113]                       msg <- conditionMessage(ex)
[10:18:32.113]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.113]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:32.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.113]                         fi_tmp[["mtime"]], msg)
[10:18:32.113]                       ex$message <- msg
[10:18:32.113]                       stop(ex)
[10:18:32.113]                     })
[10:18:32.113]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:32.113]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:32.113]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:32.113]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.113]                       fi <- file.info(pathname)
[10:18:32.113]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:32.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.113]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:32.113]                         fi[["size"]], fi[["mtime"]])
[10:18:32.113]                       stop(msg)
[10:18:32.113]                     }
[10:18:32.113]                     invisible(pathname)
[10:18:32.113]                   }
[10:18:32.113]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:32.113]                     rootPath = tempdir()) 
[10:18:32.113]                   {
[10:18:32.113]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:32.113]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:32.113]                       tmpdir = path, fileext = ".rds")
[10:18:32.113]                     save_rds(obj, file)
[10:18:32.113]                   }
[10:18:32.113]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:32.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.113]                   {
[10:18:32.113]                     inherits <- base::inherits
[10:18:32.113]                     invokeRestart <- base::invokeRestart
[10:18:32.113]                     is.null <- base::is.null
[10:18:32.113]                     muffled <- FALSE
[10:18:32.113]                     if (inherits(cond, "message")) {
[10:18:32.113]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:32.113]                       if (muffled) 
[10:18:32.113]                         invokeRestart("muffleMessage")
[10:18:32.113]                     }
[10:18:32.113]                     else if (inherits(cond, "warning")) {
[10:18:32.113]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:32.113]                       if (muffled) 
[10:18:32.113]                         invokeRestart("muffleWarning")
[10:18:32.113]                     }
[10:18:32.113]                     else if (inherits(cond, "condition")) {
[10:18:32.113]                       if (!is.null(pattern)) {
[10:18:32.113]                         computeRestarts <- base::computeRestarts
[10:18:32.113]                         grepl <- base::grepl
[10:18:32.113]                         restarts <- computeRestarts(cond)
[10:18:32.113]                         for (restart in restarts) {
[10:18:32.113]                           name <- restart$name
[10:18:32.113]                           if (is.null(name)) 
[10:18:32.113]                             next
[10:18:32.113]                           if (!grepl(pattern, name)) 
[10:18:32.113]                             next
[10:18:32.113]                           invokeRestart(restart)
[10:18:32.113]                           muffled <- TRUE
[10:18:32.113]                           break
[10:18:32.113]                         }
[10:18:32.113]                       }
[10:18:32.113]                     }
[10:18:32.113]                     invisible(muffled)
[10:18:32.113]                   }
[10:18:32.113]                   muffleCondition(cond)
[10:18:32.113]                 })
[10:18:32.113]             }))
[10:18:32.113]             future::FutureResult(value = ...future.value$value, 
[10:18:32.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.113]                   ...future.rng), globalenv = if (FALSE) 
[10:18:32.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:32.113]                     ...future.globalenv.names))
[10:18:32.113]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:32.113]         }, condition = base::local({
[10:18:32.113]             c <- base::c
[10:18:32.113]             inherits <- base::inherits
[10:18:32.113]             invokeRestart <- base::invokeRestart
[10:18:32.113]             length <- base::length
[10:18:32.113]             list <- base::list
[10:18:32.113]             seq.int <- base::seq.int
[10:18:32.113]             signalCondition <- base::signalCondition
[10:18:32.113]             sys.calls <- base::sys.calls
[10:18:32.113]             `[[` <- base::`[[`
[10:18:32.113]             `+` <- base::`+`
[10:18:32.113]             `<<-` <- base::`<<-`
[10:18:32.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:32.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:32.113]                   3L)]
[10:18:32.113]             }
[10:18:32.113]             function(cond) {
[10:18:32.113]                 is_error <- inherits(cond, "error")
[10:18:32.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:32.113]                   NULL)
[10:18:32.113]                 if (is_error) {
[10:18:32.113]                   sessionInformation <- function() {
[10:18:32.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:32.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:32.113]                       search = base::search(), system = base::Sys.info())
[10:18:32.113]                   }
[10:18:32.113]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:32.113]                     cond$call), session = sessionInformation(), 
[10:18:32.113]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:32.113]                   signalCondition(cond)
[10:18:32.113]                 }
[10:18:32.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:32.113]                 "immediateCondition"))) {
[10:18:32.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:32.113]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:32.113]                   if (TRUE && !signal) {
[10:18:32.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.113]                     {
[10:18:32.113]                       inherits <- base::inherits
[10:18:32.113]                       invokeRestart <- base::invokeRestart
[10:18:32.113]                       is.null <- base::is.null
[10:18:32.113]                       muffled <- FALSE
[10:18:32.113]                       if (inherits(cond, "message")) {
[10:18:32.113]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.113]                         if (muffled) 
[10:18:32.113]                           invokeRestart("muffleMessage")
[10:18:32.113]                       }
[10:18:32.113]                       else if (inherits(cond, "warning")) {
[10:18:32.113]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.113]                         if (muffled) 
[10:18:32.113]                           invokeRestart("muffleWarning")
[10:18:32.113]                       }
[10:18:32.113]                       else if (inherits(cond, "condition")) {
[10:18:32.113]                         if (!is.null(pattern)) {
[10:18:32.113]                           computeRestarts <- base::computeRestarts
[10:18:32.113]                           grepl <- base::grepl
[10:18:32.113]                           restarts <- computeRestarts(cond)
[10:18:32.113]                           for (restart in restarts) {
[10:18:32.113]                             name <- restart$name
[10:18:32.113]                             if (is.null(name)) 
[10:18:32.113]                               next
[10:18:32.113]                             if (!grepl(pattern, name)) 
[10:18:32.113]                               next
[10:18:32.113]                             invokeRestart(restart)
[10:18:32.113]                             muffled <- TRUE
[10:18:32.113]                             break
[10:18:32.113]                           }
[10:18:32.113]                         }
[10:18:32.113]                       }
[10:18:32.113]                       invisible(muffled)
[10:18:32.113]                     }
[10:18:32.113]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.113]                   }
[10:18:32.113]                 }
[10:18:32.113]                 else {
[10:18:32.113]                   if (TRUE) {
[10:18:32.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.113]                     {
[10:18:32.113]                       inherits <- base::inherits
[10:18:32.113]                       invokeRestart <- base::invokeRestart
[10:18:32.113]                       is.null <- base::is.null
[10:18:32.113]                       muffled <- FALSE
[10:18:32.113]                       if (inherits(cond, "message")) {
[10:18:32.113]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.113]                         if (muffled) 
[10:18:32.113]                           invokeRestart("muffleMessage")
[10:18:32.113]                       }
[10:18:32.113]                       else if (inherits(cond, "warning")) {
[10:18:32.113]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.113]                         if (muffled) 
[10:18:32.113]                           invokeRestart("muffleWarning")
[10:18:32.113]                       }
[10:18:32.113]                       else if (inherits(cond, "condition")) {
[10:18:32.113]                         if (!is.null(pattern)) {
[10:18:32.113]                           computeRestarts <- base::computeRestarts
[10:18:32.113]                           grepl <- base::grepl
[10:18:32.113]                           restarts <- computeRestarts(cond)
[10:18:32.113]                           for (restart in restarts) {
[10:18:32.113]                             name <- restart$name
[10:18:32.113]                             if (is.null(name)) 
[10:18:32.113]                               next
[10:18:32.113]                             if (!grepl(pattern, name)) 
[10:18:32.113]                               next
[10:18:32.113]                             invokeRestart(restart)
[10:18:32.113]                             muffled <- TRUE
[10:18:32.113]                             break
[10:18:32.113]                           }
[10:18:32.113]                         }
[10:18:32.113]                       }
[10:18:32.113]                       invisible(muffled)
[10:18:32.113]                     }
[10:18:32.113]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.113]                   }
[10:18:32.113]                 }
[10:18:32.113]             }
[10:18:32.113]         }))
[10:18:32.113]     }, error = function(ex) {
[10:18:32.113]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:32.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.113]                 ...future.rng), started = ...future.startTime, 
[10:18:32.113]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:32.113]             version = "1.8"), class = "FutureResult")
[10:18:32.113]     }, finally = {
[10:18:32.113]         if (!identical(...future.workdir, getwd())) 
[10:18:32.113]             setwd(...future.workdir)
[10:18:32.113]         {
[10:18:32.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:32.113]                 ...future.oldOptions$nwarnings <- NULL
[10:18:32.113]             }
[10:18:32.113]             base::options(...future.oldOptions)
[10:18:32.113]             if (.Platform$OS.type == "windows") {
[10:18:32.113]                 old_names <- names(...future.oldEnvVars)
[10:18:32.113]                 envs <- base::Sys.getenv()
[10:18:32.113]                 names <- names(envs)
[10:18:32.113]                 common <- intersect(names, old_names)
[10:18:32.113]                 added <- setdiff(names, old_names)
[10:18:32.113]                 removed <- setdiff(old_names, names)
[10:18:32.113]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:32.113]                   envs[common]]
[10:18:32.113]                 NAMES <- toupper(changed)
[10:18:32.113]                 args <- list()
[10:18:32.113]                 for (kk in seq_along(NAMES)) {
[10:18:32.113]                   name <- changed[[kk]]
[10:18:32.113]                   NAME <- NAMES[[kk]]
[10:18:32.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.113]                     next
[10:18:32.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.113]                 }
[10:18:32.113]                 NAMES <- toupper(added)
[10:18:32.113]                 for (kk in seq_along(NAMES)) {
[10:18:32.113]                   name <- added[[kk]]
[10:18:32.113]                   NAME <- NAMES[[kk]]
[10:18:32.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.113]                     next
[10:18:32.113]                   args[[name]] <- ""
[10:18:32.113]                 }
[10:18:32.113]                 NAMES <- toupper(removed)
[10:18:32.113]                 for (kk in seq_along(NAMES)) {
[10:18:32.113]                   name <- removed[[kk]]
[10:18:32.113]                   NAME <- NAMES[[kk]]
[10:18:32.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.113]                     next
[10:18:32.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.113]                 }
[10:18:32.113]                 if (length(args) > 0) 
[10:18:32.113]                   base::do.call(base::Sys.setenv, args = args)
[10:18:32.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:32.113]             }
[10:18:32.113]             else {
[10:18:32.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:32.113]             }
[10:18:32.113]             {
[10:18:32.113]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:32.113]                   0L) {
[10:18:32.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:32.113]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:32.113]                   base::options(opts)
[10:18:32.113]                 }
[10:18:32.113]                 {
[10:18:32.113]                   {
[10:18:32.113]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:32.113]                     NULL
[10:18:32.113]                   }
[10:18:32.113]                   options(future.plan = NULL)
[10:18:32.113]                   if (is.na(NA_character_)) 
[10:18:32.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:32.113]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:32.113]                     .init = FALSE)
[10:18:32.113]                 }
[10:18:32.113]             }
[10:18:32.113]         }
[10:18:32.113]     })
[10:18:32.113]     if (TRUE) {
[10:18:32.113]         base::sink(type = "output", split = FALSE)
[10:18:32.113]         if (TRUE) {
[10:18:32.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:32.113]         }
[10:18:32.113]         else {
[10:18:32.113]             ...future.result["stdout"] <- base::list(NULL)
[10:18:32.113]         }
[10:18:32.113]         base::close(...future.stdout)
[10:18:32.113]         ...future.stdout <- NULL
[10:18:32.113]     }
[10:18:32.113]     ...future.result$conditions <- ...future.conditions
[10:18:32.113]     ...future.result$finished <- base::Sys.time()
[10:18:32.113]     ...future.result
[10:18:32.113] }
[10:18:32.117] assign_globals() ...
[10:18:32.117] List of 5
[10:18:32.117]  $ ...future.FUN            :function (x, ...)  
[10:18:32.117]  $ future.call.arguments    :List of 1
[10:18:32.117]   ..$ singular.ok: logi FALSE
[10:18:32.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.117]  $ ...future.elements_ii    :List of 2
[10:18:32.117]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.117]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:32.117]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.117]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:32.117]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.117]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:32.117]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.117]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:32.117]  $ ...future.seeds_ii       : NULL
[10:18:32.117]  $ ...future.globals.maxSize: NULL
[10:18:32.117]  - attr(*, "where")=List of 5
[10:18:32.117]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:32.117]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:32.117]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:32.117]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:32.117]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:32.117]  - attr(*, "resolved")= logi FALSE
[10:18:32.117]  - attr(*, "total_size")= num 19977
[10:18:32.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.117]  - attr(*, "already-done")= logi TRUE
[10:18:32.132] - reassign environment for ‘...future.FUN’
[10:18:32.132] - copied ‘...future.FUN’ to environment
[10:18:32.133] - copied ‘future.call.arguments’ to environment
[10:18:32.133] - copied ‘...future.elements_ii’ to environment
[10:18:32.133] - copied ‘...future.seeds_ii’ to environment
[10:18:32.133] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.133] assign_globals() ... done
[10:18:32.133] requestCore(): workers = 2
[10:18:32.136] MulticoreFuture started
[10:18:32.137] - Launch lazy future ... done
[10:18:32.137] run() for ‘MulticoreFuture’ ... done
[10:18:32.137] Created future:
[10:18:32.138] plan(): Setting new future strategy stack:
[10:18:32.138] List of future strategies:
[10:18:32.138] 1. sequential:
[10:18:32.138]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.138]    - tweaked: FALSE
[10:18:32.138]    - call: NULL
[10:18:32.139] plan(): nbrOfWorkers() = 1
[10:18:32.145] plan(): Setting new future strategy stack:
[10:18:32.145] List of future strategies:
[10:18:32.145] 1. multicore:
[10:18:32.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.145]    - tweaked: FALSE
[10:18:32.145]    - call: plan(strategy)
[10:18:32.148] plan(): nbrOfWorkers() = 2
[10:18:32.138] MulticoreFuture:
[10:18:32.138] Label: ‘future_by-2’
[10:18:32.138] Expression:
[10:18:32.138] {
[10:18:32.138]     do.call(function(...) {
[10:18:32.138]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.138]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.138]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.138]             on.exit(options(oopts), add = TRUE)
[10:18:32.138]         }
[10:18:32.138]         {
[10:18:32.138]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.138]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.138]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.138]             })
[10:18:32.138]         }
[10:18:32.138]     }, args = future.call.arguments)
[10:18:32.138] }
[10:18:32.138] Lazy evaluation: FALSE
[10:18:32.138] Asynchronous evaluation: TRUE
[10:18:32.138] Local evaluation: TRUE
[10:18:32.138] Environment: R_GlobalEnv
[10:18:32.138] Capture standard output: TRUE
[10:18:32.138] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.138] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:32.138] Packages: 1 packages (‘stats’)
[10:18:32.138] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.138] Resolved: TRUE
[10:18:32.138] Value: <not collected>
[10:18:32.138] Conditions captured: <none>
[10:18:32.138] Early signaling: FALSE
[10:18:32.138] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.138] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.150] Chunk #2 of 2 ... DONE
[10:18:32.150] Launching 2 futures (chunks) ... DONE
[10:18:32.150] Resolving 2 futures (chunks) ...
[10:18:32.151] resolve() on list ...
[10:18:32.151]  recursive: 0
[10:18:32.151]  length: 2
[10:18:32.151] 
[10:18:32.151] Future #1
[10:18:32.151] result() for MulticoreFuture ...
[10:18:32.153] result() for MulticoreFuture ...
[10:18:32.153] result() for MulticoreFuture ... done
[10:18:32.154] result() for MulticoreFuture ... done
[10:18:32.154] result() for MulticoreFuture ...
[10:18:32.154] result() for MulticoreFuture ... done
[10:18:32.154] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:32.154] - nx: 2
[10:18:32.154] - relay: TRUE
[10:18:32.154] - stdout: TRUE
[10:18:32.155] - signal: TRUE
[10:18:32.155] - resignal: FALSE
[10:18:32.155] - force: TRUE
[10:18:32.155] - relayed: [n=2] FALSE, FALSE
[10:18:32.155] - queued futures: [n=2] FALSE, FALSE
[10:18:32.155]  - until=1
[10:18:32.155]  - relaying element #1
[10:18:32.155] result() for MulticoreFuture ...
[10:18:32.156] result() for MulticoreFuture ... done
[10:18:32.156] result() for MulticoreFuture ...
[10:18:32.156] result() for MulticoreFuture ... done
[10:18:32.156] result() for MulticoreFuture ...
[10:18:32.156] result() for MulticoreFuture ... done
[10:18:32.157] result() for MulticoreFuture ...
[10:18:32.157] result() for MulticoreFuture ... done
[10:18:32.157] - relayed: [n=2] TRUE, FALSE
[10:18:32.157] - queued futures: [n=2] TRUE, FALSE
[10:18:32.157] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:32.158]  length: 1 (resolved future 1)
[10:18:32.158] Future #2
[10:18:32.158] result() for MulticoreFuture ...
[10:18:32.160] result() for MulticoreFuture ...
[10:18:32.160] result() for MulticoreFuture ... done
[10:18:32.160] result() for MulticoreFuture ... done
[10:18:32.160] result() for MulticoreFuture ...
[10:18:32.161] result() for MulticoreFuture ... done
[10:18:32.161] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:32.161] - nx: 2
[10:18:32.161] - relay: TRUE
[10:18:32.161] - stdout: TRUE
[10:18:32.161] - signal: TRUE
[10:18:32.162] - resignal: FALSE
[10:18:32.162] - force: TRUE
[10:18:32.162] - relayed: [n=2] TRUE, FALSE
[10:18:32.162] - queued futures: [n=2] TRUE, FALSE
[10:18:32.162]  - until=2
[10:18:32.162]  - relaying element #2
[10:18:32.162] result() for MulticoreFuture ...
[10:18:32.162] result() for MulticoreFuture ... done
[10:18:32.163] result() for MulticoreFuture ...
[10:18:32.163] result() for MulticoreFuture ... done
[10:18:32.163] result() for MulticoreFuture ...
[10:18:32.163] result() for MulticoreFuture ... done
[10:18:32.163] result() for MulticoreFuture ...
[10:18:32.163] result() for MulticoreFuture ... done
[10:18:32.163] - relayed: [n=2] TRUE, TRUE
[10:18:32.163] - queued futures: [n=2] TRUE, TRUE
[10:18:32.164] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:32.164]  length: 0 (resolved future 2)
[10:18:32.164] Relaying remaining futures
[10:18:32.164] signalConditionsASAP(NULL, pos=0) ...
[10:18:32.164] - nx: 2
[10:18:32.164] - relay: TRUE
[10:18:32.164] - stdout: TRUE
[10:18:32.164] - signal: TRUE
[10:18:32.164] - resignal: FALSE
[10:18:32.164] - force: TRUE
[10:18:32.165] - relayed: [n=2] TRUE, TRUE
[10:18:32.165] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:32.165] - relayed: [n=2] TRUE, TRUE
[10:18:32.165] - queued futures: [n=2] TRUE, TRUE
[10:18:32.165] signalConditionsASAP(NULL, pos=0) ... done
[10:18:32.165] resolve() on list ... DONE
[10:18:32.165] result() for MulticoreFuture ...
[10:18:32.165] result() for MulticoreFuture ... done
[10:18:32.168] result() for MulticoreFuture ...
[10:18:32.169] result() for MulticoreFuture ... done
[10:18:32.169] result() for MulticoreFuture ...
[10:18:32.169] result() for MulticoreFuture ... done
[10:18:32.169] result() for MulticoreFuture ...
[10:18:32.169] result() for MulticoreFuture ... done
[10:18:32.169]  - Number of value chunks collected: 2
[10:18:32.169] Resolving 2 futures (chunks) ... DONE
[10:18:32.170] Reducing values from 2 chunks ...
[10:18:32.170]  - Number of values collected after concatenation: 3
[10:18:32.170]  - Number of values expected: 3
[10:18:32.170] Reducing values from 2 chunks ... DONE
[10:18:32.170] future_lapply() ... DONE
[10:18:32.170] future_by_internal() ... DONE
[10:18:32.177] future_by_internal() ...
[10:18:32.177] future_lapply() ...
[10:18:32.180] Number of chunks: 2
[10:18:32.180] getGlobalsAndPackagesXApply() ...
[10:18:32.180]  - future.globals: TRUE
[10:18:32.180] getGlobalsAndPackages() ...
[10:18:32.181] Searching for globals...
[10:18:32.182] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:32.183] Searching for globals ... DONE
[10:18:32.183] Resolving globals: FALSE
[10:18:32.183] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:18:32.184] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:18:32.184] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:32.184] - packages: [1] ‘stats’
[10:18:32.184] getGlobalsAndPackages() ... DONE
[10:18:32.184]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:32.184]  - needed namespaces: [n=1] ‘stats’
[10:18:32.184] Finding globals ... DONE
[10:18:32.184]  - use_args: TRUE
[10:18:32.184]  - Getting '...' globals ...
[10:18:32.185] resolve() on list ...
[10:18:32.185]  recursive: 0
[10:18:32.185]  length: 1
[10:18:32.185]  elements: ‘...’
[10:18:32.185]  length: 0 (resolved future 1)
[10:18:32.185] resolve() on list ... DONE
[10:18:32.185]    - '...' content: [n=0] 
[10:18:32.185] List of 1
[10:18:32.185]  $ ...: list()
[10:18:32.185]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.185]  - attr(*, "where")=List of 1
[10:18:32.185]   ..$ ...:<environment: 0x558448e431e0> 
[10:18:32.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.185]  - attr(*, "resolved")= logi TRUE
[10:18:32.185]  - attr(*, "total_size")= num NA
[10:18:32.188]  - Getting '...' globals ... DONE
[10:18:32.188] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:18:32.188] List of 4
[10:18:32.188]  $ ...future.FUN:function (x)  
[10:18:32.188]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:32.188]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:32.188]  $ ...          : list()
[10:18:32.188]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.188]  - attr(*, "where")=List of 4
[10:18:32.188]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:32.188]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:18:32.188]   ..$ wool         :<environment: R_EmptyEnv> 
[10:18:32.188]   ..$ ...          :<environment: 0x558448e431e0> 
[10:18:32.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.188]  - attr(*, "resolved")= logi FALSE
[10:18:32.188]  - attr(*, "total_size")= num 18867
[10:18:32.195] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:32.195] getGlobalsAndPackagesXApply() ... DONE
[10:18:32.195] Number of futures (= number of chunks): 2
[10:18:32.195] Launching 2 futures (chunks) ...
[10:18:32.195] Chunk #1 of 2 ...
[10:18:32.196]  - Finding globals in 'X' for chunk #1 ...
[10:18:32.196] getGlobalsAndPackages() ...
[10:18:32.196] Searching for globals...
[10:18:32.196] 
[10:18:32.196] Searching for globals ... DONE
[10:18:32.197] - globals: [0] <none>
[10:18:32.197] getGlobalsAndPackages() ... DONE
[10:18:32.197]    + additional globals found: [n=0] 
[10:18:32.197]    + additional namespaces needed: [n=0] 
[10:18:32.197]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:32.197]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:32.197]  - seeds: <none>
[10:18:32.197]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.197] getGlobalsAndPackages() ...
[10:18:32.198] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.198] Resolving globals: FALSE
[10:18:32.198] Tweak future expression to call with '...' arguments ...
[10:18:32.198] {
[10:18:32.198]     do.call(function(...) {
[10:18:32.198]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.198]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.198]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.198]             on.exit(options(oopts), add = TRUE)
[10:18:32.198]         }
[10:18:32.198]         {
[10:18:32.198]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.198]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.198]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.198]             })
[10:18:32.198]         }
[10:18:32.198]     }, args = future.call.arguments)
[10:18:32.198] }
[10:18:32.198] Tweak future expression to call with '...' arguments ... DONE
[10:18:32.199] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.199] 
[10:18:32.199] getGlobalsAndPackages() ... DONE
[10:18:32.199] run() for ‘Future’ ...
[10:18:32.199] - state: ‘created’
[10:18:32.199] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:32.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:32.201]   - Field: ‘label’
[10:18:32.201]   - Field: ‘local’
[10:18:32.202]   - Field: ‘owner’
[10:18:32.202]   - Field: ‘envir’
[10:18:32.202]   - Field: ‘workers’
[10:18:32.202]   - Field: ‘packages’
[10:18:32.202]   - Field: ‘gc’
[10:18:32.202]   - Field: ‘job’
[10:18:32.202]   - Field: ‘conditions’
[10:18:32.202]   - Field: ‘expr’
[10:18:32.202]   - Field: ‘uuid’
[10:18:32.202]   - Field: ‘seed’
[10:18:32.202]   - Field: ‘version’
[10:18:32.203]   - Field: ‘result’
[10:18:32.203]   - Field: ‘asynchronous’
[10:18:32.203]   - Field: ‘calls’
[10:18:32.203]   - Field: ‘globals’
[10:18:32.203]   - Field: ‘stdout’
[10:18:32.203]   - Field: ‘earlySignal’
[10:18:32.203]   - Field: ‘lazy’
[10:18:32.203]   - Field: ‘state’
[10:18:32.203] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:32.203] - Launch lazy future ...
[10:18:32.204] Packages needed by the future expression (n = 1): ‘stats’
[10:18:32.204] Packages needed by future strategies (n = 0): <none>
[10:18:32.204] {
[10:18:32.204]     {
[10:18:32.204]         {
[10:18:32.204]             ...future.startTime <- base::Sys.time()
[10:18:32.204]             {
[10:18:32.204]                 {
[10:18:32.204]                   {
[10:18:32.204]                     {
[10:18:32.204]                       {
[10:18:32.204]                         base::local({
[10:18:32.204]                           has_future <- base::requireNamespace("future", 
[10:18:32.204]                             quietly = TRUE)
[10:18:32.204]                           if (has_future) {
[10:18:32.204]                             ns <- base::getNamespace("future")
[10:18:32.204]                             version <- ns[[".package"]][["version"]]
[10:18:32.204]                             if (is.null(version)) 
[10:18:32.204]                               version <- utils::packageVersion("future")
[10:18:32.204]                           }
[10:18:32.204]                           else {
[10:18:32.204]                             version <- NULL
[10:18:32.204]                           }
[10:18:32.204]                           if (!has_future || version < "1.8.0") {
[10:18:32.204]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:32.204]                               "", base::R.version$version.string), 
[10:18:32.204]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:32.204]                                 base::R.version$platform, 8 * 
[10:18:32.204]                                   base::.Machine$sizeof.pointer), 
[10:18:32.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:32.204]                                 "release", "version")], collapse = " "), 
[10:18:32.204]                               hostname = base::Sys.info()[["nodename"]])
[10:18:32.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:32.204]                               info)
[10:18:32.204]                             info <- base::paste(info, collapse = "; ")
[10:18:32.204]                             if (!has_future) {
[10:18:32.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:32.204]                                 info)
[10:18:32.204]                             }
[10:18:32.204]                             else {
[10:18:32.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:32.204]                                 info, version)
[10:18:32.204]                             }
[10:18:32.204]                             base::stop(msg)
[10:18:32.204]                           }
[10:18:32.204]                         })
[10:18:32.204]                       }
[10:18:32.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:32.204]                       base::options(mc.cores = 1L)
[10:18:32.204]                     }
[10:18:32.204]                     base::local({
[10:18:32.204]                       for (pkg in "stats") {
[10:18:32.204]                         base::loadNamespace(pkg)
[10:18:32.204]                         base::library(pkg, character.only = TRUE)
[10:18:32.204]                       }
[10:18:32.204]                     })
[10:18:32.204]                   }
[10:18:32.204]                   ...future.strategy.old <- future::plan("list")
[10:18:32.204]                   options(future.plan = NULL)
[10:18:32.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:32.204]                 }
[10:18:32.204]                 ...future.workdir <- getwd()
[10:18:32.204]             }
[10:18:32.204]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:32.204]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:32.204]         }
[10:18:32.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:32.204]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:32.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:32.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:32.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:32.204]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:32.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:32.204]             base::names(...future.oldOptions))
[10:18:32.204]     }
[10:18:32.204]     if (FALSE) {
[10:18:32.204]     }
[10:18:32.204]     else {
[10:18:32.204]         if (TRUE) {
[10:18:32.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:32.204]                 open = "w")
[10:18:32.204]         }
[10:18:32.204]         else {
[10:18:32.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:32.204]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:32.204]         }
[10:18:32.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:32.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:32.204]             base::sink(type = "output", split = FALSE)
[10:18:32.204]             base::close(...future.stdout)
[10:18:32.204]         }, add = TRUE)
[10:18:32.204]     }
[10:18:32.204]     ...future.frame <- base::sys.nframe()
[10:18:32.204]     ...future.conditions <- base::list()
[10:18:32.204]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:32.204]     if (FALSE) {
[10:18:32.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:32.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:32.204]     }
[10:18:32.204]     ...future.result <- base::tryCatch({
[10:18:32.204]         base::withCallingHandlers({
[10:18:32.204]             ...future.value <- base::withVisible(base::local({
[10:18:32.204]                 withCallingHandlers({
[10:18:32.204]                   {
[10:18:32.204]                     do.call(function(...) {
[10:18:32.204]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.204]                       if (!identical(...future.globals.maxSize.org, 
[10:18:32.204]                         ...future.globals.maxSize)) {
[10:18:32.204]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.204]                         on.exit(options(oopts), add = TRUE)
[10:18:32.204]                       }
[10:18:32.204]                       {
[10:18:32.204]                         lapply(seq_along(...future.elements_ii), 
[10:18:32.204]                           FUN = function(jj) {
[10:18:32.204]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.204]                             ...future.FUN(...future.X_jj, ...)
[10:18:32.204]                           })
[10:18:32.204]                       }
[10:18:32.204]                     }, args = future.call.arguments)
[10:18:32.204]                   }
[10:18:32.204]                 }, immediateCondition = function(cond) {
[10:18:32.204]                   save_rds <- function (object, pathname, ...) 
[10:18:32.204]                   {
[10:18:32.204]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:32.204]                     if (file_test("-f", pathname_tmp)) {
[10:18:32.204]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.204]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:32.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.204]                         fi_tmp[["mtime"]])
[10:18:32.204]                     }
[10:18:32.204]                     tryCatch({
[10:18:32.204]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:32.204]                     }, error = function(ex) {
[10:18:32.204]                       msg <- conditionMessage(ex)
[10:18:32.204]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.204]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:32.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.204]                         fi_tmp[["mtime"]], msg)
[10:18:32.204]                       ex$message <- msg
[10:18:32.204]                       stop(ex)
[10:18:32.204]                     })
[10:18:32.204]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:32.204]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:32.204]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:32.204]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.204]                       fi <- file.info(pathname)
[10:18:32.204]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:32.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.204]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:32.204]                         fi[["size"]], fi[["mtime"]])
[10:18:32.204]                       stop(msg)
[10:18:32.204]                     }
[10:18:32.204]                     invisible(pathname)
[10:18:32.204]                   }
[10:18:32.204]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:32.204]                     rootPath = tempdir()) 
[10:18:32.204]                   {
[10:18:32.204]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:32.204]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:32.204]                       tmpdir = path, fileext = ".rds")
[10:18:32.204]                     save_rds(obj, file)
[10:18:32.204]                   }
[10:18:32.204]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:32.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.204]                   {
[10:18:32.204]                     inherits <- base::inherits
[10:18:32.204]                     invokeRestart <- base::invokeRestart
[10:18:32.204]                     is.null <- base::is.null
[10:18:32.204]                     muffled <- FALSE
[10:18:32.204]                     if (inherits(cond, "message")) {
[10:18:32.204]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:32.204]                       if (muffled) 
[10:18:32.204]                         invokeRestart("muffleMessage")
[10:18:32.204]                     }
[10:18:32.204]                     else if (inherits(cond, "warning")) {
[10:18:32.204]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:32.204]                       if (muffled) 
[10:18:32.204]                         invokeRestart("muffleWarning")
[10:18:32.204]                     }
[10:18:32.204]                     else if (inherits(cond, "condition")) {
[10:18:32.204]                       if (!is.null(pattern)) {
[10:18:32.204]                         computeRestarts <- base::computeRestarts
[10:18:32.204]                         grepl <- base::grepl
[10:18:32.204]                         restarts <- computeRestarts(cond)
[10:18:32.204]                         for (restart in restarts) {
[10:18:32.204]                           name <- restart$name
[10:18:32.204]                           if (is.null(name)) 
[10:18:32.204]                             next
[10:18:32.204]                           if (!grepl(pattern, name)) 
[10:18:32.204]                             next
[10:18:32.204]                           invokeRestart(restart)
[10:18:32.204]                           muffled <- TRUE
[10:18:32.204]                           break
[10:18:32.204]                         }
[10:18:32.204]                       }
[10:18:32.204]                     }
[10:18:32.204]                     invisible(muffled)
[10:18:32.204]                   }
[10:18:32.204]                   muffleCondition(cond)
[10:18:32.204]                 })
[10:18:32.204]             }))
[10:18:32.204]             future::FutureResult(value = ...future.value$value, 
[10:18:32.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.204]                   ...future.rng), globalenv = if (FALSE) 
[10:18:32.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:32.204]                     ...future.globalenv.names))
[10:18:32.204]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:32.204]         }, condition = base::local({
[10:18:32.204]             c <- base::c
[10:18:32.204]             inherits <- base::inherits
[10:18:32.204]             invokeRestart <- base::invokeRestart
[10:18:32.204]             length <- base::length
[10:18:32.204]             list <- base::list
[10:18:32.204]             seq.int <- base::seq.int
[10:18:32.204]             signalCondition <- base::signalCondition
[10:18:32.204]             sys.calls <- base::sys.calls
[10:18:32.204]             `[[` <- base::`[[`
[10:18:32.204]             `+` <- base::`+`
[10:18:32.204]             `<<-` <- base::`<<-`
[10:18:32.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:32.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:32.204]                   3L)]
[10:18:32.204]             }
[10:18:32.204]             function(cond) {
[10:18:32.204]                 is_error <- inherits(cond, "error")
[10:18:32.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:32.204]                   NULL)
[10:18:32.204]                 if (is_error) {
[10:18:32.204]                   sessionInformation <- function() {
[10:18:32.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:32.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:32.204]                       search = base::search(), system = base::Sys.info())
[10:18:32.204]                   }
[10:18:32.204]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:32.204]                     cond$call), session = sessionInformation(), 
[10:18:32.204]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:32.204]                   signalCondition(cond)
[10:18:32.204]                 }
[10:18:32.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:32.204]                 "immediateCondition"))) {
[10:18:32.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:32.204]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:32.204]                   if (TRUE && !signal) {
[10:18:32.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.204]                     {
[10:18:32.204]                       inherits <- base::inherits
[10:18:32.204]                       invokeRestart <- base::invokeRestart
[10:18:32.204]                       is.null <- base::is.null
[10:18:32.204]                       muffled <- FALSE
[10:18:32.204]                       if (inherits(cond, "message")) {
[10:18:32.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.204]                         if (muffled) 
[10:18:32.204]                           invokeRestart("muffleMessage")
[10:18:32.204]                       }
[10:18:32.204]                       else if (inherits(cond, "warning")) {
[10:18:32.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.204]                         if (muffled) 
[10:18:32.204]                           invokeRestart("muffleWarning")
[10:18:32.204]                       }
[10:18:32.204]                       else if (inherits(cond, "condition")) {
[10:18:32.204]                         if (!is.null(pattern)) {
[10:18:32.204]                           computeRestarts <- base::computeRestarts
[10:18:32.204]                           grepl <- base::grepl
[10:18:32.204]                           restarts <- computeRestarts(cond)
[10:18:32.204]                           for (restart in restarts) {
[10:18:32.204]                             name <- restart$name
[10:18:32.204]                             if (is.null(name)) 
[10:18:32.204]                               next
[10:18:32.204]                             if (!grepl(pattern, name)) 
[10:18:32.204]                               next
[10:18:32.204]                             invokeRestart(restart)
[10:18:32.204]                             muffled <- TRUE
[10:18:32.204]                             break
[10:18:32.204]                           }
[10:18:32.204]                         }
[10:18:32.204]                       }
[10:18:32.204]                       invisible(muffled)
[10:18:32.204]                     }
[10:18:32.204]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.204]                   }
[10:18:32.204]                 }
[10:18:32.204]                 else {
[10:18:32.204]                   if (TRUE) {
[10:18:32.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.204]                     {
[10:18:32.204]                       inherits <- base::inherits
[10:18:32.204]                       invokeRestart <- base::invokeRestart
[10:18:32.204]                       is.null <- base::is.null
[10:18:32.204]                       muffled <- FALSE
[10:18:32.204]                       if (inherits(cond, "message")) {
[10:18:32.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.204]                         if (muffled) 
[10:18:32.204]                           invokeRestart("muffleMessage")
[10:18:32.204]                       }
[10:18:32.204]                       else if (inherits(cond, "warning")) {
[10:18:32.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.204]                         if (muffled) 
[10:18:32.204]                           invokeRestart("muffleWarning")
[10:18:32.204]                       }
[10:18:32.204]                       else if (inherits(cond, "condition")) {
[10:18:32.204]                         if (!is.null(pattern)) {
[10:18:32.204]                           computeRestarts <- base::computeRestarts
[10:18:32.204]                           grepl <- base::grepl
[10:18:32.204]                           restarts <- computeRestarts(cond)
[10:18:32.204]                           for (restart in restarts) {
[10:18:32.204]                             name <- restart$name
[10:18:32.204]                             if (is.null(name)) 
[10:18:32.204]                               next
[10:18:32.204]                             if (!grepl(pattern, name)) 
[10:18:32.204]                               next
[10:18:32.204]                             invokeRestart(restart)
[10:18:32.204]                             muffled <- TRUE
[10:18:32.204]                             break
[10:18:32.204]                           }
[10:18:32.204]                         }
[10:18:32.204]                       }
[10:18:32.204]                       invisible(muffled)
[10:18:32.204]                     }
[10:18:32.204]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.204]                   }
[10:18:32.204]                 }
[10:18:32.204]             }
[10:18:32.204]         }))
[10:18:32.204]     }, error = function(ex) {
[10:18:32.204]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:32.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.204]                 ...future.rng), started = ...future.startTime, 
[10:18:32.204]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:32.204]             version = "1.8"), class = "FutureResult")
[10:18:32.204]     }, finally = {
[10:18:32.204]         if (!identical(...future.workdir, getwd())) 
[10:18:32.204]             setwd(...future.workdir)
[10:18:32.204]         {
[10:18:32.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:32.204]                 ...future.oldOptions$nwarnings <- NULL
[10:18:32.204]             }
[10:18:32.204]             base::options(...future.oldOptions)
[10:18:32.204]             if (.Platform$OS.type == "windows") {
[10:18:32.204]                 old_names <- names(...future.oldEnvVars)
[10:18:32.204]                 envs <- base::Sys.getenv()
[10:18:32.204]                 names <- names(envs)
[10:18:32.204]                 common <- intersect(names, old_names)
[10:18:32.204]                 added <- setdiff(names, old_names)
[10:18:32.204]                 removed <- setdiff(old_names, names)
[10:18:32.204]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:32.204]                   envs[common]]
[10:18:32.204]                 NAMES <- toupper(changed)
[10:18:32.204]                 args <- list()
[10:18:32.204]                 for (kk in seq_along(NAMES)) {
[10:18:32.204]                   name <- changed[[kk]]
[10:18:32.204]                   NAME <- NAMES[[kk]]
[10:18:32.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.204]                     next
[10:18:32.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.204]                 }
[10:18:32.204]                 NAMES <- toupper(added)
[10:18:32.204]                 for (kk in seq_along(NAMES)) {
[10:18:32.204]                   name <- added[[kk]]
[10:18:32.204]                   NAME <- NAMES[[kk]]
[10:18:32.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.204]                     next
[10:18:32.204]                   args[[name]] <- ""
[10:18:32.204]                 }
[10:18:32.204]                 NAMES <- toupper(removed)
[10:18:32.204]                 for (kk in seq_along(NAMES)) {
[10:18:32.204]                   name <- removed[[kk]]
[10:18:32.204]                   NAME <- NAMES[[kk]]
[10:18:32.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.204]                     next
[10:18:32.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.204]                 }
[10:18:32.204]                 if (length(args) > 0) 
[10:18:32.204]                   base::do.call(base::Sys.setenv, args = args)
[10:18:32.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:32.204]             }
[10:18:32.204]             else {
[10:18:32.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:32.204]             }
[10:18:32.204]             {
[10:18:32.204]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:32.204]                   0L) {
[10:18:32.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:32.204]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:32.204]                   base::options(opts)
[10:18:32.204]                 }
[10:18:32.204]                 {
[10:18:32.204]                   {
[10:18:32.204]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:32.204]                     NULL
[10:18:32.204]                   }
[10:18:32.204]                   options(future.plan = NULL)
[10:18:32.204]                   if (is.na(NA_character_)) 
[10:18:32.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:32.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:32.204]                     .init = FALSE)
[10:18:32.204]                 }
[10:18:32.204]             }
[10:18:32.204]         }
[10:18:32.204]     })
[10:18:32.204]     if (TRUE) {
[10:18:32.204]         base::sink(type = "output", split = FALSE)
[10:18:32.204]         if (TRUE) {
[10:18:32.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:32.204]         }
[10:18:32.204]         else {
[10:18:32.204]             ...future.result["stdout"] <- base::list(NULL)
[10:18:32.204]         }
[10:18:32.204]         base::close(...future.stdout)
[10:18:32.204]         ...future.stdout <- NULL
[10:18:32.204]     }
[10:18:32.204]     ...future.result$conditions <- ...future.conditions
[10:18:32.204]     ...future.result$finished <- base::Sys.time()
[10:18:32.204]     ...future.result
[10:18:32.204] }
[10:18:32.207] assign_globals() ...
[10:18:32.207] List of 7
[10:18:32.207]  $ ...future.FUN            :function (x)  
[10:18:32.207]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:32.207]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:32.207]  $ future.call.arguments    : list()
[10:18:32.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.207]  $ ...future.elements_ii    :List of 1
[10:18:32.207]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.207]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:32.207]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.207]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:32.207]  $ ...future.seeds_ii       : NULL
[10:18:32.207]  $ ...future.globals.maxSize: NULL
[10:18:32.207]  - attr(*, "where")=List of 7
[10:18:32.207]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:32.207]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:18:32.207]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:18:32.207]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:32.207]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:32.207]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:32.207]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:32.207]  - attr(*, "resolved")= logi FALSE
[10:18:32.207]  - attr(*, "total_size")= num 18867
[10:18:32.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.207]  - attr(*, "already-done")= logi TRUE
[10:18:32.216] - reassign environment for ‘...future.FUN’
[10:18:32.217] - copied ‘...future.FUN’ to environment
[10:18:32.217] - copied ‘breaks’ to environment
[10:18:32.217] - copied ‘wool’ to environment
[10:18:32.217] - copied ‘future.call.arguments’ to environment
[10:18:32.217] - copied ‘...future.elements_ii’ to environment
[10:18:32.217] - copied ‘...future.seeds_ii’ to environment
[10:18:32.217] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.217] assign_globals() ... done
[10:18:32.218] requestCore(): workers = 2
[10:18:32.220] MulticoreFuture started
[10:18:32.221] - Launch lazy future ... done
[10:18:32.221] run() for ‘MulticoreFuture’ ... done
[10:18:32.222] Created future:
[10:18:32.222] plan(): Setting new future strategy stack:
[10:18:32.223] List of future strategies:
[10:18:32.223] 1. sequential:
[10:18:32.223]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.223]    - tweaked: FALSE
[10:18:32.223]    - call: NULL
[10:18:32.224] plan(): nbrOfWorkers() = 1
[10:18:32.230] plan(): Setting new future strategy stack:
[10:18:32.231] List of future strategies:
[10:18:32.231] 1. multicore:
[10:18:32.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.231]    - tweaked: FALSE
[10:18:32.231]    - call: plan(strategy)
[10:18:32.234] plan(): nbrOfWorkers() = 2
[10:18:32.222] MulticoreFuture:
[10:18:32.222] Label: ‘future_by-1’
[10:18:32.222] Expression:
[10:18:32.222] {
[10:18:32.222]     do.call(function(...) {
[10:18:32.222]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.222]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.222]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.222]             on.exit(options(oopts), add = TRUE)
[10:18:32.222]         }
[10:18:32.222]         {
[10:18:32.222]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.222]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.222]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.222]             })
[10:18:32.222]         }
[10:18:32.222]     }, args = future.call.arguments)
[10:18:32.222] }
[10:18:32.222] Lazy evaluation: FALSE
[10:18:32.222] Asynchronous evaluation: TRUE
[10:18:32.222] Local evaluation: TRUE
[10:18:32.222] Environment: 0x55844961dbe8
[10:18:32.222] Capture standard output: TRUE
[10:18:32.222] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.222] Globals: 7 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, ...)
[10:18:32.222] Packages: 1 packages (‘stats’)
[10:18:32.222] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.222] Resolved: TRUE
[10:18:32.222] Value: <not collected>
[10:18:32.222] Conditions captured: <none>
[10:18:32.222] Early signaling: FALSE
[10:18:32.222] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.222] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.236] Chunk #1 of 2 ... DONE
[10:18:32.236] Chunk #2 of 2 ...
[10:18:32.236]  - Finding globals in 'X' for chunk #2 ...
[10:18:32.237] getGlobalsAndPackages() ...
[10:18:32.237] Searching for globals...
[10:18:32.238] 
[10:18:32.238] Searching for globals ... DONE
[10:18:32.238] - globals: [0] <none>
[10:18:32.238] getGlobalsAndPackages() ... DONE
[10:18:32.239]    + additional globals found: [n=0] 
[10:18:32.239]    + additional namespaces needed: [n=0] 
[10:18:32.239]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:32.239]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:32.239]  - seeds: <none>
[10:18:32.239]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.239] getGlobalsAndPackages() ...
[10:18:32.240] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.240] Resolving globals: FALSE
[10:18:32.240] Tweak future expression to call with '...' arguments ...
[10:18:32.240] {
[10:18:32.240]     do.call(function(...) {
[10:18:32.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.240]             on.exit(options(oopts), add = TRUE)
[10:18:32.240]         }
[10:18:32.240]         {
[10:18:32.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.240]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.240]             })
[10:18:32.240]         }
[10:18:32.240]     }, args = future.call.arguments)
[10:18:32.240] }
[10:18:32.240] Tweak future expression to call with '...' arguments ... DONE
[10:18:32.241] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.241] 
[10:18:32.242] getGlobalsAndPackages() ... DONE
[10:18:32.242] run() for ‘Future’ ...
[10:18:32.242] - state: ‘created’
[10:18:32.243] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:32.245] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:32.246]   - Field: ‘label’
[10:18:32.246]   - Field: ‘local’
[10:18:32.246]   - Field: ‘owner’
[10:18:32.246]   - Field: ‘envir’
[10:18:32.246]   - Field: ‘workers’
[10:18:32.246]   - Field: ‘packages’
[10:18:32.246]   - Field: ‘gc’
[10:18:32.246]   - Field: ‘job’
[10:18:32.247]   - Field: ‘conditions’
[10:18:32.247]   - Field: ‘expr’
[10:18:32.247]   - Field: ‘uuid’
[10:18:32.247]   - Field: ‘seed’
[10:18:32.247]   - Field: ‘version’
[10:18:32.247]   - Field: ‘result’
[10:18:32.247]   - Field: ‘asynchronous’
[10:18:32.248]   - Field: ‘calls’
[10:18:32.248]   - Field: ‘globals’
[10:18:32.248]   - Field: ‘stdout’
[10:18:32.248]   - Field: ‘earlySignal’
[10:18:32.248]   - Field: ‘lazy’
[10:18:32.248]   - Field: ‘state’
[10:18:32.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:32.248] - Launch lazy future ...
[10:18:32.249] Packages needed by the future expression (n = 1): ‘stats’
[10:18:32.249] Packages needed by future strategies (n = 0): <none>
[10:18:32.250] {
[10:18:32.250]     {
[10:18:32.250]         {
[10:18:32.250]             ...future.startTime <- base::Sys.time()
[10:18:32.250]             {
[10:18:32.250]                 {
[10:18:32.250]                   {
[10:18:32.250]                     {
[10:18:32.250]                       {
[10:18:32.250]                         base::local({
[10:18:32.250]                           has_future <- base::requireNamespace("future", 
[10:18:32.250]                             quietly = TRUE)
[10:18:32.250]                           if (has_future) {
[10:18:32.250]                             ns <- base::getNamespace("future")
[10:18:32.250]                             version <- ns[[".package"]][["version"]]
[10:18:32.250]                             if (is.null(version)) 
[10:18:32.250]                               version <- utils::packageVersion("future")
[10:18:32.250]                           }
[10:18:32.250]                           else {
[10:18:32.250]                             version <- NULL
[10:18:32.250]                           }
[10:18:32.250]                           if (!has_future || version < "1.8.0") {
[10:18:32.250]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:32.250]                               "", base::R.version$version.string), 
[10:18:32.250]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:32.250]                                 base::R.version$platform, 8 * 
[10:18:32.250]                                   base::.Machine$sizeof.pointer), 
[10:18:32.250]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:32.250]                                 "release", "version")], collapse = " "), 
[10:18:32.250]                               hostname = base::Sys.info()[["nodename"]])
[10:18:32.250]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:32.250]                               info)
[10:18:32.250]                             info <- base::paste(info, collapse = "; ")
[10:18:32.250]                             if (!has_future) {
[10:18:32.250]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:32.250]                                 info)
[10:18:32.250]                             }
[10:18:32.250]                             else {
[10:18:32.250]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:32.250]                                 info, version)
[10:18:32.250]                             }
[10:18:32.250]                             base::stop(msg)
[10:18:32.250]                           }
[10:18:32.250]                         })
[10:18:32.250]                       }
[10:18:32.250]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:32.250]                       base::options(mc.cores = 1L)
[10:18:32.250]                     }
[10:18:32.250]                     base::local({
[10:18:32.250]                       for (pkg in "stats") {
[10:18:32.250]                         base::loadNamespace(pkg)
[10:18:32.250]                         base::library(pkg, character.only = TRUE)
[10:18:32.250]                       }
[10:18:32.250]                     })
[10:18:32.250]                   }
[10:18:32.250]                   ...future.strategy.old <- future::plan("list")
[10:18:32.250]                   options(future.plan = NULL)
[10:18:32.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:32.250]                 }
[10:18:32.250]                 ...future.workdir <- getwd()
[10:18:32.250]             }
[10:18:32.250]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:32.250]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:32.250]         }
[10:18:32.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:32.250]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:32.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:32.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:32.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:32.250]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:32.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:32.250]             base::names(...future.oldOptions))
[10:18:32.250]     }
[10:18:32.250]     if (FALSE) {
[10:18:32.250]     }
[10:18:32.250]     else {
[10:18:32.250]         if (TRUE) {
[10:18:32.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:32.250]                 open = "w")
[10:18:32.250]         }
[10:18:32.250]         else {
[10:18:32.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:32.250]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:32.250]         }
[10:18:32.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:32.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:32.250]             base::sink(type = "output", split = FALSE)
[10:18:32.250]             base::close(...future.stdout)
[10:18:32.250]         }, add = TRUE)
[10:18:32.250]     }
[10:18:32.250]     ...future.frame <- base::sys.nframe()
[10:18:32.250]     ...future.conditions <- base::list()
[10:18:32.250]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:32.250]     if (FALSE) {
[10:18:32.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:32.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:32.250]     }
[10:18:32.250]     ...future.result <- base::tryCatch({
[10:18:32.250]         base::withCallingHandlers({
[10:18:32.250]             ...future.value <- base::withVisible(base::local({
[10:18:32.250]                 withCallingHandlers({
[10:18:32.250]                   {
[10:18:32.250]                     do.call(function(...) {
[10:18:32.250]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.250]                       if (!identical(...future.globals.maxSize.org, 
[10:18:32.250]                         ...future.globals.maxSize)) {
[10:18:32.250]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.250]                         on.exit(options(oopts), add = TRUE)
[10:18:32.250]                       }
[10:18:32.250]                       {
[10:18:32.250]                         lapply(seq_along(...future.elements_ii), 
[10:18:32.250]                           FUN = function(jj) {
[10:18:32.250]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.250]                             ...future.FUN(...future.X_jj, ...)
[10:18:32.250]                           })
[10:18:32.250]                       }
[10:18:32.250]                     }, args = future.call.arguments)
[10:18:32.250]                   }
[10:18:32.250]                 }, immediateCondition = function(cond) {
[10:18:32.250]                   save_rds <- function (object, pathname, ...) 
[10:18:32.250]                   {
[10:18:32.250]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:32.250]                     if (file_test("-f", pathname_tmp)) {
[10:18:32.250]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.250]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:32.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.250]                         fi_tmp[["mtime"]])
[10:18:32.250]                     }
[10:18:32.250]                     tryCatch({
[10:18:32.250]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:32.250]                     }, error = function(ex) {
[10:18:32.250]                       msg <- conditionMessage(ex)
[10:18:32.250]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.250]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:32.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.250]                         fi_tmp[["mtime"]], msg)
[10:18:32.250]                       ex$message <- msg
[10:18:32.250]                       stop(ex)
[10:18:32.250]                     })
[10:18:32.250]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:32.250]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:32.250]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:32.250]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.250]                       fi <- file.info(pathname)
[10:18:32.250]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:32.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.250]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:32.250]                         fi[["size"]], fi[["mtime"]])
[10:18:32.250]                       stop(msg)
[10:18:32.250]                     }
[10:18:32.250]                     invisible(pathname)
[10:18:32.250]                   }
[10:18:32.250]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:32.250]                     rootPath = tempdir()) 
[10:18:32.250]                   {
[10:18:32.250]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:32.250]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:32.250]                       tmpdir = path, fileext = ".rds")
[10:18:32.250]                     save_rds(obj, file)
[10:18:32.250]                   }
[10:18:32.250]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:32.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.250]                   {
[10:18:32.250]                     inherits <- base::inherits
[10:18:32.250]                     invokeRestart <- base::invokeRestart
[10:18:32.250]                     is.null <- base::is.null
[10:18:32.250]                     muffled <- FALSE
[10:18:32.250]                     if (inherits(cond, "message")) {
[10:18:32.250]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:32.250]                       if (muffled) 
[10:18:32.250]                         invokeRestart("muffleMessage")
[10:18:32.250]                     }
[10:18:32.250]                     else if (inherits(cond, "warning")) {
[10:18:32.250]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:32.250]                       if (muffled) 
[10:18:32.250]                         invokeRestart("muffleWarning")
[10:18:32.250]                     }
[10:18:32.250]                     else if (inherits(cond, "condition")) {
[10:18:32.250]                       if (!is.null(pattern)) {
[10:18:32.250]                         computeRestarts <- base::computeRestarts
[10:18:32.250]                         grepl <- base::grepl
[10:18:32.250]                         restarts <- computeRestarts(cond)
[10:18:32.250]                         for (restart in restarts) {
[10:18:32.250]                           name <- restart$name
[10:18:32.250]                           if (is.null(name)) 
[10:18:32.250]                             next
[10:18:32.250]                           if (!grepl(pattern, name)) 
[10:18:32.250]                             next
[10:18:32.250]                           invokeRestart(restart)
[10:18:32.250]                           muffled <- TRUE
[10:18:32.250]                           break
[10:18:32.250]                         }
[10:18:32.250]                       }
[10:18:32.250]                     }
[10:18:32.250]                     invisible(muffled)
[10:18:32.250]                   }
[10:18:32.250]                   muffleCondition(cond)
[10:18:32.250]                 })
[10:18:32.250]             }))
[10:18:32.250]             future::FutureResult(value = ...future.value$value, 
[10:18:32.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.250]                   ...future.rng), globalenv = if (FALSE) 
[10:18:32.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:32.250]                     ...future.globalenv.names))
[10:18:32.250]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:32.250]         }, condition = base::local({
[10:18:32.250]             c <- base::c
[10:18:32.250]             inherits <- base::inherits
[10:18:32.250]             invokeRestart <- base::invokeRestart
[10:18:32.250]             length <- base::length
[10:18:32.250]             list <- base::list
[10:18:32.250]             seq.int <- base::seq.int
[10:18:32.250]             signalCondition <- base::signalCondition
[10:18:32.250]             sys.calls <- base::sys.calls
[10:18:32.250]             `[[` <- base::`[[`
[10:18:32.250]             `+` <- base::`+`
[10:18:32.250]             `<<-` <- base::`<<-`
[10:18:32.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:32.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:32.250]                   3L)]
[10:18:32.250]             }
[10:18:32.250]             function(cond) {
[10:18:32.250]                 is_error <- inherits(cond, "error")
[10:18:32.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:32.250]                   NULL)
[10:18:32.250]                 if (is_error) {
[10:18:32.250]                   sessionInformation <- function() {
[10:18:32.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:32.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:32.250]                       search = base::search(), system = base::Sys.info())
[10:18:32.250]                   }
[10:18:32.250]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:32.250]                     cond$call), session = sessionInformation(), 
[10:18:32.250]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:32.250]                   signalCondition(cond)
[10:18:32.250]                 }
[10:18:32.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:32.250]                 "immediateCondition"))) {
[10:18:32.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:32.250]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:32.250]                   if (TRUE && !signal) {
[10:18:32.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.250]                     {
[10:18:32.250]                       inherits <- base::inherits
[10:18:32.250]                       invokeRestart <- base::invokeRestart
[10:18:32.250]                       is.null <- base::is.null
[10:18:32.250]                       muffled <- FALSE
[10:18:32.250]                       if (inherits(cond, "message")) {
[10:18:32.250]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.250]                         if (muffled) 
[10:18:32.250]                           invokeRestart("muffleMessage")
[10:18:32.250]                       }
[10:18:32.250]                       else if (inherits(cond, "warning")) {
[10:18:32.250]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.250]                         if (muffled) 
[10:18:32.250]                           invokeRestart("muffleWarning")
[10:18:32.250]                       }
[10:18:32.250]                       else if (inherits(cond, "condition")) {
[10:18:32.250]                         if (!is.null(pattern)) {
[10:18:32.250]                           computeRestarts <- base::computeRestarts
[10:18:32.250]                           grepl <- base::grepl
[10:18:32.250]                           restarts <- computeRestarts(cond)
[10:18:32.250]                           for (restart in restarts) {
[10:18:32.250]                             name <- restart$name
[10:18:32.250]                             if (is.null(name)) 
[10:18:32.250]                               next
[10:18:32.250]                             if (!grepl(pattern, name)) 
[10:18:32.250]                               next
[10:18:32.250]                             invokeRestart(restart)
[10:18:32.250]                             muffled <- TRUE
[10:18:32.250]                             break
[10:18:32.250]                           }
[10:18:32.250]                         }
[10:18:32.250]                       }
[10:18:32.250]                       invisible(muffled)
[10:18:32.250]                     }
[10:18:32.250]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.250]                   }
[10:18:32.250]                 }
[10:18:32.250]                 else {
[10:18:32.250]                   if (TRUE) {
[10:18:32.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.250]                     {
[10:18:32.250]                       inherits <- base::inherits
[10:18:32.250]                       invokeRestart <- base::invokeRestart
[10:18:32.250]                       is.null <- base::is.null
[10:18:32.250]                       muffled <- FALSE
[10:18:32.250]                       if (inherits(cond, "message")) {
[10:18:32.250]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.250]                         if (muffled) 
[10:18:32.250]                           invokeRestart("muffleMessage")
[10:18:32.250]                       }
[10:18:32.250]                       else if (inherits(cond, "warning")) {
[10:18:32.250]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.250]                         if (muffled) 
[10:18:32.250]                           invokeRestart("muffleWarning")
[10:18:32.250]                       }
[10:18:32.250]                       else if (inherits(cond, "condition")) {
[10:18:32.250]                         if (!is.null(pattern)) {
[10:18:32.250]                           computeRestarts <- base::computeRestarts
[10:18:32.250]                           grepl <- base::grepl
[10:18:32.250]                           restarts <- computeRestarts(cond)
[10:18:32.250]                           for (restart in restarts) {
[10:18:32.250]                             name <- restart$name
[10:18:32.250]                             if (is.null(name)) 
[10:18:32.250]                               next
[10:18:32.250]                             if (!grepl(pattern, name)) 
[10:18:32.250]                               next
[10:18:32.250]                             invokeRestart(restart)
[10:18:32.250]                             muffled <- TRUE
[10:18:32.250]                             break
[10:18:32.250]                           }
[10:18:32.250]                         }
[10:18:32.250]                       }
[10:18:32.250]                       invisible(muffled)
[10:18:32.250]                     }
[10:18:32.250]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.250]                   }
[10:18:32.250]                 }
[10:18:32.250]             }
[10:18:32.250]         }))
[10:18:32.250]     }, error = function(ex) {
[10:18:32.250]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:32.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.250]                 ...future.rng), started = ...future.startTime, 
[10:18:32.250]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:32.250]             version = "1.8"), class = "FutureResult")
[10:18:32.250]     }, finally = {
[10:18:32.250]         if (!identical(...future.workdir, getwd())) 
[10:18:32.250]             setwd(...future.workdir)
[10:18:32.250]         {
[10:18:32.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:32.250]                 ...future.oldOptions$nwarnings <- NULL
[10:18:32.250]             }
[10:18:32.250]             base::options(...future.oldOptions)
[10:18:32.250]             if (.Platform$OS.type == "windows") {
[10:18:32.250]                 old_names <- names(...future.oldEnvVars)
[10:18:32.250]                 envs <- base::Sys.getenv()
[10:18:32.250]                 names <- names(envs)
[10:18:32.250]                 common <- intersect(names, old_names)
[10:18:32.250]                 added <- setdiff(names, old_names)
[10:18:32.250]                 removed <- setdiff(old_names, names)
[10:18:32.250]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:32.250]                   envs[common]]
[10:18:32.250]                 NAMES <- toupper(changed)
[10:18:32.250]                 args <- list()
[10:18:32.250]                 for (kk in seq_along(NAMES)) {
[10:18:32.250]                   name <- changed[[kk]]
[10:18:32.250]                   NAME <- NAMES[[kk]]
[10:18:32.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.250]                     next
[10:18:32.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.250]                 }
[10:18:32.250]                 NAMES <- toupper(added)
[10:18:32.250]                 for (kk in seq_along(NAMES)) {
[10:18:32.250]                   name <- added[[kk]]
[10:18:32.250]                   NAME <- NAMES[[kk]]
[10:18:32.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.250]                     next
[10:18:32.250]                   args[[name]] <- ""
[10:18:32.250]                 }
[10:18:32.250]                 NAMES <- toupper(removed)
[10:18:32.250]                 for (kk in seq_along(NAMES)) {
[10:18:32.250]                   name <- removed[[kk]]
[10:18:32.250]                   NAME <- NAMES[[kk]]
[10:18:32.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.250]                     next
[10:18:32.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.250]                 }
[10:18:32.250]                 if (length(args) > 0) 
[10:18:32.250]                   base::do.call(base::Sys.setenv, args = args)
[10:18:32.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:32.250]             }
[10:18:32.250]             else {
[10:18:32.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:32.250]             }
[10:18:32.250]             {
[10:18:32.250]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:32.250]                   0L) {
[10:18:32.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:32.250]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:32.250]                   base::options(opts)
[10:18:32.250]                 }
[10:18:32.250]                 {
[10:18:32.250]                   {
[10:18:32.250]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:32.250]                     NULL
[10:18:32.250]                   }
[10:18:32.250]                   options(future.plan = NULL)
[10:18:32.250]                   if (is.na(NA_character_)) 
[10:18:32.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:32.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:32.250]                     .init = FALSE)
[10:18:32.250]                 }
[10:18:32.250]             }
[10:18:32.250]         }
[10:18:32.250]     })
[10:18:32.250]     if (TRUE) {
[10:18:32.250]         base::sink(type = "output", split = FALSE)
[10:18:32.250]         if (TRUE) {
[10:18:32.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:32.250]         }
[10:18:32.250]         else {
[10:18:32.250]             ...future.result["stdout"] <- base::list(NULL)
[10:18:32.250]         }
[10:18:32.250]         base::close(...future.stdout)
[10:18:32.250]         ...future.stdout <- NULL
[10:18:32.250]     }
[10:18:32.250]     ...future.result$conditions <- ...future.conditions
[10:18:32.250]     ...future.result$finished <- base::Sys.time()
[10:18:32.250]     ...future.result
[10:18:32.250] }
[10:18:32.253] assign_globals() ...
[10:18:32.253] List of 7
[10:18:32.253]  $ ...future.FUN            :function (x)  
[10:18:32.253]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:32.253]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:32.253]  $ future.call.arguments    : list()
[10:18:32.253]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.253]  $ ...future.elements_ii    :List of 2
[10:18:32.253]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.253]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:32.253]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.253]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:32.253]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.253]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:32.253]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.253]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:32.253]  $ ...future.seeds_ii       : NULL
[10:18:32.253]  $ ...future.globals.maxSize: NULL
[10:18:32.253]  - attr(*, "where")=List of 7
[10:18:32.253]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:32.253]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:18:32.253]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:18:32.253]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:32.253]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:32.253]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:32.253]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:32.253]  - attr(*, "resolved")= logi FALSE
[10:18:32.253]  - attr(*, "total_size")= num 18867
[10:18:32.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.253]  - attr(*, "already-done")= logi TRUE
[10:18:32.268] - reassign environment for ‘...future.FUN’
[10:18:32.268] - copied ‘...future.FUN’ to environment
[10:18:32.268] - copied ‘breaks’ to environment
[10:18:32.268] - copied ‘wool’ to environment
[10:18:32.268] - copied ‘future.call.arguments’ to environment
[10:18:32.268] - copied ‘...future.elements_ii’ to environment
[10:18:32.268] - copied ‘...future.seeds_ii’ to environment
[10:18:32.268] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.269] assign_globals() ... done
[10:18:32.269] requestCore(): workers = 2
[10:18:32.271] MulticoreFuture started
[10:18:32.272] - Launch lazy future ... done
[10:18:32.272] run() for ‘MulticoreFuture’ ... done
[10:18:32.273] Created future:
[10:18:32.273] plan(): Setting new future strategy stack:
[10:18:32.273] List of future strategies:
[10:18:32.273] 1. sequential:
[10:18:32.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.273]    - tweaked: FALSE
[10:18:32.273]    - call: NULL
[10:18:32.275] plan(): nbrOfWorkers() = 1
[10:18:32.283] plan(): Setting new future strategy stack:
[10:18:32.283] List of future strategies:
[10:18:32.283] 1. multicore:
[10:18:32.283]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.283]    - tweaked: FALSE
[10:18:32.283]    - call: plan(strategy)
[10:18:32.273] MulticoreFuture:
[10:18:32.273] Label: ‘future_by-2’
[10:18:32.273] Expression:
[10:18:32.273] {
[10:18:32.273]     do.call(function(...) {
[10:18:32.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.273]             on.exit(options(oopts), add = TRUE)
[10:18:32.273]         }
[10:18:32.273]         {
[10:18:32.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.273]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.273]             })
[10:18:32.273]         }
[10:18:32.273]     }, args = future.call.arguments)
[10:18:32.273] }
[10:18:32.273] Lazy evaluation: FALSE
[10:18:32.273] Asynchronous evaluation: TRUE
[10:18:32.273] Local evaluation: TRUE
[10:18:32.273] Environment: 0x55844961dbe8
[10:18:32.273] Capture standard output: TRUE
[10:18:32.273] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.273] Globals: 7 objects totaling 3.57 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, ...)
[10:18:32.273] Packages: 1 packages (‘stats’)
[10:18:32.273] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.273] Resolved: FALSE
[10:18:32.273] Value: <not collected>
[10:18:32.273] Conditions captured: <none>
[10:18:32.273] Early signaling: FALSE
[10:18:32.273] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.273] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.286] Chunk #2 of 2 ... DONE
[10:18:32.286] Launching 2 futures (chunks) ... DONE
[10:18:32.286] Resolving 2 futures (chunks) ...
[10:18:32.287] resolve() on list ...
[10:18:32.287]  recursive: 0
[10:18:32.287]  length: 2
[10:18:32.287] 
[10:18:32.287] plan(): nbrOfWorkers() = 2
[10:18:32.287] Future #1
[10:18:32.288] result() for MulticoreFuture ...
[10:18:32.289] result() for MulticoreFuture ...
[10:18:32.289] result() for MulticoreFuture ... done
[10:18:32.290] result() for MulticoreFuture ... done
[10:18:32.290] result() for MulticoreFuture ...
[10:18:32.290] result() for MulticoreFuture ... done
[10:18:32.290] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:32.290] - nx: 2
[10:18:32.290] - relay: TRUE
[10:18:32.290] - stdout: TRUE
[10:18:32.291] - signal: TRUE
[10:18:32.291] - resignal: FALSE
[10:18:32.291] - force: TRUE
[10:18:32.291] - relayed: [n=2] FALSE, FALSE
[10:18:32.291] - queued futures: [n=2] FALSE, FALSE
[10:18:32.291]  - until=1
[10:18:32.291]  - relaying element #1
[10:18:32.291] result() for MulticoreFuture ...
[10:18:32.291] result() for MulticoreFuture ... done
[10:18:32.292] result() for MulticoreFuture ...
[10:18:32.292] result() for MulticoreFuture ... done
[10:18:32.292] result() for MulticoreFuture ...
[10:18:32.292] result() for MulticoreFuture ... done
[10:18:32.292] result() for MulticoreFuture ...
[10:18:32.292] result() for MulticoreFuture ... done
[10:18:32.293] - relayed: [n=2] TRUE, FALSE
[10:18:32.293] - queued futures: [n=2] TRUE, FALSE
[10:18:32.293] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:32.293]  length: 1 (resolved future 1)
[10:18:32.293] Future #2
[10:18:32.294] result() for MulticoreFuture ...
[10:18:32.295] result() for MulticoreFuture ...
[10:18:32.295] result() for MulticoreFuture ... done
[10:18:32.295] result() for MulticoreFuture ... done
[10:18:32.295] result() for MulticoreFuture ...
[10:18:32.296] result() for MulticoreFuture ... done
[10:18:32.296] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:32.296] - nx: 2
[10:18:32.296] - relay: TRUE
[10:18:32.296] - stdout: TRUE
[10:18:32.296] - signal: TRUE
[10:18:32.296] - resignal: FALSE
[10:18:32.297] - force: TRUE
[10:18:32.297] - relayed: [n=2] TRUE, FALSE
[10:18:32.297] - queued futures: [n=2] TRUE, FALSE
[10:18:32.297]  - until=2
[10:18:32.297]  - relaying element #2
[10:18:32.297] result() for MulticoreFuture ...
[10:18:32.297] result() for MulticoreFuture ... done
[10:18:32.297] result() for MulticoreFuture ...
[10:18:32.297] result() for MulticoreFuture ... done
[10:18:32.298] result() for MulticoreFuture ...
[10:18:32.298] result() for MulticoreFuture ... done
[10:18:32.298] result() for MulticoreFuture ...
[10:18:32.298] result() for MulticoreFuture ... done
[10:18:32.298] - relayed: [n=2] TRUE, TRUE
[10:18:32.298] - queued futures: [n=2] TRUE, TRUE
[10:18:32.298] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:32.298]  length: 0 (resolved future 2)
[10:18:32.299] Relaying remaining futures
[10:18:32.299] signalConditionsASAP(NULL, pos=0) ...
[10:18:32.299] - nx: 2
[10:18:32.299] - relay: TRUE
[10:18:32.299] - stdout: TRUE
[10:18:32.299] - signal: TRUE
[10:18:32.299] - resignal: FALSE
[10:18:32.299] - force: TRUE
[10:18:32.299] - relayed: [n=2] TRUE, TRUE
[10:18:32.299] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:32.300] - relayed: [n=2] TRUE, TRUE
[10:18:32.300] - queued futures: [n=2] TRUE, TRUE
[10:18:32.300] signalConditionsASAP(NULL, pos=0) ... done
[10:18:32.300] resolve() on list ... DONE
[10:18:32.300] result() for MulticoreFuture ...
[10:18:32.300] result() for MulticoreFuture ... done
[10:18:32.300] result() for MulticoreFuture ...
[10:18:32.300] result() for MulticoreFuture ... done
[10:18:32.301] result() for MulticoreFuture ...
[10:18:32.301] result() for MulticoreFuture ... done
[10:18:32.301] result() for MulticoreFuture ...
[10:18:32.304] result() for MulticoreFuture ... done
[10:18:32.304]  - Number of value chunks collected: 2
[10:18:32.304] Resolving 2 futures (chunks) ... DONE
[10:18:32.304] Reducing values from 2 chunks ...
[10:18:32.304]  - Number of values collected after concatenation: 3
[10:18:32.304]  - Number of values expected: 3
[10:18:32.305] Reducing values from 2 chunks ... DONE
[10:18:32.305] future_lapply() ... DONE
[10:18:32.305] future_by_internal() ... DONE
[10:18:32.306] future_by_internal() ...
[10:18:32.306] future_lapply() ...
[10:18:32.310] Number of chunks: 2
[10:18:32.310] getGlobalsAndPackagesXApply() ...
[10:18:32.310]  - future.globals: TRUE
[10:18:32.310] getGlobalsAndPackages() ...
[10:18:32.310] Searching for globals...
[10:18:32.312] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:32.312] Searching for globals ... DONE
[10:18:32.312] Resolving globals: FALSE
[10:18:32.313] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:32.313] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:32.313] - globals: [1] ‘FUN’
[10:18:32.313] 
[10:18:32.314] getGlobalsAndPackages() ... DONE
[10:18:32.314]  - globals found/used: [n=1] ‘FUN’
[10:18:32.314]  - needed namespaces: [n=0] 
[10:18:32.314] Finding globals ... DONE
[10:18:32.314]  - use_args: TRUE
[10:18:32.314]  - Getting '...' globals ...
[10:18:32.315] resolve() on list ...
[10:18:32.315]  recursive: 0
[10:18:32.315]  length: 1
[10:18:32.315]  elements: ‘...’
[10:18:32.315]  length: 0 (resolved future 1)
[10:18:32.315] resolve() on list ... DONE
[10:18:32.315]    - '...' content: [n=0] 
[10:18:32.315] List of 1
[10:18:32.315]  $ ...: list()
[10:18:32.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.315]  - attr(*, "where")=List of 1
[10:18:32.315]   ..$ ...:<environment: 0x55844a6f10e0> 
[10:18:32.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.315]  - attr(*, "resolved")= logi TRUE
[10:18:32.315]  - attr(*, "total_size")= num NA
[10:18:32.318]  - Getting '...' globals ... DONE
[10:18:32.318] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:32.318] List of 2
[10:18:32.318]  $ ...future.FUN:function (object, ...)  
[10:18:32.318]  $ ...          : list()
[10:18:32.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.318]  - attr(*, "where")=List of 2
[10:18:32.318]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:32.318]   ..$ ...          :<environment: 0x55844a6f10e0> 
[10:18:32.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.318]  - attr(*, "resolved")= logi FALSE
[10:18:32.318]  - attr(*, "total_size")= num 19278
[10:18:32.321] Packages to be attached in all futures: [n=0] 
[10:18:32.321] getGlobalsAndPackagesXApply() ... DONE
[10:18:32.321] Number of futures (= number of chunks): 2
[10:18:32.321] Launching 2 futures (chunks) ...
[10:18:32.322] Chunk #1 of 2 ...
[10:18:32.322]  - Finding globals in 'X' for chunk #1 ...
[10:18:32.322] getGlobalsAndPackages() ...
[10:18:32.322] Searching for globals...
[10:18:32.322] 
[10:18:32.322] Searching for globals ... DONE
[10:18:32.322] - globals: [0] <none>
[10:18:32.323] getGlobalsAndPackages() ... DONE
[10:18:32.323]    + additional globals found: [n=0] 
[10:18:32.323]    + additional namespaces needed: [n=0] 
[10:18:32.323]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:32.323]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:32.323]  - seeds: <none>
[10:18:32.323]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.323] getGlobalsAndPackages() ...
[10:18:32.323] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.323] Resolving globals: FALSE
[10:18:32.324] Tweak future expression to call with '...' arguments ...
[10:18:32.324] {
[10:18:32.324]     do.call(function(...) {
[10:18:32.324]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.324]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.324]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.324]             on.exit(options(oopts), add = TRUE)
[10:18:32.324]         }
[10:18:32.324]         {
[10:18:32.324]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.324]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.324]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.324]             })
[10:18:32.324]         }
[10:18:32.324]     }, args = future.call.arguments)
[10:18:32.324] }
[10:18:32.324] Tweak future expression to call with '...' arguments ... DONE
[10:18:32.324] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.324] 
[10:18:32.325] getGlobalsAndPackages() ... DONE
[10:18:32.325] run() for ‘Future’ ...
[10:18:32.325] - state: ‘created’
[10:18:32.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:32.370] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.370] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:32.370]   - Field: ‘label’
[10:18:32.370]   - Field: ‘local’
[10:18:32.371]   - Field: ‘owner’
[10:18:32.371]   - Field: ‘envir’
[10:18:32.371]   - Field: ‘workers’
[10:18:32.371]   - Field: ‘packages’
[10:18:32.371]   - Field: ‘gc’
[10:18:32.371]   - Field: ‘job’
[10:18:32.371]   - Field: ‘conditions’
[10:18:32.371]   - Field: ‘expr’
[10:18:32.371]   - Field: ‘uuid’
[10:18:32.371]   - Field: ‘seed’
[10:18:32.371]   - Field: ‘version’
[10:18:32.371]   - Field: ‘result’
[10:18:32.372]   - Field: ‘asynchronous’
[10:18:32.372]   - Field: ‘calls’
[10:18:32.372]   - Field: ‘globals’
[10:18:32.372]   - Field: ‘stdout’
[10:18:32.372]   - Field: ‘earlySignal’
[10:18:32.372]   - Field: ‘lazy’
[10:18:32.372]   - Field: ‘state’
[10:18:32.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:32.372] - Launch lazy future ...
[10:18:32.372] Packages needed by the future expression (n = 0): <none>
[10:18:32.373] Packages needed by future strategies (n = 0): <none>
[10:18:32.373] {
[10:18:32.373]     {
[10:18:32.373]         {
[10:18:32.373]             ...future.startTime <- base::Sys.time()
[10:18:32.373]             {
[10:18:32.373]                 {
[10:18:32.373]                   {
[10:18:32.373]                     {
[10:18:32.373]                       base::local({
[10:18:32.373]                         has_future <- base::requireNamespace("future", 
[10:18:32.373]                           quietly = TRUE)
[10:18:32.373]                         if (has_future) {
[10:18:32.373]                           ns <- base::getNamespace("future")
[10:18:32.373]                           version <- ns[[".package"]][["version"]]
[10:18:32.373]                           if (is.null(version)) 
[10:18:32.373]                             version <- utils::packageVersion("future")
[10:18:32.373]                         }
[10:18:32.373]                         else {
[10:18:32.373]                           version <- NULL
[10:18:32.373]                         }
[10:18:32.373]                         if (!has_future || version < "1.8.0") {
[10:18:32.373]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:32.373]                             "", base::R.version$version.string), 
[10:18:32.373]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:32.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:32.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:32.373]                               "release", "version")], collapse = " "), 
[10:18:32.373]                             hostname = base::Sys.info()[["nodename"]])
[10:18:32.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:32.373]                             info)
[10:18:32.373]                           info <- base::paste(info, collapse = "; ")
[10:18:32.373]                           if (!has_future) {
[10:18:32.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:32.373]                               info)
[10:18:32.373]                           }
[10:18:32.373]                           else {
[10:18:32.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:32.373]                               info, version)
[10:18:32.373]                           }
[10:18:32.373]                           base::stop(msg)
[10:18:32.373]                         }
[10:18:32.373]                       })
[10:18:32.373]                     }
[10:18:32.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:32.373]                     base::options(mc.cores = 1L)
[10:18:32.373]                   }
[10:18:32.373]                   ...future.strategy.old <- future::plan("list")
[10:18:32.373]                   options(future.plan = NULL)
[10:18:32.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:32.373]                 }
[10:18:32.373]                 ...future.workdir <- getwd()
[10:18:32.373]             }
[10:18:32.373]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:32.373]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:32.373]         }
[10:18:32.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:32.373]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:32.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:32.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:32.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:32.373]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:32.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:32.373]             base::names(...future.oldOptions))
[10:18:32.373]     }
[10:18:32.373]     if (FALSE) {
[10:18:32.373]     }
[10:18:32.373]     else {
[10:18:32.373]         if (TRUE) {
[10:18:32.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:32.373]                 open = "w")
[10:18:32.373]         }
[10:18:32.373]         else {
[10:18:32.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:32.373]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:32.373]         }
[10:18:32.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:32.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:32.373]             base::sink(type = "output", split = FALSE)
[10:18:32.373]             base::close(...future.stdout)
[10:18:32.373]         }, add = TRUE)
[10:18:32.373]     }
[10:18:32.373]     ...future.frame <- base::sys.nframe()
[10:18:32.373]     ...future.conditions <- base::list()
[10:18:32.373]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:32.373]     if (FALSE) {
[10:18:32.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:32.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:32.373]     }
[10:18:32.373]     ...future.result <- base::tryCatch({
[10:18:32.373]         base::withCallingHandlers({
[10:18:32.373]             ...future.value <- base::withVisible(base::local({
[10:18:32.373]                 withCallingHandlers({
[10:18:32.373]                   {
[10:18:32.373]                     do.call(function(...) {
[10:18:32.373]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.373]                       if (!identical(...future.globals.maxSize.org, 
[10:18:32.373]                         ...future.globals.maxSize)) {
[10:18:32.373]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.373]                         on.exit(options(oopts), add = TRUE)
[10:18:32.373]                       }
[10:18:32.373]                       {
[10:18:32.373]                         lapply(seq_along(...future.elements_ii), 
[10:18:32.373]                           FUN = function(jj) {
[10:18:32.373]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.373]                             ...future.FUN(...future.X_jj, ...)
[10:18:32.373]                           })
[10:18:32.373]                       }
[10:18:32.373]                     }, args = future.call.arguments)
[10:18:32.373]                   }
[10:18:32.373]                 }, immediateCondition = function(cond) {
[10:18:32.373]                   save_rds <- function (object, pathname, ...) 
[10:18:32.373]                   {
[10:18:32.373]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:32.373]                     if (file_test("-f", pathname_tmp)) {
[10:18:32.373]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.373]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:32.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.373]                         fi_tmp[["mtime"]])
[10:18:32.373]                     }
[10:18:32.373]                     tryCatch({
[10:18:32.373]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:32.373]                     }, error = function(ex) {
[10:18:32.373]                       msg <- conditionMessage(ex)
[10:18:32.373]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.373]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:32.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.373]                         fi_tmp[["mtime"]], msg)
[10:18:32.373]                       ex$message <- msg
[10:18:32.373]                       stop(ex)
[10:18:32.373]                     })
[10:18:32.373]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:32.373]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:32.373]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:32.373]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.373]                       fi <- file.info(pathname)
[10:18:32.373]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:32.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.373]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:32.373]                         fi[["size"]], fi[["mtime"]])
[10:18:32.373]                       stop(msg)
[10:18:32.373]                     }
[10:18:32.373]                     invisible(pathname)
[10:18:32.373]                   }
[10:18:32.373]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:32.373]                     rootPath = tempdir()) 
[10:18:32.373]                   {
[10:18:32.373]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:32.373]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:32.373]                       tmpdir = path, fileext = ".rds")
[10:18:32.373]                     save_rds(obj, file)
[10:18:32.373]                   }
[10:18:32.373]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:32.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.373]                   {
[10:18:32.373]                     inherits <- base::inherits
[10:18:32.373]                     invokeRestart <- base::invokeRestart
[10:18:32.373]                     is.null <- base::is.null
[10:18:32.373]                     muffled <- FALSE
[10:18:32.373]                     if (inherits(cond, "message")) {
[10:18:32.373]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:32.373]                       if (muffled) 
[10:18:32.373]                         invokeRestart("muffleMessage")
[10:18:32.373]                     }
[10:18:32.373]                     else if (inherits(cond, "warning")) {
[10:18:32.373]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:32.373]                       if (muffled) 
[10:18:32.373]                         invokeRestart("muffleWarning")
[10:18:32.373]                     }
[10:18:32.373]                     else if (inherits(cond, "condition")) {
[10:18:32.373]                       if (!is.null(pattern)) {
[10:18:32.373]                         computeRestarts <- base::computeRestarts
[10:18:32.373]                         grepl <- base::grepl
[10:18:32.373]                         restarts <- computeRestarts(cond)
[10:18:32.373]                         for (restart in restarts) {
[10:18:32.373]                           name <- restart$name
[10:18:32.373]                           if (is.null(name)) 
[10:18:32.373]                             next
[10:18:32.373]                           if (!grepl(pattern, name)) 
[10:18:32.373]                             next
[10:18:32.373]                           invokeRestart(restart)
[10:18:32.373]                           muffled <- TRUE
[10:18:32.373]                           break
[10:18:32.373]                         }
[10:18:32.373]                       }
[10:18:32.373]                     }
[10:18:32.373]                     invisible(muffled)
[10:18:32.373]                   }
[10:18:32.373]                   muffleCondition(cond)
[10:18:32.373]                 })
[10:18:32.373]             }))
[10:18:32.373]             future::FutureResult(value = ...future.value$value, 
[10:18:32.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.373]                   ...future.rng), globalenv = if (FALSE) 
[10:18:32.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:32.373]                     ...future.globalenv.names))
[10:18:32.373]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:32.373]         }, condition = base::local({
[10:18:32.373]             c <- base::c
[10:18:32.373]             inherits <- base::inherits
[10:18:32.373]             invokeRestart <- base::invokeRestart
[10:18:32.373]             length <- base::length
[10:18:32.373]             list <- base::list
[10:18:32.373]             seq.int <- base::seq.int
[10:18:32.373]             signalCondition <- base::signalCondition
[10:18:32.373]             sys.calls <- base::sys.calls
[10:18:32.373]             `[[` <- base::`[[`
[10:18:32.373]             `+` <- base::`+`
[10:18:32.373]             `<<-` <- base::`<<-`
[10:18:32.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:32.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:32.373]                   3L)]
[10:18:32.373]             }
[10:18:32.373]             function(cond) {
[10:18:32.373]                 is_error <- inherits(cond, "error")
[10:18:32.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:32.373]                   NULL)
[10:18:32.373]                 if (is_error) {
[10:18:32.373]                   sessionInformation <- function() {
[10:18:32.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:32.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:32.373]                       search = base::search(), system = base::Sys.info())
[10:18:32.373]                   }
[10:18:32.373]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:32.373]                     cond$call), session = sessionInformation(), 
[10:18:32.373]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:32.373]                   signalCondition(cond)
[10:18:32.373]                 }
[10:18:32.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:32.373]                 "immediateCondition"))) {
[10:18:32.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:32.373]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:32.373]                   if (TRUE && !signal) {
[10:18:32.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.373]                     {
[10:18:32.373]                       inherits <- base::inherits
[10:18:32.373]                       invokeRestart <- base::invokeRestart
[10:18:32.373]                       is.null <- base::is.null
[10:18:32.373]                       muffled <- FALSE
[10:18:32.373]                       if (inherits(cond, "message")) {
[10:18:32.373]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.373]                         if (muffled) 
[10:18:32.373]                           invokeRestart("muffleMessage")
[10:18:32.373]                       }
[10:18:32.373]                       else if (inherits(cond, "warning")) {
[10:18:32.373]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.373]                         if (muffled) 
[10:18:32.373]                           invokeRestart("muffleWarning")
[10:18:32.373]                       }
[10:18:32.373]                       else if (inherits(cond, "condition")) {
[10:18:32.373]                         if (!is.null(pattern)) {
[10:18:32.373]                           computeRestarts <- base::computeRestarts
[10:18:32.373]                           grepl <- base::grepl
[10:18:32.373]                           restarts <- computeRestarts(cond)
[10:18:32.373]                           for (restart in restarts) {
[10:18:32.373]                             name <- restart$name
[10:18:32.373]                             if (is.null(name)) 
[10:18:32.373]                               next
[10:18:32.373]                             if (!grepl(pattern, name)) 
[10:18:32.373]                               next
[10:18:32.373]                             invokeRestart(restart)
[10:18:32.373]                             muffled <- TRUE
[10:18:32.373]                             break
[10:18:32.373]                           }
[10:18:32.373]                         }
[10:18:32.373]                       }
[10:18:32.373]                       invisible(muffled)
[10:18:32.373]                     }
[10:18:32.373]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.373]                   }
[10:18:32.373]                 }
[10:18:32.373]                 else {
[10:18:32.373]                   if (TRUE) {
[10:18:32.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.373]                     {
[10:18:32.373]                       inherits <- base::inherits
[10:18:32.373]                       invokeRestart <- base::invokeRestart
[10:18:32.373]                       is.null <- base::is.null
[10:18:32.373]                       muffled <- FALSE
[10:18:32.373]                       if (inherits(cond, "message")) {
[10:18:32.373]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.373]                         if (muffled) 
[10:18:32.373]                           invokeRestart("muffleMessage")
[10:18:32.373]                       }
[10:18:32.373]                       else if (inherits(cond, "warning")) {
[10:18:32.373]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.373]                         if (muffled) 
[10:18:32.373]                           invokeRestart("muffleWarning")
[10:18:32.373]                       }
[10:18:32.373]                       else if (inherits(cond, "condition")) {
[10:18:32.373]                         if (!is.null(pattern)) {
[10:18:32.373]                           computeRestarts <- base::computeRestarts
[10:18:32.373]                           grepl <- base::grepl
[10:18:32.373]                           restarts <- computeRestarts(cond)
[10:18:32.373]                           for (restart in restarts) {
[10:18:32.373]                             name <- restart$name
[10:18:32.373]                             if (is.null(name)) 
[10:18:32.373]                               next
[10:18:32.373]                             if (!grepl(pattern, name)) 
[10:18:32.373]                               next
[10:18:32.373]                             invokeRestart(restart)
[10:18:32.373]                             muffled <- TRUE
[10:18:32.373]                             break
[10:18:32.373]                           }
[10:18:32.373]                         }
[10:18:32.373]                       }
[10:18:32.373]                       invisible(muffled)
[10:18:32.373]                     }
[10:18:32.373]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.373]                   }
[10:18:32.373]                 }
[10:18:32.373]             }
[10:18:32.373]         }))
[10:18:32.373]     }, error = function(ex) {
[10:18:32.373]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:32.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.373]                 ...future.rng), started = ...future.startTime, 
[10:18:32.373]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:32.373]             version = "1.8"), class = "FutureResult")
[10:18:32.373]     }, finally = {
[10:18:32.373]         if (!identical(...future.workdir, getwd())) 
[10:18:32.373]             setwd(...future.workdir)
[10:18:32.373]         {
[10:18:32.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:32.373]                 ...future.oldOptions$nwarnings <- NULL
[10:18:32.373]             }
[10:18:32.373]             base::options(...future.oldOptions)
[10:18:32.373]             if (.Platform$OS.type == "windows") {
[10:18:32.373]                 old_names <- names(...future.oldEnvVars)
[10:18:32.373]                 envs <- base::Sys.getenv()
[10:18:32.373]                 names <- names(envs)
[10:18:32.373]                 common <- intersect(names, old_names)
[10:18:32.373]                 added <- setdiff(names, old_names)
[10:18:32.373]                 removed <- setdiff(old_names, names)
[10:18:32.373]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:32.373]                   envs[common]]
[10:18:32.373]                 NAMES <- toupper(changed)
[10:18:32.373]                 args <- list()
[10:18:32.373]                 for (kk in seq_along(NAMES)) {
[10:18:32.373]                   name <- changed[[kk]]
[10:18:32.373]                   NAME <- NAMES[[kk]]
[10:18:32.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.373]                     next
[10:18:32.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.373]                 }
[10:18:32.373]                 NAMES <- toupper(added)
[10:18:32.373]                 for (kk in seq_along(NAMES)) {
[10:18:32.373]                   name <- added[[kk]]
[10:18:32.373]                   NAME <- NAMES[[kk]]
[10:18:32.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.373]                     next
[10:18:32.373]                   args[[name]] <- ""
[10:18:32.373]                 }
[10:18:32.373]                 NAMES <- toupper(removed)
[10:18:32.373]                 for (kk in seq_along(NAMES)) {
[10:18:32.373]                   name <- removed[[kk]]
[10:18:32.373]                   NAME <- NAMES[[kk]]
[10:18:32.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.373]                     next
[10:18:32.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.373]                 }
[10:18:32.373]                 if (length(args) > 0) 
[10:18:32.373]                   base::do.call(base::Sys.setenv, args = args)
[10:18:32.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:32.373]             }
[10:18:32.373]             else {
[10:18:32.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:32.373]             }
[10:18:32.373]             {
[10:18:32.373]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:32.373]                   0L) {
[10:18:32.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:32.373]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:32.373]                   base::options(opts)
[10:18:32.373]                 }
[10:18:32.373]                 {
[10:18:32.373]                   {
[10:18:32.373]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:32.373]                     NULL
[10:18:32.373]                   }
[10:18:32.373]                   options(future.plan = NULL)
[10:18:32.373]                   if (is.na(NA_character_)) 
[10:18:32.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:32.373]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:32.373]                     .init = FALSE)
[10:18:32.373]                 }
[10:18:32.373]             }
[10:18:32.373]         }
[10:18:32.373]     })
[10:18:32.373]     if (TRUE) {
[10:18:32.373]         base::sink(type = "output", split = FALSE)
[10:18:32.373]         if (TRUE) {
[10:18:32.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:32.373]         }
[10:18:32.373]         else {
[10:18:32.373]             ...future.result["stdout"] <- base::list(NULL)
[10:18:32.373]         }
[10:18:32.373]         base::close(...future.stdout)
[10:18:32.373]         ...future.stdout <- NULL
[10:18:32.373]     }
[10:18:32.373]     ...future.result$conditions <- ...future.conditions
[10:18:32.373]     ...future.result$finished <- base::Sys.time()
[10:18:32.373]     ...future.result
[10:18:32.373] }
[10:18:32.375] assign_globals() ...
[10:18:32.375] List of 5
[10:18:32.375]  $ ...future.FUN            :function (object, ...)  
[10:18:32.375]  $ future.call.arguments    : list()
[10:18:32.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.375]  $ ...future.elements_ii    :List of 1
[10:18:32.375]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.375]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:32.375]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.375]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:32.375]  $ ...future.seeds_ii       : NULL
[10:18:32.375]  $ ...future.globals.maxSize: NULL
[10:18:32.375]  - attr(*, "where")=List of 5
[10:18:32.375]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:32.375]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:32.375]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:32.375]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:32.375]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:32.375]  - attr(*, "resolved")= logi FALSE
[10:18:32.375]  - attr(*, "total_size")= num 19278
[10:18:32.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.375]  - attr(*, "already-done")= logi TRUE
[10:18:32.381] - copied ‘...future.FUN’ to environment
[10:18:32.381] - copied ‘future.call.arguments’ to environment
[10:18:32.381] - copied ‘...future.elements_ii’ to environment
[10:18:32.381] - copied ‘...future.seeds_ii’ to environment
[10:18:32.381] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.381] assign_globals() ... done
[10:18:32.381] requestCore(): workers = 2
[10:18:32.384] MulticoreFuture started
[10:18:32.384] - Launch lazy future ... done
[10:18:32.384] run() for ‘MulticoreFuture’ ... done
[10:18:32.385] Created future:
[10:18:32.385] plan(): Setting new future strategy stack:
[10:18:32.385] List of future strategies:
[10:18:32.385] 1. sequential:
[10:18:32.385]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.385]    - tweaked: FALSE
[10:18:32.385]    - call: NULL
[10:18:32.386] plan(): nbrOfWorkers() = 1
[10:18:32.389] plan(): Setting new future strategy stack:
[10:18:32.390] List of future strategies:
[10:18:32.390] 1. multicore:
[10:18:32.390]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.390]    - tweaked: FALSE
[10:18:32.390]    - call: plan(strategy)
[10:18:32.393] plan(): nbrOfWorkers() = 2
[10:18:32.385] MulticoreFuture:
[10:18:32.385] Label: ‘future_by-1’
[10:18:32.385] Expression:
[10:18:32.385] {
[10:18:32.385]     do.call(function(...) {
[10:18:32.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.385]             on.exit(options(oopts), add = TRUE)
[10:18:32.385]         }
[10:18:32.385]         {
[10:18:32.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.385]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.385]             })
[10:18:32.385]         }
[10:18:32.385]     }, args = future.call.arguments)
[10:18:32.385] }
[10:18:32.385] Lazy evaluation: FALSE
[10:18:32.385] Asynchronous evaluation: TRUE
[10:18:32.385] Local evaluation: TRUE
[10:18:32.385] Environment: 0x558449b4b850
[10:18:32.385] Capture standard output: TRUE
[10:18:32.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.385] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:32.385] Packages: <none>
[10:18:32.385] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.385] Resolved: TRUE
[10:18:32.385] Value: <not collected>
[10:18:32.385] Conditions captured: <none>
[10:18:32.385] Early signaling: FALSE
[10:18:32.385] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.385] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.394] Chunk #1 of 2 ... DONE
[10:18:32.394] Chunk #2 of 2 ...
[10:18:32.394]  - Finding globals in 'X' for chunk #2 ...
[10:18:32.394] getGlobalsAndPackages() ...
[10:18:32.394] Searching for globals...
[10:18:32.395] 
[10:18:32.395] Searching for globals ... DONE
[10:18:32.395] - globals: [0] <none>
[10:18:32.396] getGlobalsAndPackages() ... DONE
[10:18:32.396]    + additional globals found: [n=0] 
[10:18:32.396]    + additional namespaces needed: [n=0] 
[10:18:32.396]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:32.396]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:32.396]  - seeds: <none>
[10:18:32.396]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.396] getGlobalsAndPackages() ...
[10:18:32.396] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.397] Resolving globals: FALSE
[10:18:32.397] Tweak future expression to call with '...' arguments ...
[10:18:32.397] {
[10:18:32.397]     do.call(function(...) {
[10:18:32.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.397]             on.exit(options(oopts), add = TRUE)
[10:18:32.397]         }
[10:18:32.397]         {
[10:18:32.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.397]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.397]             })
[10:18:32.397]         }
[10:18:32.397]     }, args = future.call.arguments)
[10:18:32.397] }
[10:18:32.397] Tweak future expression to call with '...' arguments ... DONE
[10:18:32.398] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.398] 
[10:18:32.398] getGlobalsAndPackages() ... DONE
[10:18:32.399] run() for ‘Future’ ...
[10:18:32.399] - state: ‘created’
[10:18:32.399] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:32.402] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.402] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:32.402]   - Field: ‘label’
[10:18:32.403]   - Field: ‘local’
[10:18:32.403]   - Field: ‘owner’
[10:18:32.403]   - Field: ‘envir’
[10:18:32.403]   - Field: ‘workers’
[10:18:32.403]   - Field: ‘packages’
[10:18:32.403]   - Field: ‘gc’
[10:18:32.404]   - Field: ‘job’
[10:18:32.404]   - Field: ‘conditions’
[10:18:32.404]   - Field: ‘expr’
[10:18:32.404]   - Field: ‘uuid’
[10:18:32.404]   - Field: ‘seed’
[10:18:32.404]   - Field: ‘version’
[10:18:32.404]   - Field: ‘result’
[10:18:32.404]   - Field: ‘asynchronous’
[10:18:32.405]   - Field: ‘calls’
[10:18:32.405]   - Field: ‘globals’
[10:18:32.405]   - Field: ‘stdout’
[10:18:32.405]   - Field: ‘earlySignal’
[10:18:32.405]   - Field: ‘lazy’
[10:18:32.405]   - Field: ‘state’
[10:18:32.405] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:32.406] - Launch lazy future ...
[10:18:32.406] Packages needed by the future expression (n = 0): <none>
[10:18:32.406] Packages needed by future strategies (n = 0): <none>
[10:18:32.407] {
[10:18:32.407]     {
[10:18:32.407]         {
[10:18:32.407]             ...future.startTime <- base::Sys.time()
[10:18:32.407]             {
[10:18:32.407]                 {
[10:18:32.407]                   {
[10:18:32.407]                     {
[10:18:32.407]                       base::local({
[10:18:32.407]                         has_future <- base::requireNamespace("future", 
[10:18:32.407]                           quietly = TRUE)
[10:18:32.407]                         if (has_future) {
[10:18:32.407]                           ns <- base::getNamespace("future")
[10:18:32.407]                           version <- ns[[".package"]][["version"]]
[10:18:32.407]                           if (is.null(version)) 
[10:18:32.407]                             version <- utils::packageVersion("future")
[10:18:32.407]                         }
[10:18:32.407]                         else {
[10:18:32.407]                           version <- NULL
[10:18:32.407]                         }
[10:18:32.407]                         if (!has_future || version < "1.8.0") {
[10:18:32.407]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:32.407]                             "", base::R.version$version.string), 
[10:18:32.407]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:32.407]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:32.407]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:32.407]                               "release", "version")], collapse = " "), 
[10:18:32.407]                             hostname = base::Sys.info()[["nodename"]])
[10:18:32.407]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:32.407]                             info)
[10:18:32.407]                           info <- base::paste(info, collapse = "; ")
[10:18:32.407]                           if (!has_future) {
[10:18:32.407]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:32.407]                               info)
[10:18:32.407]                           }
[10:18:32.407]                           else {
[10:18:32.407]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:32.407]                               info, version)
[10:18:32.407]                           }
[10:18:32.407]                           base::stop(msg)
[10:18:32.407]                         }
[10:18:32.407]                       })
[10:18:32.407]                     }
[10:18:32.407]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:32.407]                     base::options(mc.cores = 1L)
[10:18:32.407]                   }
[10:18:32.407]                   ...future.strategy.old <- future::plan("list")
[10:18:32.407]                   options(future.plan = NULL)
[10:18:32.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:32.407]                 }
[10:18:32.407]                 ...future.workdir <- getwd()
[10:18:32.407]             }
[10:18:32.407]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:32.407]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:32.407]         }
[10:18:32.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:32.407]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:32.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:32.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:32.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:32.407]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:32.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:32.407]             base::names(...future.oldOptions))
[10:18:32.407]     }
[10:18:32.407]     if (FALSE) {
[10:18:32.407]     }
[10:18:32.407]     else {
[10:18:32.407]         if (TRUE) {
[10:18:32.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:32.407]                 open = "w")
[10:18:32.407]         }
[10:18:32.407]         else {
[10:18:32.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:32.407]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:32.407]         }
[10:18:32.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:32.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:32.407]             base::sink(type = "output", split = FALSE)
[10:18:32.407]             base::close(...future.stdout)
[10:18:32.407]         }, add = TRUE)
[10:18:32.407]     }
[10:18:32.407]     ...future.frame <- base::sys.nframe()
[10:18:32.407]     ...future.conditions <- base::list()
[10:18:32.407]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:32.407]     if (FALSE) {
[10:18:32.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:32.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:32.407]     }
[10:18:32.407]     ...future.result <- base::tryCatch({
[10:18:32.407]         base::withCallingHandlers({
[10:18:32.407]             ...future.value <- base::withVisible(base::local({
[10:18:32.407]                 withCallingHandlers({
[10:18:32.407]                   {
[10:18:32.407]                     do.call(function(...) {
[10:18:32.407]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.407]                       if (!identical(...future.globals.maxSize.org, 
[10:18:32.407]                         ...future.globals.maxSize)) {
[10:18:32.407]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.407]                         on.exit(options(oopts), add = TRUE)
[10:18:32.407]                       }
[10:18:32.407]                       {
[10:18:32.407]                         lapply(seq_along(...future.elements_ii), 
[10:18:32.407]                           FUN = function(jj) {
[10:18:32.407]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.407]                             ...future.FUN(...future.X_jj, ...)
[10:18:32.407]                           })
[10:18:32.407]                       }
[10:18:32.407]                     }, args = future.call.arguments)
[10:18:32.407]                   }
[10:18:32.407]                 }, immediateCondition = function(cond) {
[10:18:32.407]                   save_rds <- function (object, pathname, ...) 
[10:18:32.407]                   {
[10:18:32.407]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:32.407]                     if (file_test("-f", pathname_tmp)) {
[10:18:32.407]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.407]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:32.407]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.407]                         fi_tmp[["mtime"]])
[10:18:32.407]                     }
[10:18:32.407]                     tryCatch({
[10:18:32.407]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:32.407]                     }, error = function(ex) {
[10:18:32.407]                       msg <- conditionMessage(ex)
[10:18:32.407]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.407]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:32.407]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.407]                         fi_tmp[["mtime"]], msg)
[10:18:32.407]                       ex$message <- msg
[10:18:32.407]                       stop(ex)
[10:18:32.407]                     })
[10:18:32.407]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:32.407]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:32.407]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:32.407]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.407]                       fi <- file.info(pathname)
[10:18:32.407]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:32.407]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.407]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:32.407]                         fi[["size"]], fi[["mtime"]])
[10:18:32.407]                       stop(msg)
[10:18:32.407]                     }
[10:18:32.407]                     invisible(pathname)
[10:18:32.407]                   }
[10:18:32.407]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:32.407]                     rootPath = tempdir()) 
[10:18:32.407]                   {
[10:18:32.407]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:32.407]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:32.407]                       tmpdir = path, fileext = ".rds")
[10:18:32.407]                     save_rds(obj, file)
[10:18:32.407]                   }
[10:18:32.407]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:32.407]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.407]                   {
[10:18:32.407]                     inherits <- base::inherits
[10:18:32.407]                     invokeRestart <- base::invokeRestart
[10:18:32.407]                     is.null <- base::is.null
[10:18:32.407]                     muffled <- FALSE
[10:18:32.407]                     if (inherits(cond, "message")) {
[10:18:32.407]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:32.407]                       if (muffled) 
[10:18:32.407]                         invokeRestart("muffleMessage")
[10:18:32.407]                     }
[10:18:32.407]                     else if (inherits(cond, "warning")) {
[10:18:32.407]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:32.407]                       if (muffled) 
[10:18:32.407]                         invokeRestart("muffleWarning")
[10:18:32.407]                     }
[10:18:32.407]                     else if (inherits(cond, "condition")) {
[10:18:32.407]                       if (!is.null(pattern)) {
[10:18:32.407]                         computeRestarts <- base::computeRestarts
[10:18:32.407]                         grepl <- base::grepl
[10:18:32.407]                         restarts <- computeRestarts(cond)
[10:18:32.407]                         for (restart in restarts) {
[10:18:32.407]                           name <- restart$name
[10:18:32.407]                           if (is.null(name)) 
[10:18:32.407]                             next
[10:18:32.407]                           if (!grepl(pattern, name)) 
[10:18:32.407]                             next
[10:18:32.407]                           invokeRestart(restart)
[10:18:32.407]                           muffled <- TRUE
[10:18:32.407]                           break
[10:18:32.407]                         }
[10:18:32.407]                       }
[10:18:32.407]                     }
[10:18:32.407]                     invisible(muffled)
[10:18:32.407]                   }
[10:18:32.407]                   muffleCondition(cond)
[10:18:32.407]                 })
[10:18:32.407]             }))
[10:18:32.407]             future::FutureResult(value = ...future.value$value, 
[10:18:32.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.407]                   ...future.rng), globalenv = if (FALSE) 
[10:18:32.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:32.407]                     ...future.globalenv.names))
[10:18:32.407]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:32.407]         }, condition = base::local({
[10:18:32.407]             c <- base::c
[10:18:32.407]             inherits <- base::inherits
[10:18:32.407]             invokeRestart <- base::invokeRestart
[10:18:32.407]             length <- base::length
[10:18:32.407]             list <- base::list
[10:18:32.407]             seq.int <- base::seq.int
[10:18:32.407]             signalCondition <- base::signalCondition
[10:18:32.407]             sys.calls <- base::sys.calls
[10:18:32.407]             `[[` <- base::`[[`
[10:18:32.407]             `+` <- base::`+`
[10:18:32.407]             `<<-` <- base::`<<-`
[10:18:32.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:32.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:32.407]                   3L)]
[10:18:32.407]             }
[10:18:32.407]             function(cond) {
[10:18:32.407]                 is_error <- inherits(cond, "error")
[10:18:32.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:32.407]                   NULL)
[10:18:32.407]                 if (is_error) {
[10:18:32.407]                   sessionInformation <- function() {
[10:18:32.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:32.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:32.407]                       search = base::search(), system = base::Sys.info())
[10:18:32.407]                   }
[10:18:32.407]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:32.407]                     cond$call), session = sessionInformation(), 
[10:18:32.407]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:32.407]                   signalCondition(cond)
[10:18:32.407]                 }
[10:18:32.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:32.407]                 "immediateCondition"))) {
[10:18:32.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:32.407]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:32.407]                   if (TRUE && !signal) {
[10:18:32.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.407]                     {
[10:18:32.407]                       inherits <- base::inherits
[10:18:32.407]                       invokeRestart <- base::invokeRestart
[10:18:32.407]                       is.null <- base::is.null
[10:18:32.407]                       muffled <- FALSE
[10:18:32.407]                       if (inherits(cond, "message")) {
[10:18:32.407]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.407]                         if (muffled) 
[10:18:32.407]                           invokeRestart("muffleMessage")
[10:18:32.407]                       }
[10:18:32.407]                       else if (inherits(cond, "warning")) {
[10:18:32.407]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.407]                         if (muffled) 
[10:18:32.407]                           invokeRestart("muffleWarning")
[10:18:32.407]                       }
[10:18:32.407]                       else if (inherits(cond, "condition")) {
[10:18:32.407]                         if (!is.null(pattern)) {
[10:18:32.407]                           computeRestarts <- base::computeRestarts
[10:18:32.407]                           grepl <- base::grepl
[10:18:32.407]                           restarts <- computeRestarts(cond)
[10:18:32.407]                           for (restart in restarts) {
[10:18:32.407]                             name <- restart$name
[10:18:32.407]                             if (is.null(name)) 
[10:18:32.407]                               next
[10:18:32.407]                             if (!grepl(pattern, name)) 
[10:18:32.407]                               next
[10:18:32.407]                             invokeRestart(restart)
[10:18:32.407]                             muffled <- TRUE
[10:18:32.407]                             break
[10:18:32.407]                           }
[10:18:32.407]                         }
[10:18:32.407]                       }
[10:18:32.407]                       invisible(muffled)
[10:18:32.407]                     }
[10:18:32.407]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.407]                   }
[10:18:32.407]                 }
[10:18:32.407]                 else {
[10:18:32.407]                   if (TRUE) {
[10:18:32.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.407]                     {
[10:18:32.407]                       inherits <- base::inherits
[10:18:32.407]                       invokeRestart <- base::invokeRestart
[10:18:32.407]                       is.null <- base::is.null
[10:18:32.407]                       muffled <- FALSE
[10:18:32.407]                       if (inherits(cond, "message")) {
[10:18:32.407]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.407]                         if (muffled) 
[10:18:32.407]                           invokeRestart("muffleMessage")
[10:18:32.407]                       }
[10:18:32.407]                       else if (inherits(cond, "warning")) {
[10:18:32.407]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.407]                         if (muffled) 
[10:18:32.407]                           invokeRestart("muffleWarning")
[10:18:32.407]                       }
[10:18:32.407]                       else if (inherits(cond, "condition")) {
[10:18:32.407]                         if (!is.null(pattern)) {
[10:18:32.407]                           computeRestarts <- base::computeRestarts
[10:18:32.407]                           grepl <- base::grepl
[10:18:32.407]                           restarts <- computeRestarts(cond)
[10:18:32.407]                           for (restart in restarts) {
[10:18:32.407]                             name <- restart$name
[10:18:32.407]                             if (is.null(name)) 
[10:18:32.407]                               next
[10:18:32.407]                             if (!grepl(pattern, name)) 
[10:18:32.407]                               next
[10:18:32.407]                             invokeRestart(restart)
[10:18:32.407]                             muffled <- TRUE
[10:18:32.407]                             break
[10:18:32.407]                           }
[10:18:32.407]                         }
[10:18:32.407]                       }
[10:18:32.407]                       invisible(muffled)
[10:18:32.407]                     }
[10:18:32.407]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.407]                   }
[10:18:32.407]                 }
[10:18:32.407]             }
[10:18:32.407]         }))
[10:18:32.407]     }, error = function(ex) {
[10:18:32.407]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:32.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.407]                 ...future.rng), started = ...future.startTime, 
[10:18:32.407]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:32.407]             version = "1.8"), class = "FutureResult")
[10:18:32.407]     }, finally = {
[10:18:32.407]         if (!identical(...future.workdir, getwd())) 
[10:18:32.407]             setwd(...future.workdir)
[10:18:32.407]         {
[10:18:32.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:32.407]                 ...future.oldOptions$nwarnings <- NULL
[10:18:32.407]             }
[10:18:32.407]             base::options(...future.oldOptions)
[10:18:32.407]             if (.Platform$OS.type == "windows") {
[10:18:32.407]                 old_names <- names(...future.oldEnvVars)
[10:18:32.407]                 envs <- base::Sys.getenv()
[10:18:32.407]                 names <- names(envs)
[10:18:32.407]                 common <- intersect(names, old_names)
[10:18:32.407]                 added <- setdiff(names, old_names)
[10:18:32.407]                 removed <- setdiff(old_names, names)
[10:18:32.407]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:32.407]                   envs[common]]
[10:18:32.407]                 NAMES <- toupper(changed)
[10:18:32.407]                 args <- list()
[10:18:32.407]                 for (kk in seq_along(NAMES)) {
[10:18:32.407]                   name <- changed[[kk]]
[10:18:32.407]                   NAME <- NAMES[[kk]]
[10:18:32.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.407]                     next
[10:18:32.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.407]                 }
[10:18:32.407]                 NAMES <- toupper(added)
[10:18:32.407]                 for (kk in seq_along(NAMES)) {
[10:18:32.407]                   name <- added[[kk]]
[10:18:32.407]                   NAME <- NAMES[[kk]]
[10:18:32.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.407]                     next
[10:18:32.407]                   args[[name]] <- ""
[10:18:32.407]                 }
[10:18:32.407]                 NAMES <- toupper(removed)
[10:18:32.407]                 for (kk in seq_along(NAMES)) {
[10:18:32.407]                   name <- removed[[kk]]
[10:18:32.407]                   NAME <- NAMES[[kk]]
[10:18:32.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.407]                     next
[10:18:32.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.407]                 }
[10:18:32.407]                 if (length(args) > 0) 
[10:18:32.407]                   base::do.call(base::Sys.setenv, args = args)
[10:18:32.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:32.407]             }
[10:18:32.407]             else {
[10:18:32.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:32.407]             }
[10:18:32.407]             {
[10:18:32.407]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:32.407]                   0L) {
[10:18:32.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:32.407]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:32.407]                   base::options(opts)
[10:18:32.407]                 }
[10:18:32.407]                 {
[10:18:32.407]                   {
[10:18:32.407]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:32.407]                     NULL
[10:18:32.407]                   }
[10:18:32.407]                   options(future.plan = NULL)
[10:18:32.407]                   if (is.na(NA_character_)) 
[10:18:32.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:32.407]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:32.407]                     .init = FALSE)
[10:18:32.407]                 }
[10:18:32.407]             }
[10:18:32.407]         }
[10:18:32.407]     })
[10:18:32.407]     if (TRUE) {
[10:18:32.407]         base::sink(type = "output", split = FALSE)
[10:18:32.407]         if (TRUE) {
[10:18:32.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:32.407]         }
[10:18:32.407]         else {
[10:18:32.407]             ...future.result["stdout"] <- base::list(NULL)
[10:18:32.407]         }
[10:18:32.407]         base::close(...future.stdout)
[10:18:32.407]         ...future.stdout <- NULL
[10:18:32.407]     }
[10:18:32.407]     ...future.result$conditions <- ...future.conditions
[10:18:32.407]     ...future.result$finished <- base::Sys.time()
[10:18:32.407]     ...future.result
[10:18:32.407] }
[10:18:32.410] assign_globals() ...
[10:18:32.411] List of 5
[10:18:32.411]  $ ...future.FUN            :function (object, ...)  
[10:18:32.411]  $ future.call.arguments    : list()
[10:18:32.411]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.411]  $ ...future.elements_ii    :List of 2
[10:18:32.411]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.411]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:32.411]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.411]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:32.411]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.411]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:32.411]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.411]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:32.411]  $ ...future.seeds_ii       : NULL
[10:18:32.411]  $ ...future.globals.maxSize: NULL
[10:18:32.411]  - attr(*, "where")=List of 5
[10:18:32.411]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:32.411]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:32.411]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:32.411]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:32.411]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:32.411]  - attr(*, "resolved")= logi FALSE
[10:18:32.411]  - attr(*, "total_size")= num 19278
[10:18:32.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.411]  - attr(*, "already-done")= logi TRUE
[10:18:32.422] - copied ‘...future.FUN’ to environment
[10:18:32.423] - copied ‘future.call.arguments’ to environment
[10:18:32.423] - copied ‘...future.elements_ii’ to environment
[10:18:32.423] - copied ‘...future.seeds_ii’ to environment
[10:18:32.423] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.423] assign_globals() ... done
[10:18:32.423] requestCore(): workers = 2
[10:18:32.425] MulticoreFuture started
[10:18:32.426] - Launch lazy future ... done
[10:18:32.426] run() for ‘MulticoreFuture’ ... done
[10:18:32.426] Created future:
[10:18:32.427] plan(): Setting new future strategy stack:
[10:18:32.427] List of future strategies:
[10:18:32.427] 1. sequential:
[10:18:32.427]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.427]    - tweaked: FALSE
[10:18:32.427]    - call: NULL
[10:18:32.428] plan(): nbrOfWorkers() = 1
[10:18:32.432] plan(): Setting new future strategy stack:
[10:18:32.432] List of future strategies:
[10:18:32.432] 1. multicore:
[10:18:32.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.432]    - tweaked: FALSE
[10:18:32.432]    - call: plan(strategy)
[10:18:32.435] plan(): nbrOfWorkers() = 2
[10:18:32.426] MulticoreFuture:
[10:18:32.426] Label: ‘future_by-2’
[10:18:32.426] Expression:
[10:18:32.426] {
[10:18:32.426]     do.call(function(...) {
[10:18:32.426]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.426]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.426]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.426]             on.exit(options(oopts), add = TRUE)
[10:18:32.426]         }
[10:18:32.426]         {
[10:18:32.426]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.426]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.426]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.426]             })
[10:18:32.426]         }
[10:18:32.426]     }, args = future.call.arguments)
[10:18:32.426] }
[10:18:32.426] Lazy evaluation: FALSE
[10:18:32.426] Asynchronous evaluation: TRUE
[10:18:32.426] Local evaluation: TRUE
[10:18:32.426] Environment: 0x558449b4b850
[10:18:32.426] Capture standard output: TRUE
[10:18:32.426] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.426] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:32.426] Packages: <none>
[10:18:32.426] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.426] Resolved: TRUE
[10:18:32.426] Value: <not collected>
[10:18:32.426] Conditions captured: <none>
[10:18:32.426] Early signaling: FALSE
[10:18:32.426] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.426] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.436] Chunk #2 of 2 ... DONE
[10:18:32.436] Launching 2 futures (chunks) ... DONE
[10:18:32.436] Resolving 2 futures (chunks) ...
[10:18:32.437] resolve() on list ...
[10:18:32.437]  recursive: 0
[10:18:32.437]  length: 2
[10:18:32.437] 
[10:18:32.437] Future #1
[10:18:32.437] result() for MulticoreFuture ...
[10:18:32.438] result() for MulticoreFuture ...
[10:18:32.438] result() for MulticoreFuture ... done
[10:18:32.439] result() for MulticoreFuture ... done
[10:18:32.439] result() for MulticoreFuture ...
[10:18:32.439] result() for MulticoreFuture ... done
[10:18:32.439] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:32.439] - nx: 2
[10:18:32.439] - relay: TRUE
[10:18:32.439] - stdout: TRUE
[10:18:32.439] - signal: TRUE
[10:18:32.440] - resignal: FALSE
[10:18:32.440] - force: TRUE
[10:18:32.440] - relayed: [n=2] FALSE, FALSE
[10:18:32.440] - queued futures: [n=2] FALSE, FALSE
[10:18:32.440]  - until=1
[10:18:32.440]  - relaying element #1
[10:18:32.440] result() for MulticoreFuture ...
[10:18:32.440] result() for MulticoreFuture ... done
[10:18:32.440] result() for MulticoreFuture ...
[10:18:32.441] result() for MulticoreFuture ... done
[10:18:32.441] result() for MulticoreFuture ...
[10:18:32.441] result() for MulticoreFuture ... done
[10:18:32.441] result() for MulticoreFuture ...
[10:18:32.441] result() for MulticoreFuture ... done
[10:18:32.441] - relayed: [n=2] TRUE, FALSE
[10:18:32.441] - queued futures: [n=2] TRUE, FALSE
[10:18:32.441] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:32.442]  length: 1 (resolved future 1)
[10:18:32.442] Future #2
[10:18:32.442] result() for MulticoreFuture ...
[10:18:32.443] result() for MulticoreFuture ...
[10:18:32.443] result() for MulticoreFuture ... done
[10:18:32.443] result() for MulticoreFuture ... done
[10:18:32.443] result() for MulticoreFuture ...
[10:18:32.443] result() for MulticoreFuture ... done
[10:18:32.443] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:32.443] - nx: 2
[10:18:32.443] - relay: TRUE
[10:18:32.444] - stdout: TRUE
[10:18:32.444] - signal: TRUE
[10:18:32.444] - resignal: FALSE
[10:18:32.444] - force: TRUE
[10:18:32.444] - relayed: [n=2] TRUE, FALSE
[10:18:32.444] - queued futures: [n=2] TRUE, FALSE
[10:18:32.444]  - until=2
[10:18:32.444]  - relaying element #2
[10:18:32.444] result() for MulticoreFuture ...
[10:18:32.444] result() for MulticoreFuture ... done
[10:18:32.445] result() for MulticoreFuture ...
[10:18:32.445] result() for MulticoreFuture ... done
[10:18:32.445] result() for MulticoreFuture ...
[10:18:32.445] result() for MulticoreFuture ... done
[10:18:32.445] result() for MulticoreFuture ...
[10:18:32.445] result() for MulticoreFuture ... done
[10:18:32.445] - relayed: [n=2] TRUE, TRUE
[10:18:32.445] - queued futures: [n=2] TRUE, TRUE
[10:18:32.446] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:32.446]  length: 0 (resolved future 2)
[10:18:32.446] Relaying remaining futures
[10:18:32.446] signalConditionsASAP(NULL, pos=0) ...
[10:18:32.446] - nx: 2
[10:18:32.446] - relay: TRUE
[10:18:32.446] - stdout: TRUE
[10:18:32.446] - signal: TRUE
[10:18:32.446] - resignal: FALSE
[10:18:32.446] - force: TRUE
[10:18:32.447] - relayed: [n=2] TRUE, TRUE
[10:18:32.447] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:32.447] - relayed: [n=2] TRUE, TRUE
[10:18:32.447] - queued futures: [n=2] TRUE, TRUE
[10:18:32.447] signalConditionsASAP(NULL, pos=0) ... done
[10:18:32.447] resolve() on list ... DONE
[10:18:32.447] result() for MulticoreFuture ...
[10:18:32.447] result() for MulticoreFuture ... done
[10:18:32.448] result() for MulticoreFuture ...
[10:18:32.448] result() for MulticoreFuture ... done
[10:18:32.448] result() for MulticoreFuture ...
[10:18:32.448] result() for MulticoreFuture ... done
[10:18:32.448] result() for MulticoreFuture ...
[10:18:32.448] result() for MulticoreFuture ... done
[10:18:32.448]  - Number of value chunks collected: 2
[10:18:32.448] Resolving 2 futures (chunks) ... DONE
[10:18:32.448] Reducing values from 2 chunks ...
[10:18:32.449]  - Number of values collected after concatenation: 3
[10:18:32.449]  - Number of values expected: 3
[10:18:32.449] Reducing values from 2 chunks ... DONE
[10:18:32.449] future_lapply() ... DONE
[10:18:32.449] future_by_internal() ... DONE
[10:18:32.450] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:18:32.451] future_lapply() ...
[10:18:32.454] Number of chunks: 2
[10:18:32.454] getGlobalsAndPackagesXApply() ...
[10:18:32.454]  - future.globals: TRUE
[10:18:32.454] getGlobalsAndPackages() ...
[10:18:32.454] Searching for globals...
[10:18:32.456] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:32.456] Searching for globals ... DONE
[10:18:32.456] Resolving globals: FALSE
[10:18:32.457] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:32.457] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:32.457] - globals: [1] ‘FUN’
[10:18:32.457] 
[10:18:32.457] getGlobalsAndPackages() ... DONE
[10:18:32.457]  - globals found/used: [n=1] ‘FUN’
[10:18:32.458]  - needed namespaces: [n=0] 
[10:18:32.458] Finding globals ... DONE
[10:18:32.458]  - use_args: TRUE
[10:18:32.458]  - Getting '...' globals ...
[10:18:32.458] resolve() on list ...
[10:18:32.458]  recursive: 0
[10:18:32.459]  length: 1
[10:18:32.459]  elements: ‘...’
[10:18:32.459]  length: 0 (resolved future 1)
[10:18:32.459] resolve() on list ... DONE
[10:18:32.459]    - '...' content: [n=0] 
[10:18:32.459] List of 1
[10:18:32.459]  $ ...: list()
[10:18:32.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.459]  - attr(*, "where")=List of 1
[10:18:32.459]   ..$ ...:<environment: 0x55844baa7e20> 
[10:18:32.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.459]  - attr(*, "resolved")= logi TRUE
[10:18:32.459]  - attr(*, "total_size")= num NA
[10:18:32.462]  - Getting '...' globals ... DONE
[10:18:32.463] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:32.463] List of 2
[10:18:32.463]  $ ...future.FUN:function (object, ...)  
[10:18:32.463]  $ ...          : list()
[10:18:32.463]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.463]  - attr(*, "where")=List of 2
[10:18:32.463]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:32.463]   ..$ ...          :<environment: 0x55844baa7e20> 
[10:18:32.463]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.463]  - attr(*, "resolved")= logi FALSE
[10:18:32.463]  - attr(*, "total_size")= num 18647
[10:18:32.466] Packages to be attached in all futures: [n=0] 
[10:18:32.466] getGlobalsAndPackagesXApply() ... DONE
[10:18:32.467] Number of futures (= number of chunks): 2
[10:18:32.467] Launching 2 futures (chunks) ...
[10:18:32.467] Chunk #1 of 2 ...
[10:18:32.467]  - Finding globals in 'X' for chunk #1 ...
[10:18:32.467] getGlobalsAndPackages() ...
[10:18:32.467] Searching for globals...
[10:18:32.468] 
[10:18:32.468] Searching for globals ... DONE
[10:18:32.468] - globals: [0] <none>
[10:18:32.468] getGlobalsAndPackages() ... DONE
[10:18:32.468]    + additional globals found: [n=0] 
[10:18:32.468]    + additional namespaces needed: [n=0] 
[10:18:32.468]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:32.468]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:32.469]  - seeds: <none>
[10:18:32.469]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.469] getGlobalsAndPackages() ...
[10:18:32.469] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.469] Resolving globals: FALSE
[10:18:32.469] Tweak future expression to call with '...' arguments ...
[10:18:32.469] {
[10:18:32.469]     do.call(function(...) {
[10:18:32.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.469]             on.exit(options(oopts), add = TRUE)
[10:18:32.469]         }
[10:18:32.469]         {
[10:18:32.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.469]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.469]             })
[10:18:32.469]         }
[10:18:32.469]     }, args = future.call.arguments)
[10:18:32.469] }
[10:18:32.470] Tweak future expression to call with '...' arguments ... DONE
[10:18:32.470] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.470] 
[10:18:32.470] getGlobalsAndPackages() ... DONE
[10:18:32.471] run() for ‘Future’ ...
[10:18:32.471] - state: ‘created’
[10:18:32.471] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:32.473] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:32.473]   - Field: ‘label’
[10:18:32.473]   - Field: ‘local’
[10:18:32.474]   - Field: ‘owner’
[10:18:32.474]   - Field: ‘envir’
[10:18:32.474]   - Field: ‘workers’
[10:18:32.474]   - Field: ‘packages’
[10:18:32.474]   - Field: ‘gc’
[10:18:32.474]   - Field: ‘job’
[10:18:32.474]   - Field: ‘conditions’
[10:18:32.474]   - Field: ‘expr’
[10:18:32.474]   - Field: ‘uuid’
[10:18:32.475]   - Field: ‘seed’
[10:18:32.475]   - Field: ‘version’
[10:18:32.475]   - Field: ‘result’
[10:18:32.475]   - Field: ‘asynchronous’
[10:18:32.475]   - Field: ‘calls’
[10:18:32.475]   - Field: ‘globals’
[10:18:32.475]   - Field: ‘stdout’
[10:18:32.475]   - Field: ‘earlySignal’
[10:18:32.475]   - Field: ‘lazy’
[10:18:32.476]   - Field: ‘state’
[10:18:32.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:32.476] - Launch lazy future ...
[10:18:32.476] Packages needed by the future expression (n = 0): <none>
[10:18:32.476] Packages needed by future strategies (n = 0): <none>
[10:18:32.477] {
[10:18:32.477]     {
[10:18:32.477]         {
[10:18:32.477]             ...future.startTime <- base::Sys.time()
[10:18:32.477]             {
[10:18:32.477]                 {
[10:18:32.477]                   {
[10:18:32.477]                     {
[10:18:32.477]                       base::local({
[10:18:32.477]                         has_future <- base::requireNamespace("future", 
[10:18:32.477]                           quietly = TRUE)
[10:18:32.477]                         if (has_future) {
[10:18:32.477]                           ns <- base::getNamespace("future")
[10:18:32.477]                           version <- ns[[".package"]][["version"]]
[10:18:32.477]                           if (is.null(version)) 
[10:18:32.477]                             version <- utils::packageVersion("future")
[10:18:32.477]                         }
[10:18:32.477]                         else {
[10:18:32.477]                           version <- NULL
[10:18:32.477]                         }
[10:18:32.477]                         if (!has_future || version < "1.8.0") {
[10:18:32.477]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:32.477]                             "", base::R.version$version.string), 
[10:18:32.477]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:32.477]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:32.477]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:32.477]                               "release", "version")], collapse = " "), 
[10:18:32.477]                             hostname = base::Sys.info()[["nodename"]])
[10:18:32.477]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:32.477]                             info)
[10:18:32.477]                           info <- base::paste(info, collapse = "; ")
[10:18:32.477]                           if (!has_future) {
[10:18:32.477]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:32.477]                               info)
[10:18:32.477]                           }
[10:18:32.477]                           else {
[10:18:32.477]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:32.477]                               info, version)
[10:18:32.477]                           }
[10:18:32.477]                           base::stop(msg)
[10:18:32.477]                         }
[10:18:32.477]                       })
[10:18:32.477]                     }
[10:18:32.477]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:32.477]                     base::options(mc.cores = 1L)
[10:18:32.477]                   }
[10:18:32.477]                   ...future.strategy.old <- future::plan("list")
[10:18:32.477]                   options(future.plan = NULL)
[10:18:32.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:32.477]                 }
[10:18:32.477]                 ...future.workdir <- getwd()
[10:18:32.477]             }
[10:18:32.477]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:32.477]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:32.477]         }
[10:18:32.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:32.477]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:32.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:32.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:32.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:32.477]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:32.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:32.477]             base::names(...future.oldOptions))
[10:18:32.477]     }
[10:18:32.477]     if (FALSE) {
[10:18:32.477]     }
[10:18:32.477]     else {
[10:18:32.477]         if (TRUE) {
[10:18:32.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:32.477]                 open = "w")
[10:18:32.477]         }
[10:18:32.477]         else {
[10:18:32.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:32.477]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:32.477]         }
[10:18:32.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:32.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:32.477]             base::sink(type = "output", split = FALSE)
[10:18:32.477]             base::close(...future.stdout)
[10:18:32.477]         }, add = TRUE)
[10:18:32.477]     }
[10:18:32.477]     ...future.frame <- base::sys.nframe()
[10:18:32.477]     ...future.conditions <- base::list()
[10:18:32.477]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:32.477]     if (FALSE) {
[10:18:32.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:32.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:32.477]     }
[10:18:32.477]     ...future.result <- base::tryCatch({
[10:18:32.477]         base::withCallingHandlers({
[10:18:32.477]             ...future.value <- base::withVisible(base::local({
[10:18:32.477]                 withCallingHandlers({
[10:18:32.477]                   {
[10:18:32.477]                     do.call(function(...) {
[10:18:32.477]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.477]                       if (!identical(...future.globals.maxSize.org, 
[10:18:32.477]                         ...future.globals.maxSize)) {
[10:18:32.477]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.477]                         on.exit(options(oopts), add = TRUE)
[10:18:32.477]                       }
[10:18:32.477]                       {
[10:18:32.477]                         lapply(seq_along(...future.elements_ii), 
[10:18:32.477]                           FUN = function(jj) {
[10:18:32.477]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.477]                             ...future.FUN(...future.X_jj, ...)
[10:18:32.477]                           })
[10:18:32.477]                       }
[10:18:32.477]                     }, args = future.call.arguments)
[10:18:32.477]                   }
[10:18:32.477]                 }, immediateCondition = function(cond) {
[10:18:32.477]                   save_rds <- function (object, pathname, ...) 
[10:18:32.477]                   {
[10:18:32.477]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:32.477]                     if (file_test("-f", pathname_tmp)) {
[10:18:32.477]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.477]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:32.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.477]                         fi_tmp[["mtime"]])
[10:18:32.477]                     }
[10:18:32.477]                     tryCatch({
[10:18:32.477]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:32.477]                     }, error = function(ex) {
[10:18:32.477]                       msg <- conditionMessage(ex)
[10:18:32.477]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.477]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:32.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.477]                         fi_tmp[["mtime"]], msg)
[10:18:32.477]                       ex$message <- msg
[10:18:32.477]                       stop(ex)
[10:18:32.477]                     })
[10:18:32.477]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:32.477]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:32.477]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:32.477]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.477]                       fi <- file.info(pathname)
[10:18:32.477]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:32.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.477]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:32.477]                         fi[["size"]], fi[["mtime"]])
[10:18:32.477]                       stop(msg)
[10:18:32.477]                     }
[10:18:32.477]                     invisible(pathname)
[10:18:32.477]                   }
[10:18:32.477]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:32.477]                     rootPath = tempdir()) 
[10:18:32.477]                   {
[10:18:32.477]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:32.477]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:32.477]                       tmpdir = path, fileext = ".rds")
[10:18:32.477]                     save_rds(obj, file)
[10:18:32.477]                   }
[10:18:32.477]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:32.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.477]                   {
[10:18:32.477]                     inherits <- base::inherits
[10:18:32.477]                     invokeRestart <- base::invokeRestart
[10:18:32.477]                     is.null <- base::is.null
[10:18:32.477]                     muffled <- FALSE
[10:18:32.477]                     if (inherits(cond, "message")) {
[10:18:32.477]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:32.477]                       if (muffled) 
[10:18:32.477]                         invokeRestart("muffleMessage")
[10:18:32.477]                     }
[10:18:32.477]                     else if (inherits(cond, "warning")) {
[10:18:32.477]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:32.477]                       if (muffled) 
[10:18:32.477]                         invokeRestart("muffleWarning")
[10:18:32.477]                     }
[10:18:32.477]                     else if (inherits(cond, "condition")) {
[10:18:32.477]                       if (!is.null(pattern)) {
[10:18:32.477]                         computeRestarts <- base::computeRestarts
[10:18:32.477]                         grepl <- base::grepl
[10:18:32.477]                         restarts <- computeRestarts(cond)
[10:18:32.477]                         for (restart in restarts) {
[10:18:32.477]                           name <- restart$name
[10:18:32.477]                           if (is.null(name)) 
[10:18:32.477]                             next
[10:18:32.477]                           if (!grepl(pattern, name)) 
[10:18:32.477]                             next
[10:18:32.477]                           invokeRestart(restart)
[10:18:32.477]                           muffled <- TRUE
[10:18:32.477]                           break
[10:18:32.477]                         }
[10:18:32.477]                       }
[10:18:32.477]                     }
[10:18:32.477]                     invisible(muffled)
[10:18:32.477]                   }
[10:18:32.477]                   muffleCondition(cond)
[10:18:32.477]                 })
[10:18:32.477]             }))
[10:18:32.477]             future::FutureResult(value = ...future.value$value, 
[10:18:32.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.477]                   ...future.rng), globalenv = if (FALSE) 
[10:18:32.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:32.477]                     ...future.globalenv.names))
[10:18:32.477]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:32.477]         }, condition = base::local({
[10:18:32.477]             c <- base::c
[10:18:32.477]             inherits <- base::inherits
[10:18:32.477]             invokeRestart <- base::invokeRestart
[10:18:32.477]             length <- base::length
[10:18:32.477]             list <- base::list
[10:18:32.477]             seq.int <- base::seq.int
[10:18:32.477]             signalCondition <- base::signalCondition
[10:18:32.477]             sys.calls <- base::sys.calls
[10:18:32.477]             `[[` <- base::`[[`
[10:18:32.477]             `+` <- base::`+`
[10:18:32.477]             `<<-` <- base::`<<-`
[10:18:32.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:32.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:32.477]                   3L)]
[10:18:32.477]             }
[10:18:32.477]             function(cond) {
[10:18:32.477]                 is_error <- inherits(cond, "error")
[10:18:32.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:32.477]                   NULL)
[10:18:32.477]                 if (is_error) {
[10:18:32.477]                   sessionInformation <- function() {
[10:18:32.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:32.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:32.477]                       search = base::search(), system = base::Sys.info())
[10:18:32.477]                   }
[10:18:32.477]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:32.477]                     cond$call), session = sessionInformation(), 
[10:18:32.477]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:32.477]                   signalCondition(cond)
[10:18:32.477]                 }
[10:18:32.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:32.477]                 "immediateCondition"))) {
[10:18:32.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:32.477]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:32.477]                   if (TRUE && !signal) {
[10:18:32.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.477]                     {
[10:18:32.477]                       inherits <- base::inherits
[10:18:32.477]                       invokeRestart <- base::invokeRestart
[10:18:32.477]                       is.null <- base::is.null
[10:18:32.477]                       muffled <- FALSE
[10:18:32.477]                       if (inherits(cond, "message")) {
[10:18:32.477]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.477]                         if (muffled) 
[10:18:32.477]                           invokeRestart("muffleMessage")
[10:18:32.477]                       }
[10:18:32.477]                       else if (inherits(cond, "warning")) {
[10:18:32.477]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.477]                         if (muffled) 
[10:18:32.477]                           invokeRestart("muffleWarning")
[10:18:32.477]                       }
[10:18:32.477]                       else if (inherits(cond, "condition")) {
[10:18:32.477]                         if (!is.null(pattern)) {
[10:18:32.477]                           computeRestarts <- base::computeRestarts
[10:18:32.477]                           grepl <- base::grepl
[10:18:32.477]                           restarts <- computeRestarts(cond)
[10:18:32.477]                           for (restart in restarts) {
[10:18:32.477]                             name <- restart$name
[10:18:32.477]                             if (is.null(name)) 
[10:18:32.477]                               next
[10:18:32.477]                             if (!grepl(pattern, name)) 
[10:18:32.477]                               next
[10:18:32.477]                             invokeRestart(restart)
[10:18:32.477]                             muffled <- TRUE
[10:18:32.477]                             break
[10:18:32.477]                           }
[10:18:32.477]                         }
[10:18:32.477]                       }
[10:18:32.477]                       invisible(muffled)
[10:18:32.477]                     }
[10:18:32.477]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.477]                   }
[10:18:32.477]                 }
[10:18:32.477]                 else {
[10:18:32.477]                   if (TRUE) {
[10:18:32.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.477]                     {
[10:18:32.477]                       inherits <- base::inherits
[10:18:32.477]                       invokeRestart <- base::invokeRestart
[10:18:32.477]                       is.null <- base::is.null
[10:18:32.477]                       muffled <- FALSE
[10:18:32.477]                       if (inherits(cond, "message")) {
[10:18:32.477]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.477]                         if (muffled) 
[10:18:32.477]                           invokeRestart("muffleMessage")
[10:18:32.477]                       }
[10:18:32.477]                       else if (inherits(cond, "warning")) {
[10:18:32.477]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.477]                         if (muffled) 
[10:18:32.477]                           invokeRestart("muffleWarning")
[10:18:32.477]                       }
[10:18:32.477]                       else if (inherits(cond, "condition")) {
[10:18:32.477]                         if (!is.null(pattern)) {
[10:18:32.477]                           computeRestarts <- base::computeRestarts
[10:18:32.477]                           grepl <- base::grepl
[10:18:32.477]                           restarts <- computeRestarts(cond)
[10:18:32.477]                           for (restart in restarts) {
[10:18:32.477]                             name <- restart$name
[10:18:32.477]                             if (is.null(name)) 
[10:18:32.477]                               next
[10:18:32.477]                             if (!grepl(pattern, name)) 
[10:18:32.477]                               next
[10:18:32.477]                             invokeRestart(restart)
[10:18:32.477]                             muffled <- TRUE
[10:18:32.477]                             break
[10:18:32.477]                           }
[10:18:32.477]                         }
[10:18:32.477]                       }
[10:18:32.477]                       invisible(muffled)
[10:18:32.477]                     }
[10:18:32.477]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.477]                   }
[10:18:32.477]                 }
[10:18:32.477]             }
[10:18:32.477]         }))
[10:18:32.477]     }, error = function(ex) {
[10:18:32.477]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:32.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.477]                 ...future.rng), started = ...future.startTime, 
[10:18:32.477]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:32.477]             version = "1.8"), class = "FutureResult")
[10:18:32.477]     }, finally = {
[10:18:32.477]         if (!identical(...future.workdir, getwd())) 
[10:18:32.477]             setwd(...future.workdir)
[10:18:32.477]         {
[10:18:32.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:32.477]                 ...future.oldOptions$nwarnings <- NULL
[10:18:32.477]             }
[10:18:32.477]             base::options(...future.oldOptions)
[10:18:32.477]             if (.Platform$OS.type == "windows") {
[10:18:32.477]                 old_names <- names(...future.oldEnvVars)
[10:18:32.477]                 envs <- base::Sys.getenv()
[10:18:32.477]                 names <- names(envs)
[10:18:32.477]                 common <- intersect(names, old_names)
[10:18:32.477]                 added <- setdiff(names, old_names)
[10:18:32.477]                 removed <- setdiff(old_names, names)
[10:18:32.477]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:32.477]                   envs[common]]
[10:18:32.477]                 NAMES <- toupper(changed)
[10:18:32.477]                 args <- list()
[10:18:32.477]                 for (kk in seq_along(NAMES)) {
[10:18:32.477]                   name <- changed[[kk]]
[10:18:32.477]                   NAME <- NAMES[[kk]]
[10:18:32.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.477]                     next
[10:18:32.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.477]                 }
[10:18:32.477]                 NAMES <- toupper(added)
[10:18:32.477]                 for (kk in seq_along(NAMES)) {
[10:18:32.477]                   name <- added[[kk]]
[10:18:32.477]                   NAME <- NAMES[[kk]]
[10:18:32.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.477]                     next
[10:18:32.477]                   args[[name]] <- ""
[10:18:32.477]                 }
[10:18:32.477]                 NAMES <- toupper(removed)
[10:18:32.477]                 for (kk in seq_along(NAMES)) {
[10:18:32.477]                   name <- removed[[kk]]
[10:18:32.477]                   NAME <- NAMES[[kk]]
[10:18:32.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.477]                     next
[10:18:32.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.477]                 }
[10:18:32.477]                 if (length(args) > 0) 
[10:18:32.477]                   base::do.call(base::Sys.setenv, args = args)
[10:18:32.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:32.477]             }
[10:18:32.477]             else {
[10:18:32.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:32.477]             }
[10:18:32.477]             {
[10:18:32.477]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:32.477]                   0L) {
[10:18:32.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:32.477]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:32.477]                   base::options(opts)
[10:18:32.477]                 }
[10:18:32.477]                 {
[10:18:32.477]                   {
[10:18:32.477]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:32.477]                     NULL
[10:18:32.477]                   }
[10:18:32.477]                   options(future.plan = NULL)
[10:18:32.477]                   if (is.na(NA_character_)) 
[10:18:32.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:32.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:32.477]                     .init = FALSE)
[10:18:32.477]                 }
[10:18:32.477]             }
[10:18:32.477]         }
[10:18:32.477]     })
[10:18:32.477]     if (TRUE) {
[10:18:32.477]         base::sink(type = "output", split = FALSE)
[10:18:32.477]         if (TRUE) {
[10:18:32.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:32.477]         }
[10:18:32.477]         else {
[10:18:32.477]             ...future.result["stdout"] <- base::list(NULL)
[10:18:32.477]         }
[10:18:32.477]         base::close(...future.stdout)
[10:18:32.477]         ...future.stdout <- NULL
[10:18:32.477]     }
[10:18:32.477]     ...future.result$conditions <- ...future.conditions
[10:18:32.477]     ...future.result$finished <- base::Sys.time()
[10:18:32.477]     ...future.result
[10:18:32.477] }
[10:18:32.480] assign_globals() ...
[10:18:32.480] List of 5
[10:18:32.480]  $ ...future.FUN            :function (object, ...)  
[10:18:32.480]  $ future.call.arguments    : list()
[10:18:32.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.480]  $ ...future.elements_ii    :List of 1
[10:18:32.480]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.480]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:18:32.480]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.480]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:32.480]  $ ...future.seeds_ii       : NULL
[10:18:32.480]  $ ...future.globals.maxSize: NULL
[10:18:32.480]  - attr(*, "where")=List of 5
[10:18:32.480]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:32.480]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:32.480]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:32.480]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:32.480]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:32.480]  - attr(*, "resolved")= logi FALSE
[10:18:32.480]  - attr(*, "total_size")= num 18647
[10:18:32.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.480]  - attr(*, "already-done")= logi TRUE
[10:18:32.487] - copied ‘...future.FUN’ to environment
[10:18:32.487] - copied ‘future.call.arguments’ to environment
[10:18:32.487] - copied ‘...future.elements_ii’ to environment
[10:18:32.487] - copied ‘...future.seeds_ii’ to environment
[10:18:32.487] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.487] assign_globals() ... done
[10:18:32.487] requestCore(): workers = 2
[10:18:32.490] MulticoreFuture started
[10:18:32.491] - Launch lazy future ... done
[10:18:32.491] run() for ‘MulticoreFuture’ ... done
[10:18:32.491] Created future:
[10:18:32.491] plan(): Setting new future strategy stack:
[10:18:32.491] List of future strategies:
[10:18:32.491] 1. sequential:
[10:18:32.491]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.491]    - tweaked: FALSE
[10:18:32.491]    - call: NULL
[10:18:32.492] plan(): nbrOfWorkers() = 1
[10:18:32.495] plan(): Setting new future strategy stack:
[10:18:32.496] List of future strategies:
[10:18:32.496] 1. multicore:
[10:18:32.496]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.496]    - tweaked: FALSE
[10:18:32.496]    - call: plan(strategy)
[10:18:32.498] plan(): nbrOfWorkers() = 2
[10:18:32.491] MulticoreFuture:
[10:18:32.491] Label: ‘future_by-1’
[10:18:32.491] Expression:
[10:18:32.491] {
[10:18:32.491]     do.call(function(...) {
[10:18:32.491]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.491]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.491]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.491]             on.exit(options(oopts), add = TRUE)
[10:18:32.491]         }
[10:18:32.491]         {
[10:18:32.491]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.491]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.491]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.491]             })
[10:18:32.491]         }
[10:18:32.491]     }, args = future.call.arguments)
[10:18:32.491] }
[10:18:32.491] Lazy evaluation: FALSE
[10:18:32.491] Asynchronous evaluation: TRUE
[10:18:32.491] Local evaluation: TRUE
[10:18:32.491] Environment: 0x55844ba77588
[10:18:32.491] Capture standard output: TRUE
[10:18:32.491] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.491] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:32.491] Packages: <none>
[10:18:32.491] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.491] Resolved: TRUE
[10:18:32.491] Value: <not collected>
[10:18:32.491] Conditions captured: <none>
[10:18:32.491] Early signaling: FALSE
[10:18:32.491] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.491] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.499] Chunk #1 of 2 ... DONE
[10:18:32.500] Chunk #2 of 2 ...
[10:18:32.500]  - Finding globals in 'X' for chunk #2 ...
[10:18:32.500] getGlobalsAndPackages() ...
[10:18:32.500] Searching for globals...
[10:18:32.501] 
[10:18:32.501] Searching for globals ... DONE
[10:18:32.501] - globals: [0] <none>
[10:18:32.501] getGlobalsAndPackages() ... DONE
[10:18:32.501]    + additional globals found: [n=0] 
[10:18:32.501]    + additional namespaces needed: [n=0] 
[10:18:32.502]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:32.502]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:32.502]  - seeds: <none>
[10:18:32.502]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.502] getGlobalsAndPackages() ...
[10:18:32.502] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.502] Resolving globals: FALSE
[10:18:32.502] Tweak future expression to call with '...' arguments ...
[10:18:32.503] {
[10:18:32.503]     do.call(function(...) {
[10:18:32.503]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.503]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.503]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.503]             on.exit(options(oopts), add = TRUE)
[10:18:32.503]         }
[10:18:32.503]         {
[10:18:32.503]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.503]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.503]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.503]             })
[10:18:32.503]         }
[10:18:32.503]     }, args = future.call.arguments)
[10:18:32.503] }
[10:18:32.503] Tweak future expression to call with '...' arguments ... DONE
[10:18:32.503] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:32.504] 
[10:18:32.504] getGlobalsAndPackages() ... DONE
[10:18:32.504] run() for ‘Future’ ...
[10:18:32.504] - state: ‘created’
[10:18:32.505] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:32.507] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:32.507]   - Field: ‘label’
[10:18:32.507]   - Field: ‘local’
[10:18:32.507]   - Field: ‘owner’
[10:18:32.508]   - Field: ‘envir’
[10:18:32.508]   - Field: ‘workers’
[10:18:32.508]   - Field: ‘packages’
[10:18:32.508]   - Field: ‘gc’
[10:18:32.508]   - Field: ‘job’
[10:18:32.508]   - Field: ‘conditions’
[10:18:32.508]   - Field: ‘expr’
[10:18:32.508]   - Field: ‘uuid’
[10:18:32.508]   - Field: ‘seed’
[10:18:32.509]   - Field: ‘version’
[10:18:32.509]   - Field: ‘result’
[10:18:32.509]   - Field: ‘asynchronous’
[10:18:32.509]   - Field: ‘calls’
[10:18:32.509]   - Field: ‘globals’
[10:18:32.509]   - Field: ‘stdout’
[10:18:32.509]   - Field: ‘earlySignal’
[10:18:32.509]   - Field: ‘lazy’
[10:18:32.509]   - Field: ‘state’
[10:18:32.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:32.510] - Launch lazy future ...
[10:18:32.510] Packages needed by the future expression (n = 0): <none>
[10:18:32.510] Packages needed by future strategies (n = 0): <none>
[10:18:32.511] {
[10:18:32.511]     {
[10:18:32.511]         {
[10:18:32.511]             ...future.startTime <- base::Sys.time()
[10:18:32.511]             {
[10:18:32.511]                 {
[10:18:32.511]                   {
[10:18:32.511]                     {
[10:18:32.511]                       base::local({
[10:18:32.511]                         has_future <- base::requireNamespace("future", 
[10:18:32.511]                           quietly = TRUE)
[10:18:32.511]                         if (has_future) {
[10:18:32.511]                           ns <- base::getNamespace("future")
[10:18:32.511]                           version <- ns[[".package"]][["version"]]
[10:18:32.511]                           if (is.null(version)) 
[10:18:32.511]                             version <- utils::packageVersion("future")
[10:18:32.511]                         }
[10:18:32.511]                         else {
[10:18:32.511]                           version <- NULL
[10:18:32.511]                         }
[10:18:32.511]                         if (!has_future || version < "1.8.0") {
[10:18:32.511]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:32.511]                             "", base::R.version$version.string), 
[10:18:32.511]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:32.511]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:32.511]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:32.511]                               "release", "version")], collapse = " "), 
[10:18:32.511]                             hostname = base::Sys.info()[["nodename"]])
[10:18:32.511]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:32.511]                             info)
[10:18:32.511]                           info <- base::paste(info, collapse = "; ")
[10:18:32.511]                           if (!has_future) {
[10:18:32.511]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:32.511]                               info)
[10:18:32.511]                           }
[10:18:32.511]                           else {
[10:18:32.511]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:32.511]                               info, version)
[10:18:32.511]                           }
[10:18:32.511]                           base::stop(msg)
[10:18:32.511]                         }
[10:18:32.511]                       })
[10:18:32.511]                     }
[10:18:32.511]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:32.511]                     base::options(mc.cores = 1L)
[10:18:32.511]                   }
[10:18:32.511]                   ...future.strategy.old <- future::plan("list")
[10:18:32.511]                   options(future.plan = NULL)
[10:18:32.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:32.511]                 }
[10:18:32.511]                 ...future.workdir <- getwd()
[10:18:32.511]             }
[10:18:32.511]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:32.511]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:32.511]         }
[10:18:32.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:32.511]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:32.511]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:32.511]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:32.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:32.511]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:32.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:32.511]             base::names(...future.oldOptions))
[10:18:32.511]     }
[10:18:32.511]     if (FALSE) {
[10:18:32.511]     }
[10:18:32.511]     else {
[10:18:32.511]         if (TRUE) {
[10:18:32.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:32.511]                 open = "w")
[10:18:32.511]         }
[10:18:32.511]         else {
[10:18:32.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:32.511]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:32.511]         }
[10:18:32.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:32.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:32.511]             base::sink(type = "output", split = FALSE)
[10:18:32.511]             base::close(...future.stdout)
[10:18:32.511]         }, add = TRUE)
[10:18:32.511]     }
[10:18:32.511]     ...future.frame <- base::sys.nframe()
[10:18:32.511]     ...future.conditions <- base::list()
[10:18:32.511]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:32.511]     if (FALSE) {
[10:18:32.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:32.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:32.511]     }
[10:18:32.511]     ...future.result <- base::tryCatch({
[10:18:32.511]         base::withCallingHandlers({
[10:18:32.511]             ...future.value <- base::withVisible(base::local({
[10:18:32.511]                 withCallingHandlers({
[10:18:32.511]                   {
[10:18:32.511]                     do.call(function(...) {
[10:18:32.511]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.511]                       if (!identical(...future.globals.maxSize.org, 
[10:18:32.511]                         ...future.globals.maxSize)) {
[10:18:32.511]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.511]                         on.exit(options(oopts), add = TRUE)
[10:18:32.511]                       }
[10:18:32.511]                       {
[10:18:32.511]                         lapply(seq_along(...future.elements_ii), 
[10:18:32.511]                           FUN = function(jj) {
[10:18:32.511]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.511]                             ...future.FUN(...future.X_jj, ...)
[10:18:32.511]                           })
[10:18:32.511]                       }
[10:18:32.511]                     }, args = future.call.arguments)
[10:18:32.511]                   }
[10:18:32.511]                 }, immediateCondition = function(cond) {
[10:18:32.511]                   save_rds <- function (object, pathname, ...) 
[10:18:32.511]                   {
[10:18:32.511]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:32.511]                     if (file_test("-f", pathname_tmp)) {
[10:18:32.511]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.511]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:32.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.511]                         fi_tmp[["mtime"]])
[10:18:32.511]                     }
[10:18:32.511]                     tryCatch({
[10:18:32.511]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:32.511]                     }, error = function(ex) {
[10:18:32.511]                       msg <- conditionMessage(ex)
[10:18:32.511]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.511]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:32.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.511]                         fi_tmp[["mtime"]], msg)
[10:18:32.511]                       ex$message <- msg
[10:18:32.511]                       stop(ex)
[10:18:32.511]                     })
[10:18:32.511]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:32.511]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:32.511]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:32.511]                       fi_tmp <- file.info(pathname_tmp)
[10:18:32.511]                       fi <- file.info(pathname)
[10:18:32.511]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:32.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:32.511]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:32.511]                         fi[["size"]], fi[["mtime"]])
[10:18:32.511]                       stop(msg)
[10:18:32.511]                     }
[10:18:32.511]                     invisible(pathname)
[10:18:32.511]                   }
[10:18:32.511]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:32.511]                     rootPath = tempdir()) 
[10:18:32.511]                   {
[10:18:32.511]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:32.511]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:32.511]                       tmpdir = path, fileext = ".rds")
[10:18:32.511]                     save_rds(obj, file)
[10:18:32.511]                   }
[10:18:32.511]                   saveImmediateCondition(cond, path = "/tmp/RtmpBhvLfJ/.future/immediateConditions")
[10:18:32.511]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.511]                   {
[10:18:32.511]                     inherits <- base::inherits
[10:18:32.511]                     invokeRestart <- base::invokeRestart
[10:18:32.511]                     is.null <- base::is.null
[10:18:32.511]                     muffled <- FALSE
[10:18:32.511]                     if (inherits(cond, "message")) {
[10:18:32.511]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:32.511]                       if (muffled) 
[10:18:32.511]                         invokeRestart("muffleMessage")
[10:18:32.511]                     }
[10:18:32.511]                     else if (inherits(cond, "warning")) {
[10:18:32.511]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:32.511]                       if (muffled) 
[10:18:32.511]                         invokeRestart("muffleWarning")
[10:18:32.511]                     }
[10:18:32.511]                     else if (inherits(cond, "condition")) {
[10:18:32.511]                       if (!is.null(pattern)) {
[10:18:32.511]                         computeRestarts <- base::computeRestarts
[10:18:32.511]                         grepl <- base::grepl
[10:18:32.511]                         restarts <- computeRestarts(cond)
[10:18:32.511]                         for (restart in restarts) {
[10:18:32.511]                           name <- restart$name
[10:18:32.511]                           if (is.null(name)) 
[10:18:32.511]                             next
[10:18:32.511]                           if (!grepl(pattern, name)) 
[10:18:32.511]                             next
[10:18:32.511]                           invokeRestart(restart)
[10:18:32.511]                           muffled <- TRUE
[10:18:32.511]                           break
[10:18:32.511]                         }
[10:18:32.511]                       }
[10:18:32.511]                     }
[10:18:32.511]                     invisible(muffled)
[10:18:32.511]                   }
[10:18:32.511]                   muffleCondition(cond)
[10:18:32.511]                 })
[10:18:32.511]             }))
[10:18:32.511]             future::FutureResult(value = ...future.value$value, 
[10:18:32.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.511]                   ...future.rng), globalenv = if (FALSE) 
[10:18:32.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:32.511]                     ...future.globalenv.names))
[10:18:32.511]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:32.511]         }, condition = base::local({
[10:18:32.511]             c <- base::c
[10:18:32.511]             inherits <- base::inherits
[10:18:32.511]             invokeRestart <- base::invokeRestart
[10:18:32.511]             length <- base::length
[10:18:32.511]             list <- base::list
[10:18:32.511]             seq.int <- base::seq.int
[10:18:32.511]             signalCondition <- base::signalCondition
[10:18:32.511]             sys.calls <- base::sys.calls
[10:18:32.511]             `[[` <- base::`[[`
[10:18:32.511]             `+` <- base::`+`
[10:18:32.511]             `<<-` <- base::`<<-`
[10:18:32.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:32.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:32.511]                   3L)]
[10:18:32.511]             }
[10:18:32.511]             function(cond) {
[10:18:32.511]                 is_error <- inherits(cond, "error")
[10:18:32.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:32.511]                   NULL)
[10:18:32.511]                 if (is_error) {
[10:18:32.511]                   sessionInformation <- function() {
[10:18:32.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:32.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:32.511]                       search = base::search(), system = base::Sys.info())
[10:18:32.511]                   }
[10:18:32.511]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:32.511]                     cond$call), session = sessionInformation(), 
[10:18:32.511]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:32.511]                   signalCondition(cond)
[10:18:32.511]                 }
[10:18:32.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:32.511]                 "immediateCondition"))) {
[10:18:32.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:32.511]                   ...future.conditions[[length(...future.conditions) + 
[10:18:32.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:32.511]                   if (TRUE && !signal) {
[10:18:32.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.511]                     {
[10:18:32.511]                       inherits <- base::inherits
[10:18:32.511]                       invokeRestart <- base::invokeRestart
[10:18:32.511]                       is.null <- base::is.null
[10:18:32.511]                       muffled <- FALSE
[10:18:32.511]                       if (inherits(cond, "message")) {
[10:18:32.511]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.511]                         if (muffled) 
[10:18:32.511]                           invokeRestart("muffleMessage")
[10:18:32.511]                       }
[10:18:32.511]                       else if (inherits(cond, "warning")) {
[10:18:32.511]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.511]                         if (muffled) 
[10:18:32.511]                           invokeRestart("muffleWarning")
[10:18:32.511]                       }
[10:18:32.511]                       else if (inherits(cond, "condition")) {
[10:18:32.511]                         if (!is.null(pattern)) {
[10:18:32.511]                           computeRestarts <- base::computeRestarts
[10:18:32.511]                           grepl <- base::grepl
[10:18:32.511]                           restarts <- computeRestarts(cond)
[10:18:32.511]                           for (restart in restarts) {
[10:18:32.511]                             name <- restart$name
[10:18:32.511]                             if (is.null(name)) 
[10:18:32.511]                               next
[10:18:32.511]                             if (!grepl(pattern, name)) 
[10:18:32.511]                               next
[10:18:32.511]                             invokeRestart(restart)
[10:18:32.511]                             muffled <- TRUE
[10:18:32.511]                             break
[10:18:32.511]                           }
[10:18:32.511]                         }
[10:18:32.511]                       }
[10:18:32.511]                       invisible(muffled)
[10:18:32.511]                     }
[10:18:32.511]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.511]                   }
[10:18:32.511]                 }
[10:18:32.511]                 else {
[10:18:32.511]                   if (TRUE) {
[10:18:32.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:32.511]                     {
[10:18:32.511]                       inherits <- base::inherits
[10:18:32.511]                       invokeRestart <- base::invokeRestart
[10:18:32.511]                       is.null <- base::is.null
[10:18:32.511]                       muffled <- FALSE
[10:18:32.511]                       if (inherits(cond, "message")) {
[10:18:32.511]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:32.511]                         if (muffled) 
[10:18:32.511]                           invokeRestart("muffleMessage")
[10:18:32.511]                       }
[10:18:32.511]                       else if (inherits(cond, "warning")) {
[10:18:32.511]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:32.511]                         if (muffled) 
[10:18:32.511]                           invokeRestart("muffleWarning")
[10:18:32.511]                       }
[10:18:32.511]                       else if (inherits(cond, "condition")) {
[10:18:32.511]                         if (!is.null(pattern)) {
[10:18:32.511]                           computeRestarts <- base::computeRestarts
[10:18:32.511]                           grepl <- base::grepl
[10:18:32.511]                           restarts <- computeRestarts(cond)
[10:18:32.511]                           for (restart in restarts) {
[10:18:32.511]                             name <- restart$name
[10:18:32.511]                             if (is.null(name)) 
[10:18:32.511]                               next
[10:18:32.511]                             if (!grepl(pattern, name)) 
[10:18:32.511]                               next
[10:18:32.511]                             invokeRestart(restart)
[10:18:32.511]                             muffled <- TRUE
[10:18:32.511]                             break
[10:18:32.511]                           }
[10:18:32.511]                         }
[10:18:32.511]                       }
[10:18:32.511]                       invisible(muffled)
[10:18:32.511]                     }
[10:18:32.511]                     muffleCondition(cond, pattern = "^muffle")
[10:18:32.511]                   }
[10:18:32.511]                 }
[10:18:32.511]             }
[10:18:32.511]         }))
[10:18:32.511]     }, error = function(ex) {
[10:18:32.511]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:32.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:32.511]                 ...future.rng), started = ...future.startTime, 
[10:18:32.511]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:32.511]             version = "1.8"), class = "FutureResult")
[10:18:32.511]     }, finally = {
[10:18:32.511]         if (!identical(...future.workdir, getwd())) 
[10:18:32.511]             setwd(...future.workdir)
[10:18:32.511]         {
[10:18:32.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:32.511]                 ...future.oldOptions$nwarnings <- NULL
[10:18:32.511]             }
[10:18:32.511]             base::options(...future.oldOptions)
[10:18:32.511]             if (.Platform$OS.type == "windows") {
[10:18:32.511]                 old_names <- names(...future.oldEnvVars)
[10:18:32.511]                 envs <- base::Sys.getenv()
[10:18:32.511]                 names <- names(envs)
[10:18:32.511]                 common <- intersect(names, old_names)
[10:18:32.511]                 added <- setdiff(names, old_names)
[10:18:32.511]                 removed <- setdiff(old_names, names)
[10:18:32.511]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:32.511]                   envs[common]]
[10:18:32.511]                 NAMES <- toupper(changed)
[10:18:32.511]                 args <- list()
[10:18:32.511]                 for (kk in seq_along(NAMES)) {
[10:18:32.511]                   name <- changed[[kk]]
[10:18:32.511]                   NAME <- NAMES[[kk]]
[10:18:32.511]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.511]                     next
[10:18:32.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.511]                 }
[10:18:32.511]                 NAMES <- toupper(added)
[10:18:32.511]                 for (kk in seq_along(NAMES)) {
[10:18:32.511]                   name <- added[[kk]]
[10:18:32.511]                   NAME <- NAMES[[kk]]
[10:18:32.511]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.511]                     next
[10:18:32.511]                   args[[name]] <- ""
[10:18:32.511]                 }
[10:18:32.511]                 NAMES <- toupper(removed)
[10:18:32.511]                 for (kk in seq_along(NAMES)) {
[10:18:32.511]                   name <- removed[[kk]]
[10:18:32.511]                   NAME <- NAMES[[kk]]
[10:18:32.511]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:32.511]                     next
[10:18:32.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:32.511]                 }
[10:18:32.511]                 if (length(args) > 0) 
[10:18:32.511]                   base::do.call(base::Sys.setenv, args = args)
[10:18:32.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:32.511]             }
[10:18:32.511]             else {
[10:18:32.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:32.511]             }
[10:18:32.511]             {
[10:18:32.511]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:32.511]                   0L) {
[10:18:32.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:32.511]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:32.511]                   base::options(opts)
[10:18:32.511]                 }
[10:18:32.511]                 {
[10:18:32.511]                   {
[10:18:32.511]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:32.511]                     NULL
[10:18:32.511]                   }
[10:18:32.511]                   options(future.plan = NULL)
[10:18:32.511]                   if (is.na(NA_character_)) 
[10:18:32.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:32.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:32.511]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:32.511]                     .init = FALSE)
[10:18:32.511]                 }
[10:18:32.511]             }
[10:18:32.511]         }
[10:18:32.511]     })
[10:18:32.511]     if (TRUE) {
[10:18:32.511]         base::sink(type = "output", split = FALSE)
[10:18:32.511]         if (TRUE) {
[10:18:32.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:32.511]         }
[10:18:32.511]         else {
[10:18:32.511]             ...future.result["stdout"] <- base::list(NULL)
[10:18:32.511]         }
[10:18:32.511]         base::close(...future.stdout)
[10:18:32.511]         ...future.stdout <- NULL
[10:18:32.511]     }
[10:18:32.511]     ...future.result$conditions <- ...future.conditions
[10:18:32.511]     ...future.result$finished <- base::Sys.time()
[10:18:32.511]     ...future.result
[10:18:32.511] }
[10:18:32.514] assign_globals() ...
[10:18:32.514] List of 5
[10:18:32.514]  $ ...future.FUN            :function (object, ...)  
[10:18:32.514]  $ future.call.arguments    : list()
[10:18:32.514]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:32.514]  $ ...future.elements_ii    :List of 2
[10:18:32.514]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.514]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:18:32.514]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.514]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:18:32.514]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:18:32.514]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:18:32.514]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:18:32.514]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:18:32.514]  $ ...future.seeds_ii       : NULL
[10:18:32.514]  $ ...future.globals.maxSize: NULL
[10:18:32.514]  - attr(*, "where")=List of 5
[10:18:32.514]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:32.514]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:32.514]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:32.514]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:32.514]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:32.514]  - attr(*, "resolved")= logi FALSE
[10:18:32.514]  - attr(*, "total_size")= num 18647
[10:18:32.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:32.514]  - attr(*, "already-done")= logi TRUE
[10:18:32.529] - copied ‘...future.FUN’ to environment
[10:18:32.530] - copied ‘future.call.arguments’ to environment
[10:18:32.530] - copied ‘...future.elements_ii’ to environment
[10:18:32.530] - copied ‘...future.seeds_ii’ to environment
[10:18:32.530] - copied ‘...future.globals.maxSize’ to environment
[10:18:32.530] assign_globals() ... done
[10:18:32.530] requestCore(): workers = 2
[10:18:32.533] MulticoreFuture started
[10:18:32.533] - Launch lazy future ... done
[10:18:32.534] run() for ‘MulticoreFuture’ ... done
[10:18:32.534] Created future:
[10:18:32.534] plan(): Setting new future strategy stack:
[10:18:32.535] List of future strategies:
[10:18:32.535] 1. sequential:
[10:18:32.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:32.535]    - tweaked: FALSE
[10:18:32.535]    - call: NULL
[10:18:32.535] plan(): nbrOfWorkers() = 1
[10:18:32.540] plan(): Setting new future strategy stack:
[10:18:32.540] List of future strategies:
[10:18:32.540] 1. multicore:
[10:18:32.540]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:32.540]    - tweaked: FALSE
[10:18:32.540]    - call: plan(strategy)
[10:18:32.543] plan(): nbrOfWorkers() = 2
[10:18:32.534] MulticoreFuture:
[10:18:32.534] Label: ‘future_by-2’
[10:18:32.534] Expression:
[10:18:32.534] {
[10:18:32.534]     do.call(function(...) {
[10:18:32.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:32.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:32.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:32.534]             on.exit(options(oopts), add = TRUE)
[10:18:32.534]         }
[10:18:32.534]         {
[10:18:32.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:32.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:32.534]                 ...future.FUN(...future.X_jj, ...)
[10:18:32.534]             })
[10:18:32.534]         }
[10:18:32.534]     }, args = future.call.arguments)
[10:18:32.534] }
[10:18:32.534] Lazy evaluation: FALSE
[10:18:32.534] Asynchronous evaluation: TRUE
[10:18:32.534] Local evaluation: TRUE
[10:18:32.534] Environment: 0x55844ba77588
[10:18:32.534] Capture standard output: TRUE
[10:18:32.534] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:32.534] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:32.534] Packages: <none>
[10:18:32.534] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:32.534] Resolved: TRUE
[10:18:32.534] Value: <not collected>
[10:18:32.534] Conditions captured: <none>
[10:18:32.534] Early signaling: FALSE
[10:18:32.534] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:32.534] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:32.544] Chunk #2 of 2 ... DONE
[10:18:32.544] Launching 2 futures (chunks) ... DONE
[10:18:32.544] Resolving 2 futures (chunks) ...
[10:18:32.544] resolve() on list ...
[10:18:32.544]  recursive: 0
[10:18:32.544]  length: 2
[10:18:32.545] 
[10:18:32.545] Future #1
[10:18:32.545] result() for MulticoreFuture ...
[10:18:32.546] result() for MulticoreFuture ...
[10:18:32.546] result() for MulticoreFuture ... done
[10:18:32.546] result() for MulticoreFuture ... done
[10:18:32.546] result() for MulticoreFuture ...
[10:18:32.547] result() for MulticoreFuture ... done
[10:18:32.547] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:32.547] - nx: 2
[10:18:32.547] - relay: TRUE
[10:18:32.547] - stdout: TRUE
[10:18:32.547] - signal: TRUE
[10:18:32.547] - resignal: FALSE
[10:18:32.547] - force: TRUE
[10:18:32.548] - relayed: [n=2] FALSE, FALSE
[10:18:32.548] - queued futures: [n=2] FALSE, FALSE
[10:18:32.548]  - until=1
[10:18:32.548]  - relaying element #1
[10:18:32.548] result() for MulticoreFuture ...
[10:18:32.548] result() for MulticoreFuture ... done
[10:18:32.548] result() for MulticoreFuture ...
[10:18:32.548] result() for MulticoreFuture ... done
[10:18:32.549] result() for MulticoreFuture ...
[10:18:32.549] result() for MulticoreFuture ... done
[10:18:32.549] result() for MulticoreFuture ...
[10:18:32.549] result() for MulticoreFuture ... done
[10:18:32.549] - relayed: [n=2] TRUE, FALSE
[10:18:32.549] - queued futures: [n=2] TRUE, FALSE
[10:18:32.549] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:32.550]  length: 1 (resolved future 1)
[10:18:32.550] Future #2
[10:18:32.550] result() for MulticoreFuture ...
[10:18:32.551] result() for MulticoreFuture ...
[10:18:32.551] result() for MulticoreFuture ... done
[10:18:32.551] result() for MulticoreFuture ... done
[10:18:32.551] result() for MulticoreFuture ...
[10:18:32.551] result() for MulticoreFuture ... done
[10:18:32.551] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:32.551] - nx: 2
[10:18:32.552] - relay: TRUE
[10:18:32.552] - stdout: TRUE
[10:18:32.552] - signal: TRUE
[10:18:32.552] - resignal: FALSE
[10:18:32.552] - force: TRUE
[10:18:32.552] - relayed: [n=2] TRUE, FALSE
[10:18:32.552] - queued futures: [n=2] TRUE, FALSE
[10:18:32.552]  - until=2
[10:18:32.553]  - relaying element #2
[10:18:32.553] result() for MulticoreFuture ...
[10:18:32.553] result() for MulticoreFuture ... done
[10:18:32.553] result() for MulticoreFuture ...
[10:18:32.553] result() for MulticoreFuture ... done
[10:18:32.553] result() for MulticoreFuture ...
[10:18:32.553] result() for MulticoreFuture ... done
[10:18:32.553] result() for MulticoreFuture ...
[10:18:32.553] result() for MulticoreFuture ... done
[10:18:32.554] - relayed: [n=2] TRUE, TRUE
[10:18:32.554] - queued futures: [n=2] TRUE, TRUE
[10:18:32.554] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:32.554]  length: 0 (resolved future 2)
[10:18:32.554] Relaying remaining futures
[10:18:32.554] signalConditionsASAP(NULL, pos=0) ...
[10:18:32.554] - nx: 2
[10:18:32.554] - relay: TRUE
[10:18:32.554] - stdout: TRUE
[10:18:32.555] - signal: TRUE
[10:18:32.555] - resignal: FALSE
[10:18:32.555] - force: TRUE
[10:18:32.555] - relayed: [n=2] TRUE, TRUE
[10:18:32.555] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:32.555] - relayed: [n=2] TRUE, TRUE
[10:18:32.555] - queued futures: [n=2] TRUE, TRUE
[10:18:32.555] signalConditionsASAP(NULL, pos=0) ... done
[10:18:32.556] resolve() on list ... DONE
[10:18:32.556] result() for MulticoreFuture ...
[10:18:32.556] result() for MulticoreFuture ... done
[10:18:32.556] result() for MulticoreFuture ...
[10:18:32.556] result() for MulticoreFuture ... done
[10:18:32.556] result() for MulticoreFuture ...
[10:18:32.556] result() for MulticoreFuture ... done
[10:18:32.556] result() for MulticoreFuture ...
[10:18:32.556] result() for MulticoreFuture ... done
[10:18:32.557]  - Number of value chunks collected: 2
[10:18:32.557] Resolving 2 futures (chunks) ... DONE
[10:18:32.557] Reducing values from 2 chunks ...
[10:18:32.557]  - Number of values collected after concatenation: 3
[10:18:32.557]  - Number of values expected: 3
[10:18:32.557] Reducing values from 2 chunks ... DONE
[10:18:32.557] future_lapply() ... DONE
[10:18:32.557] future_by_internal() ... DONE
[10:18:32.559] future_by_internal() ...
- plan('multisession') ...
[10:18:32.559] plan(): Setting new future strategy stack:
[10:18:32.559] List of future strategies:
[10:18:32.559] 1. multisession:
[10:18:32.559]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:32.559]    - tweaked: FALSE
[10:18:32.559]    - call: plan(strategy)
[10:18:32.560] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:18:32.560] multisession:
[10:18:32.560] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:32.560] - tweaked: FALSE
[10:18:32.560] - call: plan(strategy)
[10:18:32.565] getGlobalsAndPackages() ...
[10:18:32.565] Not searching for globals
[10:18:32.565] - globals: [0] <none>
[10:18:32.565] getGlobalsAndPackages() ... DONE
[10:18:33.062] Packages needed by the future expression (n = 0): <none>
[10:18:33.063] Packages needed by future strategies (n = 0): <none>
[10:18:33.063] {
[10:18:33.063]     {
[10:18:33.063]         {
[10:18:33.063]             ...future.startTime <- base::Sys.time()
[10:18:33.063]             {
[10:18:33.063]                 {
[10:18:33.063]                   {
[10:18:33.063]                     {
[10:18:33.063]                       base::local({
[10:18:33.063]                         has_future <- base::requireNamespace("future", 
[10:18:33.063]                           quietly = TRUE)
[10:18:33.063]                         if (has_future) {
[10:18:33.063]                           ns <- base::getNamespace("future")
[10:18:33.063]                           version <- ns[[".package"]][["version"]]
[10:18:33.063]                           if (is.null(version)) 
[10:18:33.063]                             version <- utils::packageVersion("future")
[10:18:33.063]                         }
[10:18:33.063]                         else {
[10:18:33.063]                           version <- NULL
[10:18:33.063]                         }
[10:18:33.063]                         if (!has_future || version < "1.8.0") {
[10:18:33.063]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.063]                             "", base::R.version$version.string), 
[10:18:33.063]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.063]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.063]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.063]                               "release", "version")], collapse = " "), 
[10:18:33.063]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.063]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.063]                             info)
[10:18:33.063]                           info <- base::paste(info, collapse = "; ")
[10:18:33.063]                           if (!has_future) {
[10:18:33.063]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.063]                               info)
[10:18:33.063]                           }
[10:18:33.063]                           else {
[10:18:33.063]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.063]                               info, version)
[10:18:33.063]                           }
[10:18:33.063]                           base::stop(msg)
[10:18:33.063]                         }
[10:18:33.063]                       })
[10:18:33.063]                     }
[10:18:33.063]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.063]                     base::options(mc.cores = 1L)
[10:18:33.063]                   }
[10:18:33.063]                   ...future.strategy.old <- future::plan("list")
[10:18:33.063]                   options(future.plan = NULL)
[10:18:33.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.063]                 }
[10:18:33.063]                 ...future.workdir <- getwd()
[10:18:33.063]             }
[10:18:33.063]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.063]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.063]         }
[10:18:33.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.063]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:33.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.063]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.063]             base::names(...future.oldOptions))
[10:18:33.063]     }
[10:18:33.063]     if (FALSE) {
[10:18:33.063]     }
[10:18:33.063]     else {
[10:18:33.063]         if (TRUE) {
[10:18:33.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.063]                 open = "w")
[10:18:33.063]         }
[10:18:33.063]         else {
[10:18:33.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.063]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.063]         }
[10:18:33.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.063]             base::sink(type = "output", split = FALSE)
[10:18:33.063]             base::close(...future.stdout)
[10:18:33.063]         }, add = TRUE)
[10:18:33.063]     }
[10:18:33.063]     ...future.frame <- base::sys.nframe()
[10:18:33.063]     ...future.conditions <- base::list()
[10:18:33.063]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.063]     if (FALSE) {
[10:18:33.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.063]     }
[10:18:33.063]     ...future.result <- base::tryCatch({
[10:18:33.063]         base::withCallingHandlers({
[10:18:33.063]             ...future.value <- base::withVisible(base::local({
[10:18:33.063]                 ...future.makeSendCondition <- base::local({
[10:18:33.063]                   sendCondition <- NULL
[10:18:33.063]                   function(frame = 1L) {
[10:18:33.063]                     if (is.function(sendCondition)) 
[10:18:33.063]                       return(sendCondition)
[10:18:33.063]                     ns <- getNamespace("parallel")
[10:18:33.063]                     if (exists("sendData", mode = "function", 
[10:18:33.063]                       envir = ns)) {
[10:18:33.063]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.063]                         envir = ns)
[10:18:33.063]                       envir <- sys.frame(frame)
[10:18:33.063]                       master <- NULL
[10:18:33.063]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.063]                         !identical(envir, emptyenv())) {
[10:18:33.063]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.063]                           inherits = FALSE)) {
[10:18:33.063]                           master <- get("master", mode = "list", 
[10:18:33.063]                             envir = envir, inherits = FALSE)
[10:18:33.063]                           if (inherits(master, c("SOCKnode", 
[10:18:33.063]                             "SOCK0node"))) {
[10:18:33.063]                             sendCondition <<- function(cond) {
[10:18:33.063]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.063]                                 success = TRUE)
[10:18:33.063]                               parallel_sendData(master, data)
[10:18:33.063]                             }
[10:18:33.063]                             return(sendCondition)
[10:18:33.063]                           }
[10:18:33.063]                         }
[10:18:33.063]                         frame <- frame + 1L
[10:18:33.063]                         envir <- sys.frame(frame)
[10:18:33.063]                       }
[10:18:33.063]                     }
[10:18:33.063]                     sendCondition <<- function(cond) NULL
[10:18:33.063]                   }
[10:18:33.063]                 })
[10:18:33.063]                 withCallingHandlers({
[10:18:33.063]                   NA
[10:18:33.063]                 }, immediateCondition = function(cond) {
[10:18:33.063]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.063]                   sendCondition(cond)
[10:18:33.063]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.063]                   {
[10:18:33.063]                     inherits <- base::inherits
[10:18:33.063]                     invokeRestart <- base::invokeRestart
[10:18:33.063]                     is.null <- base::is.null
[10:18:33.063]                     muffled <- FALSE
[10:18:33.063]                     if (inherits(cond, "message")) {
[10:18:33.063]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.063]                       if (muffled) 
[10:18:33.063]                         invokeRestart("muffleMessage")
[10:18:33.063]                     }
[10:18:33.063]                     else if (inherits(cond, "warning")) {
[10:18:33.063]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.063]                       if (muffled) 
[10:18:33.063]                         invokeRestart("muffleWarning")
[10:18:33.063]                     }
[10:18:33.063]                     else if (inherits(cond, "condition")) {
[10:18:33.063]                       if (!is.null(pattern)) {
[10:18:33.063]                         computeRestarts <- base::computeRestarts
[10:18:33.063]                         grepl <- base::grepl
[10:18:33.063]                         restarts <- computeRestarts(cond)
[10:18:33.063]                         for (restart in restarts) {
[10:18:33.063]                           name <- restart$name
[10:18:33.063]                           if (is.null(name)) 
[10:18:33.063]                             next
[10:18:33.063]                           if (!grepl(pattern, name)) 
[10:18:33.063]                             next
[10:18:33.063]                           invokeRestart(restart)
[10:18:33.063]                           muffled <- TRUE
[10:18:33.063]                           break
[10:18:33.063]                         }
[10:18:33.063]                       }
[10:18:33.063]                     }
[10:18:33.063]                     invisible(muffled)
[10:18:33.063]                   }
[10:18:33.063]                   muffleCondition(cond)
[10:18:33.063]                 })
[10:18:33.063]             }))
[10:18:33.063]             future::FutureResult(value = ...future.value$value, 
[10:18:33.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.063]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.063]                     ...future.globalenv.names))
[10:18:33.063]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.063]         }, condition = base::local({
[10:18:33.063]             c <- base::c
[10:18:33.063]             inherits <- base::inherits
[10:18:33.063]             invokeRestart <- base::invokeRestart
[10:18:33.063]             length <- base::length
[10:18:33.063]             list <- base::list
[10:18:33.063]             seq.int <- base::seq.int
[10:18:33.063]             signalCondition <- base::signalCondition
[10:18:33.063]             sys.calls <- base::sys.calls
[10:18:33.063]             `[[` <- base::`[[`
[10:18:33.063]             `+` <- base::`+`
[10:18:33.063]             `<<-` <- base::`<<-`
[10:18:33.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.063]                   3L)]
[10:18:33.063]             }
[10:18:33.063]             function(cond) {
[10:18:33.063]                 is_error <- inherits(cond, "error")
[10:18:33.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.063]                   NULL)
[10:18:33.063]                 if (is_error) {
[10:18:33.063]                   sessionInformation <- function() {
[10:18:33.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.063]                       search = base::search(), system = base::Sys.info())
[10:18:33.063]                   }
[10:18:33.063]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.063]                     cond$call), session = sessionInformation(), 
[10:18:33.063]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.063]                   signalCondition(cond)
[10:18:33.063]                 }
[10:18:33.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.063]                 "immediateCondition"))) {
[10:18:33.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.063]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.063]                   if (TRUE && !signal) {
[10:18:33.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.063]                     {
[10:18:33.063]                       inherits <- base::inherits
[10:18:33.063]                       invokeRestart <- base::invokeRestart
[10:18:33.063]                       is.null <- base::is.null
[10:18:33.063]                       muffled <- FALSE
[10:18:33.063]                       if (inherits(cond, "message")) {
[10:18:33.063]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.063]                         if (muffled) 
[10:18:33.063]                           invokeRestart("muffleMessage")
[10:18:33.063]                       }
[10:18:33.063]                       else if (inherits(cond, "warning")) {
[10:18:33.063]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.063]                         if (muffled) 
[10:18:33.063]                           invokeRestart("muffleWarning")
[10:18:33.063]                       }
[10:18:33.063]                       else if (inherits(cond, "condition")) {
[10:18:33.063]                         if (!is.null(pattern)) {
[10:18:33.063]                           computeRestarts <- base::computeRestarts
[10:18:33.063]                           grepl <- base::grepl
[10:18:33.063]                           restarts <- computeRestarts(cond)
[10:18:33.063]                           for (restart in restarts) {
[10:18:33.063]                             name <- restart$name
[10:18:33.063]                             if (is.null(name)) 
[10:18:33.063]                               next
[10:18:33.063]                             if (!grepl(pattern, name)) 
[10:18:33.063]                               next
[10:18:33.063]                             invokeRestart(restart)
[10:18:33.063]                             muffled <- TRUE
[10:18:33.063]                             break
[10:18:33.063]                           }
[10:18:33.063]                         }
[10:18:33.063]                       }
[10:18:33.063]                       invisible(muffled)
[10:18:33.063]                     }
[10:18:33.063]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.063]                   }
[10:18:33.063]                 }
[10:18:33.063]                 else {
[10:18:33.063]                   if (TRUE) {
[10:18:33.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.063]                     {
[10:18:33.063]                       inherits <- base::inherits
[10:18:33.063]                       invokeRestart <- base::invokeRestart
[10:18:33.063]                       is.null <- base::is.null
[10:18:33.063]                       muffled <- FALSE
[10:18:33.063]                       if (inherits(cond, "message")) {
[10:18:33.063]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.063]                         if (muffled) 
[10:18:33.063]                           invokeRestart("muffleMessage")
[10:18:33.063]                       }
[10:18:33.063]                       else if (inherits(cond, "warning")) {
[10:18:33.063]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.063]                         if (muffled) 
[10:18:33.063]                           invokeRestart("muffleWarning")
[10:18:33.063]                       }
[10:18:33.063]                       else if (inherits(cond, "condition")) {
[10:18:33.063]                         if (!is.null(pattern)) {
[10:18:33.063]                           computeRestarts <- base::computeRestarts
[10:18:33.063]                           grepl <- base::grepl
[10:18:33.063]                           restarts <- computeRestarts(cond)
[10:18:33.063]                           for (restart in restarts) {
[10:18:33.063]                             name <- restart$name
[10:18:33.063]                             if (is.null(name)) 
[10:18:33.063]                               next
[10:18:33.063]                             if (!grepl(pattern, name)) 
[10:18:33.063]                               next
[10:18:33.063]                             invokeRestart(restart)
[10:18:33.063]                             muffled <- TRUE
[10:18:33.063]                             break
[10:18:33.063]                           }
[10:18:33.063]                         }
[10:18:33.063]                       }
[10:18:33.063]                       invisible(muffled)
[10:18:33.063]                     }
[10:18:33.063]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.063]                   }
[10:18:33.063]                 }
[10:18:33.063]             }
[10:18:33.063]         }))
[10:18:33.063]     }, error = function(ex) {
[10:18:33.063]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.063]                 ...future.rng), started = ...future.startTime, 
[10:18:33.063]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.063]             version = "1.8"), class = "FutureResult")
[10:18:33.063]     }, finally = {
[10:18:33.063]         if (!identical(...future.workdir, getwd())) 
[10:18:33.063]             setwd(...future.workdir)
[10:18:33.063]         {
[10:18:33.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.063]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.063]             }
[10:18:33.063]             base::options(...future.oldOptions)
[10:18:33.063]             if (.Platform$OS.type == "windows") {
[10:18:33.063]                 old_names <- names(...future.oldEnvVars)
[10:18:33.063]                 envs <- base::Sys.getenv()
[10:18:33.063]                 names <- names(envs)
[10:18:33.063]                 common <- intersect(names, old_names)
[10:18:33.063]                 added <- setdiff(names, old_names)
[10:18:33.063]                 removed <- setdiff(old_names, names)
[10:18:33.063]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.063]                   envs[common]]
[10:18:33.063]                 NAMES <- toupper(changed)
[10:18:33.063]                 args <- list()
[10:18:33.063]                 for (kk in seq_along(NAMES)) {
[10:18:33.063]                   name <- changed[[kk]]
[10:18:33.063]                   NAME <- NAMES[[kk]]
[10:18:33.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.063]                     next
[10:18:33.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.063]                 }
[10:18:33.063]                 NAMES <- toupper(added)
[10:18:33.063]                 for (kk in seq_along(NAMES)) {
[10:18:33.063]                   name <- added[[kk]]
[10:18:33.063]                   NAME <- NAMES[[kk]]
[10:18:33.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.063]                     next
[10:18:33.063]                   args[[name]] <- ""
[10:18:33.063]                 }
[10:18:33.063]                 NAMES <- toupper(removed)
[10:18:33.063]                 for (kk in seq_along(NAMES)) {
[10:18:33.063]                   name <- removed[[kk]]
[10:18:33.063]                   NAME <- NAMES[[kk]]
[10:18:33.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.063]                     next
[10:18:33.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.063]                 }
[10:18:33.063]                 if (length(args) > 0) 
[10:18:33.063]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.063]             }
[10:18:33.063]             else {
[10:18:33.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.063]             }
[10:18:33.063]             {
[10:18:33.063]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.063]                   0L) {
[10:18:33.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.063]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.063]                   base::options(opts)
[10:18:33.063]                 }
[10:18:33.063]                 {
[10:18:33.063]                   {
[10:18:33.063]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.063]                     NULL
[10:18:33.063]                   }
[10:18:33.063]                   options(future.plan = NULL)
[10:18:33.063]                   if (is.na(NA_character_)) 
[10:18:33.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.063]                     .init = FALSE)
[10:18:33.063]                 }
[10:18:33.063]             }
[10:18:33.063]         }
[10:18:33.063]     })
[10:18:33.063]     if (TRUE) {
[10:18:33.063]         base::sink(type = "output", split = FALSE)
[10:18:33.063]         if (TRUE) {
[10:18:33.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.063]         }
[10:18:33.063]         else {
[10:18:33.063]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.063]         }
[10:18:33.063]         base::close(...future.stdout)
[10:18:33.063]         ...future.stdout <- NULL
[10:18:33.063]     }
[10:18:33.063]     ...future.result$conditions <- ...future.conditions
[10:18:33.063]     ...future.result$finished <- base::Sys.time()
[10:18:33.063]     ...future.result
[10:18:33.063] }
[10:18:33.117] MultisessionFuture started
[10:18:33.117] result() for ClusterFuture ...
[10:18:33.118] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.118] - Validating connection of MultisessionFuture
[10:18:33.148] - received message: FutureResult
[10:18:33.149] - Received FutureResult
[10:18:33.149] - Erased future from FutureRegistry
[10:18:33.149] result() for ClusterFuture ...
[10:18:33.149] - result already collected: FutureResult
[10:18:33.149] result() for ClusterFuture ... done
[10:18:33.149] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.149] result() for ClusterFuture ... done
[10:18:33.149] result() for ClusterFuture ...
[10:18:33.149] - result already collected: FutureResult
[10:18:33.150] result() for ClusterFuture ... done
[10:18:33.150] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:18:33.151] plan(): nbrOfWorkers() = 2
[10:18:33.151] future_by_internal() ...
[10:18:33.152] future_lapply() ...
[10:18:33.154] Number of chunks: 2
[10:18:33.154] getGlobalsAndPackagesXApply() ...
[10:18:33.154]  - future.globals: TRUE
[10:18:33.154] getGlobalsAndPackages() ...
[10:18:33.154] Searching for globals...
[10:18:33.155] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:33.155] Searching for globals ... DONE
[10:18:33.155] Resolving globals: FALSE
[10:18:33.156] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:33.156] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:33.156] - globals: [1] ‘FUN’
[10:18:33.156] 
[10:18:33.156] getGlobalsAndPackages() ... DONE
[10:18:33.156]  - globals found/used: [n=1] ‘FUN’
[10:18:33.156]  - needed namespaces: [n=0] 
[10:18:33.156] Finding globals ... DONE
[10:18:33.157]  - use_args: TRUE
[10:18:33.157]  - Getting '...' globals ...
[10:18:33.157] resolve() on list ...
[10:18:33.157]  recursive: 0
[10:18:33.157]  length: 1
[10:18:33.157]  elements: ‘...’
[10:18:33.157]  length: 0 (resolved future 1)
[10:18:33.157] resolve() on list ... DONE
[10:18:33.157]    - '...' content: [n=0] 
[10:18:33.158] List of 1
[10:18:33.158]  $ ...: list()
[10:18:33.158]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.158]  - attr(*, "where")=List of 1
[10:18:33.158]   ..$ ...:<environment: 0x55844c6ce750> 
[10:18:33.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.158]  - attr(*, "resolved")= logi TRUE
[10:18:33.158]  - attr(*, "total_size")= num NA
[10:18:33.160]  - Getting '...' globals ... DONE
[10:18:33.160] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:33.160] List of 2
[10:18:33.160]  $ ...future.FUN:function (object, ...)  
[10:18:33.160]  $ ...          : list()
[10:18:33.160]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.160]  - attr(*, "where")=List of 2
[10:18:33.160]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:33.160]   ..$ ...          :<environment: 0x55844c6ce750> 
[10:18:33.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.160]  - attr(*, "resolved")= logi FALSE
[10:18:33.160]  - attr(*, "total_size")= num 15670
[10:18:33.163] Packages to be attached in all futures: [n=0] 
[10:18:33.163] getGlobalsAndPackagesXApply() ... DONE
[10:18:33.163] Number of futures (= number of chunks): 2
[10:18:33.163] Launching 2 futures (chunks) ...
[10:18:33.163] Chunk #1 of 2 ...
[10:18:33.163]  - Finding globals in 'X' for chunk #1 ...
[10:18:33.163] getGlobalsAndPackages() ...
[10:18:33.163] Searching for globals...
[10:18:33.164] 
[10:18:33.164] Searching for globals ... DONE
[10:18:33.164] - globals: [0] <none>
[10:18:33.164] getGlobalsAndPackages() ... DONE
[10:18:33.164]    + additional globals found: [n=0] 
[10:18:33.164]    + additional namespaces needed: [n=0] 
[10:18:33.164]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:33.164]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.164]  - seeds: <none>
[10:18:33.164]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.165] getGlobalsAndPackages() ...
[10:18:33.165] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.165] Resolving globals: FALSE
[10:18:33.165] Tweak future expression to call with '...' arguments ...
[10:18:33.165] {
[10:18:33.165]     do.call(function(...) {
[10:18:33.165]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.165]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.165]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.165]             on.exit(options(oopts), add = TRUE)
[10:18:33.165]         }
[10:18:33.165]         {
[10:18:33.165]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.165]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.165]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.165]             })
[10:18:33.165]         }
[10:18:33.165]     }, args = future.call.arguments)
[10:18:33.165] }
[10:18:33.165] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.165] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.166] 
[10:18:33.166] getGlobalsAndPackages() ... DONE
[10:18:33.166] run() for ‘Future’ ...
[10:18:33.166] - state: ‘created’
[10:18:33.166] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.180] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.180]   - Field: ‘node’
[10:18:33.180]   - Field: ‘label’
[10:18:33.180]   - Field: ‘local’
[10:18:33.180]   - Field: ‘owner’
[10:18:33.181]   - Field: ‘envir’
[10:18:33.181]   - Field: ‘workers’
[10:18:33.181]   - Field: ‘packages’
[10:18:33.181]   - Field: ‘gc’
[10:18:33.181]   - Field: ‘conditions’
[10:18:33.181]   - Field: ‘persistent’
[10:18:33.181]   - Field: ‘expr’
[10:18:33.181]   - Field: ‘uuid’
[10:18:33.181]   - Field: ‘seed’
[10:18:33.181]   - Field: ‘version’
[10:18:33.181]   - Field: ‘result’
[10:18:33.181]   - Field: ‘asynchronous’
[10:18:33.182]   - Field: ‘calls’
[10:18:33.182]   - Field: ‘globals’
[10:18:33.182]   - Field: ‘stdout’
[10:18:33.182]   - Field: ‘earlySignal’
[10:18:33.182]   - Field: ‘lazy’
[10:18:33.182]   - Field: ‘state’
[10:18:33.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.182] - Launch lazy future ...
[10:18:33.182] Packages needed by the future expression (n = 0): <none>
[10:18:33.183] Packages needed by future strategies (n = 0): <none>
[10:18:33.183] {
[10:18:33.183]     {
[10:18:33.183]         {
[10:18:33.183]             ...future.startTime <- base::Sys.time()
[10:18:33.183]             {
[10:18:33.183]                 {
[10:18:33.183]                   {
[10:18:33.183]                     {
[10:18:33.183]                       base::local({
[10:18:33.183]                         has_future <- base::requireNamespace("future", 
[10:18:33.183]                           quietly = TRUE)
[10:18:33.183]                         if (has_future) {
[10:18:33.183]                           ns <- base::getNamespace("future")
[10:18:33.183]                           version <- ns[[".package"]][["version"]]
[10:18:33.183]                           if (is.null(version)) 
[10:18:33.183]                             version <- utils::packageVersion("future")
[10:18:33.183]                         }
[10:18:33.183]                         else {
[10:18:33.183]                           version <- NULL
[10:18:33.183]                         }
[10:18:33.183]                         if (!has_future || version < "1.8.0") {
[10:18:33.183]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.183]                             "", base::R.version$version.string), 
[10:18:33.183]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.183]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.183]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.183]                               "release", "version")], collapse = " "), 
[10:18:33.183]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.183]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.183]                             info)
[10:18:33.183]                           info <- base::paste(info, collapse = "; ")
[10:18:33.183]                           if (!has_future) {
[10:18:33.183]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.183]                               info)
[10:18:33.183]                           }
[10:18:33.183]                           else {
[10:18:33.183]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.183]                               info, version)
[10:18:33.183]                           }
[10:18:33.183]                           base::stop(msg)
[10:18:33.183]                         }
[10:18:33.183]                       })
[10:18:33.183]                     }
[10:18:33.183]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.183]                     base::options(mc.cores = 1L)
[10:18:33.183]                   }
[10:18:33.183]                   ...future.strategy.old <- future::plan("list")
[10:18:33.183]                   options(future.plan = NULL)
[10:18:33.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.183]                 }
[10:18:33.183]                 ...future.workdir <- getwd()
[10:18:33.183]             }
[10:18:33.183]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.183]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.183]         }
[10:18:33.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.183]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.183]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.183]             base::names(...future.oldOptions))
[10:18:33.183]     }
[10:18:33.183]     if (FALSE) {
[10:18:33.183]     }
[10:18:33.183]     else {
[10:18:33.183]         if (TRUE) {
[10:18:33.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.183]                 open = "w")
[10:18:33.183]         }
[10:18:33.183]         else {
[10:18:33.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.183]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.183]         }
[10:18:33.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.183]             base::sink(type = "output", split = FALSE)
[10:18:33.183]             base::close(...future.stdout)
[10:18:33.183]         }, add = TRUE)
[10:18:33.183]     }
[10:18:33.183]     ...future.frame <- base::sys.nframe()
[10:18:33.183]     ...future.conditions <- base::list()
[10:18:33.183]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.183]     if (FALSE) {
[10:18:33.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.183]     }
[10:18:33.183]     ...future.result <- base::tryCatch({
[10:18:33.183]         base::withCallingHandlers({
[10:18:33.183]             ...future.value <- base::withVisible(base::local({
[10:18:33.183]                 ...future.makeSendCondition <- base::local({
[10:18:33.183]                   sendCondition <- NULL
[10:18:33.183]                   function(frame = 1L) {
[10:18:33.183]                     if (is.function(sendCondition)) 
[10:18:33.183]                       return(sendCondition)
[10:18:33.183]                     ns <- getNamespace("parallel")
[10:18:33.183]                     if (exists("sendData", mode = "function", 
[10:18:33.183]                       envir = ns)) {
[10:18:33.183]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.183]                         envir = ns)
[10:18:33.183]                       envir <- sys.frame(frame)
[10:18:33.183]                       master <- NULL
[10:18:33.183]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.183]                         !identical(envir, emptyenv())) {
[10:18:33.183]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.183]                           inherits = FALSE)) {
[10:18:33.183]                           master <- get("master", mode = "list", 
[10:18:33.183]                             envir = envir, inherits = FALSE)
[10:18:33.183]                           if (inherits(master, c("SOCKnode", 
[10:18:33.183]                             "SOCK0node"))) {
[10:18:33.183]                             sendCondition <<- function(cond) {
[10:18:33.183]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.183]                                 success = TRUE)
[10:18:33.183]                               parallel_sendData(master, data)
[10:18:33.183]                             }
[10:18:33.183]                             return(sendCondition)
[10:18:33.183]                           }
[10:18:33.183]                         }
[10:18:33.183]                         frame <- frame + 1L
[10:18:33.183]                         envir <- sys.frame(frame)
[10:18:33.183]                       }
[10:18:33.183]                     }
[10:18:33.183]                     sendCondition <<- function(cond) NULL
[10:18:33.183]                   }
[10:18:33.183]                 })
[10:18:33.183]                 withCallingHandlers({
[10:18:33.183]                   {
[10:18:33.183]                     do.call(function(...) {
[10:18:33.183]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.183]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.183]                         ...future.globals.maxSize)) {
[10:18:33.183]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.183]                         on.exit(options(oopts), add = TRUE)
[10:18:33.183]                       }
[10:18:33.183]                       {
[10:18:33.183]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.183]                           FUN = function(jj) {
[10:18:33.183]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.183]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.183]                           })
[10:18:33.183]                       }
[10:18:33.183]                     }, args = future.call.arguments)
[10:18:33.183]                   }
[10:18:33.183]                 }, immediateCondition = function(cond) {
[10:18:33.183]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.183]                   sendCondition(cond)
[10:18:33.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.183]                   {
[10:18:33.183]                     inherits <- base::inherits
[10:18:33.183]                     invokeRestart <- base::invokeRestart
[10:18:33.183]                     is.null <- base::is.null
[10:18:33.183]                     muffled <- FALSE
[10:18:33.183]                     if (inherits(cond, "message")) {
[10:18:33.183]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.183]                       if (muffled) 
[10:18:33.183]                         invokeRestart("muffleMessage")
[10:18:33.183]                     }
[10:18:33.183]                     else if (inherits(cond, "warning")) {
[10:18:33.183]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.183]                       if (muffled) 
[10:18:33.183]                         invokeRestart("muffleWarning")
[10:18:33.183]                     }
[10:18:33.183]                     else if (inherits(cond, "condition")) {
[10:18:33.183]                       if (!is.null(pattern)) {
[10:18:33.183]                         computeRestarts <- base::computeRestarts
[10:18:33.183]                         grepl <- base::grepl
[10:18:33.183]                         restarts <- computeRestarts(cond)
[10:18:33.183]                         for (restart in restarts) {
[10:18:33.183]                           name <- restart$name
[10:18:33.183]                           if (is.null(name)) 
[10:18:33.183]                             next
[10:18:33.183]                           if (!grepl(pattern, name)) 
[10:18:33.183]                             next
[10:18:33.183]                           invokeRestart(restart)
[10:18:33.183]                           muffled <- TRUE
[10:18:33.183]                           break
[10:18:33.183]                         }
[10:18:33.183]                       }
[10:18:33.183]                     }
[10:18:33.183]                     invisible(muffled)
[10:18:33.183]                   }
[10:18:33.183]                   muffleCondition(cond)
[10:18:33.183]                 })
[10:18:33.183]             }))
[10:18:33.183]             future::FutureResult(value = ...future.value$value, 
[10:18:33.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.183]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.183]                     ...future.globalenv.names))
[10:18:33.183]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.183]         }, condition = base::local({
[10:18:33.183]             c <- base::c
[10:18:33.183]             inherits <- base::inherits
[10:18:33.183]             invokeRestart <- base::invokeRestart
[10:18:33.183]             length <- base::length
[10:18:33.183]             list <- base::list
[10:18:33.183]             seq.int <- base::seq.int
[10:18:33.183]             signalCondition <- base::signalCondition
[10:18:33.183]             sys.calls <- base::sys.calls
[10:18:33.183]             `[[` <- base::`[[`
[10:18:33.183]             `+` <- base::`+`
[10:18:33.183]             `<<-` <- base::`<<-`
[10:18:33.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.183]                   3L)]
[10:18:33.183]             }
[10:18:33.183]             function(cond) {
[10:18:33.183]                 is_error <- inherits(cond, "error")
[10:18:33.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.183]                   NULL)
[10:18:33.183]                 if (is_error) {
[10:18:33.183]                   sessionInformation <- function() {
[10:18:33.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.183]                       search = base::search(), system = base::Sys.info())
[10:18:33.183]                   }
[10:18:33.183]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.183]                     cond$call), session = sessionInformation(), 
[10:18:33.183]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.183]                   signalCondition(cond)
[10:18:33.183]                 }
[10:18:33.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.183]                 "immediateCondition"))) {
[10:18:33.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.183]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.183]                   if (TRUE && !signal) {
[10:18:33.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.183]                     {
[10:18:33.183]                       inherits <- base::inherits
[10:18:33.183]                       invokeRestart <- base::invokeRestart
[10:18:33.183]                       is.null <- base::is.null
[10:18:33.183]                       muffled <- FALSE
[10:18:33.183]                       if (inherits(cond, "message")) {
[10:18:33.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.183]                         if (muffled) 
[10:18:33.183]                           invokeRestart("muffleMessage")
[10:18:33.183]                       }
[10:18:33.183]                       else if (inherits(cond, "warning")) {
[10:18:33.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.183]                         if (muffled) 
[10:18:33.183]                           invokeRestart("muffleWarning")
[10:18:33.183]                       }
[10:18:33.183]                       else if (inherits(cond, "condition")) {
[10:18:33.183]                         if (!is.null(pattern)) {
[10:18:33.183]                           computeRestarts <- base::computeRestarts
[10:18:33.183]                           grepl <- base::grepl
[10:18:33.183]                           restarts <- computeRestarts(cond)
[10:18:33.183]                           for (restart in restarts) {
[10:18:33.183]                             name <- restart$name
[10:18:33.183]                             if (is.null(name)) 
[10:18:33.183]                               next
[10:18:33.183]                             if (!grepl(pattern, name)) 
[10:18:33.183]                               next
[10:18:33.183]                             invokeRestart(restart)
[10:18:33.183]                             muffled <- TRUE
[10:18:33.183]                             break
[10:18:33.183]                           }
[10:18:33.183]                         }
[10:18:33.183]                       }
[10:18:33.183]                       invisible(muffled)
[10:18:33.183]                     }
[10:18:33.183]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.183]                   }
[10:18:33.183]                 }
[10:18:33.183]                 else {
[10:18:33.183]                   if (TRUE) {
[10:18:33.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.183]                     {
[10:18:33.183]                       inherits <- base::inherits
[10:18:33.183]                       invokeRestart <- base::invokeRestart
[10:18:33.183]                       is.null <- base::is.null
[10:18:33.183]                       muffled <- FALSE
[10:18:33.183]                       if (inherits(cond, "message")) {
[10:18:33.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.183]                         if (muffled) 
[10:18:33.183]                           invokeRestart("muffleMessage")
[10:18:33.183]                       }
[10:18:33.183]                       else if (inherits(cond, "warning")) {
[10:18:33.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.183]                         if (muffled) 
[10:18:33.183]                           invokeRestart("muffleWarning")
[10:18:33.183]                       }
[10:18:33.183]                       else if (inherits(cond, "condition")) {
[10:18:33.183]                         if (!is.null(pattern)) {
[10:18:33.183]                           computeRestarts <- base::computeRestarts
[10:18:33.183]                           grepl <- base::grepl
[10:18:33.183]                           restarts <- computeRestarts(cond)
[10:18:33.183]                           for (restart in restarts) {
[10:18:33.183]                             name <- restart$name
[10:18:33.183]                             if (is.null(name)) 
[10:18:33.183]                               next
[10:18:33.183]                             if (!grepl(pattern, name)) 
[10:18:33.183]                               next
[10:18:33.183]                             invokeRestart(restart)
[10:18:33.183]                             muffled <- TRUE
[10:18:33.183]                             break
[10:18:33.183]                           }
[10:18:33.183]                         }
[10:18:33.183]                       }
[10:18:33.183]                       invisible(muffled)
[10:18:33.183]                     }
[10:18:33.183]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.183]                   }
[10:18:33.183]                 }
[10:18:33.183]             }
[10:18:33.183]         }))
[10:18:33.183]     }, error = function(ex) {
[10:18:33.183]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.183]                 ...future.rng), started = ...future.startTime, 
[10:18:33.183]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.183]             version = "1.8"), class = "FutureResult")
[10:18:33.183]     }, finally = {
[10:18:33.183]         if (!identical(...future.workdir, getwd())) 
[10:18:33.183]             setwd(...future.workdir)
[10:18:33.183]         {
[10:18:33.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.183]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.183]             }
[10:18:33.183]             base::options(...future.oldOptions)
[10:18:33.183]             if (.Platform$OS.type == "windows") {
[10:18:33.183]                 old_names <- names(...future.oldEnvVars)
[10:18:33.183]                 envs <- base::Sys.getenv()
[10:18:33.183]                 names <- names(envs)
[10:18:33.183]                 common <- intersect(names, old_names)
[10:18:33.183]                 added <- setdiff(names, old_names)
[10:18:33.183]                 removed <- setdiff(old_names, names)
[10:18:33.183]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.183]                   envs[common]]
[10:18:33.183]                 NAMES <- toupper(changed)
[10:18:33.183]                 args <- list()
[10:18:33.183]                 for (kk in seq_along(NAMES)) {
[10:18:33.183]                   name <- changed[[kk]]
[10:18:33.183]                   NAME <- NAMES[[kk]]
[10:18:33.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.183]                     next
[10:18:33.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.183]                 }
[10:18:33.183]                 NAMES <- toupper(added)
[10:18:33.183]                 for (kk in seq_along(NAMES)) {
[10:18:33.183]                   name <- added[[kk]]
[10:18:33.183]                   NAME <- NAMES[[kk]]
[10:18:33.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.183]                     next
[10:18:33.183]                   args[[name]] <- ""
[10:18:33.183]                 }
[10:18:33.183]                 NAMES <- toupper(removed)
[10:18:33.183]                 for (kk in seq_along(NAMES)) {
[10:18:33.183]                   name <- removed[[kk]]
[10:18:33.183]                   NAME <- NAMES[[kk]]
[10:18:33.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.183]                     next
[10:18:33.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.183]                 }
[10:18:33.183]                 if (length(args) > 0) 
[10:18:33.183]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.183]             }
[10:18:33.183]             else {
[10:18:33.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.183]             }
[10:18:33.183]             {
[10:18:33.183]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.183]                   0L) {
[10:18:33.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.183]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.183]                   base::options(opts)
[10:18:33.183]                 }
[10:18:33.183]                 {
[10:18:33.183]                   {
[10:18:33.183]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.183]                     NULL
[10:18:33.183]                   }
[10:18:33.183]                   options(future.plan = NULL)
[10:18:33.183]                   if (is.na(NA_character_)) 
[10:18:33.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.183]                     .init = FALSE)
[10:18:33.183]                 }
[10:18:33.183]             }
[10:18:33.183]         }
[10:18:33.183]     })
[10:18:33.183]     if (TRUE) {
[10:18:33.183]         base::sink(type = "output", split = FALSE)
[10:18:33.183]         if (TRUE) {
[10:18:33.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.183]         }
[10:18:33.183]         else {
[10:18:33.183]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.183]         }
[10:18:33.183]         base::close(...future.stdout)
[10:18:33.183]         ...future.stdout <- NULL
[10:18:33.183]     }
[10:18:33.183]     ...future.result$conditions <- ...future.conditions
[10:18:33.183]     ...future.result$finished <- base::Sys.time()
[10:18:33.183]     ...future.result
[10:18:33.183] }
[10:18:33.186] Exporting 5 global objects (1.40 KiB) to cluster node #1 ...
[10:18:33.186] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[10:18:33.187] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[10:18:33.187] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:33.187] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:33.187] Exporting ‘...future.elements_ii’ (564 bytes) to cluster node #1 ...
[10:18:33.187] Exporting ‘...future.elements_ii’ (564 bytes) to cluster node #1 ... DONE
[10:18:33.188] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:33.188] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.188] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:33.188] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.188] Exporting 5 global objects (1.40 KiB) to cluster node #1 ... DONE
[10:18:33.189] MultisessionFuture started
[10:18:33.189] - Launch lazy future ... done
[10:18:33.189] run() for ‘MultisessionFuture’ ... done
[10:18:33.189] Created future:
[10:18:33.189] MultisessionFuture:
[10:18:33.189] Label: ‘future_by-1’
[10:18:33.189] Expression:
[10:18:33.189] {
[10:18:33.189]     do.call(function(...) {
[10:18:33.189]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.189]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.189]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.189]             on.exit(options(oopts), add = TRUE)
[10:18:33.189]         }
[10:18:33.189]         {
[10:18:33.189]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.189]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.189]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.189]             })
[10:18:33.189]         }
[10:18:33.189]     }, args = future.call.arguments)
[10:18:33.189] }
[10:18:33.189] Lazy evaluation: FALSE
[10:18:33.189] Asynchronous evaluation: TRUE
[10:18:33.189] Local evaluation: TRUE
[10:18:33.189] Environment: R_GlobalEnv
[10:18:33.189] Capture standard output: TRUE
[10:18:33.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.189] Globals: 5 objects totaling 996 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 564 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.189] Packages: <none>
[10:18:33.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.189] Resolved: FALSE
[10:18:33.189] Value: <not collected>
[10:18:33.189] Conditions captured: <none>
[10:18:33.189] Early signaling: FALSE
[10:18:33.189] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.189] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.201] Chunk #1 of 2 ... DONE
[10:18:33.201] Chunk #2 of 2 ...
[10:18:33.201]  - Finding globals in 'X' for chunk #2 ...
[10:18:33.202] getGlobalsAndPackages() ...
[10:18:33.202] Searching for globals...
[10:18:33.202] 
[10:18:33.202] Searching for globals ... DONE
[10:18:33.202] - globals: [0] <none>
[10:18:33.202] getGlobalsAndPackages() ... DONE
[10:18:33.202]    + additional globals found: [n=0] 
[10:18:33.203]    + additional namespaces needed: [n=0] 
[10:18:33.203]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:33.203]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.203]  - seeds: <none>
[10:18:33.203]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.203] getGlobalsAndPackages() ...
[10:18:33.203] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.203] Resolving globals: FALSE
[10:18:33.203] Tweak future expression to call with '...' arguments ...
[10:18:33.203] {
[10:18:33.203]     do.call(function(...) {
[10:18:33.203]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.203]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.203]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.203]             on.exit(options(oopts), add = TRUE)
[10:18:33.203]         }
[10:18:33.203]         {
[10:18:33.203]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.203]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.203]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.203]             })
[10:18:33.203]         }
[10:18:33.203]     }, args = future.call.arguments)
[10:18:33.203] }
[10:18:33.204] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.204] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.204] 
[10:18:33.204] getGlobalsAndPackages() ... DONE
[10:18:33.204] run() for ‘Future’ ...
[10:18:33.205] - state: ‘created’
[10:18:33.205] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.219] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.219]   - Field: ‘node’
[10:18:33.219]   - Field: ‘label’
[10:18:33.219]   - Field: ‘local’
[10:18:33.220]   - Field: ‘owner’
[10:18:33.220]   - Field: ‘envir’
[10:18:33.220]   - Field: ‘workers’
[10:18:33.220]   - Field: ‘packages’
[10:18:33.220]   - Field: ‘gc’
[10:18:33.220]   - Field: ‘conditions’
[10:18:33.220]   - Field: ‘persistent’
[10:18:33.220]   - Field: ‘expr’
[10:18:33.220]   - Field: ‘uuid’
[10:18:33.220]   - Field: ‘seed’
[10:18:33.220]   - Field: ‘version’
[10:18:33.220]   - Field: ‘result’
[10:18:33.221]   - Field: ‘asynchronous’
[10:18:33.221]   - Field: ‘calls’
[10:18:33.221]   - Field: ‘globals’
[10:18:33.221]   - Field: ‘stdout’
[10:18:33.221]   - Field: ‘earlySignal’
[10:18:33.221]   - Field: ‘lazy’
[10:18:33.221]   - Field: ‘state’
[10:18:33.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.221] - Launch lazy future ...
[10:18:33.222] Packages needed by the future expression (n = 0): <none>
[10:18:33.222] Packages needed by future strategies (n = 0): <none>
[10:18:33.222] {
[10:18:33.222]     {
[10:18:33.222]         {
[10:18:33.222]             ...future.startTime <- base::Sys.time()
[10:18:33.222]             {
[10:18:33.222]                 {
[10:18:33.222]                   {
[10:18:33.222]                     {
[10:18:33.222]                       base::local({
[10:18:33.222]                         has_future <- base::requireNamespace("future", 
[10:18:33.222]                           quietly = TRUE)
[10:18:33.222]                         if (has_future) {
[10:18:33.222]                           ns <- base::getNamespace("future")
[10:18:33.222]                           version <- ns[[".package"]][["version"]]
[10:18:33.222]                           if (is.null(version)) 
[10:18:33.222]                             version <- utils::packageVersion("future")
[10:18:33.222]                         }
[10:18:33.222]                         else {
[10:18:33.222]                           version <- NULL
[10:18:33.222]                         }
[10:18:33.222]                         if (!has_future || version < "1.8.0") {
[10:18:33.222]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.222]                             "", base::R.version$version.string), 
[10:18:33.222]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.222]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.222]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.222]                               "release", "version")], collapse = " "), 
[10:18:33.222]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.222]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.222]                             info)
[10:18:33.222]                           info <- base::paste(info, collapse = "; ")
[10:18:33.222]                           if (!has_future) {
[10:18:33.222]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.222]                               info)
[10:18:33.222]                           }
[10:18:33.222]                           else {
[10:18:33.222]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.222]                               info, version)
[10:18:33.222]                           }
[10:18:33.222]                           base::stop(msg)
[10:18:33.222]                         }
[10:18:33.222]                       })
[10:18:33.222]                     }
[10:18:33.222]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.222]                     base::options(mc.cores = 1L)
[10:18:33.222]                   }
[10:18:33.222]                   ...future.strategy.old <- future::plan("list")
[10:18:33.222]                   options(future.plan = NULL)
[10:18:33.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.222]                 }
[10:18:33.222]                 ...future.workdir <- getwd()
[10:18:33.222]             }
[10:18:33.222]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.222]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.222]         }
[10:18:33.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.222]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.222]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.222]             base::names(...future.oldOptions))
[10:18:33.222]     }
[10:18:33.222]     if (FALSE) {
[10:18:33.222]     }
[10:18:33.222]     else {
[10:18:33.222]         if (TRUE) {
[10:18:33.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.222]                 open = "w")
[10:18:33.222]         }
[10:18:33.222]         else {
[10:18:33.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.222]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.222]         }
[10:18:33.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.222]             base::sink(type = "output", split = FALSE)
[10:18:33.222]             base::close(...future.stdout)
[10:18:33.222]         }, add = TRUE)
[10:18:33.222]     }
[10:18:33.222]     ...future.frame <- base::sys.nframe()
[10:18:33.222]     ...future.conditions <- base::list()
[10:18:33.222]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.222]     if (FALSE) {
[10:18:33.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.222]     }
[10:18:33.222]     ...future.result <- base::tryCatch({
[10:18:33.222]         base::withCallingHandlers({
[10:18:33.222]             ...future.value <- base::withVisible(base::local({
[10:18:33.222]                 ...future.makeSendCondition <- base::local({
[10:18:33.222]                   sendCondition <- NULL
[10:18:33.222]                   function(frame = 1L) {
[10:18:33.222]                     if (is.function(sendCondition)) 
[10:18:33.222]                       return(sendCondition)
[10:18:33.222]                     ns <- getNamespace("parallel")
[10:18:33.222]                     if (exists("sendData", mode = "function", 
[10:18:33.222]                       envir = ns)) {
[10:18:33.222]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.222]                         envir = ns)
[10:18:33.222]                       envir <- sys.frame(frame)
[10:18:33.222]                       master <- NULL
[10:18:33.222]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.222]                         !identical(envir, emptyenv())) {
[10:18:33.222]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.222]                           inherits = FALSE)) {
[10:18:33.222]                           master <- get("master", mode = "list", 
[10:18:33.222]                             envir = envir, inherits = FALSE)
[10:18:33.222]                           if (inherits(master, c("SOCKnode", 
[10:18:33.222]                             "SOCK0node"))) {
[10:18:33.222]                             sendCondition <<- function(cond) {
[10:18:33.222]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.222]                                 success = TRUE)
[10:18:33.222]                               parallel_sendData(master, data)
[10:18:33.222]                             }
[10:18:33.222]                             return(sendCondition)
[10:18:33.222]                           }
[10:18:33.222]                         }
[10:18:33.222]                         frame <- frame + 1L
[10:18:33.222]                         envir <- sys.frame(frame)
[10:18:33.222]                       }
[10:18:33.222]                     }
[10:18:33.222]                     sendCondition <<- function(cond) NULL
[10:18:33.222]                   }
[10:18:33.222]                 })
[10:18:33.222]                 withCallingHandlers({
[10:18:33.222]                   {
[10:18:33.222]                     do.call(function(...) {
[10:18:33.222]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.222]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.222]                         ...future.globals.maxSize)) {
[10:18:33.222]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.222]                         on.exit(options(oopts), add = TRUE)
[10:18:33.222]                       }
[10:18:33.222]                       {
[10:18:33.222]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.222]                           FUN = function(jj) {
[10:18:33.222]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.222]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.222]                           })
[10:18:33.222]                       }
[10:18:33.222]                     }, args = future.call.arguments)
[10:18:33.222]                   }
[10:18:33.222]                 }, immediateCondition = function(cond) {
[10:18:33.222]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.222]                   sendCondition(cond)
[10:18:33.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.222]                   {
[10:18:33.222]                     inherits <- base::inherits
[10:18:33.222]                     invokeRestart <- base::invokeRestart
[10:18:33.222]                     is.null <- base::is.null
[10:18:33.222]                     muffled <- FALSE
[10:18:33.222]                     if (inherits(cond, "message")) {
[10:18:33.222]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.222]                       if (muffled) 
[10:18:33.222]                         invokeRestart("muffleMessage")
[10:18:33.222]                     }
[10:18:33.222]                     else if (inherits(cond, "warning")) {
[10:18:33.222]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.222]                       if (muffled) 
[10:18:33.222]                         invokeRestart("muffleWarning")
[10:18:33.222]                     }
[10:18:33.222]                     else if (inherits(cond, "condition")) {
[10:18:33.222]                       if (!is.null(pattern)) {
[10:18:33.222]                         computeRestarts <- base::computeRestarts
[10:18:33.222]                         grepl <- base::grepl
[10:18:33.222]                         restarts <- computeRestarts(cond)
[10:18:33.222]                         for (restart in restarts) {
[10:18:33.222]                           name <- restart$name
[10:18:33.222]                           if (is.null(name)) 
[10:18:33.222]                             next
[10:18:33.222]                           if (!grepl(pattern, name)) 
[10:18:33.222]                             next
[10:18:33.222]                           invokeRestart(restart)
[10:18:33.222]                           muffled <- TRUE
[10:18:33.222]                           break
[10:18:33.222]                         }
[10:18:33.222]                       }
[10:18:33.222]                     }
[10:18:33.222]                     invisible(muffled)
[10:18:33.222]                   }
[10:18:33.222]                   muffleCondition(cond)
[10:18:33.222]                 })
[10:18:33.222]             }))
[10:18:33.222]             future::FutureResult(value = ...future.value$value, 
[10:18:33.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.222]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.222]                     ...future.globalenv.names))
[10:18:33.222]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.222]         }, condition = base::local({
[10:18:33.222]             c <- base::c
[10:18:33.222]             inherits <- base::inherits
[10:18:33.222]             invokeRestart <- base::invokeRestart
[10:18:33.222]             length <- base::length
[10:18:33.222]             list <- base::list
[10:18:33.222]             seq.int <- base::seq.int
[10:18:33.222]             signalCondition <- base::signalCondition
[10:18:33.222]             sys.calls <- base::sys.calls
[10:18:33.222]             `[[` <- base::`[[`
[10:18:33.222]             `+` <- base::`+`
[10:18:33.222]             `<<-` <- base::`<<-`
[10:18:33.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.222]                   3L)]
[10:18:33.222]             }
[10:18:33.222]             function(cond) {
[10:18:33.222]                 is_error <- inherits(cond, "error")
[10:18:33.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.222]                   NULL)
[10:18:33.222]                 if (is_error) {
[10:18:33.222]                   sessionInformation <- function() {
[10:18:33.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.222]                       search = base::search(), system = base::Sys.info())
[10:18:33.222]                   }
[10:18:33.222]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.222]                     cond$call), session = sessionInformation(), 
[10:18:33.222]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.222]                   signalCondition(cond)
[10:18:33.222]                 }
[10:18:33.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.222]                 "immediateCondition"))) {
[10:18:33.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.222]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.222]                   if (TRUE && !signal) {
[10:18:33.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.222]                     {
[10:18:33.222]                       inherits <- base::inherits
[10:18:33.222]                       invokeRestart <- base::invokeRestart
[10:18:33.222]                       is.null <- base::is.null
[10:18:33.222]                       muffled <- FALSE
[10:18:33.222]                       if (inherits(cond, "message")) {
[10:18:33.222]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.222]                         if (muffled) 
[10:18:33.222]                           invokeRestart("muffleMessage")
[10:18:33.222]                       }
[10:18:33.222]                       else if (inherits(cond, "warning")) {
[10:18:33.222]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.222]                         if (muffled) 
[10:18:33.222]                           invokeRestart("muffleWarning")
[10:18:33.222]                       }
[10:18:33.222]                       else if (inherits(cond, "condition")) {
[10:18:33.222]                         if (!is.null(pattern)) {
[10:18:33.222]                           computeRestarts <- base::computeRestarts
[10:18:33.222]                           grepl <- base::grepl
[10:18:33.222]                           restarts <- computeRestarts(cond)
[10:18:33.222]                           for (restart in restarts) {
[10:18:33.222]                             name <- restart$name
[10:18:33.222]                             if (is.null(name)) 
[10:18:33.222]                               next
[10:18:33.222]                             if (!grepl(pattern, name)) 
[10:18:33.222]                               next
[10:18:33.222]                             invokeRestart(restart)
[10:18:33.222]                             muffled <- TRUE
[10:18:33.222]                             break
[10:18:33.222]                           }
[10:18:33.222]                         }
[10:18:33.222]                       }
[10:18:33.222]                       invisible(muffled)
[10:18:33.222]                     }
[10:18:33.222]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.222]                   }
[10:18:33.222]                 }
[10:18:33.222]                 else {
[10:18:33.222]                   if (TRUE) {
[10:18:33.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.222]                     {
[10:18:33.222]                       inherits <- base::inherits
[10:18:33.222]                       invokeRestart <- base::invokeRestart
[10:18:33.222]                       is.null <- base::is.null
[10:18:33.222]                       muffled <- FALSE
[10:18:33.222]                       if (inherits(cond, "message")) {
[10:18:33.222]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.222]                         if (muffled) 
[10:18:33.222]                           invokeRestart("muffleMessage")
[10:18:33.222]                       }
[10:18:33.222]                       else if (inherits(cond, "warning")) {
[10:18:33.222]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.222]                         if (muffled) 
[10:18:33.222]                           invokeRestart("muffleWarning")
[10:18:33.222]                       }
[10:18:33.222]                       else if (inherits(cond, "condition")) {
[10:18:33.222]                         if (!is.null(pattern)) {
[10:18:33.222]                           computeRestarts <- base::computeRestarts
[10:18:33.222]                           grepl <- base::grepl
[10:18:33.222]                           restarts <- computeRestarts(cond)
[10:18:33.222]                           for (restart in restarts) {
[10:18:33.222]                             name <- restart$name
[10:18:33.222]                             if (is.null(name)) 
[10:18:33.222]                               next
[10:18:33.222]                             if (!grepl(pattern, name)) 
[10:18:33.222]                               next
[10:18:33.222]                             invokeRestart(restart)
[10:18:33.222]                             muffled <- TRUE
[10:18:33.222]                             break
[10:18:33.222]                           }
[10:18:33.222]                         }
[10:18:33.222]                       }
[10:18:33.222]                       invisible(muffled)
[10:18:33.222]                     }
[10:18:33.222]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.222]                   }
[10:18:33.222]                 }
[10:18:33.222]             }
[10:18:33.222]         }))
[10:18:33.222]     }, error = function(ex) {
[10:18:33.222]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.222]                 ...future.rng), started = ...future.startTime, 
[10:18:33.222]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.222]             version = "1.8"), class = "FutureResult")
[10:18:33.222]     }, finally = {
[10:18:33.222]         if (!identical(...future.workdir, getwd())) 
[10:18:33.222]             setwd(...future.workdir)
[10:18:33.222]         {
[10:18:33.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.222]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.222]             }
[10:18:33.222]             base::options(...future.oldOptions)
[10:18:33.222]             if (.Platform$OS.type == "windows") {
[10:18:33.222]                 old_names <- names(...future.oldEnvVars)
[10:18:33.222]                 envs <- base::Sys.getenv()
[10:18:33.222]                 names <- names(envs)
[10:18:33.222]                 common <- intersect(names, old_names)
[10:18:33.222]                 added <- setdiff(names, old_names)
[10:18:33.222]                 removed <- setdiff(old_names, names)
[10:18:33.222]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.222]                   envs[common]]
[10:18:33.222]                 NAMES <- toupper(changed)
[10:18:33.222]                 args <- list()
[10:18:33.222]                 for (kk in seq_along(NAMES)) {
[10:18:33.222]                   name <- changed[[kk]]
[10:18:33.222]                   NAME <- NAMES[[kk]]
[10:18:33.222]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.222]                     next
[10:18:33.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.222]                 }
[10:18:33.222]                 NAMES <- toupper(added)
[10:18:33.222]                 for (kk in seq_along(NAMES)) {
[10:18:33.222]                   name <- added[[kk]]
[10:18:33.222]                   NAME <- NAMES[[kk]]
[10:18:33.222]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.222]                     next
[10:18:33.222]                   args[[name]] <- ""
[10:18:33.222]                 }
[10:18:33.222]                 NAMES <- toupper(removed)
[10:18:33.222]                 for (kk in seq_along(NAMES)) {
[10:18:33.222]                   name <- removed[[kk]]
[10:18:33.222]                   NAME <- NAMES[[kk]]
[10:18:33.222]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.222]                     next
[10:18:33.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.222]                 }
[10:18:33.222]                 if (length(args) > 0) 
[10:18:33.222]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.222]             }
[10:18:33.222]             else {
[10:18:33.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.222]             }
[10:18:33.222]             {
[10:18:33.222]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.222]                   0L) {
[10:18:33.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.222]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.222]                   base::options(opts)
[10:18:33.222]                 }
[10:18:33.222]                 {
[10:18:33.222]                   {
[10:18:33.222]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.222]                     NULL
[10:18:33.222]                   }
[10:18:33.222]                   options(future.plan = NULL)
[10:18:33.222]                   if (is.na(NA_character_)) 
[10:18:33.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.222]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.222]                     .init = FALSE)
[10:18:33.222]                 }
[10:18:33.222]             }
[10:18:33.222]         }
[10:18:33.222]     })
[10:18:33.222]     if (TRUE) {
[10:18:33.222]         base::sink(type = "output", split = FALSE)
[10:18:33.222]         if (TRUE) {
[10:18:33.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.222]         }
[10:18:33.222]         else {
[10:18:33.222]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.222]         }
[10:18:33.222]         base::close(...future.stdout)
[10:18:33.222]         ...future.stdout <- NULL
[10:18:33.222]     }
[10:18:33.222]     ...future.result$conditions <- ...future.conditions
[10:18:33.222]     ...future.result$finished <- base::Sys.time()
[10:18:33.222]     ...future.result
[10:18:33.222] }
[10:18:33.276] Exporting 5 global objects (1.86 KiB) to cluster node #2 ...
[10:18:33.276] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[10:18:33.277] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[10:18:33.277] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:33.277] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:33.277] Exporting ‘...future.elements_ii’ (1.02 KiB) to cluster node #2 ...
[10:18:33.278] Exporting ‘...future.elements_ii’ (1.02 KiB) to cluster node #2 ... DONE
[10:18:33.278] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:33.278] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.278] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:33.279] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.279] Exporting 5 global objects (1.86 KiB) to cluster node #2 ... DONE
[10:18:33.280] MultisessionFuture started
[10:18:33.280] - Launch lazy future ... done
[10:18:33.280] run() for ‘MultisessionFuture’ ... done
[10:18:33.280] Created future:
[10:18:33.280] MultisessionFuture:
[10:18:33.280] Label: ‘future_by-2’
[10:18:33.280] Expression:
[10:18:33.280] {
[10:18:33.280]     do.call(function(...) {
[10:18:33.280]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.280]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.280]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.280]             on.exit(options(oopts), add = TRUE)
[10:18:33.280]         }
[10:18:33.280]         {
[10:18:33.280]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.280]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.280]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.280]             })
[10:18:33.280]         }
[10:18:33.280]     }, args = future.call.arguments)
[10:18:33.280] }
[10:18:33.280] Lazy evaluation: FALSE
[10:18:33.280] Asynchronous evaluation: TRUE
[10:18:33.280] Local evaluation: TRUE
[10:18:33.280] Environment: R_GlobalEnv
[10:18:33.280] Capture standard output: TRUE
[10:18:33.280] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.280] Globals: 5 objects totaling 1.44 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.02 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.280] Packages: <none>
[10:18:33.280] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.280] Resolved: FALSE
[10:18:33.280] Value: <not collected>
[10:18:33.280] Conditions captured: <none>
[10:18:33.280] Early signaling: FALSE
[10:18:33.280] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.280] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.292] Chunk #2 of 2 ... DONE
[10:18:33.292] Launching 2 futures (chunks) ... DONE
[10:18:33.292] Resolving 2 futures (chunks) ...
[10:18:33.292] resolve() on list ...
[10:18:33.292]  recursive: 0
[10:18:33.292]  length: 2
[10:18:33.292] 
[10:18:33.293] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.293] - Validating connection of MultisessionFuture
[10:18:33.293] - received message: FutureResult
[10:18:33.293] - Received FutureResult
[10:18:33.293] - Erased future from FutureRegistry
[10:18:33.293] result() for ClusterFuture ...
[10:18:33.293] - result already collected: FutureResult
[10:18:33.293] result() for ClusterFuture ... done
[10:18:33.294] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.294] Future #1
[10:18:33.294] result() for ClusterFuture ...
[10:18:33.294] - result already collected: FutureResult
[10:18:33.294] result() for ClusterFuture ... done
[10:18:33.294] result() for ClusterFuture ...
[10:18:33.294] - result already collected: FutureResult
[10:18:33.294] result() for ClusterFuture ... done
[10:18:33.294] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:33.294] - nx: 2
[10:18:33.294] - relay: TRUE
[10:18:33.294] - stdout: TRUE
[10:18:33.295] - signal: TRUE
[10:18:33.295] - resignal: FALSE
[10:18:33.295] - force: TRUE
[10:18:33.295] - relayed: [n=2] FALSE, FALSE
[10:18:33.295] - queued futures: [n=2] FALSE, FALSE
[10:18:33.295]  - until=1
[10:18:33.295]  - relaying element #1
[10:18:33.295] result() for ClusterFuture ...
[10:18:33.295] - result already collected: FutureResult
[10:18:33.295] result() for ClusterFuture ... done
[10:18:33.295] result() for ClusterFuture ...
[10:18:33.295] - result already collected: FutureResult
[10:18:33.295] result() for ClusterFuture ... done
[10:18:33.296] result() for ClusterFuture ...
[10:18:33.296] - result already collected: FutureResult
[10:18:33.296] result() for ClusterFuture ... done
[10:18:33.296] result() for ClusterFuture ...
[10:18:33.296] - result already collected: FutureResult
[10:18:33.296] result() for ClusterFuture ... done
[10:18:33.296] - relayed: [n=2] TRUE, FALSE
[10:18:33.296] - queued futures: [n=2] TRUE, FALSE
[10:18:33.296] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:33.296]  length: 1 (resolved future 1)
[10:18:33.360] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.360] - Validating connection of MultisessionFuture
[10:18:33.361] - received message: FutureResult
[10:18:33.361] - Received FutureResult
[10:18:33.361] - Erased future from FutureRegistry
[10:18:33.361] result() for ClusterFuture ...
[10:18:33.361] - result already collected: FutureResult
[10:18:33.361] result() for ClusterFuture ... done
[10:18:33.361] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.361] Future #2
[10:18:33.361] result() for ClusterFuture ...
[10:18:33.362] - result already collected: FutureResult
[10:18:33.362] result() for ClusterFuture ... done
[10:18:33.362] result() for ClusterFuture ...
[10:18:33.362] - result already collected: FutureResult
[10:18:33.362] result() for ClusterFuture ... done
[10:18:33.362] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:33.362] - nx: 2
[10:18:33.362] - relay: TRUE
[10:18:33.362] - stdout: TRUE
[10:18:33.362] - signal: TRUE
[10:18:33.362] - resignal: FALSE
[10:18:33.362] - force: TRUE
[10:18:33.363] - relayed: [n=2] TRUE, FALSE
[10:18:33.363] - queued futures: [n=2] TRUE, FALSE
[10:18:33.363]  - until=2
[10:18:33.363]  - relaying element #2
[10:18:33.363] result() for ClusterFuture ...
[10:18:33.363] - result already collected: FutureResult
[10:18:33.363] result() for ClusterFuture ... done
[10:18:33.363] result() for ClusterFuture ...
[10:18:33.363] - result already collected: FutureResult
[10:18:33.363] result() for ClusterFuture ... done
[10:18:33.363] result() for ClusterFuture ...
[10:18:33.363] - result already collected: FutureResult
[10:18:33.364] result() for ClusterFuture ... done
[10:18:33.364] result() for ClusterFuture ...
[10:18:33.364] - result already collected: FutureResult
[10:18:33.364] result() for ClusterFuture ... done
[10:18:33.364] - relayed: [n=2] TRUE, TRUE
[10:18:33.364] - queued futures: [n=2] TRUE, TRUE
[10:18:33.364] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:33.364]  length: 0 (resolved future 2)
[10:18:33.364] Relaying remaining futures
[10:18:33.364] signalConditionsASAP(NULL, pos=0) ...
[10:18:33.364] - nx: 2
[10:18:33.364] - relay: TRUE
[10:18:33.364] - stdout: TRUE
[10:18:33.365] - signal: TRUE
[10:18:33.365] - resignal: FALSE
[10:18:33.365] - force: TRUE
[10:18:33.365] - relayed: [n=2] TRUE, TRUE
[10:18:33.365] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:33.365] - relayed: [n=2] TRUE, TRUE
[10:18:33.365] - queued futures: [n=2] TRUE, TRUE
[10:18:33.365] signalConditionsASAP(NULL, pos=0) ... done
[10:18:33.365] resolve() on list ... DONE
[10:18:33.365] result() for ClusterFuture ...
[10:18:33.365] - result already collected: FutureResult
[10:18:33.365] result() for ClusterFuture ... done
[10:18:33.366] result() for ClusterFuture ...
[10:18:33.366] - result already collected: FutureResult
[10:18:33.366] result() for ClusterFuture ... done
[10:18:33.366] result() for ClusterFuture ...
[10:18:33.366] - result already collected: FutureResult
[10:18:33.366] result() for ClusterFuture ... done
[10:18:33.366] result() for ClusterFuture ...
[10:18:33.366] - result already collected: FutureResult
[10:18:33.366] result() for ClusterFuture ... done
[10:18:33.366]  - Number of value chunks collected: 2
[10:18:33.366] Resolving 2 futures (chunks) ... DONE
[10:18:33.366] Reducing values from 2 chunks ...
[10:18:33.367]  - Number of values collected after concatenation: 3
[10:18:33.367]  - Number of values expected: 3
[10:18:33.367] Reducing values from 2 chunks ... DONE
[10:18:33.367] future_lapply() ... DONE
[10:18:33.367] future_by_internal() ... DONE
[10:18:33.367] future_by_internal() ...
[10:18:33.368] future_lapply() ...
[10:18:33.370] Number of chunks: 2
[10:18:33.370] getGlobalsAndPackagesXApply() ...
[10:18:33.370]  - future.globals: TRUE
[10:18:33.370] getGlobalsAndPackages() ...
[10:18:33.370] Searching for globals...
[10:18:33.371] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:33.371] Searching for globals ... DONE
[10:18:33.371] Resolving globals: FALSE
[10:18:33.372] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:33.372] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:33.372] - globals: [1] ‘FUN’
[10:18:33.372] 
[10:18:33.372] getGlobalsAndPackages() ... DONE
[10:18:33.372]  - globals found/used: [n=1] ‘FUN’
[10:18:33.373]  - needed namespaces: [n=0] 
[10:18:33.373] Finding globals ... DONE
[10:18:33.373]  - use_args: TRUE
[10:18:33.373]  - Getting '...' globals ...
[10:18:33.373] resolve() on list ...
[10:18:33.373]  recursive: 0
[10:18:33.373]  length: 1
[10:18:33.373]  elements: ‘...’
[10:18:33.374]  length: 0 (resolved future 1)
[10:18:33.374] resolve() on list ... DONE
[10:18:33.374]    - '...' content: [n=1] ‘digits’
[10:18:33.374] List of 1
[10:18:33.374]  $ ...:List of 1
[10:18:33.374]   ..$ digits: int 2
[10:18:33.374]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.374]  - attr(*, "where")=List of 1
[10:18:33.374]   ..$ ...:<environment: 0x55844a7e7e30> 
[10:18:33.374]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.374]  - attr(*, "resolved")= logi TRUE
[10:18:33.374]  - attr(*, "total_size")= num NA
[10:18:33.377]  - Getting '...' globals ... DONE
[10:18:33.377] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:33.377] List of 2
[10:18:33.377]  $ ...future.FUN:function (object, ...)  
[10:18:33.377]  $ ...          :List of 1
[10:18:33.377]   ..$ digits: int 2
[10:18:33.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.377]  - attr(*, "where")=List of 2
[10:18:33.377]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:33.377]   ..$ ...          :<environment: 0x55844a7e7e30> 
[10:18:33.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.377]  - attr(*, "resolved")= logi FALSE
[10:18:33.377]  - attr(*, "total_size")= num 13284
[10:18:33.380] Packages to be attached in all futures: [n=0] 
[10:18:33.380] getGlobalsAndPackagesXApply() ... DONE
[10:18:33.380] Number of futures (= number of chunks): 2
[10:18:33.381] Launching 2 futures (chunks) ...
[10:18:33.381] Chunk #1 of 2 ...
[10:18:33.381]  - Finding globals in 'X' for chunk #1 ...
[10:18:33.381] getGlobalsAndPackages() ...
[10:18:33.381] Searching for globals...
[10:18:33.381] 
[10:18:33.381] Searching for globals ... DONE
[10:18:33.381] - globals: [0] <none>
[10:18:33.381] getGlobalsAndPackages() ... DONE
[10:18:33.382]    + additional globals found: [n=0] 
[10:18:33.382]    + additional namespaces needed: [n=0] 
[10:18:33.382]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:33.382]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.382]  - seeds: <none>
[10:18:33.382]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.382] getGlobalsAndPackages() ...
[10:18:33.382] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.382] Resolving globals: FALSE
[10:18:33.382] Tweak future expression to call with '...' arguments ...
[10:18:33.383] {
[10:18:33.383]     do.call(function(...) {
[10:18:33.383]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.383]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.383]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.383]             on.exit(options(oopts), add = TRUE)
[10:18:33.383]         }
[10:18:33.383]         {
[10:18:33.383]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.383]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.383]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.383]             })
[10:18:33.383]         }
[10:18:33.383]     }, args = future.call.arguments)
[10:18:33.383] }
[10:18:33.383] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.383] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.383] 
[10:18:33.383] getGlobalsAndPackages() ... DONE
[10:18:33.384] run() for ‘Future’ ...
[10:18:33.384] - state: ‘created’
[10:18:33.386] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.400]   - Field: ‘node’
[10:18:33.400]   - Field: ‘label’
[10:18:33.401]   - Field: ‘local’
[10:18:33.401]   - Field: ‘owner’
[10:18:33.401]   - Field: ‘envir’
[10:18:33.401]   - Field: ‘workers’
[10:18:33.401]   - Field: ‘packages’
[10:18:33.401]   - Field: ‘gc’
[10:18:33.401]   - Field: ‘conditions’
[10:18:33.401]   - Field: ‘persistent’
[10:18:33.401]   - Field: ‘expr’
[10:18:33.401]   - Field: ‘uuid’
[10:18:33.401]   - Field: ‘seed’
[10:18:33.402]   - Field: ‘version’
[10:18:33.402]   - Field: ‘result’
[10:18:33.402]   - Field: ‘asynchronous’
[10:18:33.402]   - Field: ‘calls’
[10:18:33.402]   - Field: ‘globals’
[10:18:33.402]   - Field: ‘stdout’
[10:18:33.402]   - Field: ‘earlySignal’
[10:18:33.402]   - Field: ‘lazy’
[10:18:33.402]   - Field: ‘state’
[10:18:33.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.402] - Launch lazy future ...
[10:18:33.403] Packages needed by the future expression (n = 0): <none>
[10:18:33.403] Packages needed by future strategies (n = 0): <none>
[10:18:33.403] {
[10:18:33.403]     {
[10:18:33.403]         {
[10:18:33.403]             ...future.startTime <- base::Sys.time()
[10:18:33.403]             {
[10:18:33.403]                 {
[10:18:33.403]                   {
[10:18:33.403]                     {
[10:18:33.403]                       base::local({
[10:18:33.403]                         has_future <- base::requireNamespace("future", 
[10:18:33.403]                           quietly = TRUE)
[10:18:33.403]                         if (has_future) {
[10:18:33.403]                           ns <- base::getNamespace("future")
[10:18:33.403]                           version <- ns[[".package"]][["version"]]
[10:18:33.403]                           if (is.null(version)) 
[10:18:33.403]                             version <- utils::packageVersion("future")
[10:18:33.403]                         }
[10:18:33.403]                         else {
[10:18:33.403]                           version <- NULL
[10:18:33.403]                         }
[10:18:33.403]                         if (!has_future || version < "1.8.0") {
[10:18:33.403]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.403]                             "", base::R.version$version.string), 
[10:18:33.403]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.403]                               "release", "version")], collapse = " "), 
[10:18:33.403]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.403]                             info)
[10:18:33.403]                           info <- base::paste(info, collapse = "; ")
[10:18:33.403]                           if (!has_future) {
[10:18:33.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.403]                               info)
[10:18:33.403]                           }
[10:18:33.403]                           else {
[10:18:33.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.403]                               info, version)
[10:18:33.403]                           }
[10:18:33.403]                           base::stop(msg)
[10:18:33.403]                         }
[10:18:33.403]                       })
[10:18:33.403]                     }
[10:18:33.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.403]                     base::options(mc.cores = 1L)
[10:18:33.403]                   }
[10:18:33.403]                   ...future.strategy.old <- future::plan("list")
[10:18:33.403]                   options(future.plan = NULL)
[10:18:33.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.403]                 }
[10:18:33.403]                 ...future.workdir <- getwd()
[10:18:33.403]             }
[10:18:33.403]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.403]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.403]         }
[10:18:33.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.403]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.403]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.403]             base::names(...future.oldOptions))
[10:18:33.403]     }
[10:18:33.403]     if (FALSE) {
[10:18:33.403]     }
[10:18:33.403]     else {
[10:18:33.403]         if (TRUE) {
[10:18:33.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.403]                 open = "w")
[10:18:33.403]         }
[10:18:33.403]         else {
[10:18:33.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.403]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.403]         }
[10:18:33.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.403]             base::sink(type = "output", split = FALSE)
[10:18:33.403]             base::close(...future.stdout)
[10:18:33.403]         }, add = TRUE)
[10:18:33.403]     }
[10:18:33.403]     ...future.frame <- base::sys.nframe()
[10:18:33.403]     ...future.conditions <- base::list()
[10:18:33.403]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.403]     if (FALSE) {
[10:18:33.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.403]     }
[10:18:33.403]     ...future.result <- base::tryCatch({
[10:18:33.403]         base::withCallingHandlers({
[10:18:33.403]             ...future.value <- base::withVisible(base::local({
[10:18:33.403]                 ...future.makeSendCondition <- base::local({
[10:18:33.403]                   sendCondition <- NULL
[10:18:33.403]                   function(frame = 1L) {
[10:18:33.403]                     if (is.function(sendCondition)) 
[10:18:33.403]                       return(sendCondition)
[10:18:33.403]                     ns <- getNamespace("parallel")
[10:18:33.403]                     if (exists("sendData", mode = "function", 
[10:18:33.403]                       envir = ns)) {
[10:18:33.403]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.403]                         envir = ns)
[10:18:33.403]                       envir <- sys.frame(frame)
[10:18:33.403]                       master <- NULL
[10:18:33.403]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.403]                         !identical(envir, emptyenv())) {
[10:18:33.403]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.403]                           inherits = FALSE)) {
[10:18:33.403]                           master <- get("master", mode = "list", 
[10:18:33.403]                             envir = envir, inherits = FALSE)
[10:18:33.403]                           if (inherits(master, c("SOCKnode", 
[10:18:33.403]                             "SOCK0node"))) {
[10:18:33.403]                             sendCondition <<- function(cond) {
[10:18:33.403]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.403]                                 success = TRUE)
[10:18:33.403]                               parallel_sendData(master, data)
[10:18:33.403]                             }
[10:18:33.403]                             return(sendCondition)
[10:18:33.403]                           }
[10:18:33.403]                         }
[10:18:33.403]                         frame <- frame + 1L
[10:18:33.403]                         envir <- sys.frame(frame)
[10:18:33.403]                       }
[10:18:33.403]                     }
[10:18:33.403]                     sendCondition <<- function(cond) NULL
[10:18:33.403]                   }
[10:18:33.403]                 })
[10:18:33.403]                 withCallingHandlers({
[10:18:33.403]                   {
[10:18:33.403]                     do.call(function(...) {
[10:18:33.403]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.403]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.403]                         ...future.globals.maxSize)) {
[10:18:33.403]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.403]                         on.exit(options(oopts), add = TRUE)
[10:18:33.403]                       }
[10:18:33.403]                       {
[10:18:33.403]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.403]                           FUN = function(jj) {
[10:18:33.403]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.403]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.403]                           })
[10:18:33.403]                       }
[10:18:33.403]                     }, args = future.call.arguments)
[10:18:33.403]                   }
[10:18:33.403]                 }, immediateCondition = function(cond) {
[10:18:33.403]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.403]                   sendCondition(cond)
[10:18:33.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.403]                   {
[10:18:33.403]                     inherits <- base::inherits
[10:18:33.403]                     invokeRestart <- base::invokeRestart
[10:18:33.403]                     is.null <- base::is.null
[10:18:33.403]                     muffled <- FALSE
[10:18:33.403]                     if (inherits(cond, "message")) {
[10:18:33.403]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.403]                       if (muffled) 
[10:18:33.403]                         invokeRestart("muffleMessage")
[10:18:33.403]                     }
[10:18:33.403]                     else if (inherits(cond, "warning")) {
[10:18:33.403]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.403]                       if (muffled) 
[10:18:33.403]                         invokeRestart("muffleWarning")
[10:18:33.403]                     }
[10:18:33.403]                     else if (inherits(cond, "condition")) {
[10:18:33.403]                       if (!is.null(pattern)) {
[10:18:33.403]                         computeRestarts <- base::computeRestarts
[10:18:33.403]                         grepl <- base::grepl
[10:18:33.403]                         restarts <- computeRestarts(cond)
[10:18:33.403]                         for (restart in restarts) {
[10:18:33.403]                           name <- restart$name
[10:18:33.403]                           if (is.null(name)) 
[10:18:33.403]                             next
[10:18:33.403]                           if (!grepl(pattern, name)) 
[10:18:33.403]                             next
[10:18:33.403]                           invokeRestart(restart)
[10:18:33.403]                           muffled <- TRUE
[10:18:33.403]                           break
[10:18:33.403]                         }
[10:18:33.403]                       }
[10:18:33.403]                     }
[10:18:33.403]                     invisible(muffled)
[10:18:33.403]                   }
[10:18:33.403]                   muffleCondition(cond)
[10:18:33.403]                 })
[10:18:33.403]             }))
[10:18:33.403]             future::FutureResult(value = ...future.value$value, 
[10:18:33.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.403]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.403]                     ...future.globalenv.names))
[10:18:33.403]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.403]         }, condition = base::local({
[10:18:33.403]             c <- base::c
[10:18:33.403]             inherits <- base::inherits
[10:18:33.403]             invokeRestart <- base::invokeRestart
[10:18:33.403]             length <- base::length
[10:18:33.403]             list <- base::list
[10:18:33.403]             seq.int <- base::seq.int
[10:18:33.403]             signalCondition <- base::signalCondition
[10:18:33.403]             sys.calls <- base::sys.calls
[10:18:33.403]             `[[` <- base::`[[`
[10:18:33.403]             `+` <- base::`+`
[10:18:33.403]             `<<-` <- base::`<<-`
[10:18:33.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.403]                   3L)]
[10:18:33.403]             }
[10:18:33.403]             function(cond) {
[10:18:33.403]                 is_error <- inherits(cond, "error")
[10:18:33.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.403]                   NULL)
[10:18:33.403]                 if (is_error) {
[10:18:33.403]                   sessionInformation <- function() {
[10:18:33.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.403]                       search = base::search(), system = base::Sys.info())
[10:18:33.403]                   }
[10:18:33.403]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.403]                     cond$call), session = sessionInformation(), 
[10:18:33.403]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.403]                   signalCondition(cond)
[10:18:33.403]                 }
[10:18:33.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.403]                 "immediateCondition"))) {
[10:18:33.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.403]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.403]                   if (TRUE && !signal) {
[10:18:33.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.403]                     {
[10:18:33.403]                       inherits <- base::inherits
[10:18:33.403]                       invokeRestart <- base::invokeRestart
[10:18:33.403]                       is.null <- base::is.null
[10:18:33.403]                       muffled <- FALSE
[10:18:33.403]                       if (inherits(cond, "message")) {
[10:18:33.403]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.403]                         if (muffled) 
[10:18:33.403]                           invokeRestart("muffleMessage")
[10:18:33.403]                       }
[10:18:33.403]                       else if (inherits(cond, "warning")) {
[10:18:33.403]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.403]                         if (muffled) 
[10:18:33.403]                           invokeRestart("muffleWarning")
[10:18:33.403]                       }
[10:18:33.403]                       else if (inherits(cond, "condition")) {
[10:18:33.403]                         if (!is.null(pattern)) {
[10:18:33.403]                           computeRestarts <- base::computeRestarts
[10:18:33.403]                           grepl <- base::grepl
[10:18:33.403]                           restarts <- computeRestarts(cond)
[10:18:33.403]                           for (restart in restarts) {
[10:18:33.403]                             name <- restart$name
[10:18:33.403]                             if (is.null(name)) 
[10:18:33.403]                               next
[10:18:33.403]                             if (!grepl(pattern, name)) 
[10:18:33.403]                               next
[10:18:33.403]                             invokeRestart(restart)
[10:18:33.403]                             muffled <- TRUE
[10:18:33.403]                             break
[10:18:33.403]                           }
[10:18:33.403]                         }
[10:18:33.403]                       }
[10:18:33.403]                       invisible(muffled)
[10:18:33.403]                     }
[10:18:33.403]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.403]                   }
[10:18:33.403]                 }
[10:18:33.403]                 else {
[10:18:33.403]                   if (TRUE) {
[10:18:33.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.403]                     {
[10:18:33.403]                       inherits <- base::inherits
[10:18:33.403]                       invokeRestart <- base::invokeRestart
[10:18:33.403]                       is.null <- base::is.null
[10:18:33.403]                       muffled <- FALSE
[10:18:33.403]                       if (inherits(cond, "message")) {
[10:18:33.403]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.403]                         if (muffled) 
[10:18:33.403]                           invokeRestart("muffleMessage")
[10:18:33.403]                       }
[10:18:33.403]                       else if (inherits(cond, "warning")) {
[10:18:33.403]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.403]                         if (muffled) 
[10:18:33.403]                           invokeRestart("muffleWarning")
[10:18:33.403]                       }
[10:18:33.403]                       else if (inherits(cond, "condition")) {
[10:18:33.403]                         if (!is.null(pattern)) {
[10:18:33.403]                           computeRestarts <- base::computeRestarts
[10:18:33.403]                           grepl <- base::grepl
[10:18:33.403]                           restarts <- computeRestarts(cond)
[10:18:33.403]                           for (restart in restarts) {
[10:18:33.403]                             name <- restart$name
[10:18:33.403]                             if (is.null(name)) 
[10:18:33.403]                               next
[10:18:33.403]                             if (!grepl(pattern, name)) 
[10:18:33.403]                               next
[10:18:33.403]                             invokeRestart(restart)
[10:18:33.403]                             muffled <- TRUE
[10:18:33.403]                             break
[10:18:33.403]                           }
[10:18:33.403]                         }
[10:18:33.403]                       }
[10:18:33.403]                       invisible(muffled)
[10:18:33.403]                     }
[10:18:33.403]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.403]                   }
[10:18:33.403]                 }
[10:18:33.403]             }
[10:18:33.403]         }))
[10:18:33.403]     }, error = function(ex) {
[10:18:33.403]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.403]                 ...future.rng), started = ...future.startTime, 
[10:18:33.403]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.403]             version = "1.8"), class = "FutureResult")
[10:18:33.403]     }, finally = {
[10:18:33.403]         if (!identical(...future.workdir, getwd())) 
[10:18:33.403]             setwd(...future.workdir)
[10:18:33.403]         {
[10:18:33.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.403]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.403]             }
[10:18:33.403]             base::options(...future.oldOptions)
[10:18:33.403]             if (.Platform$OS.type == "windows") {
[10:18:33.403]                 old_names <- names(...future.oldEnvVars)
[10:18:33.403]                 envs <- base::Sys.getenv()
[10:18:33.403]                 names <- names(envs)
[10:18:33.403]                 common <- intersect(names, old_names)
[10:18:33.403]                 added <- setdiff(names, old_names)
[10:18:33.403]                 removed <- setdiff(old_names, names)
[10:18:33.403]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.403]                   envs[common]]
[10:18:33.403]                 NAMES <- toupper(changed)
[10:18:33.403]                 args <- list()
[10:18:33.403]                 for (kk in seq_along(NAMES)) {
[10:18:33.403]                   name <- changed[[kk]]
[10:18:33.403]                   NAME <- NAMES[[kk]]
[10:18:33.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.403]                     next
[10:18:33.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.403]                 }
[10:18:33.403]                 NAMES <- toupper(added)
[10:18:33.403]                 for (kk in seq_along(NAMES)) {
[10:18:33.403]                   name <- added[[kk]]
[10:18:33.403]                   NAME <- NAMES[[kk]]
[10:18:33.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.403]                     next
[10:18:33.403]                   args[[name]] <- ""
[10:18:33.403]                 }
[10:18:33.403]                 NAMES <- toupper(removed)
[10:18:33.403]                 for (kk in seq_along(NAMES)) {
[10:18:33.403]                   name <- removed[[kk]]
[10:18:33.403]                   NAME <- NAMES[[kk]]
[10:18:33.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.403]                     next
[10:18:33.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.403]                 }
[10:18:33.403]                 if (length(args) > 0) 
[10:18:33.403]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.403]             }
[10:18:33.403]             else {
[10:18:33.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.403]             }
[10:18:33.403]             {
[10:18:33.403]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.403]                   0L) {
[10:18:33.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.403]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.403]                   base::options(opts)
[10:18:33.403]                 }
[10:18:33.403]                 {
[10:18:33.403]                   {
[10:18:33.403]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.403]                     NULL
[10:18:33.403]                   }
[10:18:33.403]                   options(future.plan = NULL)
[10:18:33.403]                   if (is.na(NA_character_)) 
[10:18:33.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.403]                     .init = FALSE)
[10:18:33.403]                 }
[10:18:33.403]             }
[10:18:33.403]         }
[10:18:33.403]     })
[10:18:33.403]     if (TRUE) {
[10:18:33.403]         base::sink(type = "output", split = FALSE)
[10:18:33.403]         if (TRUE) {
[10:18:33.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.403]         }
[10:18:33.403]         else {
[10:18:33.403]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.403]         }
[10:18:33.403]         base::close(...future.stdout)
[10:18:33.403]         ...future.stdout <- NULL
[10:18:33.403]     }
[10:18:33.403]     ...future.result$conditions <- ...future.conditions
[10:18:33.403]     ...future.result$finished <- base::Sys.time()
[10:18:33.403]     ...future.result
[10:18:33.403] }
[10:18:33.406] Exporting 5 global objects (1.18 KiB) to cluster node #1 ...
[10:18:33.406] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[10:18:33.407] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[10:18:33.407] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #1 ...
[10:18:33.407] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #1 ... DONE
[10:18:33.407] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #1 ...
[10:18:33.408] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #1 ... DONE
[10:18:33.408] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:33.408] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.408] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:33.409] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.409] Exporting 5 global objects (1.18 KiB) to cluster node #1 ... DONE
[10:18:33.409] MultisessionFuture started
[10:18:33.409] - Launch lazy future ... done
[10:18:33.409] run() for ‘MultisessionFuture’ ... done
[10:18:33.409] Created future:
[10:18:33.410] MultisessionFuture:
[10:18:33.410] Label: ‘future_by-1’
[10:18:33.410] Expression:
[10:18:33.410] {
[10:18:33.410]     do.call(function(...) {
[10:18:33.410]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.410]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.410]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.410]             on.exit(options(oopts), add = TRUE)
[10:18:33.410]         }
[10:18:33.410]         {
[10:18:33.410]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.410]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.410]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.410]             })
[10:18:33.410]         }
[10:18:33.410]     }, args = future.call.arguments)
[10:18:33.410] }
[10:18:33.410] Lazy evaluation: FALSE
[10:18:33.410] Asynchronous evaluation: TRUE
[10:18:33.410] Local evaluation: TRUE
[10:18:33.410] Environment: R_GlobalEnv
[10:18:33.410] Capture standard output: TRUE
[10:18:33.410] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.410] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.410] Packages: <none>
[10:18:33.410] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.410] Resolved: FALSE
[10:18:33.410] Value: <not collected>
[10:18:33.410] Conditions captured: <none>
[10:18:33.410] Early signaling: FALSE
[10:18:33.410] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.410] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.421] Chunk #1 of 2 ... DONE
[10:18:33.421] Chunk #2 of 2 ...
[10:18:33.421]  - Finding globals in 'X' for chunk #2 ...
[10:18:33.421] getGlobalsAndPackages() ...
[10:18:33.421] Searching for globals...
[10:18:33.422] 
[10:18:33.422] Searching for globals ... DONE
[10:18:33.422] - globals: [0] <none>
[10:18:33.422] getGlobalsAndPackages() ... DONE
[10:18:33.422]    + additional globals found: [n=0] 
[10:18:33.422]    + additional namespaces needed: [n=0] 
[10:18:33.422]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:33.422]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.422]  - seeds: <none>
[10:18:33.422]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.422] getGlobalsAndPackages() ...
[10:18:33.423] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.423] Resolving globals: FALSE
[10:18:33.423] Tweak future expression to call with '...' arguments ...
[10:18:33.423] {
[10:18:33.423]     do.call(function(...) {
[10:18:33.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.423]             on.exit(options(oopts), add = TRUE)
[10:18:33.423]         }
[10:18:33.423]         {
[10:18:33.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.423]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.423]             })
[10:18:33.423]         }
[10:18:33.423]     }, args = future.call.arguments)
[10:18:33.423] }
[10:18:33.423] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.423] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.424] 
[10:18:33.424] getGlobalsAndPackages() ... DONE
[10:18:33.424] run() for ‘Future’ ...
[10:18:33.424] - state: ‘created’
[10:18:33.424] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.437] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.438]   - Field: ‘node’
[10:18:33.438]   - Field: ‘label’
[10:18:33.438]   - Field: ‘local’
[10:18:33.438]   - Field: ‘owner’
[10:18:33.438]   - Field: ‘envir’
[10:18:33.438]   - Field: ‘workers’
[10:18:33.438]   - Field: ‘packages’
[10:18:33.438]   - Field: ‘gc’
[10:18:33.438]   - Field: ‘conditions’
[10:18:33.438]   - Field: ‘persistent’
[10:18:33.439]   - Field: ‘expr’
[10:18:33.439]   - Field: ‘uuid’
[10:18:33.439]   - Field: ‘seed’
[10:18:33.439]   - Field: ‘version’
[10:18:33.439]   - Field: ‘result’
[10:18:33.439]   - Field: ‘asynchronous’
[10:18:33.439]   - Field: ‘calls’
[10:18:33.439]   - Field: ‘globals’
[10:18:33.439]   - Field: ‘stdout’
[10:18:33.439]   - Field: ‘earlySignal’
[10:18:33.439]   - Field: ‘lazy’
[10:18:33.439]   - Field: ‘state’
[10:18:33.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.440] - Launch lazy future ...
[10:18:33.440] Packages needed by the future expression (n = 0): <none>
[10:18:33.440] Packages needed by future strategies (n = 0): <none>
[10:18:33.440] {
[10:18:33.440]     {
[10:18:33.440]         {
[10:18:33.440]             ...future.startTime <- base::Sys.time()
[10:18:33.440]             {
[10:18:33.440]                 {
[10:18:33.440]                   {
[10:18:33.440]                     {
[10:18:33.440]                       base::local({
[10:18:33.440]                         has_future <- base::requireNamespace("future", 
[10:18:33.440]                           quietly = TRUE)
[10:18:33.440]                         if (has_future) {
[10:18:33.440]                           ns <- base::getNamespace("future")
[10:18:33.440]                           version <- ns[[".package"]][["version"]]
[10:18:33.440]                           if (is.null(version)) 
[10:18:33.440]                             version <- utils::packageVersion("future")
[10:18:33.440]                         }
[10:18:33.440]                         else {
[10:18:33.440]                           version <- NULL
[10:18:33.440]                         }
[10:18:33.440]                         if (!has_future || version < "1.8.0") {
[10:18:33.440]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.440]                             "", base::R.version$version.string), 
[10:18:33.440]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.440]                               "release", "version")], collapse = " "), 
[10:18:33.440]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.440]                             info)
[10:18:33.440]                           info <- base::paste(info, collapse = "; ")
[10:18:33.440]                           if (!has_future) {
[10:18:33.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.440]                               info)
[10:18:33.440]                           }
[10:18:33.440]                           else {
[10:18:33.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.440]                               info, version)
[10:18:33.440]                           }
[10:18:33.440]                           base::stop(msg)
[10:18:33.440]                         }
[10:18:33.440]                       })
[10:18:33.440]                     }
[10:18:33.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.440]                     base::options(mc.cores = 1L)
[10:18:33.440]                   }
[10:18:33.440]                   ...future.strategy.old <- future::plan("list")
[10:18:33.440]                   options(future.plan = NULL)
[10:18:33.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.440]                 }
[10:18:33.440]                 ...future.workdir <- getwd()
[10:18:33.440]             }
[10:18:33.440]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.440]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.440]         }
[10:18:33.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.440]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.440]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.440]             base::names(...future.oldOptions))
[10:18:33.440]     }
[10:18:33.440]     if (FALSE) {
[10:18:33.440]     }
[10:18:33.440]     else {
[10:18:33.440]         if (TRUE) {
[10:18:33.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.440]                 open = "w")
[10:18:33.440]         }
[10:18:33.440]         else {
[10:18:33.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.440]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.440]         }
[10:18:33.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.440]             base::sink(type = "output", split = FALSE)
[10:18:33.440]             base::close(...future.stdout)
[10:18:33.440]         }, add = TRUE)
[10:18:33.440]     }
[10:18:33.440]     ...future.frame <- base::sys.nframe()
[10:18:33.440]     ...future.conditions <- base::list()
[10:18:33.440]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.440]     if (FALSE) {
[10:18:33.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.440]     }
[10:18:33.440]     ...future.result <- base::tryCatch({
[10:18:33.440]         base::withCallingHandlers({
[10:18:33.440]             ...future.value <- base::withVisible(base::local({
[10:18:33.440]                 ...future.makeSendCondition <- base::local({
[10:18:33.440]                   sendCondition <- NULL
[10:18:33.440]                   function(frame = 1L) {
[10:18:33.440]                     if (is.function(sendCondition)) 
[10:18:33.440]                       return(sendCondition)
[10:18:33.440]                     ns <- getNamespace("parallel")
[10:18:33.440]                     if (exists("sendData", mode = "function", 
[10:18:33.440]                       envir = ns)) {
[10:18:33.440]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.440]                         envir = ns)
[10:18:33.440]                       envir <- sys.frame(frame)
[10:18:33.440]                       master <- NULL
[10:18:33.440]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.440]                         !identical(envir, emptyenv())) {
[10:18:33.440]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.440]                           inherits = FALSE)) {
[10:18:33.440]                           master <- get("master", mode = "list", 
[10:18:33.440]                             envir = envir, inherits = FALSE)
[10:18:33.440]                           if (inherits(master, c("SOCKnode", 
[10:18:33.440]                             "SOCK0node"))) {
[10:18:33.440]                             sendCondition <<- function(cond) {
[10:18:33.440]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.440]                                 success = TRUE)
[10:18:33.440]                               parallel_sendData(master, data)
[10:18:33.440]                             }
[10:18:33.440]                             return(sendCondition)
[10:18:33.440]                           }
[10:18:33.440]                         }
[10:18:33.440]                         frame <- frame + 1L
[10:18:33.440]                         envir <- sys.frame(frame)
[10:18:33.440]                       }
[10:18:33.440]                     }
[10:18:33.440]                     sendCondition <<- function(cond) NULL
[10:18:33.440]                   }
[10:18:33.440]                 })
[10:18:33.440]                 withCallingHandlers({
[10:18:33.440]                   {
[10:18:33.440]                     do.call(function(...) {
[10:18:33.440]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.440]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.440]                         ...future.globals.maxSize)) {
[10:18:33.440]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.440]                         on.exit(options(oopts), add = TRUE)
[10:18:33.440]                       }
[10:18:33.440]                       {
[10:18:33.440]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.440]                           FUN = function(jj) {
[10:18:33.440]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.440]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.440]                           })
[10:18:33.440]                       }
[10:18:33.440]                     }, args = future.call.arguments)
[10:18:33.440]                   }
[10:18:33.440]                 }, immediateCondition = function(cond) {
[10:18:33.440]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.440]                   sendCondition(cond)
[10:18:33.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.440]                   {
[10:18:33.440]                     inherits <- base::inherits
[10:18:33.440]                     invokeRestart <- base::invokeRestart
[10:18:33.440]                     is.null <- base::is.null
[10:18:33.440]                     muffled <- FALSE
[10:18:33.440]                     if (inherits(cond, "message")) {
[10:18:33.440]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.440]                       if (muffled) 
[10:18:33.440]                         invokeRestart("muffleMessage")
[10:18:33.440]                     }
[10:18:33.440]                     else if (inherits(cond, "warning")) {
[10:18:33.440]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.440]                       if (muffled) 
[10:18:33.440]                         invokeRestart("muffleWarning")
[10:18:33.440]                     }
[10:18:33.440]                     else if (inherits(cond, "condition")) {
[10:18:33.440]                       if (!is.null(pattern)) {
[10:18:33.440]                         computeRestarts <- base::computeRestarts
[10:18:33.440]                         grepl <- base::grepl
[10:18:33.440]                         restarts <- computeRestarts(cond)
[10:18:33.440]                         for (restart in restarts) {
[10:18:33.440]                           name <- restart$name
[10:18:33.440]                           if (is.null(name)) 
[10:18:33.440]                             next
[10:18:33.440]                           if (!grepl(pattern, name)) 
[10:18:33.440]                             next
[10:18:33.440]                           invokeRestart(restart)
[10:18:33.440]                           muffled <- TRUE
[10:18:33.440]                           break
[10:18:33.440]                         }
[10:18:33.440]                       }
[10:18:33.440]                     }
[10:18:33.440]                     invisible(muffled)
[10:18:33.440]                   }
[10:18:33.440]                   muffleCondition(cond)
[10:18:33.440]                 })
[10:18:33.440]             }))
[10:18:33.440]             future::FutureResult(value = ...future.value$value, 
[10:18:33.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.440]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.440]                     ...future.globalenv.names))
[10:18:33.440]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.440]         }, condition = base::local({
[10:18:33.440]             c <- base::c
[10:18:33.440]             inherits <- base::inherits
[10:18:33.440]             invokeRestart <- base::invokeRestart
[10:18:33.440]             length <- base::length
[10:18:33.440]             list <- base::list
[10:18:33.440]             seq.int <- base::seq.int
[10:18:33.440]             signalCondition <- base::signalCondition
[10:18:33.440]             sys.calls <- base::sys.calls
[10:18:33.440]             `[[` <- base::`[[`
[10:18:33.440]             `+` <- base::`+`
[10:18:33.440]             `<<-` <- base::`<<-`
[10:18:33.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.440]                   3L)]
[10:18:33.440]             }
[10:18:33.440]             function(cond) {
[10:18:33.440]                 is_error <- inherits(cond, "error")
[10:18:33.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.440]                   NULL)
[10:18:33.440]                 if (is_error) {
[10:18:33.440]                   sessionInformation <- function() {
[10:18:33.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.440]                       search = base::search(), system = base::Sys.info())
[10:18:33.440]                   }
[10:18:33.440]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.440]                     cond$call), session = sessionInformation(), 
[10:18:33.440]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.440]                   signalCondition(cond)
[10:18:33.440]                 }
[10:18:33.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.440]                 "immediateCondition"))) {
[10:18:33.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.440]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.440]                   if (TRUE && !signal) {
[10:18:33.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.440]                     {
[10:18:33.440]                       inherits <- base::inherits
[10:18:33.440]                       invokeRestart <- base::invokeRestart
[10:18:33.440]                       is.null <- base::is.null
[10:18:33.440]                       muffled <- FALSE
[10:18:33.440]                       if (inherits(cond, "message")) {
[10:18:33.440]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.440]                         if (muffled) 
[10:18:33.440]                           invokeRestart("muffleMessage")
[10:18:33.440]                       }
[10:18:33.440]                       else if (inherits(cond, "warning")) {
[10:18:33.440]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.440]                         if (muffled) 
[10:18:33.440]                           invokeRestart("muffleWarning")
[10:18:33.440]                       }
[10:18:33.440]                       else if (inherits(cond, "condition")) {
[10:18:33.440]                         if (!is.null(pattern)) {
[10:18:33.440]                           computeRestarts <- base::computeRestarts
[10:18:33.440]                           grepl <- base::grepl
[10:18:33.440]                           restarts <- computeRestarts(cond)
[10:18:33.440]                           for (restart in restarts) {
[10:18:33.440]                             name <- restart$name
[10:18:33.440]                             if (is.null(name)) 
[10:18:33.440]                               next
[10:18:33.440]                             if (!grepl(pattern, name)) 
[10:18:33.440]                               next
[10:18:33.440]                             invokeRestart(restart)
[10:18:33.440]                             muffled <- TRUE
[10:18:33.440]                             break
[10:18:33.440]                           }
[10:18:33.440]                         }
[10:18:33.440]                       }
[10:18:33.440]                       invisible(muffled)
[10:18:33.440]                     }
[10:18:33.440]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.440]                   }
[10:18:33.440]                 }
[10:18:33.440]                 else {
[10:18:33.440]                   if (TRUE) {
[10:18:33.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.440]                     {
[10:18:33.440]                       inherits <- base::inherits
[10:18:33.440]                       invokeRestart <- base::invokeRestart
[10:18:33.440]                       is.null <- base::is.null
[10:18:33.440]                       muffled <- FALSE
[10:18:33.440]                       if (inherits(cond, "message")) {
[10:18:33.440]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.440]                         if (muffled) 
[10:18:33.440]                           invokeRestart("muffleMessage")
[10:18:33.440]                       }
[10:18:33.440]                       else if (inherits(cond, "warning")) {
[10:18:33.440]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.440]                         if (muffled) 
[10:18:33.440]                           invokeRestart("muffleWarning")
[10:18:33.440]                       }
[10:18:33.440]                       else if (inherits(cond, "condition")) {
[10:18:33.440]                         if (!is.null(pattern)) {
[10:18:33.440]                           computeRestarts <- base::computeRestarts
[10:18:33.440]                           grepl <- base::grepl
[10:18:33.440]                           restarts <- computeRestarts(cond)
[10:18:33.440]                           for (restart in restarts) {
[10:18:33.440]                             name <- restart$name
[10:18:33.440]                             if (is.null(name)) 
[10:18:33.440]                               next
[10:18:33.440]                             if (!grepl(pattern, name)) 
[10:18:33.440]                               next
[10:18:33.440]                             invokeRestart(restart)
[10:18:33.440]                             muffled <- TRUE
[10:18:33.440]                             break
[10:18:33.440]                           }
[10:18:33.440]                         }
[10:18:33.440]                       }
[10:18:33.440]                       invisible(muffled)
[10:18:33.440]                     }
[10:18:33.440]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.440]                   }
[10:18:33.440]                 }
[10:18:33.440]             }
[10:18:33.440]         }))
[10:18:33.440]     }, error = function(ex) {
[10:18:33.440]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.440]                 ...future.rng), started = ...future.startTime, 
[10:18:33.440]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.440]             version = "1.8"), class = "FutureResult")
[10:18:33.440]     }, finally = {
[10:18:33.440]         if (!identical(...future.workdir, getwd())) 
[10:18:33.440]             setwd(...future.workdir)
[10:18:33.440]         {
[10:18:33.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.440]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.440]             }
[10:18:33.440]             base::options(...future.oldOptions)
[10:18:33.440]             if (.Platform$OS.type == "windows") {
[10:18:33.440]                 old_names <- names(...future.oldEnvVars)
[10:18:33.440]                 envs <- base::Sys.getenv()
[10:18:33.440]                 names <- names(envs)
[10:18:33.440]                 common <- intersect(names, old_names)
[10:18:33.440]                 added <- setdiff(names, old_names)
[10:18:33.440]                 removed <- setdiff(old_names, names)
[10:18:33.440]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.440]                   envs[common]]
[10:18:33.440]                 NAMES <- toupper(changed)
[10:18:33.440]                 args <- list()
[10:18:33.440]                 for (kk in seq_along(NAMES)) {
[10:18:33.440]                   name <- changed[[kk]]
[10:18:33.440]                   NAME <- NAMES[[kk]]
[10:18:33.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.440]                     next
[10:18:33.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.440]                 }
[10:18:33.440]                 NAMES <- toupper(added)
[10:18:33.440]                 for (kk in seq_along(NAMES)) {
[10:18:33.440]                   name <- added[[kk]]
[10:18:33.440]                   NAME <- NAMES[[kk]]
[10:18:33.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.440]                     next
[10:18:33.440]                   args[[name]] <- ""
[10:18:33.440]                 }
[10:18:33.440]                 NAMES <- toupper(removed)
[10:18:33.440]                 for (kk in seq_along(NAMES)) {
[10:18:33.440]                   name <- removed[[kk]]
[10:18:33.440]                   NAME <- NAMES[[kk]]
[10:18:33.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.440]                     next
[10:18:33.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.440]                 }
[10:18:33.440]                 if (length(args) > 0) 
[10:18:33.440]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.440]             }
[10:18:33.440]             else {
[10:18:33.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.440]             }
[10:18:33.440]             {
[10:18:33.440]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.440]                   0L) {
[10:18:33.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.440]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.440]                   base::options(opts)
[10:18:33.440]                 }
[10:18:33.440]                 {
[10:18:33.440]                   {
[10:18:33.440]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.440]                     NULL
[10:18:33.440]                   }
[10:18:33.440]                   options(future.plan = NULL)
[10:18:33.440]                   if (is.na(NA_character_)) 
[10:18:33.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.440]                     .init = FALSE)
[10:18:33.440]                 }
[10:18:33.440]             }
[10:18:33.440]         }
[10:18:33.440]     })
[10:18:33.440]     if (TRUE) {
[10:18:33.440]         base::sink(type = "output", split = FALSE)
[10:18:33.440]         if (TRUE) {
[10:18:33.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.440]         }
[10:18:33.440]         else {
[10:18:33.440]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.440]         }
[10:18:33.440]         base::close(...future.stdout)
[10:18:33.440]         ...future.stdout <- NULL
[10:18:33.440]     }
[10:18:33.440]     ...future.result$conditions <- ...future.conditions
[10:18:33.440]     ...future.result$finished <- base::Sys.time()
[10:18:33.440]     ...future.result
[10:18:33.440] }
[10:18:33.443] Exporting 5 global objects (1.18 KiB) to cluster node #2 ...
[10:18:33.443] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[10:18:33.443] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[10:18:33.444] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #2 ...
[10:18:33.444] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #2 ... DONE
[10:18:33.444] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #2 ...
[10:18:33.444] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #2 ... DONE
[10:18:33.444] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:33.445] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.445] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:33.445] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.445] Exporting 5 global objects (1.18 KiB) to cluster node #2 ... DONE
[10:18:33.446] MultisessionFuture started
[10:18:33.446] - Launch lazy future ... done
[10:18:33.446] run() for ‘MultisessionFuture’ ... done
[10:18:33.446] Created future:
[10:18:33.446] MultisessionFuture:
[10:18:33.446] Label: ‘future_by-2’
[10:18:33.446] Expression:
[10:18:33.446] {
[10:18:33.446]     do.call(function(...) {
[10:18:33.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.446]             on.exit(options(oopts), add = TRUE)
[10:18:33.446]         }
[10:18:33.446]         {
[10:18:33.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.446]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.446]             })
[10:18:33.446]         }
[10:18:33.446]     }, args = future.call.arguments)
[10:18:33.446] }
[10:18:33.446] Lazy evaluation: FALSE
[10:18:33.446] Asynchronous evaluation: TRUE
[10:18:33.446] Local evaluation: TRUE
[10:18:33.446] Environment: R_GlobalEnv
[10:18:33.446] Capture standard output: TRUE
[10:18:33.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.446] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.446] Packages: <none>
[10:18:33.446] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.446] Resolved: FALSE
[10:18:33.446] Value: <not collected>
[10:18:33.446] Conditions captured: <none>
[10:18:33.446] Early signaling: FALSE
[10:18:33.446] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.446] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.457] Chunk #2 of 2 ... DONE
[10:18:33.457] Launching 2 futures (chunks) ... DONE
[10:18:33.458] Resolving 2 futures (chunks) ...
[10:18:33.458] resolve() on list ...
[10:18:33.458]  recursive: 0
[10:18:33.458]  length: 2
[10:18:33.458] 
[10:18:33.458] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.459] - Validating connection of MultisessionFuture
[10:18:33.459] - received message: FutureResult
[10:18:33.459] - Received FutureResult
[10:18:33.459] - Erased future from FutureRegistry
[10:18:33.459] result() for ClusterFuture ...
[10:18:33.459] - result already collected: FutureResult
[10:18:33.459] result() for ClusterFuture ... done
[10:18:33.459] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.459] Future #1
[10:18:33.460] result() for ClusterFuture ...
[10:18:33.460] - result already collected: FutureResult
[10:18:33.460] result() for ClusterFuture ... done
[10:18:33.460] result() for ClusterFuture ...
[10:18:33.460] - result already collected: FutureResult
[10:18:33.460] result() for ClusterFuture ... done
[10:18:33.460] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:33.460] - nx: 2
[10:18:33.460] - relay: TRUE
[10:18:33.460] - stdout: TRUE
[10:18:33.460] - signal: TRUE
[10:18:33.460] - resignal: FALSE
[10:18:33.461] - force: TRUE
[10:18:33.461] - relayed: [n=2] FALSE, FALSE
[10:18:33.461] - queued futures: [n=2] FALSE, FALSE
[10:18:33.461]  - until=1
[10:18:33.461]  - relaying element #1
[10:18:33.461] result() for ClusterFuture ...
[10:18:33.461] - result already collected: FutureResult
[10:18:33.461] result() for ClusterFuture ... done
[10:18:33.461] result() for ClusterFuture ...
[10:18:33.461] - result already collected: FutureResult
[10:18:33.461] result() for ClusterFuture ... done
[10:18:33.461] result() for ClusterFuture ...
[10:18:33.462] - result already collected: FutureResult
[10:18:33.462] result() for ClusterFuture ... done
[10:18:33.462] result() for ClusterFuture ...
[10:18:33.462] - result already collected: FutureResult
[10:18:33.462] result() for ClusterFuture ... done
[10:18:33.462] - relayed: [n=2] TRUE, FALSE
[10:18:33.462] - queued futures: [n=2] TRUE, FALSE
[10:18:33.462] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:33.462]  length: 1 (resolved future 1)
[10:18:33.488] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.489] - Validating connection of MultisessionFuture
[10:18:33.489] - received message: FutureResult
[10:18:33.489] - Received FutureResult
[10:18:33.489] - Erased future from FutureRegistry
[10:18:33.489] result() for ClusterFuture ...
[10:18:33.489] - result already collected: FutureResult
[10:18:33.489] result() for ClusterFuture ... done
[10:18:33.489] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.489] Future #2
[10:18:33.490] result() for ClusterFuture ...
[10:18:33.490] - result already collected: FutureResult
[10:18:33.490] result() for ClusterFuture ... done
[10:18:33.490] result() for ClusterFuture ...
[10:18:33.490] - result already collected: FutureResult
[10:18:33.490] result() for ClusterFuture ... done
[10:18:33.490] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:33.490] - nx: 2
[10:18:33.490] - relay: TRUE
[10:18:33.490] - stdout: TRUE
[10:18:33.490] - signal: TRUE
[10:18:33.490] - resignal: FALSE
[10:18:33.490] - force: TRUE
[10:18:33.491] - relayed: [n=2] TRUE, FALSE
[10:18:33.491] - queued futures: [n=2] TRUE, FALSE
[10:18:33.491]  - until=2
[10:18:33.491]  - relaying element #2
[10:18:33.491] result() for ClusterFuture ...
[10:18:33.491] - result already collected: FutureResult
[10:18:33.491] result() for ClusterFuture ... done
[10:18:33.491] result() for ClusterFuture ...
[10:18:33.491] - result already collected: FutureResult
[10:18:33.491] result() for ClusterFuture ... done
[10:18:33.491] result() for ClusterFuture ...
[10:18:33.491] - result already collected: FutureResult
[10:18:33.492] result() for ClusterFuture ... done
[10:18:33.492] result() for ClusterFuture ...
[10:18:33.492] - result already collected: FutureResult
[10:18:33.492] result() for ClusterFuture ... done
[10:18:33.492] - relayed: [n=2] TRUE, TRUE
[10:18:33.492] - queued futures: [n=2] TRUE, TRUE
[10:18:33.492] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:33.492]  length: 0 (resolved future 2)
[10:18:33.492] Relaying remaining futures
[10:18:33.492] signalConditionsASAP(NULL, pos=0) ...
[10:18:33.492] - nx: 2
[10:18:33.492] - relay: TRUE
[10:18:33.492] - stdout: TRUE
[10:18:33.493] - signal: TRUE
[10:18:33.493] - resignal: FALSE
[10:18:33.493] - force: TRUE
[10:18:33.493] - relayed: [n=2] TRUE, TRUE
[10:18:33.493] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:33.493] - relayed: [n=2] TRUE, TRUE
[10:18:33.493] - queued futures: [n=2] TRUE, TRUE
[10:18:33.493] signalConditionsASAP(NULL, pos=0) ... done
[10:18:33.493] resolve() on list ... DONE
[10:18:33.493] result() for ClusterFuture ...
[10:18:33.493] - result already collected: FutureResult
[10:18:33.493] result() for ClusterFuture ... done
[10:18:33.494] result() for ClusterFuture ...
[10:18:33.494] - result already collected: FutureResult
[10:18:33.494] result() for ClusterFuture ... done
[10:18:33.494] result() for ClusterFuture ...
[10:18:33.494] - result already collected: FutureResult
[10:18:33.494] result() for ClusterFuture ... done
[10:18:33.494] result() for ClusterFuture ...
[10:18:33.494] - result already collected: FutureResult
[10:18:33.494] result() for ClusterFuture ... done
[10:18:33.494]  - Number of value chunks collected: 2
[10:18:33.494] Resolving 2 futures (chunks) ... DONE
[10:18:33.494] Reducing values from 2 chunks ...
[10:18:33.495]  - Number of values collected after concatenation: 6
[10:18:33.495]  - Number of values expected: 6
[10:18:33.495] Reducing values from 2 chunks ... DONE
[10:18:33.495] future_lapply() ... DONE
[10:18:33.495] future_by_internal() ... DONE
[10:18:33.496] future_by_internal() ...
[10:18:33.496] future_lapply() ...
[10:18:33.499] Number of chunks: 2
[10:18:33.499] getGlobalsAndPackagesXApply() ...
[10:18:33.499]  - future.globals: TRUE
[10:18:33.499] getGlobalsAndPackages() ...
[10:18:33.499] Searching for globals...
[10:18:33.501] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:33.501] Searching for globals ... DONE
[10:18:33.501] Resolving globals: FALSE
[10:18:33.501] The total size of the 1 globals is 762 bytes (762 bytes)
[10:18:33.502] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[10:18:33.502] - globals: [1] ‘FUN’
[10:18:33.502] - packages: [1] ‘stats’
[10:18:33.502] getGlobalsAndPackages() ... DONE
[10:18:33.502]  - globals found/used: [n=1] ‘FUN’
[10:18:33.502]  - needed namespaces: [n=1] ‘stats’
[10:18:33.502] Finding globals ... DONE
[10:18:33.502]  - use_args: TRUE
[10:18:33.502]  - Getting '...' globals ...
[10:18:33.503] resolve() on list ...
[10:18:33.503]  recursive: 0
[10:18:33.503]  length: 1
[10:18:33.503]  elements: ‘...’
[10:18:33.503]  length: 0 (resolved future 1)
[10:18:33.503] resolve() on list ... DONE
[10:18:33.503]    - '...' content: [n=1] ‘singular.ok’
[10:18:33.503] List of 1
[10:18:33.503]  $ ...:List of 1
[10:18:33.503]   ..$ singular.ok: logi FALSE
[10:18:33.503]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.503]  - attr(*, "where")=List of 1
[10:18:33.503]   ..$ ...:<environment: 0x55844bafce88> 
[10:18:33.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.503]  - attr(*, "resolved")= logi TRUE
[10:18:33.503]  - attr(*, "total_size")= num NA
[10:18:33.506]  - Getting '...' globals ... DONE
[10:18:33.506] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:33.506] List of 2
[10:18:33.506]  $ ...future.FUN:function (x, ...)  
[10:18:33.506]  $ ...          :List of 1
[10:18:33.506]   ..$ singular.ok: logi FALSE
[10:18:33.506]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.506]  - attr(*, "where")=List of 2
[10:18:33.506]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:33.506]   ..$ ...          :<environment: 0x55844bafce88> 
[10:18:33.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.506]  - attr(*, "resolved")= logi FALSE
[10:18:33.506]  - attr(*, "total_size")= num 19977
[10:18:33.509] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:33.509] getGlobalsAndPackagesXApply() ... DONE
[10:18:33.510] Number of futures (= number of chunks): 2
[10:18:33.510] Launching 2 futures (chunks) ...
[10:18:33.510] Chunk #1 of 2 ...
[10:18:33.510]  - Finding globals in 'X' for chunk #1 ...
[10:18:33.510] getGlobalsAndPackages() ...
[10:18:33.510] Searching for globals...
[10:18:33.510] 
[10:18:33.511] Searching for globals ... DONE
[10:18:33.511] - globals: [0] <none>
[10:18:33.511] getGlobalsAndPackages() ... DONE
[10:18:33.511]    + additional globals found: [n=0] 
[10:18:33.511]    + additional namespaces needed: [n=0] 
[10:18:33.511]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:33.511]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.511]  - seeds: <none>
[10:18:33.511]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.511] getGlobalsAndPackages() ...
[10:18:33.511] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.512] Resolving globals: FALSE
[10:18:33.512] Tweak future expression to call with '...' arguments ...
[10:18:33.512] {
[10:18:33.512]     do.call(function(...) {
[10:18:33.512]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.512]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.512]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.512]             on.exit(options(oopts), add = TRUE)
[10:18:33.512]         }
[10:18:33.512]         {
[10:18:33.512]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.512]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.512]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.512]             })
[10:18:33.512]         }
[10:18:33.512]     }, args = future.call.arguments)
[10:18:33.512] }
[10:18:33.512] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.512] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.512] 
[10:18:33.513] getGlobalsAndPackages() ... DONE
[10:18:33.513] run() for ‘Future’ ...
[10:18:33.513] - state: ‘created’
[10:18:33.513] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.527] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.527]   - Field: ‘node’
[10:18:33.527]   - Field: ‘label’
[10:18:33.527]   - Field: ‘local’
[10:18:33.527]   - Field: ‘owner’
[10:18:33.527]   - Field: ‘envir’
[10:18:33.527]   - Field: ‘workers’
[10:18:33.528]   - Field: ‘packages’
[10:18:33.528]   - Field: ‘gc’
[10:18:33.528]   - Field: ‘conditions’
[10:18:33.528]   - Field: ‘persistent’
[10:18:33.528]   - Field: ‘expr’
[10:18:33.528]   - Field: ‘uuid’
[10:18:33.528]   - Field: ‘seed’
[10:18:33.528]   - Field: ‘version’
[10:18:33.528]   - Field: ‘result’
[10:18:33.528]   - Field: ‘asynchronous’
[10:18:33.528]   - Field: ‘calls’
[10:18:33.528]   - Field: ‘globals’
[10:18:33.529]   - Field: ‘stdout’
[10:18:33.529]   - Field: ‘earlySignal’
[10:18:33.529]   - Field: ‘lazy’
[10:18:33.529]   - Field: ‘state’
[10:18:33.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.529] - Launch lazy future ...
[10:18:33.529] Packages needed by the future expression (n = 1): ‘stats’
[10:18:33.529] Packages needed by future strategies (n = 0): <none>
[10:18:33.530] {
[10:18:33.530]     {
[10:18:33.530]         {
[10:18:33.530]             ...future.startTime <- base::Sys.time()
[10:18:33.530]             {
[10:18:33.530]                 {
[10:18:33.530]                   {
[10:18:33.530]                     {
[10:18:33.530]                       {
[10:18:33.530]                         base::local({
[10:18:33.530]                           has_future <- base::requireNamespace("future", 
[10:18:33.530]                             quietly = TRUE)
[10:18:33.530]                           if (has_future) {
[10:18:33.530]                             ns <- base::getNamespace("future")
[10:18:33.530]                             version <- ns[[".package"]][["version"]]
[10:18:33.530]                             if (is.null(version)) 
[10:18:33.530]                               version <- utils::packageVersion("future")
[10:18:33.530]                           }
[10:18:33.530]                           else {
[10:18:33.530]                             version <- NULL
[10:18:33.530]                           }
[10:18:33.530]                           if (!has_future || version < "1.8.0") {
[10:18:33.530]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.530]                               "", base::R.version$version.string), 
[10:18:33.530]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:33.530]                                 base::R.version$platform, 8 * 
[10:18:33.530]                                   base::.Machine$sizeof.pointer), 
[10:18:33.530]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.530]                                 "release", "version")], collapse = " "), 
[10:18:33.530]                               hostname = base::Sys.info()[["nodename"]])
[10:18:33.530]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.530]                               info)
[10:18:33.530]                             info <- base::paste(info, collapse = "; ")
[10:18:33.530]                             if (!has_future) {
[10:18:33.530]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.530]                                 info)
[10:18:33.530]                             }
[10:18:33.530]                             else {
[10:18:33.530]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.530]                                 info, version)
[10:18:33.530]                             }
[10:18:33.530]                             base::stop(msg)
[10:18:33.530]                           }
[10:18:33.530]                         })
[10:18:33.530]                       }
[10:18:33.530]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.530]                       base::options(mc.cores = 1L)
[10:18:33.530]                     }
[10:18:33.530]                     base::local({
[10:18:33.530]                       for (pkg in "stats") {
[10:18:33.530]                         base::loadNamespace(pkg)
[10:18:33.530]                         base::library(pkg, character.only = TRUE)
[10:18:33.530]                       }
[10:18:33.530]                     })
[10:18:33.530]                   }
[10:18:33.530]                   ...future.strategy.old <- future::plan("list")
[10:18:33.530]                   options(future.plan = NULL)
[10:18:33.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.530]                 }
[10:18:33.530]                 ...future.workdir <- getwd()
[10:18:33.530]             }
[10:18:33.530]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.530]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.530]         }
[10:18:33.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.530]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.530]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.530]             base::names(...future.oldOptions))
[10:18:33.530]     }
[10:18:33.530]     if (FALSE) {
[10:18:33.530]     }
[10:18:33.530]     else {
[10:18:33.530]         if (TRUE) {
[10:18:33.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.530]                 open = "w")
[10:18:33.530]         }
[10:18:33.530]         else {
[10:18:33.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.530]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.530]         }
[10:18:33.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.530]             base::sink(type = "output", split = FALSE)
[10:18:33.530]             base::close(...future.stdout)
[10:18:33.530]         }, add = TRUE)
[10:18:33.530]     }
[10:18:33.530]     ...future.frame <- base::sys.nframe()
[10:18:33.530]     ...future.conditions <- base::list()
[10:18:33.530]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.530]     if (FALSE) {
[10:18:33.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.530]     }
[10:18:33.530]     ...future.result <- base::tryCatch({
[10:18:33.530]         base::withCallingHandlers({
[10:18:33.530]             ...future.value <- base::withVisible(base::local({
[10:18:33.530]                 ...future.makeSendCondition <- base::local({
[10:18:33.530]                   sendCondition <- NULL
[10:18:33.530]                   function(frame = 1L) {
[10:18:33.530]                     if (is.function(sendCondition)) 
[10:18:33.530]                       return(sendCondition)
[10:18:33.530]                     ns <- getNamespace("parallel")
[10:18:33.530]                     if (exists("sendData", mode = "function", 
[10:18:33.530]                       envir = ns)) {
[10:18:33.530]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.530]                         envir = ns)
[10:18:33.530]                       envir <- sys.frame(frame)
[10:18:33.530]                       master <- NULL
[10:18:33.530]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.530]                         !identical(envir, emptyenv())) {
[10:18:33.530]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.530]                           inherits = FALSE)) {
[10:18:33.530]                           master <- get("master", mode = "list", 
[10:18:33.530]                             envir = envir, inherits = FALSE)
[10:18:33.530]                           if (inherits(master, c("SOCKnode", 
[10:18:33.530]                             "SOCK0node"))) {
[10:18:33.530]                             sendCondition <<- function(cond) {
[10:18:33.530]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.530]                                 success = TRUE)
[10:18:33.530]                               parallel_sendData(master, data)
[10:18:33.530]                             }
[10:18:33.530]                             return(sendCondition)
[10:18:33.530]                           }
[10:18:33.530]                         }
[10:18:33.530]                         frame <- frame + 1L
[10:18:33.530]                         envir <- sys.frame(frame)
[10:18:33.530]                       }
[10:18:33.530]                     }
[10:18:33.530]                     sendCondition <<- function(cond) NULL
[10:18:33.530]                   }
[10:18:33.530]                 })
[10:18:33.530]                 withCallingHandlers({
[10:18:33.530]                   {
[10:18:33.530]                     do.call(function(...) {
[10:18:33.530]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.530]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.530]                         ...future.globals.maxSize)) {
[10:18:33.530]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.530]                         on.exit(options(oopts), add = TRUE)
[10:18:33.530]                       }
[10:18:33.530]                       {
[10:18:33.530]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.530]                           FUN = function(jj) {
[10:18:33.530]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.530]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.530]                           })
[10:18:33.530]                       }
[10:18:33.530]                     }, args = future.call.arguments)
[10:18:33.530]                   }
[10:18:33.530]                 }, immediateCondition = function(cond) {
[10:18:33.530]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.530]                   sendCondition(cond)
[10:18:33.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.530]                   {
[10:18:33.530]                     inherits <- base::inherits
[10:18:33.530]                     invokeRestart <- base::invokeRestart
[10:18:33.530]                     is.null <- base::is.null
[10:18:33.530]                     muffled <- FALSE
[10:18:33.530]                     if (inherits(cond, "message")) {
[10:18:33.530]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.530]                       if (muffled) 
[10:18:33.530]                         invokeRestart("muffleMessage")
[10:18:33.530]                     }
[10:18:33.530]                     else if (inherits(cond, "warning")) {
[10:18:33.530]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.530]                       if (muffled) 
[10:18:33.530]                         invokeRestart("muffleWarning")
[10:18:33.530]                     }
[10:18:33.530]                     else if (inherits(cond, "condition")) {
[10:18:33.530]                       if (!is.null(pattern)) {
[10:18:33.530]                         computeRestarts <- base::computeRestarts
[10:18:33.530]                         grepl <- base::grepl
[10:18:33.530]                         restarts <- computeRestarts(cond)
[10:18:33.530]                         for (restart in restarts) {
[10:18:33.530]                           name <- restart$name
[10:18:33.530]                           if (is.null(name)) 
[10:18:33.530]                             next
[10:18:33.530]                           if (!grepl(pattern, name)) 
[10:18:33.530]                             next
[10:18:33.530]                           invokeRestart(restart)
[10:18:33.530]                           muffled <- TRUE
[10:18:33.530]                           break
[10:18:33.530]                         }
[10:18:33.530]                       }
[10:18:33.530]                     }
[10:18:33.530]                     invisible(muffled)
[10:18:33.530]                   }
[10:18:33.530]                   muffleCondition(cond)
[10:18:33.530]                 })
[10:18:33.530]             }))
[10:18:33.530]             future::FutureResult(value = ...future.value$value, 
[10:18:33.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.530]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.530]                     ...future.globalenv.names))
[10:18:33.530]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.530]         }, condition = base::local({
[10:18:33.530]             c <- base::c
[10:18:33.530]             inherits <- base::inherits
[10:18:33.530]             invokeRestart <- base::invokeRestart
[10:18:33.530]             length <- base::length
[10:18:33.530]             list <- base::list
[10:18:33.530]             seq.int <- base::seq.int
[10:18:33.530]             signalCondition <- base::signalCondition
[10:18:33.530]             sys.calls <- base::sys.calls
[10:18:33.530]             `[[` <- base::`[[`
[10:18:33.530]             `+` <- base::`+`
[10:18:33.530]             `<<-` <- base::`<<-`
[10:18:33.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.530]                   3L)]
[10:18:33.530]             }
[10:18:33.530]             function(cond) {
[10:18:33.530]                 is_error <- inherits(cond, "error")
[10:18:33.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.530]                   NULL)
[10:18:33.530]                 if (is_error) {
[10:18:33.530]                   sessionInformation <- function() {
[10:18:33.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.530]                       search = base::search(), system = base::Sys.info())
[10:18:33.530]                   }
[10:18:33.530]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.530]                     cond$call), session = sessionInformation(), 
[10:18:33.530]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.530]                   signalCondition(cond)
[10:18:33.530]                 }
[10:18:33.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.530]                 "immediateCondition"))) {
[10:18:33.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.530]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.530]                   if (TRUE && !signal) {
[10:18:33.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.530]                     {
[10:18:33.530]                       inherits <- base::inherits
[10:18:33.530]                       invokeRestart <- base::invokeRestart
[10:18:33.530]                       is.null <- base::is.null
[10:18:33.530]                       muffled <- FALSE
[10:18:33.530]                       if (inherits(cond, "message")) {
[10:18:33.530]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.530]                         if (muffled) 
[10:18:33.530]                           invokeRestart("muffleMessage")
[10:18:33.530]                       }
[10:18:33.530]                       else if (inherits(cond, "warning")) {
[10:18:33.530]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.530]                         if (muffled) 
[10:18:33.530]                           invokeRestart("muffleWarning")
[10:18:33.530]                       }
[10:18:33.530]                       else if (inherits(cond, "condition")) {
[10:18:33.530]                         if (!is.null(pattern)) {
[10:18:33.530]                           computeRestarts <- base::computeRestarts
[10:18:33.530]                           grepl <- base::grepl
[10:18:33.530]                           restarts <- computeRestarts(cond)
[10:18:33.530]                           for (restart in restarts) {
[10:18:33.530]                             name <- restart$name
[10:18:33.530]                             if (is.null(name)) 
[10:18:33.530]                               next
[10:18:33.530]                             if (!grepl(pattern, name)) 
[10:18:33.530]                               next
[10:18:33.530]                             invokeRestart(restart)
[10:18:33.530]                             muffled <- TRUE
[10:18:33.530]                             break
[10:18:33.530]                           }
[10:18:33.530]                         }
[10:18:33.530]                       }
[10:18:33.530]                       invisible(muffled)
[10:18:33.530]                     }
[10:18:33.530]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.530]                   }
[10:18:33.530]                 }
[10:18:33.530]                 else {
[10:18:33.530]                   if (TRUE) {
[10:18:33.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.530]                     {
[10:18:33.530]                       inherits <- base::inherits
[10:18:33.530]                       invokeRestart <- base::invokeRestart
[10:18:33.530]                       is.null <- base::is.null
[10:18:33.530]                       muffled <- FALSE
[10:18:33.530]                       if (inherits(cond, "message")) {
[10:18:33.530]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.530]                         if (muffled) 
[10:18:33.530]                           invokeRestart("muffleMessage")
[10:18:33.530]                       }
[10:18:33.530]                       else if (inherits(cond, "warning")) {
[10:18:33.530]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.530]                         if (muffled) 
[10:18:33.530]                           invokeRestart("muffleWarning")
[10:18:33.530]                       }
[10:18:33.530]                       else if (inherits(cond, "condition")) {
[10:18:33.530]                         if (!is.null(pattern)) {
[10:18:33.530]                           computeRestarts <- base::computeRestarts
[10:18:33.530]                           grepl <- base::grepl
[10:18:33.530]                           restarts <- computeRestarts(cond)
[10:18:33.530]                           for (restart in restarts) {
[10:18:33.530]                             name <- restart$name
[10:18:33.530]                             if (is.null(name)) 
[10:18:33.530]                               next
[10:18:33.530]                             if (!grepl(pattern, name)) 
[10:18:33.530]                               next
[10:18:33.530]                             invokeRestart(restart)
[10:18:33.530]                             muffled <- TRUE
[10:18:33.530]                             break
[10:18:33.530]                           }
[10:18:33.530]                         }
[10:18:33.530]                       }
[10:18:33.530]                       invisible(muffled)
[10:18:33.530]                     }
[10:18:33.530]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.530]                   }
[10:18:33.530]                 }
[10:18:33.530]             }
[10:18:33.530]         }))
[10:18:33.530]     }, error = function(ex) {
[10:18:33.530]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.530]                 ...future.rng), started = ...future.startTime, 
[10:18:33.530]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.530]             version = "1.8"), class = "FutureResult")
[10:18:33.530]     }, finally = {
[10:18:33.530]         if (!identical(...future.workdir, getwd())) 
[10:18:33.530]             setwd(...future.workdir)
[10:18:33.530]         {
[10:18:33.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.530]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.530]             }
[10:18:33.530]             base::options(...future.oldOptions)
[10:18:33.530]             if (.Platform$OS.type == "windows") {
[10:18:33.530]                 old_names <- names(...future.oldEnvVars)
[10:18:33.530]                 envs <- base::Sys.getenv()
[10:18:33.530]                 names <- names(envs)
[10:18:33.530]                 common <- intersect(names, old_names)
[10:18:33.530]                 added <- setdiff(names, old_names)
[10:18:33.530]                 removed <- setdiff(old_names, names)
[10:18:33.530]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.530]                   envs[common]]
[10:18:33.530]                 NAMES <- toupper(changed)
[10:18:33.530]                 args <- list()
[10:18:33.530]                 for (kk in seq_along(NAMES)) {
[10:18:33.530]                   name <- changed[[kk]]
[10:18:33.530]                   NAME <- NAMES[[kk]]
[10:18:33.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.530]                     next
[10:18:33.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.530]                 }
[10:18:33.530]                 NAMES <- toupper(added)
[10:18:33.530]                 for (kk in seq_along(NAMES)) {
[10:18:33.530]                   name <- added[[kk]]
[10:18:33.530]                   NAME <- NAMES[[kk]]
[10:18:33.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.530]                     next
[10:18:33.530]                   args[[name]] <- ""
[10:18:33.530]                 }
[10:18:33.530]                 NAMES <- toupper(removed)
[10:18:33.530]                 for (kk in seq_along(NAMES)) {
[10:18:33.530]                   name <- removed[[kk]]
[10:18:33.530]                   NAME <- NAMES[[kk]]
[10:18:33.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.530]                     next
[10:18:33.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.530]                 }
[10:18:33.530]                 if (length(args) > 0) 
[10:18:33.530]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.530]             }
[10:18:33.530]             else {
[10:18:33.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.530]             }
[10:18:33.530]             {
[10:18:33.530]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.530]                   0L) {
[10:18:33.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.530]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.530]                   base::options(opts)
[10:18:33.530]                 }
[10:18:33.530]                 {
[10:18:33.530]                   {
[10:18:33.530]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.530]                     NULL
[10:18:33.530]                   }
[10:18:33.530]                   options(future.plan = NULL)
[10:18:33.530]                   if (is.na(NA_character_)) 
[10:18:33.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.530]                     .init = FALSE)
[10:18:33.530]                 }
[10:18:33.530]             }
[10:18:33.530]         }
[10:18:33.530]     })
[10:18:33.530]     if (TRUE) {
[10:18:33.530]         base::sink(type = "output", split = FALSE)
[10:18:33.530]         if (TRUE) {
[10:18:33.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.530]         }
[10:18:33.530]         else {
[10:18:33.530]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.530]         }
[10:18:33.530]         base::close(...future.stdout)
[10:18:33.530]         ...future.stdout <- NULL
[10:18:33.530]     }
[10:18:33.530]     ...future.result$conditions <- ...future.conditions
[10:18:33.530]     ...future.result$finished <- base::Sys.time()
[10:18:33.530]     ...future.result
[10:18:33.530] }
[10:18:33.533] Exporting 5 global objects (2.08 KiB) to cluster node #1 ...
[10:18:33.533] Exporting ‘...future.FUN’ (762 bytes) to cluster node #1 ...
[10:18:33.533] Exporting ‘...future.FUN’ (762 bytes) to cluster node #1 ... DONE
[10:18:33.534] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #1 ...
[10:18:33.534] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #1 ... DONE
[10:18:33.534] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[10:18:33.534] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[10:18:33.535] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:33.535] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.535] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:33.535] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.536] Exporting 5 global objects (2.08 KiB) to cluster node #1 ... DONE
[10:18:33.536] MultisessionFuture started
[10:18:33.536] - Launch lazy future ... done
[10:18:33.536] run() for ‘MultisessionFuture’ ... done
[10:18:33.536] Created future:
[10:18:33.536] MultisessionFuture:
[10:18:33.536] Label: ‘future_by-1’
[10:18:33.536] Expression:
[10:18:33.536] {
[10:18:33.536]     do.call(function(...) {
[10:18:33.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.536]             on.exit(options(oopts), add = TRUE)
[10:18:33.536]         }
[10:18:33.536]         {
[10:18:33.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.536]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.536]             })
[10:18:33.536]         }
[10:18:33.536]     }, args = future.call.arguments)
[10:18:33.536] }
[10:18:33.536] Lazy evaluation: FALSE
[10:18:33.536] Asynchronous evaluation: TRUE
[10:18:33.536] Local evaluation: TRUE
[10:18:33.536] Environment: R_GlobalEnv
[10:18:33.536] Capture standard output: TRUE
[10:18:33.536] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.536] Globals: 5 objects totaling 1.67 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.536] Packages: 1 packages (‘stats’)
[10:18:33.536] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.536] Resolved: FALSE
[10:18:33.536] Value: <not collected>
[10:18:33.536] Conditions captured: <none>
[10:18:33.536] Early signaling: FALSE
[10:18:33.536] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.536] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.548] Chunk #1 of 2 ... DONE
[10:18:33.548] Chunk #2 of 2 ...
[10:18:33.548]  - Finding globals in 'X' for chunk #2 ...
[10:18:33.548] getGlobalsAndPackages() ...
[10:18:33.548] Searching for globals...
[10:18:33.549] 
[10:18:33.549] Searching for globals ... DONE
[10:18:33.549] - globals: [0] <none>
[10:18:33.549] getGlobalsAndPackages() ... DONE
[10:18:33.549]    + additional globals found: [n=0] 
[10:18:33.549]    + additional namespaces needed: [n=0] 
[10:18:33.549]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:33.549]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.549]  - seeds: <none>
[10:18:33.549]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.550] getGlobalsAndPackages() ...
[10:18:33.550] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.550] Resolving globals: FALSE
[10:18:33.550] Tweak future expression to call with '...' arguments ...
[10:18:33.550] {
[10:18:33.550]     do.call(function(...) {
[10:18:33.550]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.550]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.550]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.550]             on.exit(options(oopts), add = TRUE)
[10:18:33.550]         }
[10:18:33.550]         {
[10:18:33.550]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.550]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.550]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.550]             })
[10:18:33.550]         }
[10:18:33.550]     }, args = future.call.arguments)
[10:18:33.550] }
[10:18:33.550] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.551] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.551] 
[10:18:33.551] getGlobalsAndPackages() ... DONE
[10:18:33.551] run() for ‘Future’ ...
[10:18:33.551] - state: ‘created’
[10:18:33.551] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.565]   - Field: ‘node’
[10:18:33.565]   - Field: ‘label’
[10:18:33.565]   - Field: ‘local’
[10:18:33.566]   - Field: ‘owner’
[10:18:33.566]   - Field: ‘envir’
[10:18:33.566]   - Field: ‘workers’
[10:18:33.566]   - Field: ‘packages’
[10:18:33.566]   - Field: ‘gc’
[10:18:33.566]   - Field: ‘conditions’
[10:18:33.566]   - Field: ‘persistent’
[10:18:33.566]   - Field: ‘expr’
[10:18:33.566]   - Field: ‘uuid’
[10:18:33.566]   - Field: ‘seed’
[10:18:33.566]   - Field: ‘version’
[10:18:33.566]   - Field: ‘result’
[10:18:33.567]   - Field: ‘asynchronous’
[10:18:33.567]   - Field: ‘calls’
[10:18:33.567]   - Field: ‘globals’
[10:18:33.567]   - Field: ‘stdout’
[10:18:33.567]   - Field: ‘earlySignal’
[10:18:33.567]   - Field: ‘lazy’
[10:18:33.567]   - Field: ‘state’
[10:18:33.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.567] - Launch lazy future ...
[10:18:33.568] Packages needed by the future expression (n = 1): ‘stats’
[10:18:33.568] Packages needed by future strategies (n = 0): <none>
[10:18:33.568] {
[10:18:33.568]     {
[10:18:33.568]         {
[10:18:33.568]             ...future.startTime <- base::Sys.time()
[10:18:33.568]             {
[10:18:33.568]                 {
[10:18:33.568]                   {
[10:18:33.568]                     {
[10:18:33.568]                       {
[10:18:33.568]                         base::local({
[10:18:33.568]                           has_future <- base::requireNamespace("future", 
[10:18:33.568]                             quietly = TRUE)
[10:18:33.568]                           if (has_future) {
[10:18:33.568]                             ns <- base::getNamespace("future")
[10:18:33.568]                             version <- ns[[".package"]][["version"]]
[10:18:33.568]                             if (is.null(version)) 
[10:18:33.568]                               version <- utils::packageVersion("future")
[10:18:33.568]                           }
[10:18:33.568]                           else {
[10:18:33.568]                             version <- NULL
[10:18:33.568]                           }
[10:18:33.568]                           if (!has_future || version < "1.8.0") {
[10:18:33.568]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.568]                               "", base::R.version$version.string), 
[10:18:33.568]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:33.568]                                 base::R.version$platform, 8 * 
[10:18:33.568]                                   base::.Machine$sizeof.pointer), 
[10:18:33.568]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.568]                                 "release", "version")], collapse = " "), 
[10:18:33.568]                               hostname = base::Sys.info()[["nodename"]])
[10:18:33.568]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.568]                               info)
[10:18:33.568]                             info <- base::paste(info, collapse = "; ")
[10:18:33.568]                             if (!has_future) {
[10:18:33.568]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.568]                                 info)
[10:18:33.568]                             }
[10:18:33.568]                             else {
[10:18:33.568]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.568]                                 info, version)
[10:18:33.568]                             }
[10:18:33.568]                             base::stop(msg)
[10:18:33.568]                           }
[10:18:33.568]                         })
[10:18:33.568]                       }
[10:18:33.568]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.568]                       base::options(mc.cores = 1L)
[10:18:33.568]                     }
[10:18:33.568]                     base::local({
[10:18:33.568]                       for (pkg in "stats") {
[10:18:33.568]                         base::loadNamespace(pkg)
[10:18:33.568]                         base::library(pkg, character.only = TRUE)
[10:18:33.568]                       }
[10:18:33.568]                     })
[10:18:33.568]                   }
[10:18:33.568]                   ...future.strategy.old <- future::plan("list")
[10:18:33.568]                   options(future.plan = NULL)
[10:18:33.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.568]                 }
[10:18:33.568]                 ...future.workdir <- getwd()
[10:18:33.568]             }
[10:18:33.568]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.568]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.568]         }
[10:18:33.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.568]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.568]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.568]             base::names(...future.oldOptions))
[10:18:33.568]     }
[10:18:33.568]     if (FALSE) {
[10:18:33.568]     }
[10:18:33.568]     else {
[10:18:33.568]         if (TRUE) {
[10:18:33.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.568]                 open = "w")
[10:18:33.568]         }
[10:18:33.568]         else {
[10:18:33.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.568]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.568]         }
[10:18:33.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.568]             base::sink(type = "output", split = FALSE)
[10:18:33.568]             base::close(...future.stdout)
[10:18:33.568]         }, add = TRUE)
[10:18:33.568]     }
[10:18:33.568]     ...future.frame <- base::sys.nframe()
[10:18:33.568]     ...future.conditions <- base::list()
[10:18:33.568]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.568]     if (FALSE) {
[10:18:33.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.568]     }
[10:18:33.568]     ...future.result <- base::tryCatch({
[10:18:33.568]         base::withCallingHandlers({
[10:18:33.568]             ...future.value <- base::withVisible(base::local({
[10:18:33.568]                 ...future.makeSendCondition <- base::local({
[10:18:33.568]                   sendCondition <- NULL
[10:18:33.568]                   function(frame = 1L) {
[10:18:33.568]                     if (is.function(sendCondition)) 
[10:18:33.568]                       return(sendCondition)
[10:18:33.568]                     ns <- getNamespace("parallel")
[10:18:33.568]                     if (exists("sendData", mode = "function", 
[10:18:33.568]                       envir = ns)) {
[10:18:33.568]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.568]                         envir = ns)
[10:18:33.568]                       envir <- sys.frame(frame)
[10:18:33.568]                       master <- NULL
[10:18:33.568]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.568]                         !identical(envir, emptyenv())) {
[10:18:33.568]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.568]                           inherits = FALSE)) {
[10:18:33.568]                           master <- get("master", mode = "list", 
[10:18:33.568]                             envir = envir, inherits = FALSE)
[10:18:33.568]                           if (inherits(master, c("SOCKnode", 
[10:18:33.568]                             "SOCK0node"))) {
[10:18:33.568]                             sendCondition <<- function(cond) {
[10:18:33.568]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.568]                                 success = TRUE)
[10:18:33.568]                               parallel_sendData(master, data)
[10:18:33.568]                             }
[10:18:33.568]                             return(sendCondition)
[10:18:33.568]                           }
[10:18:33.568]                         }
[10:18:33.568]                         frame <- frame + 1L
[10:18:33.568]                         envir <- sys.frame(frame)
[10:18:33.568]                       }
[10:18:33.568]                     }
[10:18:33.568]                     sendCondition <<- function(cond) NULL
[10:18:33.568]                   }
[10:18:33.568]                 })
[10:18:33.568]                 withCallingHandlers({
[10:18:33.568]                   {
[10:18:33.568]                     do.call(function(...) {
[10:18:33.568]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.568]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.568]                         ...future.globals.maxSize)) {
[10:18:33.568]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.568]                         on.exit(options(oopts), add = TRUE)
[10:18:33.568]                       }
[10:18:33.568]                       {
[10:18:33.568]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.568]                           FUN = function(jj) {
[10:18:33.568]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.568]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.568]                           })
[10:18:33.568]                       }
[10:18:33.568]                     }, args = future.call.arguments)
[10:18:33.568]                   }
[10:18:33.568]                 }, immediateCondition = function(cond) {
[10:18:33.568]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.568]                   sendCondition(cond)
[10:18:33.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.568]                   {
[10:18:33.568]                     inherits <- base::inherits
[10:18:33.568]                     invokeRestart <- base::invokeRestart
[10:18:33.568]                     is.null <- base::is.null
[10:18:33.568]                     muffled <- FALSE
[10:18:33.568]                     if (inherits(cond, "message")) {
[10:18:33.568]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.568]                       if (muffled) 
[10:18:33.568]                         invokeRestart("muffleMessage")
[10:18:33.568]                     }
[10:18:33.568]                     else if (inherits(cond, "warning")) {
[10:18:33.568]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.568]                       if (muffled) 
[10:18:33.568]                         invokeRestart("muffleWarning")
[10:18:33.568]                     }
[10:18:33.568]                     else if (inherits(cond, "condition")) {
[10:18:33.568]                       if (!is.null(pattern)) {
[10:18:33.568]                         computeRestarts <- base::computeRestarts
[10:18:33.568]                         grepl <- base::grepl
[10:18:33.568]                         restarts <- computeRestarts(cond)
[10:18:33.568]                         for (restart in restarts) {
[10:18:33.568]                           name <- restart$name
[10:18:33.568]                           if (is.null(name)) 
[10:18:33.568]                             next
[10:18:33.568]                           if (!grepl(pattern, name)) 
[10:18:33.568]                             next
[10:18:33.568]                           invokeRestart(restart)
[10:18:33.568]                           muffled <- TRUE
[10:18:33.568]                           break
[10:18:33.568]                         }
[10:18:33.568]                       }
[10:18:33.568]                     }
[10:18:33.568]                     invisible(muffled)
[10:18:33.568]                   }
[10:18:33.568]                   muffleCondition(cond)
[10:18:33.568]                 })
[10:18:33.568]             }))
[10:18:33.568]             future::FutureResult(value = ...future.value$value, 
[10:18:33.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.568]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.568]                     ...future.globalenv.names))
[10:18:33.568]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.568]         }, condition = base::local({
[10:18:33.568]             c <- base::c
[10:18:33.568]             inherits <- base::inherits
[10:18:33.568]             invokeRestart <- base::invokeRestart
[10:18:33.568]             length <- base::length
[10:18:33.568]             list <- base::list
[10:18:33.568]             seq.int <- base::seq.int
[10:18:33.568]             signalCondition <- base::signalCondition
[10:18:33.568]             sys.calls <- base::sys.calls
[10:18:33.568]             `[[` <- base::`[[`
[10:18:33.568]             `+` <- base::`+`
[10:18:33.568]             `<<-` <- base::`<<-`
[10:18:33.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.568]                   3L)]
[10:18:33.568]             }
[10:18:33.568]             function(cond) {
[10:18:33.568]                 is_error <- inherits(cond, "error")
[10:18:33.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.568]                   NULL)
[10:18:33.568]                 if (is_error) {
[10:18:33.568]                   sessionInformation <- function() {
[10:18:33.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.568]                       search = base::search(), system = base::Sys.info())
[10:18:33.568]                   }
[10:18:33.568]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.568]                     cond$call), session = sessionInformation(), 
[10:18:33.568]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.568]                   signalCondition(cond)
[10:18:33.568]                 }
[10:18:33.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.568]                 "immediateCondition"))) {
[10:18:33.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.568]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.568]                   if (TRUE && !signal) {
[10:18:33.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.568]                     {
[10:18:33.568]                       inherits <- base::inherits
[10:18:33.568]                       invokeRestart <- base::invokeRestart
[10:18:33.568]                       is.null <- base::is.null
[10:18:33.568]                       muffled <- FALSE
[10:18:33.568]                       if (inherits(cond, "message")) {
[10:18:33.568]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.568]                         if (muffled) 
[10:18:33.568]                           invokeRestart("muffleMessage")
[10:18:33.568]                       }
[10:18:33.568]                       else if (inherits(cond, "warning")) {
[10:18:33.568]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.568]                         if (muffled) 
[10:18:33.568]                           invokeRestart("muffleWarning")
[10:18:33.568]                       }
[10:18:33.568]                       else if (inherits(cond, "condition")) {
[10:18:33.568]                         if (!is.null(pattern)) {
[10:18:33.568]                           computeRestarts <- base::computeRestarts
[10:18:33.568]                           grepl <- base::grepl
[10:18:33.568]                           restarts <- computeRestarts(cond)
[10:18:33.568]                           for (restart in restarts) {
[10:18:33.568]                             name <- restart$name
[10:18:33.568]                             if (is.null(name)) 
[10:18:33.568]                               next
[10:18:33.568]                             if (!grepl(pattern, name)) 
[10:18:33.568]                               next
[10:18:33.568]                             invokeRestart(restart)
[10:18:33.568]                             muffled <- TRUE
[10:18:33.568]                             break
[10:18:33.568]                           }
[10:18:33.568]                         }
[10:18:33.568]                       }
[10:18:33.568]                       invisible(muffled)
[10:18:33.568]                     }
[10:18:33.568]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.568]                   }
[10:18:33.568]                 }
[10:18:33.568]                 else {
[10:18:33.568]                   if (TRUE) {
[10:18:33.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.568]                     {
[10:18:33.568]                       inherits <- base::inherits
[10:18:33.568]                       invokeRestart <- base::invokeRestart
[10:18:33.568]                       is.null <- base::is.null
[10:18:33.568]                       muffled <- FALSE
[10:18:33.568]                       if (inherits(cond, "message")) {
[10:18:33.568]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.568]                         if (muffled) 
[10:18:33.568]                           invokeRestart("muffleMessage")
[10:18:33.568]                       }
[10:18:33.568]                       else if (inherits(cond, "warning")) {
[10:18:33.568]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.568]                         if (muffled) 
[10:18:33.568]                           invokeRestart("muffleWarning")
[10:18:33.568]                       }
[10:18:33.568]                       else if (inherits(cond, "condition")) {
[10:18:33.568]                         if (!is.null(pattern)) {
[10:18:33.568]                           computeRestarts <- base::computeRestarts
[10:18:33.568]                           grepl <- base::grepl
[10:18:33.568]                           restarts <- computeRestarts(cond)
[10:18:33.568]                           for (restart in restarts) {
[10:18:33.568]                             name <- restart$name
[10:18:33.568]                             if (is.null(name)) 
[10:18:33.568]                               next
[10:18:33.568]                             if (!grepl(pattern, name)) 
[10:18:33.568]                               next
[10:18:33.568]                             invokeRestart(restart)
[10:18:33.568]                             muffled <- TRUE
[10:18:33.568]                             break
[10:18:33.568]                           }
[10:18:33.568]                         }
[10:18:33.568]                       }
[10:18:33.568]                       invisible(muffled)
[10:18:33.568]                     }
[10:18:33.568]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.568]                   }
[10:18:33.568]                 }
[10:18:33.568]             }
[10:18:33.568]         }))
[10:18:33.568]     }, error = function(ex) {
[10:18:33.568]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.568]                 ...future.rng), started = ...future.startTime, 
[10:18:33.568]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.568]             version = "1.8"), class = "FutureResult")
[10:18:33.568]     }, finally = {
[10:18:33.568]         if (!identical(...future.workdir, getwd())) 
[10:18:33.568]             setwd(...future.workdir)
[10:18:33.568]         {
[10:18:33.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.568]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.568]             }
[10:18:33.568]             base::options(...future.oldOptions)
[10:18:33.568]             if (.Platform$OS.type == "windows") {
[10:18:33.568]                 old_names <- names(...future.oldEnvVars)
[10:18:33.568]                 envs <- base::Sys.getenv()
[10:18:33.568]                 names <- names(envs)
[10:18:33.568]                 common <- intersect(names, old_names)
[10:18:33.568]                 added <- setdiff(names, old_names)
[10:18:33.568]                 removed <- setdiff(old_names, names)
[10:18:33.568]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.568]                   envs[common]]
[10:18:33.568]                 NAMES <- toupper(changed)
[10:18:33.568]                 args <- list()
[10:18:33.568]                 for (kk in seq_along(NAMES)) {
[10:18:33.568]                   name <- changed[[kk]]
[10:18:33.568]                   NAME <- NAMES[[kk]]
[10:18:33.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.568]                     next
[10:18:33.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.568]                 }
[10:18:33.568]                 NAMES <- toupper(added)
[10:18:33.568]                 for (kk in seq_along(NAMES)) {
[10:18:33.568]                   name <- added[[kk]]
[10:18:33.568]                   NAME <- NAMES[[kk]]
[10:18:33.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.568]                     next
[10:18:33.568]                   args[[name]] <- ""
[10:18:33.568]                 }
[10:18:33.568]                 NAMES <- toupper(removed)
[10:18:33.568]                 for (kk in seq_along(NAMES)) {
[10:18:33.568]                   name <- removed[[kk]]
[10:18:33.568]                   NAME <- NAMES[[kk]]
[10:18:33.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.568]                     next
[10:18:33.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.568]                 }
[10:18:33.568]                 if (length(args) > 0) 
[10:18:33.568]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.568]             }
[10:18:33.568]             else {
[10:18:33.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.568]             }
[10:18:33.568]             {
[10:18:33.568]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.568]                   0L) {
[10:18:33.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.568]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.568]                   base::options(opts)
[10:18:33.568]                 }
[10:18:33.568]                 {
[10:18:33.568]                   {
[10:18:33.568]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.568]                     NULL
[10:18:33.568]                   }
[10:18:33.568]                   options(future.plan = NULL)
[10:18:33.568]                   if (is.na(NA_character_)) 
[10:18:33.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.568]                     .init = FALSE)
[10:18:33.568]                 }
[10:18:33.568]             }
[10:18:33.568]         }
[10:18:33.568]     })
[10:18:33.568]     if (TRUE) {
[10:18:33.568]         base::sink(type = "output", split = FALSE)
[10:18:33.568]         if (TRUE) {
[10:18:33.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.568]         }
[10:18:33.568]         else {
[10:18:33.568]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.568]         }
[10:18:33.568]         base::close(...future.stdout)
[10:18:33.568]         ...future.stdout <- NULL
[10:18:33.568]     }
[10:18:33.568]     ...future.result$conditions <- ...future.conditions
[10:18:33.568]     ...future.result$finished <- base::Sys.time()
[10:18:33.568]     ...future.result
[10:18:33.568] }
[10:18:33.571] Exporting 5 global objects (2.72 KiB) to cluster node #2 ...
[10:18:33.571] Exporting ‘...future.FUN’ (762 bytes) to cluster node #2 ...
[10:18:33.572] Exporting ‘...future.FUN’ (762 bytes) to cluster node #2 ... DONE
[10:18:33.572] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #2 ...
[10:18:33.572] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #2 ... DONE
[10:18:33.572] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[10:18:33.573] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[10:18:33.573] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:33.573] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.573] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:33.573] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.574] Exporting 5 global objects (2.72 KiB) to cluster node #2 ... DONE
[10:18:33.574] MultisessionFuture started
[10:18:33.574] - Launch lazy future ... done
[10:18:33.574] run() for ‘MultisessionFuture’ ... done
[10:18:33.574] Created future:
[10:18:33.574] MultisessionFuture:
[10:18:33.574] Label: ‘future_by-2’
[10:18:33.574] Expression:
[10:18:33.574] {
[10:18:33.574]     do.call(function(...) {
[10:18:33.574]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.574]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.574]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.574]             on.exit(options(oopts), add = TRUE)
[10:18:33.574]         }
[10:18:33.574]         {
[10:18:33.574]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.574]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.574]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.574]             })
[10:18:33.574]         }
[10:18:33.574]     }, args = future.call.arguments)
[10:18:33.574] }
[10:18:33.574] Lazy evaluation: FALSE
[10:18:33.574] Asynchronous evaluation: TRUE
[10:18:33.574] Local evaluation: TRUE
[10:18:33.574] Environment: R_GlobalEnv
[10:18:33.574] Capture standard output: TRUE
[10:18:33.574] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.574] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.574] Packages: 1 packages (‘stats’)
[10:18:33.574] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.574] Resolved: FALSE
[10:18:33.574] Value: <not collected>
[10:18:33.574] Conditions captured: <none>
[10:18:33.574] Early signaling: FALSE
[10:18:33.574] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.574] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.586] Chunk #2 of 2 ... DONE
[10:18:33.586] Launching 2 futures (chunks) ... DONE
[10:18:33.586] Resolving 2 futures (chunks) ...
[10:18:33.586] resolve() on list ...
[10:18:33.586]  recursive: 0
[10:18:33.587]  length: 2
[10:18:33.589] 
[10:18:33.590] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.590] - Validating connection of MultisessionFuture
[10:18:33.590] - received message: FutureResult
[10:18:33.590] - Received FutureResult
[10:18:33.590] - Erased future from FutureRegistry
[10:18:33.590] result() for ClusterFuture ...
[10:18:33.590] - result already collected: FutureResult
[10:18:33.590] result() for ClusterFuture ... done
[10:18:33.590] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.591] Future #1
[10:18:33.591] result() for ClusterFuture ...
[10:18:33.591] - result already collected: FutureResult
[10:18:33.591] result() for ClusterFuture ... done
[10:18:33.591] result() for ClusterFuture ...
[10:18:33.591] - result already collected: FutureResult
[10:18:33.591] result() for ClusterFuture ... done
[10:18:33.591] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:33.591] - nx: 2
[10:18:33.591] - relay: TRUE
[10:18:33.591] - stdout: TRUE
[10:18:33.591] - signal: TRUE
[10:18:33.592] - resignal: FALSE
[10:18:33.592] - force: TRUE
[10:18:33.592] - relayed: [n=2] FALSE, FALSE
[10:18:33.592] - queued futures: [n=2] FALSE, FALSE
[10:18:33.592]  - until=1
[10:18:33.592]  - relaying element #1
[10:18:33.592] result() for ClusterFuture ...
[10:18:33.592] - result already collected: FutureResult
[10:18:33.592] result() for ClusterFuture ... done
[10:18:33.592] result() for ClusterFuture ...
[10:18:33.592] - result already collected: FutureResult
[10:18:33.592] result() for ClusterFuture ... done
[10:18:33.593] result() for ClusterFuture ...
[10:18:33.593] - result already collected: FutureResult
[10:18:33.593] result() for ClusterFuture ... done
[10:18:33.593] result() for ClusterFuture ...
[10:18:33.593] - result already collected: FutureResult
[10:18:33.593] result() for ClusterFuture ... done
[10:18:33.593] - relayed: [n=2] TRUE, FALSE
[10:18:33.593] - queued futures: [n=2] TRUE, FALSE
[10:18:33.593] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:33.593]  length: 1 (resolved future 1)
[10:18:33.620] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.620] - Validating connection of MultisessionFuture
[10:18:33.620] - received message: FutureResult
[10:18:33.621] - Received FutureResult
[10:18:33.621] - Erased future from FutureRegistry
[10:18:33.621] result() for ClusterFuture ...
[10:18:33.621] - result already collected: FutureResult
[10:18:33.621] result() for ClusterFuture ... done
[10:18:33.621] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.621] Future #2
[10:18:33.621] result() for ClusterFuture ...
[10:18:33.621] - result already collected: FutureResult
[10:18:33.621] result() for ClusterFuture ... done
[10:18:33.621] result() for ClusterFuture ...
[10:18:33.621] - result already collected: FutureResult
[10:18:33.622] result() for ClusterFuture ... done
[10:18:33.622] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:33.622] - nx: 2
[10:18:33.622] - relay: TRUE
[10:18:33.622] - stdout: TRUE
[10:18:33.622] - signal: TRUE
[10:18:33.622] - resignal: FALSE
[10:18:33.622] - force: TRUE
[10:18:33.622] - relayed: [n=2] TRUE, FALSE
[10:18:33.622] - queued futures: [n=2] TRUE, FALSE
[10:18:33.622]  - until=2
[10:18:33.622]  - relaying element #2
[10:18:33.623] result() for ClusterFuture ...
[10:18:33.623] - result already collected: FutureResult
[10:18:33.623] result() for ClusterFuture ... done
[10:18:33.623] result() for ClusterFuture ...
[10:18:33.623] - result already collected: FutureResult
[10:18:33.623] result() for ClusterFuture ... done
[10:18:33.623] result() for ClusterFuture ...
[10:18:33.623] - result already collected: FutureResult
[10:18:33.623] result() for ClusterFuture ... done
[10:18:33.623] result() for ClusterFuture ...
[10:18:33.623] - result already collected: FutureResult
[10:18:33.623] result() for ClusterFuture ... done
[10:18:33.623] - relayed: [n=2] TRUE, TRUE
[10:18:33.624] - queued futures: [n=2] TRUE, TRUE
[10:18:33.624] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:33.624]  length: 0 (resolved future 2)
[10:18:33.624] Relaying remaining futures
[10:18:33.624] signalConditionsASAP(NULL, pos=0) ...
[10:18:33.624] - nx: 2
[10:18:33.624] - relay: TRUE
[10:18:33.624] - stdout: TRUE
[10:18:33.624] - signal: TRUE
[10:18:33.624] - resignal: FALSE
[10:18:33.624] - force: TRUE
[10:18:33.624] - relayed: [n=2] TRUE, TRUE
[10:18:33.625] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:33.625] - relayed: [n=2] TRUE, TRUE
[10:18:33.625] - queued futures: [n=2] TRUE, TRUE
[10:18:33.625] signalConditionsASAP(NULL, pos=0) ... done
[10:18:33.625] resolve() on list ... DONE
[10:18:33.625] result() for ClusterFuture ...
[10:18:33.625] - result already collected: FutureResult
[10:18:33.625] result() for ClusterFuture ... done
[10:18:33.625] result() for ClusterFuture ...
[10:18:33.625] - result already collected: FutureResult
[10:18:33.625] result() for ClusterFuture ... done
[10:18:33.626] result() for ClusterFuture ...
[10:18:33.626] - result already collected: FutureResult
[10:18:33.626] result() for ClusterFuture ... done
[10:18:33.626] result() for ClusterFuture ...
[10:18:33.626] - result already collected: FutureResult
[10:18:33.626] result() for ClusterFuture ... done
[10:18:33.626]  - Number of value chunks collected: 2
[10:18:33.626] Resolving 2 futures (chunks) ... DONE
[10:18:33.626] Reducing values from 2 chunks ...
[10:18:33.626]  - Number of values collected after concatenation: 3
[10:18:33.626]  - Number of values expected: 3
[10:18:33.626] Reducing values from 2 chunks ... DONE
[10:18:33.627] future_lapply() ... DONE
[10:18:33.627] future_by_internal() ... DONE
[10:18:33.630] future_by_internal() ...
[10:18:33.631] future_lapply() ...
[10:18:33.633] Number of chunks: 2
[10:18:33.633] getGlobalsAndPackagesXApply() ...
[10:18:33.634]  - future.globals: TRUE
[10:18:33.634] getGlobalsAndPackages() ...
[10:18:33.634] Searching for globals...
[10:18:33.635] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:18:33.636] Searching for globals ... DONE
[10:18:33.636] Resolving globals: FALSE
[10:18:33.636] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[10:18:33.637] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[10:18:33.637] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:33.637] - packages: [1] ‘stats’
[10:18:33.637] getGlobalsAndPackages() ... DONE
[10:18:33.637]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:18:33.637]  - needed namespaces: [n=1] ‘stats’
[10:18:33.637] Finding globals ... DONE
[10:18:33.637]  - use_args: TRUE
[10:18:33.637]  - Getting '...' globals ...
[10:18:33.638] resolve() on list ...
[10:18:33.638]  recursive: 0
[10:18:33.638]  length: 1
[10:18:33.638]  elements: ‘...’
[10:18:33.638]  length: 0 (resolved future 1)
[10:18:33.638] resolve() on list ... DONE
[10:18:33.638]    - '...' content: [n=0] 
[10:18:33.638] List of 1
[10:18:33.638]  $ ...: list()
[10:18:33.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.638]  - attr(*, "where")=List of 1
[10:18:33.638]   ..$ ...:<environment: 0x55844c2bda98> 
[10:18:33.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.638]  - attr(*, "resolved")= logi TRUE
[10:18:33.638]  - attr(*, "total_size")= num NA
[10:18:33.641]  - Getting '...' globals ... DONE
[10:18:33.641] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:18:33.641] List of 4
[10:18:33.641]  $ ...future.FUN:function (x)  
[10:18:33.641]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:18:33.641]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:18:33.641]  $ ...          : list()
[10:18:33.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.641]  - attr(*, "where")=List of 4
[10:18:33.641]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:33.641]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:18:33.641]   ..$ wool         :<environment: R_EmptyEnv> 
[10:18:33.641]   ..$ ...          :<environment: 0x55844c2bda98> 
[10:18:33.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.641]  - attr(*, "resolved")= logi FALSE
[10:18:33.641]  - attr(*, "total_size")= num 18867
[10:18:33.645] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:33.645] getGlobalsAndPackagesXApply() ... DONE
[10:18:33.645] Number of futures (= number of chunks): 2
[10:18:33.645] Launching 2 futures (chunks) ...
[10:18:33.645] Chunk #1 of 2 ...
[10:18:33.645]  - Finding globals in 'X' for chunk #1 ...
[10:18:33.645] getGlobalsAndPackages() ...
[10:18:33.645] Searching for globals...
[10:18:33.646] 
[10:18:33.646] Searching for globals ... DONE
[10:18:33.646] - globals: [0] <none>
[10:18:33.646] getGlobalsAndPackages() ... DONE
[10:18:33.646]    + additional globals found: [n=0] 
[10:18:33.646]    + additional namespaces needed: [n=0] 
[10:18:33.646]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:33.646]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.646]  - seeds: <none>
[10:18:33.646]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.647] getGlobalsAndPackages() ...
[10:18:33.647] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.647] Resolving globals: FALSE
[10:18:33.647] Tweak future expression to call with '...' arguments ...
[10:18:33.647] {
[10:18:33.647]     do.call(function(...) {
[10:18:33.647]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.647]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.647]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.647]             on.exit(options(oopts), add = TRUE)
[10:18:33.647]         }
[10:18:33.647]         {
[10:18:33.647]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.647]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.647]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.647]             })
[10:18:33.647]         }
[10:18:33.647]     }, args = future.call.arguments)
[10:18:33.647] }
[10:18:33.647] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.648] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.648] 
[10:18:33.648] getGlobalsAndPackages() ... DONE
[10:18:33.648] run() for ‘Future’ ...
[10:18:33.648] - state: ‘created’
[10:18:33.648] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.662] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.662]   - Field: ‘node’
[10:18:33.662]   - Field: ‘label’
[10:18:33.663]   - Field: ‘local’
[10:18:33.663]   - Field: ‘owner’
[10:18:33.663]   - Field: ‘envir’
[10:18:33.663]   - Field: ‘workers’
[10:18:33.663]   - Field: ‘packages’
[10:18:33.663]   - Field: ‘gc’
[10:18:33.663]   - Field: ‘conditions’
[10:18:33.663]   - Field: ‘persistent’
[10:18:33.663]   - Field: ‘expr’
[10:18:33.663]   - Field: ‘uuid’
[10:18:33.663]   - Field: ‘seed’
[10:18:33.663]   - Field: ‘version’
[10:18:33.664]   - Field: ‘result’
[10:18:33.664]   - Field: ‘asynchronous’
[10:18:33.664]   - Field: ‘calls’
[10:18:33.664]   - Field: ‘globals’
[10:18:33.664]   - Field: ‘stdout’
[10:18:33.664]   - Field: ‘earlySignal’
[10:18:33.664]   - Field: ‘lazy’
[10:18:33.664]   - Field: ‘state’
[10:18:33.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.664] - Launch lazy future ...
[10:18:33.665] Packages needed by the future expression (n = 1): ‘stats’
[10:18:33.665] Packages needed by future strategies (n = 0): <none>
[10:18:33.665] {
[10:18:33.665]     {
[10:18:33.665]         {
[10:18:33.665]             ...future.startTime <- base::Sys.time()
[10:18:33.665]             {
[10:18:33.665]                 {
[10:18:33.665]                   {
[10:18:33.665]                     {
[10:18:33.665]                       {
[10:18:33.665]                         base::local({
[10:18:33.665]                           has_future <- base::requireNamespace("future", 
[10:18:33.665]                             quietly = TRUE)
[10:18:33.665]                           if (has_future) {
[10:18:33.665]                             ns <- base::getNamespace("future")
[10:18:33.665]                             version <- ns[[".package"]][["version"]]
[10:18:33.665]                             if (is.null(version)) 
[10:18:33.665]                               version <- utils::packageVersion("future")
[10:18:33.665]                           }
[10:18:33.665]                           else {
[10:18:33.665]                             version <- NULL
[10:18:33.665]                           }
[10:18:33.665]                           if (!has_future || version < "1.8.0") {
[10:18:33.665]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.665]                               "", base::R.version$version.string), 
[10:18:33.665]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:33.665]                                 base::R.version$platform, 8 * 
[10:18:33.665]                                   base::.Machine$sizeof.pointer), 
[10:18:33.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.665]                                 "release", "version")], collapse = " "), 
[10:18:33.665]                               hostname = base::Sys.info()[["nodename"]])
[10:18:33.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.665]                               info)
[10:18:33.665]                             info <- base::paste(info, collapse = "; ")
[10:18:33.665]                             if (!has_future) {
[10:18:33.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.665]                                 info)
[10:18:33.665]                             }
[10:18:33.665]                             else {
[10:18:33.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.665]                                 info, version)
[10:18:33.665]                             }
[10:18:33.665]                             base::stop(msg)
[10:18:33.665]                           }
[10:18:33.665]                         })
[10:18:33.665]                       }
[10:18:33.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.665]                       base::options(mc.cores = 1L)
[10:18:33.665]                     }
[10:18:33.665]                     base::local({
[10:18:33.665]                       for (pkg in "stats") {
[10:18:33.665]                         base::loadNamespace(pkg)
[10:18:33.665]                         base::library(pkg, character.only = TRUE)
[10:18:33.665]                       }
[10:18:33.665]                     })
[10:18:33.665]                   }
[10:18:33.665]                   ...future.strategy.old <- future::plan("list")
[10:18:33.665]                   options(future.plan = NULL)
[10:18:33.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.665]                 }
[10:18:33.665]                 ...future.workdir <- getwd()
[10:18:33.665]             }
[10:18:33.665]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.665]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.665]         }
[10:18:33.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.665]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.665]             base::names(...future.oldOptions))
[10:18:33.665]     }
[10:18:33.665]     if (FALSE) {
[10:18:33.665]     }
[10:18:33.665]     else {
[10:18:33.665]         if (TRUE) {
[10:18:33.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.665]                 open = "w")
[10:18:33.665]         }
[10:18:33.665]         else {
[10:18:33.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.665]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.665]         }
[10:18:33.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.665]             base::sink(type = "output", split = FALSE)
[10:18:33.665]             base::close(...future.stdout)
[10:18:33.665]         }, add = TRUE)
[10:18:33.665]     }
[10:18:33.665]     ...future.frame <- base::sys.nframe()
[10:18:33.665]     ...future.conditions <- base::list()
[10:18:33.665]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.665]     if (FALSE) {
[10:18:33.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.665]     }
[10:18:33.665]     ...future.result <- base::tryCatch({
[10:18:33.665]         base::withCallingHandlers({
[10:18:33.665]             ...future.value <- base::withVisible(base::local({
[10:18:33.665]                 ...future.makeSendCondition <- base::local({
[10:18:33.665]                   sendCondition <- NULL
[10:18:33.665]                   function(frame = 1L) {
[10:18:33.665]                     if (is.function(sendCondition)) 
[10:18:33.665]                       return(sendCondition)
[10:18:33.665]                     ns <- getNamespace("parallel")
[10:18:33.665]                     if (exists("sendData", mode = "function", 
[10:18:33.665]                       envir = ns)) {
[10:18:33.665]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.665]                         envir = ns)
[10:18:33.665]                       envir <- sys.frame(frame)
[10:18:33.665]                       master <- NULL
[10:18:33.665]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.665]                         !identical(envir, emptyenv())) {
[10:18:33.665]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.665]                           inherits = FALSE)) {
[10:18:33.665]                           master <- get("master", mode = "list", 
[10:18:33.665]                             envir = envir, inherits = FALSE)
[10:18:33.665]                           if (inherits(master, c("SOCKnode", 
[10:18:33.665]                             "SOCK0node"))) {
[10:18:33.665]                             sendCondition <<- function(cond) {
[10:18:33.665]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.665]                                 success = TRUE)
[10:18:33.665]                               parallel_sendData(master, data)
[10:18:33.665]                             }
[10:18:33.665]                             return(sendCondition)
[10:18:33.665]                           }
[10:18:33.665]                         }
[10:18:33.665]                         frame <- frame + 1L
[10:18:33.665]                         envir <- sys.frame(frame)
[10:18:33.665]                       }
[10:18:33.665]                     }
[10:18:33.665]                     sendCondition <<- function(cond) NULL
[10:18:33.665]                   }
[10:18:33.665]                 })
[10:18:33.665]                 withCallingHandlers({
[10:18:33.665]                   {
[10:18:33.665]                     do.call(function(...) {
[10:18:33.665]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.665]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.665]                         ...future.globals.maxSize)) {
[10:18:33.665]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.665]                         on.exit(options(oopts), add = TRUE)
[10:18:33.665]                       }
[10:18:33.665]                       {
[10:18:33.665]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.665]                           FUN = function(jj) {
[10:18:33.665]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.665]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.665]                           })
[10:18:33.665]                       }
[10:18:33.665]                     }, args = future.call.arguments)
[10:18:33.665]                   }
[10:18:33.665]                 }, immediateCondition = function(cond) {
[10:18:33.665]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.665]                   sendCondition(cond)
[10:18:33.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.665]                   {
[10:18:33.665]                     inherits <- base::inherits
[10:18:33.665]                     invokeRestart <- base::invokeRestart
[10:18:33.665]                     is.null <- base::is.null
[10:18:33.665]                     muffled <- FALSE
[10:18:33.665]                     if (inherits(cond, "message")) {
[10:18:33.665]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.665]                       if (muffled) 
[10:18:33.665]                         invokeRestart("muffleMessage")
[10:18:33.665]                     }
[10:18:33.665]                     else if (inherits(cond, "warning")) {
[10:18:33.665]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.665]                       if (muffled) 
[10:18:33.665]                         invokeRestart("muffleWarning")
[10:18:33.665]                     }
[10:18:33.665]                     else if (inherits(cond, "condition")) {
[10:18:33.665]                       if (!is.null(pattern)) {
[10:18:33.665]                         computeRestarts <- base::computeRestarts
[10:18:33.665]                         grepl <- base::grepl
[10:18:33.665]                         restarts <- computeRestarts(cond)
[10:18:33.665]                         for (restart in restarts) {
[10:18:33.665]                           name <- restart$name
[10:18:33.665]                           if (is.null(name)) 
[10:18:33.665]                             next
[10:18:33.665]                           if (!grepl(pattern, name)) 
[10:18:33.665]                             next
[10:18:33.665]                           invokeRestart(restart)
[10:18:33.665]                           muffled <- TRUE
[10:18:33.665]                           break
[10:18:33.665]                         }
[10:18:33.665]                       }
[10:18:33.665]                     }
[10:18:33.665]                     invisible(muffled)
[10:18:33.665]                   }
[10:18:33.665]                   muffleCondition(cond)
[10:18:33.665]                 })
[10:18:33.665]             }))
[10:18:33.665]             future::FutureResult(value = ...future.value$value, 
[10:18:33.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.665]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.665]                     ...future.globalenv.names))
[10:18:33.665]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.665]         }, condition = base::local({
[10:18:33.665]             c <- base::c
[10:18:33.665]             inherits <- base::inherits
[10:18:33.665]             invokeRestart <- base::invokeRestart
[10:18:33.665]             length <- base::length
[10:18:33.665]             list <- base::list
[10:18:33.665]             seq.int <- base::seq.int
[10:18:33.665]             signalCondition <- base::signalCondition
[10:18:33.665]             sys.calls <- base::sys.calls
[10:18:33.665]             `[[` <- base::`[[`
[10:18:33.665]             `+` <- base::`+`
[10:18:33.665]             `<<-` <- base::`<<-`
[10:18:33.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.665]                   3L)]
[10:18:33.665]             }
[10:18:33.665]             function(cond) {
[10:18:33.665]                 is_error <- inherits(cond, "error")
[10:18:33.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.665]                   NULL)
[10:18:33.665]                 if (is_error) {
[10:18:33.665]                   sessionInformation <- function() {
[10:18:33.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.665]                       search = base::search(), system = base::Sys.info())
[10:18:33.665]                   }
[10:18:33.665]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.665]                     cond$call), session = sessionInformation(), 
[10:18:33.665]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.665]                   signalCondition(cond)
[10:18:33.665]                 }
[10:18:33.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.665]                 "immediateCondition"))) {
[10:18:33.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.665]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.665]                   if (TRUE && !signal) {
[10:18:33.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.665]                     {
[10:18:33.665]                       inherits <- base::inherits
[10:18:33.665]                       invokeRestart <- base::invokeRestart
[10:18:33.665]                       is.null <- base::is.null
[10:18:33.665]                       muffled <- FALSE
[10:18:33.665]                       if (inherits(cond, "message")) {
[10:18:33.665]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.665]                         if (muffled) 
[10:18:33.665]                           invokeRestart("muffleMessage")
[10:18:33.665]                       }
[10:18:33.665]                       else if (inherits(cond, "warning")) {
[10:18:33.665]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.665]                         if (muffled) 
[10:18:33.665]                           invokeRestart("muffleWarning")
[10:18:33.665]                       }
[10:18:33.665]                       else if (inherits(cond, "condition")) {
[10:18:33.665]                         if (!is.null(pattern)) {
[10:18:33.665]                           computeRestarts <- base::computeRestarts
[10:18:33.665]                           grepl <- base::grepl
[10:18:33.665]                           restarts <- computeRestarts(cond)
[10:18:33.665]                           for (restart in restarts) {
[10:18:33.665]                             name <- restart$name
[10:18:33.665]                             if (is.null(name)) 
[10:18:33.665]                               next
[10:18:33.665]                             if (!grepl(pattern, name)) 
[10:18:33.665]                               next
[10:18:33.665]                             invokeRestart(restart)
[10:18:33.665]                             muffled <- TRUE
[10:18:33.665]                             break
[10:18:33.665]                           }
[10:18:33.665]                         }
[10:18:33.665]                       }
[10:18:33.665]                       invisible(muffled)
[10:18:33.665]                     }
[10:18:33.665]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.665]                   }
[10:18:33.665]                 }
[10:18:33.665]                 else {
[10:18:33.665]                   if (TRUE) {
[10:18:33.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.665]                     {
[10:18:33.665]                       inherits <- base::inherits
[10:18:33.665]                       invokeRestart <- base::invokeRestart
[10:18:33.665]                       is.null <- base::is.null
[10:18:33.665]                       muffled <- FALSE
[10:18:33.665]                       if (inherits(cond, "message")) {
[10:18:33.665]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.665]                         if (muffled) 
[10:18:33.665]                           invokeRestart("muffleMessage")
[10:18:33.665]                       }
[10:18:33.665]                       else if (inherits(cond, "warning")) {
[10:18:33.665]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.665]                         if (muffled) 
[10:18:33.665]                           invokeRestart("muffleWarning")
[10:18:33.665]                       }
[10:18:33.665]                       else if (inherits(cond, "condition")) {
[10:18:33.665]                         if (!is.null(pattern)) {
[10:18:33.665]                           computeRestarts <- base::computeRestarts
[10:18:33.665]                           grepl <- base::grepl
[10:18:33.665]                           restarts <- computeRestarts(cond)
[10:18:33.665]                           for (restart in restarts) {
[10:18:33.665]                             name <- restart$name
[10:18:33.665]                             if (is.null(name)) 
[10:18:33.665]                               next
[10:18:33.665]                             if (!grepl(pattern, name)) 
[10:18:33.665]                               next
[10:18:33.665]                             invokeRestart(restart)
[10:18:33.665]                             muffled <- TRUE
[10:18:33.665]                             break
[10:18:33.665]                           }
[10:18:33.665]                         }
[10:18:33.665]                       }
[10:18:33.665]                       invisible(muffled)
[10:18:33.665]                     }
[10:18:33.665]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.665]                   }
[10:18:33.665]                 }
[10:18:33.665]             }
[10:18:33.665]         }))
[10:18:33.665]     }, error = function(ex) {
[10:18:33.665]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.665]                 ...future.rng), started = ...future.startTime, 
[10:18:33.665]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.665]             version = "1.8"), class = "FutureResult")
[10:18:33.665]     }, finally = {
[10:18:33.665]         if (!identical(...future.workdir, getwd())) 
[10:18:33.665]             setwd(...future.workdir)
[10:18:33.665]         {
[10:18:33.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.665]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.665]             }
[10:18:33.665]             base::options(...future.oldOptions)
[10:18:33.665]             if (.Platform$OS.type == "windows") {
[10:18:33.665]                 old_names <- names(...future.oldEnvVars)
[10:18:33.665]                 envs <- base::Sys.getenv()
[10:18:33.665]                 names <- names(envs)
[10:18:33.665]                 common <- intersect(names, old_names)
[10:18:33.665]                 added <- setdiff(names, old_names)
[10:18:33.665]                 removed <- setdiff(old_names, names)
[10:18:33.665]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.665]                   envs[common]]
[10:18:33.665]                 NAMES <- toupper(changed)
[10:18:33.665]                 args <- list()
[10:18:33.665]                 for (kk in seq_along(NAMES)) {
[10:18:33.665]                   name <- changed[[kk]]
[10:18:33.665]                   NAME <- NAMES[[kk]]
[10:18:33.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.665]                     next
[10:18:33.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.665]                 }
[10:18:33.665]                 NAMES <- toupper(added)
[10:18:33.665]                 for (kk in seq_along(NAMES)) {
[10:18:33.665]                   name <- added[[kk]]
[10:18:33.665]                   NAME <- NAMES[[kk]]
[10:18:33.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.665]                     next
[10:18:33.665]                   args[[name]] <- ""
[10:18:33.665]                 }
[10:18:33.665]                 NAMES <- toupper(removed)
[10:18:33.665]                 for (kk in seq_along(NAMES)) {
[10:18:33.665]                   name <- removed[[kk]]
[10:18:33.665]                   NAME <- NAMES[[kk]]
[10:18:33.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.665]                     next
[10:18:33.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.665]                 }
[10:18:33.665]                 if (length(args) > 0) 
[10:18:33.665]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.665]             }
[10:18:33.665]             else {
[10:18:33.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.665]             }
[10:18:33.665]             {
[10:18:33.665]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.665]                   0L) {
[10:18:33.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.665]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.665]                   base::options(opts)
[10:18:33.665]                 }
[10:18:33.665]                 {
[10:18:33.665]                   {
[10:18:33.665]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.665]                     NULL
[10:18:33.665]                   }
[10:18:33.665]                   options(future.plan = NULL)
[10:18:33.665]                   if (is.na(NA_character_)) 
[10:18:33.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.665]                     .init = FALSE)
[10:18:33.665]                 }
[10:18:33.665]             }
[10:18:33.665]         }
[10:18:33.665]     })
[10:18:33.665]     if (TRUE) {
[10:18:33.665]         base::sink(type = "output", split = FALSE)
[10:18:33.665]         if (TRUE) {
[10:18:33.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.665]         }
[10:18:33.665]         else {
[10:18:33.665]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.665]         }
[10:18:33.665]         base::close(...future.stdout)
[10:18:33.665]         ...future.stdout <- NULL
[10:18:33.665]     }
[10:18:33.665]     ...future.result$conditions <- ...future.conditions
[10:18:33.665]     ...future.result$finished <- base::Sys.time()
[10:18:33.665]     ...future.result
[10:18:33.665] }
[10:18:33.668] Exporting 7 global objects (3.33 KiB) to cluster node #1 ...
[10:18:33.668] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ...
[10:18:33.669] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ... DONE
[10:18:33.669] Exporting ‘breaks’ (463 bytes) to cluster node #1 ...
[10:18:33.669] Exporting ‘breaks’ (463 bytes) to cluster node #1 ... DONE
[10:18:33.669] Exporting ‘wool’ (342 bytes) to cluster node #1 ...
[10:18:33.670] Exporting ‘wool’ (342 bytes) to cluster node #1 ... DONE
[10:18:33.670] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:33.670] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:33.670] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[10:18:33.671] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[10:18:33.671] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:33.671] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.671] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:33.672] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.672] Exporting 7 global objects (3.33 KiB) to cluster node #1 ... DONE
[10:18:33.672] MultisessionFuture started
[10:18:33.672] - Launch lazy future ... done
[10:18:33.673] run() for ‘MultisessionFuture’ ... done
[10:18:33.673] Created future:
[10:18:33.673] MultisessionFuture:
[10:18:33.673] Label: ‘future_by-1’
[10:18:33.673] Expression:
[10:18:33.673] {
[10:18:33.673]     do.call(function(...) {
[10:18:33.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.673]             on.exit(options(oopts), add = TRUE)
[10:18:33.673]         }
[10:18:33.673]         {
[10:18:33.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.673]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.673]             })
[10:18:33.673]         }
[10:18:33.673]     }, args = future.call.arguments)
[10:18:33.673] }
[10:18:33.673] Lazy evaluation: FALSE
[10:18:33.673] Asynchronous evaluation: TRUE
[10:18:33.673] Local evaluation: TRUE
[10:18:33.673] Environment: 0x55844c2e8db0
[10:18:33.673] Capture standard output: TRUE
[10:18:33.673] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.673] Globals: 7 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, ...)
[10:18:33.673] Packages: 1 packages (‘stats’)
[10:18:33.673] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.673] Resolved: FALSE
[10:18:33.673] Value: <not collected>
[10:18:33.673] Conditions captured: <none>
[10:18:33.673] Early signaling: FALSE
[10:18:33.673] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.673] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.684] Chunk #1 of 2 ... DONE
[10:18:33.684] Chunk #2 of 2 ...
[10:18:33.684]  - Finding globals in 'X' for chunk #2 ...
[10:18:33.685] getGlobalsAndPackages() ...
[10:18:33.685] Searching for globals...
[10:18:33.685] 
[10:18:33.685] Searching for globals ... DONE
[10:18:33.685] - globals: [0] <none>
[10:18:33.685] getGlobalsAndPackages() ... DONE
[10:18:33.686]    + additional globals found: [n=0] 
[10:18:33.686]    + additional namespaces needed: [n=0] 
[10:18:33.686]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:33.686]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.686]  - seeds: <none>
[10:18:33.686]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.686] getGlobalsAndPackages() ...
[10:18:33.686] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.686] Resolving globals: FALSE
[10:18:33.686] Tweak future expression to call with '...' arguments ...
[10:18:33.686] {
[10:18:33.686]     do.call(function(...) {
[10:18:33.686]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.686]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.686]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.686]             on.exit(options(oopts), add = TRUE)
[10:18:33.686]         }
[10:18:33.686]         {
[10:18:33.686]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.686]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.686]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.686]             })
[10:18:33.686]         }
[10:18:33.686]     }, args = future.call.arguments)
[10:18:33.686] }
[10:18:33.687] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.687] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.687] 
[10:18:33.687] getGlobalsAndPackages() ... DONE
[10:18:33.688] run() for ‘Future’ ...
[10:18:33.688] - state: ‘created’
[10:18:33.688] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.702] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.702]   - Field: ‘node’
[10:18:33.702]   - Field: ‘label’
[10:18:33.702]   - Field: ‘local’
[10:18:33.702]   - Field: ‘owner’
[10:18:33.702]   - Field: ‘envir’
[10:18:33.702]   - Field: ‘workers’
[10:18:33.702]   - Field: ‘packages’
[10:18:33.702]   - Field: ‘gc’
[10:18:33.702]   - Field: ‘conditions’
[10:18:33.703]   - Field: ‘persistent’
[10:18:33.703]   - Field: ‘expr’
[10:18:33.703]   - Field: ‘uuid’
[10:18:33.703]   - Field: ‘seed’
[10:18:33.703]   - Field: ‘version’
[10:18:33.703]   - Field: ‘result’
[10:18:33.703]   - Field: ‘asynchronous’
[10:18:33.703]   - Field: ‘calls’
[10:18:33.703]   - Field: ‘globals’
[10:18:33.703]   - Field: ‘stdout’
[10:18:33.703]   - Field: ‘earlySignal’
[10:18:33.703]   - Field: ‘lazy’
[10:18:33.704]   - Field: ‘state’
[10:18:33.704] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.704] - Launch lazy future ...
[10:18:33.704] Packages needed by the future expression (n = 1): ‘stats’
[10:18:33.704] Packages needed by future strategies (n = 0): <none>
[10:18:33.705] {
[10:18:33.705]     {
[10:18:33.705]         {
[10:18:33.705]             ...future.startTime <- base::Sys.time()
[10:18:33.705]             {
[10:18:33.705]                 {
[10:18:33.705]                   {
[10:18:33.705]                     {
[10:18:33.705]                       {
[10:18:33.705]                         base::local({
[10:18:33.705]                           has_future <- base::requireNamespace("future", 
[10:18:33.705]                             quietly = TRUE)
[10:18:33.705]                           if (has_future) {
[10:18:33.705]                             ns <- base::getNamespace("future")
[10:18:33.705]                             version <- ns[[".package"]][["version"]]
[10:18:33.705]                             if (is.null(version)) 
[10:18:33.705]                               version <- utils::packageVersion("future")
[10:18:33.705]                           }
[10:18:33.705]                           else {
[10:18:33.705]                             version <- NULL
[10:18:33.705]                           }
[10:18:33.705]                           if (!has_future || version < "1.8.0") {
[10:18:33.705]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.705]                               "", base::R.version$version.string), 
[10:18:33.705]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:33.705]                                 base::R.version$platform, 8 * 
[10:18:33.705]                                   base::.Machine$sizeof.pointer), 
[10:18:33.705]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.705]                                 "release", "version")], collapse = " "), 
[10:18:33.705]                               hostname = base::Sys.info()[["nodename"]])
[10:18:33.705]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.705]                               info)
[10:18:33.705]                             info <- base::paste(info, collapse = "; ")
[10:18:33.705]                             if (!has_future) {
[10:18:33.705]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.705]                                 info)
[10:18:33.705]                             }
[10:18:33.705]                             else {
[10:18:33.705]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.705]                                 info, version)
[10:18:33.705]                             }
[10:18:33.705]                             base::stop(msg)
[10:18:33.705]                           }
[10:18:33.705]                         })
[10:18:33.705]                       }
[10:18:33.705]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.705]                       base::options(mc.cores = 1L)
[10:18:33.705]                     }
[10:18:33.705]                     base::local({
[10:18:33.705]                       for (pkg in "stats") {
[10:18:33.705]                         base::loadNamespace(pkg)
[10:18:33.705]                         base::library(pkg, character.only = TRUE)
[10:18:33.705]                       }
[10:18:33.705]                     })
[10:18:33.705]                   }
[10:18:33.705]                   ...future.strategy.old <- future::plan("list")
[10:18:33.705]                   options(future.plan = NULL)
[10:18:33.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.705]                 }
[10:18:33.705]                 ...future.workdir <- getwd()
[10:18:33.705]             }
[10:18:33.705]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.705]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.705]         }
[10:18:33.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.705]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.705]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.705]             base::names(...future.oldOptions))
[10:18:33.705]     }
[10:18:33.705]     if (FALSE) {
[10:18:33.705]     }
[10:18:33.705]     else {
[10:18:33.705]         if (TRUE) {
[10:18:33.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.705]                 open = "w")
[10:18:33.705]         }
[10:18:33.705]         else {
[10:18:33.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.705]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.705]         }
[10:18:33.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.705]             base::sink(type = "output", split = FALSE)
[10:18:33.705]             base::close(...future.stdout)
[10:18:33.705]         }, add = TRUE)
[10:18:33.705]     }
[10:18:33.705]     ...future.frame <- base::sys.nframe()
[10:18:33.705]     ...future.conditions <- base::list()
[10:18:33.705]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.705]     if (FALSE) {
[10:18:33.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.705]     }
[10:18:33.705]     ...future.result <- base::tryCatch({
[10:18:33.705]         base::withCallingHandlers({
[10:18:33.705]             ...future.value <- base::withVisible(base::local({
[10:18:33.705]                 ...future.makeSendCondition <- base::local({
[10:18:33.705]                   sendCondition <- NULL
[10:18:33.705]                   function(frame = 1L) {
[10:18:33.705]                     if (is.function(sendCondition)) 
[10:18:33.705]                       return(sendCondition)
[10:18:33.705]                     ns <- getNamespace("parallel")
[10:18:33.705]                     if (exists("sendData", mode = "function", 
[10:18:33.705]                       envir = ns)) {
[10:18:33.705]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.705]                         envir = ns)
[10:18:33.705]                       envir <- sys.frame(frame)
[10:18:33.705]                       master <- NULL
[10:18:33.705]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.705]                         !identical(envir, emptyenv())) {
[10:18:33.705]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.705]                           inherits = FALSE)) {
[10:18:33.705]                           master <- get("master", mode = "list", 
[10:18:33.705]                             envir = envir, inherits = FALSE)
[10:18:33.705]                           if (inherits(master, c("SOCKnode", 
[10:18:33.705]                             "SOCK0node"))) {
[10:18:33.705]                             sendCondition <<- function(cond) {
[10:18:33.705]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.705]                                 success = TRUE)
[10:18:33.705]                               parallel_sendData(master, data)
[10:18:33.705]                             }
[10:18:33.705]                             return(sendCondition)
[10:18:33.705]                           }
[10:18:33.705]                         }
[10:18:33.705]                         frame <- frame + 1L
[10:18:33.705]                         envir <- sys.frame(frame)
[10:18:33.705]                       }
[10:18:33.705]                     }
[10:18:33.705]                     sendCondition <<- function(cond) NULL
[10:18:33.705]                   }
[10:18:33.705]                 })
[10:18:33.705]                 withCallingHandlers({
[10:18:33.705]                   {
[10:18:33.705]                     do.call(function(...) {
[10:18:33.705]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.705]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.705]                         ...future.globals.maxSize)) {
[10:18:33.705]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.705]                         on.exit(options(oopts), add = TRUE)
[10:18:33.705]                       }
[10:18:33.705]                       {
[10:18:33.705]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.705]                           FUN = function(jj) {
[10:18:33.705]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.705]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.705]                           })
[10:18:33.705]                       }
[10:18:33.705]                     }, args = future.call.arguments)
[10:18:33.705]                   }
[10:18:33.705]                 }, immediateCondition = function(cond) {
[10:18:33.705]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.705]                   sendCondition(cond)
[10:18:33.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.705]                   {
[10:18:33.705]                     inherits <- base::inherits
[10:18:33.705]                     invokeRestart <- base::invokeRestart
[10:18:33.705]                     is.null <- base::is.null
[10:18:33.705]                     muffled <- FALSE
[10:18:33.705]                     if (inherits(cond, "message")) {
[10:18:33.705]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.705]                       if (muffled) 
[10:18:33.705]                         invokeRestart("muffleMessage")
[10:18:33.705]                     }
[10:18:33.705]                     else if (inherits(cond, "warning")) {
[10:18:33.705]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.705]                       if (muffled) 
[10:18:33.705]                         invokeRestart("muffleWarning")
[10:18:33.705]                     }
[10:18:33.705]                     else if (inherits(cond, "condition")) {
[10:18:33.705]                       if (!is.null(pattern)) {
[10:18:33.705]                         computeRestarts <- base::computeRestarts
[10:18:33.705]                         grepl <- base::grepl
[10:18:33.705]                         restarts <- computeRestarts(cond)
[10:18:33.705]                         for (restart in restarts) {
[10:18:33.705]                           name <- restart$name
[10:18:33.705]                           if (is.null(name)) 
[10:18:33.705]                             next
[10:18:33.705]                           if (!grepl(pattern, name)) 
[10:18:33.705]                             next
[10:18:33.705]                           invokeRestart(restart)
[10:18:33.705]                           muffled <- TRUE
[10:18:33.705]                           break
[10:18:33.705]                         }
[10:18:33.705]                       }
[10:18:33.705]                     }
[10:18:33.705]                     invisible(muffled)
[10:18:33.705]                   }
[10:18:33.705]                   muffleCondition(cond)
[10:18:33.705]                 })
[10:18:33.705]             }))
[10:18:33.705]             future::FutureResult(value = ...future.value$value, 
[10:18:33.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.705]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.705]                     ...future.globalenv.names))
[10:18:33.705]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.705]         }, condition = base::local({
[10:18:33.705]             c <- base::c
[10:18:33.705]             inherits <- base::inherits
[10:18:33.705]             invokeRestart <- base::invokeRestart
[10:18:33.705]             length <- base::length
[10:18:33.705]             list <- base::list
[10:18:33.705]             seq.int <- base::seq.int
[10:18:33.705]             signalCondition <- base::signalCondition
[10:18:33.705]             sys.calls <- base::sys.calls
[10:18:33.705]             `[[` <- base::`[[`
[10:18:33.705]             `+` <- base::`+`
[10:18:33.705]             `<<-` <- base::`<<-`
[10:18:33.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.705]                   3L)]
[10:18:33.705]             }
[10:18:33.705]             function(cond) {
[10:18:33.705]                 is_error <- inherits(cond, "error")
[10:18:33.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.705]                   NULL)
[10:18:33.705]                 if (is_error) {
[10:18:33.705]                   sessionInformation <- function() {
[10:18:33.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.705]                       search = base::search(), system = base::Sys.info())
[10:18:33.705]                   }
[10:18:33.705]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.705]                     cond$call), session = sessionInformation(), 
[10:18:33.705]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.705]                   signalCondition(cond)
[10:18:33.705]                 }
[10:18:33.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.705]                 "immediateCondition"))) {
[10:18:33.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.705]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.705]                   if (TRUE && !signal) {
[10:18:33.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.705]                     {
[10:18:33.705]                       inherits <- base::inherits
[10:18:33.705]                       invokeRestart <- base::invokeRestart
[10:18:33.705]                       is.null <- base::is.null
[10:18:33.705]                       muffled <- FALSE
[10:18:33.705]                       if (inherits(cond, "message")) {
[10:18:33.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.705]                         if (muffled) 
[10:18:33.705]                           invokeRestart("muffleMessage")
[10:18:33.705]                       }
[10:18:33.705]                       else if (inherits(cond, "warning")) {
[10:18:33.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.705]                         if (muffled) 
[10:18:33.705]                           invokeRestart("muffleWarning")
[10:18:33.705]                       }
[10:18:33.705]                       else if (inherits(cond, "condition")) {
[10:18:33.705]                         if (!is.null(pattern)) {
[10:18:33.705]                           computeRestarts <- base::computeRestarts
[10:18:33.705]                           grepl <- base::grepl
[10:18:33.705]                           restarts <- computeRestarts(cond)
[10:18:33.705]                           for (restart in restarts) {
[10:18:33.705]                             name <- restart$name
[10:18:33.705]                             if (is.null(name)) 
[10:18:33.705]                               next
[10:18:33.705]                             if (!grepl(pattern, name)) 
[10:18:33.705]                               next
[10:18:33.705]                             invokeRestart(restart)
[10:18:33.705]                             muffled <- TRUE
[10:18:33.705]                             break
[10:18:33.705]                           }
[10:18:33.705]                         }
[10:18:33.705]                       }
[10:18:33.705]                       invisible(muffled)
[10:18:33.705]                     }
[10:18:33.705]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.705]                   }
[10:18:33.705]                 }
[10:18:33.705]                 else {
[10:18:33.705]                   if (TRUE) {
[10:18:33.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.705]                     {
[10:18:33.705]                       inherits <- base::inherits
[10:18:33.705]                       invokeRestart <- base::invokeRestart
[10:18:33.705]                       is.null <- base::is.null
[10:18:33.705]                       muffled <- FALSE
[10:18:33.705]                       if (inherits(cond, "message")) {
[10:18:33.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.705]                         if (muffled) 
[10:18:33.705]                           invokeRestart("muffleMessage")
[10:18:33.705]                       }
[10:18:33.705]                       else if (inherits(cond, "warning")) {
[10:18:33.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.705]                         if (muffled) 
[10:18:33.705]                           invokeRestart("muffleWarning")
[10:18:33.705]                       }
[10:18:33.705]                       else if (inherits(cond, "condition")) {
[10:18:33.705]                         if (!is.null(pattern)) {
[10:18:33.705]                           computeRestarts <- base::computeRestarts
[10:18:33.705]                           grepl <- base::grepl
[10:18:33.705]                           restarts <- computeRestarts(cond)
[10:18:33.705]                           for (restart in restarts) {
[10:18:33.705]                             name <- restart$name
[10:18:33.705]                             if (is.null(name)) 
[10:18:33.705]                               next
[10:18:33.705]                             if (!grepl(pattern, name)) 
[10:18:33.705]                               next
[10:18:33.705]                             invokeRestart(restart)
[10:18:33.705]                             muffled <- TRUE
[10:18:33.705]                             break
[10:18:33.705]                           }
[10:18:33.705]                         }
[10:18:33.705]                       }
[10:18:33.705]                       invisible(muffled)
[10:18:33.705]                     }
[10:18:33.705]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.705]                   }
[10:18:33.705]                 }
[10:18:33.705]             }
[10:18:33.705]         }))
[10:18:33.705]     }, error = function(ex) {
[10:18:33.705]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.705]                 ...future.rng), started = ...future.startTime, 
[10:18:33.705]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.705]             version = "1.8"), class = "FutureResult")
[10:18:33.705]     }, finally = {
[10:18:33.705]         if (!identical(...future.workdir, getwd())) 
[10:18:33.705]             setwd(...future.workdir)
[10:18:33.705]         {
[10:18:33.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.705]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.705]             }
[10:18:33.705]             base::options(...future.oldOptions)
[10:18:33.705]             if (.Platform$OS.type == "windows") {
[10:18:33.705]                 old_names <- names(...future.oldEnvVars)
[10:18:33.705]                 envs <- base::Sys.getenv()
[10:18:33.705]                 names <- names(envs)
[10:18:33.705]                 common <- intersect(names, old_names)
[10:18:33.705]                 added <- setdiff(names, old_names)
[10:18:33.705]                 removed <- setdiff(old_names, names)
[10:18:33.705]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.705]                   envs[common]]
[10:18:33.705]                 NAMES <- toupper(changed)
[10:18:33.705]                 args <- list()
[10:18:33.705]                 for (kk in seq_along(NAMES)) {
[10:18:33.705]                   name <- changed[[kk]]
[10:18:33.705]                   NAME <- NAMES[[kk]]
[10:18:33.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.705]                     next
[10:18:33.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.705]                 }
[10:18:33.705]                 NAMES <- toupper(added)
[10:18:33.705]                 for (kk in seq_along(NAMES)) {
[10:18:33.705]                   name <- added[[kk]]
[10:18:33.705]                   NAME <- NAMES[[kk]]
[10:18:33.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.705]                     next
[10:18:33.705]                   args[[name]] <- ""
[10:18:33.705]                 }
[10:18:33.705]                 NAMES <- toupper(removed)
[10:18:33.705]                 for (kk in seq_along(NAMES)) {
[10:18:33.705]                   name <- removed[[kk]]
[10:18:33.705]                   NAME <- NAMES[[kk]]
[10:18:33.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.705]                     next
[10:18:33.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.705]                 }
[10:18:33.705]                 if (length(args) > 0) 
[10:18:33.705]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.705]             }
[10:18:33.705]             else {
[10:18:33.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.705]             }
[10:18:33.705]             {
[10:18:33.705]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.705]                   0L) {
[10:18:33.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.705]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.705]                   base::options(opts)
[10:18:33.705]                 }
[10:18:33.705]                 {
[10:18:33.705]                   {
[10:18:33.705]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.705]                     NULL
[10:18:33.705]                   }
[10:18:33.705]                   options(future.plan = NULL)
[10:18:33.705]                   if (is.na(NA_character_)) 
[10:18:33.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.705]                     .init = FALSE)
[10:18:33.705]                 }
[10:18:33.705]             }
[10:18:33.705]         }
[10:18:33.705]     })
[10:18:33.705]     if (TRUE) {
[10:18:33.705]         base::sink(type = "output", split = FALSE)
[10:18:33.705]         if (TRUE) {
[10:18:33.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.705]         }
[10:18:33.705]         else {
[10:18:33.705]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.705]         }
[10:18:33.705]         base::close(...future.stdout)
[10:18:33.705]         ...future.stdout <- NULL
[10:18:33.705]     }
[10:18:33.705]     ...future.result$conditions <- ...future.conditions
[10:18:33.705]     ...future.result$finished <- base::Sys.time()
[10:18:33.705]     ...future.result
[10:18:33.705] }
[10:18:33.707] Exporting 7 global objects (3.97 KiB) to cluster node #2 ...
[10:18:33.708] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ...
[10:18:33.708] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ... DONE
[10:18:33.708] Exporting ‘breaks’ (463 bytes) to cluster node #2 ...
[10:18:33.708] Exporting ‘breaks’ (463 bytes) to cluster node #2 ... DONE
[10:18:33.709] Exporting ‘wool’ (342 bytes) to cluster node #2 ...
[10:18:33.709] Exporting ‘wool’ (342 bytes) to cluster node #2 ... DONE
[10:18:33.709] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:33.709] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:33.710] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[10:18:33.710] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[10:18:33.710] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:33.710] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.710] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:33.711] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.711] Exporting 7 global objects (3.97 KiB) to cluster node #2 ... DONE
[10:18:33.711] MultisessionFuture started
[10:18:33.711] - Launch lazy future ... done
[10:18:33.712] run() for ‘MultisessionFuture’ ... done
[10:18:33.712] Created future:
[10:18:33.712] MultisessionFuture:
[10:18:33.712] Label: ‘future_by-2’
[10:18:33.712] Expression:
[10:18:33.712] {
[10:18:33.712]     do.call(function(...) {
[10:18:33.712]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.712]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.712]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.712]             on.exit(options(oopts), add = TRUE)
[10:18:33.712]         }
[10:18:33.712]         {
[10:18:33.712]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.712]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.712]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.712]             })
[10:18:33.712]         }
[10:18:33.712]     }, args = future.call.arguments)
[10:18:33.712] }
[10:18:33.712] Lazy evaluation: FALSE
[10:18:33.712] Asynchronous evaluation: TRUE
[10:18:33.712] Local evaluation: TRUE
[10:18:33.712] Environment: 0x55844c2e8db0
[10:18:33.712] Capture standard output: TRUE
[10:18:33.712] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.712] Globals: 7 objects totaling 3.57 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, ...)
[10:18:33.712] Packages: 1 packages (‘stats’)
[10:18:33.712] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.712] Resolved: FALSE
[10:18:33.712] Value: <not collected>
[10:18:33.712] Conditions captured: <none>
[10:18:33.712] Early signaling: FALSE
[10:18:33.712] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.712] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.724] Chunk #2 of 2 ... DONE
[10:18:33.724] Launching 2 futures (chunks) ... DONE
[10:18:33.724] Resolving 2 futures (chunks) ...
[10:18:33.724] resolve() on list ...
[10:18:33.724]  recursive: 0
[10:18:33.724]  length: 2
[10:18:33.724] 
[10:18:33.725] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.725] - Validating connection of MultisessionFuture
[10:18:33.725] - received message: FutureResult
[10:18:33.725] - Received FutureResult
[10:18:33.725] - Erased future from FutureRegistry
[10:18:33.725] result() for ClusterFuture ...
[10:18:33.725] - result already collected: FutureResult
[10:18:33.726] result() for ClusterFuture ... done
[10:18:33.726] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.726] Future #1
[10:18:33.726] result() for ClusterFuture ...
[10:18:33.726] - result already collected: FutureResult
[10:18:33.726] result() for ClusterFuture ... done
[10:18:33.726] result() for ClusterFuture ...
[10:18:33.726] - result already collected: FutureResult
[10:18:33.726] result() for ClusterFuture ... done
[10:18:33.726] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:33.726] - nx: 2
[10:18:33.726] - relay: TRUE
[10:18:33.727] - stdout: TRUE
[10:18:33.727] - signal: TRUE
[10:18:33.727] - resignal: FALSE
[10:18:33.727] - force: TRUE
[10:18:33.727] - relayed: [n=2] FALSE, FALSE
[10:18:33.727] - queued futures: [n=2] FALSE, FALSE
[10:18:33.727]  - until=1
[10:18:33.727]  - relaying element #1
[10:18:33.727] result() for ClusterFuture ...
[10:18:33.727] - result already collected: FutureResult
[10:18:33.727] result() for ClusterFuture ... done
[10:18:33.727] result() for ClusterFuture ...
[10:18:33.728] - result already collected: FutureResult
[10:18:33.728] result() for ClusterFuture ... done
[10:18:33.728] result() for ClusterFuture ...
[10:18:33.728] - result already collected: FutureResult
[10:18:33.728] result() for ClusterFuture ... done
[10:18:33.728] result() for ClusterFuture ...
[10:18:33.728] - result already collected: FutureResult
[10:18:33.728] result() for ClusterFuture ... done
[10:18:33.728] - relayed: [n=2] TRUE, FALSE
[10:18:33.728] - queued futures: [n=2] TRUE, FALSE
[10:18:33.728] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:33.728]  length: 1 (resolved future 1)
[10:18:33.755] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.756] - Validating connection of MultisessionFuture
[10:18:33.756] - received message: FutureResult
[10:18:33.756] - Received FutureResult
[10:18:33.756] - Erased future from FutureRegistry
[10:18:33.756] result() for ClusterFuture ...
[10:18:33.756] - result already collected: FutureResult
[10:18:33.757] result() for ClusterFuture ... done
[10:18:33.757] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.757] Future #2
[10:18:33.757] result() for ClusterFuture ...
[10:18:33.757] - result already collected: FutureResult
[10:18:33.757] result() for ClusterFuture ... done
[10:18:33.757] result() for ClusterFuture ...
[10:18:33.757] - result already collected: FutureResult
[10:18:33.757] result() for ClusterFuture ... done
[10:18:33.757] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:33.757] - nx: 2
[10:18:33.758] - relay: TRUE
[10:18:33.758] - stdout: TRUE
[10:18:33.758] - signal: TRUE
[10:18:33.758] - resignal: FALSE
[10:18:33.758] - force: TRUE
[10:18:33.758] - relayed: [n=2] TRUE, FALSE
[10:18:33.758] - queued futures: [n=2] TRUE, FALSE
[10:18:33.758]  - until=2
[10:18:33.758]  - relaying element #2
[10:18:33.758] result() for ClusterFuture ...
[10:18:33.758] - result already collected: FutureResult
[10:18:33.758] result() for ClusterFuture ... done
[10:18:33.759] result() for ClusterFuture ...
[10:18:33.759] - result already collected: FutureResult
[10:18:33.759] result() for ClusterFuture ... done
[10:18:33.759] result() for ClusterFuture ...
[10:18:33.759] - result already collected: FutureResult
[10:18:33.759] result() for ClusterFuture ... done
[10:18:33.759] result() for ClusterFuture ...
[10:18:33.759] - result already collected: FutureResult
[10:18:33.759] result() for ClusterFuture ... done
[10:18:33.759] - relayed: [n=2] TRUE, TRUE
[10:18:33.759] - queued futures: [n=2] TRUE, TRUE
[10:18:33.759] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:33.760]  length: 0 (resolved future 2)
[10:18:33.760] Relaying remaining futures
[10:18:33.760] signalConditionsASAP(NULL, pos=0) ...
[10:18:33.760] - nx: 2
[10:18:33.760] - relay: TRUE
[10:18:33.760] - stdout: TRUE
[10:18:33.760] - signal: TRUE
[10:18:33.760] - resignal: FALSE
[10:18:33.760] - force: TRUE
[10:18:33.760] - relayed: [n=2] TRUE, TRUE
[10:18:33.760] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:33.760] - relayed: [n=2] TRUE, TRUE
[10:18:33.761] - queued futures: [n=2] TRUE, TRUE
[10:18:33.761] signalConditionsASAP(NULL, pos=0) ... done
[10:18:33.761] resolve() on list ... DONE
[10:18:33.761] result() for ClusterFuture ...
[10:18:33.761] - result already collected: FutureResult
[10:18:33.761] result() for ClusterFuture ... done
[10:18:33.761] result() for ClusterFuture ...
[10:18:33.761] - result already collected: FutureResult
[10:18:33.761] result() for ClusterFuture ... done
[10:18:33.761] result() for ClusterFuture ...
[10:18:33.761] - result already collected: FutureResult
[10:18:33.761] result() for ClusterFuture ... done
[10:18:33.762] result() for ClusterFuture ...
[10:18:33.762] - result already collected: FutureResult
[10:18:33.762] result() for ClusterFuture ... done
[10:18:33.762]  - Number of value chunks collected: 2
[10:18:33.762] Resolving 2 futures (chunks) ... DONE
[10:18:33.762] Reducing values from 2 chunks ...
[10:18:33.762]  - Number of values collected after concatenation: 3
[10:18:33.762]  - Number of values expected: 3
[10:18:33.762] Reducing values from 2 chunks ... DONE
[10:18:33.762] future_lapply() ... DONE
[10:18:33.762] future_by_internal() ... DONE
[10:18:33.763] future_by_internal() ...
[10:18:33.763] future_lapply() ...
[10:18:33.765] Number of chunks: 2
[10:18:33.765] getGlobalsAndPackagesXApply() ...
[10:18:33.766]  - future.globals: TRUE
[10:18:33.766] getGlobalsAndPackages() ...
[10:18:33.766] Searching for globals...
[10:18:33.769] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:33.769] Searching for globals ... DONE
[10:18:33.769] Resolving globals: FALSE
[10:18:33.770] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:33.770] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:33.770] - globals: [1] ‘FUN’
[10:18:33.770] 
[10:18:33.770] getGlobalsAndPackages() ... DONE
[10:18:33.770]  - globals found/used: [n=1] ‘FUN’
[10:18:33.770]  - needed namespaces: [n=0] 
[10:18:33.771] Finding globals ... DONE
[10:18:33.771]  - use_args: TRUE
[10:18:33.771]  - Getting '...' globals ...
[10:18:33.771] resolve() on list ...
[10:18:33.771]  recursive: 0
[10:18:33.771]  length: 1
[10:18:33.771]  elements: ‘...’
[10:18:33.771]  length: 0 (resolved future 1)
[10:18:33.771] resolve() on list ... DONE
[10:18:33.772]    - '...' content: [n=0] 
[10:18:33.772] List of 1
[10:18:33.772]  $ ...: list()
[10:18:33.772]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.772]  - attr(*, "where")=List of 1
[10:18:33.772]   ..$ ...:<environment: 0x5584497b51b8> 
[10:18:33.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.772]  - attr(*, "resolved")= logi TRUE
[10:18:33.772]  - attr(*, "total_size")= num NA
[10:18:33.774]  - Getting '...' globals ... DONE
[10:18:33.774] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:33.774] List of 2
[10:18:33.774]  $ ...future.FUN:function (object, ...)  
[10:18:33.774]  $ ...          : list()
[10:18:33.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.774]  - attr(*, "where")=List of 2
[10:18:33.774]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:33.774]   ..$ ...          :<environment: 0x5584497b51b8> 
[10:18:33.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.774]  - attr(*, "resolved")= logi FALSE
[10:18:33.774]  - attr(*, "total_size")= num 19278
[10:18:33.777] Packages to be attached in all futures: [n=0] 
[10:18:33.777] getGlobalsAndPackagesXApply() ... DONE
[10:18:33.777] Number of futures (= number of chunks): 2
[10:18:33.777] Launching 2 futures (chunks) ...
[10:18:33.777] Chunk #1 of 2 ...
[10:18:33.777]  - Finding globals in 'X' for chunk #1 ...
[10:18:33.778] getGlobalsAndPackages() ...
[10:18:33.778] Searching for globals...
[10:18:33.778] 
[10:18:33.778] Searching for globals ... DONE
[10:18:33.778] - globals: [0] <none>
[10:18:33.778] getGlobalsAndPackages() ... DONE
[10:18:33.778]    + additional globals found: [n=0] 
[10:18:33.778]    + additional namespaces needed: [n=0] 
[10:18:33.778]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:33.778]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.779]  - seeds: <none>
[10:18:33.779]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.779] getGlobalsAndPackages() ...
[10:18:33.779] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.779] Resolving globals: FALSE
[10:18:33.779] Tweak future expression to call with '...' arguments ...
[10:18:33.779] {
[10:18:33.779]     do.call(function(...) {
[10:18:33.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.779]             on.exit(options(oopts), add = TRUE)
[10:18:33.779]         }
[10:18:33.779]         {
[10:18:33.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.779]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.779]             })
[10:18:33.779]         }
[10:18:33.779]     }, args = future.call.arguments)
[10:18:33.779] }
[10:18:33.779] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.780] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.780] 
[10:18:33.780] getGlobalsAndPackages() ... DONE
[10:18:33.780] run() for ‘Future’ ...
[10:18:33.780] - state: ‘created’
[10:18:33.780] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.794] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.794]   - Field: ‘node’
[10:18:33.794]   - Field: ‘label’
[10:18:33.794]   - Field: ‘local’
[10:18:33.794]   - Field: ‘owner’
[10:18:33.794]   - Field: ‘envir’
[10:18:33.794]   - Field: ‘workers’
[10:18:33.795]   - Field: ‘packages’
[10:18:33.795]   - Field: ‘gc’
[10:18:33.795]   - Field: ‘conditions’
[10:18:33.795]   - Field: ‘persistent’
[10:18:33.795]   - Field: ‘expr’
[10:18:33.795]   - Field: ‘uuid’
[10:18:33.795]   - Field: ‘seed’
[10:18:33.795]   - Field: ‘version’
[10:18:33.795]   - Field: ‘result’
[10:18:33.795]   - Field: ‘asynchronous’
[10:18:33.795]   - Field: ‘calls’
[10:18:33.795]   - Field: ‘globals’
[10:18:33.796]   - Field: ‘stdout’
[10:18:33.796]   - Field: ‘earlySignal’
[10:18:33.796]   - Field: ‘lazy’
[10:18:33.796]   - Field: ‘state’
[10:18:33.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.796] - Launch lazy future ...
[10:18:33.796] Packages needed by the future expression (n = 0): <none>
[10:18:33.796] Packages needed by future strategies (n = 0): <none>
[10:18:33.797] {
[10:18:33.797]     {
[10:18:33.797]         {
[10:18:33.797]             ...future.startTime <- base::Sys.time()
[10:18:33.797]             {
[10:18:33.797]                 {
[10:18:33.797]                   {
[10:18:33.797]                     {
[10:18:33.797]                       base::local({
[10:18:33.797]                         has_future <- base::requireNamespace("future", 
[10:18:33.797]                           quietly = TRUE)
[10:18:33.797]                         if (has_future) {
[10:18:33.797]                           ns <- base::getNamespace("future")
[10:18:33.797]                           version <- ns[[".package"]][["version"]]
[10:18:33.797]                           if (is.null(version)) 
[10:18:33.797]                             version <- utils::packageVersion("future")
[10:18:33.797]                         }
[10:18:33.797]                         else {
[10:18:33.797]                           version <- NULL
[10:18:33.797]                         }
[10:18:33.797]                         if (!has_future || version < "1.8.0") {
[10:18:33.797]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.797]                             "", base::R.version$version.string), 
[10:18:33.797]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.797]                               "release", "version")], collapse = " "), 
[10:18:33.797]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.797]                             info)
[10:18:33.797]                           info <- base::paste(info, collapse = "; ")
[10:18:33.797]                           if (!has_future) {
[10:18:33.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.797]                               info)
[10:18:33.797]                           }
[10:18:33.797]                           else {
[10:18:33.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.797]                               info, version)
[10:18:33.797]                           }
[10:18:33.797]                           base::stop(msg)
[10:18:33.797]                         }
[10:18:33.797]                       })
[10:18:33.797]                     }
[10:18:33.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.797]                     base::options(mc.cores = 1L)
[10:18:33.797]                   }
[10:18:33.797]                   ...future.strategy.old <- future::plan("list")
[10:18:33.797]                   options(future.plan = NULL)
[10:18:33.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.797]                 }
[10:18:33.797]                 ...future.workdir <- getwd()
[10:18:33.797]             }
[10:18:33.797]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.797]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.797]         }
[10:18:33.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.797]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.797]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.797]             base::names(...future.oldOptions))
[10:18:33.797]     }
[10:18:33.797]     if (FALSE) {
[10:18:33.797]     }
[10:18:33.797]     else {
[10:18:33.797]         if (TRUE) {
[10:18:33.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.797]                 open = "w")
[10:18:33.797]         }
[10:18:33.797]         else {
[10:18:33.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.797]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.797]         }
[10:18:33.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.797]             base::sink(type = "output", split = FALSE)
[10:18:33.797]             base::close(...future.stdout)
[10:18:33.797]         }, add = TRUE)
[10:18:33.797]     }
[10:18:33.797]     ...future.frame <- base::sys.nframe()
[10:18:33.797]     ...future.conditions <- base::list()
[10:18:33.797]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.797]     if (FALSE) {
[10:18:33.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.797]     }
[10:18:33.797]     ...future.result <- base::tryCatch({
[10:18:33.797]         base::withCallingHandlers({
[10:18:33.797]             ...future.value <- base::withVisible(base::local({
[10:18:33.797]                 ...future.makeSendCondition <- base::local({
[10:18:33.797]                   sendCondition <- NULL
[10:18:33.797]                   function(frame = 1L) {
[10:18:33.797]                     if (is.function(sendCondition)) 
[10:18:33.797]                       return(sendCondition)
[10:18:33.797]                     ns <- getNamespace("parallel")
[10:18:33.797]                     if (exists("sendData", mode = "function", 
[10:18:33.797]                       envir = ns)) {
[10:18:33.797]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.797]                         envir = ns)
[10:18:33.797]                       envir <- sys.frame(frame)
[10:18:33.797]                       master <- NULL
[10:18:33.797]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.797]                         !identical(envir, emptyenv())) {
[10:18:33.797]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.797]                           inherits = FALSE)) {
[10:18:33.797]                           master <- get("master", mode = "list", 
[10:18:33.797]                             envir = envir, inherits = FALSE)
[10:18:33.797]                           if (inherits(master, c("SOCKnode", 
[10:18:33.797]                             "SOCK0node"))) {
[10:18:33.797]                             sendCondition <<- function(cond) {
[10:18:33.797]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.797]                                 success = TRUE)
[10:18:33.797]                               parallel_sendData(master, data)
[10:18:33.797]                             }
[10:18:33.797]                             return(sendCondition)
[10:18:33.797]                           }
[10:18:33.797]                         }
[10:18:33.797]                         frame <- frame + 1L
[10:18:33.797]                         envir <- sys.frame(frame)
[10:18:33.797]                       }
[10:18:33.797]                     }
[10:18:33.797]                     sendCondition <<- function(cond) NULL
[10:18:33.797]                   }
[10:18:33.797]                 })
[10:18:33.797]                 withCallingHandlers({
[10:18:33.797]                   {
[10:18:33.797]                     do.call(function(...) {
[10:18:33.797]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.797]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.797]                         ...future.globals.maxSize)) {
[10:18:33.797]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.797]                         on.exit(options(oopts), add = TRUE)
[10:18:33.797]                       }
[10:18:33.797]                       {
[10:18:33.797]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.797]                           FUN = function(jj) {
[10:18:33.797]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.797]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.797]                           })
[10:18:33.797]                       }
[10:18:33.797]                     }, args = future.call.arguments)
[10:18:33.797]                   }
[10:18:33.797]                 }, immediateCondition = function(cond) {
[10:18:33.797]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.797]                   sendCondition(cond)
[10:18:33.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.797]                   {
[10:18:33.797]                     inherits <- base::inherits
[10:18:33.797]                     invokeRestart <- base::invokeRestart
[10:18:33.797]                     is.null <- base::is.null
[10:18:33.797]                     muffled <- FALSE
[10:18:33.797]                     if (inherits(cond, "message")) {
[10:18:33.797]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.797]                       if (muffled) 
[10:18:33.797]                         invokeRestart("muffleMessage")
[10:18:33.797]                     }
[10:18:33.797]                     else if (inherits(cond, "warning")) {
[10:18:33.797]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.797]                       if (muffled) 
[10:18:33.797]                         invokeRestart("muffleWarning")
[10:18:33.797]                     }
[10:18:33.797]                     else if (inherits(cond, "condition")) {
[10:18:33.797]                       if (!is.null(pattern)) {
[10:18:33.797]                         computeRestarts <- base::computeRestarts
[10:18:33.797]                         grepl <- base::grepl
[10:18:33.797]                         restarts <- computeRestarts(cond)
[10:18:33.797]                         for (restart in restarts) {
[10:18:33.797]                           name <- restart$name
[10:18:33.797]                           if (is.null(name)) 
[10:18:33.797]                             next
[10:18:33.797]                           if (!grepl(pattern, name)) 
[10:18:33.797]                             next
[10:18:33.797]                           invokeRestart(restart)
[10:18:33.797]                           muffled <- TRUE
[10:18:33.797]                           break
[10:18:33.797]                         }
[10:18:33.797]                       }
[10:18:33.797]                     }
[10:18:33.797]                     invisible(muffled)
[10:18:33.797]                   }
[10:18:33.797]                   muffleCondition(cond)
[10:18:33.797]                 })
[10:18:33.797]             }))
[10:18:33.797]             future::FutureResult(value = ...future.value$value, 
[10:18:33.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.797]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.797]                     ...future.globalenv.names))
[10:18:33.797]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.797]         }, condition = base::local({
[10:18:33.797]             c <- base::c
[10:18:33.797]             inherits <- base::inherits
[10:18:33.797]             invokeRestart <- base::invokeRestart
[10:18:33.797]             length <- base::length
[10:18:33.797]             list <- base::list
[10:18:33.797]             seq.int <- base::seq.int
[10:18:33.797]             signalCondition <- base::signalCondition
[10:18:33.797]             sys.calls <- base::sys.calls
[10:18:33.797]             `[[` <- base::`[[`
[10:18:33.797]             `+` <- base::`+`
[10:18:33.797]             `<<-` <- base::`<<-`
[10:18:33.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.797]                   3L)]
[10:18:33.797]             }
[10:18:33.797]             function(cond) {
[10:18:33.797]                 is_error <- inherits(cond, "error")
[10:18:33.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.797]                   NULL)
[10:18:33.797]                 if (is_error) {
[10:18:33.797]                   sessionInformation <- function() {
[10:18:33.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.797]                       search = base::search(), system = base::Sys.info())
[10:18:33.797]                   }
[10:18:33.797]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.797]                     cond$call), session = sessionInformation(), 
[10:18:33.797]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.797]                   signalCondition(cond)
[10:18:33.797]                 }
[10:18:33.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.797]                 "immediateCondition"))) {
[10:18:33.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.797]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.797]                   if (TRUE && !signal) {
[10:18:33.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.797]                     {
[10:18:33.797]                       inherits <- base::inherits
[10:18:33.797]                       invokeRestart <- base::invokeRestart
[10:18:33.797]                       is.null <- base::is.null
[10:18:33.797]                       muffled <- FALSE
[10:18:33.797]                       if (inherits(cond, "message")) {
[10:18:33.797]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.797]                         if (muffled) 
[10:18:33.797]                           invokeRestart("muffleMessage")
[10:18:33.797]                       }
[10:18:33.797]                       else if (inherits(cond, "warning")) {
[10:18:33.797]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.797]                         if (muffled) 
[10:18:33.797]                           invokeRestart("muffleWarning")
[10:18:33.797]                       }
[10:18:33.797]                       else if (inherits(cond, "condition")) {
[10:18:33.797]                         if (!is.null(pattern)) {
[10:18:33.797]                           computeRestarts <- base::computeRestarts
[10:18:33.797]                           grepl <- base::grepl
[10:18:33.797]                           restarts <- computeRestarts(cond)
[10:18:33.797]                           for (restart in restarts) {
[10:18:33.797]                             name <- restart$name
[10:18:33.797]                             if (is.null(name)) 
[10:18:33.797]                               next
[10:18:33.797]                             if (!grepl(pattern, name)) 
[10:18:33.797]                               next
[10:18:33.797]                             invokeRestart(restart)
[10:18:33.797]                             muffled <- TRUE
[10:18:33.797]                             break
[10:18:33.797]                           }
[10:18:33.797]                         }
[10:18:33.797]                       }
[10:18:33.797]                       invisible(muffled)
[10:18:33.797]                     }
[10:18:33.797]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.797]                   }
[10:18:33.797]                 }
[10:18:33.797]                 else {
[10:18:33.797]                   if (TRUE) {
[10:18:33.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.797]                     {
[10:18:33.797]                       inherits <- base::inherits
[10:18:33.797]                       invokeRestart <- base::invokeRestart
[10:18:33.797]                       is.null <- base::is.null
[10:18:33.797]                       muffled <- FALSE
[10:18:33.797]                       if (inherits(cond, "message")) {
[10:18:33.797]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.797]                         if (muffled) 
[10:18:33.797]                           invokeRestart("muffleMessage")
[10:18:33.797]                       }
[10:18:33.797]                       else if (inherits(cond, "warning")) {
[10:18:33.797]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.797]                         if (muffled) 
[10:18:33.797]                           invokeRestart("muffleWarning")
[10:18:33.797]                       }
[10:18:33.797]                       else if (inherits(cond, "condition")) {
[10:18:33.797]                         if (!is.null(pattern)) {
[10:18:33.797]                           computeRestarts <- base::computeRestarts
[10:18:33.797]                           grepl <- base::grepl
[10:18:33.797]                           restarts <- computeRestarts(cond)
[10:18:33.797]                           for (restart in restarts) {
[10:18:33.797]                             name <- restart$name
[10:18:33.797]                             if (is.null(name)) 
[10:18:33.797]                               next
[10:18:33.797]                             if (!grepl(pattern, name)) 
[10:18:33.797]                               next
[10:18:33.797]                             invokeRestart(restart)
[10:18:33.797]                             muffled <- TRUE
[10:18:33.797]                             break
[10:18:33.797]                           }
[10:18:33.797]                         }
[10:18:33.797]                       }
[10:18:33.797]                       invisible(muffled)
[10:18:33.797]                     }
[10:18:33.797]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.797]                   }
[10:18:33.797]                 }
[10:18:33.797]             }
[10:18:33.797]         }))
[10:18:33.797]     }, error = function(ex) {
[10:18:33.797]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.797]                 ...future.rng), started = ...future.startTime, 
[10:18:33.797]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.797]             version = "1.8"), class = "FutureResult")
[10:18:33.797]     }, finally = {
[10:18:33.797]         if (!identical(...future.workdir, getwd())) 
[10:18:33.797]             setwd(...future.workdir)
[10:18:33.797]         {
[10:18:33.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.797]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.797]             }
[10:18:33.797]             base::options(...future.oldOptions)
[10:18:33.797]             if (.Platform$OS.type == "windows") {
[10:18:33.797]                 old_names <- names(...future.oldEnvVars)
[10:18:33.797]                 envs <- base::Sys.getenv()
[10:18:33.797]                 names <- names(envs)
[10:18:33.797]                 common <- intersect(names, old_names)
[10:18:33.797]                 added <- setdiff(names, old_names)
[10:18:33.797]                 removed <- setdiff(old_names, names)
[10:18:33.797]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.797]                   envs[common]]
[10:18:33.797]                 NAMES <- toupper(changed)
[10:18:33.797]                 args <- list()
[10:18:33.797]                 for (kk in seq_along(NAMES)) {
[10:18:33.797]                   name <- changed[[kk]]
[10:18:33.797]                   NAME <- NAMES[[kk]]
[10:18:33.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.797]                     next
[10:18:33.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.797]                 }
[10:18:33.797]                 NAMES <- toupper(added)
[10:18:33.797]                 for (kk in seq_along(NAMES)) {
[10:18:33.797]                   name <- added[[kk]]
[10:18:33.797]                   NAME <- NAMES[[kk]]
[10:18:33.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.797]                     next
[10:18:33.797]                   args[[name]] <- ""
[10:18:33.797]                 }
[10:18:33.797]                 NAMES <- toupper(removed)
[10:18:33.797]                 for (kk in seq_along(NAMES)) {
[10:18:33.797]                   name <- removed[[kk]]
[10:18:33.797]                   NAME <- NAMES[[kk]]
[10:18:33.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.797]                     next
[10:18:33.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.797]                 }
[10:18:33.797]                 if (length(args) > 0) 
[10:18:33.797]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.797]             }
[10:18:33.797]             else {
[10:18:33.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.797]             }
[10:18:33.797]             {
[10:18:33.797]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.797]                   0L) {
[10:18:33.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.797]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.797]                   base::options(opts)
[10:18:33.797]                 }
[10:18:33.797]                 {
[10:18:33.797]                   {
[10:18:33.797]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.797]                     NULL
[10:18:33.797]                   }
[10:18:33.797]                   options(future.plan = NULL)
[10:18:33.797]                   if (is.na(NA_character_)) 
[10:18:33.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.797]                     .init = FALSE)
[10:18:33.797]                 }
[10:18:33.797]             }
[10:18:33.797]         }
[10:18:33.797]     })
[10:18:33.797]     if (TRUE) {
[10:18:33.797]         base::sink(type = "output", split = FALSE)
[10:18:33.797]         if (TRUE) {
[10:18:33.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.797]         }
[10:18:33.797]         else {
[10:18:33.797]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.797]         }
[10:18:33.797]         base::close(...future.stdout)
[10:18:33.797]         ...future.stdout <- NULL
[10:18:33.797]     }
[10:18:33.797]     ...future.result$conditions <- ...future.conditions
[10:18:33.797]     ...future.result$finished <- base::Sys.time()
[10:18:33.797]     ...future.result
[10:18:33.797] }
[10:18:33.800] Exporting 5 global objects (1.57 KiB) to cluster node #1 ...
[10:18:33.800] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[10:18:33.800] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[10:18:33.800] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:33.801] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:33.801] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[10:18:33.801] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[10:18:33.801] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:33.802] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.802] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:33.802] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.802] Exporting 5 global objects (1.57 KiB) to cluster node #1 ... DONE
[10:18:33.803] MultisessionFuture started
[10:18:33.803] - Launch lazy future ... done
[10:18:33.803] run() for ‘MultisessionFuture’ ... done
[10:18:33.803] Created future:
[10:18:33.803] MultisessionFuture:
[10:18:33.803] Label: ‘future_by-1’
[10:18:33.803] Expression:
[10:18:33.803] {
[10:18:33.803]     do.call(function(...) {
[10:18:33.803]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.803]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.803]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.803]             on.exit(options(oopts), add = TRUE)
[10:18:33.803]         }
[10:18:33.803]         {
[10:18:33.803]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.803]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.803]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.803]             })
[10:18:33.803]         }
[10:18:33.803]     }, args = future.call.arguments)
[10:18:33.803] }
[10:18:33.803] Lazy evaluation: FALSE
[10:18:33.803] Asynchronous evaluation: TRUE
[10:18:33.803] Local evaluation: TRUE
[10:18:33.803] Environment: 0x5584480f9d30
[10:18:33.803] Capture standard output: TRUE
[10:18:33.803] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.803] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.803] Packages: <none>
[10:18:33.803] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.803] Resolved: FALSE
[10:18:33.803] Value: <not collected>
[10:18:33.803] Conditions captured: <none>
[10:18:33.803] Early signaling: FALSE
[10:18:33.803] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.803] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.815] Chunk #1 of 2 ... DONE
[10:18:33.815] Chunk #2 of 2 ...
[10:18:33.815]  - Finding globals in 'X' for chunk #2 ...
[10:18:33.815] getGlobalsAndPackages() ...
[10:18:33.815] Searching for globals...
[10:18:33.815] 
[10:18:33.816] Searching for globals ... DONE
[10:18:33.816] - globals: [0] <none>
[10:18:33.816] getGlobalsAndPackages() ... DONE
[10:18:33.816]    + additional globals found: [n=0] 
[10:18:33.816]    + additional namespaces needed: [n=0] 
[10:18:33.816]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:33.816]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.816]  - seeds: <none>
[10:18:33.816]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.816] getGlobalsAndPackages() ...
[10:18:33.816] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.817] Resolving globals: FALSE
[10:18:33.817] Tweak future expression to call with '...' arguments ...
[10:18:33.817] {
[10:18:33.817]     do.call(function(...) {
[10:18:33.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.817]             on.exit(options(oopts), add = TRUE)
[10:18:33.817]         }
[10:18:33.817]         {
[10:18:33.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.817]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.817]             })
[10:18:33.817]         }
[10:18:33.817]     }, args = future.call.arguments)
[10:18:33.817] }
[10:18:33.817] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.817] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.817] 
[10:18:33.818] getGlobalsAndPackages() ... DONE
[10:18:33.818] run() for ‘Future’ ...
[10:18:33.818] - state: ‘created’
[10:18:33.818] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.832] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.832]   - Field: ‘node’
[10:18:33.832]   - Field: ‘label’
[10:18:33.832]   - Field: ‘local’
[10:18:33.832]   - Field: ‘owner’
[10:18:33.832]   - Field: ‘envir’
[10:18:33.832]   - Field: ‘workers’
[10:18:33.833]   - Field: ‘packages’
[10:18:33.833]   - Field: ‘gc’
[10:18:33.833]   - Field: ‘conditions’
[10:18:33.833]   - Field: ‘persistent’
[10:18:33.833]   - Field: ‘expr’
[10:18:33.833]   - Field: ‘uuid’
[10:18:33.833]   - Field: ‘seed’
[10:18:33.833]   - Field: ‘version’
[10:18:33.833]   - Field: ‘result’
[10:18:33.833]   - Field: ‘asynchronous’
[10:18:33.833]   - Field: ‘calls’
[10:18:33.833]   - Field: ‘globals’
[10:18:33.834]   - Field: ‘stdout’
[10:18:33.834]   - Field: ‘earlySignal’
[10:18:33.834]   - Field: ‘lazy’
[10:18:33.834]   - Field: ‘state’
[10:18:33.834] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.834] - Launch lazy future ...
[10:18:33.834] Packages needed by the future expression (n = 0): <none>
[10:18:33.834] Packages needed by future strategies (n = 0): <none>
[10:18:33.835] {
[10:18:33.835]     {
[10:18:33.835]         {
[10:18:33.835]             ...future.startTime <- base::Sys.time()
[10:18:33.835]             {
[10:18:33.835]                 {
[10:18:33.835]                   {
[10:18:33.835]                     {
[10:18:33.835]                       base::local({
[10:18:33.835]                         has_future <- base::requireNamespace("future", 
[10:18:33.835]                           quietly = TRUE)
[10:18:33.835]                         if (has_future) {
[10:18:33.835]                           ns <- base::getNamespace("future")
[10:18:33.835]                           version <- ns[[".package"]][["version"]]
[10:18:33.835]                           if (is.null(version)) 
[10:18:33.835]                             version <- utils::packageVersion("future")
[10:18:33.835]                         }
[10:18:33.835]                         else {
[10:18:33.835]                           version <- NULL
[10:18:33.835]                         }
[10:18:33.835]                         if (!has_future || version < "1.8.0") {
[10:18:33.835]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.835]                             "", base::R.version$version.string), 
[10:18:33.835]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.835]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.835]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.835]                               "release", "version")], collapse = " "), 
[10:18:33.835]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.835]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.835]                             info)
[10:18:33.835]                           info <- base::paste(info, collapse = "; ")
[10:18:33.835]                           if (!has_future) {
[10:18:33.835]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.835]                               info)
[10:18:33.835]                           }
[10:18:33.835]                           else {
[10:18:33.835]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.835]                               info, version)
[10:18:33.835]                           }
[10:18:33.835]                           base::stop(msg)
[10:18:33.835]                         }
[10:18:33.835]                       })
[10:18:33.835]                     }
[10:18:33.835]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.835]                     base::options(mc.cores = 1L)
[10:18:33.835]                   }
[10:18:33.835]                   ...future.strategy.old <- future::plan("list")
[10:18:33.835]                   options(future.plan = NULL)
[10:18:33.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.835]                 }
[10:18:33.835]                 ...future.workdir <- getwd()
[10:18:33.835]             }
[10:18:33.835]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.835]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.835]         }
[10:18:33.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.835]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.835]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.835]             base::names(...future.oldOptions))
[10:18:33.835]     }
[10:18:33.835]     if (FALSE) {
[10:18:33.835]     }
[10:18:33.835]     else {
[10:18:33.835]         if (TRUE) {
[10:18:33.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.835]                 open = "w")
[10:18:33.835]         }
[10:18:33.835]         else {
[10:18:33.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.835]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.835]         }
[10:18:33.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.835]             base::sink(type = "output", split = FALSE)
[10:18:33.835]             base::close(...future.stdout)
[10:18:33.835]         }, add = TRUE)
[10:18:33.835]     }
[10:18:33.835]     ...future.frame <- base::sys.nframe()
[10:18:33.835]     ...future.conditions <- base::list()
[10:18:33.835]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.835]     if (FALSE) {
[10:18:33.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.835]     }
[10:18:33.835]     ...future.result <- base::tryCatch({
[10:18:33.835]         base::withCallingHandlers({
[10:18:33.835]             ...future.value <- base::withVisible(base::local({
[10:18:33.835]                 ...future.makeSendCondition <- base::local({
[10:18:33.835]                   sendCondition <- NULL
[10:18:33.835]                   function(frame = 1L) {
[10:18:33.835]                     if (is.function(sendCondition)) 
[10:18:33.835]                       return(sendCondition)
[10:18:33.835]                     ns <- getNamespace("parallel")
[10:18:33.835]                     if (exists("sendData", mode = "function", 
[10:18:33.835]                       envir = ns)) {
[10:18:33.835]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.835]                         envir = ns)
[10:18:33.835]                       envir <- sys.frame(frame)
[10:18:33.835]                       master <- NULL
[10:18:33.835]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.835]                         !identical(envir, emptyenv())) {
[10:18:33.835]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.835]                           inherits = FALSE)) {
[10:18:33.835]                           master <- get("master", mode = "list", 
[10:18:33.835]                             envir = envir, inherits = FALSE)
[10:18:33.835]                           if (inherits(master, c("SOCKnode", 
[10:18:33.835]                             "SOCK0node"))) {
[10:18:33.835]                             sendCondition <<- function(cond) {
[10:18:33.835]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.835]                                 success = TRUE)
[10:18:33.835]                               parallel_sendData(master, data)
[10:18:33.835]                             }
[10:18:33.835]                             return(sendCondition)
[10:18:33.835]                           }
[10:18:33.835]                         }
[10:18:33.835]                         frame <- frame + 1L
[10:18:33.835]                         envir <- sys.frame(frame)
[10:18:33.835]                       }
[10:18:33.835]                     }
[10:18:33.835]                     sendCondition <<- function(cond) NULL
[10:18:33.835]                   }
[10:18:33.835]                 })
[10:18:33.835]                 withCallingHandlers({
[10:18:33.835]                   {
[10:18:33.835]                     do.call(function(...) {
[10:18:33.835]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.835]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.835]                         ...future.globals.maxSize)) {
[10:18:33.835]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.835]                         on.exit(options(oopts), add = TRUE)
[10:18:33.835]                       }
[10:18:33.835]                       {
[10:18:33.835]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.835]                           FUN = function(jj) {
[10:18:33.835]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.835]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.835]                           })
[10:18:33.835]                       }
[10:18:33.835]                     }, args = future.call.arguments)
[10:18:33.835]                   }
[10:18:33.835]                 }, immediateCondition = function(cond) {
[10:18:33.835]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.835]                   sendCondition(cond)
[10:18:33.835]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.835]                   {
[10:18:33.835]                     inherits <- base::inherits
[10:18:33.835]                     invokeRestart <- base::invokeRestart
[10:18:33.835]                     is.null <- base::is.null
[10:18:33.835]                     muffled <- FALSE
[10:18:33.835]                     if (inherits(cond, "message")) {
[10:18:33.835]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.835]                       if (muffled) 
[10:18:33.835]                         invokeRestart("muffleMessage")
[10:18:33.835]                     }
[10:18:33.835]                     else if (inherits(cond, "warning")) {
[10:18:33.835]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.835]                       if (muffled) 
[10:18:33.835]                         invokeRestart("muffleWarning")
[10:18:33.835]                     }
[10:18:33.835]                     else if (inherits(cond, "condition")) {
[10:18:33.835]                       if (!is.null(pattern)) {
[10:18:33.835]                         computeRestarts <- base::computeRestarts
[10:18:33.835]                         grepl <- base::grepl
[10:18:33.835]                         restarts <- computeRestarts(cond)
[10:18:33.835]                         for (restart in restarts) {
[10:18:33.835]                           name <- restart$name
[10:18:33.835]                           if (is.null(name)) 
[10:18:33.835]                             next
[10:18:33.835]                           if (!grepl(pattern, name)) 
[10:18:33.835]                             next
[10:18:33.835]                           invokeRestart(restart)
[10:18:33.835]                           muffled <- TRUE
[10:18:33.835]                           break
[10:18:33.835]                         }
[10:18:33.835]                       }
[10:18:33.835]                     }
[10:18:33.835]                     invisible(muffled)
[10:18:33.835]                   }
[10:18:33.835]                   muffleCondition(cond)
[10:18:33.835]                 })
[10:18:33.835]             }))
[10:18:33.835]             future::FutureResult(value = ...future.value$value, 
[10:18:33.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.835]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.835]                     ...future.globalenv.names))
[10:18:33.835]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.835]         }, condition = base::local({
[10:18:33.835]             c <- base::c
[10:18:33.835]             inherits <- base::inherits
[10:18:33.835]             invokeRestart <- base::invokeRestart
[10:18:33.835]             length <- base::length
[10:18:33.835]             list <- base::list
[10:18:33.835]             seq.int <- base::seq.int
[10:18:33.835]             signalCondition <- base::signalCondition
[10:18:33.835]             sys.calls <- base::sys.calls
[10:18:33.835]             `[[` <- base::`[[`
[10:18:33.835]             `+` <- base::`+`
[10:18:33.835]             `<<-` <- base::`<<-`
[10:18:33.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.835]                   3L)]
[10:18:33.835]             }
[10:18:33.835]             function(cond) {
[10:18:33.835]                 is_error <- inherits(cond, "error")
[10:18:33.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.835]                   NULL)
[10:18:33.835]                 if (is_error) {
[10:18:33.835]                   sessionInformation <- function() {
[10:18:33.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.835]                       search = base::search(), system = base::Sys.info())
[10:18:33.835]                   }
[10:18:33.835]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.835]                     cond$call), session = sessionInformation(), 
[10:18:33.835]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.835]                   signalCondition(cond)
[10:18:33.835]                 }
[10:18:33.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.835]                 "immediateCondition"))) {
[10:18:33.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.835]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.835]                   if (TRUE && !signal) {
[10:18:33.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.835]                     {
[10:18:33.835]                       inherits <- base::inherits
[10:18:33.835]                       invokeRestart <- base::invokeRestart
[10:18:33.835]                       is.null <- base::is.null
[10:18:33.835]                       muffled <- FALSE
[10:18:33.835]                       if (inherits(cond, "message")) {
[10:18:33.835]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.835]                         if (muffled) 
[10:18:33.835]                           invokeRestart("muffleMessage")
[10:18:33.835]                       }
[10:18:33.835]                       else if (inherits(cond, "warning")) {
[10:18:33.835]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.835]                         if (muffled) 
[10:18:33.835]                           invokeRestart("muffleWarning")
[10:18:33.835]                       }
[10:18:33.835]                       else if (inherits(cond, "condition")) {
[10:18:33.835]                         if (!is.null(pattern)) {
[10:18:33.835]                           computeRestarts <- base::computeRestarts
[10:18:33.835]                           grepl <- base::grepl
[10:18:33.835]                           restarts <- computeRestarts(cond)
[10:18:33.835]                           for (restart in restarts) {
[10:18:33.835]                             name <- restart$name
[10:18:33.835]                             if (is.null(name)) 
[10:18:33.835]                               next
[10:18:33.835]                             if (!grepl(pattern, name)) 
[10:18:33.835]                               next
[10:18:33.835]                             invokeRestart(restart)
[10:18:33.835]                             muffled <- TRUE
[10:18:33.835]                             break
[10:18:33.835]                           }
[10:18:33.835]                         }
[10:18:33.835]                       }
[10:18:33.835]                       invisible(muffled)
[10:18:33.835]                     }
[10:18:33.835]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.835]                   }
[10:18:33.835]                 }
[10:18:33.835]                 else {
[10:18:33.835]                   if (TRUE) {
[10:18:33.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.835]                     {
[10:18:33.835]                       inherits <- base::inherits
[10:18:33.835]                       invokeRestart <- base::invokeRestart
[10:18:33.835]                       is.null <- base::is.null
[10:18:33.835]                       muffled <- FALSE
[10:18:33.835]                       if (inherits(cond, "message")) {
[10:18:33.835]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.835]                         if (muffled) 
[10:18:33.835]                           invokeRestart("muffleMessage")
[10:18:33.835]                       }
[10:18:33.835]                       else if (inherits(cond, "warning")) {
[10:18:33.835]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.835]                         if (muffled) 
[10:18:33.835]                           invokeRestart("muffleWarning")
[10:18:33.835]                       }
[10:18:33.835]                       else if (inherits(cond, "condition")) {
[10:18:33.835]                         if (!is.null(pattern)) {
[10:18:33.835]                           computeRestarts <- base::computeRestarts
[10:18:33.835]                           grepl <- base::grepl
[10:18:33.835]                           restarts <- computeRestarts(cond)
[10:18:33.835]                           for (restart in restarts) {
[10:18:33.835]                             name <- restart$name
[10:18:33.835]                             if (is.null(name)) 
[10:18:33.835]                               next
[10:18:33.835]                             if (!grepl(pattern, name)) 
[10:18:33.835]                               next
[10:18:33.835]                             invokeRestart(restart)
[10:18:33.835]                             muffled <- TRUE
[10:18:33.835]                             break
[10:18:33.835]                           }
[10:18:33.835]                         }
[10:18:33.835]                       }
[10:18:33.835]                       invisible(muffled)
[10:18:33.835]                     }
[10:18:33.835]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.835]                   }
[10:18:33.835]                 }
[10:18:33.835]             }
[10:18:33.835]         }))
[10:18:33.835]     }, error = function(ex) {
[10:18:33.835]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.835]                 ...future.rng), started = ...future.startTime, 
[10:18:33.835]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.835]             version = "1.8"), class = "FutureResult")
[10:18:33.835]     }, finally = {
[10:18:33.835]         if (!identical(...future.workdir, getwd())) 
[10:18:33.835]             setwd(...future.workdir)
[10:18:33.835]         {
[10:18:33.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.835]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.835]             }
[10:18:33.835]             base::options(...future.oldOptions)
[10:18:33.835]             if (.Platform$OS.type == "windows") {
[10:18:33.835]                 old_names <- names(...future.oldEnvVars)
[10:18:33.835]                 envs <- base::Sys.getenv()
[10:18:33.835]                 names <- names(envs)
[10:18:33.835]                 common <- intersect(names, old_names)
[10:18:33.835]                 added <- setdiff(names, old_names)
[10:18:33.835]                 removed <- setdiff(old_names, names)
[10:18:33.835]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.835]                   envs[common]]
[10:18:33.835]                 NAMES <- toupper(changed)
[10:18:33.835]                 args <- list()
[10:18:33.835]                 for (kk in seq_along(NAMES)) {
[10:18:33.835]                   name <- changed[[kk]]
[10:18:33.835]                   NAME <- NAMES[[kk]]
[10:18:33.835]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.835]                     next
[10:18:33.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.835]                 }
[10:18:33.835]                 NAMES <- toupper(added)
[10:18:33.835]                 for (kk in seq_along(NAMES)) {
[10:18:33.835]                   name <- added[[kk]]
[10:18:33.835]                   NAME <- NAMES[[kk]]
[10:18:33.835]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.835]                     next
[10:18:33.835]                   args[[name]] <- ""
[10:18:33.835]                 }
[10:18:33.835]                 NAMES <- toupper(removed)
[10:18:33.835]                 for (kk in seq_along(NAMES)) {
[10:18:33.835]                   name <- removed[[kk]]
[10:18:33.835]                   NAME <- NAMES[[kk]]
[10:18:33.835]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.835]                     next
[10:18:33.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.835]                 }
[10:18:33.835]                 if (length(args) > 0) 
[10:18:33.835]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.835]             }
[10:18:33.835]             else {
[10:18:33.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.835]             }
[10:18:33.835]             {
[10:18:33.835]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.835]                   0L) {
[10:18:33.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.835]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.835]                   base::options(opts)
[10:18:33.835]                 }
[10:18:33.835]                 {
[10:18:33.835]                   {
[10:18:33.835]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.835]                     NULL
[10:18:33.835]                   }
[10:18:33.835]                   options(future.plan = NULL)
[10:18:33.835]                   if (is.na(NA_character_)) 
[10:18:33.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.835]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.835]                     .init = FALSE)
[10:18:33.835]                 }
[10:18:33.835]             }
[10:18:33.835]         }
[10:18:33.835]     })
[10:18:33.835]     if (TRUE) {
[10:18:33.835]         base::sink(type = "output", split = FALSE)
[10:18:33.835]         if (TRUE) {
[10:18:33.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.835]         }
[10:18:33.835]         else {
[10:18:33.835]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.835]         }
[10:18:33.835]         base::close(...future.stdout)
[10:18:33.835]         ...future.stdout <- NULL
[10:18:33.835]     }
[10:18:33.835]     ...future.result$conditions <- ...future.conditions
[10:18:33.835]     ...future.result$finished <- base::Sys.time()
[10:18:33.835]     ...future.result
[10:18:33.835] }
[10:18:33.838] Exporting 5 global objects (2.20 KiB) to cluster node #2 ...
[10:18:33.838] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[10:18:33.838] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[10:18:33.838] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:33.839] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:33.839] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[10:18:33.839] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[10:18:33.839] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:33.840] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.840] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:33.840] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.840] Exporting 5 global objects (2.20 KiB) to cluster node #2 ... DONE
[10:18:33.841] MultisessionFuture started
[10:18:33.841] - Launch lazy future ... done
[10:18:33.841] run() for ‘MultisessionFuture’ ... done
[10:18:33.841] Created future:
[10:18:33.841] MultisessionFuture:
[10:18:33.841] Label: ‘future_by-2’
[10:18:33.841] Expression:
[10:18:33.841] {
[10:18:33.841]     do.call(function(...) {
[10:18:33.841]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.841]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.841]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.841]             on.exit(options(oopts), add = TRUE)
[10:18:33.841]         }
[10:18:33.841]         {
[10:18:33.841]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.841]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.841]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.841]             })
[10:18:33.841]         }
[10:18:33.841]     }, args = future.call.arguments)
[10:18:33.841] }
[10:18:33.841] Lazy evaluation: FALSE
[10:18:33.841] Asynchronous evaluation: TRUE
[10:18:33.841] Local evaluation: TRUE
[10:18:33.841] Environment: 0x5584480f9d30
[10:18:33.841] Capture standard output: TRUE
[10:18:33.841] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.841] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.841] Packages: <none>
[10:18:33.841] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.841] Resolved: FALSE
[10:18:33.841] Value: <not collected>
[10:18:33.841] Conditions captured: <none>
[10:18:33.841] Early signaling: FALSE
[10:18:33.841] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.841] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.853] Chunk #2 of 2 ... DONE
[10:18:33.853] Launching 2 futures (chunks) ... DONE
[10:18:33.853] Resolving 2 futures (chunks) ...
[10:18:33.853] resolve() on list ...
[10:18:33.853]  recursive: 0
[10:18:33.853]  length: 2
[10:18:33.853] 
[10:18:33.854] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.854] - Validating connection of MultisessionFuture
[10:18:33.854] - received message: FutureResult
[10:18:33.854] - Received FutureResult
[10:18:33.854] - Erased future from FutureRegistry
[10:18:33.855] result() for ClusterFuture ...
[10:18:33.855] - result already collected: FutureResult
[10:18:33.855] result() for ClusterFuture ... done
[10:18:33.855] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.855] Future #1
[10:18:33.855] result() for ClusterFuture ...
[10:18:33.855] - result already collected: FutureResult
[10:18:33.855] result() for ClusterFuture ... done
[10:18:33.855] result() for ClusterFuture ...
[10:18:33.855] - result already collected: FutureResult
[10:18:33.855] result() for ClusterFuture ... done
[10:18:33.855] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:33.856] - nx: 2
[10:18:33.856] - relay: TRUE
[10:18:33.856] - stdout: TRUE
[10:18:33.856] - signal: TRUE
[10:18:33.856] - resignal: FALSE
[10:18:33.856] - force: TRUE
[10:18:33.856] - relayed: [n=2] FALSE, FALSE
[10:18:33.856] - queued futures: [n=2] FALSE, FALSE
[10:18:33.856]  - until=1
[10:18:33.856]  - relaying element #1
[10:18:33.856] result() for ClusterFuture ...
[10:18:33.856] - result already collected: FutureResult
[10:18:33.856] result() for ClusterFuture ... done
[10:18:33.857] result() for ClusterFuture ...
[10:18:33.857] - result already collected: FutureResult
[10:18:33.857] result() for ClusterFuture ... done
[10:18:33.857] result() for ClusterFuture ...
[10:18:33.857] - result already collected: FutureResult
[10:18:33.857] result() for ClusterFuture ... done
[10:18:33.857] result() for ClusterFuture ...
[10:18:33.857] - result already collected: FutureResult
[10:18:33.857] result() for ClusterFuture ... done
[10:18:33.857] - relayed: [n=2] TRUE, FALSE
[10:18:33.857] - queued futures: [n=2] TRUE, FALSE
[10:18:33.857] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:33.858]  length: 1 (resolved future 1)
[10:18:33.884] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.884] - Validating connection of MultisessionFuture
[10:18:33.885] - received message: FutureResult
[10:18:33.885] - Received FutureResult
[10:18:33.885] - Erased future from FutureRegistry
[10:18:33.885] result() for ClusterFuture ...
[10:18:33.885] - result already collected: FutureResult
[10:18:33.885] result() for ClusterFuture ... done
[10:18:33.885] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.885] Future #2
[10:18:33.886] result() for ClusterFuture ...
[10:18:33.886] - result already collected: FutureResult
[10:18:33.886] result() for ClusterFuture ... done
[10:18:33.886] result() for ClusterFuture ...
[10:18:33.886] - result already collected: FutureResult
[10:18:33.886] result() for ClusterFuture ... done
[10:18:33.886] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:33.886] - nx: 2
[10:18:33.886] - relay: TRUE
[10:18:33.886] - stdout: TRUE
[10:18:33.886] - signal: TRUE
[10:18:33.886] - resignal: FALSE
[10:18:33.887] - force: TRUE
[10:18:33.887] - relayed: [n=2] TRUE, FALSE
[10:18:33.887] - queued futures: [n=2] TRUE, FALSE
[10:18:33.887]  - until=2
[10:18:33.887]  - relaying element #2
[10:18:33.887] result() for ClusterFuture ...
[10:18:33.887] - result already collected: FutureResult
[10:18:33.887] result() for ClusterFuture ... done
[10:18:33.887] result() for ClusterFuture ...
[10:18:33.887] - result already collected: FutureResult
[10:18:33.887] result() for ClusterFuture ... done
[10:18:33.887] result() for ClusterFuture ...
[10:18:33.888] - result already collected: FutureResult
[10:18:33.888] result() for ClusterFuture ... done
[10:18:33.888] result() for ClusterFuture ...
[10:18:33.888] - result already collected: FutureResult
[10:18:33.888] result() for ClusterFuture ... done
[10:18:33.888] - relayed: [n=2] TRUE, TRUE
[10:18:33.888] - queued futures: [n=2] TRUE, TRUE
[10:18:33.888] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:33.888]  length: 0 (resolved future 2)
[10:18:33.888] Relaying remaining futures
[10:18:33.888] signalConditionsASAP(NULL, pos=0) ...
[10:18:33.888] - nx: 2
[10:18:33.889] - relay: TRUE
[10:18:33.889] - stdout: TRUE
[10:18:33.889] - signal: TRUE
[10:18:33.889] - resignal: FALSE
[10:18:33.889] - force: TRUE
[10:18:33.889] - relayed: [n=2] TRUE, TRUE
[10:18:33.889] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:33.889] - relayed: [n=2] TRUE, TRUE
[10:18:33.889] - queued futures: [n=2] TRUE, TRUE
[10:18:33.889] signalConditionsASAP(NULL, pos=0) ... done
[10:18:33.889] resolve() on list ... DONE
[10:18:33.889] result() for ClusterFuture ...
[10:18:33.890] - result already collected: FutureResult
[10:18:33.890] result() for ClusterFuture ... done
[10:18:33.890] result() for ClusterFuture ...
[10:18:33.890] - result already collected: FutureResult
[10:18:33.890] result() for ClusterFuture ... done
[10:18:33.890] result() for ClusterFuture ...
[10:18:33.890] - result already collected: FutureResult
[10:18:33.890] result() for ClusterFuture ... done
[10:18:33.890] result() for ClusterFuture ...
[10:18:33.890] - result already collected: FutureResult
[10:18:33.890] result() for ClusterFuture ... done
[10:18:33.890]  - Number of value chunks collected: 2
[10:18:33.891] Resolving 2 futures (chunks) ... DONE
[10:18:33.891] Reducing values from 2 chunks ...
[10:18:33.891]  - Number of values collected after concatenation: 3
[10:18:33.891]  - Number of values expected: 3
[10:18:33.891] Reducing values from 2 chunks ... DONE
[10:18:33.891] future_lapply() ... DONE
[10:18:33.891] future_by_internal() ... DONE
[10:18:33.892] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:18:33.892] future_lapply() ...
[10:18:33.894] Number of chunks: 2
[10:18:33.895] getGlobalsAndPackagesXApply() ...
[10:18:33.895]  - future.globals: TRUE
[10:18:33.895] getGlobalsAndPackages() ...
[10:18:33.895] Searching for globals...
[10:18:33.896] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:33.896] Searching for globals ... DONE
[10:18:33.896] Resolving globals: FALSE
[10:18:33.897] The total size of the 1 globals is 281 bytes (281 bytes)
[10:18:33.897] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[10:18:33.897] - globals: [1] ‘FUN’
[10:18:33.897] 
[10:18:33.897] getGlobalsAndPackages() ... DONE
[10:18:33.897]  - globals found/used: [n=1] ‘FUN’
[10:18:33.897]  - needed namespaces: [n=0] 
[10:18:33.897] Finding globals ... DONE
[10:18:33.898]  - use_args: TRUE
[10:18:33.898]  - Getting '...' globals ...
[10:18:33.898] resolve() on list ...
[10:18:33.898]  recursive: 0
[10:18:33.898]  length: 1
[10:18:33.898]  elements: ‘...’
[10:18:33.898]  length: 0 (resolved future 1)
[10:18:33.898] resolve() on list ... DONE
[10:18:33.899]    - '...' content: [n=0] 
[10:18:33.899] List of 1
[10:18:33.899]  $ ...: list()
[10:18:33.899]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.899]  - attr(*, "where")=List of 1
[10:18:33.899]   ..$ ...:<environment: 0x55844b577dd0> 
[10:18:33.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.899]  - attr(*, "resolved")= logi TRUE
[10:18:33.899]  - attr(*, "total_size")= num NA
[10:18:33.901]  - Getting '...' globals ... DONE
[10:18:33.901] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:33.901] List of 2
[10:18:33.901]  $ ...future.FUN:function (object, ...)  
[10:18:33.901]  $ ...          : list()
[10:18:33.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:33.901]  - attr(*, "where")=List of 2
[10:18:33.901]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:33.901]   ..$ ...          :<environment: 0x55844b577dd0> 
[10:18:33.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:33.901]  - attr(*, "resolved")= logi FALSE
[10:18:33.901]  - attr(*, "total_size")= num 18647
[10:18:33.904] Packages to be attached in all futures: [n=0] 
[10:18:33.904] getGlobalsAndPackagesXApply() ... DONE
[10:18:33.905] Number of futures (= number of chunks): 2
[10:18:33.905] Launching 2 futures (chunks) ...
[10:18:33.905] Chunk #1 of 2 ...
[10:18:33.905]  - Finding globals in 'X' for chunk #1 ...
[10:18:33.905] getGlobalsAndPackages() ...
[10:18:33.905] Searching for globals...
[10:18:33.906] 
[10:18:33.906] Searching for globals ... DONE
[10:18:33.906] - globals: [0] <none>
[10:18:33.906] getGlobalsAndPackages() ... DONE
[10:18:33.906]    + additional globals found: [n=0] 
[10:18:33.906]    + additional namespaces needed: [n=0] 
[10:18:33.906]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:33.906]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.906]  - seeds: <none>
[10:18:33.906]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.906] getGlobalsAndPackages() ...
[10:18:33.907] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.907] Resolving globals: FALSE
[10:18:33.907] Tweak future expression to call with '...' arguments ...
[10:18:33.907] {
[10:18:33.907]     do.call(function(...) {
[10:18:33.907]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.907]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.907]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.907]             on.exit(options(oopts), add = TRUE)
[10:18:33.907]         }
[10:18:33.907]         {
[10:18:33.907]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.907]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.907]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.907]             })
[10:18:33.907]         }
[10:18:33.907]     }, args = future.call.arguments)
[10:18:33.907] }
[10:18:33.907] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.907] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.908] 
[10:18:33.908] getGlobalsAndPackages() ... DONE
[10:18:33.908] run() for ‘Future’ ...
[10:18:33.908] - state: ‘created’
[10:18:33.908] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.922] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.922]   - Field: ‘node’
[10:18:33.923]   - Field: ‘label’
[10:18:33.923]   - Field: ‘local’
[10:18:33.923]   - Field: ‘owner’
[10:18:33.923]   - Field: ‘envir’
[10:18:33.923]   - Field: ‘workers’
[10:18:33.923]   - Field: ‘packages’
[10:18:33.923]   - Field: ‘gc’
[10:18:33.923]   - Field: ‘conditions’
[10:18:33.923]   - Field: ‘persistent’
[10:18:33.923]   - Field: ‘expr’
[10:18:33.923]   - Field: ‘uuid’
[10:18:33.923]   - Field: ‘seed’
[10:18:33.924]   - Field: ‘version’
[10:18:33.924]   - Field: ‘result’
[10:18:33.924]   - Field: ‘asynchronous’
[10:18:33.924]   - Field: ‘calls’
[10:18:33.924]   - Field: ‘globals’
[10:18:33.924]   - Field: ‘stdout’
[10:18:33.924]   - Field: ‘earlySignal’
[10:18:33.924]   - Field: ‘lazy’
[10:18:33.924]   - Field: ‘state’
[10:18:33.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.924] - Launch lazy future ...
[10:18:33.925] Packages needed by the future expression (n = 0): <none>
[10:18:33.925] Packages needed by future strategies (n = 0): <none>
[10:18:33.925] {
[10:18:33.925]     {
[10:18:33.925]         {
[10:18:33.925]             ...future.startTime <- base::Sys.time()
[10:18:33.925]             {
[10:18:33.925]                 {
[10:18:33.925]                   {
[10:18:33.925]                     {
[10:18:33.925]                       base::local({
[10:18:33.925]                         has_future <- base::requireNamespace("future", 
[10:18:33.925]                           quietly = TRUE)
[10:18:33.925]                         if (has_future) {
[10:18:33.925]                           ns <- base::getNamespace("future")
[10:18:33.925]                           version <- ns[[".package"]][["version"]]
[10:18:33.925]                           if (is.null(version)) 
[10:18:33.925]                             version <- utils::packageVersion("future")
[10:18:33.925]                         }
[10:18:33.925]                         else {
[10:18:33.925]                           version <- NULL
[10:18:33.925]                         }
[10:18:33.925]                         if (!has_future || version < "1.8.0") {
[10:18:33.925]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.925]                             "", base::R.version$version.string), 
[10:18:33.925]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.925]                               "release", "version")], collapse = " "), 
[10:18:33.925]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.925]                             info)
[10:18:33.925]                           info <- base::paste(info, collapse = "; ")
[10:18:33.925]                           if (!has_future) {
[10:18:33.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.925]                               info)
[10:18:33.925]                           }
[10:18:33.925]                           else {
[10:18:33.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.925]                               info, version)
[10:18:33.925]                           }
[10:18:33.925]                           base::stop(msg)
[10:18:33.925]                         }
[10:18:33.925]                       })
[10:18:33.925]                     }
[10:18:33.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.925]                     base::options(mc.cores = 1L)
[10:18:33.925]                   }
[10:18:33.925]                   ...future.strategy.old <- future::plan("list")
[10:18:33.925]                   options(future.plan = NULL)
[10:18:33.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.925]                 }
[10:18:33.925]                 ...future.workdir <- getwd()
[10:18:33.925]             }
[10:18:33.925]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.925]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.925]         }
[10:18:33.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.925]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.925]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.925]             base::names(...future.oldOptions))
[10:18:33.925]     }
[10:18:33.925]     if (FALSE) {
[10:18:33.925]     }
[10:18:33.925]     else {
[10:18:33.925]         if (TRUE) {
[10:18:33.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.925]                 open = "w")
[10:18:33.925]         }
[10:18:33.925]         else {
[10:18:33.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.925]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.925]         }
[10:18:33.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.925]             base::sink(type = "output", split = FALSE)
[10:18:33.925]             base::close(...future.stdout)
[10:18:33.925]         }, add = TRUE)
[10:18:33.925]     }
[10:18:33.925]     ...future.frame <- base::sys.nframe()
[10:18:33.925]     ...future.conditions <- base::list()
[10:18:33.925]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.925]     if (FALSE) {
[10:18:33.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.925]     }
[10:18:33.925]     ...future.result <- base::tryCatch({
[10:18:33.925]         base::withCallingHandlers({
[10:18:33.925]             ...future.value <- base::withVisible(base::local({
[10:18:33.925]                 ...future.makeSendCondition <- base::local({
[10:18:33.925]                   sendCondition <- NULL
[10:18:33.925]                   function(frame = 1L) {
[10:18:33.925]                     if (is.function(sendCondition)) 
[10:18:33.925]                       return(sendCondition)
[10:18:33.925]                     ns <- getNamespace("parallel")
[10:18:33.925]                     if (exists("sendData", mode = "function", 
[10:18:33.925]                       envir = ns)) {
[10:18:33.925]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.925]                         envir = ns)
[10:18:33.925]                       envir <- sys.frame(frame)
[10:18:33.925]                       master <- NULL
[10:18:33.925]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.925]                         !identical(envir, emptyenv())) {
[10:18:33.925]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.925]                           inherits = FALSE)) {
[10:18:33.925]                           master <- get("master", mode = "list", 
[10:18:33.925]                             envir = envir, inherits = FALSE)
[10:18:33.925]                           if (inherits(master, c("SOCKnode", 
[10:18:33.925]                             "SOCK0node"))) {
[10:18:33.925]                             sendCondition <<- function(cond) {
[10:18:33.925]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.925]                                 success = TRUE)
[10:18:33.925]                               parallel_sendData(master, data)
[10:18:33.925]                             }
[10:18:33.925]                             return(sendCondition)
[10:18:33.925]                           }
[10:18:33.925]                         }
[10:18:33.925]                         frame <- frame + 1L
[10:18:33.925]                         envir <- sys.frame(frame)
[10:18:33.925]                       }
[10:18:33.925]                     }
[10:18:33.925]                     sendCondition <<- function(cond) NULL
[10:18:33.925]                   }
[10:18:33.925]                 })
[10:18:33.925]                 withCallingHandlers({
[10:18:33.925]                   {
[10:18:33.925]                     do.call(function(...) {
[10:18:33.925]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.925]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.925]                         ...future.globals.maxSize)) {
[10:18:33.925]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.925]                         on.exit(options(oopts), add = TRUE)
[10:18:33.925]                       }
[10:18:33.925]                       {
[10:18:33.925]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.925]                           FUN = function(jj) {
[10:18:33.925]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.925]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.925]                           })
[10:18:33.925]                       }
[10:18:33.925]                     }, args = future.call.arguments)
[10:18:33.925]                   }
[10:18:33.925]                 }, immediateCondition = function(cond) {
[10:18:33.925]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.925]                   sendCondition(cond)
[10:18:33.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.925]                   {
[10:18:33.925]                     inherits <- base::inherits
[10:18:33.925]                     invokeRestart <- base::invokeRestart
[10:18:33.925]                     is.null <- base::is.null
[10:18:33.925]                     muffled <- FALSE
[10:18:33.925]                     if (inherits(cond, "message")) {
[10:18:33.925]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.925]                       if (muffled) 
[10:18:33.925]                         invokeRestart("muffleMessage")
[10:18:33.925]                     }
[10:18:33.925]                     else if (inherits(cond, "warning")) {
[10:18:33.925]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.925]                       if (muffled) 
[10:18:33.925]                         invokeRestart("muffleWarning")
[10:18:33.925]                     }
[10:18:33.925]                     else if (inherits(cond, "condition")) {
[10:18:33.925]                       if (!is.null(pattern)) {
[10:18:33.925]                         computeRestarts <- base::computeRestarts
[10:18:33.925]                         grepl <- base::grepl
[10:18:33.925]                         restarts <- computeRestarts(cond)
[10:18:33.925]                         for (restart in restarts) {
[10:18:33.925]                           name <- restart$name
[10:18:33.925]                           if (is.null(name)) 
[10:18:33.925]                             next
[10:18:33.925]                           if (!grepl(pattern, name)) 
[10:18:33.925]                             next
[10:18:33.925]                           invokeRestart(restart)
[10:18:33.925]                           muffled <- TRUE
[10:18:33.925]                           break
[10:18:33.925]                         }
[10:18:33.925]                       }
[10:18:33.925]                     }
[10:18:33.925]                     invisible(muffled)
[10:18:33.925]                   }
[10:18:33.925]                   muffleCondition(cond)
[10:18:33.925]                 })
[10:18:33.925]             }))
[10:18:33.925]             future::FutureResult(value = ...future.value$value, 
[10:18:33.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.925]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.925]                     ...future.globalenv.names))
[10:18:33.925]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.925]         }, condition = base::local({
[10:18:33.925]             c <- base::c
[10:18:33.925]             inherits <- base::inherits
[10:18:33.925]             invokeRestart <- base::invokeRestart
[10:18:33.925]             length <- base::length
[10:18:33.925]             list <- base::list
[10:18:33.925]             seq.int <- base::seq.int
[10:18:33.925]             signalCondition <- base::signalCondition
[10:18:33.925]             sys.calls <- base::sys.calls
[10:18:33.925]             `[[` <- base::`[[`
[10:18:33.925]             `+` <- base::`+`
[10:18:33.925]             `<<-` <- base::`<<-`
[10:18:33.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.925]                   3L)]
[10:18:33.925]             }
[10:18:33.925]             function(cond) {
[10:18:33.925]                 is_error <- inherits(cond, "error")
[10:18:33.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.925]                   NULL)
[10:18:33.925]                 if (is_error) {
[10:18:33.925]                   sessionInformation <- function() {
[10:18:33.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.925]                       search = base::search(), system = base::Sys.info())
[10:18:33.925]                   }
[10:18:33.925]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.925]                     cond$call), session = sessionInformation(), 
[10:18:33.925]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.925]                   signalCondition(cond)
[10:18:33.925]                 }
[10:18:33.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.925]                 "immediateCondition"))) {
[10:18:33.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.925]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.925]                   if (TRUE && !signal) {
[10:18:33.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.925]                     {
[10:18:33.925]                       inherits <- base::inherits
[10:18:33.925]                       invokeRestart <- base::invokeRestart
[10:18:33.925]                       is.null <- base::is.null
[10:18:33.925]                       muffled <- FALSE
[10:18:33.925]                       if (inherits(cond, "message")) {
[10:18:33.925]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.925]                         if (muffled) 
[10:18:33.925]                           invokeRestart("muffleMessage")
[10:18:33.925]                       }
[10:18:33.925]                       else if (inherits(cond, "warning")) {
[10:18:33.925]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.925]                         if (muffled) 
[10:18:33.925]                           invokeRestart("muffleWarning")
[10:18:33.925]                       }
[10:18:33.925]                       else if (inherits(cond, "condition")) {
[10:18:33.925]                         if (!is.null(pattern)) {
[10:18:33.925]                           computeRestarts <- base::computeRestarts
[10:18:33.925]                           grepl <- base::grepl
[10:18:33.925]                           restarts <- computeRestarts(cond)
[10:18:33.925]                           for (restart in restarts) {
[10:18:33.925]                             name <- restart$name
[10:18:33.925]                             if (is.null(name)) 
[10:18:33.925]                               next
[10:18:33.925]                             if (!grepl(pattern, name)) 
[10:18:33.925]                               next
[10:18:33.925]                             invokeRestart(restart)
[10:18:33.925]                             muffled <- TRUE
[10:18:33.925]                             break
[10:18:33.925]                           }
[10:18:33.925]                         }
[10:18:33.925]                       }
[10:18:33.925]                       invisible(muffled)
[10:18:33.925]                     }
[10:18:33.925]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.925]                   }
[10:18:33.925]                 }
[10:18:33.925]                 else {
[10:18:33.925]                   if (TRUE) {
[10:18:33.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.925]                     {
[10:18:33.925]                       inherits <- base::inherits
[10:18:33.925]                       invokeRestart <- base::invokeRestart
[10:18:33.925]                       is.null <- base::is.null
[10:18:33.925]                       muffled <- FALSE
[10:18:33.925]                       if (inherits(cond, "message")) {
[10:18:33.925]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.925]                         if (muffled) 
[10:18:33.925]                           invokeRestart("muffleMessage")
[10:18:33.925]                       }
[10:18:33.925]                       else if (inherits(cond, "warning")) {
[10:18:33.925]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.925]                         if (muffled) 
[10:18:33.925]                           invokeRestart("muffleWarning")
[10:18:33.925]                       }
[10:18:33.925]                       else if (inherits(cond, "condition")) {
[10:18:33.925]                         if (!is.null(pattern)) {
[10:18:33.925]                           computeRestarts <- base::computeRestarts
[10:18:33.925]                           grepl <- base::grepl
[10:18:33.925]                           restarts <- computeRestarts(cond)
[10:18:33.925]                           for (restart in restarts) {
[10:18:33.925]                             name <- restart$name
[10:18:33.925]                             if (is.null(name)) 
[10:18:33.925]                               next
[10:18:33.925]                             if (!grepl(pattern, name)) 
[10:18:33.925]                               next
[10:18:33.925]                             invokeRestart(restart)
[10:18:33.925]                             muffled <- TRUE
[10:18:33.925]                             break
[10:18:33.925]                           }
[10:18:33.925]                         }
[10:18:33.925]                       }
[10:18:33.925]                       invisible(muffled)
[10:18:33.925]                     }
[10:18:33.925]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.925]                   }
[10:18:33.925]                 }
[10:18:33.925]             }
[10:18:33.925]         }))
[10:18:33.925]     }, error = function(ex) {
[10:18:33.925]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.925]                 ...future.rng), started = ...future.startTime, 
[10:18:33.925]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.925]             version = "1.8"), class = "FutureResult")
[10:18:33.925]     }, finally = {
[10:18:33.925]         if (!identical(...future.workdir, getwd())) 
[10:18:33.925]             setwd(...future.workdir)
[10:18:33.925]         {
[10:18:33.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.925]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.925]             }
[10:18:33.925]             base::options(...future.oldOptions)
[10:18:33.925]             if (.Platform$OS.type == "windows") {
[10:18:33.925]                 old_names <- names(...future.oldEnvVars)
[10:18:33.925]                 envs <- base::Sys.getenv()
[10:18:33.925]                 names <- names(envs)
[10:18:33.925]                 common <- intersect(names, old_names)
[10:18:33.925]                 added <- setdiff(names, old_names)
[10:18:33.925]                 removed <- setdiff(old_names, names)
[10:18:33.925]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.925]                   envs[common]]
[10:18:33.925]                 NAMES <- toupper(changed)
[10:18:33.925]                 args <- list()
[10:18:33.925]                 for (kk in seq_along(NAMES)) {
[10:18:33.925]                   name <- changed[[kk]]
[10:18:33.925]                   NAME <- NAMES[[kk]]
[10:18:33.925]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.925]                     next
[10:18:33.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.925]                 }
[10:18:33.925]                 NAMES <- toupper(added)
[10:18:33.925]                 for (kk in seq_along(NAMES)) {
[10:18:33.925]                   name <- added[[kk]]
[10:18:33.925]                   NAME <- NAMES[[kk]]
[10:18:33.925]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.925]                     next
[10:18:33.925]                   args[[name]] <- ""
[10:18:33.925]                 }
[10:18:33.925]                 NAMES <- toupper(removed)
[10:18:33.925]                 for (kk in seq_along(NAMES)) {
[10:18:33.925]                   name <- removed[[kk]]
[10:18:33.925]                   NAME <- NAMES[[kk]]
[10:18:33.925]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.925]                     next
[10:18:33.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.925]                 }
[10:18:33.925]                 if (length(args) > 0) 
[10:18:33.925]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.925]             }
[10:18:33.925]             else {
[10:18:33.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.925]             }
[10:18:33.925]             {
[10:18:33.925]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.925]                   0L) {
[10:18:33.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.925]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.925]                   base::options(opts)
[10:18:33.925]                 }
[10:18:33.925]                 {
[10:18:33.925]                   {
[10:18:33.925]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.925]                     NULL
[10:18:33.925]                   }
[10:18:33.925]                   options(future.plan = NULL)
[10:18:33.925]                   if (is.na(NA_character_)) 
[10:18:33.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.925]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.925]                     .init = FALSE)
[10:18:33.925]                 }
[10:18:33.925]             }
[10:18:33.925]         }
[10:18:33.925]     })
[10:18:33.925]     if (TRUE) {
[10:18:33.925]         base::sink(type = "output", split = FALSE)
[10:18:33.925]         if (TRUE) {
[10:18:33.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.925]         }
[10:18:33.925]         else {
[10:18:33.925]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.925]         }
[10:18:33.925]         base::close(...future.stdout)
[10:18:33.925]         ...future.stdout <- NULL
[10:18:33.925]     }
[10:18:33.925]     ...future.result$conditions <- ...future.conditions
[10:18:33.925]     ...future.result$finished <- base::Sys.time()
[10:18:33.925]     ...future.result
[10:18:33.925] }
[10:18:33.928] Exporting 5 global objects (1.57 KiB) to cluster node #1 ...
[10:18:33.928] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[10:18:33.929] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[10:18:33.929] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:33.929] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:33.929] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[10:18:33.930] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[10:18:33.930] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:33.930] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.930] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:33.931] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:33.931] Exporting 5 global objects (1.57 KiB) to cluster node #1 ... DONE
[10:18:33.931] MultisessionFuture started
[10:18:33.932] - Launch lazy future ... done
[10:18:33.932] run() for ‘MultisessionFuture’ ... done
[10:18:33.932] Created future:
[10:18:33.932] MultisessionFuture:
[10:18:33.932] Label: ‘future_by-1’
[10:18:33.932] Expression:
[10:18:33.932] {
[10:18:33.932]     do.call(function(...) {
[10:18:33.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.932]             on.exit(options(oopts), add = TRUE)
[10:18:33.932]         }
[10:18:33.932]         {
[10:18:33.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.932]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.932]             })
[10:18:33.932]         }
[10:18:33.932]     }, args = future.call.arguments)
[10:18:33.932] }
[10:18:33.932] Lazy evaluation: FALSE
[10:18:33.932] Asynchronous evaluation: TRUE
[10:18:33.932] Local evaluation: TRUE
[10:18:33.932] Environment: 0x55844b5b5590
[10:18:33.932] Capture standard output: TRUE
[10:18:33.932] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.932] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.932] Packages: <none>
[10:18:33.932] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.932] Resolved: FALSE
[10:18:33.932] Value: <not collected>
[10:18:33.932] Conditions captured: <none>
[10:18:33.932] Early signaling: FALSE
[10:18:33.932] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.932] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.943] Chunk #1 of 2 ... DONE
[10:18:33.943] Chunk #2 of 2 ...
[10:18:33.944]  - Finding globals in 'X' for chunk #2 ...
[10:18:33.944] getGlobalsAndPackages() ...
[10:18:33.944] Searching for globals...
[10:18:33.944] 
[10:18:33.944] Searching for globals ... DONE
[10:18:33.945] - globals: [0] <none>
[10:18:33.945] getGlobalsAndPackages() ... DONE
[10:18:33.945]    + additional globals found: [n=0] 
[10:18:33.945]    + additional namespaces needed: [n=0] 
[10:18:33.945]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:33.945]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:33.945]  - seeds: <none>
[10:18:33.945]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.945] getGlobalsAndPackages() ...
[10:18:33.945] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.945] Resolving globals: FALSE
[10:18:33.946] Tweak future expression to call with '...' arguments ...
[10:18:33.946] {
[10:18:33.946]     do.call(function(...) {
[10:18:33.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.946]             on.exit(options(oopts), add = TRUE)
[10:18:33.946]         }
[10:18:33.946]         {
[10:18:33.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.946]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.946]             })
[10:18:33.946]         }
[10:18:33.946]     }, args = future.call.arguments)
[10:18:33.946] }
[10:18:33.948] Tweak future expression to call with '...' arguments ... DONE
[10:18:33.949] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:33.949] 
[10:18:33.949] getGlobalsAndPackages() ... DONE
[10:18:33.949] run() for ‘Future’ ...
[10:18:33.949] - state: ‘created’
[10:18:33.949] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:33.963] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:33.963]   - Field: ‘node’
[10:18:33.963]   - Field: ‘label’
[10:18:33.963]   - Field: ‘local’
[10:18:33.963]   - Field: ‘owner’
[10:18:33.963]   - Field: ‘envir’
[10:18:33.964]   - Field: ‘workers’
[10:18:33.964]   - Field: ‘packages’
[10:18:33.964]   - Field: ‘gc’
[10:18:33.964]   - Field: ‘conditions’
[10:18:33.964]   - Field: ‘persistent’
[10:18:33.964]   - Field: ‘expr’
[10:18:33.964]   - Field: ‘uuid’
[10:18:33.964]   - Field: ‘seed’
[10:18:33.964]   - Field: ‘version’
[10:18:33.964]   - Field: ‘result’
[10:18:33.964]   - Field: ‘asynchronous’
[10:18:33.964]   - Field: ‘calls’
[10:18:33.964]   - Field: ‘globals’
[10:18:33.965]   - Field: ‘stdout’
[10:18:33.965]   - Field: ‘earlySignal’
[10:18:33.965]   - Field: ‘lazy’
[10:18:33.965]   - Field: ‘state’
[10:18:33.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:33.965] - Launch lazy future ...
[10:18:33.965] Packages needed by the future expression (n = 0): <none>
[10:18:33.965] Packages needed by future strategies (n = 0): <none>
[10:18:33.966] {
[10:18:33.966]     {
[10:18:33.966]         {
[10:18:33.966]             ...future.startTime <- base::Sys.time()
[10:18:33.966]             {
[10:18:33.966]                 {
[10:18:33.966]                   {
[10:18:33.966]                     {
[10:18:33.966]                       base::local({
[10:18:33.966]                         has_future <- base::requireNamespace("future", 
[10:18:33.966]                           quietly = TRUE)
[10:18:33.966]                         if (has_future) {
[10:18:33.966]                           ns <- base::getNamespace("future")
[10:18:33.966]                           version <- ns[[".package"]][["version"]]
[10:18:33.966]                           if (is.null(version)) 
[10:18:33.966]                             version <- utils::packageVersion("future")
[10:18:33.966]                         }
[10:18:33.966]                         else {
[10:18:33.966]                           version <- NULL
[10:18:33.966]                         }
[10:18:33.966]                         if (!has_future || version < "1.8.0") {
[10:18:33.966]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:33.966]                             "", base::R.version$version.string), 
[10:18:33.966]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:33.966]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:33.966]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:33.966]                               "release", "version")], collapse = " "), 
[10:18:33.966]                             hostname = base::Sys.info()[["nodename"]])
[10:18:33.966]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:33.966]                             info)
[10:18:33.966]                           info <- base::paste(info, collapse = "; ")
[10:18:33.966]                           if (!has_future) {
[10:18:33.966]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:33.966]                               info)
[10:18:33.966]                           }
[10:18:33.966]                           else {
[10:18:33.966]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:33.966]                               info, version)
[10:18:33.966]                           }
[10:18:33.966]                           base::stop(msg)
[10:18:33.966]                         }
[10:18:33.966]                       })
[10:18:33.966]                     }
[10:18:33.966]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:33.966]                     base::options(mc.cores = 1L)
[10:18:33.966]                   }
[10:18:33.966]                   ...future.strategy.old <- future::plan("list")
[10:18:33.966]                   options(future.plan = NULL)
[10:18:33.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:33.966]                 }
[10:18:33.966]                 ...future.workdir <- getwd()
[10:18:33.966]             }
[10:18:33.966]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:33.966]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:33.966]         }
[10:18:33.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:33.966]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:33.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:33.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:33.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:33.966]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:33.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:33.966]             base::names(...future.oldOptions))
[10:18:33.966]     }
[10:18:33.966]     if (FALSE) {
[10:18:33.966]     }
[10:18:33.966]     else {
[10:18:33.966]         if (TRUE) {
[10:18:33.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:33.966]                 open = "w")
[10:18:33.966]         }
[10:18:33.966]         else {
[10:18:33.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:33.966]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:33.966]         }
[10:18:33.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:33.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:33.966]             base::sink(type = "output", split = FALSE)
[10:18:33.966]             base::close(...future.stdout)
[10:18:33.966]         }, add = TRUE)
[10:18:33.966]     }
[10:18:33.966]     ...future.frame <- base::sys.nframe()
[10:18:33.966]     ...future.conditions <- base::list()
[10:18:33.966]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:33.966]     if (FALSE) {
[10:18:33.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:33.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:33.966]     }
[10:18:33.966]     ...future.result <- base::tryCatch({
[10:18:33.966]         base::withCallingHandlers({
[10:18:33.966]             ...future.value <- base::withVisible(base::local({
[10:18:33.966]                 ...future.makeSendCondition <- base::local({
[10:18:33.966]                   sendCondition <- NULL
[10:18:33.966]                   function(frame = 1L) {
[10:18:33.966]                     if (is.function(sendCondition)) 
[10:18:33.966]                       return(sendCondition)
[10:18:33.966]                     ns <- getNamespace("parallel")
[10:18:33.966]                     if (exists("sendData", mode = "function", 
[10:18:33.966]                       envir = ns)) {
[10:18:33.966]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:33.966]                         envir = ns)
[10:18:33.966]                       envir <- sys.frame(frame)
[10:18:33.966]                       master <- NULL
[10:18:33.966]                       while (!identical(envir, .GlobalEnv) && 
[10:18:33.966]                         !identical(envir, emptyenv())) {
[10:18:33.966]                         if (exists("master", mode = "list", envir = envir, 
[10:18:33.966]                           inherits = FALSE)) {
[10:18:33.966]                           master <- get("master", mode = "list", 
[10:18:33.966]                             envir = envir, inherits = FALSE)
[10:18:33.966]                           if (inherits(master, c("SOCKnode", 
[10:18:33.966]                             "SOCK0node"))) {
[10:18:33.966]                             sendCondition <<- function(cond) {
[10:18:33.966]                               data <- list(type = "VALUE", value = cond, 
[10:18:33.966]                                 success = TRUE)
[10:18:33.966]                               parallel_sendData(master, data)
[10:18:33.966]                             }
[10:18:33.966]                             return(sendCondition)
[10:18:33.966]                           }
[10:18:33.966]                         }
[10:18:33.966]                         frame <- frame + 1L
[10:18:33.966]                         envir <- sys.frame(frame)
[10:18:33.966]                       }
[10:18:33.966]                     }
[10:18:33.966]                     sendCondition <<- function(cond) NULL
[10:18:33.966]                   }
[10:18:33.966]                 })
[10:18:33.966]                 withCallingHandlers({
[10:18:33.966]                   {
[10:18:33.966]                     do.call(function(...) {
[10:18:33.966]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.966]                       if (!identical(...future.globals.maxSize.org, 
[10:18:33.966]                         ...future.globals.maxSize)) {
[10:18:33.966]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.966]                         on.exit(options(oopts), add = TRUE)
[10:18:33.966]                       }
[10:18:33.966]                       {
[10:18:33.966]                         lapply(seq_along(...future.elements_ii), 
[10:18:33.966]                           FUN = function(jj) {
[10:18:33.966]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.966]                             ...future.FUN(...future.X_jj, ...)
[10:18:33.966]                           })
[10:18:33.966]                       }
[10:18:33.966]                     }, args = future.call.arguments)
[10:18:33.966]                   }
[10:18:33.966]                 }, immediateCondition = function(cond) {
[10:18:33.966]                   sendCondition <- ...future.makeSendCondition()
[10:18:33.966]                   sendCondition(cond)
[10:18:33.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.966]                   {
[10:18:33.966]                     inherits <- base::inherits
[10:18:33.966]                     invokeRestart <- base::invokeRestart
[10:18:33.966]                     is.null <- base::is.null
[10:18:33.966]                     muffled <- FALSE
[10:18:33.966]                     if (inherits(cond, "message")) {
[10:18:33.966]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:33.966]                       if (muffled) 
[10:18:33.966]                         invokeRestart("muffleMessage")
[10:18:33.966]                     }
[10:18:33.966]                     else if (inherits(cond, "warning")) {
[10:18:33.966]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:33.966]                       if (muffled) 
[10:18:33.966]                         invokeRestart("muffleWarning")
[10:18:33.966]                     }
[10:18:33.966]                     else if (inherits(cond, "condition")) {
[10:18:33.966]                       if (!is.null(pattern)) {
[10:18:33.966]                         computeRestarts <- base::computeRestarts
[10:18:33.966]                         grepl <- base::grepl
[10:18:33.966]                         restarts <- computeRestarts(cond)
[10:18:33.966]                         for (restart in restarts) {
[10:18:33.966]                           name <- restart$name
[10:18:33.966]                           if (is.null(name)) 
[10:18:33.966]                             next
[10:18:33.966]                           if (!grepl(pattern, name)) 
[10:18:33.966]                             next
[10:18:33.966]                           invokeRestart(restart)
[10:18:33.966]                           muffled <- TRUE
[10:18:33.966]                           break
[10:18:33.966]                         }
[10:18:33.966]                       }
[10:18:33.966]                     }
[10:18:33.966]                     invisible(muffled)
[10:18:33.966]                   }
[10:18:33.966]                   muffleCondition(cond)
[10:18:33.966]                 })
[10:18:33.966]             }))
[10:18:33.966]             future::FutureResult(value = ...future.value$value, 
[10:18:33.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.966]                   ...future.rng), globalenv = if (FALSE) 
[10:18:33.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:33.966]                     ...future.globalenv.names))
[10:18:33.966]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:33.966]         }, condition = base::local({
[10:18:33.966]             c <- base::c
[10:18:33.966]             inherits <- base::inherits
[10:18:33.966]             invokeRestart <- base::invokeRestart
[10:18:33.966]             length <- base::length
[10:18:33.966]             list <- base::list
[10:18:33.966]             seq.int <- base::seq.int
[10:18:33.966]             signalCondition <- base::signalCondition
[10:18:33.966]             sys.calls <- base::sys.calls
[10:18:33.966]             `[[` <- base::`[[`
[10:18:33.966]             `+` <- base::`+`
[10:18:33.966]             `<<-` <- base::`<<-`
[10:18:33.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:33.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:33.966]                   3L)]
[10:18:33.966]             }
[10:18:33.966]             function(cond) {
[10:18:33.966]                 is_error <- inherits(cond, "error")
[10:18:33.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:33.966]                   NULL)
[10:18:33.966]                 if (is_error) {
[10:18:33.966]                   sessionInformation <- function() {
[10:18:33.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:33.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:33.966]                       search = base::search(), system = base::Sys.info())
[10:18:33.966]                   }
[10:18:33.966]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:33.966]                     cond$call), session = sessionInformation(), 
[10:18:33.966]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:33.966]                   signalCondition(cond)
[10:18:33.966]                 }
[10:18:33.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:33.966]                 "immediateCondition"))) {
[10:18:33.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:33.966]                   ...future.conditions[[length(...future.conditions) + 
[10:18:33.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:33.966]                   if (TRUE && !signal) {
[10:18:33.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.966]                     {
[10:18:33.966]                       inherits <- base::inherits
[10:18:33.966]                       invokeRestart <- base::invokeRestart
[10:18:33.966]                       is.null <- base::is.null
[10:18:33.966]                       muffled <- FALSE
[10:18:33.966]                       if (inherits(cond, "message")) {
[10:18:33.966]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.966]                         if (muffled) 
[10:18:33.966]                           invokeRestart("muffleMessage")
[10:18:33.966]                       }
[10:18:33.966]                       else if (inherits(cond, "warning")) {
[10:18:33.966]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.966]                         if (muffled) 
[10:18:33.966]                           invokeRestart("muffleWarning")
[10:18:33.966]                       }
[10:18:33.966]                       else if (inherits(cond, "condition")) {
[10:18:33.966]                         if (!is.null(pattern)) {
[10:18:33.966]                           computeRestarts <- base::computeRestarts
[10:18:33.966]                           grepl <- base::grepl
[10:18:33.966]                           restarts <- computeRestarts(cond)
[10:18:33.966]                           for (restart in restarts) {
[10:18:33.966]                             name <- restart$name
[10:18:33.966]                             if (is.null(name)) 
[10:18:33.966]                               next
[10:18:33.966]                             if (!grepl(pattern, name)) 
[10:18:33.966]                               next
[10:18:33.966]                             invokeRestart(restart)
[10:18:33.966]                             muffled <- TRUE
[10:18:33.966]                             break
[10:18:33.966]                           }
[10:18:33.966]                         }
[10:18:33.966]                       }
[10:18:33.966]                       invisible(muffled)
[10:18:33.966]                     }
[10:18:33.966]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.966]                   }
[10:18:33.966]                 }
[10:18:33.966]                 else {
[10:18:33.966]                   if (TRUE) {
[10:18:33.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:33.966]                     {
[10:18:33.966]                       inherits <- base::inherits
[10:18:33.966]                       invokeRestart <- base::invokeRestart
[10:18:33.966]                       is.null <- base::is.null
[10:18:33.966]                       muffled <- FALSE
[10:18:33.966]                       if (inherits(cond, "message")) {
[10:18:33.966]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:33.966]                         if (muffled) 
[10:18:33.966]                           invokeRestart("muffleMessage")
[10:18:33.966]                       }
[10:18:33.966]                       else if (inherits(cond, "warning")) {
[10:18:33.966]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:33.966]                         if (muffled) 
[10:18:33.966]                           invokeRestart("muffleWarning")
[10:18:33.966]                       }
[10:18:33.966]                       else if (inherits(cond, "condition")) {
[10:18:33.966]                         if (!is.null(pattern)) {
[10:18:33.966]                           computeRestarts <- base::computeRestarts
[10:18:33.966]                           grepl <- base::grepl
[10:18:33.966]                           restarts <- computeRestarts(cond)
[10:18:33.966]                           for (restart in restarts) {
[10:18:33.966]                             name <- restart$name
[10:18:33.966]                             if (is.null(name)) 
[10:18:33.966]                               next
[10:18:33.966]                             if (!grepl(pattern, name)) 
[10:18:33.966]                               next
[10:18:33.966]                             invokeRestart(restart)
[10:18:33.966]                             muffled <- TRUE
[10:18:33.966]                             break
[10:18:33.966]                           }
[10:18:33.966]                         }
[10:18:33.966]                       }
[10:18:33.966]                       invisible(muffled)
[10:18:33.966]                     }
[10:18:33.966]                     muffleCondition(cond, pattern = "^muffle")
[10:18:33.966]                   }
[10:18:33.966]                 }
[10:18:33.966]             }
[10:18:33.966]         }))
[10:18:33.966]     }, error = function(ex) {
[10:18:33.966]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:33.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:33.966]                 ...future.rng), started = ...future.startTime, 
[10:18:33.966]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:33.966]             version = "1.8"), class = "FutureResult")
[10:18:33.966]     }, finally = {
[10:18:33.966]         if (!identical(...future.workdir, getwd())) 
[10:18:33.966]             setwd(...future.workdir)
[10:18:33.966]         {
[10:18:33.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:33.966]                 ...future.oldOptions$nwarnings <- NULL
[10:18:33.966]             }
[10:18:33.966]             base::options(...future.oldOptions)
[10:18:33.966]             if (.Platform$OS.type == "windows") {
[10:18:33.966]                 old_names <- names(...future.oldEnvVars)
[10:18:33.966]                 envs <- base::Sys.getenv()
[10:18:33.966]                 names <- names(envs)
[10:18:33.966]                 common <- intersect(names, old_names)
[10:18:33.966]                 added <- setdiff(names, old_names)
[10:18:33.966]                 removed <- setdiff(old_names, names)
[10:18:33.966]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:33.966]                   envs[common]]
[10:18:33.966]                 NAMES <- toupper(changed)
[10:18:33.966]                 args <- list()
[10:18:33.966]                 for (kk in seq_along(NAMES)) {
[10:18:33.966]                   name <- changed[[kk]]
[10:18:33.966]                   NAME <- NAMES[[kk]]
[10:18:33.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.966]                     next
[10:18:33.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.966]                 }
[10:18:33.966]                 NAMES <- toupper(added)
[10:18:33.966]                 for (kk in seq_along(NAMES)) {
[10:18:33.966]                   name <- added[[kk]]
[10:18:33.966]                   NAME <- NAMES[[kk]]
[10:18:33.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.966]                     next
[10:18:33.966]                   args[[name]] <- ""
[10:18:33.966]                 }
[10:18:33.966]                 NAMES <- toupper(removed)
[10:18:33.966]                 for (kk in seq_along(NAMES)) {
[10:18:33.966]                   name <- removed[[kk]]
[10:18:33.966]                   NAME <- NAMES[[kk]]
[10:18:33.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:33.966]                     next
[10:18:33.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:33.966]                 }
[10:18:33.966]                 if (length(args) > 0) 
[10:18:33.966]                   base::do.call(base::Sys.setenv, args = args)
[10:18:33.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:33.966]             }
[10:18:33.966]             else {
[10:18:33.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:33.966]             }
[10:18:33.966]             {
[10:18:33.966]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:33.966]                   0L) {
[10:18:33.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:33.966]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:33.966]                   base::options(opts)
[10:18:33.966]                 }
[10:18:33.966]                 {
[10:18:33.966]                   {
[10:18:33.966]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:33.966]                     NULL
[10:18:33.966]                   }
[10:18:33.966]                   options(future.plan = NULL)
[10:18:33.966]                   if (is.na(NA_character_)) 
[10:18:33.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:33.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:33.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:33.966]                     .init = FALSE)
[10:18:33.966]                 }
[10:18:33.966]             }
[10:18:33.966]         }
[10:18:33.966]     })
[10:18:33.966]     if (TRUE) {
[10:18:33.966]         base::sink(type = "output", split = FALSE)
[10:18:33.966]         if (TRUE) {
[10:18:33.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:33.966]         }
[10:18:33.966]         else {
[10:18:33.966]             ...future.result["stdout"] <- base::list(NULL)
[10:18:33.966]         }
[10:18:33.966]         base::close(...future.stdout)
[10:18:33.966]         ...future.stdout <- NULL
[10:18:33.966]     }
[10:18:33.966]     ...future.result$conditions <- ...future.conditions
[10:18:33.966]     ...future.result$finished <- base::Sys.time()
[10:18:33.966]     ...future.result
[10:18:33.966] }
[10:18:33.969] Exporting 5 global objects (2.20 KiB) to cluster node #2 ...
[10:18:33.969] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[10:18:33.969] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[10:18:33.969] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:33.970] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:33.970] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[10:18:33.970] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[10:18:33.970] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:33.970] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.971] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:33.971] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:33.971] Exporting 5 global objects (2.20 KiB) to cluster node #2 ... DONE
[10:18:33.971] MultisessionFuture started
[10:18:33.972] - Launch lazy future ... done
[10:18:33.972] run() for ‘MultisessionFuture’ ... done
[10:18:33.972] Created future:
[10:18:33.972] MultisessionFuture:
[10:18:33.972] Label: ‘future_by-2’
[10:18:33.972] Expression:
[10:18:33.972] {
[10:18:33.972]     do.call(function(...) {
[10:18:33.972]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:33.972]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:33.972]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:33.972]             on.exit(options(oopts), add = TRUE)
[10:18:33.972]         }
[10:18:33.972]         {
[10:18:33.972]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:33.972]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:33.972]                 ...future.FUN(...future.X_jj, ...)
[10:18:33.972]             })
[10:18:33.972]         }
[10:18:33.972]     }, args = future.call.arguments)
[10:18:33.972] }
[10:18:33.972] Lazy evaluation: FALSE
[10:18:33.972] Asynchronous evaluation: TRUE
[10:18:33.972] Local evaluation: TRUE
[10:18:33.972] Environment: 0x55844b5b5590
[10:18:33.972] Capture standard output: TRUE
[10:18:33.972] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:33.972] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:33.972] Packages: <none>
[10:18:33.972] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:33.972] Resolved: FALSE
[10:18:33.972] Value: <not collected>
[10:18:33.972] Conditions captured: <none>
[10:18:33.972] Early signaling: FALSE
[10:18:33.972] Owner process: 6cf44bd9-0a3b-32b7-4366-36e37d27f7ee
[10:18:33.972] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:33.984] Chunk #2 of 2 ... DONE
[10:18:33.984] Launching 2 futures (chunks) ... DONE
[10:18:33.984] Resolving 2 futures (chunks) ...
[10:18:33.984] resolve() on list ...
[10:18:33.984]  recursive: 0
[10:18:33.984]  length: 2
[10:18:33.984] 
[10:18:33.985] receiveMessageFromWorker() for ClusterFuture ...
[10:18:33.985] - Validating connection of MultisessionFuture
[10:18:33.985] - received message: FutureResult
[10:18:33.985] - Received FutureResult
[10:18:33.985] - Erased future from FutureRegistry
[10:18:33.985] result() for ClusterFuture ...
[10:18:33.986] - result already collected: FutureResult
[10:18:33.986] result() for ClusterFuture ... done
[10:18:33.986] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:33.986] Future #1
[10:18:33.986] result() for ClusterFuture ...
[10:18:33.986] - result already collected: FutureResult
[10:18:33.986] result() for ClusterFuture ... done
[10:18:33.986] result() for ClusterFuture ...
[10:18:33.986] - result already collected: FutureResult
[10:18:33.986] result() for ClusterFuture ... done
[10:18:33.986] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:33.986] - nx: 2
[10:18:33.987] - relay: TRUE
[10:18:33.987] - stdout: TRUE
[10:18:33.987] - signal: TRUE
[10:18:33.987] - resignal: FALSE
[10:18:33.987] - force: TRUE
[10:18:33.987] - relayed: [n=2] FALSE, FALSE
[10:18:33.987] - queued futures: [n=2] FALSE, FALSE
[10:18:33.987]  - until=1
[10:18:33.987]  - relaying element #1
[10:18:33.987] result() for ClusterFuture ...
[10:18:33.987] - result already collected: FutureResult
[10:18:33.987] result() for ClusterFuture ... done
[10:18:33.988] result() for ClusterFuture ...
[10:18:33.988] - result already collected: FutureResult
[10:18:33.988] result() for ClusterFuture ... done
[10:18:33.988] result() for ClusterFuture ...
[10:18:33.988] - result already collected: FutureResult
[10:18:33.988] result() for ClusterFuture ... done
[10:18:33.988] result() for ClusterFuture ...
[10:18:33.988] - result already collected: FutureResult
[10:18:33.988] result() for ClusterFuture ... done
[10:18:33.988] - relayed: [n=2] TRUE, FALSE
[10:18:33.988] - queued futures: [n=2] TRUE, FALSE
[10:18:33.988] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:33.989]  length: 1 (resolved future 1)
[10:18:34.015] receiveMessageFromWorker() for ClusterFuture ...
[10:18:34.015] - Validating connection of MultisessionFuture
[10:18:34.016] - received message: FutureResult
[10:18:34.016] - Received FutureResult
[10:18:34.016] - Erased future from FutureRegistry
[10:18:34.016] result() for ClusterFuture ...
[10:18:34.016] - result already collected: FutureResult
[10:18:34.016] result() for ClusterFuture ... done
[10:18:34.016] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:34.016] Future #2
[10:18:34.017] result() for ClusterFuture ...
[10:18:34.017] - result already collected: FutureResult
[10:18:34.017] result() for ClusterFuture ... done
[10:18:34.017] result() for ClusterFuture ...
[10:18:34.017] - result already collected: FutureResult
[10:18:34.017] result() for ClusterFuture ... done
[10:18:34.017] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:34.017] - nx: 2
[10:18:34.017] - relay: TRUE
[10:18:34.017] - stdout: TRUE
[10:18:34.017] - signal: TRUE
[10:18:34.017] - resignal: FALSE
[10:18:34.018] - force: TRUE
[10:18:34.018] - relayed: [n=2] TRUE, FALSE
[10:18:34.018] - queued futures: [n=2] TRUE, FALSE
[10:18:34.018]  - until=2
[10:18:34.018]  - relaying element #2
[10:18:34.018] result() for ClusterFuture ...
[10:18:34.018] - result already collected: FutureResult
[10:18:34.018] result() for ClusterFuture ... done
[10:18:34.018] result() for ClusterFuture ...
[10:18:34.018] - result already collected: FutureResult
[10:18:34.018] result() for ClusterFuture ... done
[10:18:34.019] result() for ClusterFuture ...
[10:18:34.019] - result already collected: FutureResult
[10:18:34.019] result() for ClusterFuture ... done
[10:18:34.019] result() for ClusterFuture ...
[10:18:34.019] - result already collected: FutureResult
[10:18:34.019] result() for ClusterFuture ... done
[10:18:34.019] - relayed: [n=2] TRUE, TRUE
[10:18:34.019] - queued futures: [n=2] TRUE, TRUE
[10:18:34.019] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:34.019]  length: 0 (resolved future 2)
[10:18:34.019] Relaying remaining futures
[10:18:34.019] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.019] - nx: 2
[10:18:34.020] - relay: TRUE
[10:18:34.020] - stdout: TRUE
[10:18:34.020] - signal: TRUE
[10:18:34.020] - resignal: FALSE
[10:18:34.020] - force: TRUE
[10:18:34.020] - relayed: [n=2] TRUE, TRUE
[10:18:34.020] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:34.020] - relayed: [n=2] TRUE, TRUE
[10:18:34.020] - queued futures: [n=2] TRUE, TRUE
[10:18:34.020] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.020] resolve() on list ... DONE
[10:18:34.020] result() for ClusterFuture ...
[10:18:34.021] - result already collected: FutureResult
[10:18:34.021] result() for ClusterFuture ... done
[10:18:34.021] result() for ClusterFuture ...
[10:18:34.021] - result already collected: FutureResult
[10:18:34.021] result() for ClusterFuture ... done
[10:18:34.021] result() for ClusterFuture ...
[10:18:34.021] - result already collected: FutureResult
[10:18:34.021] result() for ClusterFuture ... done
[10:18:34.021] result() for ClusterFuture ...
[10:18:34.021] - result already collected: FutureResult
[10:18:34.021] result() for ClusterFuture ... done
[10:18:34.021]  - Number of value chunks collected: 2
[10:18:34.022] Resolving 2 futures (chunks) ... DONE
[10:18:34.022] Reducing values from 2 chunks ...
[10:18:34.022]  - Number of values collected after concatenation: 3
[10:18:34.022]  - Number of values expected: 3
[10:18:34.022] Reducing values from 2 chunks ... DONE
[10:18:34.022] future_lapply() ... DONE
[10:18:34.022] future_by_internal() ... DONE
[10:18:34.023] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[10:18:34.024] plan(): Setting new future strategy stack:
[10:18:34.024] List of future strategies:
[10:18:34.024] 1. FutureStrategy:
[10:18:34.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.024]    - tweaked: FALSE
[10:18:34.024]    - call: future::plan(oplan)
[10:18:34.025] plan(): nbrOfWorkers() = 1
> 
