
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[08:24:56.194] plan(): Setting new future strategy stack:
[08:24:56.194] List of future strategies:
[08:24:56.194] 1. sequential:
[08:24:56.194]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.194]    - tweaked: FALSE
[08:24:56.194]    - call: future::plan("sequential")
[08:24:56.209] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[08:24:56.269] plan(): Setting new future strategy stack:
[08:24:56.269] List of future strategies:
[08:24:56.269] 1. sequential:
[08:24:56.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.269]    - tweaked: FALSE
[08:24:56.269]    - call: plan(strategy)
[08:24:56.283] plan(): nbrOfWorkers() = 1
[08:24:56.283] future_by_internal() ...
[08:24:56.283] future_lapply() ...
[08:24:56.287] Number of chunks: 1
[08:24:56.287] getGlobalsAndPackagesXApply() ...
[08:24:56.287]  - future.globals: TRUE
[08:24:56.288] getGlobalsAndPackages() ...
[08:24:56.288] Searching for globals...
[08:24:56.290] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.290] Searching for globals ... DONE
[08:24:56.290] Resolving globals: FALSE
[08:24:56.291] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.292] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.292] - globals: [1] ‘FUN’
[08:24:56.292] 
[08:24:56.292] getGlobalsAndPackages() ... DONE
[08:24:56.292]  - globals found/used: [n=1] ‘FUN’
[08:24:56.292]  - needed namespaces: [n=0] 
[08:24:56.292] Finding globals ... DONE
[08:24:56.292]  - use_args: TRUE
[08:24:56.292]  - Getting '...' globals ...
[08:24:56.293] resolve() on list ...
[08:24:56.293]  recursive: 0
[08:24:56.293]  length: 1
[08:24:56.294]  elements: ‘...’
[08:24:56.294]  length: 0 (resolved future 1)
[08:24:56.294] resolve() on list ... DONE
[08:24:56.294]    - '...' content: [n=0] 
[08:24:56.294] List of 1
[08:24:56.294]  $ ...: list()
[08:24:56.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.294]  - attr(*, "where")=List of 1
[08:24:56.294]   ..$ ...:<environment: 0x557b26272d60> 
[08:24:56.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.294]  - attr(*, "resolved")= logi TRUE
[08:24:56.294]  - attr(*, "total_size")= num NA
[08:24:56.298]  - Getting '...' globals ... DONE
[08:24:56.298] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.298] List of 2
[08:24:56.298]  $ ...future.FUN:function (object, ...)  
[08:24:56.298]  $ ...          : list()
[08:24:56.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.298]  - attr(*, "where")=List of 2
[08:24:56.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.298]   ..$ ...          :<environment: 0x557b26272d60> 
[08:24:56.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.298]  - attr(*, "resolved")= logi FALSE
[08:24:56.298]  - attr(*, "total_size")= num 15670
[08:24:56.301] Packages to be attached in all futures: [n=0] 
[08:24:56.301] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.301] Number of futures (= number of chunks): 1
[08:24:56.301] Launching 1 futures (chunks) ...
[08:24:56.301] Chunk #1 of 1 ...
[08:24:56.301]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.301] getGlobalsAndPackages() ...
[08:24:56.302] Searching for globals...
[08:24:56.302] 
[08:24:56.302] Searching for globals ... DONE
[08:24:56.302] - globals: [0] <none>
[08:24:56.302] getGlobalsAndPackages() ... DONE
[08:24:56.302]    + additional globals found: [n=0] 
[08:24:56.303]    + additional namespaces needed: [n=0] 
[08:24:56.303]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.303]  - seeds: <none>
[08:24:56.303]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.303] getGlobalsAndPackages() ...
[08:24:56.303] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.303] Resolving globals: FALSE
[08:24:56.303] Tweak future expression to call with '...' arguments ...
[08:24:56.303] {
[08:24:56.303]     do.call(function(...) {
[08:24:56.303]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.303]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.303]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.303]             on.exit(options(oopts), add = TRUE)
[08:24:56.303]         }
[08:24:56.303]         {
[08:24:56.303]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.303]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.303]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.303]             })
[08:24:56.303]         }
[08:24:56.303]     }, args = future.call.arguments)
[08:24:56.303] }
[08:24:56.304] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.304] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.304] 
[08:24:56.304] getGlobalsAndPackages() ... DONE
[08:24:56.305] run() for ‘Future’ ...
[08:24:56.305] - state: ‘created’
[08:24:56.305] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:56.306] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.308]   - Field: ‘label’
[08:24:56.308]   - Field: ‘local’
[08:24:56.309]   - Field: ‘owner’
[08:24:56.309]   - Field: ‘envir’
[08:24:56.309]   - Field: ‘packages’
[08:24:56.309]   - Field: ‘gc’
[08:24:56.309]   - Field: ‘conditions’
[08:24:56.309]   - Field: ‘expr’
[08:24:56.309]   - Field: ‘uuid’
[08:24:56.309]   - Field: ‘seed’
[08:24:56.309]   - Field: ‘version’
[08:24:56.309]   - Field: ‘result’
[08:24:56.309]   - Field: ‘asynchronous’
[08:24:56.309]   - Field: ‘calls’
[08:24:56.310]   - Field: ‘globals’
[08:24:56.310]   - Field: ‘stdout’
[08:24:56.310]   - Field: ‘earlySignal’
[08:24:56.310]   - Field: ‘lazy’
[08:24:56.310]   - Field: ‘state’
[08:24:56.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.310] - Launch lazy future ...
[08:24:56.311] Packages needed by the future expression (n = 0): <none>
[08:24:56.311] Packages needed by future strategies (n = 0): <none>
[08:24:56.312] {
[08:24:56.312]     {
[08:24:56.312]         {
[08:24:56.312]             ...future.startTime <- base::Sys.time()
[08:24:56.312]             {
[08:24:56.312]                 {
[08:24:56.312]                   {
[08:24:56.312]                     base::local({
[08:24:56.312]                       has_future <- base::requireNamespace("future", 
[08:24:56.312]                         quietly = TRUE)
[08:24:56.312]                       if (has_future) {
[08:24:56.312]                         ns <- base::getNamespace("future")
[08:24:56.312]                         version <- ns[[".package"]][["version"]]
[08:24:56.312]                         if (is.null(version)) 
[08:24:56.312]                           version <- utils::packageVersion("future")
[08:24:56.312]                       }
[08:24:56.312]                       else {
[08:24:56.312]                         version <- NULL
[08:24:56.312]                       }
[08:24:56.312]                       if (!has_future || version < "1.8.0") {
[08:24:56.312]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.312]                           "", base::R.version$version.string), 
[08:24:56.312]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.312]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.312]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.312]                             "release", "version")], collapse = " "), 
[08:24:56.312]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.312]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.312]                           info)
[08:24:56.312]                         info <- base::paste(info, collapse = "; ")
[08:24:56.312]                         if (!has_future) {
[08:24:56.312]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.312]                             info)
[08:24:56.312]                         }
[08:24:56.312]                         else {
[08:24:56.312]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.312]                             info, version)
[08:24:56.312]                         }
[08:24:56.312]                         base::stop(msg)
[08:24:56.312]                       }
[08:24:56.312]                     })
[08:24:56.312]                   }
[08:24:56.312]                   ...future.strategy.old <- future::plan("list")
[08:24:56.312]                   options(future.plan = NULL)
[08:24:56.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.312]                 }
[08:24:56.312]                 ...future.workdir <- getwd()
[08:24:56.312]             }
[08:24:56.312]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.312]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.312]         }
[08:24:56.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.312]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.312]             base::names(...future.oldOptions))
[08:24:56.312]     }
[08:24:56.312]     if (FALSE) {
[08:24:56.312]     }
[08:24:56.312]     else {
[08:24:56.312]         if (TRUE) {
[08:24:56.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.312]                 open = "w")
[08:24:56.312]         }
[08:24:56.312]         else {
[08:24:56.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.312]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.312]         }
[08:24:56.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.312]             base::sink(type = "output", split = FALSE)
[08:24:56.312]             base::close(...future.stdout)
[08:24:56.312]         }, add = TRUE)
[08:24:56.312]     }
[08:24:56.312]     ...future.frame <- base::sys.nframe()
[08:24:56.312]     ...future.conditions <- base::list()
[08:24:56.312]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.312]     if (FALSE) {
[08:24:56.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.312]     }
[08:24:56.312]     ...future.result <- base::tryCatch({
[08:24:56.312]         base::withCallingHandlers({
[08:24:56.312]             ...future.value <- base::withVisible(base::local({
[08:24:56.312]                 do.call(function(...) {
[08:24:56.312]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.312]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.312]                     ...future.globals.maxSize)) {
[08:24:56.312]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.312]                     on.exit(options(oopts), add = TRUE)
[08:24:56.312]                   }
[08:24:56.312]                   {
[08:24:56.312]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.312]                       FUN = function(jj) {
[08:24:56.312]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.312]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.312]                       })
[08:24:56.312]                   }
[08:24:56.312]                 }, args = future.call.arguments)
[08:24:56.312]             }))
[08:24:56.312]             future::FutureResult(value = ...future.value$value, 
[08:24:56.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.312]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.312]                     ...future.globalenv.names))
[08:24:56.312]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.312]         }, condition = base::local({
[08:24:56.312]             c <- base::c
[08:24:56.312]             inherits <- base::inherits
[08:24:56.312]             invokeRestart <- base::invokeRestart
[08:24:56.312]             length <- base::length
[08:24:56.312]             list <- base::list
[08:24:56.312]             seq.int <- base::seq.int
[08:24:56.312]             signalCondition <- base::signalCondition
[08:24:56.312]             sys.calls <- base::sys.calls
[08:24:56.312]             `[[` <- base::`[[`
[08:24:56.312]             `+` <- base::`+`
[08:24:56.312]             `<<-` <- base::`<<-`
[08:24:56.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.312]                   3L)]
[08:24:56.312]             }
[08:24:56.312]             function(cond) {
[08:24:56.312]                 is_error <- inherits(cond, "error")
[08:24:56.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.312]                   NULL)
[08:24:56.312]                 if (is_error) {
[08:24:56.312]                   sessionInformation <- function() {
[08:24:56.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.312]                       search = base::search(), system = base::Sys.info())
[08:24:56.312]                   }
[08:24:56.312]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.312]                     cond$call), session = sessionInformation(), 
[08:24:56.312]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.312]                   signalCondition(cond)
[08:24:56.312]                 }
[08:24:56.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.312]                 "immediateCondition"))) {
[08:24:56.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.312]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.312]                   if (TRUE && !signal) {
[08:24:56.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.312]                     {
[08:24:56.312]                       inherits <- base::inherits
[08:24:56.312]                       invokeRestart <- base::invokeRestart
[08:24:56.312]                       is.null <- base::is.null
[08:24:56.312]                       muffled <- FALSE
[08:24:56.312]                       if (inherits(cond, "message")) {
[08:24:56.312]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.312]                         if (muffled) 
[08:24:56.312]                           invokeRestart("muffleMessage")
[08:24:56.312]                       }
[08:24:56.312]                       else if (inherits(cond, "warning")) {
[08:24:56.312]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.312]                         if (muffled) 
[08:24:56.312]                           invokeRestart("muffleWarning")
[08:24:56.312]                       }
[08:24:56.312]                       else if (inherits(cond, "condition")) {
[08:24:56.312]                         if (!is.null(pattern)) {
[08:24:56.312]                           computeRestarts <- base::computeRestarts
[08:24:56.312]                           grepl <- base::grepl
[08:24:56.312]                           restarts <- computeRestarts(cond)
[08:24:56.312]                           for (restart in restarts) {
[08:24:56.312]                             name <- restart$name
[08:24:56.312]                             if (is.null(name)) 
[08:24:56.312]                               next
[08:24:56.312]                             if (!grepl(pattern, name)) 
[08:24:56.312]                               next
[08:24:56.312]                             invokeRestart(restart)
[08:24:56.312]                             muffled <- TRUE
[08:24:56.312]                             break
[08:24:56.312]                           }
[08:24:56.312]                         }
[08:24:56.312]                       }
[08:24:56.312]                       invisible(muffled)
[08:24:56.312]                     }
[08:24:56.312]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.312]                   }
[08:24:56.312]                 }
[08:24:56.312]                 else {
[08:24:56.312]                   if (TRUE) {
[08:24:56.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.312]                     {
[08:24:56.312]                       inherits <- base::inherits
[08:24:56.312]                       invokeRestart <- base::invokeRestart
[08:24:56.312]                       is.null <- base::is.null
[08:24:56.312]                       muffled <- FALSE
[08:24:56.312]                       if (inherits(cond, "message")) {
[08:24:56.312]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.312]                         if (muffled) 
[08:24:56.312]                           invokeRestart("muffleMessage")
[08:24:56.312]                       }
[08:24:56.312]                       else if (inherits(cond, "warning")) {
[08:24:56.312]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.312]                         if (muffled) 
[08:24:56.312]                           invokeRestart("muffleWarning")
[08:24:56.312]                       }
[08:24:56.312]                       else if (inherits(cond, "condition")) {
[08:24:56.312]                         if (!is.null(pattern)) {
[08:24:56.312]                           computeRestarts <- base::computeRestarts
[08:24:56.312]                           grepl <- base::grepl
[08:24:56.312]                           restarts <- computeRestarts(cond)
[08:24:56.312]                           for (restart in restarts) {
[08:24:56.312]                             name <- restart$name
[08:24:56.312]                             if (is.null(name)) 
[08:24:56.312]                               next
[08:24:56.312]                             if (!grepl(pattern, name)) 
[08:24:56.312]                               next
[08:24:56.312]                             invokeRestart(restart)
[08:24:56.312]                             muffled <- TRUE
[08:24:56.312]                             break
[08:24:56.312]                           }
[08:24:56.312]                         }
[08:24:56.312]                       }
[08:24:56.312]                       invisible(muffled)
[08:24:56.312]                     }
[08:24:56.312]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.312]                   }
[08:24:56.312]                 }
[08:24:56.312]             }
[08:24:56.312]         }))
[08:24:56.312]     }, error = function(ex) {
[08:24:56.312]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.312]                 ...future.rng), started = ...future.startTime, 
[08:24:56.312]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.312]             version = "1.8"), class = "FutureResult")
[08:24:56.312]     }, finally = {
[08:24:56.312]         if (!identical(...future.workdir, getwd())) 
[08:24:56.312]             setwd(...future.workdir)
[08:24:56.312]         {
[08:24:56.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.312]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.312]             }
[08:24:56.312]             base::options(...future.oldOptions)
[08:24:56.312]             if (.Platform$OS.type == "windows") {
[08:24:56.312]                 old_names <- names(...future.oldEnvVars)
[08:24:56.312]                 envs <- base::Sys.getenv()
[08:24:56.312]                 names <- names(envs)
[08:24:56.312]                 common <- intersect(names, old_names)
[08:24:56.312]                 added <- setdiff(names, old_names)
[08:24:56.312]                 removed <- setdiff(old_names, names)
[08:24:56.312]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.312]                   envs[common]]
[08:24:56.312]                 NAMES <- toupper(changed)
[08:24:56.312]                 args <- list()
[08:24:56.312]                 for (kk in seq_along(NAMES)) {
[08:24:56.312]                   name <- changed[[kk]]
[08:24:56.312]                   NAME <- NAMES[[kk]]
[08:24:56.312]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.312]                     next
[08:24:56.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.312]                 }
[08:24:56.312]                 NAMES <- toupper(added)
[08:24:56.312]                 for (kk in seq_along(NAMES)) {
[08:24:56.312]                   name <- added[[kk]]
[08:24:56.312]                   NAME <- NAMES[[kk]]
[08:24:56.312]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.312]                     next
[08:24:56.312]                   args[[name]] <- ""
[08:24:56.312]                 }
[08:24:56.312]                 NAMES <- toupper(removed)
[08:24:56.312]                 for (kk in seq_along(NAMES)) {
[08:24:56.312]                   name <- removed[[kk]]
[08:24:56.312]                   NAME <- NAMES[[kk]]
[08:24:56.312]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.312]                     next
[08:24:56.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.312]                 }
[08:24:56.312]                 if (length(args) > 0) 
[08:24:56.312]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.312]             }
[08:24:56.312]             else {
[08:24:56.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.312]             }
[08:24:56.312]             {
[08:24:56.312]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.312]                   0L) {
[08:24:56.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.312]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.312]                   base::options(opts)
[08:24:56.312]                 }
[08:24:56.312]                 {
[08:24:56.312]                   {
[08:24:56.312]                     NULL
[08:24:56.312]                     RNGkind("Mersenne-Twister")
[08:24:56.312]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.312]                       inherits = FALSE)
[08:24:56.312]                   }
[08:24:56.312]                   options(future.plan = NULL)
[08:24:56.312]                   if (is.na(NA_character_)) 
[08:24:56.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.312]                     .init = FALSE)
[08:24:56.312]                 }
[08:24:56.312]             }
[08:24:56.312]         }
[08:24:56.312]     })
[08:24:56.312]     if (TRUE) {
[08:24:56.312]         base::sink(type = "output", split = FALSE)
[08:24:56.312]         if (TRUE) {
[08:24:56.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.312]         }
[08:24:56.312]         else {
[08:24:56.312]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.312]         }
[08:24:56.312]         base::close(...future.stdout)
[08:24:56.312]         ...future.stdout <- NULL
[08:24:56.312]     }
[08:24:56.312]     ...future.result$conditions <- ...future.conditions
[08:24:56.312]     ...future.result$finished <- base::Sys.time()
[08:24:56.312]     ...future.result
[08:24:56.312] }
[08:24:56.314] assign_globals() ...
[08:24:56.314] List of 5
[08:24:56.314]  $ ...future.FUN            :function (object, ...)  
[08:24:56.314]  $ future.call.arguments    : list()
[08:24:56.314]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.314]  $ ...future.elements_ii    :List of 3
[08:24:56.314]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.314]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.314]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.314]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.314]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.314]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.314]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.314]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.314]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.314]  $ ...future.seeds_ii       : NULL
[08:24:56.314]  $ ...future.globals.maxSize: NULL
[08:24:56.314]  - attr(*, "where")=List of 5
[08:24:56.314]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.314]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.314]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.314]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.314]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.314]  - attr(*, "resolved")= logi FALSE
[08:24:56.314]  - attr(*, "total_size")= num 15670
[08:24:56.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.314]  - attr(*, "already-done")= logi TRUE
[08:24:56.321] - copied ‘...future.FUN’ to environment
[08:24:56.321] - copied ‘future.call.arguments’ to environment
[08:24:56.321] - copied ‘...future.elements_ii’ to environment
[08:24:56.322] - copied ‘...future.seeds_ii’ to environment
[08:24:56.322] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.322] assign_globals() ... done
[08:24:56.322] plan(): Setting new future strategy stack:
[08:24:56.322] List of future strategies:
[08:24:56.322] 1. sequential:
[08:24:56.322]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.322]    - tweaked: FALSE
[08:24:56.322]    - call: NULL
[08:24:56.323] plan(): nbrOfWorkers() = 1
[08:24:56.325] plan(): Setting new future strategy stack:
[08:24:56.325] List of future strategies:
[08:24:56.325] 1. sequential:
[08:24:56.325]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.325]    - tweaked: FALSE
[08:24:56.325]    - call: plan(strategy)
[08:24:56.325] plan(): nbrOfWorkers() = 1
[08:24:56.326] SequentialFuture started (and completed)
[08:24:56.326] - Launch lazy future ... done
[08:24:56.326] run() for ‘SequentialFuture’ ... done
[08:24:56.326] Created future:
[08:24:56.326] SequentialFuture:
[08:24:56.326] Label: ‘future_by-1’
[08:24:56.326] Expression:
[08:24:56.326] {
[08:24:56.326]     do.call(function(...) {
[08:24:56.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.326]             on.exit(options(oopts), add = TRUE)
[08:24:56.326]         }
[08:24:56.326]         {
[08:24:56.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.326]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.326]             })
[08:24:56.326]         }
[08:24:56.326]     }, args = future.call.arguments)
[08:24:56.326] }
[08:24:56.326] Lazy evaluation: FALSE
[08:24:56.326] Asynchronous evaluation: FALSE
[08:24:56.326] Local evaluation: TRUE
[08:24:56.326] Environment: R_GlobalEnv
[08:24:56.326] Capture standard output: TRUE
[08:24:56.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.326] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.326] Packages: <none>
[08:24:56.326] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.326] Resolved: TRUE
[08:24:56.326] Value: 1.16 KiB of class ‘list’
[08:24:56.326] Early signaling: FALSE
[08:24:56.326] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.326] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.328] Chunk #1 of 1 ... DONE
[08:24:56.328] Launching 1 futures (chunks) ... DONE
[08:24:56.328] Resolving 1 futures (chunks) ...
[08:24:56.328] resolve() on list ...
[08:24:56.328]  recursive: 0
[08:24:56.328]  length: 1
[08:24:56.328] 
[08:24:56.328] resolved() for ‘SequentialFuture’ ...
[08:24:56.328] - state: ‘finished’
[08:24:56.329] - run: TRUE
[08:24:56.329] - result: ‘FutureResult’
[08:24:56.329] resolved() for ‘SequentialFuture’ ... done
[08:24:56.329] Future #1
[08:24:56.329] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.329] - nx: 1
[08:24:56.329] - relay: TRUE
[08:24:56.329] - stdout: TRUE
[08:24:56.330] - signal: TRUE
[08:24:56.330] - resignal: FALSE
[08:24:56.330] - force: TRUE
[08:24:56.330] - relayed: [n=1] FALSE
[08:24:56.330] - queued futures: [n=1] FALSE
[08:24:56.330]  - until=1
[08:24:56.330]  - relaying element #1
[08:24:56.330] - relayed: [n=1] TRUE
[08:24:56.330] - queued futures: [n=1] TRUE
[08:24:56.330] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.331]  length: 0 (resolved future 1)
[08:24:56.331] Relaying remaining futures
[08:24:56.331] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.331] - nx: 1
[08:24:56.331] - relay: TRUE
[08:24:56.331] - stdout: TRUE
[08:24:56.331] - signal: TRUE
[08:24:56.331] - resignal: FALSE
[08:24:56.331] - force: TRUE
[08:24:56.331] - relayed: [n=1] TRUE
[08:24:56.331] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.331] - relayed: [n=1] TRUE
[08:24:56.332] - queued futures: [n=1] TRUE
[08:24:56.332] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.332] resolve() on list ... DONE
[08:24:56.332]  - Number of value chunks collected: 1
[08:24:56.332] Resolving 1 futures (chunks) ... DONE
[08:24:56.332] Reducing values from 1 chunks ...
[08:24:56.332]  - Number of values collected after concatenation: 3
[08:24:56.332]  - Number of values expected: 3
[08:24:56.332] Reducing values from 1 chunks ... DONE
[08:24:56.332] future_lapply() ... DONE
[08:24:56.333] future_by_internal() ... DONE
[08:24:56.335] future_by_internal() ...
[08:24:56.335] future_lapply() ...
[08:24:56.336] Number of chunks: 1
[08:24:56.336] getGlobalsAndPackagesXApply() ...
[08:24:56.336]  - future.globals: TRUE
[08:24:56.336] getGlobalsAndPackages() ...
[08:24:56.337] Searching for globals...
[08:24:56.338] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.338] Searching for globals ... DONE
[08:24:56.338] Resolving globals: FALSE
[08:24:56.338] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.338] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.339] - globals: [1] ‘FUN’
[08:24:56.339] 
[08:24:56.339] getGlobalsAndPackages() ... DONE
[08:24:56.339]  - globals found/used: [n=1] ‘FUN’
[08:24:56.339]  - needed namespaces: [n=0] 
[08:24:56.339] Finding globals ... DONE
[08:24:56.339]  - use_args: TRUE
[08:24:56.339]  - Getting '...' globals ...
[08:24:56.340] resolve() on list ...
[08:24:56.340]  recursive: 0
[08:24:56.340]  length: 1
[08:24:56.340]  elements: ‘...’
[08:24:56.340]  length: 0 (resolved future 1)
[08:24:56.340] resolve() on list ... DONE
[08:24:56.340]    - '...' content: [n=1] ‘digits’
[08:24:56.340] List of 1
[08:24:56.340]  $ ...:List of 1
[08:24:56.340]   ..$ digits: int 2
[08:24:56.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.340]  - attr(*, "where")=List of 1
[08:24:56.340]   ..$ ...:<environment: 0x557b2746ea48> 
[08:24:56.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.340]  - attr(*, "resolved")= logi TRUE
[08:24:56.340]  - attr(*, "total_size")= num NA
[08:24:56.343]  - Getting '...' globals ... DONE
[08:24:56.343] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.343] List of 2
[08:24:56.343]  $ ...future.FUN:function (object, ...)  
[08:24:56.343]  $ ...          :List of 1
[08:24:56.343]   ..$ digits: int 2
[08:24:56.343]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.343]  - attr(*, "where")=List of 2
[08:24:56.343]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.343]   ..$ ...          :<environment: 0x557b2746ea48> 
[08:24:56.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.343]  - attr(*, "resolved")= logi FALSE
[08:24:56.343]  - attr(*, "total_size")= num 13284
[08:24:56.346] Packages to be attached in all futures: [n=0] 
[08:24:56.346] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.347] Number of futures (= number of chunks): 1
[08:24:56.347] Launching 1 futures (chunks) ...
[08:24:56.347] Chunk #1 of 1 ...
[08:24:56.347]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.347] getGlobalsAndPackages() ...
[08:24:56.347] Searching for globals...
[08:24:56.347] 
[08:24:56.347] Searching for globals ... DONE
[08:24:56.348] - globals: [0] <none>
[08:24:56.348] getGlobalsAndPackages() ... DONE
[08:24:56.348]    + additional globals found: [n=0] 
[08:24:56.348]    + additional namespaces needed: [n=0] 
[08:24:56.348]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.348]  - seeds: <none>
[08:24:56.348]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.348] getGlobalsAndPackages() ...
[08:24:56.348] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.348] Resolving globals: FALSE
[08:24:56.348] Tweak future expression to call with '...' arguments ...
[08:24:56.349] {
[08:24:56.349]     do.call(function(...) {
[08:24:56.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.349]             on.exit(options(oopts), add = TRUE)
[08:24:56.349]         }
[08:24:56.349]         {
[08:24:56.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.349]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.349]             })
[08:24:56.349]         }
[08:24:56.349]     }, args = future.call.arguments)
[08:24:56.349] }
[08:24:56.349] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.349] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.349] 
[08:24:56.349] getGlobalsAndPackages() ... DONE
[08:24:56.350] run() for ‘Future’ ...
[08:24:56.350] - state: ‘created’
[08:24:56.350] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:56.350] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.350]   - Field: ‘label’
[08:24:56.351]   - Field: ‘local’
[08:24:56.351]   - Field: ‘owner’
[08:24:56.351]   - Field: ‘envir’
[08:24:56.351]   - Field: ‘packages’
[08:24:56.351]   - Field: ‘gc’
[08:24:56.351]   - Field: ‘conditions’
[08:24:56.351]   - Field: ‘expr’
[08:24:56.351]   - Field: ‘uuid’
[08:24:56.351]   - Field: ‘seed’
[08:24:56.351]   - Field: ‘version’
[08:24:56.351]   - Field: ‘result’
[08:24:56.352]   - Field: ‘asynchronous’
[08:24:56.352]   - Field: ‘calls’
[08:24:56.352]   - Field: ‘globals’
[08:24:56.352]   - Field: ‘stdout’
[08:24:56.352]   - Field: ‘earlySignal’
[08:24:56.352]   - Field: ‘lazy’
[08:24:56.352]   - Field: ‘state’
[08:24:56.352] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.352] - Launch lazy future ...
[08:24:56.352] Packages needed by the future expression (n = 0): <none>
[08:24:56.353] Packages needed by future strategies (n = 0): <none>
[08:24:56.353] {
[08:24:56.353]     {
[08:24:56.353]         {
[08:24:56.353]             ...future.startTime <- base::Sys.time()
[08:24:56.353]             {
[08:24:56.353]                 {
[08:24:56.353]                   {
[08:24:56.353]                     base::local({
[08:24:56.353]                       has_future <- base::requireNamespace("future", 
[08:24:56.353]                         quietly = TRUE)
[08:24:56.353]                       if (has_future) {
[08:24:56.353]                         ns <- base::getNamespace("future")
[08:24:56.353]                         version <- ns[[".package"]][["version"]]
[08:24:56.353]                         if (is.null(version)) 
[08:24:56.353]                           version <- utils::packageVersion("future")
[08:24:56.353]                       }
[08:24:56.353]                       else {
[08:24:56.353]                         version <- NULL
[08:24:56.353]                       }
[08:24:56.353]                       if (!has_future || version < "1.8.0") {
[08:24:56.353]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.353]                           "", base::R.version$version.string), 
[08:24:56.353]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.353]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.353]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.353]                             "release", "version")], collapse = " "), 
[08:24:56.353]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.353]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.353]                           info)
[08:24:56.353]                         info <- base::paste(info, collapse = "; ")
[08:24:56.353]                         if (!has_future) {
[08:24:56.353]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.353]                             info)
[08:24:56.353]                         }
[08:24:56.353]                         else {
[08:24:56.353]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.353]                             info, version)
[08:24:56.353]                         }
[08:24:56.353]                         base::stop(msg)
[08:24:56.353]                       }
[08:24:56.353]                     })
[08:24:56.353]                   }
[08:24:56.353]                   ...future.strategy.old <- future::plan("list")
[08:24:56.353]                   options(future.plan = NULL)
[08:24:56.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.353]                 }
[08:24:56.353]                 ...future.workdir <- getwd()
[08:24:56.353]             }
[08:24:56.353]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.353]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.353]         }
[08:24:56.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.353]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.353]             base::names(...future.oldOptions))
[08:24:56.353]     }
[08:24:56.353]     if (FALSE) {
[08:24:56.353]     }
[08:24:56.353]     else {
[08:24:56.353]         if (TRUE) {
[08:24:56.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.353]                 open = "w")
[08:24:56.353]         }
[08:24:56.353]         else {
[08:24:56.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.353]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.353]         }
[08:24:56.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.353]             base::sink(type = "output", split = FALSE)
[08:24:56.353]             base::close(...future.stdout)
[08:24:56.353]         }, add = TRUE)
[08:24:56.353]     }
[08:24:56.353]     ...future.frame <- base::sys.nframe()
[08:24:56.353]     ...future.conditions <- base::list()
[08:24:56.353]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.353]     if (FALSE) {
[08:24:56.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.353]     }
[08:24:56.353]     ...future.result <- base::tryCatch({
[08:24:56.353]         base::withCallingHandlers({
[08:24:56.353]             ...future.value <- base::withVisible(base::local({
[08:24:56.353]                 do.call(function(...) {
[08:24:56.353]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.353]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.353]                     ...future.globals.maxSize)) {
[08:24:56.353]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.353]                     on.exit(options(oopts), add = TRUE)
[08:24:56.353]                   }
[08:24:56.353]                   {
[08:24:56.353]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.353]                       FUN = function(jj) {
[08:24:56.353]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.353]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.353]                       })
[08:24:56.353]                   }
[08:24:56.353]                 }, args = future.call.arguments)
[08:24:56.353]             }))
[08:24:56.353]             future::FutureResult(value = ...future.value$value, 
[08:24:56.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.353]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.353]                     ...future.globalenv.names))
[08:24:56.353]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.353]         }, condition = base::local({
[08:24:56.353]             c <- base::c
[08:24:56.353]             inherits <- base::inherits
[08:24:56.353]             invokeRestart <- base::invokeRestart
[08:24:56.353]             length <- base::length
[08:24:56.353]             list <- base::list
[08:24:56.353]             seq.int <- base::seq.int
[08:24:56.353]             signalCondition <- base::signalCondition
[08:24:56.353]             sys.calls <- base::sys.calls
[08:24:56.353]             `[[` <- base::`[[`
[08:24:56.353]             `+` <- base::`+`
[08:24:56.353]             `<<-` <- base::`<<-`
[08:24:56.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.353]                   3L)]
[08:24:56.353]             }
[08:24:56.353]             function(cond) {
[08:24:56.353]                 is_error <- inherits(cond, "error")
[08:24:56.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.353]                   NULL)
[08:24:56.353]                 if (is_error) {
[08:24:56.353]                   sessionInformation <- function() {
[08:24:56.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.353]                       search = base::search(), system = base::Sys.info())
[08:24:56.353]                   }
[08:24:56.353]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.353]                     cond$call), session = sessionInformation(), 
[08:24:56.353]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.353]                   signalCondition(cond)
[08:24:56.353]                 }
[08:24:56.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.353]                 "immediateCondition"))) {
[08:24:56.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.353]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.353]                   if (TRUE && !signal) {
[08:24:56.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.353]                     {
[08:24:56.353]                       inherits <- base::inherits
[08:24:56.353]                       invokeRestart <- base::invokeRestart
[08:24:56.353]                       is.null <- base::is.null
[08:24:56.353]                       muffled <- FALSE
[08:24:56.353]                       if (inherits(cond, "message")) {
[08:24:56.353]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.353]                         if (muffled) 
[08:24:56.353]                           invokeRestart("muffleMessage")
[08:24:56.353]                       }
[08:24:56.353]                       else if (inherits(cond, "warning")) {
[08:24:56.353]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.353]                         if (muffled) 
[08:24:56.353]                           invokeRestart("muffleWarning")
[08:24:56.353]                       }
[08:24:56.353]                       else if (inherits(cond, "condition")) {
[08:24:56.353]                         if (!is.null(pattern)) {
[08:24:56.353]                           computeRestarts <- base::computeRestarts
[08:24:56.353]                           grepl <- base::grepl
[08:24:56.353]                           restarts <- computeRestarts(cond)
[08:24:56.353]                           for (restart in restarts) {
[08:24:56.353]                             name <- restart$name
[08:24:56.353]                             if (is.null(name)) 
[08:24:56.353]                               next
[08:24:56.353]                             if (!grepl(pattern, name)) 
[08:24:56.353]                               next
[08:24:56.353]                             invokeRestart(restart)
[08:24:56.353]                             muffled <- TRUE
[08:24:56.353]                             break
[08:24:56.353]                           }
[08:24:56.353]                         }
[08:24:56.353]                       }
[08:24:56.353]                       invisible(muffled)
[08:24:56.353]                     }
[08:24:56.353]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.353]                   }
[08:24:56.353]                 }
[08:24:56.353]                 else {
[08:24:56.353]                   if (TRUE) {
[08:24:56.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.353]                     {
[08:24:56.353]                       inherits <- base::inherits
[08:24:56.353]                       invokeRestart <- base::invokeRestart
[08:24:56.353]                       is.null <- base::is.null
[08:24:56.353]                       muffled <- FALSE
[08:24:56.353]                       if (inherits(cond, "message")) {
[08:24:56.353]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.353]                         if (muffled) 
[08:24:56.353]                           invokeRestart("muffleMessage")
[08:24:56.353]                       }
[08:24:56.353]                       else if (inherits(cond, "warning")) {
[08:24:56.353]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.353]                         if (muffled) 
[08:24:56.353]                           invokeRestart("muffleWarning")
[08:24:56.353]                       }
[08:24:56.353]                       else if (inherits(cond, "condition")) {
[08:24:56.353]                         if (!is.null(pattern)) {
[08:24:56.353]                           computeRestarts <- base::computeRestarts
[08:24:56.353]                           grepl <- base::grepl
[08:24:56.353]                           restarts <- computeRestarts(cond)
[08:24:56.353]                           for (restart in restarts) {
[08:24:56.353]                             name <- restart$name
[08:24:56.353]                             if (is.null(name)) 
[08:24:56.353]                               next
[08:24:56.353]                             if (!grepl(pattern, name)) 
[08:24:56.353]                               next
[08:24:56.353]                             invokeRestart(restart)
[08:24:56.353]                             muffled <- TRUE
[08:24:56.353]                             break
[08:24:56.353]                           }
[08:24:56.353]                         }
[08:24:56.353]                       }
[08:24:56.353]                       invisible(muffled)
[08:24:56.353]                     }
[08:24:56.353]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.353]                   }
[08:24:56.353]                 }
[08:24:56.353]             }
[08:24:56.353]         }))
[08:24:56.353]     }, error = function(ex) {
[08:24:56.353]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.353]                 ...future.rng), started = ...future.startTime, 
[08:24:56.353]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.353]             version = "1.8"), class = "FutureResult")
[08:24:56.353]     }, finally = {
[08:24:56.353]         if (!identical(...future.workdir, getwd())) 
[08:24:56.353]             setwd(...future.workdir)
[08:24:56.353]         {
[08:24:56.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.353]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.353]             }
[08:24:56.353]             base::options(...future.oldOptions)
[08:24:56.353]             if (.Platform$OS.type == "windows") {
[08:24:56.353]                 old_names <- names(...future.oldEnvVars)
[08:24:56.353]                 envs <- base::Sys.getenv()
[08:24:56.353]                 names <- names(envs)
[08:24:56.353]                 common <- intersect(names, old_names)
[08:24:56.353]                 added <- setdiff(names, old_names)
[08:24:56.353]                 removed <- setdiff(old_names, names)
[08:24:56.353]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.353]                   envs[common]]
[08:24:56.353]                 NAMES <- toupper(changed)
[08:24:56.353]                 args <- list()
[08:24:56.353]                 for (kk in seq_along(NAMES)) {
[08:24:56.353]                   name <- changed[[kk]]
[08:24:56.353]                   NAME <- NAMES[[kk]]
[08:24:56.353]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.353]                     next
[08:24:56.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.353]                 }
[08:24:56.353]                 NAMES <- toupper(added)
[08:24:56.353]                 for (kk in seq_along(NAMES)) {
[08:24:56.353]                   name <- added[[kk]]
[08:24:56.353]                   NAME <- NAMES[[kk]]
[08:24:56.353]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.353]                     next
[08:24:56.353]                   args[[name]] <- ""
[08:24:56.353]                 }
[08:24:56.353]                 NAMES <- toupper(removed)
[08:24:56.353]                 for (kk in seq_along(NAMES)) {
[08:24:56.353]                   name <- removed[[kk]]
[08:24:56.353]                   NAME <- NAMES[[kk]]
[08:24:56.353]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.353]                     next
[08:24:56.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.353]                 }
[08:24:56.353]                 if (length(args) > 0) 
[08:24:56.353]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.353]             }
[08:24:56.353]             else {
[08:24:56.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.353]             }
[08:24:56.353]             {
[08:24:56.353]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.353]                   0L) {
[08:24:56.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.353]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.353]                   base::options(opts)
[08:24:56.353]                 }
[08:24:56.353]                 {
[08:24:56.353]                   {
[08:24:56.353]                     NULL
[08:24:56.353]                     RNGkind("Mersenne-Twister")
[08:24:56.353]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.353]                       inherits = FALSE)
[08:24:56.353]                   }
[08:24:56.353]                   options(future.plan = NULL)
[08:24:56.353]                   if (is.na(NA_character_)) 
[08:24:56.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.353]                     .init = FALSE)
[08:24:56.353]                 }
[08:24:56.353]             }
[08:24:56.353]         }
[08:24:56.353]     })
[08:24:56.353]     if (TRUE) {
[08:24:56.353]         base::sink(type = "output", split = FALSE)
[08:24:56.353]         if (TRUE) {
[08:24:56.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.353]         }
[08:24:56.353]         else {
[08:24:56.353]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.353]         }
[08:24:56.353]         base::close(...future.stdout)
[08:24:56.353]         ...future.stdout <- NULL
[08:24:56.353]     }
[08:24:56.353]     ...future.result$conditions <- ...future.conditions
[08:24:56.353]     ...future.result$finished <- base::Sys.time()
[08:24:56.353]     ...future.result
[08:24:56.353] }
[08:24:56.355] assign_globals() ...
[08:24:56.355] List of 5
[08:24:56.355]  $ ...future.FUN            :function (object, ...)  
[08:24:56.355]  $ future.call.arguments    :List of 1
[08:24:56.355]   ..$ digits: int 2
[08:24:56.355]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.355]  $ ...future.elements_ii    :List of 6
[08:24:56.355]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[08:24:56.355]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[08:24:56.355]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[08:24:56.355]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[08:24:56.355]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[08:24:56.355]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[08:24:56.355]  $ ...future.seeds_ii       : NULL
[08:24:56.355]  $ ...future.globals.maxSize: NULL
[08:24:56.355]  - attr(*, "where")=List of 5
[08:24:56.355]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.355]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.355]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.355]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.355]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.355]  - attr(*, "resolved")= logi FALSE
[08:24:56.355]  - attr(*, "total_size")= num 13284
[08:24:56.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.355]  - attr(*, "already-done")= logi TRUE
[08:24:56.363] - copied ‘...future.FUN’ to environment
[08:24:56.363] - copied ‘future.call.arguments’ to environment
[08:24:56.363] - copied ‘...future.elements_ii’ to environment
[08:24:56.363] - copied ‘...future.seeds_ii’ to environment
[08:24:56.363] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.364] assign_globals() ... done
[08:24:56.364] plan(): Setting new future strategy stack:
[08:24:56.364] List of future strategies:
[08:24:56.364] 1. sequential:
[08:24:56.364]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.364]    - tweaked: FALSE
[08:24:56.364]    - call: NULL
[08:24:56.364] plan(): nbrOfWorkers() = 1
[08:24:56.366] plan(): Setting new future strategy stack:
[08:24:56.366] List of future strategies:
[08:24:56.366] 1. sequential:
[08:24:56.366]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.366]    - tweaked: FALSE
[08:24:56.366]    - call: plan(strategy)
[08:24:56.366] plan(): nbrOfWorkers() = 1
[08:24:56.366] SequentialFuture started (and completed)
[08:24:56.367] - Launch lazy future ... done
[08:24:56.367] run() for ‘SequentialFuture’ ... done
[08:24:56.367] Created future:
[08:24:56.367] SequentialFuture:
[08:24:56.367] Label: ‘future_by-1’
[08:24:56.367] Expression:
[08:24:56.367] {
[08:24:56.367]     do.call(function(...) {
[08:24:56.367]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.367]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.367]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.367]             on.exit(options(oopts), add = TRUE)
[08:24:56.367]         }
[08:24:56.367]         {
[08:24:56.367]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.367]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.367]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.367]             })
[08:24:56.367]         }
[08:24:56.367]     }, args = future.call.arguments)
[08:24:56.367] }
[08:24:56.367] Lazy evaluation: FALSE
[08:24:56.367] Asynchronous evaluation: FALSE
[08:24:56.367] Local evaluation: TRUE
[08:24:56.367] Environment: R_GlobalEnv
[08:24:56.367] Capture standard output: TRUE
[08:24:56.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.367] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.367] Packages: <none>
[08:24:56.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.367] Resolved: TRUE
[08:24:56.367] Value: 1.27 KiB of class ‘list’
[08:24:56.367] Early signaling: FALSE
[08:24:56.367] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.367] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.368] Chunk #1 of 1 ... DONE
[08:24:56.368] Launching 1 futures (chunks) ... DONE
[08:24:56.368] Resolving 1 futures (chunks) ...
[08:24:56.368] resolve() on list ...
[08:24:56.368]  recursive: 0
[08:24:56.368]  length: 1
[08:24:56.368] 
[08:24:56.368] resolved() for ‘SequentialFuture’ ...
[08:24:56.369] - state: ‘finished’
[08:24:56.369] - run: TRUE
[08:24:56.369] - result: ‘FutureResult’
[08:24:56.369] resolved() for ‘SequentialFuture’ ... done
[08:24:56.369] Future #1
[08:24:56.369] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.369] - nx: 1
[08:24:56.369] - relay: TRUE
[08:24:56.369] - stdout: TRUE
[08:24:56.369] - signal: TRUE
[08:24:56.369] - resignal: FALSE
[08:24:56.369] - force: TRUE
[08:24:56.370] - relayed: [n=1] FALSE
[08:24:56.370] - queued futures: [n=1] FALSE
[08:24:56.370]  - until=1
[08:24:56.370]  - relaying element #1
[08:24:56.370] - relayed: [n=1] TRUE
[08:24:56.370] - queued futures: [n=1] TRUE
[08:24:56.370] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.370]  length: 0 (resolved future 1)
[08:24:56.370] Relaying remaining futures
[08:24:56.370] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.371] - nx: 1
[08:24:56.371] - relay: TRUE
[08:24:56.371] - stdout: TRUE
[08:24:56.371] - signal: TRUE
[08:24:56.371] - resignal: FALSE
[08:24:56.371] - force: TRUE
[08:24:56.371] - relayed: [n=1] TRUE
[08:24:56.371] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.371] - relayed: [n=1] TRUE
[08:24:56.371] - queued futures: [n=1] TRUE
[08:24:56.371] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.371] resolve() on list ... DONE
[08:24:56.372]  - Number of value chunks collected: 1
[08:24:56.372] Resolving 1 futures (chunks) ... DONE
[08:24:56.372] Reducing values from 1 chunks ...
[08:24:56.372]  - Number of values collected after concatenation: 6
[08:24:56.372]  - Number of values expected: 6
[08:24:56.372] Reducing values from 1 chunks ... DONE
[08:24:56.372] future_lapply() ... DONE
[08:24:56.372] future_by_internal() ... DONE
[08:24:56.375] future_by_internal() ...
[08:24:56.376] future_lapply() ...
[08:24:56.377] Number of chunks: 1
[08:24:56.377] getGlobalsAndPackagesXApply() ...
[08:24:56.377]  - future.globals: TRUE
[08:24:56.377] getGlobalsAndPackages() ...
[08:24:56.377] Searching for globals...
[08:24:56.380] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:56.380] Searching for globals ... DONE
[08:24:56.380] Resolving globals: FALSE
[08:24:56.381] The total size of the 1 globals is 762 bytes (762 bytes)
[08:24:56.381] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[08:24:56.381] - globals: [1] ‘FUN’
[08:24:56.381] - packages: [1] ‘stats’
[08:24:56.381] getGlobalsAndPackages() ... DONE
[08:24:56.382]  - globals found/used: [n=1] ‘FUN’
[08:24:56.382]  - needed namespaces: [n=1] ‘stats’
[08:24:56.382] Finding globals ... DONE
[08:24:56.382]  - use_args: TRUE
[08:24:56.382]  - Getting '...' globals ...
[08:24:56.382] resolve() on list ...
[08:24:56.382]  recursive: 0
[08:24:56.382]  length: 1
[08:24:56.383]  elements: ‘...’
[08:24:56.383]  length: 0 (resolved future 1)
[08:24:56.383] resolve() on list ... DONE
[08:24:56.383]    - '...' content: [n=1] ‘singular.ok’
[08:24:56.383] List of 1
[08:24:56.383]  $ ...:List of 1
[08:24:56.383]   ..$ singular.ok: logi FALSE
[08:24:56.383]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.383]  - attr(*, "where")=List of 1
[08:24:56.383]   ..$ ...:<environment: 0x557b283800d0> 
[08:24:56.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.383]  - attr(*, "resolved")= logi TRUE
[08:24:56.383]  - attr(*, "total_size")= num NA
[08:24:56.386]  - Getting '...' globals ... DONE
[08:24:56.386] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.386] List of 2
[08:24:56.386]  $ ...future.FUN:function (x, ...)  
[08:24:56.386]  $ ...          :List of 1
[08:24:56.386]   ..$ singular.ok: logi FALSE
[08:24:56.386]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.386]  - attr(*, "where")=List of 2
[08:24:56.386]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.386]   ..$ ...          :<environment: 0x557b283800d0> 
[08:24:56.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.386]  - attr(*, "resolved")= logi FALSE
[08:24:56.386]  - attr(*, "total_size")= num 19977
[08:24:56.389] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:56.389] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.389] Number of futures (= number of chunks): 1
[08:24:56.389] Launching 1 futures (chunks) ...
[08:24:56.389] Chunk #1 of 1 ...
[08:24:56.390]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.390] getGlobalsAndPackages() ...
[08:24:56.390] Searching for globals...
[08:24:56.390] 
[08:24:56.390] Searching for globals ... DONE
[08:24:56.390] - globals: [0] <none>
[08:24:56.390] getGlobalsAndPackages() ... DONE
[08:24:56.391]    + additional globals found: [n=0] 
[08:24:56.391]    + additional namespaces needed: [n=0] 
[08:24:56.391]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.391]  - seeds: <none>
[08:24:56.391]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.391] getGlobalsAndPackages() ...
[08:24:56.391] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.391] Resolving globals: FALSE
[08:24:56.391] Tweak future expression to call with '...' arguments ...
[08:24:56.391] {
[08:24:56.391]     do.call(function(...) {
[08:24:56.391]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.391]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.391]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.391]             on.exit(options(oopts), add = TRUE)
[08:24:56.391]         }
[08:24:56.391]         {
[08:24:56.391]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.391]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.391]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.391]             })
[08:24:56.391]         }
[08:24:56.391]     }, args = future.call.arguments)
[08:24:56.391] }
[08:24:56.392] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.392] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.392] 
[08:24:56.392] getGlobalsAndPackages() ... DONE
[08:24:56.392] run() for ‘Future’ ...
[08:24:56.393] - state: ‘created’
[08:24:56.393] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:56.393] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.393]   - Field: ‘label’
[08:24:56.393]   - Field: ‘local’
[08:24:56.393]   - Field: ‘owner’
[08:24:56.393]   - Field: ‘envir’
[08:24:56.394]   - Field: ‘packages’
[08:24:56.394]   - Field: ‘gc’
[08:24:56.394]   - Field: ‘conditions’
[08:24:56.394]   - Field: ‘expr’
[08:24:56.394]   - Field: ‘uuid’
[08:24:56.394]   - Field: ‘seed’
[08:24:56.394]   - Field: ‘version’
[08:24:56.394]   - Field: ‘result’
[08:24:56.394]   - Field: ‘asynchronous’
[08:24:56.394]   - Field: ‘calls’
[08:24:56.394]   - Field: ‘globals’
[08:24:56.394]   - Field: ‘stdout’
[08:24:56.395]   - Field: ‘earlySignal’
[08:24:56.395]   - Field: ‘lazy’
[08:24:56.395]   - Field: ‘state’
[08:24:56.395] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.395] - Launch lazy future ...
[08:24:56.395] Packages needed by the future expression (n = 1): ‘stats’
[08:24:56.395] Packages needed by future strategies (n = 0): <none>
[08:24:56.396] {
[08:24:56.396]     {
[08:24:56.396]         {
[08:24:56.396]             ...future.startTime <- base::Sys.time()
[08:24:56.396]             {
[08:24:56.396]                 {
[08:24:56.396]                   {
[08:24:56.396]                     {
[08:24:56.396]                       base::local({
[08:24:56.396]                         has_future <- base::requireNamespace("future", 
[08:24:56.396]                           quietly = TRUE)
[08:24:56.396]                         if (has_future) {
[08:24:56.396]                           ns <- base::getNamespace("future")
[08:24:56.396]                           version <- ns[[".package"]][["version"]]
[08:24:56.396]                           if (is.null(version)) 
[08:24:56.396]                             version <- utils::packageVersion("future")
[08:24:56.396]                         }
[08:24:56.396]                         else {
[08:24:56.396]                           version <- NULL
[08:24:56.396]                         }
[08:24:56.396]                         if (!has_future || version < "1.8.0") {
[08:24:56.396]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.396]                             "", base::R.version$version.string), 
[08:24:56.396]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:56.396]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.396]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.396]                               "release", "version")], collapse = " "), 
[08:24:56.396]                             hostname = base::Sys.info()[["nodename"]])
[08:24:56.396]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.396]                             info)
[08:24:56.396]                           info <- base::paste(info, collapse = "; ")
[08:24:56.396]                           if (!has_future) {
[08:24:56.396]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.396]                               info)
[08:24:56.396]                           }
[08:24:56.396]                           else {
[08:24:56.396]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.396]                               info, version)
[08:24:56.396]                           }
[08:24:56.396]                           base::stop(msg)
[08:24:56.396]                         }
[08:24:56.396]                       })
[08:24:56.396]                     }
[08:24:56.396]                     base::local({
[08:24:56.396]                       for (pkg in "stats") {
[08:24:56.396]                         base::loadNamespace(pkg)
[08:24:56.396]                         base::library(pkg, character.only = TRUE)
[08:24:56.396]                       }
[08:24:56.396]                     })
[08:24:56.396]                   }
[08:24:56.396]                   ...future.strategy.old <- future::plan("list")
[08:24:56.396]                   options(future.plan = NULL)
[08:24:56.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.396]                 }
[08:24:56.396]                 ...future.workdir <- getwd()
[08:24:56.396]             }
[08:24:56.396]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.396]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.396]         }
[08:24:56.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.396]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.396]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.396]             base::names(...future.oldOptions))
[08:24:56.396]     }
[08:24:56.396]     if (FALSE) {
[08:24:56.396]     }
[08:24:56.396]     else {
[08:24:56.396]         if (TRUE) {
[08:24:56.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.396]                 open = "w")
[08:24:56.396]         }
[08:24:56.396]         else {
[08:24:56.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.396]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.396]         }
[08:24:56.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.396]             base::sink(type = "output", split = FALSE)
[08:24:56.396]             base::close(...future.stdout)
[08:24:56.396]         }, add = TRUE)
[08:24:56.396]     }
[08:24:56.396]     ...future.frame <- base::sys.nframe()
[08:24:56.396]     ...future.conditions <- base::list()
[08:24:56.396]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.396]     if (FALSE) {
[08:24:56.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.396]     }
[08:24:56.396]     ...future.result <- base::tryCatch({
[08:24:56.396]         base::withCallingHandlers({
[08:24:56.396]             ...future.value <- base::withVisible(base::local({
[08:24:56.396]                 do.call(function(...) {
[08:24:56.396]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.396]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.396]                     ...future.globals.maxSize)) {
[08:24:56.396]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.396]                     on.exit(options(oopts), add = TRUE)
[08:24:56.396]                   }
[08:24:56.396]                   {
[08:24:56.396]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.396]                       FUN = function(jj) {
[08:24:56.396]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.396]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.396]                       })
[08:24:56.396]                   }
[08:24:56.396]                 }, args = future.call.arguments)
[08:24:56.396]             }))
[08:24:56.396]             future::FutureResult(value = ...future.value$value, 
[08:24:56.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.396]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.396]                     ...future.globalenv.names))
[08:24:56.396]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.396]         }, condition = base::local({
[08:24:56.396]             c <- base::c
[08:24:56.396]             inherits <- base::inherits
[08:24:56.396]             invokeRestart <- base::invokeRestart
[08:24:56.396]             length <- base::length
[08:24:56.396]             list <- base::list
[08:24:56.396]             seq.int <- base::seq.int
[08:24:56.396]             signalCondition <- base::signalCondition
[08:24:56.396]             sys.calls <- base::sys.calls
[08:24:56.396]             `[[` <- base::`[[`
[08:24:56.396]             `+` <- base::`+`
[08:24:56.396]             `<<-` <- base::`<<-`
[08:24:56.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.396]                   3L)]
[08:24:56.396]             }
[08:24:56.396]             function(cond) {
[08:24:56.396]                 is_error <- inherits(cond, "error")
[08:24:56.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.396]                   NULL)
[08:24:56.396]                 if (is_error) {
[08:24:56.396]                   sessionInformation <- function() {
[08:24:56.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.396]                       search = base::search(), system = base::Sys.info())
[08:24:56.396]                   }
[08:24:56.396]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.396]                     cond$call), session = sessionInformation(), 
[08:24:56.396]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.396]                   signalCondition(cond)
[08:24:56.396]                 }
[08:24:56.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.396]                 "immediateCondition"))) {
[08:24:56.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.396]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.396]                   if (TRUE && !signal) {
[08:24:56.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.396]                     {
[08:24:56.396]                       inherits <- base::inherits
[08:24:56.396]                       invokeRestart <- base::invokeRestart
[08:24:56.396]                       is.null <- base::is.null
[08:24:56.396]                       muffled <- FALSE
[08:24:56.396]                       if (inherits(cond, "message")) {
[08:24:56.396]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.396]                         if (muffled) 
[08:24:56.396]                           invokeRestart("muffleMessage")
[08:24:56.396]                       }
[08:24:56.396]                       else if (inherits(cond, "warning")) {
[08:24:56.396]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.396]                         if (muffled) 
[08:24:56.396]                           invokeRestart("muffleWarning")
[08:24:56.396]                       }
[08:24:56.396]                       else if (inherits(cond, "condition")) {
[08:24:56.396]                         if (!is.null(pattern)) {
[08:24:56.396]                           computeRestarts <- base::computeRestarts
[08:24:56.396]                           grepl <- base::grepl
[08:24:56.396]                           restarts <- computeRestarts(cond)
[08:24:56.396]                           for (restart in restarts) {
[08:24:56.396]                             name <- restart$name
[08:24:56.396]                             if (is.null(name)) 
[08:24:56.396]                               next
[08:24:56.396]                             if (!grepl(pattern, name)) 
[08:24:56.396]                               next
[08:24:56.396]                             invokeRestart(restart)
[08:24:56.396]                             muffled <- TRUE
[08:24:56.396]                             break
[08:24:56.396]                           }
[08:24:56.396]                         }
[08:24:56.396]                       }
[08:24:56.396]                       invisible(muffled)
[08:24:56.396]                     }
[08:24:56.396]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.396]                   }
[08:24:56.396]                 }
[08:24:56.396]                 else {
[08:24:56.396]                   if (TRUE) {
[08:24:56.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.396]                     {
[08:24:56.396]                       inherits <- base::inherits
[08:24:56.396]                       invokeRestart <- base::invokeRestart
[08:24:56.396]                       is.null <- base::is.null
[08:24:56.396]                       muffled <- FALSE
[08:24:56.396]                       if (inherits(cond, "message")) {
[08:24:56.396]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.396]                         if (muffled) 
[08:24:56.396]                           invokeRestart("muffleMessage")
[08:24:56.396]                       }
[08:24:56.396]                       else if (inherits(cond, "warning")) {
[08:24:56.396]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.396]                         if (muffled) 
[08:24:56.396]                           invokeRestart("muffleWarning")
[08:24:56.396]                       }
[08:24:56.396]                       else if (inherits(cond, "condition")) {
[08:24:56.396]                         if (!is.null(pattern)) {
[08:24:56.396]                           computeRestarts <- base::computeRestarts
[08:24:56.396]                           grepl <- base::grepl
[08:24:56.396]                           restarts <- computeRestarts(cond)
[08:24:56.396]                           for (restart in restarts) {
[08:24:56.396]                             name <- restart$name
[08:24:56.396]                             if (is.null(name)) 
[08:24:56.396]                               next
[08:24:56.396]                             if (!grepl(pattern, name)) 
[08:24:56.396]                               next
[08:24:56.396]                             invokeRestart(restart)
[08:24:56.396]                             muffled <- TRUE
[08:24:56.396]                             break
[08:24:56.396]                           }
[08:24:56.396]                         }
[08:24:56.396]                       }
[08:24:56.396]                       invisible(muffled)
[08:24:56.396]                     }
[08:24:56.396]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.396]                   }
[08:24:56.396]                 }
[08:24:56.396]             }
[08:24:56.396]         }))
[08:24:56.396]     }, error = function(ex) {
[08:24:56.396]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.396]                 ...future.rng), started = ...future.startTime, 
[08:24:56.396]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.396]             version = "1.8"), class = "FutureResult")
[08:24:56.396]     }, finally = {
[08:24:56.396]         if (!identical(...future.workdir, getwd())) 
[08:24:56.396]             setwd(...future.workdir)
[08:24:56.396]         {
[08:24:56.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.396]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.396]             }
[08:24:56.396]             base::options(...future.oldOptions)
[08:24:56.396]             if (.Platform$OS.type == "windows") {
[08:24:56.396]                 old_names <- names(...future.oldEnvVars)
[08:24:56.396]                 envs <- base::Sys.getenv()
[08:24:56.396]                 names <- names(envs)
[08:24:56.396]                 common <- intersect(names, old_names)
[08:24:56.396]                 added <- setdiff(names, old_names)
[08:24:56.396]                 removed <- setdiff(old_names, names)
[08:24:56.396]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.396]                   envs[common]]
[08:24:56.396]                 NAMES <- toupper(changed)
[08:24:56.396]                 args <- list()
[08:24:56.396]                 for (kk in seq_along(NAMES)) {
[08:24:56.396]                   name <- changed[[kk]]
[08:24:56.396]                   NAME <- NAMES[[kk]]
[08:24:56.396]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.396]                     next
[08:24:56.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.396]                 }
[08:24:56.396]                 NAMES <- toupper(added)
[08:24:56.396]                 for (kk in seq_along(NAMES)) {
[08:24:56.396]                   name <- added[[kk]]
[08:24:56.396]                   NAME <- NAMES[[kk]]
[08:24:56.396]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.396]                     next
[08:24:56.396]                   args[[name]] <- ""
[08:24:56.396]                 }
[08:24:56.396]                 NAMES <- toupper(removed)
[08:24:56.396]                 for (kk in seq_along(NAMES)) {
[08:24:56.396]                   name <- removed[[kk]]
[08:24:56.396]                   NAME <- NAMES[[kk]]
[08:24:56.396]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.396]                     next
[08:24:56.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.396]                 }
[08:24:56.396]                 if (length(args) > 0) 
[08:24:56.396]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.396]             }
[08:24:56.396]             else {
[08:24:56.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.396]             }
[08:24:56.396]             {
[08:24:56.396]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.396]                   0L) {
[08:24:56.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.396]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.396]                   base::options(opts)
[08:24:56.396]                 }
[08:24:56.396]                 {
[08:24:56.396]                   {
[08:24:56.396]                     NULL
[08:24:56.396]                     RNGkind("Mersenne-Twister")
[08:24:56.396]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.396]                       inherits = FALSE)
[08:24:56.396]                   }
[08:24:56.396]                   options(future.plan = NULL)
[08:24:56.396]                   if (is.na(NA_character_)) 
[08:24:56.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.396]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.396]                     .init = FALSE)
[08:24:56.396]                 }
[08:24:56.396]             }
[08:24:56.396]         }
[08:24:56.396]     })
[08:24:56.396]     if (TRUE) {
[08:24:56.396]         base::sink(type = "output", split = FALSE)
[08:24:56.396]         if (TRUE) {
[08:24:56.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.396]         }
[08:24:56.396]         else {
[08:24:56.396]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.396]         }
[08:24:56.396]         base::close(...future.stdout)
[08:24:56.396]         ...future.stdout <- NULL
[08:24:56.396]     }
[08:24:56.396]     ...future.result$conditions <- ...future.conditions
[08:24:56.396]     ...future.result$finished <- base::Sys.time()
[08:24:56.396]     ...future.result
[08:24:56.396] }
[08:24:56.398] assign_globals() ...
[08:24:56.398] List of 5
[08:24:56.398]  $ ...future.FUN            :function (x, ...)  
[08:24:56.398]  $ future.call.arguments    :List of 1
[08:24:56.398]   ..$ singular.ok: logi FALSE
[08:24:56.398]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.398]  $ ...future.elements_ii    :List of 3
[08:24:56.398]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.398]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.398]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.398]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.398]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.398]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.398]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.398]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:56.398]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.398]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.398]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.398]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:56.398]  $ ...future.seeds_ii       : NULL
[08:24:56.398]  $ ...future.globals.maxSize: NULL
[08:24:56.398]  - attr(*, "where")=List of 5
[08:24:56.398]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.398]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.398]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.398]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.398]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.398]  - attr(*, "resolved")= logi FALSE
[08:24:56.398]  - attr(*, "total_size")= num 19977
[08:24:56.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.398]  - attr(*, "already-done")= logi TRUE
[08:24:56.408] - reassign environment for ‘...future.FUN’
[08:24:56.408] - copied ‘...future.FUN’ to environment
[08:24:56.408] - copied ‘future.call.arguments’ to environment
[08:24:56.408] - copied ‘...future.elements_ii’ to environment
[08:24:56.408] - copied ‘...future.seeds_ii’ to environment
[08:24:56.408] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.408] assign_globals() ... done
[08:24:56.409] plan(): Setting new future strategy stack:
[08:24:56.409] List of future strategies:
[08:24:56.409] 1. sequential:
[08:24:56.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.409]    - tweaked: FALSE
[08:24:56.409]    - call: NULL
[08:24:56.409] plan(): nbrOfWorkers() = 1
[08:24:56.412] plan(): Setting new future strategy stack:
[08:24:56.412] List of future strategies:
[08:24:56.412] 1. sequential:
[08:24:56.412]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.412]    - tweaked: FALSE
[08:24:56.412]    - call: plan(strategy)
[08:24:56.413] plan(): nbrOfWorkers() = 1
[08:24:56.413] SequentialFuture started (and completed)
[08:24:56.413] - Launch lazy future ... done
[08:24:56.413] run() for ‘SequentialFuture’ ... done
[08:24:56.413] Created future:
[08:24:56.413] SequentialFuture:
[08:24:56.413] Label: ‘future_by-1’
[08:24:56.413] Expression:
[08:24:56.413] {
[08:24:56.413]     do.call(function(...) {
[08:24:56.413]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.413]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.413]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.413]             on.exit(options(oopts), add = TRUE)
[08:24:56.413]         }
[08:24:56.413]         {
[08:24:56.413]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.413]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.413]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.413]             })
[08:24:56.413]         }
[08:24:56.413]     }, args = future.call.arguments)
[08:24:56.413] }
[08:24:56.413] Lazy evaluation: FALSE
[08:24:56.413] Asynchronous evaluation: FALSE
[08:24:56.413] Local evaluation: TRUE
[08:24:56.413] Environment: R_GlobalEnv
[08:24:56.413] Capture standard output: TRUE
[08:24:56.413] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.413] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.413] Packages: 1 packages (‘stats’)
[08:24:56.413] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.413] Resolved: TRUE
[08:24:56.413] Value: 77.05 KiB of class ‘list’
[08:24:56.413] Early signaling: FALSE
[08:24:56.413] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.413] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.415] Chunk #1 of 1 ... DONE
[08:24:56.415] Launching 1 futures (chunks) ... DONE
[08:24:56.415] Resolving 1 futures (chunks) ...
[08:24:56.415] resolve() on list ...
[08:24:56.415]  recursive: 0
[08:24:56.415]  length: 1
[08:24:56.415] 
[08:24:56.415] resolved() for ‘SequentialFuture’ ...
[08:24:56.415] - state: ‘finished’
[08:24:56.415] - run: TRUE
[08:24:56.415] - result: ‘FutureResult’
[08:24:56.416] resolved() for ‘SequentialFuture’ ... done
[08:24:56.416] Future #1
[08:24:56.416] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.416] - nx: 1
[08:24:56.416] - relay: TRUE
[08:24:56.416] - stdout: TRUE
[08:24:56.416] - signal: TRUE
[08:24:56.416] - resignal: FALSE
[08:24:56.416] - force: TRUE
[08:24:56.416] - relayed: [n=1] FALSE
[08:24:56.416] - queued futures: [n=1] FALSE
[08:24:56.417]  - until=1
[08:24:56.417]  - relaying element #1
[08:24:56.417] - relayed: [n=1] TRUE
[08:24:56.417] - queued futures: [n=1] TRUE
[08:24:56.417] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.417]  length: 0 (resolved future 1)
[08:24:56.417] Relaying remaining futures
[08:24:56.417] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.417] - nx: 1
[08:24:56.417] - relay: TRUE
[08:24:56.417] - stdout: TRUE
[08:24:56.418] - signal: TRUE
[08:24:56.418] - resignal: FALSE
[08:24:56.418] - force: TRUE
[08:24:56.418] - relayed: [n=1] TRUE
[08:24:56.418] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.418] - relayed: [n=1] TRUE
[08:24:56.418] - queued futures: [n=1] TRUE
[08:24:56.418] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.418] resolve() on list ... DONE
[08:24:56.418]  - Number of value chunks collected: 1
[08:24:56.418] Resolving 1 futures (chunks) ... DONE
[08:24:56.419] Reducing values from 1 chunks ...
[08:24:56.419]  - Number of values collected after concatenation: 3
[08:24:56.419]  - Number of values expected: 3
[08:24:56.419] Reducing values from 1 chunks ... DONE
[08:24:56.419] future_lapply() ... DONE
[08:24:56.419] future_by_internal() ... DONE
[08:24:56.425] future_by_internal() ...
[08:24:56.425] future_lapply() ...
[08:24:56.426] Number of chunks: 1
[08:24:56.426] getGlobalsAndPackagesXApply() ...
[08:24:56.426]  - future.globals: TRUE
[08:24:56.426] getGlobalsAndPackages() ...
[08:24:56.426] Searching for globals...
[08:24:56.428] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:56.428] Searching for globals ... DONE
[08:24:56.428] Resolving globals: FALSE
[08:24:56.428] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[08:24:56.429] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[08:24:56.429] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:56.429] - packages: [1] ‘stats’
[08:24:56.429] getGlobalsAndPackages() ... DONE
[08:24:56.429]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:56.429]  - needed namespaces: [n=1] ‘stats’
[08:24:56.430] Finding globals ... DONE
[08:24:56.430]  - use_args: TRUE
[08:24:56.430]  - Getting '...' globals ...
[08:24:56.430] resolve() on list ...
[08:24:56.430]  recursive: 0
[08:24:56.430]  length: 1
[08:24:56.430]  elements: ‘...’
[08:24:56.430]  length: 0 (resolved future 1)
[08:24:56.430] resolve() on list ... DONE
[08:24:56.431]    - '...' content: [n=0] 
[08:24:56.431] List of 1
[08:24:56.431]  $ ...: list()
[08:24:56.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.431]  - attr(*, "where")=List of 1
[08:24:56.431]   ..$ ...:<environment: 0x557b26878ec0> 
[08:24:56.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.431]  - attr(*, "resolved")= logi TRUE
[08:24:56.431]  - attr(*, "total_size")= num NA
[08:24:56.433]  - Getting '...' globals ... DONE
[08:24:56.433] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[08:24:56.433] List of 4
[08:24:56.433]  $ ...future.FUN:function (x)  
[08:24:56.433]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:56.433]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.433]  $ ...          : list()
[08:24:56.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.433]  - attr(*, "where")=List of 4
[08:24:56.433]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.433]   ..$ breaks       :<environment: R_EmptyEnv> 
[08:24:56.433]   ..$ wool         :<environment: R_EmptyEnv> 
[08:24:56.433]   ..$ ...          :<environment: 0x557b26878ec0> 
[08:24:56.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.433]  - attr(*, "resolved")= logi FALSE
[08:24:56.433]  - attr(*, "total_size")= num 18867
[08:24:56.437] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:56.437] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.437] Number of futures (= number of chunks): 1
[08:24:56.437] Launching 1 futures (chunks) ...
[08:24:56.438] Chunk #1 of 1 ...
[08:24:56.438]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.438] getGlobalsAndPackages() ...
[08:24:56.438] Searching for globals...
[08:24:56.438] 
[08:24:56.438] Searching for globals ... DONE
[08:24:56.438] - globals: [0] <none>
[08:24:56.439] getGlobalsAndPackages() ... DONE
[08:24:56.439]    + additional globals found: [n=0] 
[08:24:56.439]    + additional namespaces needed: [n=0] 
[08:24:56.439]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.439]  - seeds: <none>
[08:24:56.439]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.439] getGlobalsAndPackages() ...
[08:24:56.439] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.439] Resolving globals: FALSE
[08:24:56.439] Tweak future expression to call with '...' arguments ...
[08:24:56.440] {
[08:24:56.440]     do.call(function(...) {
[08:24:56.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.440]             on.exit(options(oopts), add = TRUE)
[08:24:56.440]         }
[08:24:56.440]         {
[08:24:56.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.440]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.440]             })
[08:24:56.440]         }
[08:24:56.440]     }, args = future.call.arguments)
[08:24:56.440] }
[08:24:56.440] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.440] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.440] 
[08:24:56.440] getGlobalsAndPackages() ... DONE
[08:24:56.441] run() for ‘Future’ ...
[08:24:56.441] - state: ‘created’
[08:24:56.441] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:56.441] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.441]   - Field: ‘label’
[08:24:56.442]   - Field: ‘local’
[08:24:56.442]   - Field: ‘owner’
[08:24:56.442]   - Field: ‘envir’
[08:24:56.442]   - Field: ‘packages’
[08:24:56.443]   - Field: ‘gc’
[08:24:56.443]   - Field: ‘conditions’
[08:24:56.444]   - Field: ‘expr’
[08:24:56.444]   - Field: ‘uuid’
[08:24:56.444]   - Field: ‘seed’
[08:24:56.444]   - Field: ‘version’
[08:24:56.444]   - Field: ‘result’
[08:24:56.444]   - Field: ‘asynchronous’
[08:24:56.444]   - Field: ‘calls’
[08:24:56.444]   - Field: ‘globals’
[08:24:56.444]   - Field: ‘stdout’
[08:24:56.444]   - Field: ‘earlySignal’
[08:24:56.444]   - Field: ‘lazy’
[08:24:56.444]   - Field: ‘state’
[08:24:56.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.445] - Launch lazy future ...
[08:24:56.445] Packages needed by the future expression (n = 1): ‘stats’
[08:24:56.445] Packages needed by future strategies (n = 0): <none>
[08:24:56.446] {
[08:24:56.446]     {
[08:24:56.446]         {
[08:24:56.446]             ...future.startTime <- base::Sys.time()
[08:24:56.446]             {
[08:24:56.446]                 {
[08:24:56.446]                   {
[08:24:56.446]                     {
[08:24:56.446]                       base::local({
[08:24:56.446]                         has_future <- base::requireNamespace("future", 
[08:24:56.446]                           quietly = TRUE)
[08:24:56.446]                         if (has_future) {
[08:24:56.446]                           ns <- base::getNamespace("future")
[08:24:56.446]                           version <- ns[[".package"]][["version"]]
[08:24:56.446]                           if (is.null(version)) 
[08:24:56.446]                             version <- utils::packageVersion("future")
[08:24:56.446]                         }
[08:24:56.446]                         else {
[08:24:56.446]                           version <- NULL
[08:24:56.446]                         }
[08:24:56.446]                         if (!has_future || version < "1.8.0") {
[08:24:56.446]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.446]                             "", base::R.version$version.string), 
[08:24:56.446]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:56.446]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.446]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.446]                               "release", "version")], collapse = " "), 
[08:24:56.446]                             hostname = base::Sys.info()[["nodename"]])
[08:24:56.446]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.446]                             info)
[08:24:56.446]                           info <- base::paste(info, collapse = "; ")
[08:24:56.446]                           if (!has_future) {
[08:24:56.446]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.446]                               info)
[08:24:56.446]                           }
[08:24:56.446]                           else {
[08:24:56.446]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.446]                               info, version)
[08:24:56.446]                           }
[08:24:56.446]                           base::stop(msg)
[08:24:56.446]                         }
[08:24:56.446]                       })
[08:24:56.446]                     }
[08:24:56.446]                     base::local({
[08:24:56.446]                       for (pkg in "stats") {
[08:24:56.446]                         base::loadNamespace(pkg)
[08:24:56.446]                         base::library(pkg, character.only = TRUE)
[08:24:56.446]                       }
[08:24:56.446]                     })
[08:24:56.446]                   }
[08:24:56.446]                   ...future.strategy.old <- future::plan("list")
[08:24:56.446]                   options(future.plan = NULL)
[08:24:56.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.446]                 }
[08:24:56.446]                 ...future.workdir <- getwd()
[08:24:56.446]             }
[08:24:56.446]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.446]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.446]         }
[08:24:56.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.446]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.446]             base::names(...future.oldOptions))
[08:24:56.446]     }
[08:24:56.446]     if (FALSE) {
[08:24:56.446]     }
[08:24:56.446]     else {
[08:24:56.446]         if (TRUE) {
[08:24:56.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.446]                 open = "w")
[08:24:56.446]         }
[08:24:56.446]         else {
[08:24:56.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.446]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.446]         }
[08:24:56.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.446]             base::sink(type = "output", split = FALSE)
[08:24:56.446]             base::close(...future.stdout)
[08:24:56.446]         }, add = TRUE)
[08:24:56.446]     }
[08:24:56.446]     ...future.frame <- base::sys.nframe()
[08:24:56.446]     ...future.conditions <- base::list()
[08:24:56.446]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.446]     if (FALSE) {
[08:24:56.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.446]     }
[08:24:56.446]     ...future.result <- base::tryCatch({
[08:24:56.446]         base::withCallingHandlers({
[08:24:56.446]             ...future.value <- base::withVisible(base::local({
[08:24:56.446]                 do.call(function(...) {
[08:24:56.446]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.446]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.446]                     ...future.globals.maxSize)) {
[08:24:56.446]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.446]                     on.exit(options(oopts), add = TRUE)
[08:24:56.446]                   }
[08:24:56.446]                   {
[08:24:56.446]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.446]                       FUN = function(jj) {
[08:24:56.446]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.446]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.446]                       })
[08:24:56.446]                   }
[08:24:56.446]                 }, args = future.call.arguments)
[08:24:56.446]             }))
[08:24:56.446]             future::FutureResult(value = ...future.value$value, 
[08:24:56.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.446]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.446]                     ...future.globalenv.names))
[08:24:56.446]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.446]         }, condition = base::local({
[08:24:56.446]             c <- base::c
[08:24:56.446]             inherits <- base::inherits
[08:24:56.446]             invokeRestart <- base::invokeRestart
[08:24:56.446]             length <- base::length
[08:24:56.446]             list <- base::list
[08:24:56.446]             seq.int <- base::seq.int
[08:24:56.446]             signalCondition <- base::signalCondition
[08:24:56.446]             sys.calls <- base::sys.calls
[08:24:56.446]             `[[` <- base::`[[`
[08:24:56.446]             `+` <- base::`+`
[08:24:56.446]             `<<-` <- base::`<<-`
[08:24:56.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.446]                   3L)]
[08:24:56.446]             }
[08:24:56.446]             function(cond) {
[08:24:56.446]                 is_error <- inherits(cond, "error")
[08:24:56.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.446]                   NULL)
[08:24:56.446]                 if (is_error) {
[08:24:56.446]                   sessionInformation <- function() {
[08:24:56.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.446]                       search = base::search(), system = base::Sys.info())
[08:24:56.446]                   }
[08:24:56.446]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.446]                     cond$call), session = sessionInformation(), 
[08:24:56.446]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.446]                   signalCondition(cond)
[08:24:56.446]                 }
[08:24:56.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.446]                 "immediateCondition"))) {
[08:24:56.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.446]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.446]                   if (TRUE && !signal) {
[08:24:56.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.446]                     {
[08:24:56.446]                       inherits <- base::inherits
[08:24:56.446]                       invokeRestart <- base::invokeRestart
[08:24:56.446]                       is.null <- base::is.null
[08:24:56.446]                       muffled <- FALSE
[08:24:56.446]                       if (inherits(cond, "message")) {
[08:24:56.446]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.446]                         if (muffled) 
[08:24:56.446]                           invokeRestart("muffleMessage")
[08:24:56.446]                       }
[08:24:56.446]                       else if (inherits(cond, "warning")) {
[08:24:56.446]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.446]                         if (muffled) 
[08:24:56.446]                           invokeRestart("muffleWarning")
[08:24:56.446]                       }
[08:24:56.446]                       else if (inherits(cond, "condition")) {
[08:24:56.446]                         if (!is.null(pattern)) {
[08:24:56.446]                           computeRestarts <- base::computeRestarts
[08:24:56.446]                           grepl <- base::grepl
[08:24:56.446]                           restarts <- computeRestarts(cond)
[08:24:56.446]                           for (restart in restarts) {
[08:24:56.446]                             name <- restart$name
[08:24:56.446]                             if (is.null(name)) 
[08:24:56.446]                               next
[08:24:56.446]                             if (!grepl(pattern, name)) 
[08:24:56.446]                               next
[08:24:56.446]                             invokeRestart(restart)
[08:24:56.446]                             muffled <- TRUE
[08:24:56.446]                             break
[08:24:56.446]                           }
[08:24:56.446]                         }
[08:24:56.446]                       }
[08:24:56.446]                       invisible(muffled)
[08:24:56.446]                     }
[08:24:56.446]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.446]                   }
[08:24:56.446]                 }
[08:24:56.446]                 else {
[08:24:56.446]                   if (TRUE) {
[08:24:56.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.446]                     {
[08:24:56.446]                       inherits <- base::inherits
[08:24:56.446]                       invokeRestart <- base::invokeRestart
[08:24:56.446]                       is.null <- base::is.null
[08:24:56.446]                       muffled <- FALSE
[08:24:56.446]                       if (inherits(cond, "message")) {
[08:24:56.446]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.446]                         if (muffled) 
[08:24:56.446]                           invokeRestart("muffleMessage")
[08:24:56.446]                       }
[08:24:56.446]                       else if (inherits(cond, "warning")) {
[08:24:56.446]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.446]                         if (muffled) 
[08:24:56.446]                           invokeRestart("muffleWarning")
[08:24:56.446]                       }
[08:24:56.446]                       else if (inherits(cond, "condition")) {
[08:24:56.446]                         if (!is.null(pattern)) {
[08:24:56.446]                           computeRestarts <- base::computeRestarts
[08:24:56.446]                           grepl <- base::grepl
[08:24:56.446]                           restarts <- computeRestarts(cond)
[08:24:56.446]                           for (restart in restarts) {
[08:24:56.446]                             name <- restart$name
[08:24:56.446]                             if (is.null(name)) 
[08:24:56.446]                               next
[08:24:56.446]                             if (!grepl(pattern, name)) 
[08:24:56.446]                               next
[08:24:56.446]                             invokeRestart(restart)
[08:24:56.446]                             muffled <- TRUE
[08:24:56.446]                             break
[08:24:56.446]                           }
[08:24:56.446]                         }
[08:24:56.446]                       }
[08:24:56.446]                       invisible(muffled)
[08:24:56.446]                     }
[08:24:56.446]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.446]                   }
[08:24:56.446]                 }
[08:24:56.446]             }
[08:24:56.446]         }))
[08:24:56.446]     }, error = function(ex) {
[08:24:56.446]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.446]                 ...future.rng), started = ...future.startTime, 
[08:24:56.446]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.446]             version = "1.8"), class = "FutureResult")
[08:24:56.446]     }, finally = {
[08:24:56.446]         if (!identical(...future.workdir, getwd())) 
[08:24:56.446]             setwd(...future.workdir)
[08:24:56.446]         {
[08:24:56.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.446]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.446]             }
[08:24:56.446]             base::options(...future.oldOptions)
[08:24:56.446]             if (.Platform$OS.type == "windows") {
[08:24:56.446]                 old_names <- names(...future.oldEnvVars)
[08:24:56.446]                 envs <- base::Sys.getenv()
[08:24:56.446]                 names <- names(envs)
[08:24:56.446]                 common <- intersect(names, old_names)
[08:24:56.446]                 added <- setdiff(names, old_names)
[08:24:56.446]                 removed <- setdiff(old_names, names)
[08:24:56.446]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.446]                   envs[common]]
[08:24:56.446]                 NAMES <- toupper(changed)
[08:24:56.446]                 args <- list()
[08:24:56.446]                 for (kk in seq_along(NAMES)) {
[08:24:56.446]                   name <- changed[[kk]]
[08:24:56.446]                   NAME <- NAMES[[kk]]
[08:24:56.446]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.446]                     next
[08:24:56.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.446]                 }
[08:24:56.446]                 NAMES <- toupper(added)
[08:24:56.446]                 for (kk in seq_along(NAMES)) {
[08:24:56.446]                   name <- added[[kk]]
[08:24:56.446]                   NAME <- NAMES[[kk]]
[08:24:56.446]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.446]                     next
[08:24:56.446]                   args[[name]] <- ""
[08:24:56.446]                 }
[08:24:56.446]                 NAMES <- toupper(removed)
[08:24:56.446]                 for (kk in seq_along(NAMES)) {
[08:24:56.446]                   name <- removed[[kk]]
[08:24:56.446]                   NAME <- NAMES[[kk]]
[08:24:56.446]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.446]                     next
[08:24:56.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.446]                 }
[08:24:56.446]                 if (length(args) > 0) 
[08:24:56.446]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.446]             }
[08:24:56.446]             else {
[08:24:56.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.446]             }
[08:24:56.446]             {
[08:24:56.446]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.446]                   0L) {
[08:24:56.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.446]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.446]                   base::options(opts)
[08:24:56.446]                 }
[08:24:56.446]                 {
[08:24:56.446]                   {
[08:24:56.446]                     NULL
[08:24:56.446]                     RNGkind("Mersenne-Twister")
[08:24:56.446]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.446]                       inherits = FALSE)
[08:24:56.446]                   }
[08:24:56.446]                   options(future.plan = NULL)
[08:24:56.446]                   if (is.na(NA_character_)) 
[08:24:56.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.446]                     .init = FALSE)
[08:24:56.446]                 }
[08:24:56.446]             }
[08:24:56.446]         }
[08:24:56.446]     })
[08:24:56.446]     if (TRUE) {
[08:24:56.446]         base::sink(type = "output", split = FALSE)
[08:24:56.446]         if (TRUE) {
[08:24:56.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.446]         }
[08:24:56.446]         else {
[08:24:56.446]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.446]         }
[08:24:56.446]         base::close(...future.stdout)
[08:24:56.446]         ...future.stdout <- NULL
[08:24:56.446]     }
[08:24:56.446]     ...future.result$conditions <- ...future.conditions
[08:24:56.446]     ...future.result$finished <- base::Sys.time()
[08:24:56.446]     ...future.result
[08:24:56.446] }
[08:24:56.447] assign_globals() ...
[08:24:56.447] List of 7
[08:24:56.447]  $ ...future.FUN            :function (x)  
[08:24:56.447]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:56.447]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.447]  $ future.call.arguments    : list()
[08:24:56.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.447]  $ ...future.elements_ii    :List of 3
[08:24:56.447]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.447]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.447]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.447]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.447]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.447]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.447]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.447]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:56.447]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.447]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.447]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.447]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:56.447]  $ ...future.seeds_ii       : NULL
[08:24:56.447]  $ ...future.globals.maxSize: NULL
[08:24:56.447]  - attr(*, "where")=List of 7
[08:24:56.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.447]   ..$ breaks                   :<environment: R_EmptyEnv> 
[08:24:56.447]   ..$ wool                     :<environment: R_EmptyEnv> 
[08:24:56.447]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.447]  - attr(*, "resolved")= logi FALSE
[08:24:56.447]  - attr(*, "total_size")= num 18867
[08:24:56.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.447]  - attr(*, "already-done")= logi TRUE
[08:24:56.457] - reassign environment for ‘...future.FUN’
[08:24:56.457] - copied ‘...future.FUN’ to environment
[08:24:56.457] - copied ‘breaks’ to environment
[08:24:56.457] - copied ‘wool’ to environment
[08:24:56.457] - copied ‘future.call.arguments’ to environment
[08:24:56.457] - copied ‘...future.elements_ii’ to environment
[08:24:56.458] - copied ‘...future.seeds_ii’ to environment
[08:24:56.458] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.458] assign_globals() ... done
[08:24:56.458] plan(): Setting new future strategy stack:
[08:24:56.458] List of future strategies:
[08:24:56.458] 1. sequential:
[08:24:56.458]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.458]    - tweaked: FALSE
[08:24:56.458]    - call: NULL
[08:24:56.459] plan(): nbrOfWorkers() = 1
[08:24:56.462] plan(): Setting new future strategy stack:
[08:24:56.462] List of future strategies:
[08:24:56.462] 1. sequential:
[08:24:56.462]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.462]    - tweaked: FALSE
[08:24:56.462]    - call: plan(strategy)
[08:24:56.462] plan(): nbrOfWorkers() = 1
[08:24:56.462] SequentialFuture started (and completed)
[08:24:56.462] - Launch lazy future ... done
[08:24:56.463] run() for ‘SequentialFuture’ ... done
[08:24:56.463] Created future:
[08:24:56.463] SequentialFuture:
[08:24:56.463] Label: ‘future_by-1’
[08:24:56.463] Expression:
[08:24:56.463] {
[08:24:56.463]     do.call(function(...) {
[08:24:56.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.463]             on.exit(options(oopts), add = TRUE)
[08:24:56.463]         }
[08:24:56.463]         {
[08:24:56.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.463]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.463]             })
[08:24:56.463]         }
[08:24:56.463]     }, args = future.call.arguments)
[08:24:56.463] }
[08:24:56.463] Lazy evaluation: FALSE
[08:24:56.463] Asynchronous evaluation: FALSE
[08:24:56.463] Local evaluation: TRUE
[08:24:56.463] Environment: 0x557b26ac5ea0
[08:24:56.463] Capture standard output: TRUE
[08:24:56.463] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.463] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[08:24:56.463] Packages: 1 packages (‘stats’)
[08:24:56.463] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.463] Resolved: TRUE
[08:24:56.463] Value: 78.42 KiB of class ‘list’
[08:24:56.463] Early signaling: FALSE
[08:24:56.463] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.463] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.464] Chunk #1 of 1 ... DONE
[08:24:56.464] Launching 1 futures (chunks) ... DONE
[08:24:56.464] Resolving 1 futures (chunks) ...
[08:24:56.464] resolve() on list ...
[08:24:56.465]  recursive: 0
[08:24:56.465]  length: 1
[08:24:56.466] 
[08:24:56.467] resolved() for ‘SequentialFuture’ ...
[08:24:56.467] - state: ‘finished’
[08:24:56.467] - run: TRUE
[08:24:56.467] - result: ‘FutureResult’
[08:24:56.467] resolved() for ‘SequentialFuture’ ... done
[08:24:56.467] Future #1
[08:24:56.467] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.467] - nx: 1
[08:24:56.467] - relay: TRUE
[08:24:56.467] - stdout: TRUE
[08:24:56.467] - signal: TRUE
[08:24:56.468] - resignal: FALSE
[08:24:56.468] - force: TRUE
[08:24:56.468] - relayed: [n=1] FALSE
[08:24:56.468] - queued futures: [n=1] FALSE
[08:24:56.468]  - until=1
[08:24:56.468]  - relaying element #1
[08:24:56.468] - relayed: [n=1] TRUE
[08:24:56.468] - queued futures: [n=1] TRUE
[08:24:56.468] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.468]  length: 0 (resolved future 1)
[08:24:56.469] Relaying remaining futures
[08:24:56.469] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.469] - nx: 1
[08:24:56.469] - relay: TRUE
[08:24:56.469] - stdout: TRUE
[08:24:56.469] - signal: TRUE
[08:24:56.469] - resignal: FALSE
[08:24:56.469] - force: TRUE
[08:24:56.469] - relayed: [n=1] TRUE
[08:24:56.469] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.469] - relayed: [n=1] TRUE
[08:24:56.470] - queued futures: [n=1] TRUE
[08:24:56.470] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.470] resolve() on list ... DONE
[08:24:56.470]  - Number of value chunks collected: 1
[08:24:56.470] Resolving 1 futures (chunks) ... DONE
[08:24:56.470] Reducing values from 1 chunks ...
[08:24:56.470]  - Number of values collected after concatenation: 3
[08:24:56.470]  - Number of values expected: 3
[08:24:56.470] Reducing values from 1 chunks ... DONE
[08:24:56.470] future_lapply() ... DONE
[08:24:56.470] future_by_internal() ... DONE
[08:24:56.471] future_by_internal() ...
[08:24:56.471] future_lapply() ...
[08:24:56.472] Number of chunks: 1
[08:24:56.472] getGlobalsAndPackagesXApply() ...
[08:24:56.472]  - future.globals: TRUE
[08:24:56.472] getGlobalsAndPackages() ...
[08:24:56.472] Searching for globals...
[08:24:56.473] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.473] Searching for globals ... DONE
[08:24:56.473] Resolving globals: FALSE
[08:24:56.474] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.474] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.474] - globals: [1] ‘FUN’
[08:24:56.474] 
[08:24:56.474] getGlobalsAndPackages() ... DONE
[08:24:56.474]  - globals found/used: [n=1] ‘FUN’
[08:24:56.475]  - needed namespaces: [n=0] 
[08:24:56.475] Finding globals ... DONE
[08:24:56.475]  - use_args: TRUE
[08:24:56.475]  - Getting '...' globals ...
[08:24:56.475] resolve() on list ...
[08:24:56.475]  recursive: 0
[08:24:56.475]  length: 1
[08:24:56.475]  elements: ‘...’
[08:24:56.476]  length: 0 (resolved future 1)
[08:24:56.476] resolve() on list ... DONE
[08:24:56.476]    - '...' content: [n=0] 
[08:24:56.476] List of 1
[08:24:56.476]  $ ...: list()
[08:24:56.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.476]  - attr(*, "where")=List of 1
[08:24:56.476]   ..$ ...:<environment: 0x557b25c93238> 
[08:24:56.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.476]  - attr(*, "resolved")= logi TRUE
[08:24:56.476]  - attr(*, "total_size")= num NA
[08:24:56.478]  - Getting '...' globals ... DONE
[08:24:56.478] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.478] List of 2
[08:24:56.478]  $ ...future.FUN:function (object, ...)  
[08:24:56.478]  $ ...          : list()
[08:24:56.478]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.478]  - attr(*, "where")=List of 2
[08:24:56.478]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.478]   ..$ ...          :<environment: 0x557b25c93238> 
[08:24:56.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.478]  - attr(*, "resolved")= logi FALSE
[08:24:56.478]  - attr(*, "total_size")= num 18709
[08:24:56.481] Packages to be attached in all futures: [n=0] 
[08:24:56.481] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.481] Number of futures (= number of chunks): 1
[08:24:56.482] Launching 1 futures (chunks) ...
[08:24:56.482] Chunk #1 of 1 ...
[08:24:56.482]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.482] getGlobalsAndPackages() ...
[08:24:56.482] Searching for globals...
[08:24:56.482] 
[08:24:56.482] Searching for globals ... DONE
[08:24:56.483] - globals: [0] <none>
[08:24:56.483] getGlobalsAndPackages() ... DONE
[08:24:56.483]    + additional globals found: [n=0] 
[08:24:56.483]    + additional namespaces needed: [n=0] 
[08:24:56.483]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.483]  - seeds: <none>
[08:24:56.483]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.483] getGlobalsAndPackages() ...
[08:24:56.483] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.483] Resolving globals: FALSE
[08:24:56.483] Tweak future expression to call with '...' arguments ...
[08:24:56.484] {
[08:24:56.484]     do.call(function(...) {
[08:24:56.484]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.484]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.484]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.484]             on.exit(options(oopts), add = TRUE)
[08:24:56.484]         }
[08:24:56.484]         {
[08:24:56.484]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.484]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.484]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.484]             })
[08:24:56.484]         }
[08:24:56.484]     }, args = future.call.arguments)
[08:24:56.484] }
[08:24:56.484] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.484] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.484] 
[08:24:56.484] getGlobalsAndPackages() ... DONE
[08:24:56.485] run() for ‘Future’ ...
[08:24:56.485] - state: ‘created’
[08:24:56.485] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:56.485] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.485] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.485]   - Field: ‘label’
[08:24:56.485]   - Field: ‘local’
[08:24:56.486]   - Field: ‘owner’
[08:24:56.486]   - Field: ‘envir’
[08:24:56.486]   - Field: ‘packages’
[08:24:56.488]   - Field: ‘gc’
[08:24:56.488]   - Field: ‘conditions’
[08:24:56.488]   - Field: ‘expr’
[08:24:56.488]   - Field: ‘uuid’
[08:24:56.488]   - Field: ‘seed’
[08:24:56.488]   - Field: ‘version’
[08:24:56.488]   - Field: ‘result’
[08:24:56.488]   - Field: ‘asynchronous’
[08:24:56.488]   - Field: ‘calls’
[08:24:56.488]   - Field: ‘globals’
[08:24:56.488]   - Field: ‘stdout’
[08:24:56.488]   - Field: ‘earlySignal’
[08:24:56.489]   - Field: ‘lazy’
[08:24:56.489]   - Field: ‘state’
[08:24:56.489] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.489] - Launch lazy future ...
[08:24:56.489] Packages needed by the future expression (n = 0): <none>
[08:24:56.489] Packages needed by future strategies (n = 0): <none>
[08:24:56.490] {
[08:24:56.490]     {
[08:24:56.490]         {
[08:24:56.490]             ...future.startTime <- base::Sys.time()
[08:24:56.490]             {
[08:24:56.490]                 {
[08:24:56.490]                   {
[08:24:56.490]                     base::local({
[08:24:56.490]                       has_future <- base::requireNamespace("future", 
[08:24:56.490]                         quietly = TRUE)
[08:24:56.490]                       if (has_future) {
[08:24:56.490]                         ns <- base::getNamespace("future")
[08:24:56.490]                         version <- ns[[".package"]][["version"]]
[08:24:56.490]                         if (is.null(version)) 
[08:24:56.490]                           version <- utils::packageVersion("future")
[08:24:56.490]                       }
[08:24:56.490]                       else {
[08:24:56.490]                         version <- NULL
[08:24:56.490]                       }
[08:24:56.490]                       if (!has_future || version < "1.8.0") {
[08:24:56.490]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.490]                           "", base::R.version$version.string), 
[08:24:56.490]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.490]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.490]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.490]                             "release", "version")], collapse = " "), 
[08:24:56.490]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.490]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.490]                           info)
[08:24:56.490]                         info <- base::paste(info, collapse = "; ")
[08:24:56.490]                         if (!has_future) {
[08:24:56.490]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.490]                             info)
[08:24:56.490]                         }
[08:24:56.490]                         else {
[08:24:56.490]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.490]                             info, version)
[08:24:56.490]                         }
[08:24:56.490]                         base::stop(msg)
[08:24:56.490]                       }
[08:24:56.490]                     })
[08:24:56.490]                   }
[08:24:56.490]                   ...future.strategy.old <- future::plan("list")
[08:24:56.490]                   options(future.plan = NULL)
[08:24:56.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.490]                 }
[08:24:56.490]                 ...future.workdir <- getwd()
[08:24:56.490]             }
[08:24:56.490]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.490]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.490]         }
[08:24:56.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.490]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.490]             base::names(...future.oldOptions))
[08:24:56.490]     }
[08:24:56.490]     if (FALSE) {
[08:24:56.490]     }
[08:24:56.490]     else {
[08:24:56.490]         if (TRUE) {
[08:24:56.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.490]                 open = "w")
[08:24:56.490]         }
[08:24:56.490]         else {
[08:24:56.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.490]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.490]         }
[08:24:56.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.490]             base::sink(type = "output", split = FALSE)
[08:24:56.490]             base::close(...future.stdout)
[08:24:56.490]         }, add = TRUE)
[08:24:56.490]     }
[08:24:56.490]     ...future.frame <- base::sys.nframe()
[08:24:56.490]     ...future.conditions <- base::list()
[08:24:56.490]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.490]     if (FALSE) {
[08:24:56.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.490]     }
[08:24:56.490]     ...future.result <- base::tryCatch({
[08:24:56.490]         base::withCallingHandlers({
[08:24:56.490]             ...future.value <- base::withVisible(base::local({
[08:24:56.490]                 do.call(function(...) {
[08:24:56.490]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.490]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.490]                     ...future.globals.maxSize)) {
[08:24:56.490]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.490]                     on.exit(options(oopts), add = TRUE)
[08:24:56.490]                   }
[08:24:56.490]                   {
[08:24:56.490]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.490]                       FUN = function(jj) {
[08:24:56.490]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.490]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.490]                       })
[08:24:56.490]                   }
[08:24:56.490]                 }, args = future.call.arguments)
[08:24:56.490]             }))
[08:24:56.490]             future::FutureResult(value = ...future.value$value, 
[08:24:56.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.490]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.490]                     ...future.globalenv.names))
[08:24:56.490]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.490]         }, condition = base::local({
[08:24:56.490]             c <- base::c
[08:24:56.490]             inherits <- base::inherits
[08:24:56.490]             invokeRestart <- base::invokeRestart
[08:24:56.490]             length <- base::length
[08:24:56.490]             list <- base::list
[08:24:56.490]             seq.int <- base::seq.int
[08:24:56.490]             signalCondition <- base::signalCondition
[08:24:56.490]             sys.calls <- base::sys.calls
[08:24:56.490]             `[[` <- base::`[[`
[08:24:56.490]             `+` <- base::`+`
[08:24:56.490]             `<<-` <- base::`<<-`
[08:24:56.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.490]                   3L)]
[08:24:56.490]             }
[08:24:56.490]             function(cond) {
[08:24:56.490]                 is_error <- inherits(cond, "error")
[08:24:56.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.490]                   NULL)
[08:24:56.490]                 if (is_error) {
[08:24:56.490]                   sessionInformation <- function() {
[08:24:56.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.490]                       search = base::search(), system = base::Sys.info())
[08:24:56.490]                   }
[08:24:56.490]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.490]                     cond$call), session = sessionInformation(), 
[08:24:56.490]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.490]                   signalCondition(cond)
[08:24:56.490]                 }
[08:24:56.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.490]                 "immediateCondition"))) {
[08:24:56.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.490]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.490]                   if (TRUE && !signal) {
[08:24:56.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.490]                     {
[08:24:56.490]                       inherits <- base::inherits
[08:24:56.490]                       invokeRestart <- base::invokeRestart
[08:24:56.490]                       is.null <- base::is.null
[08:24:56.490]                       muffled <- FALSE
[08:24:56.490]                       if (inherits(cond, "message")) {
[08:24:56.490]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.490]                         if (muffled) 
[08:24:56.490]                           invokeRestart("muffleMessage")
[08:24:56.490]                       }
[08:24:56.490]                       else if (inherits(cond, "warning")) {
[08:24:56.490]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.490]                         if (muffled) 
[08:24:56.490]                           invokeRestart("muffleWarning")
[08:24:56.490]                       }
[08:24:56.490]                       else if (inherits(cond, "condition")) {
[08:24:56.490]                         if (!is.null(pattern)) {
[08:24:56.490]                           computeRestarts <- base::computeRestarts
[08:24:56.490]                           grepl <- base::grepl
[08:24:56.490]                           restarts <- computeRestarts(cond)
[08:24:56.490]                           for (restart in restarts) {
[08:24:56.490]                             name <- restart$name
[08:24:56.490]                             if (is.null(name)) 
[08:24:56.490]                               next
[08:24:56.490]                             if (!grepl(pattern, name)) 
[08:24:56.490]                               next
[08:24:56.490]                             invokeRestart(restart)
[08:24:56.490]                             muffled <- TRUE
[08:24:56.490]                             break
[08:24:56.490]                           }
[08:24:56.490]                         }
[08:24:56.490]                       }
[08:24:56.490]                       invisible(muffled)
[08:24:56.490]                     }
[08:24:56.490]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.490]                   }
[08:24:56.490]                 }
[08:24:56.490]                 else {
[08:24:56.490]                   if (TRUE) {
[08:24:56.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.490]                     {
[08:24:56.490]                       inherits <- base::inherits
[08:24:56.490]                       invokeRestart <- base::invokeRestart
[08:24:56.490]                       is.null <- base::is.null
[08:24:56.490]                       muffled <- FALSE
[08:24:56.490]                       if (inherits(cond, "message")) {
[08:24:56.490]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.490]                         if (muffled) 
[08:24:56.490]                           invokeRestart("muffleMessage")
[08:24:56.490]                       }
[08:24:56.490]                       else if (inherits(cond, "warning")) {
[08:24:56.490]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.490]                         if (muffled) 
[08:24:56.490]                           invokeRestart("muffleWarning")
[08:24:56.490]                       }
[08:24:56.490]                       else if (inherits(cond, "condition")) {
[08:24:56.490]                         if (!is.null(pattern)) {
[08:24:56.490]                           computeRestarts <- base::computeRestarts
[08:24:56.490]                           grepl <- base::grepl
[08:24:56.490]                           restarts <- computeRestarts(cond)
[08:24:56.490]                           for (restart in restarts) {
[08:24:56.490]                             name <- restart$name
[08:24:56.490]                             if (is.null(name)) 
[08:24:56.490]                               next
[08:24:56.490]                             if (!grepl(pattern, name)) 
[08:24:56.490]                               next
[08:24:56.490]                             invokeRestart(restart)
[08:24:56.490]                             muffled <- TRUE
[08:24:56.490]                             break
[08:24:56.490]                           }
[08:24:56.490]                         }
[08:24:56.490]                       }
[08:24:56.490]                       invisible(muffled)
[08:24:56.490]                     }
[08:24:56.490]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.490]                   }
[08:24:56.490]                 }
[08:24:56.490]             }
[08:24:56.490]         }))
[08:24:56.490]     }, error = function(ex) {
[08:24:56.490]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.490]                 ...future.rng), started = ...future.startTime, 
[08:24:56.490]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.490]             version = "1.8"), class = "FutureResult")
[08:24:56.490]     }, finally = {
[08:24:56.490]         if (!identical(...future.workdir, getwd())) 
[08:24:56.490]             setwd(...future.workdir)
[08:24:56.490]         {
[08:24:56.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.490]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.490]             }
[08:24:56.490]             base::options(...future.oldOptions)
[08:24:56.490]             if (.Platform$OS.type == "windows") {
[08:24:56.490]                 old_names <- names(...future.oldEnvVars)
[08:24:56.490]                 envs <- base::Sys.getenv()
[08:24:56.490]                 names <- names(envs)
[08:24:56.490]                 common <- intersect(names, old_names)
[08:24:56.490]                 added <- setdiff(names, old_names)
[08:24:56.490]                 removed <- setdiff(old_names, names)
[08:24:56.490]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.490]                   envs[common]]
[08:24:56.490]                 NAMES <- toupper(changed)
[08:24:56.490]                 args <- list()
[08:24:56.490]                 for (kk in seq_along(NAMES)) {
[08:24:56.490]                   name <- changed[[kk]]
[08:24:56.490]                   NAME <- NAMES[[kk]]
[08:24:56.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.490]                     next
[08:24:56.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.490]                 }
[08:24:56.490]                 NAMES <- toupper(added)
[08:24:56.490]                 for (kk in seq_along(NAMES)) {
[08:24:56.490]                   name <- added[[kk]]
[08:24:56.490]                   NAME <- NAMES[[kk]]
[08:24:56.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.490]                     next
[08:24:56.490]                   args[[name]] <- ""
[08:24:56.490]                 }
[08:24:56.490]                 NAMES <- toupper(removed)
[08:24:56.490]                 for (kk in seq_along(NAMES)) {
[08:24:56.490]                   name <- removed[[kk]]
[08:24:56.490]                   NAME <- NAMES[[kk]]
[08:24:56.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.490]                     next
[08:24:56.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.490]                 }
[08:24:56.490]                 if (length(args) > 0) 
[08:24:56.490]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.490]             }
[08:24:56.490]             else {
[08:24:56.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.490]             }
[08:24:56.490]             {
[08:24:56.490]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.490]                   0L) {
[08:24:56.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.490]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.490]                   base::options(opts)
[08:24:56.490]                 }
[08:24:56.490]                 {
[08:24:56.490]                   {
[08:24:56.490]                     NULL
[08:24:56.490]                     RNGkind("Mersenne-Twister")
[08:24:56.490]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.490]                       inherits = FALSE)
[08:24:56.490]                   }
[08:24:56.490]                   options(future.plan = NULL)
[08:24:56.490]                   if (is.na(NA_character_)) 
[08:24:56.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.490]                     .init = FALSE)
[08:24:56.490]                 }
[08:24:56.490]             }
[08:24:56.490]         }
[08:24:56.490]     })
[08:24:56.490]     if (TRUE) {
[08:24:56.490]         base::sink(type = "output", split = FALSE)
[08:24:56.490]         if (TRUE) {
[08:24:56.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.490]         }
[08:24:56.490]         else {
[08:24:56.490]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.490]         }
[08:24:56.490]         base::close(...future.stdout)
[08:24:56.490]         ...future.stdout <- NULL
[08:24:56.490]     }
[08:24:56.490]     ...future.result$conditions <- ...future.conditions
[08:24:56.490]     ...future.result$finished <- base::Sys.time()
[08:24:56.490]     ...future.result
[08:24:56.490] }
[08:24:56.491] assign_globals() ...
[08:24:56.492] List of 5
[08:24:56.492]  $ ...future.FUN            :function (object, ...)  
[08:24:56.492]  $ future.call.arguments    : list()
[08:24:56.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.492]  $ ...future.elements_ii    :List of 3
[08:24:56.492]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.492]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.492]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.492]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.492]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.492]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.492]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.492]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:56.492]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.492]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.492]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.492]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:56.492]  $ ...future.seeds_ii       : NULL
[08:24:56.492]  $ ...future.globals.maxSize: NULL
[08:24:56.492]  - attr(*, "where")=List of 5
[08:24:56.492]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.492]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.492]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.492]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.492]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.492]  - attr(*, "resolved")= logi FALSE
[08:24:56.492]  - attr(*, "total_size")= num 18709
[08:24:56.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.492]  - attr(*, "already-done")= logi TRUE
[08:24:56.500] - copied ‘...future.FUN’ to environment
[08:24:56.500] - copied ‘future.call.arguments’ to environment
[08:24:56.500] - copied ‘...future.elements_ii’ to environment
[08:24:56.500] - copied ‘...future.seeds_ii’ to environment
[08:24:56.500] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.500] assign_globals() ... done
[08:24:56.501] plan(): Setting new future strategy stack:
[08:24:56.501] List of future strategies:
[08:24:56.501] 1. sequential:
[08:24:56.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.501]    - tweaked: FALSE
[08:24:56.501]    - call: NULL
[08:24:56.501] plan(): nbrOfWorkers() = 1
[08:24:56.503] plan(): Setting new future strategy stack:
[08:24:56.504] List of future strategies:
[08:24:56.504] 1. sequential:
[08:24:56.504]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.504]    - tweaked: FALSE
[08:24:56.504]    - call: plan(strategy)
[08:24:56.504] plan(): nbrOfWorkers() = 1
[08:24:56.504] SequentialFuture started (and completed)
[08:24:56.504] - Launch lazy future ... done
[08:24:56.504] run() for ‘SequentialFuture’ ... done
[08:24:56.504] Created future:
[08:24:56.505] SequentialFuture:
[08:24:56.505] Label: ‘future_by-1’
[08:24:56.505] Expression:
[08:24:56.505] {
[08:24:56.505]     do.call(function(...) {
[08:24:56.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.505]             on.exit(options(oopts), add = TRUE)
[08:24:56.505]         }
[08:24:56.505]         {
[08:24:56.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.505]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.505]             })
[08:24:56.505]         }
[08:24:56.505]     }, args = future.call.arguments)
[08:24:56.505] }
[08:24:56.505] Lazy evaluation: FALSE
[08:24:56.505] Asynchronous evaluation: FALSE
[08:24:56.505] Local evaluation: TRUE
[08:24:56.505] Environment: 0x557b25d5b1d0
[08:24:56.505] Capture standard output: TRUE
[08:24:56.505] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.505] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.505] Packages: <none>
[08:24:56.505] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.505] Resolved: TRUE
[08:24:56.505] Value: 1.39 KiB of class ‘list’
[08:24:56.505] Early signaling: FALSE
[08:24:56.505] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.505] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.506] Chunk #1 of 1 ... DONE
[08:24:56.506] Launching 1 futures (chunks) ... DONE
[08:24:56.506] Resolving 1 futures (chunks) ...
[08:24:56.506] resolve() on list ...
[08:24:56.506]  recursive: 0
[08:24:56.506]  length: 1
[08:24:56.506] 
[08:24:56.506] resolved() for ‘SequentialFuture’ ...
[08:24:56.506] - state: ‘finished’
[08:24:56.506] - run: TRUE
[08:24:56.506] - result: ‘FutureResult’
[08:24:56.507] resolved() for ‘SequentialFuture’ ... done
[08:24:56.507] Future #1
[08:24:56.507] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.507] - nx: 1
[08:24:56.507] - relay: TRUE
[08:24:56.507] - stdout: TRUE
[08:24:56.507] - signal: TRUE
[08:24:56.507] - resignal: FALSE
[08:24:56.507] - force: TRUE
[08:24:56.507] - relayed: [n=1] FALSE
[08:24:56.507] - queued futures: [n=1] FALSE
[08:24:56.507]  - until=1
[08:24:56.508]  - relaying element #1
[08:24:56.508] - relayed: [n=1] TRUE
[08:24:56.508] - queued futures: [n=1] TRUE
[08:24:56.508] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.508]  length: 0 (resolved future 1)
[08:24:56.508] Relaying remaining futures
[08:24:56.508] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.510] - nx: 1
[08:24:56.510] - relay: TRUE
[08:24:56.510] - stdout: TRUE
[08:24:56.510] - signal: TRUE
[08:24:56.510] - resignal: FALSE
[08:24:56.510] - force: TRUE
[08:24:56.511] - relayed: [n=1] TRUE
[08:24:56.511] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.511] - relayed: [n=1] TRUE
[08:24:56.511] - queued futures: [n=1] TRUE
[08:24:56.511] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.511] resolve() on list ... DONE
[08:24:56.511]  - Number of value chunks collected: 1
[08:24:56.511] Resolving 1 futures (chunks) ... DONE
[08:24:56.511] Reducing values from 1 chunks ...
[08:24:56.511]  - Number of values collected after concatenation: 3
[08:24:56.512]  - Number of values expected: 3
[08:24:56.512] Reducing values from 1 chunks ... DONE
[08:24:56.512] future_lapply() ... DONE
[08:24:56.512] future_by_internal() ... DONE
[08:24:56.514] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[08:24:56.514] future_lapply() ...
[08:24:56.515] Number of chunks: 1
[08:24:56.515] getGlobalsAndPackagesXApply() ...
[08:24:56.515]  - future.globals: TRUE
[08:24:56.515] getGlobalsAndPackages() ...
[08:24:56.515] Searching for globals...
[08:24:56.516] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.517] Searching for globals ... DONE
[08:24:56.517] Resolving globals: FALSE
[08:24:56.517] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.517] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.517] - globals: [1] ‘FUN’
[08:24:56.518] 
[08:24:56.518] getGlobalsAndPackages() ... DONE
[08:24:56.518]  - globals found/used: [n=1] ‘FUN’
[08:24:56.518]  - needed namespaces: [n=0] 
[08:24:56.518] Finding globals ... DONE
[08:24:56.518]  - use_args: TRUE
[08:24:56.518]  - Getting '...' globals ...
[08:24:56.518] resolve() on list ...
[08:24:56.518]  recursive: 0
[08:24:56.519]  length: 1
[08:24:56.519]  elements: ‘...’
[08:24:56.519]  length: 0 (resolved future 1)
[08:24:56.519] resolve() on list ... DONE
[08:24:56.519]    - '...' content: [n=0] 
[08:24:56.519] List of 1
[08:24:56.519]  $ ...: list()
[08:24:56.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.519]  - attr(*, "where")=List of 1
[08:24:56.519]   ..$ ...:<environment: 0x557b25d3cb58> 
[08:24:56.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.519]  - attr(*, "resolved")= logi TRUE
[08:24:56.519]  - attr(*, "total_size")= num NA
[08:24:56.521]  - Getting '...' globals ... DONE
[08:24:56.522] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.522] List of 2
[08:24:56.522]  $ ...future.FUN:function (object, ...)  
[08:24:56.522]  $ ...          : list()
[08:24:56.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.522]  - attr(*, "where")=List of 2
[08:24:56.522]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.522]   ..$ ...          :<environment: 0x557b25d3cb58> 
[08:24:56.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.522]  - attr(*, "resolved")= logi FALSE
[08:24:56.522]  - attr(*, "total_size")= num 18647
[08:24:56.524] Packages to be attached in all futures: [n=0] 
[08:24:56.525] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.525] Number of futures (= number of chunks): 1
[08:24:56.525] Launching 1 futures (chunks) ...
[08:24:56.525] Chunk #1 of 1 ...
[08:24:56.525]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.525] getGlobalsAndPackages() ...
[08:24:56.525] Searching for globals...
[08:24:56.526] 
[08:24:56.526] Searching for globals ... DONE
[08:24:56.526] - globals: [0] <none>
[08:24:56.526] getGlobalsAndPackages() ... DONE
[08:24:56.526]    + additional globals found: [n=0] 
[08:24:56.526]    + additional namespaces needed: [n=0] 
[08:24:56.526]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.526]  - seeds: <none>
[08:24:56.526]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.527] getGlobalsAndPackages() ...
[08:24:56.527] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.527] Resolving globals: FALSE
[08:24:56.527] Tweak future expression to call with '...' arguments ...
[08:24:56.527] {
[08:24:56.527]     do.call(function(...) {
[08:24:56.527]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.527]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.527]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.527]             on.exit(options(oopts), add = TRUE)
[08:24:56.527]         }
[08:24:56.527]         {
[08:24:56.527]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.527]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.527]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.527]             })
[08:24:56.527]         }
[08:24:56.527]     }, args = future.call.arguments)
[08:24:56.527] }
[08:24:56.527] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.528] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.528] 
[08:24:56.528] getGlobalsAndPackages() ... DONE
[08:24:56.528] run() for ‘Future’ ...
[08:24:56.528] - state: ‘created’
[08:24:56.528] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:56.529] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.529] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.529]   - Field: ‘label’
[08:24:56.529]   - Field: ‘local’
[08:24:56.529]   - Field: ‘owner’
[08:24:56.529]   - Field: ‘envir’
[08:24:56.529]   - Field: ‘packages’
[08:24:56.529]   - Field: ‘gc’
[08:24:56.531]   - Field: ‘conditions’
[08:24:56.531]   - Field: ‘expr’
[08:24:56.531]   - Field: ‘uuid’
[08:24:56.531]   - Field: ‘seed’
[08:24:56.532]   - Field: ‘version’
[08:24:56.532]   - Field: ‘result’
[08:24:56.532]   - Field: ‘asynchronous’
[08:24:56.532]   - Field: ‘calls’
[08:24:56.532]   - Field: ‘globals’
[08:24:56.532]   - Field: ‘stdout’
[08:24:56.532]   - Field: ‘earlySignal’
[08:24:56.532]   - Field: ‘lazy’
[08:24:56.532]   - Field: ‘state’
[08:24:56.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.532] - Launch lazy future ...
[08:24:56.533] Packages needed by the future expression (n = 0): <none>
[08:24:56.533] Packages needed by future strategies (n = 0): <none>
[08:24:56.533] {
[08:24:56.533]     {
[08:24:56.533]         {
[08:24:56.533]             ...future.startTime <- base::Sys.time()
[08:24:56.533]             {
[08:24:56.533]                 {
[08:24:56.533]                   {
[08:24:56.533]                     base::local({
[08:24:56.533]                       has_future <- base::requireNamespace("future", 
[08:24:56.533]                         quietly = TRUE)
[08:24:56.533]                       if (has_future) {
[08:24:56.533]                         ns <- base::getNamespace("future")
[08:24:56.533]                         version <- ns[[".package"]][["version"]]
[08:24:56.533]                         if (is.null(version)) 
[08:24:56.533]                           version <- utils::packageVersion("future")
[08:24:56.533]                       }
[08:24:56.533]                       else {
[08:24:56.533]                         version <- NULL
[08:24:56.533]                       }
[08:24:56.533]                       if (!has_future || version < "1.8.0") {
[08:24:56.533]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.533]                           "", base::R.version$version.string), 
[08:24:56.533]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.533]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.533]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.533]                             "release", "version")], collapse = " "), 
[08:24:56.533]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.533]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.533]                           info)
[08:24:56.533]                         info <- base::paste(info, collapse = "; ")
[08:24:56.533]                         if (!has_future) {
[08:24:56.533]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.533]                             info)
[08:24:56.533]                         }
[08:24:56.533]                         else {
[08:24:56.533]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.533]                             info, version)
[08:24:56.533]                         }
[08:24:56.533]                         base::stop(msg)
[08:24:56.533]                       }
[08:24:56.533]                     })
[08:24:56.533]                   }
[08:24:56.533]                   ...future.strategy.old <- future::plan("list")
[08:24:56.533]                   options(future.plan = NULL)
[08:24:56.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.533]                 }
[08:24:56.533]                 ...future.workdir <- getwd()
[08:24:56.533]             }
[08:24:56.533]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.533]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.533]         }
[08:24:56.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.533]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.533]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.533]             base::names(...future.oldOptions))
[08:24:56.533]     }
[08:24:56.533]     if (FALSE) {
[08:24:56.533]     }
[08:24:56.533]     else {
[08:24:56.533]         if (TRUE) {
[08:24:56.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.533]                 open = "w")
[08:24:56.533]         }
[08:24:56.533]         else {
[08:24:56.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.533]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.533]         }
[08:24:56.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.533]             base::sink(type = "output", split = FALSE)
[08:24:56.533]             base::close(...future.stdout)
[08:24:56.533]         }, add = TRUE)
[08:24:56.533]     }
[08:24:56.533]     ...future.frame <- base::sys.nframe()
[08:24:56.533]     ...future.conditions <- base::list()
[08:24:56.533]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.533]     if (FALSE) {
[08:24:56.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.533]     }
[08:24:56.533]     ...future.result <- base::tryCatch({
[08:24:56.533]         base::withCallingHandlers({
[08:24:56.533]             ...future.value <- base::withVisible(base::local({
[08:24:56.533]                 do.call(function(...) {
[08:24:56.533]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.533]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.533]                     ...future.globals.maxSize)) {
[08:24:56.533]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.533]                     on.exit(options(oopts), add = TRUE)
[08:24:56.533]                   }
[08:24:56.533]                   {
[08:24:56.533]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.533]                       FUN = function(jj) {
[08:24:56.533]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.533]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.533]                       })
[08:24:56.533]                   }
[08:24:56.533]                 }, args = future.call.arguments)
[08:24:56.533]             }))
[08:24:56.533]             future::FutureResult(value = ...future.value$value, 
[08:24:56.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.533]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.533]                     ...future.globalenv.names))
[08:24:56.533]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.533]         }, condition = base::local({
[08:24:56.533]             c <- base::c
[08:24:56.533]             inherits <- base::inherits
[08:24:56.533]             invokeRestart <- base::invokeRestart
[08:24:56.533]             length <- base::length
[08:24:56.533]             list <- base::list
[08:24:56.533]             seq.int <- base::seq.int
[08:24:56.533]             signalCondition <- base::signalCondition
[08:24:56.533]             sys.calls <- base::sys.calls
[08:24:56.533]             `[[` <- base::`[[`
[08:24:56.533]             `+` <- base::`+`
[08:24:56.533]             `<<-` <- base::`<<-`
[08:24:56.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.533]                   3L)]
[08:24:56.533]             }
[08:24:56.533]             function(cond) {
[08:24:56.533]                 is_error <- inherits(cond, "error")
[08:24:56.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.533]                   NULL)
[08:24:56.533]                 if (is_error) {
[08:24:56.533]                   sessionInformation <- function() {
[08:24:56.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.533]                       search = base::search(), system = base::Sys.info())
[08:24:56.533]                   }
[08:24:56.533]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.533]                     cond$call), session = sessionInformation(), 
[08:24:56.533]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.533]                   signalCondition(cond)
[08:24:56.533]                 }
[08:24:56.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.533]                 "immediateCondition"))) {
[08:24:56.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.533]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.533]                   if (TRUE && !signal) {
[08:24:56.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.533]                     {
[08:24:56.533]                       inherits <- base::inherits
[08:24:56.533]                       invokeRestart <- base::invokeRestart
[08:24:56.533]                       is.null <- base::is.null
[08:24:56.533]                       muffled <- FALSE
[08:24:56.533]                       if (inherits(cond, "message")) {
[08:24:56.533]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.533]                         if (muffled) 
[08:24:56.533]                           invokeRestart("muffleMessage")
[08:24:56.533]                       }
[08:24:56.533]                       else if (inherits(cond, "warning")) {
[08:24:56.533]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.533]                         if (muffled) 
[08:24:56.533]                           invokeRestart("muffleWarning")
[08:24:56.533]                       }
[08:24:56.533]                       else if (inherits(cond, "condition")) {
[08:24:56.533]                         if (!is.null(pattern)) {
[08:24:56.533]                           computeRestarts <- base::computeRestarts
[08:24:56.533]                           grepl <- base::grepl
[08:24:56.533]                           restarts <- computeRestarts(cond)
[08:24:56.533]                           for (restart in restarts) {
[08:24:56.533]                             name <- restart$name
[08:24:56.533]                             if (is.null(name)) 
[08:24:56.533]                               next
[08:24:56.533]                             if (!grepl(pattern, name)) 
[08:24:56.533]                               next
[08:24:56.533]                             invokeRestart(restart)
[08:24:56.533]                             muffled <- TRUE
[08:24:56.533]                             break
[08:24:56.533]                           }
[08:24:56.533]                         }
[08:24:56.533]                       }
[08:24:56.533]                       invisible(muffled)
[08:24:56.533]                     }
[08:24:56.533]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.533]                   }
[08:24:56.533]                 }
[08:24:56.533]                 else {
[08:24:56.533]                   if (TRUE) {
[08:24:56.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.533]                     {
[08:24:56.533]                       inherits <- base::inherits
[08:24:56.533]                       invokeRestart <- base::invokeRestart
[08:24:56.533]                       is.null <- base::is.null
[08:24:56.533]                       muffled <- FALSE
[08:24:56.533]                       if (inherits(cond, "message")) {
[08:24:56.533]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.533]                         if (muffled) 
[08:24:56.533]                           invokeRestart("muffleMessage")
[08:24:56.533]                       }
[08:24:56.533]                       else if (inherits(cond, "warning")) {
[08:24:56.533]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.533]                         if (muffled) 
[08:24:56.533]                           invokeRestart("muffleWarning")
[08:24:56.533]                       }
[08:24:56.533]                       else if (inherits(cond, "condition")) {
[08:24:56.533]                         if (!is.null(pattern)) {
[08:24:56.533]                           computeRestarts <- base::computeRestarts
[08:24:56.533]                           grepl <- base::grepl
[08:24:56.533]                           restarts <- computeRestarts(cond)
[08:24:56.533]                           for (restart in restarts) {
[08:24:56.533]                             name <- restart$name
[08:24:56.533]                             if (is.null(name)) 
[08:24:56.533]                               next
[08:24:56.533]                             if (!grepl(pattern, name)) 
[08:24:56.533]                               next
[08:24:56.533]                             invokeRestart(restart)
[08:24:56.533]                             muffled <- TRUE
[08:24:56.533]                             break
[08:24:56.533]                           }
[08:24:56.533]                         }
[08:24:56.533]                       }
[08:24:56.533]                       invisible(muffled)
[08:24:56.533]                     }
[08:24:56.533]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.533]                   }
[08:24:56.533]                 }
[08:24:56.533]             }
[08:24:56.533]         }))
[08:24:56.533]     }, error = function(ex) {
[08:24:56.533]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.533]                 ...future.rng), started = ...future.startTime, 
[08:24:56.533]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.533]             version = "1.8"), class = "FutureResult")
[08:24:56.533]     }, finally = {
[08:24:56.533]         if (!identical(...future.workdir, getwd())) 
[08:24:56.533]             setwd(...future.workdir)
[08:24:56.533]         {
[08:24:56.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.533]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.533]             }
[08:24:56.533]             base::options(...future.oldOptions)
[08:24:56.533]             if (.Platform$OS.type == "windows") {
[08:24:56.533]                 old_names <- names(...future.oldEnvVars)
[08:24:56.533]                 envs <- base::Sys.getenv()
[08:24:56.533]                 names <- names(envs)
[08:24:56.533]                 common <- intersect(names, old_names)
[08:24:56.533]                 added <- setdiff(names, old_names)
[08:24:56.533]                 removed <- setdiff(old_names, names)
[08:24:56.533]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.533]                   envs[common]]
[08:24:56.533]                 NAMES <- toupper(changed)
[08:24:56.533]                 args <- list()
[08:24:56.533]                 for (kk in seq_along(NAMES)) {
[08:24:56.533]                   name <- changed[[kk]]
[08:24:56.533]                   NAME <- NAMES[[kk]]
[08:24:56.533]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.533]                     next
[08:24:56.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.533]                 }
[08:24:56.533]                 NAMES <- toupper(added)
[08:24:56.533]                 for (kk in seq_along(NAMES)) {
[08:24:56.533]                   name <- added[[kk]]
[08:24:56.533]                   NAME <- NAMES[[kk]]
[08:24:56.533]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.533]                     next
[08:24:56.533]                   args[[name]] <- ""
[08:24:56.533]                 }
[08:24:56.533]                 NAMES <- toupper(removed)
[08:24:56.533]                 for (kk in seq_along(NAMES)) {
[08:24:56.533]                   name <- removed[[kk]]
[08:24:56.533]                   NAME <- NAMES[[kk]]
[08:24:56.533]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.533]                     next
[08:24:56.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.533]                 }
[08:24:56.533]                 if (length(args) > 0) 
[08:24:56.533]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.533]             }
[08:24:56.533]             else {
[08:24:56.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.533]             }
[08:24:56.533]             {
[08:24:56.533]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.533]                   0L) {
[08:24:56.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.533]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.533]                   base::options(opts)
[08:24:56.533]                 }
[08:24:56.533]                 {
[08:24:56.533]                   {
[08:24:56.533]                     NULL
[08:24:56.533]                     RNGkind("Mersenne-Twister")
[08:24:56.533]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.533]                       inherits = FALSE)
[08:24:56.533]                   }
[08:24:56.533]                   options(future.plan = NULL)
[08:24:56.533]                   if (is.na(NA_character_)) 
[08:24:56.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.533]                     .init = FALSE)
[08:24:56.533]                 }
[08:24:56.533]             }
[08:24:56.533]         }
[08:24:56.533]     })
[08:24:56.533]     if (TRUE) {
[08:24:56.533]         base::sink(type = "output", split = FALSE)
[08:24:56.533]         if (TRUE) {
[08:24:56.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.533]         }
[08:24:56.533]         else {
[08:24:56.533]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.533]         }
[08:24:56.533]         base::close(...future.stdout)
[08:24:56.533]         ...future.stdout <- NULL
[08:24:56.533]     }
[08:24:56.533]     ...future.result$conditions <- ...future.conditions
[08:24:56.533]     ...future.result$finished <- base::Sys.time()
[08:24:56.533]     ...future.result
[08:24:56.533] }
[08:24:56.535] assign_globals() ...
[08:24:56.535] List of 5
[08:24:56.535]  $ ...future.FUN            :function (object, ...)  
[08:24:56.535]  $ future.call.arguments    : list()
[08:24:56.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.535]  $ ...future.elements_ii    :List of 3
[08:24:56.535]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.535]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.535]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.535]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.535]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.535]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.535]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.535]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:56.535]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.535]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.535]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.535]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:56.535]  $ ...future.seeds_ii       : NULL
[08:24:56.535]  $ ...future.globals.maxSize: NULL
[08:24:56.535]  - attr(*, "where")=List of 5
[08:24:56.535]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.535]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.535]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.535]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.535]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.535]  - attr(*, "resolved")= logi FALSE
[08:24:56.535]  - attr(*, "total_size")= num 18647
[08:24:56.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.535]  - attr(*, "already-done")= logi TRUE
[08:24:56.544] - copied ‘...future.FUN’ to environment
[08:24:56.544] - copied ‘future.call.arguments’ to environment
[08:24:56.544] - copied ‘...future.elements_ii’ to environment
[08:24:56.544] - copied ‘...future.seeds_ii’ to environment
[08:24:56.544] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.544] assign_globals() ... done
[08:24:56.544] plan(): Setting new future strategy stack:
[08:24:56.545] List of future strategies:
[08:24:56.545] 1. sequential:
[08:24:56.545]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.545]    - tweaked: FALSE
[08:24:56.545]    - call: NULL
[08:24:56.545] plan(): nbrOfWorkers() = 1
[08:24:56.547] plan(): Setting new future strategy stack:
[08:24:56.547] List of future strategies:
[08:24:56.547] 1. sequential:
[08:24:56.547]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.547]    - tweaked: FALSE
[08:24:56.547]    - call: plan(strategy)
[08:24:56.548] plan(): nbrOfWorkers() = 1
[08:24:56.548] SequentialFuture started (and completed)
[08:24:56.548] - Launch lazy future ... done
[08:24:56.548] run() for ‘SequentialFuture’ ... done
[08:24:56.548] Created future:
[08:24:56.548] SequentialFuture:
[08:24:56.548] Label: ‘future_by-1’
[08:24:56.548] Expression:
[08:24:56.548] {
[08:24:56.548]     do.call(function(...) {
[08:24:56.548]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.548]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.548]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.548]             on.exit(options(oopts), add = TRUE)
[08:24:56.548]         }
[08:24:56.548]         {
[08:24:56.548]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.548]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.548]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.548]             })
[08:24:56.548]         }
[08:24:56.548]     }, args = future.call.arguments)
[08:24:56.548] }
[08:24:56.548] Lazy evaluation: FALSE
[08:24:56.548] Asynchronous evaluation: FALSE
[08:24:56.548] Local evaluation: TRUE
[08:24:56.548] Environment: 0x557b2663e2c0
[08:24:56.548] Capture standard output: TRUE
[08:24:56.548] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.548] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.548] Packages: <none>
[08:24:56.548] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.548] Resolved: TRUE
[08:24:56.548] Value: 1.39 KiB of class ‘list’
[08:24:56.548] Early signaling: FALSE
[08:24:56.548] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.548] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.549] Chunk #1 of 1 ... DONE
[08:24:56.550] Launching 1 futures (chunks) ... DONE
[08:24:56.550] Resolving 1 futures (chunks) ...
[08:24:56.550] resolve() on list ...
[08:24:56.550]  recursive: 0
[08:24:56.550]  length: 1
[08:24:56.550] 
[08:24:56.550] resolved() for ‘SequentialFuture’ ...
[08:24:56.550] - state: ‘finished’
[08:24:56.550] - run: TRUE
[08:24:56.550] - result: ‘FutureResult’
[08:24:56.550] resolved() for ‘SequentialFuture’ ... done
[08:24:56.551] Future #1
[08:24:56.551] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.551] - nx: 1
[08:24:56.551] - relay: TRUE
[08:24:56.551] - stdout: TRUE
[08:24:56.551] - signal: TRUE
[08:24:56.551] - resignal: FALSE
[08:24:56.551] - force: TRUE
[08:24:56.551] - relayed: [n=1] FALSE
[08:24:56.551] - queued futures: [n=1] FALSE
[08:24:56.551]  - until=1
[08:24:56.552]  - relaying element #1
[08:24:56.552] - relayed: [n=1] TRUE
[08:24:56.552] - queued futures: [n=1] TRUE
[08:24:56.552] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.552]  length: 0 (resolved future 1)
[08:24:56.554] Relaying remaining futures
[08:24:56.554] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.554] - nx: 1
[08:24:56.554] - relay: TRUE
[08:24:56.554] - stdout: TRUE
[08:24:56.554] - signal: TRUE
[08:24:56.554] - resignal: FALSE
[08:24:56.555] - force: TRUE
[08:24:56.555] - relayed: [n=1] TRUE
[08:24:56.555] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.555] - relayed: [n=1] TRUE
[08:24:56.555] - queued futures: [n=1] TRUE
[08:24:56.555] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.555] resolve() on list ... DONE
[08:24:56.555]  - Number of value chunks collected: 1
[08:24:56.555] Resolving 1 futures (chunks) ... DONE
[08:24:56.555] Reducing values from 1 chunks ...
[08:24:56.556]  - Number of values collected after concatenation: 3
[08:24:56.556]  - Number of values expected: 3
[08:24:56.556] Reducing values from 1 chunks ... DONE
[08:24:56.556] future_lapply() ... DONE
[08:24:56.556] future_by_internal() ... DONE
[08:24:56.557] future_by_internal() ...
- plan('multicore') ...
[08:24:56.557] plan(): Setting new future strategy stack:
[08:24:56.558] List of future strategies:
[08:24:56.558] 1. multicore:
[08:24:56.558]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:56.558]    - tweaked: FALSE
[08:24:56.558]    - call: plan(strategy)
[08:24:56.559] plan(): nbrOfWorkers() = 1
[08:24:56.560] future_by_internal() ...
[08:24:56.560] future_lapply() ...
[08:24:56.562] Number of chunks: 1
[08:24:56.562] getGlobalsAndPackagesXApply() ...
[08:24:56.562]  - future.globals: TRUE
[08:24:56.562] getGlobalsAndPackages() ...
[08:24:56.562] Searching for globals...
[08:24:56.563] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.563] Searching for globals ... DONE
[08:24:56.563] Resolving globals: FALSE
[08:24:56.564] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.564] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.564] - globals: [1] ‘FUN’
[08:24:56.564] 
[08:24:56.564] getGlobalsAndPackages() ... DONE
[08:24:56.564]  - globals found/used: [n=1] ‘FUN’
[08:24:56.565]  - needed namespaces: [n=0] 
[08:24:56.565] Finding globals ... DONE
[08:24:56.565]  - use_args: TRUE
[08:24:56.565]  - Getting '...' globals ...
[08:24:56.565] resolve() on list ...
[08:24:56.565]  recursive: 0
[08:24:56.565]  length: 1
[08:24:56.565]  elements: ‘...’
[08:24:56.565]  length: 0 (resolved future 1)
[08:24:56.566] resolve() on list ... DONE
[08:24:56.566]    - '...' content: [n=0] 
[08:24:56.566] List of 1
[08:24:56.566]  $ ...: list()
[08:24:56.566]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.566]  - attr(*, "where")=List of 1
[08:24:56.566]   ..$ ...:<environment: 0x557b25c5a460> 
[08:24:56.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.566]  - attr(*, "resolved")= logi TRUE
[08:24:56.566]  - attr(*, "total_size")= num NA
[08:24:56.568]  - Getting '...' globals ... DONE
[08:24:56.568] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.568] List of 2
[08:24:56.568]  $ ...future.FUN:function (object, ...)  
[08:24:56.568]  $ ...          : list()
[08:24:56.568]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.568]  - attr(*, "where")=List of 2
[08:24:56.568]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.568]   ..$ ...          :<environment: 0x557b25c5a460> 
[08:24:56.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.568]  - attr(*, "resolved")= logi FALSE
[08:24:56.568]  - attr(*, "total_size")= num 15670
[08:24:56.571] Packages to be attached in all futures: [n=0] 
[08:24:56.571] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.571] Number of futures (= number of chunks): 1
[08:24:56.571] Launching 1 futures (chunks) ...
[08:24:56.572] Chunk #1 of 1 ...
[08:24:56.572]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.572] getGlobalsAndPackages() ...
[08:24:56.572] Searching for globals...
[08:24:56.572] 
[08:24:56.572] Searching for globals ... DONE
[08:24:56.573] - globals: [0] <none>
[08:24:56.573] getGlobalsAndPackages() ... DONE
[08:24:56.573]    + additional globals found: [n=0] 
[08:24:56.573]    + additional namespaces needed: [n=0] 
[08:24:56.573]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.573]  - seeds: <none>
[08:24:56.573]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.573] getGlobalsAndPackages() ...
[08:24:56.573] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.573] Resolving globals: FALSE
[08:24:56.573] Tweak future expression to call with '...' arguments ...
[08:24:56.574] {
[08:24:56.574]     do.call(function(...) {
[08:24:56.574]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.574]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.574]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.574]             on.exit(options(oopts), add = TRUE)
[08:24:56.574]         }
[08:24:56.574]         {
[08:24:56.574]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.574]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.574]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.574]             })
[08:24:56.574]         }
[08:24:56.574]     }, args = future.call.arguments)
[08:24:56.574] }
[08:24:56.574] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.574] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.576] 
[08:24:56.576] getGlobalsAndPackages() ... DONE
[08:24:56.576] run() for ‘Future’ ...
[08:24:56.577] - state: ‘created’
[08:24:56.577] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:56.578] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.579]   - Field: ‘label’
[08:24:56.579]   - Field: ‘local’
[08:24:56.579]   - Field: ‘owner’
[08:24:56.579]   - Field: ‘envir’
[08:24:56.579]   - Field: ‘packages’
[08:24:56.579]   - Field: ‘gc’
[08:24:56.579]   - Field: ‘conditions’
[08:24:56.579]   - Field: ‘expr’
[08:24:56.579]   - Field: ‘uuid’
[08:24:56.579]   - Field: ‘seed’
[08:24:56.579]   - Field: ‘version’
[08:24:56.580]   - Field: ‘result’
[08:24:56.580]   - Field: ‘asynchronous’
[08:24:56.580]   - Field: ‘calls’
[08:24:56.580]   - Field: ‘globals’
[08:24:56.580]   - Field: ‘stdout’
[08:24:56.580]   - Field: ‘earlySignal’
[08:24:56.580]   - Field: ‘lazy’
[08:24:56.580]   - Field: ‘state’
[08:24:56.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.580] - Launch lazy future ...
[08:24:56.581] Packages needed by the future expression (n = 0): <none>
[08:24:56.581] Packages needed by future strategies (n = 0): <none>
[08:24:56.581] {
[08:24:56.581]     {
[08:24:56.581]         {
[08:24:56.581]             ...future.startTime <- base::Sys.time()
[08:24:56.581]             {
[08:24:56.581]                 {
[08:24:56.581]                   {
[08:24:56.581]                     base::local({
[08:24:56.581]                       has_future <- base::requireNamespace("future", 
[08:24:56.581]                         quietly = TRUE)
[08:24:56.581]                       if (has_future) {
[08:24:56.581]                         ns <- base::getNamespace("future")
[08:24:56.581]                         version <- ns[[".package"]][["version"]]
[08:24:56.581]                         if (is.null(version)) 
[08:24:56.581]                           version <- utils::packageVersion("future")
[08:24:56.581]                       }
[08:24:56.581]                       else {
[08:24:56.581]                         version <- NULL
[08:24:56.581]                       }
[08:24:56.581]                       if (!has_future || version < "1.8.0") {
[08:24:56.581]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.581]                           "", base::R.version$version.string), 
[08:24:56.581]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.581]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.581]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.581]                             "release", "version")], collapse = " "), 
[08:24:56.581]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.581]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.581]                           info)
[08:24:56.581]                         info <- base::paste(info, collapse = "; ")
[08:24:56.581]                         if (!has_future) {
[08:24:56.581]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.581]                             info)
[08:24:56.581]                         }
[08:24:56.581]                         else {
[08:24:56.581]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.581]                             info, version)
[08:24:56.581]                         }
[08:24:56.581]                         base::stop(msg)
[08:24:56.581]                       }
[08:24:56.581]                     })
[08:24:56.581]                   }
[08:24:56.581]                   ...future.strategy.old <- future::plan("list")
[08:24:56.581]                   options(future.plan = NULL)
[08:24:56.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.581]                 }
[08:24:56.581]                 ...future.workdir <- getwd()
[08:24:56.581]             }
[08:24:56.581]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.581]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.581]         }
[08:24:56.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.581]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.581]             base::names(...future.oldOptions))
[08:24:56.581]     }
[08:24:56.581]     if (FALSE) {
[08:24:56.581]     }
[08:24:56.581]     else {
[08:24:56.581]         if (TRUE) {
[08:24:56.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.581]                 open = "w")
[08:24:56.581]         }
[08:24:56.581]         else {
[08:24:56.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.581]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.581]         }
[08:24:56.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.581]             base::sink(type = "output", split = FALSE)
[08:24:56.581]             base::close(...future.stdout)
[08:24:56.581]         }, add = TRUE)
[08:24:56.581]     }
[08:24:56.581]     ...future.frame <- base::sys.nframe()
[08:24:56.581]     ...future.conditions <- base::list()
[08:24:56.581]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.581]     if (FALSE) {
[08:24:56.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.581]     }
[08:24:56.581]     ...future.result <- base::tryCatch({
[08:24:56.581]         base::withCallingHandlers({
[08:24:56.581]             ...future.value <- base::withVisible(base::local({
[08:24:56.581]                 do.call(function(...) {
[08:24:56.581]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.581]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.581]                     ...future.globals.maxSize)) {
[08:24:56.581]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.581]                     on.exit(options(oopts), add = TRUE)
[08:24:56.581]                   }
[08:24:56.581]                   {
[08:24:56.581]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.581]                       FUN = function(jj) {
[08:24:56.581]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.581]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.581]                       })
[08:24:56.581]                   }
[08:24:56.581]                 }, args = future.call.arguments)
[08:24:56.581]             }))
[08:24:56.581]             future::FutureResult(value = ...future.value$value, 
[08:24:56.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.581]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.581]                     ...future.globalenv.names))
[08:24:56.581]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.581]         }, condition = base::local({
[08:24:56.581]             c <- base::c
[08:24:56.581]             inherits <- base::inherits
[08:24:56.581]             invokeRestart <- base::invokeRestart
[08:24:56.581]             length <- base::length
[08:24:56.581]             list <- base::list
[08:24:56.581]             seq.int <- base::seq.int
[08:24:56.581]             signalCondition <- base::signalCondition
[08:24:56.581]             sys.calls <- base::sys.calls
[08:24:56.581]             `[[` <- base::`[[`
[08:24:56.581]             `+` <- base::`+`
[08:24:56.581]             `<<-` <- base::`<<-`
[08:24:56.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.581]                   3L)]
[08:24:56.581]             }
[08:24:56.581]             function(cond) {
[08:24:56.581]                 is_error <- inherits(cond, "error")
[08:24:56.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.581]                   NULL)
[08:24:56.581]                 if (is_error) {
[08:24:56.581]                   sessionInformation <- function() {
[08:24:56.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.581]                       search = base::search(), system = base::Sys.info())
[08:24:56.581]                   }
[08:24:56.581]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.581]                     cond$call), session = sessionInformation(), 
[08:24:56.581]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.581]                   signalCondition(cond)
[08:24:56.581]                 }
[08:24:56.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.581]                 "immediateCondition"))) {
[08:24:56.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.581]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.581]                   if (TRUE && !signal) {
[08:24:56.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.581]                     {
[08:24:56.581]                       inherits <- base::inherits
[08:24:56.581]                       invokeRestart <- base::invokeRestart
[08:24:56.581]                       is.null <- base::is.null
[08:24:56.581]                       muffled <- FALSE
[08:24:56.581]                       if (inherits(cond, "message")) {
[08:24:56.581]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.581]                         if (muffled) 
[08:24:56.581]                           invokeRestart("muffleMessage")
[08:24:56.581]                       }
[08:24:56.581]                       else if (inherits(cond, "warning")) {
[08:24:56.581]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.581]                         if (muffled) 
[08:24:56.581]                           invokeRestart("muffleWarning")
[08:24:56.581]                       }
[08:24:56.581]                       else if (inherits(cond, "condition")) {
[08:24:56.581]                         if (!is.null(pattern)) {
[08:24:56.581]                           computeRestarts <- base::computeRestarts
[08:24:56.581]                           grepl <- base::grepl
[08:24:56.581]                           restarts <- computeRestarts(cond)
[08:24:56.581]                           for (restart in restarts) {
[08:24:56.581]                             name <- restart$name
[08:24:56.581]                             if (is.null(name)) 
[08:24:56.581]                               next
[08:24:56.581]                             if (!grepl(pattern, name)) 
[08:24:56.581]                               next
[08:24:56.581]                             invokeRestart(restart)
[08:24:56.581]                             muffled <- TRUE
[08:24:56.581]                             break
[08:24:56.581]                           }
[08:24:56.581]                         }
[08:24:56.581]                       }
[08:24:56.581]                       invisible(muffled)
[08:24:56.581]                     }
[08:24:56.581]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.581]                   }
[08:24:56.581]                 }
[08:24:56.581]                 else {
[08:24:56.581]                   if (TRUE) {
[08:24:56.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.581]                     {
[08:24:56.581]                       inherits <- base::inherits
[08:24:56.581]                       invokeRestart <- base::invokeRestart
[08:24:56.581]                       is.null <- base::is.null
[08:24:56.581]                       muffled <- FALSE
[08:24:56.581]                       if (inherits(cond, "message")) {
[08:24:56.581]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.581]                         if (muffled) 
[08:24:56.581]                           invokeRestart("muffleMessage")
[08:24:56.581]                       }
[08:24:56.581]                       else if (inherits(cond, "warning")) {
[08:24:56.581]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.581]                         if (muffled) 
[08:24:56.581]                           invokeRestart("muffleWarning")
[08:24:56.581]                       }
[08:24:56.581]                       else if (inherits(cond, "condition")) {
[08:24:56.581]                         if (!is.null(pattern)) {
[08:24:56.581]                           computeRestarts <- base::computeRestarts
[08:24:56.581]                           grepl <- base::grepl
[08:24:56.581]                           restarts <- computeRestarts(cond)
[08:24:56.581]                           for (restart in restarts) {
[08:24:56.581]                             name <- restart$name
[08:24:56.581]                             if (is.null(name)) 
[08:24:56.581]                               next
[08:24:56.581]                             if (!grepl(pattern, name)) 
[08:24:56.581]                               next
[08:24:56.581]                             invokeRestart(restart)
[08:24:56.581]                             muffled <- TRUE
[08:24:56.581]                             break
[08:24:56.581]                           }
[08:24:56.581]                         }
[08:24:56.581]                       }
[08:24:56.581]                       invisible(muffled)
[08:24:56.581]                     }
[08:24:56.581]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.581]                   }
[08:24:56.581]                 }
[08:24:56.581]             }
[08:24:56.581]         }))
[08:24:56.581]     }, error = function(ex) {
[08:24:56.581]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.581]                 ...future.rng), started = ...future.startTime, 
[08:24:56.581]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.581]             version = "1.8"), class = "FutureResult")
[08:24:56.581]     }, finally = {
[08:24:56.581]         if (!identical(...future.workdir, getwd())) 
[08:24:56.581]             setwd(...future.workdir)
[08:24:56.581]         {
[08:24:56.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.581]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.581]             }
[08:24:56.581]             base::options(...future.oldOptions)
[08:24:56.581]             if (.Platform$OS.type == "windows") {
[08:24:56.581]                 old_names <- names(...future.oldEnvVars)
[08:24:56.581]                 envs <- base::Sys.getenv()
[08:24:56.581]                 names <- names(envs)
[08:24:56.581]                 common <- intersect(names, old_names)
[08:24:56.581]                 added <- setdiff(names, old_names)
[08:24:56.581]                 removed <- setdiff(old_names, names)
[08:24:56.581]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.581]                   envs[common]]
[08:24:56.581]                 NAMES <- toupper(changed)
[08:24:56.581]                 args <- list()
[08:24:56.581]                 for (kk in seq_along(NAMES)) {
[08:24:56.581]                   name <- changed[[kk]]
[08:24:56.581]                   NAME <- NAMES[[kk]]
[08:24:56.581]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.581]                     next
[08:24:56.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.581]                 }
[08:24:56.581]                 NAMES <- toupper(added)
[08:24:56.581]                 for (kk in seq_along(NAMES)) {
[08:24:56.581]                   name <- added[[kk]]
[08:24:56.581]                   NAME <- NAMES[[kk]]
[08:24:56.581]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.581]                     next
[08:24:56.581]                   args[[name]] <- ""
[08:24:56.581]                 }
[08:24:56.581]                 NAMES <- toupper(removed)
[08:24:56.581]                 for (kk in seq_along(NAMES)) {
[08:24:56.581]                   name <- removed[[kk]]
[08:24:56.581]                   NAME <- NAMES[[kk]]
[08:24:56.581]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.581]                     next
[08:24:56.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.581]                 }
[08:24:56.581]                 if (length(args) > 0) 
[08:24:56.581]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.581]             }
[08:24:56.581]             else {
[08:24:56.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.581]             }
[08:24:56.581]             {
[08:24:56.581]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.581]                   0L) {
[08:24:56.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.581]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.581]                   base::options(opts)
[08:24:56.581]                 }
[08:24:56.581]                 {
[08:24:56.581]                   {
[08:24:56.581]                     NULL
[08:24:56.581]                     RNGkind("Mersenne-Twister")
[08:24:56.581]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.581]                       inherits = FALSE)
[08:24:56.581]                   }
[08:24:56.581]                   options(future.plan = NULL)
[08:24:56.581]                   if (is.na(NA_character_)) 
[08:24:56.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.581]                     .init = FALSE)
[08:24:56.581]                 }
[08:24:56.581]             }
[08:24:56.581]         }
[08:24:56.581]     })
[08:24:56.581]     if (TRUE) {
[08:24:56.581]         base::sink(type = "output", split = FALSE)
[08:24:56.581]         if (TRUE) {
[08:24:56.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.581]         }
[08:24:56.581]         else {
[08:24:56.581]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.581]         }
[08:24:56.581]         base::close(...future.stdout)
[08:24:56.581]         ...future.stdout <- NULL
[08:24:56.581]     }
[08:24:56.581]     ...future.result$conditions <- ...future.conditions
[08:24:56.581]     ...future.result$finished <- base::Sys.time()
[08:24:56.581]     ...future.result
[08:24:56.581] }
[08:24:56.583] assign_globals() ...
[08:24:56.583] List of 5
[08:24:56.583]  $ ...future.FUN            :function (object, ...)  
[08:24:56.583]  $ future.call.arguments    : list()
[08:24:56.583]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.583]  $ ...future.elements_ii    :List of 3
[08:24:56.583]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.583]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.583]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.583]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.583]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.583]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.583]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.583]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.583]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.583]  $ ...future.seeds_ii       : NULL
[08:24:56.583]  $ ...future.globals.maxSize: NULL
[08:24:56.583]  - attr(*, "where")=List of 5
[08:24:56.583]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.583]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.583]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.583]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.583]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.583]  - attr(*, "resolved")= logi FALSE
[08:24:56.583]  - attr(*, "total_size")= num 15670
[08:24:56.583]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.583]  - attr(*, "already-done")= logi TRUE
[08:24:56.590] - copied ‘...future.FUN’ to environment
[08:24:56.590] - copied ‘future.call.arguments’ to environment
[08:24:56.591] - copied ‘...future.elements_ii’ to environment
[08:24:56.591] - copied ‘...future.seeds_ii’ to environment
[08:24:56.591] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.591] assign_globals() ... done
[08:24:56.591] plan(): Setting new future strategy stack:
[08:24:56.591] List of future strategies:
[08:24:56.591] 1. sequential:
[08:24:56.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.591]    - tweaked: FALSE
[08:24:56.591]    - call: NULL
[08:24:56.592] plan(): nbrOfWorkers() = 1
[08:24:56.594] plan(): Setting new future strategy stack:
[08:24:56.594] List of future strategies:
[08:24:56.594] 1. multicore:
[08:24:56.594]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:56.594]    - tweaked: FALSE
[08:24:56.594]    - call: plan(strategy)
[08:24:56.595] plan(): nbrOfWorkers() = 1
[08:24:56.595] SequentialFuture started (and completed)
[08:24:56.596] - Launch lazy future ... done
[08:24:56.596] run() for ‘SequentialFuture’ ... done
[08:24:56.596] Created future:
[08:24:56.596] SequentialFuture:
[08:24:56.596] Label: ‘future_by-1’
[08:24:56.596] Expression:
[08:24:56.596] {
[08:24:56.596]     do.call(function(...) {
[08:24:56.596]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.596]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.596]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.596]             on.exit(options(oopts), add = TRUE)
[08:24:56.596]         }
[08:24:56.596]         {
[08:24:56.596]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.596]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.596]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.596]             })
[08:24:56.596]         }
[08:24:56.596]     }, args = future.call.arguments)
[08:24:56.596] }
[08:24:56.596] Lazy evaluation: FALSE
[08:24:56.596] Asynchronous evaluation: FALSE
[08:24:56.596] Local evaluation: TRUE
[08:24:56.596] Environment: R_GlobalEnv
[08:24:56.596] Capture standard output: TRUE
[08:24:56.596] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.596] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.596] Packages: <none>
[08:24:56.596] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.596] Resolved: TRUE
[08:24:56.596] Value: 1.16 KiB of class ‘list’
[08:24:56.596] Early signaling: FALSE
[08:24:56.596] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.596] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.597] Chunk #1 of 1 ... DONE
[08:24:56.597] Launching 1 futures (chunks) ... DONE
[08:24:56.597] Resolving 1 futures (chunks) ...
[08:24:56.597] resolve() on list ...
[08:24:56.597]  recursive: 0
[08:24:56.597]  length: 1
[08:24:56.597] 
[08:24:56.597] resolved() for ‘SequentialFuture’ ...
[08:24:56.597] - state: ‘finished’
[08:24:56.597] - run: TRUE
[08:24:56.599] - result: ‘FutureResult’
[08:24:56.599] resolved() for ‘SequentialFuture’ ... done
[08:24:56.600] Future #1
[08:24:56.600] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.600] - nx: 1
[08:24:56.600] - relay: TRUE
[08:24:56.600] - stdout: TRUE
[08:24:56.600] - signal: TRUE
[08:24:56.600] - resignal: FALSE
[08:24:56.600] - force: TRUE
[08:24:56.600] - relayed: [n=1] FALSE
[08:24:56.600] - queued futures: [n=1] FALSE
[08:24:56.600]  - until=1
[08:24:56.601]  - relaying element #1
[08:24:56.601] - relayed: [n=1] TRUE
[08:24:56.601] - queued futures: [n=1] TRUE
[08:24:56.601] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.601]  length: 0 (resolved future 1)
[08:24:56.601] Relaying remaining futures
[08:24:56.601] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.601] - nx: 1
[08:24:56.601] - relay: TRUE
[08:24:56.601] - stdout: TRUE
[08:24:56.601] - signal: TRUE
[08:24:56.602] - resignal: FALSE
[08:24:56.602] - force: TRUE
[08:24:56.602] - relayed: [n=1] TRUE
[08:24:56.602] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.602] - relayed: [n=1] TRUE
[08:24:56.602] - queued futures: [n=1] TRUE
[08:24:56.602] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.602] resolve() on list ... DONE
[08:24:56.602]  - Number of value chunks collected: 1
[08:24:56.602] Resolving 1 futures (chunks) ... DONE
[08:24:56.602] Reducing values from 1 chunks ...
[08:24:56.603]  - Number of values collected after concatenation: 3
[08:24:56.603]  - Number of values expected: 3
[08:24:56.603] Reducing values from 1 chunks ... DONE
[08:24:56.603] future_lapply() ... DONE
[08:24:56.603] future_by_internal() ... DONE
[08:24:56.603] future_by_internal() ...
[08:24:56.604] future_lapply() ...
[08:24:56.605] Number of chunks: 1
[08:24:56.605] getGlobalsAndPackagesXApply() ...
[08:24:56.605]  - future.globals: TRUE
[08:24:56.606] getGlobalsAndPackages() ...
[08:24:56.606] Searching for globals...
[08:24:56.607] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.607] Searching for globals ... DONE
[08:24:56.607] Resolving globals: FALSE
[08:24:56.607] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.608] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.608] - globals: [1] ‘FUN’
[08:24:56.608] 
[08:24:56.608] getGlobalsAndPackages() ... DONE
[08:24:56.608]  - globals found/used: [n=1] ‘FUN’
[08:24:56.608]  - needed namespaces: [n=0] 
[08:24:56.608] Finding globals ... DONE
[08:24:56.608]  - use_args: TRUE
[08:24:56.608]  - Getting '...' globals ...
[08:24:56.609] resolve() on list ...
[08:24:56.609]  recursive: 0
[08:24:56.609]  length: 1
[08:24:56.609]  elements: ‘...’
[08:24:56.609]  length: 0 (resolved future 1)
[08:24:56.609] resolve() on list ... DONE
[08:24:56.609]    - '...' content: [n=1] ‘digits’
[08:24:56.609] List of 1
[08:24:56.609]  $ ...:List of 1
[08:24:56.609]   ..$ digits: int 2
[08:24:56.609]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.609]  - attr(*, "where")=List of 1
[08:24:56.609]   ..$ ...:<environment: 0x557b25d71140> 
[08:24:56.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.609]  - attr(*, "resolved")= logi TRUE
[08:24:56.609]  - attr(*, "total_size")= num NA
[08:24:56.612]  - Getting '...' globals ... DONE
[08:24:56.612] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.612] List of 2
[08:24:56.612]  $ ...future.FUN:function (object, ...)  
[08:24:56.612]  $ ...          :List of 1
[08:24:56.612]   ..$ digits: int 2
[08:24:56.612]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.612]  - attr(*, "where")=List of 2
[08:24:56.612]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.612]   ..$ ...          :<environment: 0x557b25d71140> 
[08:24:56.612]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.612]  - attr(*, "resolved")= logi FALSE
[08:24:56.612]  - attr(*, "total_size")= num 13284
[08:24:56.615] Packages to be attached in all futures: [n=0] 
[08:24:56.615] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.616] Number of futures (= number of chunks): 1
[08:24:56.616] Launching 1 futures (chunks) ...
[08:24:56.616] Chunk #1 of 1 ...
[08:24:56.616]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.616] getGlobalsAndPackages() ...
[08:24:56.616] Searching for globals...
[08:24:56.616] 
[08:24:56.617] Searching for globals ... DONE
[08:24:56.617] - globals: [0] <none>
[08:24:56.617] getGlobalsAndPackages() ... DONE
[08:24:56.617]    + additional globals found: [n=0] 
[08:24:56.617]    + additional namespaces needed: [n=0] 
[08:24:56.617]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.617]  - seeds: <none>
[08:24:56.617]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.617] getGlobalsAndPackages() ...
[08:24:56.617] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.617] Resolving globals: FALSE
[08:24:56.617] Tweak future expression to call with '...' arguments ...
[08:24:56.618] {
[08:24:56.618]     do.call(function(...) {
[08:24:56.618]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.618]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.618]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.618]             on.exit(options(oopts), add = TRUE)
[08:24:56.618]         }
[08:24:56.618]         {
[08:24:56.618]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.618]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.618]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.618]             })
[08:24:56.618]         }
[08:24:56.618]     }, args = future.call.arguments)
[08:24:56.618] }
[08:24:56.618] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.618] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.620] 
[08:24:56.620] getGlobalsAndPackages() ... DONE
[08:24:56.620] run() for ‘Future’ ...
[08:24:56.621] - state: ‘created’
[08:24:56.621] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:56.622] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.622]   - Field: ‘label’
[08:24:56.623]   - Field: ‘local’
[08:24:56.623]   - Field: ‘owner’
[08:24:56.623]   - Field: ‘envir’
[08:24:56.623]   - Field: ‘packages’
[08:24:56.623]   - Field: ‘gc’
[08:24:56.623]   - Field: ‘conditions’
[08:24:56.623]   - Field: ‘expr’
[08:24:56.623]   - Field: ‘uuid’
[08:24:56.623]   - Field: ‘seed’
[08:24:56.623]   - Field: ‘version’
[08:24:56.623]   - Field: ‘result’
[08:24:56.624]   - Field: ‘asynchronous’
[08:24:56.624]   - Field: ‘calls’
[08:24:56.624]   - Field: ‘globals’
[08:24:56.624]   - Field: ‘stdout’
[08:24:56.624]   - Field: ‘earlySignal’
[08:24:56.624]   - Field: ‘lazy’
[08:24:56.624]   - Field: ‘state’
[08:24:56.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.624] - Launch lazy future ...
[08:24:56.624] Packages needed by the future expression (n = 0): <none>
[08:24:56.625] Packages needed by future strategies (n = 0): <none>
[08:24:56.625] {
[08:24:56.625]     {
[08:24:56.625]         {
[08:24:56.625]             ...future.startTime <- base::Sys.time()
[08:24:56.625]             {
[08:24:56.625]                 {
[08:24:56.625]                   {
[08:24:56.625]                     base::local({
[08:24:56.625]                       has_future <- base::requireNamespace("future", 
[08:24:56.625]                         quietly = TRUE)
[08:24:56.625]                       if (has_future) {
[08:24:56.625]                         ns <- base::getNamespace("future")
[08:24:56.625]                         version <- ns[[".package"]][["version"]]
[08:24:56.625]                         if (is.null(version)) 
[08:24:56.625]                           version <- utils::packageVersion("future")
[08:24:56.625]                       }
[08:24:56.625]                       else {
[08:24:56.625]                         version <- NULL
[08:24:56.625]                       }
[08:24:56.625]                       if (!has_future || version < "1.8.0") {
[08:24:56.625]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.625]                           "", base::R.version$version.string), 
[08:24:56.625]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.625]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.625]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.625]                             "release", "version")], collapse = " "), 
[08:24:56.625]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.625]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.625]                           info)
[08:24:56.625]                         info <- base::paste(info, collapse = "; ")
[08:24:56.625]                         if (!has_future) {
[08:24:56.625]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.625]                             info)
[08:24:56.625]                         }
[08:24:56.625]                         else {
[08:24:56.625]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.625]                             info, version)
[08:24:56.625]                         }
[08:24:56.625]                         base::stop(msg)
[08:24:56.625]                       }
[08:24:56.625]                     })
[08:24:56.625]                   }
[08:24:56.625]                   ...future.strategy.old <- future::plan("list")
[08:24:56.625]                   options(future.plan = NULL)
[08:24:56.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.625]                 }
[08:24:56.625]                 ...future.workdir <- getwd()
[08:24:56.625]             }
[08:24:56.625]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.625]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.625]         }
[08:24:56.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.625]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.625]             base::names(...future.oldOptions))
[08:24:56.625]     }
[08:24:56.625]     if (FALSE) {
[08:24:56.625]     }
[08:24:56.625]     else {
[08:24:56.625]         if (TRUE) {
[08:24:56.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.625]                 open = "w")
[08:24:56.625]         }
[08:24:56.625]         else {
[08:24:56.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.625]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.625]         }
[08:24:56.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.625]             base::sink(type = "output", split = FALSE)
[08:24:56.625]             base::close(...future.stdout)
[08:24:56.625]         }, add = TRUE)
[08:24:56.625]     }
[08:24:56.625]     ...future.frame <- base::sys.nframe()
[08:24:56.625]     ...future.conditions <- base::list()
[08:24:56.625]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.625]     if (FALSE) {
[08:24:56.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.625]     }
[08:24:56.625]     ...future.result <- base::tryCatch({
[08:24:56.625]         base::withCallingHandlers({
[08:24:56.625]             ...future.value <- base::withVisible(base::local({
[08:24:56.625]                 do.call(function(...) {
[08:24:56.625]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.625]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.625]                     ...future.globals.maxSize)) {
[08:24:56.625]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.625]                     on.exit(options(oopts), add = TRUE)
[08:24:56.625]                   }
[08:24:56.625]                   {
[08:24:56.625]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.625]                       FUN = function(jj) {
[08:24:56.625]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.625]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.625]                       })
[08:24:56.625]                   }
[08:24:56.625]                 }, args = future.call.arguments)
[08:24:56.625]             }))
[08:24:56.625]             future::FutureResult(value = ...future.value$value, 
[08:24:56.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.625]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.625]                     ...future.globalenv.names))
[08:24:56.625]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.625]         }, condition = base::local({
[08:24:56.625]             c <- base::c
[08:24:56.625]             inherits <- base::inherits
[08:24:56.625]             invokeRestart <- base::invokeRestart
[08:24:56.625]             length <- base::length
[08:24:56.625]             list <- base::list
[08:24:56.625]             seq.int <- base::seq.int
[08:24:56.625]             signalCondition <- base::signalCondition
[08:24:56.625]             sys.calls <- base::sys.calls
[08:24:56.625]             `[[` <- base::`[[`
[08:24:56.625]             `+` <- base::`+`
[08:24:56.625]             `<<-` <- base::`<<-`
[08:24:56.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.625]                   3L)]
[08:24:56.625]             }
[08:24:56.625]             function(cond) {
[08:24:56.625]                 is_error <- inherits(cond, "error")
[08:24:56.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.625]                   NULL)
[08:24:56.625]                 if (is_error) {
[08:24:56.625]                   sessionInformation <- function() {
[08:24:56.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.625]                       search = base::search(), system = base::Sys.info())
[08:24:56.625]                   }
[08:24:56.625]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.625]                     cond$call), session = sessionInformation(), 
[08:24:56.625]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.625]                   signalCondition(cond)
[08:24:56.625]                 }
[08:24:56.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.625]                 "immediateCondition"))) {
[08:24:56.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.625]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.625]                   if (TRUE && !signal) {
[08:24:56.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.625]                     {
[08:24:56.625]                       inherits <- base::inherits
[08:24:56.625]                       invokeRestart <- base::invokeRestart
[08:24:56.625]                       is.null <- base::is.null
[08:24:56.625]                       muffled <- FALSE
[08:24:56.625]                       if (inherits(cond, "message")) {
[08:24:56.625]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.625]                         if (muffled) 
[08:24:56.625]                           invokeRestart("muffleMessage")
[08:24:56.625]                       }
[08:24:56.625]                       else if (inherits(cond, "warning")) {
[08:24:56.625]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.625]                         if (muffled) 
[08:24:56.625]                           invokeRestart("muffleWarning")
[08:24:56.625]                       }
[08:24:56.625]                       else if (inherits(cond, "condition")) {
[08:24:56.625]                         if (!is.null(pattern)) {
[08:24:56.625]                           computeRestarts <- base::computeRestarts
[08:24:56.625]                           grepl <- base::grepl
[08:24:56.625]                           restarts <- computeRestarts(cond)
[08:24:56.625]                           for (restart in restarts) {
[08:24:56.625]                             name <- restart$name
[08:24:56.625]                             if (is.null(name)) 
[08:24:56.625]                               next
[08:24:56.625]                             if (!grepl(pattern, name)) 
[08:24:56.625]                               next
[08:24:56.625]                             invokeRestart(restart)
[08:24:56.625]                             muffled <- TRUE
[08:24:56.625]                             break
[08:24:56.625]                           }
[08:24:56.625]                         }
[08:24:56.625]                       }
[08:24:56.625]                       invisible(muffled)
[08:24:56.625]                     }
[08:24:56.625]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.625]                   }
[08:24:56.625]                 }
[08:24:56.625]                 else {
[08:24:56.625]                   if (TRUE) {
[08:24:56.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.625]                     {
[08:24:56.625]                       inherits <- base::inherits
[08:24:56.625]                       invokeRestart <- base::invokeRestart
[08:24:56.625]                       is.null <- base::is.null
[08:24:56.625]                       muffled <- FALSE
[08:24:56.625]                       if (inherits(cond, "message")) {
[08:24:56.625]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.625]                         if (muffled) 
[08:24:56.625]                           invokeRestart("muffleMessage")
[08:24:56.625]                       }
[08:24:56.625]                       else if (inherits(cond, "warning")) {
[08:24:56.625]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.625]                         if (muffled) 
[08:24:56.625]                           invokeRestart("muffleWarning")
[08:24:56.625]                       }
[08:24:56.625]                       else if (inherits(cond, "condition")) {
[08:24:56.625]                         if (!is.null(pattern)) {
[08:24:56.625]                           computeRestarts <- base::computeRestarts
[08:24:56.625]                           grepl <- base::grepl
[08:24:56.625]                           restarts <- computeRestarts(cond)
[08:24:56.625]                           for (restart in restarts) {
[08:24:56.625]                             name <- restart$name
[08:24:56.625]                             if (is.null(name)) 
[08:24:56.625]                               next
[08:24:56.625]                             if (!grepl(pattern, name)) 
[08:24:56.625]                               next
[08:24:56.625]                             invokeRestart(restart)
[08:24:56.625]                             muffled <- TRUE
[08:24:56.625]                             break
[08:24:56.625]                           }
[08:24:56.625]                         }
[08:24:56.625]                       }
[08:24:56.625]                       invisible(muffled)
[08:24:56.625]                     }
[08:24:56.625]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.625]                   }
[08:24:56.625]                 }
[08:24:56.625]             }
[08:24:56.625]         }))
[08:24:56.625]     }, error = function(ex) {
[08:24:56.625]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.625]                 ...future.rng), started = ...future.startTime, 
[08:24:56.625]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.625]             version = "1.8"), class = "FutureResult")
[08:24:56.625]     }, finally = {
[08:24:56.625]         if (!identical(...future.workdir, getwd())) 
[08:24:56.625]             setwd(...future.workdir)
[08:24:56.625]         {
[08:24:56.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.625]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.625]             }
[08:24:56.625]             base::options(...future.oldOptions)
[08:24:56.625]             if (.Platform$OS.type == "windows") {
[08:24:56.625]                 old_names <- names(...future.oldEnvVars)
[08:24:56.625]                 envs <- base::Sys.getenv()
[08:24:56.625]                 names <- names(envs)
[08:24:56.625]                 common <- intersect(names, old_names)
[08:24:56.625]                 added <- setdiff(names, old_names)
[08:24:56.625]                 removed <- setdiff(old_names, names)
[08:24:56.625]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.625]                   envs[common]]
[08:24:56.625]                 NAMES <- toupper(changed)
[08:24:56.625]                 args <- list()
[08:24:56.625]                 for (kk in seq_along(NAMES)) {
[08:24:56.625]                   name <- changed[[kk]]
[08:24:56.625]                   NAME <- NAMES[[kk]]
[08:24:56.625]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.625]                     next
[08:24:56.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.625]                 }
[08:24:56.625]                 NAMES <- toupper(added)
[08:24:56.625]                 for (kk in seq_along(NAMES)) {
[08:24:56.625]                   name <- added[[kk]]
[08:24:56.625]                   NAME <- NAMES[[kk]]
[08:24:56.625]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.625]                     next
[08:24:56.625]                   args[[name]] <- ""
[08:24:56.625]                 }
[08:24:56.625]                 NAMES <- toupper(removed)
[08:24:56.625]                 for (kk in seq_along(NAMES)) {
[08:24:56.625]                   name <- removed[[kk]]
[08:24:56.625]                   NAME <- NAMES[[kk]]
[08:24:56.625]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.625]                     next
[08:24:56.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.625]                 }
[08:24:56.625]                 if (length(args) > 0) 
[08:24:56.625]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.625]             }
[08:24:56.625]             else {
[08:24:56.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.625]             }
[08:24:56.625]             {
[08:24:56.625]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.625]                   0L) {
[08:24:56.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.625]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.625]                   base::options(opts)
[08:24:56.625]                 }
[08:24:56.625]                 {
[08:24:56.625]                   {
[08:24:56.625]                     NULL
[08:24:56.625]                     RNGkind("Mersenne-Twister")
[08:24:56.625]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.625]                       inherits = FALSE)
[08:24:56.625]                   }
[08:24:56.625]                   options(future.plan = NULL)
[08:24:56.625]                   if (is.na(NA_character_)) 
[08:24:56.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.625]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.625]                     .init = FALSE)
[08:24:56.625]                 }
[08:24:56.625]             }
[08:24:56.625]         }
[08:24:56.625]     })
[08:24:56.625]     if (TRUE) {
[08:24:56.625]         base::sink(type = "output", split = FALSE)
[08:24:56.625]         if (TRUE) {
[08:24:56.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.625]         }
[08:24:56.625]         else {
[08:24:56.625]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.625]         }
[08:24:56.625]         base::close(...future.stdout)
[08:24:56.625]         ...future.stdout <- NULL
[08:24:56.625]     }
[08:24:56.625]     ...future.result$conditions <- ...future.conditions
[08:24:56.625]     ...future.result$finished <- base::Sys.time()
[08:24:56.625]     ...future.result
[08:24:56.625] }
[08:24:56.627] assign_globals() ...
[08:24:56.627] List of 5
[08:24:56.627]  $ ...future.FUN            :function (object, ...)  
[08:24:56.627]  $ future.call.arguments    :List of 1
[08:24:56.627]   ..$ digits: int 2
[08:24:56.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.627]  $ ...future.elements_ii    :List of 6
[08:24:56.627]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[08:24:56.627]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[08:24:56.627]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[08:24:56.627]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[08:24:56.627]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[08:24:56.627]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[08:24:56.627]  $ ...future.seeds_ii       : NULL
[08:24:56.627]  $ ...future.globals.maxSize: NULL
[08:24:56.627]  - attr(*, "where")=List of 5
[08:24:56.627]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.627]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.627]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.627]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.627]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.627]  - attr(*, "resolved")= logi FALSE
[08:24:56.627]  - attr(*, "total_size")= num 13284
[08:24:56.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.627]  - attr(*, "already-done")= logi TRUE
[08:24:56.633] - copied ‘...future.FUN’ to environment
[08:24:56.633] - copied ‘future.call.arguments’ to environment
[08:24:56.634] - copied ‘...future.elements_ii’ to environment
[08:24:56.634] - copied ‘...future.seeds_ii’ to environment
[08:24:56.634] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.634] assign_globals() ... done
[08:24:56.634] plan(): Setting new future strategy stack:
[08:24:56.634] List of future strategies:
[08:24:56.634] 1. sequential:
[08:24:56.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.634]    - tweaked: FALSE
[08:24:56.634]    - call: NULL
[08:24:56.635] plan(): nbrOfWorkers() = 1
[08:24:56.636] plan(): Setting new future strategy stack:
[08:24:56.636] List of future strategies:
[08:24:56.636] 1. multicore:
[08:24:56.636]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:56.636]    - tweaked: FALSE
[08:24:56.636]    - call: plan(strategy)
[08:24:56.638] plan(): nbrOfWorkers() = 1
[08:24:56.638] SequentialFuture started (and completed)
[08:24:56.638] - Launch lazy future ... done
[08:24:56.638] run() for ‘SequentialFuture’ ... done
[08:24:56.638] Created future:
[08:24:56.638] SequentialFuture:
[08:24:56.638] Label: ‘future_by-1’
[08:24:56.638] Expression:
[08:24:56.638] {
[08:24:56.638]     do.call(function(...) {
[08:24:56.638]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.638]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.638]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.638]             on.exit(options(oopts), add = TRUE)
[08:24:56.638]         }
[08:24:56.638]         {
[08:24:56.638]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.638]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.638]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.638]             })
[08:24:56.638]         }
[08:24:56.638]     }, args = future.call.arguments)
[08:24:56.638] }
[08:24:56.638] Lazy evaluation: FALSE
[08:24:56.638] Asynchronous evaluation: FALSE
[08:24:56.638] Local evaluation: TRUE
[08:24:56.638] Environment: R_GlobalEnv
[08:24:56.638] Capture standard output: TRUE
[08:24:56.638] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.638] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.638] Packages: <none>
[08:24:56.638] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.638] Resolved: TRUE
[08:24:56.638] Value: 1.27 KiB of class ‘list’
[08:24:56.638] Early signaling: FALSE
[08:24:56.638] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.638] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.639] Chunk #1 of 1 ... DONE
[08:24:56.639] Launching 1 futures (chunks) ... DONE
[08:24:56.639] Resolving 1 futures (chunks) ...
[08:24:56.639] resolve() on list ...
[08:24:56.640]  recursive: 0
[08:24:56.640]  length: 1
[08:24:56.640] 
[08:24:56.640] resolved() for ‘SequentialFuture’ ...
[08:24:56.640] - state: ‘finished’
[08:24:56.640] - run: TRUE
[08:24:56.640] - result: ‘FutureResult’
[08:24:56.640] resolved() for ‘SequentialFuture’ ... done
[08:24:56.640] Future #1
[08:24:56.640] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.640] - nx: 1
[08:24:56.641] - relay: TRUE
[08:24:56.641] - stdout: TRUE
[08:24:56.641] - signal: TRUE
[08:24:56.641] - resignal: FALSE
[08:24:56.641] - force: TRUE
[08:24:56.643] - relayed: [n=1] FALSE
[08:24:56.643] - queued futures: [n=1] FALSE
[08:24:56.643]  - until=1
[08:24:56.643]  - relaying element #1
[08:24:56.643] - relayed: [n=1] TRUE
[08:24:56.643] - queued futures: [n=1] TRUE
[08:24:56.643] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.643]  length: 0 (resolved future 1)
[08:24:56.644] Relaying remaining futures
[08:24:56.644] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.644] - nx: 1
[08:24:56.644] - relay: TRUE
[08:24:56.644] - stdout: TRUE
[08:24:56.644] - signal: TRUE
[08:24:56.644] - resignal: FALSE
[08:24:56.644] - force: TRUE
[08:24:56.644] - relayed: [n=1] TRUE
[08:24:56.644] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.644] - relayed: [n=1] TRUE
[08:24:56.644] - queued futures: [n=1] TRUE
[08:24:56.645] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.645] resolve() on list ... DONE
[08:24:56.645]  - Number of value chunks collected: 1
[08:24:56.645] Resolving 1 futures (chunks) ... DONE
[08:24:56.645] Reducing values from 1 chunks ...
[08:24:56.645]  - Number of values collected after concatenation: 6
[08:24:56.645]  - Number of values expected: 6
[08:24:56.645] Reducing values from 1 chunks ... DONE
[08:24:56.645] future_lapply() ... DONE
[08:24:56.645] future_by_internal() ... DONE
[08:24:56.646] future_by_internal() ...
[08:24:56.647] future_lapply() ...
[08:24:56.649] Number of chunks: 1
[08:24:56.649] getGlobalsAndPackagesXApply() ...
[08:24:56.649]  - future.globals: TRUE
[08:24:56.649] getGlobalsAndPackages() ...
[08:24:56.649] Searching for globals...
[08:24:56.651] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:56.651] Searching for globals ... DONE
[08:24:56.651] Resolving globals: FALSE
[08:24:56.652] The total size of the 1 globals is 762 bytes (762 bytes)
[08:24:56.652] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[08:24:56.652] - globals: [1] ‘FUN’
[08:24:56.652] - packages: [1] ‘stats’
[08:24:56.652] getGlobalsAndPackages() ... DONE
[08:24:56.652]  - globals found/used: [n=1] ‘FUN’
[08:24:56.652]  - needed namespaces: [n=1] ‘stats’
[08:24:56.652] Finding globals ... DONE
[08:24:56.653]  - use_args: TRUE
[08:24:56.653]  - Getting '...' globals ...
[08:24:56.653] resolve() on list ...
[08:24:56.653]  recursive: 0
[08:24:56.653]  length: 1
[08:24:56.653]  elements: ‘...’
[08:24:56.653]  length: 0 (resolved future 1)
[08:24:56.653] resolve() on list ... DONE
[08:24:56.654]    - '...' content: [n=1] ‘singular.ok’
[08:24:56.654] List of 1
[08:24:56.654]  $ ...:List of 1
[08:24:56.654]   ..$ singular.ok: logi FALSE
[08:24:56.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.654]  - attr(*, "where")=List of 1
[08:24:56.654]   ..$ ...:<environment: 0x557b25d2c140> 
[08:24:56.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.654]  - attr(*, "resolved")= logi TRUE
[08:24:56.654]  - attr(*, "total_size")= num NA
[08:24:56.656]  - Getting '...' globals ... DONE
[08:24:56.657] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.657] List of 2
[08:24:56.657]  $ ...future.FUN:function (x, ...)  
[08:24:56.657]  $ ...          :List of 1
[08:24:56.657]   ..$ singular.ok: logi FALSE
[08:24:56.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.657]  - attr(*, "where")=List of 2
[08:24:56.657]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.657]   ..$ ...          :<environment: 0x557b25d2c140> 
[08:24:56.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.657]  - attr(*, "resolved")= logi FALSE
[08:24:56.657]  - attr(*, "total_size")= num 19977
[08:24:56.660] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:56.660] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.660] Number of futures (= number of chunks): 1
[08:24:56.660] Launching 1 futures (chunks) ...
[08:24:56.660] Chunk #1 of 1 ...
[08:24:56.660]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.660] getGlobalsAndPackages() ...
[08:24:56.660] Searching for globals...
[08:24:56.694] 
[08:24:56.695] Searching for globals ... DONE
[08:24:56.695] - globals: [0] <none>
[08:24:56.695] getGlobalsAndPackages() ... DONE
[08:24:56.695]    + additional globals found: [n=0] 
[08:24:56.695]    + additional namespaces needed: [n=0] 
[08:24:56.695]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.695]  - seeds: <none>
[08:24:56.695]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.696] getGlobalsAndPackages() ...
[08:24:56.696] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.696] Resolving globals: FALSE
[08:24:56.696] Tweak future expression to call with '...' arguments ...
[08:24:56.696] {
[08:24:56.696]     do.call(function(...) {
[08:24:56.696]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.696]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.696]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.696]             on.exit(options(oopts), add = TRUE)
[08:24:56.696]         }
[08:24:56.696]         {
[08:24:56.696]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.696]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.696]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.696]             })
[08:24:56.696]         }
[08:24:56.696]     }, args = future.call.arguments)
[08:24:56.696] }
[08:24:56.696] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.697] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.697] 
[08:24:56.697] getGlobalsAndPackages() ... DONE
[08:24:56.697] run() for ‘Future’ ...
[08:24:56.697] - state: ‘created’
[08:24:56.698] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:56.699] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.700]   - Field: ‘label’
[08:24:56.700]   - Field: ‘local’
[08:24:56.700]   - Field: ‘owner’
[08:24:56.700]   - Field: ‘envir’
[08:24:56.700]   - Field: ‘packages’
[08:24:56.700]   - Field: ‘gc’
[08:24:56.700]   - Field: ‘conditions’
[08:24:56.700]   - Field: ‘expr’
[08:24:56.700]   - Field: ‘uuid’
[08:24:56.700]   - Field: ‘seed’
[08:24:56.701]   - Field: ‘version’
[08:24:56.701]   - Field: ‘result’
[08:24:56.701]   - Field: ‘asynchronous’
[08:24:56.701]   - Field: ‘calls’
[08:24:56.701]   - Field: ‘globals’
[08:24:56.701]   - Field: ‘stdout’
[08:24:56.701]   - Field: ‘earlySignal’
[08:24:56.701]   - Field: ‘lazy’
[08:24:56.701]   - Field: ‘state’
[08:24:56.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.701] - Launch lazy future ...
[08:24:56.702] Packages needed by the future expression (n = 1): ‘stats’
[08:24:56.702] Packages needed by future strategies (n = 0): <none>
[08:24:56.702] {
[08:24:56.702]     {
[08:24:56.702]         {
[08:24:56.702]             ...future.startTime <- base::Sys.time()
[08:24:56.702]             {
[08:24:56.702]                 {
[08:24:56.702]                   {
[08:24:56.702]                     {
[08:24:56.702]                       base::local({
[08:24:56.702]                         has_future <- base::requireNamespace("future", 
[08:24:56.702]                           quietly = TRUE)
[08:24:56.702]                         if (has_future) {
[08:24:56.702]                           ns <- base::getNamespace("future")
[08:24:56.702]                           version <- ns[[".package"]][["version"]]
[08:24:56.702]                           if (is.null(version)) 
[08:24:56.702]                             version <- utils::packageVersion("future")
[08:24:56.702]                         }
[08:24:56.702]                         else {
[08:24:56.702]                           version <- NULL
[08:24:56.702]                         }
[08:24:56.702]                         if (!has_future || version < "1.8.0") {
[08:24:56.702]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.702]                             "", base::R.version$version.string), 
[08:24:56.702]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:56.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.702]                               "release", "version")], collapse = " "), 
[08:24:56.702]                             hostname = base::Sys.info()[["nodename"]])
[08:24:56.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.702]                             info)
[08:24:56.702]                           info <- base::paste(info, collapse = "; ")
[08:24:56.702]                           if (!has_future) {
[08:24:56.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.702]                               info)
[08:24:56.702]                           }
[08:24:56.702]                           else {
[08:24:56.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.702]                               info, version)
[08:24:56.702]                           }
[08:24:56.702]                           base::stop(msg)
[08:24:56.702]                         }
[08:24:56.702]                       })
[08:24:56.702]                     }
[08:24:56.702]                     base::local({
[08:24:56.702]                       for (pkg in "stats") {
[08:24:56.702]                         base::loadNamespace(pkg)
[08:24:56.702]                         base::library(pkg, character.only = TRUE)
[08:24:56.702]                       }
[08:24:56.702]                     })
[08:24:56.702]                   }
[08:24:56.702]                   ...future.strategy.old <- future::plan("list")
[08:24:56.702]                   options(future.plan = NULL)
[08:24:56.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.702]                 }
[08:24:56.702]                 ...future.workdir <- getwd()
[08:24:56.702]             }
[08:24:56.702]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.702]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.702]         }
[08:24:56.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.702]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.702]             base::names(...future.oldOptions))
[08:24:56.702]     }
[08:24:56.702]     if (FALSE) {
[08:24:56.702]     }
[08:24:56.702]     else {
[08:24:56.702]         if (TRUE) {
[08:24:56.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.702]                 open = "w")
[08:24:56.702]         }
[08:24:56.702]         else {
[08:24:56.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.702]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.702]         }
[08:24:56.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.702]             base::sink(type = "output", split = FALSE)
[08:24:56.702]             base::close(...future.stdout)
[08:24:56.702]         }, add = TRUE)
[08:24:56.702]     }
[08:24:56.702]     ...future.frame <- base::sys.nframe()
[08:24:56.702]     ...future.conditions <- base::list()
[08:24:56.702]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.702]     if (FALSE) {
[08:24:56.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.702]     }
[08:24:56.702]     ...future.result <- base::tryCatch({
[08:24:56.702]         base::withCallingHandlers({
[08:24:56.702]             ...future.value <- base::withVisible(base::local({
[08:24:56.702]                 do.call(function(...) {
[08:24:56.702]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.702]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.702]                     ...future.globals.maxSize)) {
[08:24:56.702]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.702]                     on.exit(options(oopts), add = TRUE)
[08:24:56.702]                   }
[08:24:56.702]                   {
[08:24:56.702]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.702]                       FUN = function(jj) {
[08:24:56.702]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.702]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.702]                       })
[08:24:56.702]                   }
[08:24:56.702]                 }, args = future.call.arguments)
[08:24:56.702]             }))
[08:24:56.702]             future::FutureResult(value = ...future.value$value, 
[08:24:56.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.702]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.702]                     ...future.globalenv.names))
[08:24:56.702]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.702]         }, condition = base::local({
[08:24:56.702]             c <- base::c
[08:24:56.702]             inherits <- base::inherits
[08:24:56.702]             invokeRestart <- base::invokeRestart
[08:24:56.702]             length <- base::length
[08:24:56.702]             list <- base::list
[08:24:56.702]             seq.int <- base::seq.int
[08:24:56.702]             signalCondition <- base::signalCondition
[08:24:56.702]             sys.calls <- base::sys.calls
[08:24:56.702]             `[[` <- base::`[[`
[08:24:56.702]             `+` <- base::`+`
[08:24:56.702]             `<<-` <- base::`<<-`
[08:24:56.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.702]                   3L)]
[08:24:56.702]             }
[08:24:56.702]             function(cond) {
[08:24:56.702]                 is_error <- inherits(cond, "error")
[08:24:56.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.702]                   NULL)
[08:24:56.702]                 if (is_error) {
[08:24:56.702]                   sessionInformation <- function() {
[08:24:56.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.702]                       search = base::search(), system = base::Sys.info())
[08:24:56.702]                   }
[08:24:56.702]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.702]                     cond$call), session = sessionInformation(), 
[08:24:56.702]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.702]                   signalCondition(cond)
[08:24:56.702]                 }
[08:24:56.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.702]                 "immediateCondition"))) {
[08:24:56.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.702]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.702]                   if (TRUE && !signal) {
[08:24:56.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.702]                     {
[08:24:56.702]                       inherits <- base::inherits
[08:24:56.702]                       invokeRestart <- base::invokeRestart
[08:24:56.702]                       is.null <- base::is.null
[08:24:56.702]                       muffled <- FALSE
[08:24:56.702]                       if (inherits(cond, "message")) {
[08:24:56.702]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.702]                         if (muffled) 
[08:24:56.702]                           invokeRestart("muffleMessage")
[08:24:56.702]                       }
[08:24:56.702]                       else if (inherits(cond, "warning")) {
[08:24:56.702]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.702]                         if (muffled) 
[08:24:56.702]                           invokeRestart("muffleWarning")
[08:24:56.702]                       }
[08:24:56.702]                       else if (inherits(cond, "condition")) {
[08:24:56.702]                         if (!is.null(pattern)) {
[08:24:56.702]                           computeRestarts <- base::computeRestarts
[08:24:56.702]                           grepl <- base::grepl
[08:24:56.702]                           restarts <- computeRestarts(cond)
[08:24:56.702]                           for (restart in restarts) {
[08:24:56.702]                             name <- restart$name
[08:24:56.702]                             if (is.null(name)) 
[08:24:56.702]                               next
[08:24:56.702]                             if (!grepl(pattern, name)) 
[08:24:56.702]                               next
[08:24:56.702]                             invokeRestart(restart)
[08:24:56.702]                             muffled <- TRUE
[08:24:56.702]                             break
[08:24:56.702]                           }
[08:24:56.702]                         }
[08:24:56.702]                       }
[08:24:56.702]                       invisible(muffled)
[08:24:56.702]                     }
[08:24:56.702]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.702]                   }
[08:24:56.702]                 }
[08:24:56.702]                 else {
[08:24:56.702]                   if (TRUE) {
[08:24:56.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.702]                     {
[08:24:56.702]                       inherits <- base::inherits
[08:24:56.702]                       invokeRestart <- base::invokeRestart
[08:24:56.702]                       is.null <- base::is.null
[08:24:56.702]                       muffled <- FALSE
[08:24:56.702]                       if (inherits(cond, "message")) {
[08:24:56.702]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.702]                         if (muffled) 
[08:24:56.702]                           invokeRestart("muffleMessage")
[08:24:56.702]                       }
[08:24:56.702]                       else if (inherits(cond, "warning")) {
[08:24:56.702]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.702]                         if (muffled) 
[08:24:56.702]                           invokeRestart("muffleWarning")
[08:24:56.702]                       }
[08:24:56.702]                       else if (inherits(cond, "condition")) {
[08:24:56.702]                         if (!is.null(pattern)) {
[08:24:56.702]                           computeRestarts <- base::computeRestarts
[08:24:56.702]                           grepl <- base::grepl
[08:24:56.702]                           restarts <- computeRestarts(cond)
[08:24:56.702]                           for (restart in restarts) {
[08:24:56.702]                             name <- restart$name
[08:24:56.702]                             if (is.null(name)) 
[08:24:56.702]                               next
[08:24:56.702]                             if (!grepl(pattern, name)) 
[08:24:56.702]                               next
[08:24:56.702]                             invokeRestart(restart)
[08:24:56.702]                             muffled <- TRUE
[08:24:56.702]                             break
[08:24:56.702]                           }
[08:24:56.702]                         }
[08:24:56.702]                       }
[08:24:56.702]                       invisible(muffled)
[08:24:56.702]                     }
[08:24:56.702]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.702]                   }
[08:24:56.702]                 }
[08:24:56.702]             }
[08:24:56.702]         }))
[08:24:56.702]     }, error = function(ex) {
[08:24:56.702]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.702]                 ...future.rng), started = ...future.startTime, 
[08:24:56.702]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.702]             version = "1.8"), class = "FutureResult")
[08:24:56.702]     }, finally = {
[08:24:56.702]         if (!identical(...future.workdir, getwd())) 
[08:24:56.702]             setwd(...future.workdir)
[08:24:56.702]         {
[08:24:56.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.702]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.702]             }
[08:24:56.702]             base::options(...future.oldOptions)
[08:24:56.702]             if (.Platform$OS.type == "windows") {
[08:24:56.702]                 old_names <- names(...future.oldEnvVars)
[08:24:56.702]                 envs <- base::Sys.getenv()
[08:24:56.702]                 names <- names(envs)
[08:24:56.702]                 common <- intersect(names, old_names)
[08:24:56.702]                 added <- setdiff(names, old_names)
[08:24:56.702]                 removed <- setdiff(old_names, names)
[08:24:56.702]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.702]                   envs[common]]
[08:24:56.702]                 NAMES <- toupper(changed)
[08:24:56.702]                 args <- list()
[08:24:56.702]                 for (kk in seq_along(NAMES)) {
[08:24:56.702]                   name <- changed[[kk]]
[08:24:56.702]                   NAME <- NAMES[[kk]]
[08:24:56.702]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.702]                     next
[08:24:56.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.702]                 }
[08:24:56.702]                 NAMES <- toupper(added)
[08:24:56.702]                 for (kk in seq_along(NAMES)) {
[08:24:56.702]                   name <- added[[kk]]
[08:24:56.702]                   NAME <- NAMES[[kk]]
[08:24:56.702]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.702]                     next
[08:24:56.702]                   args[[name]] <- ""
[08:24:56.702]                 }
[08:24:56.702]                 NAMES <- toupper(removed)
[08:24:56.702]                 for (kk in seq_along(NAMES)) {
[08:24:56.702]                   name <- removed[[kk]]
[08:24:56.702]                   NAME <- NAMES[[kk]]
[08:24:56.702]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.702]                     next
[08:24:56.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.702]                 }
[08:24:56.702]                 if (length(args) > 0) 
[08:24:56.702]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.702]             }
[08:24:56.702]             else {
[08:24:56.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.702]             }
[08:24:56.702]             {
[08:24:56.702]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.702]                   0L) {
[08:24:56.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.702]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.702]                   base::options(opts)
[08:24:56.702]                 }
[08:24:56.702]                 {
[08:24:56.702]                   {
[08:24:56.702]                     NULL
[08:24:56.702]                     RNGkind("Mersenne-Twister")
[08:24:56.702]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.702]                       inherits = FALSE)
[08:24:56.702]                   }
[08:24:56.702]                   options(future.plan = NULL)
[08:24:56.702]                   if (is.na(NA_character_)) 
[08:24:56.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.702]                     .init = FALSE)
[08:24:56.702]                 }
[08:24:56.702]             }
[08:24:56.702]         }
[08:24:56.702]     })
[08:24:56.702]     if (TRUE) {
[08:24:56.702]         base::sink(type = "output", split = FALSE)
[08:24:56.702]         if (TRUE) {
[08:24:56.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.702]         }
[08:24:56.702]         else {
[08:24:56.702]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.702]         }
[08:24:56.702]         base::close(...future.stdout)
[08:24:56.702]         ...future.stdout <- NULL
[08:24:56.702]     }
[08:24:56.702]     ...future.result$conditions <- ...future.conditions
[08:24:56.702]     ...future.result$finished <- base::Sys.time()
[08:24:56.702]     ...future.result
[08:24:56.702] }
[08:24:56.704] assign_globals() ...
[08:24:56.704] List of 5
[08:24:56.704]  $ ...future.FUN            :function (x, ...)  
[08:24:56.704]  $ future.call.arguments    :List of 1
[08:24:56.704]   ..$ singular.ok: logi FALSE
[08:24:56.704]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.704]  $ ...future.elements_ii    :List of 3
[08:24:56.704]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.704]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.704]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.704]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.704]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.704]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.704]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.704]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:56.704]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.704]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.704]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.704]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:56.704]  $ ...future.seeds_ii       : NULL
[08:24:56.704]  $ ...future.globals.maxSize: NULL
[08:24:56.704]  - attr(*, "where")=List of 5
[08:24:56.704]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.704]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.704]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.704]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.704]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.704]  - attr(*, "resolved")= logi FALSE
[08:24:56.704]  - attr(*, "total_size")= num 19977
[08:24:56.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.704]  - attr(*, "already-done")= logi TRUE
[08:24:56.713] - reassign environment for ‘...future.FUN’
[08:24:56.714] - copied ‘...future.FUN’ to environment
[08:24:56.714] - copied ‘future.call.arguments’ to environment
[08:24:56.714] - copied ‘...future.elements_ii’ to environment
[08:24:56.714] - copied ‘...future.seeds_ii’ to environment
[08:24:56.714] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.714] assign_globals() ... done
[08:24:56.714] plan(): Setting new future strategy stack:
[08:24:56.715] List of future strategies:
[08:24:56.715] 1. sequential:
[08:24:56.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.715]    - tweaked: FALSE
[08:24:56.715]    - call: NULL
[08:24:56.715] plan(): nbrOfWorkers() = 1
[08:24:56.718] plan(): Setting new future strategy stack:
[08:24:56.718] List of future strategies:
[08:24:56.718] 1. multicore:
[08:24:56.718]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:56.718]    - tweaked: FALSE
[08:24:56.718]    - call: plan(strategy)
[08:24:56.721] plan(): nbrOfWorkers() = 1
[08:24:56.721] SequentialFuture started (and completed)
[08:24:56.722] - Launch lazy future ... done
[08:24:56.722] run() for ‘SequentialFuture’ ... done
[08:24:56.722] Created future:
[08:24:56.722] SequentialFuture:
[08:24:56.722] Label: ‘future_by-1’
[08:24:56.722] Expression:
[08:24:56.722] {
[08:24:56.722]     do.call(function(...) {
[08:24:56.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.722]             on.exit(options(oopts), add = TRUE)
[08:24:56.722]         }
[08:24:56.722]         {
[08:24:56.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.722]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.722]             })
[08:24:56.722]         }
[08:24:56.722]     }, args = future.call.arguments)
[08:24:56.722] }
[08:24:56.722] Lazy evaluation: FALSE
[08:24:56.722] Asynchronous evaluation: FALSE
[08:24:56.722] Local evaluation: TRUE
[08:24:56.722] Environment: R_GlobalEnv
[08:24:56.722] Capture standard output: TRUE
[08:24:56.722] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.722] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.722] Packages: 1 packages (‘stats’)
[08:24:56.722] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.722] Resolved: TRUE
[08:24:56.722] Value: 81.44 KiB of class ‘list’
[08:24:56.722] Early signaling: FALSE
[08:24:56.722] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.722] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.723] Chunk #1 of 1 ... DONE
[08:24:56.724] Launching 1 futures (chunks) ... DONE
[08:24:56.724] Resolving 1 futures (chunks) ...
[08:24:56.724] resolve() on list ...
[08:24:56.724]  recursive: 0
[08:24:56.724]  length: 1
[08:24:56.724] 
[08:24:56.724] resolved() for ‘SequentialFuture’ ...
[08:24:56.724] - state: ‘finished’
[08:24:56.724] - run: TRUE
[08:24:56.724] - result: ‘FutureResult’
[08:24:56.725] resolved() for ‘SequentialFuture’ ... done
[08:24:56.725] Future #1
[08:24:56.725] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.725] - nx: 1
[08:24:56.725] - relay: TRUE
[08:24:56.725] - stdout: TRUE
[08:24:56.725] - signal: TRUE
[08:24:56.725] - resignal: FALSE
[08:24:56.725] - force: TRUE
[08:24:56.725] - relayed: [n=1] FALSE
[08:24:56.725] - queued futures: [n=1] FALSE
[08:24:56.726]  - until=1
[08:24:56.726]  - relaying element #1
[08:24:56.726] - relayed: [n=1] TRUE
[08:24:56.726] - queued futures: [n=1] TRUE
[08:24:56.726] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.726]  length: 0 (resolved future 1)
[08:24:56.726] Relaying remaining futures
[08:24:56.726] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.726] - nx: 1
[08:24:56.726] - relay: TRUE
[08:24:56.726] - stdout: TRUE
[08:24:56.727] - signal: TRUE
[08:24:56.727] - resignal: FALSE
[08:24:56.727] - force: TRUE
[08:24:56.727] - relayed: [n=1] TRUE
[08:24:56.727] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.727] - relayed: [n=1] TRUE
[08:24:56.727] - queued futures: [n=1] TRUE
[08:24:56.727] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.727] resolve() on list ... DONE
[08:24:56.727]  - Number of value chunks collected: 1
[08:24:56.728] Resolving 1 futures (chunks) ... DONE
[08:24:56.728] Reducing values from 1 chunks ...
[08:24:56.728]  - Number of values collected after concatenation: 3
[08:24:56.728]  - Number of values expected: 3
[08:24:56.728] Reducing values from 1 chunks ... DONE
[08:24:56.728] future_lapply() ... DONE
[08:24:56.728] future_by_internal() ... DONE
[08:24:56.732] future_by_internal() ...
[08:24:56.732] future_lapply() ...
[08:24:56.734] Number of chunks: 1
[08:24:56.735] getGlobalsAndPackagesXApply() ...
[08:24:56.735]  - future.globals: TRUE
[08:24:56.735] getGlobalsAndPackages() ...
[08:24:56.735] Searching for globals...
[08:24:56.737] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:56.737] Searching for globals ... DONE
[08:24:56.737] Resolving globals: FALSE
[08:24:56.737] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[08:24:56.738] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[08:24:56.738] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:56.738] - packages: [1] ‘stats’
[08:24:56.738] getGlobalsAndPackages() ... DONE
[08:24:56.738]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:56.738]  - needed namespaces: [n=1] ‘stats’
[08:24:56.738] Finding globals ... DONE
[08:24:56.738]  - use_args: TRUE
[08:24:56.738]  - Getting '...' globals ...
[08:24:56.739] resolve() on list ...
[08:24:56.739]  recursive: 0
[08:24:56.739]  length: 1
[08:24:56.739]  elements: ‘...’
[08:24:56.739]  length: 0 (resolved future 1)
[08:24:56.739] resolve() on list ... DONE
[08:24:56.739]    - '...' content: [n=0] 
[08:24:56.739] List of 1
[08:24:56.739]  $ ...: list()
[08:24:56.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.739]  - attr(*, "where")=List of 1
[08:24:56.739]   ..$ ...:<environment: 0x557b27ee8f58> 
[08:24:56.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.739]  - attr(*, "resolved")= logi TRUE
[08:24:56.739]  - attr(*, "total_size")= num NA
[08:24:56.744]  - Getting '...' globals ... DONE
[08:24:56.744] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[08:24:56.744] List of 4
[08:24:56.744]  $ ...future.FUN:function (x)  
[08:24:56.744]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:56.744]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.744]  $ ...          : list()
[08:24:56.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.744]  - attr(*, "where")=List of 4
[08:24:56.744]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.744]   ..$ breaks       :<environment: R_EmptyEnv> 
[08:24:56.744]   ..$ wool         :<environment: R_EmptyEnv> 
[08:24:56.744]   ..$ ...          :<environment: 0x557b27ee8f58> 
[08:24:56.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.744]  - attr(*, "resolved")= logi FALSE
[08:24:56.744]  - attr(*, "total_size")= num 18867
[08:24:56.748] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:56.748] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.748] Number of futures (= number of chunks): 1
[08:24:56.749] Launching 1 futures (chunks) ...
[08:24:56.749] Chunk #1 of 1 ...
[08:24:56.749]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.749] getGlobalsAndPackages() ...
[08:24:56.749] Searching for globals...
[08:24:56.749] 
[08:24:56.750] Searching for globals ... DONE
[08:24:56.750] - globals: [0] <none>
[08:24:56.750] getGlobalsAndPackages() ... DONE
[08:24:56.750]    + additional globals found: [n=0] 
[08:24:56.750]    + additional namespaces needed: [n=0] 
[08:24:56.750]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.750]  - seeds: <none>
[08:24:56.750]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.750] getGlobalsAndPackages() ...
[08:24:56.750] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.750] Resolving globals: FALSE
[08:24:56.751] Tweak future expression to call with '...' arguments ...
[08:24:56.751] {
[08:24:56.751]     do.call(function(...) {
[08:24:56.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.751]             on.exit(options(oopts), add = TRUE)
[08:24:56.751]         }
[08:24:56.751]         {
[08:24:56.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.751]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.751]             })
[08:24:56.751]         }
[08:24:56.751]     }, args = future.call.arguments)
[08:24:56.751] }
[08:24:56.751] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.751] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.751] 
[08:24:56.752] getGlobalsAndPackages() ... DONE
[08:24:56.752] run() for ‘Future’ ...
[08:24:56.752] - state: ‘created’
[08:24:56.752] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:56.754] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.754] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.754]   - Field: ‘label’
[08:24:56.754]   - Field: ‘local’
[08:24:56.754]   - Field: ‘owner’
[08:24:56.754]   - Field: ‘envir’
[08:24:56.754]   - Field: ‘packages’
[08:24:56.755]   - Field: ‘gc’
[08:24:56.755]   - Field: ‘conditions’
[08:24:56.755]   - Field: ‘expr’
[08:24:56.755]   - Field: ‘uuid’
[08:24:56.755]   - Field: ‘seed’
[08:24:56.755]   - Field: ‘version’
[08:24:56.755]   - Field: ‘result’
[08:24:56.755]   - Field: ‘asynchronous’
[08:24:56.755]   - Field: ‘calls’
[08:24:56.755]   - Field: ‘globals’
[08:24:56.755]   - Field: ‘stdout’
[08:24:56.756]   - Field: ‘earlySignal’
[08:24:56.756]   - Field: ‘lazy’
[08:24:56.756]   - Field: ‘state’
[08:24:56.756] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.756] - Launch lazy future ...
[08:24:56.756] Packages needed by the future expression (n = 1): ‘stats’
[08:24:56.756] Packages needed by future strategies (n = 0): <none>
[08:24:56.757] {
[08:24:56.757]     {
[08:24:56.757]         {
[08:24:56.757]             ...future.startTime <- base::Sys.time()
[08:24:56.757]             {
[08:24:56.757]                 {
[08:24:56.757]                   {
[08:24:56.757]                     {
[08:24:56.757]                       base::local({
[08:24:56.757]                         has_future <- base::requireNamespace("future", 
[08:24:56.757]                           quietly = TRUE)
[08:24:56.757]                         if (has_future) {
[08:24:56.757]                           ns <- base::getNamespace("future")
[08:24:56.757]                           version <- ns[[".package"]][["version"]]
[08:24:56.757]                           if (is.null(version)) 
[08:24:56.757]                             version <- utils::packageVersion("future")
[08:24:56.757]                         }
[08:24:56.757]                         else {
[08:24:56.757]                           version <- NULL
[08:24:56.757]                         }
[08:24:56.757]                         if (!has_future || version < "1.8.0") {
[08:24:56.757]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.757]                             "", base::R.version$version.string), 
[08:24:56.757]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:56.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.757]                               "release", "version")], collapse = " "), 
[08:24:56.757]                             hostname = base::Sys.info()[["nodename"]])
[08:24:56.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.757]                             info)
[08:24:56.757]                           info <- base::paste(info, collapse = "; ")
[08:24:56.757]                           if (!has_future) {
[08:24:56.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.757]                               info)
[08:24:56.757]                           }
[08:24:56.757]                           else {
[08:24:56.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.757]                               info, version)
[08:24:56.757]                           }
[08:24:56.757]                           base::stop(msg)
[08:24:56.757]                         }
[08:24:56.757]                       })
[08:24:56.757]                     }
[08:24:56.757]                     base::local({
[08:24:56.757]                       for (pkg in "stats") {
[08:24:56.757]                         base::loadNamespace(pkg)
[08:24:56.757]                         base::library(pkg, character.only = TRUE)
[08:24:56.757]                       }
[08:24:56.757]                     })
[08:24:56.757]                   }
[08:24:56.757]                   ...future.strategy.old <- future::plan("list")
[08:24:56.757]                   options(future.plan = NULL)
[08:24:56.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.757]                 }
[08:24:56.757]                 ...future.workdir <- getwd()
[08:24:56.757]             }
[08:24:56.757]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.757]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.757]         }
[08:24:56.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.757]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.757]             base::names(...future.oldOptions))
[08:24:56.757]     }
[08:24:56.757]     if (FALSE) {
[08:24:56.757]     }
[08:24:56.757]     else {
[08:24:56.757]         if (TRUE) {
[08:24:56.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.757]                 open = "w")
[08:24:56.757]         }
[08:24:56.757]         else {
[08:24:56.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.757]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.757]         }
[08:24:56.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.757]             base::sink(type = "output", split = FALSE)
[08:24:56.757]             base::close(...future.stdout)
[08:24:56.757]         }, add = TRUE)
[08:24:56.757]     }
[08:24:56.757]     ...future.frame <- base::sys.nframe()
[08:24:56.757]     ...future.conditions <- base::list()
[08:24:56.757]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.757]     if (FALSE) {
[08:24:56.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.757]     }
[08:24:56.757]     ...future.result <- base::tryCatch({
[08:24:56.757]         base::withCallingHandlers({
[08:24:56.757]             ...future.value <- base::withVisible(base::local({
[08:24:56.757]                 do.call(function(...) {
[08:24:56.757]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.757]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.757]                     ...future.globals.maxSize)) {
[08:24:56.757]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.757]                     on.exit(options(oopts), add = TRUE)
[08:24:56.757]                   }
[08:24:56.757]                   {
[08:24:56.757]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.757]                       FUN = function(jj) {
[08:24:56.757]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.757]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.757]                       })
[08:24:56.757]                   }
[08:24:56.757]                 }, args = future.call.arguments)
[08:24:56.757]             }))
[08:24:56.757]             future::FutureResult(value = ...future.value$value, 
[08:24:56.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.757]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.757]                     ...future.globalenv.names))
[08:24:56.757]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.757]         }, condition = base::local({
[08:24:56.757]             c <- base::c
[08:24:56.757]             inherits <- base::inherits
[08:24:56.757]             invokeRestart <- base::invokeRestart
[08:24:56.757]             length <- base::length
[08:24:56.757]             list <- base::list
[08:24:56.757]             seq.int <- base::seq.int
[08:24:56.757]             signalCondition <- base::signalCondition
[08:24:56.757]             sys.calls <- base::sys.calls
[08:24:56.757]             `[[` <- base::`[[`
[08:24:56.757]             `+` <- base::`+`
[08:24:56.757]             `<<-` <- base::`<<-`
[08:24:56.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.757]                   3L)]
[08:24:56.757]             }
[08:24:56.757]             function(cond) {
[08:24:56.757]                 is_error <- inherits(cond, "error")
[08:24:56.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.757]                   NULL)
[08:24:56.757]                 if (is_error) {
[08:24:56.757]                   sessionInformation <- function() {
[08:24:56.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.757]                       search = base::search(), system = base::Sys.info())
[08:24:56.757]                   }
[08:24:56.757]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.757]                     cond$call), session = sessionInformation(), 
[08:24:56.757]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.757]                   signalCondition(cond)
[08:24:56.757]                 }
[08:24:56.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.757]                 "immediateCondition"))) {
[08:24:56.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.757]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.757]                   if (TRUE && !signal) {
[08:24:56.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.757]                     {
[08:24:56.757]                       inherits <- base::inherits
[08:24:56.757]                       invokeRestart <- base::invokeRestart
[08:24:56.757]                       is.null <- base::is.null
[08:24:56.757]                       muffled <- FALSE
[08:24:56.757]                       if (inherits(cond, "message")) {
[08:24:56.757]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.757]                         if (muffled) 
[08:24:56.757]                           invokeRestart("muffleMessage")
[08:24:56.757]                       }
[08:24:56.757]                       else if (inherits(cond, "warning")) {
[08:24:56.757]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.757]                         if (muffled) 
[08:24:56.757]                           invokeRestart("muffleWarning")
[08:24:56.757]                       }
[08:24:56.757]                       else if (inherits(cond, "condition")) {
[08:24:56.757]                         if (!is.null(pattern)) {
[08:24:56.757]                           computeRestarts <- base::computeRestarts
[08:24:56.757]                           grepl <- base::grepl
[08:24:56.757]                           restarts <- computeRestarts(cond)
[08:24:56.757]                           for (restart in restarts) {
[08:24:56.757]                             name <- restart$name
[08:24:56.757]                             if (is.null(name)) 
[08:24:56.757]                               next
[08:24:56.757]                             if (!grepl(pattern, name)) 
[08:24:56.757]                               next
[08:24:56.757]                             invokeRestart(restart)
[08:24:56.757]                             muffled <- TRUE
[08:24:56.757]                             break
[08:24:56.757]                           }
[08:24:56.757]                         }
[08:24:56.757]                       }
[08:24:56.757]                       invisible(muffled)
[08:24:56.757]                     }
[08:24:56.757]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.757]                   }
[08:24:56.757]                 }
[08:24:56.757]                 else {
[08:24:56.757]                   if (TRUE) {
[08:24:56.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.757]                     {
[08:24:56.757]                       inherits <- base::inherits
[08:24:56.757]                       invokeRestart <- base::invokeRestart
[08:24:56.757]                       is.null <- base::is.null
[08:24:56.757]                       muffled <- FALSE
[08:24:56.757]                       if (inherits(cond, "message")) {
[08:24:56.757]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.757]                         if (muffled) 
[08:24:56.757]                           invokeRestart("muffleMessage")
[08:24:56.757]                       }
[08:24:56.757]                       else if (inherits(cond, "warning")) {
[08:24:56.757]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.757]                         if (muffled) 
[08:24:56.757]                           invokeRestart("muffleWarning")
[08:24:56.757]                       }
[08:24:56.757]                       else if (inherits(cond, "condition")) {
[08:24:56.757]                         if (!is.null(pattern)) {
[08:24:56.757]                           computeRestarts <- base::computeRestarts
[08:24:56.757]                           grepl <- base::grepl
[08:24:56.757]                           restarts <- computeRestarts(cond)
[08:24:56.757]                           for (restart in restarts) {
[08:24:56.757]                             name <- restart$name
[08:24:56.757]                             if (is.null(name)) 
[08:24:56.757]                               next
[08:24:56.757]                             if (!grepl(pattern, name)) 
[08:24:56.757]                               next
[08:24:56.757]                             invokeRestart(restart)
[08:24:56.757]                             muffled <- TRUE
[08:24:56.757]                             break
[08:24:56.757]                           }
[08:24:56.757]                         }
[08:24:56.757]                       }
[08:24:56.757]                       invisible(muffled)
[08:24:56.757]                     }
[08:24:56.757]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.757]                   }
[08:24:56.757]                 }
[08:24:56.757]             }
[08:24:56.757]         }))
[08:24:56.757]     }, error = function(ex) {
[08:24:56.757]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.757]                 ...future.rng), started = ...future.startTime, 
[08:24:56.757]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.757]             version = "1.8"), class = "FutureResult")
[08:24:56.757]     }, finally = {
[08:24:56.757]         if (!identical(...future.workdir, getwd())) 
[08:24:56.757]             setwd(...future.workdir)
[08:24:56.757]         {
[08:24:56.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.757]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.757]             }
[08:24:56.757]             base::options(...future.oldOptions)
[08:24:56.757]             if (.Platform$OS.type == "windows") {
[08:24:56.757]                 old_names <- names(...future.oldEnvVars)
[08:24:56.757]                 envs <- base::Sys.getenv()
[08:24:56.757]                 names <- names(envs)
[08:24:56.757]                 common <- intersect(names, old_names)
[08:24:56.757]                 added <- setdiff(names, old_names)
[08:24:56.757]                 removed <- setdiff(old_names, names)
[08:24:56.757]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.757]                   envs[common]]
[08:24:56.757]                 NAMES <- toupper(changed)
[08:24:56.757]                 args <- list()
[08:24:56.757]                 for (kk in seq_along(NAMES)) {
[08:24:56.757]                   name <- changed[[kk]]
[08:24:56.757]                   NAME <- NAMES[[kk]]
[08:24:56.757]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.757]                     next
[08:24:56.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.757]                 }
[08:24:56.757]                 NAMES <- toupper(added)
[08:24:56.757]                 for (kk in seq_along(NAMES)) {
[08:24:56.757]                   name <- added[[kk]]
[08:24:56.757]                   NAME <- NAMES[[kk]]
[08:24:56.757]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.757]                     next
[08:24:56.757]                   args[[name]] <- ""
[08:24:56.757]                 }
[08:24:56.757]                 NAMES <- toupper(removed)
[08:24:56.757]                 for (kk in seq_along(NAMES)) {
[08:24:56.757]                   name <- removed[[kk]]
[08:24:56.757]                   NAME <- NAMES[[kk]]
[08:24:56.757]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.757]                     next
[08:24:56.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.757]                 }
[08:24:56.757]                 if (length(args) > 0) 
[08:24:56.757]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.757]             }
[08:24:56.757]             else {
[08:24:56.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.757]             }
[08:24:56.757]             {
[08:24:56.757]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.757]                   0L) {
[08:24:56.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.757]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.757]                   base::options(opts)
[08:24:56.757]                 }
[08:24:56.757]                 {
[08:24:56.757]                   {
[08:24:56.757]                     NULL
[08:24:56.757]                     RNGkind("Mersenne-Twister")
[08:24:56.757]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.757]                       inherits = FALSE)
[08:24:56.757]                   }
[08:24:56.757]                   options(future.plan = NULL)
[08:24:56.757]                   if (is.na(NA_character_)) 
[08:24:56.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.757]                     .init = FALSE)
[08:24:56.757]                 }
[08:24:56.757]             }
[08:24:56.757]         }
[08:24:56.757]     })
[08:24:56.757]     if (TRUE) {
[08:24:56.757]         base::sink(type = "output", split = FALSE)
[08:24:56.757]         if (TRUE) {
[08:24:56.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.757]         }
[08:24:56.757]         else {
[08:24:56.757]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.757]         }
[08:24:56.757]         base::close(...future.stdout)
[08:24:56.757]         ...future.stdout <- NULL
[08:24:56.757]     }
[08:24:56.757]     ...future.result$conditions <- ...future.conditions
[08:24:56.757]     ...future.result$finished <- base::Sys.time()
[08:24:56.757]     ...future.result
[08:24:56.757] }
[08:24:56.759] assign_globals() ...
[08:24:56.759] List of 7
[08:24:56.759]  $ ...future.FUN            :function (x)  
[08:24:56.759]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:56.759]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.759]  $ future.call.arguments    : list()
[08:24:56.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.759]  $ ...future.elements_ii    :List of 3
[08:24:56.759]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.759]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.759]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.759]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.759]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.759]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.759]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.759]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:56.759]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.759]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.759]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.759]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:56.759]  $ ...future.seeds_ii       : NULL
[08:24:56.759]  $ ...future.globals.maxSize: NULL
[08:24:56.759]  - attr(*, "where")=List of 7
[08:24:56.759]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.759]   ..$ breaks                   :<environment: R_EmptyEnv> 
[08:24:56.759]   ..$ wool                     :<environment: R_EmptyEnv> 
[08:24:56.759]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.759]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.759]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.759]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.759]  - attr(*, "resolved")= logi FALSE
[08:24:56.759]  - attr(*, "total_size")= num 18867
[08:24:56.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.759]  - attr(*, "already-done")= logi TRUE
[08:24:56.771] - reassign environment for ‘...future.FUN’
[08:24:56.771] - copied ‘...future.FUN’ to environment
[08:24:56.771] - copied ‘breaks’ to environment
[08:24:56.771] - copied ‘wool’ to environment
[08:24:56.771] - copied ‘future.call.arguments’ to environment
[08:24:56.771] - copied ‘...future.elements_ii’ to environment
[08:24:56.771] - copied ‘...future.seeds_ii’ to environment
[08:24:56.771] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.772] assign_globals() ... done
[08:24:56.772] plan(): Setting new future strategy stack:
[08:24:56.772] List of future strategies:
[08:24:56.772] 1. sequential:
[08:24:56.772]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.772]    - tweaked: FALSE
[08:24:56.772]    - call: NULL
[08:24:56.773] plan(): nbrOfWorkers() = 1
[08:24:56.776] plan(): Setting new future strategy stack:
[08:24:56.776] List of future strategies:
[08:24:56.776] 1. multicore:
[08:24:56.776]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:56.776]    - tweaked: FALSE
[08:24:56.776]    - call: plan(strategy)
[08:24:56.777] plan(): nbrOfWorkers() = 1
[08:24:56.778] SequentialFuture started (and completed)
[08:24:56.778] - Launch lazy future ... done
[08:24:56.778] run() for ‘SequentialFuture’ ... done
[08:24:56.778] Created future:
[08:24:56.778] SequentialFuture:
[08:24:56.778] Label: ‘future_by-1’
[08:24:56.778] Expression:
[08:24:56.778] {
[08:24:56.778]     do.call(function(...) {
[08:24:56.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.778]             on.exit(options(oopts), add = TRUE)
[08:24:56.778]         }
[08:24:56.778]         {
[08:24:56.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.778]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.778]             })
[08:24:56.778]         }
[08:24:56.778]     }, args = future.call.arguments)
[08:24:56.778] }
[08:24:56.778] Lazy evaluation: FALSE
[08:24:56.778] Asynchronous evaluation: FALSE
[08:24:56.778] Local evaluation: TRUE
[08:24:56.778] Environment: 0x557b27eb9e68
[08:24:56.778] Capture standard output: TRUE
[08:24:56.778] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.778] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[08:24:56.778] Packages: 1 packages (‘stats’)
[08:24:56.778] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.778] Resolved: TRUE
[08:24:56.778] Value: 82.82 KiB of class ‘list’
[08:24:56.778] Early signaling: FALSE
[08:24:56.778] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.778] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.780] Chunk #1 of 1 ... DONE
[08:24:56.780] Launching 1 futures (chunks) ... DONE
[08:24:56.780] Resolving 1 futures (chunks) ...
[08:24:56.780] resolve() on list ...
[08:24:56.780]  recursive: 0
[08:24:56.780]  length: 1
[08:24:56.780] 
[08:24:56.780] resolved() for ‘SequentialFuture’ ...
[08:24:56.780] - state: ‘finished’
[08:24:56.780] - run: TRUE
[08:24:56.781] - result: ‘FutureResult’
[08:24:56.781] resolved() for ‘SequentialFuture’ ... done
[08:24:56.781] Future #1
[08:24:56.781] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.781] - nx: 1
[08:24:56.781] - relay: TRUE
[08:24:56.781] - stdout: TRUE
[08:24:56.781] - signal: TRUE
[08:24:56.781] - resignal: FALSE
[08:24:56.781] - force: TRUE
[08:24:56.781] - relayed: [n=1] FALSE
[08:24:56.782] - queued futures: [n=1] FALSE
[08:24:56.782]  - until=1
[08:24:56.782]  - relaying element #1
[08:24:56.782] - relayed: [n=1] TRUE
[08:24:56.782] - queued futures: [n=1] TRUE
[08:24:56.782] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.782]  length: 0 (resolved future 1)
[08:24:56.782] Relaying remaining futures
[08:24:56.782] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.782] - nx: 1
[08:24:56.783] - relay: TRUE
[08:24:56.783] - stdout: TRUE
[08:24:56.783] - signal: TRUE
[08:24:56.783] - resignal: FALSE
[08:24:56.783] - force: TRUE
[08:24:56.783] - relayed: [n=1] TRUE
[08:24:56.783] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.783] - relayed: [n=1] TRUE
[08:24:56.783] - queued futures: [n=1] TRUE
[08:24:56.783] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.783] resolve() on list ... DONE
[08:24:56.784]  - Number of value chunks collected: 1
[08:24:56.784] Resolving 1 futures (chunks) ... DONE
[08:24:56.784] Reducing values from 1 chunks ...
[08:24:56.784]  - Number of values collected after concatenation: 3
[08:24:56.784]  - Number of values expected: 3
[08:24:56.784] Reducing values from 1 chunks ... DONE
[08:24:56.784] future_lapply() ... DONE
[08:24:56.784] future_by_internal() ... DONE
[08:24:56.785] future_by_internal() ...
[08:24:56.785] future_lapply() ...
[08:24:56.787] Number of chunks: 1
[08:24:56.787] getGlobalsAndPackagesXApply() ...
[08:24:56.787]  - future.globals: TRUE
[08:24:56.787] getGlobalsAndPackages() ...
[08:24:56.787] Searching for globals...
[08:24:56.788] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.789] Searching for globals ... DONE
[08:24:56.789] Resolving globals: FALSE
[08:24:56.789] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.789] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.789] - globals: [1] ‘FUN’
[08:24:56.790] 
[08:24:56.790] getGlobalsAndPackages() ... DONE
[08:24:56.790]  - globals found/used: [n=1] ‘FUN’
[08:24:56.790]  - needed namespaces: [n=0] 
[08:24:56.790] Finding globals ... DONE
[08:24:56.790]  - use_args: TRUE
[08:24:56.790]  - Getting '...' globals ...
[08:24:56.790] resolve() on list ...
[08:24:56.791]  recursive: 0
[08:24:56.791]  length: 1
[08:24:56.791]  elements: ‘...’
[08:24:56.791]  length: 0 (resolved future 1)
[08:24:56.791] resolve() on list ... DONE
[08:24:56.791]    - '...' content: [n=0] 
[08:24:56.791] List of 1
[08:24:56.791]  $ ...: list()
[08:24:56.791]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.791]  - attr(*, "where")=List of 1
[08:24:56.791]   ..$ ...:<environment: 0x557b281289b8> 
[08:24:56.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.791]  - attr(*, "resolved")= logi TRUE
[08:24:56.791]  - attr(*, "total_size")= num NA
[08:24:56.796]  - Getting '...' globals ... DONE
[08:24:56.796] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.796] List of 2
[08:24:56.796]  $ ...future.FUN:function (object, ...)  
[08:24:56.796]  $ ...          : list()
[08:24:56.796]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.796]  - attr(*, "where")=List of 2
[08:24:56.796]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.796]   ..$ ...          :<environment: 0x557b281289b8> 
[08:24:56.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.796]  - attr(*, "resolved")= logi FALSE
[08:24:56.796]  - attr(*, "total_size")= num 19278
[08:24:56.799] Packages to be attached in all futures: [n=0] 
[08:24:56.799] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.799] Number of futures (= number of chunks): 1
[08:24:56.799] Launching 1 futures (chunks) ...
[08:24:56.799] Chunk #1 of 1 ...
[08:24:56.800]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.800] getGlobalsAndPackages() ...
[08:24:56.800] Searching for globals...
[08:24:56.800] 
[08:24:56.800] Searching for globals ... DONE
[08:24:56.800] - globals: [0] <none>
[08:24:56.801] getGlobalsAndPackages() ... DONE
[08:24:56.801]    + additional globals found: [n=0] 
[08:24:56.801]    + additional namespaces needed: [n=0] 
[08:24:56.801]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.801]  - seeds: <none>
[08:24:56.801]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.801] getGlobalsAndPackages() ...
[08:24:56.801] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.801] Resolving globals: FALSE
[08:24:56.801] Tweak future expression to call with '...' arguments ...
[08:24:56.801] {
[08:24:56.801]     do.call(function(...) {
[08:24:56.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.801]             on.exit(options(oopts), add = TRUE)
[08:24:56.801]         }
[08:24:56.801]         {
[08:24:56.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.801]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.801]             })
[08:24:56.801]         }
[08:24:56.801]     }, args = future.call.arguments)
[08:24:56.801] }
[08:24:56.802] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.802] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.802] 
[08:24:56.802] getGlobalsAndPackages() ... DONE
[08:24:56.803] run() for ‘Future’ ...
[08:24:56.803] - state: ‘created’
[08:24:56.803] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:56.805] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.805]   - Field: ‘label’
[08:24:56.805]   - Field: ‘local’
[08:24:56.805]   - Field: ‘owner’
[08:24:56.805]   - Field: ‘envir’
[08:24:56.805]   - Field: ‘packages’
[08:24:56.805]   - Field: ‘gc’
[08:24:56.805]   - Field: ‘conditions’
[08:24:56.806]   - Field: ‘expr’
[08:24:56.806]   - Field: ‘uuid’
[08:24:56.806]   - Field: ‘seed’
[08:24:56.806]   - Field: ‘version’
[08:24:56.806]   - Field: ‘result’
[08:24:56.806]   - Field: ‘asynchronous’
[08:24:56.806]   - Field: ‘calls’
[08:24:56.806]   - Field: ‘globals’
[08:24:56.806]   - Field: ‘stdout’
[08:24:56.806]   - Field: ‘earlySignal’
[08:24:56.806]   - Field: ‘lazy’
[08:24:56.806]   - Field: ‘state’
[08:24:56.807] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.807] - Launch lazy future ...
[08:24:56.807] Packages needed by the future expression (n = 0): <none>
[08:24:56.807] Packages needed by future strategies (n = 0): <none>
[08:24:56.807] {
[08:24:56.807]     {
[08:24:56.807]         {
[08:24:56.807]             ...future.startTime <- base::Sys.time()
[08:24:56.807]             {
[08:24:56.807]                 {
[08:24:56.807]                   {
[08:24:56.807]                     base::local({
[08:24:56.807]                       has_future <- base::requireNamespace("future", 
[08:24:56.807]                         quietly = TRUE)
[08:24:56.807]                       if (has_future) {
[08:24:56.807]                         ns <- base::getNamespace("future")
[08:24:56.807]                         version <- ns[[".package"]][["version"]]
[08:24:56.807]                         if (is.null(version)) 
[08:24:56.807]                           version <- utils::packageVersion("future")
[08:24:56.807]                       }
[08:24:56.807]                       else {
[08:24:56.807]                         version <- NULL
[08:24:56.807]                       }
[08:24:56.807]                       if (!has_future || version < "1.8.0") {
[08:24:56.807]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.807]                           "", base::R.version$version.string), 
[08:24:56.807]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.807]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.807]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.807]                             "release", "version")], collapse = " "), 
[08:24:56.807]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.807]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.807]                           info)
[08:24:56.807]                         info <- base::paste(info, collapse = "; ")
[08:24:56.807]                         if (!has_future) {
[08:24:56.807]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.807]                             info)
[08:24:56.807]                         }
[08:24:56.807]                         else {
[08:24:56.807]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.807]                             info, version)
[08:24:56.807]                         }
[08:24:56.807]                         base::stop(msg)
[08:24:56.807]                       }
[08:24:56.807]                     })
[08:24:56.807]                   }
[08:24:56.807]                   ...future.strategy.old <- future::plan("list")
[08:24:56.807]                   options(future.plan = NULL)
[08:24:56.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.807]                 }
[08:24:56.807]                 ...future.workdir <- getwd()
[08:24:56.807]             }
[08:24:56.807]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.807]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.807]         }
[08:24:56.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.807]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.807]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.807]             base::names(...future.oldOptions))
[08:24:56.807]     }
[08:24:56.807]     if (FALSE) {
[08:24:56.807]     }
[08:24:56.807]     else {
[08:24:56.807]         if (TRUE) {
[08:24:56.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.807]                 open = "w")
[08:24:56.807]         }
[08:24:56.807]         else {
[08:24:56.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.807]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.807]         }
[08:24:56.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.807]             base::sink(type = "output", split = FALSE)
[08:24:56.807]             base::close(...future.stdout)
[08:24:56.807]         }, add = TRUE)
[08:24:56.807]     }
[08:24:56.807]     ...future.frame <- base::sys.nframe()
[08:24:56.807]     ...future.conditions <- base::list()
[08:24:56.807]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.807]     if (FALSE) {
[08:24:56.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.807]     }
[08:24:56.807]     ...future.result <- base::tryCatch({
[08:24:56.807]         base::withCallingHandlers({
[08:24:56.807]             ...future.value <- base::withVisible(base::local({
[08:24:56.807]                 do.call(function(...) {
[08:24:56.807]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.807]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.807]                     ...future.globals.maxSize)) {
[08:24:56.807]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.807]                     on.exit(options(oopts), add = TRUE)
[08:24:56.807]                   }
[08:24:56.807]                   {
[08:24:56.807]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.807]                       FUN = function(jj) {
[08:24:56.807]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.807]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.807]                       })
[08:24:56.807]                   }
[08:24:56.807]                 }, args = future.call.arguments)
[08:24:56.807]             }))
[08:24:56.807]             future::FutureResult(value = ...future.value$value, 
[08:24:56.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.807]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.807]                     ...future.globalenv.names))
[08:24:56.807]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.807]         }, condition = base::local({
[08:24:56.807]             c <- base::c
[08:24:56.807]             inherits <- base::inherits
[08:24:56.807]             invokeRestart <- base::invokeRestart
[08:24:56.807]             length <- base::length
[08:24:56.807]             list <- base::list
[08:24:56.807]             seq.int <- base::seq.int
[08:24:56.807]             signalCondition <- base::signalCondition
[08:24:56.807]             sys.calls <- base::sys.calls
[08:24:56.807]             `[[` <- base::`[[`
[08:24:56.807]             `+` <- base::`+`
[08:24:56.807]             `<<-` <- base::`<<-`
[08:24:56.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.807]                   3L)]
[08:24:56.807]             }
[08:24:56.807]             function(cond) {
[08:24:56.807]                 is_error <- inherits(cond, "error")
[08:24:56.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.807]                   NULL)
[08:24:56.807]                 if (is_error) {
[08:24:56.807]                   sessionInformation <- function() {
[08:24:56.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.807]                       search = base::search(), system = base::Sys.info())
[08:24:56.807]                   }
[08:24:56.807]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.807]                     cond$call), session = sessionInformation(), 
[08:24:56.807]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.807]                   signalCondition(cond)
[08:24:56.807]                 }
[08:24:56.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.807]                 "immediateCondition"))) {
[08:24:56.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.807]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.807]                   if (TRUE && !signal) {
[08:24:56.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.807]                     {
[08:24:56.807]                       inherits <- base::inherits
[08:24:56.807]                       invokeRestart <- base::invokeRestart
[08:24:56.807]                       is.null <- base::is.null
[08:24:56.807]                       muffled <- FALSE
[08:24:56.807]                       if (inherits(cond, "message")) {
[08:24:56.807]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.807]                         if (muffled) 
[08:24:56.807]                           invokeRestart("muffleMessage")
[08:24:56.807]                       }
[08:24:56.807]                       else if (inherits(cond, "warning")) {
[08:24:56.807]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.807]                         if (muffled) 
[08:24:56.807]                           invokeRestart("muffleWarning")
[08:24:56.807]                       }
[08:24:56.807]                       else if (inherits(cond, "condition")) {
[08:24:56.807]                         if (!is.null(pattern)) {
[08:24:56.807]                           computeRestarts <- base::computeRestarts
[08:24:56.807]                           grepl <- base::grepl
[08:24:56.807]                           restarts <- computeRestarts(cond)
[08:24:56.807]                           for (restart in restarts) {
[08:24:56.807]                             name <- restart$name
[08:24:56.807]                             if (is.null(name)) 
[08:24:56.807]                               next
[08:24:56.807]                             if (!grepl(pattern, name)) 
[08:24:56.807]                               next
[08:24:56.807]                             invokeRestart(restart)
[08:24:56.807]                             muffled <- TRUE
[08:24:56.807]                             break
[08:24:56.807]                           }
[08:24:56.807]                         }
[08:24:56.807]                       }
[08:24:56.807]                       invisible(muffled)
[08:24:56.807]                     }
[08:24:56.807]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.807]                   }
[08:24:56.807]                 }
[08:24:56.807]                 else {
[08:24:56.807]                   if (TRUE) {
[08:24:56.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.807]                     {
[08:24:56.807]                       inherits <- base::inherits
[08:24:56.807]                       invokeRestart <- base::invokeRestart
[08:24:56.807]                       is.null <- base::is.null
[08:24:56.807]                       muffled <- FALSE
[08:24:56.807]                       if (inherits(cond, "message")) {
[08:24:56.807]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.807]                         if (muffled) 
[08:24:56.807]                           invokeRestart("muffleMessage")
[08:24:56.807]                       }
[08:24:56.807]                       else if (inherits(cond, "warning")) {
[08:24:56.807]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.807]                         if (muffled) 
[08:24:56.807]                           invokeRestart("muffleWarning")
[08:24:56.807]                       }
[08:24:56.807]                       else if (inherits(cond, "condition")) {
[08:24:56.807]                         if (!is.null(pattern)) {
[08:24:56.807]                           computeRestarts <- base::computeRestarts
[08:24:56.807]                           grepl <- base::grepl
[08:24:56.807]                           restarts <- computeRestarts(cond)
[08:24:56.807]                           for (restart in restarts) {
[08:24:56.807]                             name <- restart$name
[08:24:56.807]                             if (is.null(name)) 
[08:24:56.807]                               next
[08:24:56.807]                             if (!grepl(pattern, name)) 
[08:24:56.807]                               next
[08:24:56.807]                             invokeRestart(restart)
[08:24:56.807]                             muffled <- TRUE
[08:24:56.807]                             break
[08:24:56.807]                           }
[08:24:56.807]                         }
[08:24:56.807]                       }
[08:24:56.807]                       invisible(muffled)
[08:24:56.807]                     }
[08:24:56.807]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.807]                   }
[08:24:56.807]                 }
[08:24:56.807]             }
[08:24:56.807]         }))
[08:24:56.807]     }, error = function(ex) {
[08:24:56.807]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.807]                 ...future.rng), started = ...future.startTime, 
[08:24:56.807]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.807]             version = "1.8"), class = "FutureResult")
[08:24:56.807]     }, finally = {
[08:24:56.807]         if (!identical(...future.workdir, getwd())) 
[08:24:56.807]             setwd(...future.workdir)
[08:24:56.807]         {
[08:24:56.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.807]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.807]             }
[08:24:56.807]             base::options(...future.oldOptions)
[08:24:56.807]             if (.Platform$OS.type == "windows") {
[08:24:56.807]                 old_names <- names(...future.oldEnvVars)
[08:24:56.807]                 envs <- base::Sys.getenv()
[08:24:56.807]                 names <- names(envs)
[08:24:56.807]                 common <- intersect(names, old_names)
[08:24:56.807]                 added <- setdiff(names, old_names)
[08:24:56.807]                 removed <- setdiff(old_names, names)
[08:24:56.807]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.807]                   envs[common]]
[08:24:56.807]                 NAMES <- toupper(changed)
[08:24:56.807]                 args <- list()
[08:24:56.807]                 for (kk in seq_along(NAMES)) {
[08:24:56.807]                   name <- changed[[kk]]
[08:24:56.807]                   NAME <- NAMES[[kk]]
[08:24:56.807]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.807]                     next
[08:24:56.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.807]                 }
[08:24:56.807]                 NAMES <- toupper(added)
[08:24:56.807]                 for (kk in seq_along(NAMES)) {
[08:24:56.807]                   name <- added[[kk]]
[08:24:56.807]                   NAME <- NAMES[[kk]]
[08:24:56.807]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.807]                     next
[08:24:56.807]                   args[[name]] <- ""
[08:24:56.807]                 }
[08:24:56.807]                 NAMES <- toupper(removed)
[08:24:56.807]                 for (kk in seq_along(NAMES)) {
[08:24:56.807]                   name <- removed[[kk]]
[08:24:56.807]                   NAME <- NAMES[[kk]]
[08:24:56.807]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.807]                     next
[08:24:56.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.807]                 }
[08:24:56.807]                 if (length(args) > 0) 
[08:24:56.807]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.807]             }
[08:24:56.807]             else {
[08:24:56.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.807]             }
[08:24:56.807]             {
[08:24:56.807]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.807]                   0L) {
[08:24:56.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.807]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.807]                   base::options(opts)
[08:24:56.807]                 }
[08:24:56.807]                 {
[08:24:56.807]                   {
[08:24:56.807]                     NULL
[08:24:56.807]                     RNGkind("Mersenne-Twister")
[08:24:56.807]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.807]                       inherits = FALSE)
[08:24:56.807]                   }
[08:24:56.807]                   options(future.plan = NULL)
[08:24:56.807]                   if (is.na(NA_character_)) 
[08:24:56.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.807]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.807]                     .init = FALSE)
[08:24:56.807]                 }
[08:24:56.807]             }
[08:24:56.807]         }
[08:24:56.807]     })
[08:24:56.807]     if (TRUE) {
[08:24:56.807]         base::sink(type = "output", split = FALSE)
[08:24:56.807]         if (TRUE) {
[08:24:56.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.807]         }
[08:24:56.807]         else {
[08:24:56.807]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.807]         }
[08:24:56.807]         base::close(...future.stdout)
[08:24:56.807]         ...future.stdout <- NULL
[08:24:56.807]     }
[08:24:56.807]     ...future.result$conditions <- ...future.conditions
[08:24:56.807]     ...future.result$finished <- base::Sys.time()
[08:24:56.807]     ...future.result
[08:24:56.807] }
[08:24:56.809] assign_globals() ...
[08:24:56.809] List of 5
[08:24:56.809]  $ ...future.FUN            :function (object, ...)  
[08:24:56.809]  $ future.call.arguments    : list()
[08:24:56.809]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.809]  $ ...future.elements_ii    :List of 3
[08:24:56.809]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.809]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.809]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.809]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.809]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.809]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.809]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.809]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:56.809]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.809]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.809]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.809]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:56.809]  $ ...future.seeds_ii       : NULL
[08:24:56.809]  $ ...future.globals.maxSize: NULL
[08:24:56.809]  - attr(*, "where")=List of 5
[08:24:56.809]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.809]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.809]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.809]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.809]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.809]  - attr(*, "resolved")= logi FALSE
[08:24:56.809]  - attr(*, "total_size")= num 19278
[08:24:56.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.809]  - attr(*, "already-done")= logi TRUE
[08:24:56.820] - copied ‘...future.FUN’ to environment
[08:24:56.820] - copied ‘future.call.arguments’ to environment
[08:24:56.820] - copied ‘...future.elements_ii’ to environment
[08:24:56.821] - copied ‘...future.seeds_ii’ to environment
[08:24:56.821] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.821] assign_globals() ... done
[08:24:56.821] plan(): Setting new future strategy stack:
[08:24:56.821] List of future strategies:
[08:24:56.821] 1. sequential:
[08:24:56.821]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.821]    - tweaked: FALSE
[08:24:56.821]    - call: NULL
[08:24:56.822] plan(): nbrOfWorkers() = 1
[08:24:56.824] plan(): Setting new future strategy stack:
[08:24:56.824] List of future strategies:
[08:24:56.824] 1. multicore:
[08:24:56.824]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:56.824]    - tweaked: FALSE
[08:24:56.824]    - call: plan(strategy)
[08:24:56.826] plan(): nbrOfWorkers() = 1
[08:24:56.826] SequentialFuture started (and completed)
[08:24:56.826] - Launch lazy future ... done
[08:24:56.826] run() for ‘SequentialFuture’ ... done
[08:24:56.826] Created future:
[08:24:56.826] SequentialFuture:
[08:24:56.826] Label: ‘future_by-1’
[08:24:56.826] Expression:
[08:24:56.826] {
[08:24:56.826]     do.call(function(...) {
[08:24:56.826]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.826]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.826]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.826]             on.exit(options(oopts), add = TRUE)
[08:24:56.826]         }
[08:24:56.826]         {
[08:24:56.826]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.826]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.826]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.826]             })
[08:24:56.826]         }
[08:24:56.826]     }, args = future.call.arguments)
[08:24:56.826] }
[08:24:56.826] Lazy evaluation: FALSE
[08:24:56.826] Asynchronous evaluation: FALSE
[08:24:56.826] Local evaluation: TRUE
[08:24:56.826] Environment: 0x557b280f9400
[08:24:56.826] Capture standard output: TRUE
[08:24:56.826] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.826] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.826] Packages: <none>
[08:24:56.826] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.826] Resolved: TRUE
[08:24:56.826] Value: 1.39 KiB of class ‘list’
[08:24:56.826] Early signaling: FALSE
[08:24:56.826] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.826] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.827] Chunk #1 of 1 ... DONE
[08:24:56.827] Launching 1 futures (chunks) ... DONE
[08:24:56.828] Resolving 1 futures (chunks) ...
[08:24:56.828] resolve() on list ...
[08:24:56.828]  recursive: 0
[08:24:56.828]  length: 1
[08:24:56.828] 
[08:24:56.828] resolved() for ‘SequentialFuture’ ...
[08:24:56.828] - state: ‘finished’
[08:24:56.828] - run: TRUE
[08:24:56.828] - result: ‘FutureResult’
[08:24:56.828] resolved() for ‘SequentialFuture’ ... done
[08:24:56.829] Future #1
[08:24:56.829] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.829] - nx: 1
[08:24:56.829] - relay: TRUE
[08:24:56.829] - stdout: TRUE
[08:24:56.829] - signal: TRUE
[08:24:56.829] - resignal: FALSE
[08:24:56.829] - force: TRUE
[08:24:56.829] - relayed: [n=1] FALSE
[08:24:56.829] - queued futures: [n=1] FALSE
[08:24:56.829]  - until=1
[08:24:56.830]  - relaying element #1
[08:24:56.830] - relayed: [n=1] TRUE
[08:24:56.830] - queued futures: [n=1] TRUE
[08:24:56.830] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.830]  length: 0 (resolved future 1)
[08:24:56.830] Relaying remaining futures
[08:24:56.830] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.830] - nx: 1
[08:24:56.830] - relay: TRUE
[08:24:56.830] - stdout: TRUE
[08:24:56.831] - signal: TRUE
[08:24:56.831] - resignal: FALSE
[08:24:56.831] - force: TRUE
[08:24:56.831] - relayed: [n=1] TRUE
[08:24:56.831] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.831] - relayed: [n=1] TRUE
[08:24:56.831] - queued futures: [n=1] TRUE
[08:24:56.831] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.831] resolve() on list ... DONE
[08:24:56.831]  - Number of value chunks collected: 1
[08:24:56.832] Resolving 1 futures (chunks) ... DONE
[08:24:56.832] Reducing values from 1 chunks ...
[08:24:56.832]  - Number of values collected after concatenation: 3
[08:24:56.832]  - Number of values expected: 3
[08:24:56.832] Reducing values from 1 chunks ... DONE
[08:24:56.832] future_lapply() ... DONE
[08:24:56.832] future_by_internal() ... DONE
[08:24:56.833] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[08:24:56.833] future_lapply() ...
[08:24:56.835] Number of chunks: 1
[08:24:56.835] getGlobalsAndPackagesXApply() ...
[08:24:56.835]  - future.globals: TRUE
[08:24:56.836] getGlobalsAndPackages() ...
[08:24:56.836] Searching for globals...
[08:24:56.837] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.837] Searching for globals ... DONE
[08:24:56.837] Resolving globals: FALSE
[08:24:56.837] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.838] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.838] - globals: [1] ‘FUN’
[08:24:56.838] 
[08:24:56.838] getGlobalsAndPackages() ... DONE
[08:24:56.838]  - globals found/used: [n=1] ‘FUN’
[08:24:56.838]  - needed namespaces: [n=0] 
[08:24:56.838] Finding globals ... DONE
[08:24:56.838]  - use_args: TRUE
[08:24:56.838]  - Getting '...' globals ...
[08:24:56.839] resolve() on list ...
[08:24:56.839]  recursive: 0
[08:24:56.839]  length: 1
[08:24:56.839]  elements: ‘...’
[08:24:56.839]  length: 0 (resolved future 1)
[08:24:56.839] resolve() on list ... DONE
[08:24:56.839]    - '...' content: [n=0] 
[08:24:56.839] List of 1
[08:24:56.839]  $ ...: list()
[08:24:56.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.839]  - attr(*, "where")=List of 1
[08:24:56.839]   ..$ ...:<environment: 0x557b27f8c998> 
[08:24:56.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.839]  - attr(*, "resolved")= logi TRUE
[08:24:56.839]  - attr(*, "total_size")= num NA
[08:24:56.844]  - Getting '...' globals ... DONE
[08:24:56.844] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.844] List of 2
[08:24:56.844]  $ ...future.FUN:function (object, ...)  
[08:24:56.844]  $ ...          : list()
[08:24:56.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.844]  - attr(*, "where")=List of 2
[08:24:56.844]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.844]   ..$ ...          :<environment: 0x557b27f8c998> 
[08:24:56.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.844]  - attr(*, "resolved")= logi FALSE
[08:24:56.844]  - attr(*, "total_size")= num 18647
[08:24:56.847] Packages to be attached in all futures: [n=0] 
[08:24:56.847] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.847] Number of futures (= number of chunks): 1
[08:24:56.847] Launching 1 futures (chunks) ...
[08:24:56.848] Chunk #1 of 1 ...
[08:24:56.848]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.848] getGlobalsAndPackages() ...
[08:24:56.848] Searching for globals...
[08:24:56.848] 
[08:24:56.848] Searching for globals ... DONE
[08:24:56.849] - globals: [0] <none>
[08:24:56.849] getGlobalsAndPackages() ... DONE
[08:24:56.849]    + additional globals found: [n=0] 
[08:24:56.849]    + additional namespaces needed: [n=0] 
[08:24:56.849]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.849]  - seeds: <none>
[08:24:56.849]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.849] getGlobalsAndPackages() ...
[08:24:56.849] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.849] Resolving globals: FALSE
[08:24:56.849] Tweak future expression to call with '...' arguments ...
[08:24:56.850] {
[08:24:56.850]     do.call(function(...) {
[08:24:56.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.850]             on.exit(options(oopts), add = TRUE)
[08:24:56.850]         }
[08:24:56.850]         {
[08:24:56.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.850]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.850]             })
[08:24:56.850]         }
[08:24:56.850]     }, args = future.call.arguments)
[08:24:56.850] }
[08:24:56.850] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.850] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.850] 
[08:24:56.850] getGlobalsAndPackages() ... DONE
[08:24:56.851] run() for ‘Future’ ...
[08:24:56.851] - state: ‘created’
[08:24:56.851] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:56.853] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.853] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.853]   - Field: ‘label’
[08:24:56.853]   - Field: ‘local’
[08:24:56.853]   - Field: ‘owner’
[08:24:56.853]   - Field: ‘envir’
[08:24:56.853]   - Field: ‘packages’
[08:24:56.853]   - Field: ‘gc’
[08:24:56.853]   - Field: ‘conditions’
[08:24:56.854]   - Field: ‘expr’
[08:24:56.854]   - Field: ‘uuid’
[08:24:56.854]   - Field: ‘seed’
[08:24:56.854]   - Field: ‘version’
[08:24:56.854]   - Field: ‘result’
[08:24:56.854]   - Field: ‘asynchronous’
[08:24:56.854]   - Field: ‘calls’
[08:24:56.854]   - Field: ‘globals’
[08:24:56.854]   - Field: ‘stdout’
[08:24:56.854]   - Field: ‘earlySignal’
[08:24:56.854]   - Field: ‘lazy’
[08:24:56.855]   - Field: ‘state’
[08:24:56.855] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.855] - Launch lazy future ...
[08:24:56.855] Packages needed by the future expression (n = 0): <none>
[08:24:56.855] Packages needed by future strategies (n = 0): <none>
[08:24:56.856] {
[08:24:56.856]     {
[08:24:56.856]         {
[08:24:56.856]             ...future.startTime <- base::Sys.time()
[08:24:56.856]             {
[08:24:56.856]                 {
[08:24:56.856]                   {
[08:24:56.856]                     base::local({
[08:24:56.856]                       has_future <- base::requireNamespace("future", 
[08:24:56.856]                         quietly = TRUE)
[08:24:56.856]                       if (has_future) {
[08:24:56.856]                         ns <- base::getNamespace("future")
[08:24:56.856]                         version <- ns[[".package"]][["version"]]
[08:24:56.856]                         if (is.null(version)) 
[08:24:56.856]                           version <- utils::packageVersion("future")
[08:24:56.856]                       }
[08:24:56.856]                       else {
[08:24:56.856]                         version <- NULL
[08:24:56.856]                       }
[08:24:56.856]                       if (!has_future || version < "1.8.0") {
[08:24:56.856]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.856]                           "", base::R.version$version.string), 
[08:24:56.856]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.856]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.856]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.856]                             "release", "version")], collapse = " "), 
[08:24:56.856]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.856]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.856]                           info)
[08:24:56.856]                         info <- base::paste(info, collapse = "; ")
[08:24:56.856]                         if (!has_future) {
[08:24:56.856]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.856]                             info)
[08:24:56.856]                         }
[08:24:56.856]                         else {
[08:24:56.856]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.856]                             info, version)
[08:24:56.856]                         }
[08:24:56.856]                         base::stop(msg)
[08:24:56.856]                       }
[08:24:56.856]                     })
[08:24:56.856]                   }
[08:24:56.856]                   ...future.strategy.old <- future::plan("list")
[08:24:56.856]                   options(future.plan = NULL)
[08:24:56.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.856]                 }
[08:24:56.856]                 ...future.workdir <- getwd()
[08:24:56.856]             }
[08:24:56.856]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.856]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.856]         }
[08:24:56.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.856]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.856]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.856]             base::names(...future.oldOptions))
[08:24:56.856]     }
[08:24:56.856]     if (FALSE) {
[08:24:56.856]     }
[08:24:56.856]     else {
[08:24:56.856]         if (TRUE) {
[08:24:56.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.856]                 open = "w")
[08:24:56.856]         }
[08:24:56.856]         else {
[08:24:56.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.856]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.856]         }
[08:24:56.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.856]             base::sink(type = "output", split = FALSE)
[08:24:56.856]             base::close(...future.stdout)
[08:24:56.856]         }, add = TRUE)
[08:24:56.856]     }
[08:24:56.856]     ...future.frame <- base::sys.nframe()
[08:24:56.856]     ...future.conditions <- base::list()
[08:24:56.856]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.856]     if (FALSE) {
[08:24:56.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.856]     }
[08:24:56.856]     ...future.result <- base::tryCatch({
[08:24:56.856]         base::withCallingHandlers({
[08:24:56.856]             ...future.value <- base::withVisible(base::local({
[08:24:56.856]                 do.call(function(...) {
[08:24:56.856]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.856]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.856]                     ...future.globals.maxSize)) {
[08:24:56.856]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.856]                     on.exit(options(oopts), add = TRUE)
[08:24:56.856]                   }
[08:24:56.856]                   {
[08:24:56.856]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.856]                       FUN = function(jj) {
[08:24:56.856]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.856]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.856]                       })
[08:24:56.856]                   }
[08:24:56.856]                 }, args = future.call.arguments)
[08:24:56.856]             }))
[08:24:56.856]             future::FutureResult(value = ...future.value$value, 
[08:24:56.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.856]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.856]                     ...future.globalenv.names))
[08:24:56.856]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.856]         }, condition = base::local({
[08:24:56.856]             c <- base::c
[08:24:56.856]             inherits <- base::inherits
[08:24:56.856]             invokeRestart <- base::invokeRestart
[08:24:56.856]             length <- base::length
[08:24:56.856]             list <- base::list
[08:24:56.856]             seq.int <- base::seq.int
[08:24:56.856]             signalCondition <- base::signalCondition
[08:24:56.856]             sys.calls <- base::sys.calls
[08:24:56.856]             `[[` <- base::`[[`
[08:24:56.856]             `+` <- base::`+`
[08:24:56.856]             `<<-` <- base::`<<-`
[08:24:56.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.856]                   3L)]
[08:24:56.856]             }
[08:24:56.856]             function(cond) {
[08:24:56.856]                 is_error <- inherits(cond, "error")
[08:24:56.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.856]                   NULL)
[08:24:56.856]                 if (is_error) {
[08:24:56.856]                   sessionInformation <- function() {
[08:24:56.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.856]                       search = base::search(), system = base::Sys.info())
[08:24:56.856]                   }
[08:24:56.856]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.856]                     cond$call), session = sessionInformation(), 
[08:24:56.856]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.856]                   signalCondition(cond)
[08:24:56.856]                 }
[08:24:56.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.856]                 "immediateCondition"))) {
[08:24:56.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.856]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.856]                   if (TRUE && !signal) {
[08:24:56.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.856]                     {
[08:24:56.856]                       inherits <- base::inherits
[08:24:56.856]                       invokeRestart <- base::invokeRestart
[08:24:56.856]                       is.null <- base::is.null
[08:24:56.856]                       muffled <- FALSE
[08:24:56.856]                       if (inherits(cond, "message")) {
[08:24:56.856]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.856]                         if (muffled) 
[08:24:56.856]                           invokeRestart("muffleMessage")
[08:24:56.856]                       }
[08:24:56.856]                       else if (inherits(cond, "warning")) {
[08:24:56.856]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.856]                         if (muffled) 
[08:24:56.856]                           invokeRestart("muffleWarning")
[08:24:56.856]                       }
[08:24:56.856]                       else if (inherits(cond, "condition")) {
[08:24:56.856]                         if (!is.null(pattern)) {
[08:24:56.856]                           computeRestarts <- base::computeRestarts
[08:24:56.856]                           grepl <- base::grepl
[08:24:56.856]                           restarts <- computeRestarts(cond)
[08:24:56.856]                           for (restart in restarts) {
[08:24:56.856]                             name <- restart$name
[08:24:56.856]                             if (is.null(name)) 
[08:24:56.856]                               next
[08:24:56.856]                             if (!grepl(pattern, name)) 
[08:24:56.856]                               next
[08:24:56.856]                             invokeRestart(restart)
[08:24:56.856]                             muffled <- TRUE
[08:24:56.856]                             break
[08:24:56.856]                           }
[08:24:56.856]                         }
[08:24:56.856]                       }
[08:24:56.856]                       invisible(muffled)
[08:24:56.856]                     }
[08:24:56.856]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.856]                   }
[08:24:56.856]                 }
[08:24:56.856]                 else {
[08:24:56.856]                   if (TRUE) {
[08:24:56.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.856]                     {
[08:24:56.856]                       inherits <- base::inherits
[08:24:56.856]                       invokeRestart <- base::invokeRestart
[08:24:56.856]                       is.null <- base::is.null
[08:24:56.856]                       muffled <- FALSE
[08:24:56.856]                       if (inherits(cond, "message")) {
[08:24:56.856]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.856]                         if (muffled) 
[08:24:56.856]                           invokeRestart("muffleMessage")
[08:24:56.856]                       }
[08:24:56.856]                       else if (inherits(cond, "warning")) {
[08:24:56.856]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.856]                         if (muffled) 
[08:24:56.856]                           invokeRestart("muffleWarning")
[08:24:56.856]                       }
[08:24:56.856]                       else if (inherits(cond, "condition")) {
[08:24:56.856]                         if (!is.null(pattern)) {
[08:24:56.856]                           computeRestarts <- base::computeRestarts
[08:24:56.856]                           grepl <- base::grepl
[08:24:56.856]                           restarts <- computeRestarts(cond)
[08:24:56.856]                           for (restart in restarts) {
[08:24:56.856]                             name <- restart$name
[08:24:56.856]                             if (is.null(name)) 
[08:24:56.856]                               next
[08:24:56.856]                             if (!grepl(pattern, name)) 
[08:24:56.856]                               next
[08:24:56.856]                             invokeRestart(restart)
[08:24:56.856]                             muffled <- TRUE
[08:24:56.856]                             break
[08:24:56.856]                           }
[08:24:56.856]                         }
[08:24:56.856]                       }
[08:24:56.856]                       invisible(muffled)
[08:24:56.856]                     }
[08:24:56.856]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.856]                   }
[08:24:56.856]                 }
[08:24:56.856]             }
[08:24:56.856]         }))
[08:24:56.856]     }, error = function(ex) {
[08:24:56.856]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.856]                 ...future.rng), started = ...future.startTime, 
[08:24:56.856]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.856]             version = "1.8"), class = "FutureResult")
[08:24:56.856]     }, finally = {
[08:24:56.856]         if (!identical(...future.workdir, getwd())) 
[08:24:56.856]             setwd(...future.workdir)
[08:24:56.856]         {
[08:24:56.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.856]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.856]             }
[08:24:56.856]             base::options(...future.oldOptions)
[08:24:56.856]             if (.Platform$OS.type == "windows") {
[08:24:56.856]                 old_names <- names(...future.oldEnvVars)
[08:24:56.856]                 envs <- base::Sys.getenv()
[08:24:56.856]                 names <- names(envs)
[08:24:56.856]                 common <- intersect(names, old_names)
[08:24:56.856]                 added <- setdiff(names, old_names)
[08:24:56.856]                 removed <- setdiff(old_names, names)
[08:24:56.856]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.856]                   envs[common]]
[08:24:56.856]                 NAMES <- toupper(changed)
[08:24:56.856]                 args <- list()
[08:24:56.856]                 for (kk in seq_along(NAMES)) {
[08:24:56.856]                   name <- changed[[kk]]
[08:24:56.856]                   NAME <- NAMES[[kk]]
[08:24:56.856]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.856]                     next
[08:24:56.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.856]                 }
[08:24:56.856]                 NAMES <- toupper(added)
[08:24:56.856]                 for (kk in seq_along(NAMES)) {
[08:24:56.856]                   name <- added[[kk]]
[08:24:56.856]                   NAME <- NAMES[[kk]]
[08:24:56.856]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.856]                     next
[08:24:56.856]                   args[[name]] <- ""
[08:24:56.856]                 }
[08:24:56.856]                 NAMES <- toupper(removed)
[08:24:56.856]                 for (kk in seq_along(NAMES)) {
[08:24:56.856]                   name <- removed[[kk]]
[08:24:56.856]                   NAME <- NAMES[[kk]]
[08:24:56.856]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.856]                     next
[08:24:56.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.856]                 }
[08:24:56.856]                 if (length(args) > 0) 
[08:24:56.856]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.856]             }
[08:24:56.856]             else {
[08:24:56.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.856]             }
[08:24:56.856]             {
[08:24:56.856]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.856]                   0L) {
[08:24:56.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.856]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.856]                   base::options(opts)
[08:24:56.856]                 }
[08:24:56.856]                 {
[08:24:56.856]                   {
[08:24:56.856]                     NULL
[08:24:56.856]                     RNGkind("Mersenne-Twister")
[08:24:56.856]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.856]                       inherits = FALSE)
[08:24:56.856]                   }
[08:24:56.856]                   options(future.plan = NULL)
[08:24:56.856]                   if (is.na(NA_character_)) 
[08:24:56.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.856]                     .init = FALSE)
[08:24:56.856]                 }
[08:24:56.856]             }
[08:24:56.856]         }
[08:24:56.856]     })
[08:24:56.856]     if (TRUE) {
[08:24:56.856]         base::sink(type = "output", split = FALSE)
[08:24:56.856]         if (TRUE) {
[08:24:56.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.856]         }
[08:24:56.856]         else {
[08:24:56.856]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.856]         }
[08:24:56.856]         base::close(...future.stdout)
[08:24:56.856]         ...future.stdout <- NULL
[08:24:56.856]     }
[08:24:56.856]     ...future.result$conditions <- ...future.conditions
[08:24:56.856]     ...future.result$finished <- base::Sys.time()
[08:24:56.856]     ...future.result
[08:24:56.856] }
[08:24:56.857] assign_globals() ...
[08:24:56.857] List of 5
[08:24:56.857]  $ ...future.FUN            :function (object, ...)  
[08:24:56.857]  $ future.call.arguments    : list()
[08:24:56.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.857]  $ ...future.elements_ii    :List of 3
[08:24:56.857]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.857]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.857]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.857]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:56.857]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.857]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.857]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.857]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:56.857]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:56.857]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.857]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.857]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:56.857]  $ ...future.seeds_ii       : NULL
[08:24:56.857]  $ ...future.globals.maxSize: NULL
[08:24:56.857]  - attr(*, "where")=List of 5
[08:24:56.857]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.857]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.857]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.857]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.857]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.857]  - attr(*, "resolved")= logi FALSE
[08:24:56.857]  - attr(*, "total_size")= num 18647
[08:24:56.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.857]  - attr(*, "already-done")= logi TRUE
[08:24:56.868] - copied ‘...future.FUN’ to environment
[08:24:56.868] - copied ‘future.call.arguments’ to environment
[08:24:56.868] - copied ‘...future.elements_ii’ to environment
[08:24:56.868] - copied ‘...future.seeds_ii’ to environment
[08:24:56.869] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.869] assign_globals() ... done
[08:24:56.869] plan(): Setting new future strategy stack:
[08:24:56.869] List of future strategies:
[08:24:56.869] 1. sequential:
[08:24:56.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.869]    - tweaked: FALSE
[08:24:56.869]    - call: NULL
[08:24:56.870] plan(): nbrOfWorkers() = 1
[08:24:56.872] plan(): Setting new future strategy stack:
[08:24:56.872] List of future strategies:
[08:24:56.872] 1. multicore:
[08:24:56.872]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:56.872]    - tweaked: FALSE
[08:24:56.872]    - call: plan(strategy)
[08:24:56.874] plan(): nbrOfWorkers() = 1
[08:24:56.874] SequentialFuture started (and completed)
[08:24:56.874] - Launch lazy future ... done
[08:24:56.874] run() for ‘SequentialFuture’ ... done
[08:24:56.874] Created future:
[08:24:56.874] SequentialFuture:
[08:24:56.874] Label: ‘future_by-1’
[08:24:56.874] Expression:
[08:24:56.874] {
[08:24:56.874]     do.call(function(...) {
[08:24:56.874]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.874]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.874]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.874]             on.exit(options(oopts), add = TRUE)
[08:24:56.874]         }
[08:24:56.874]         {
[08:24:56.874]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.874]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.874]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.874]             })
[08:24:56.874]         }
[08:24:56.874]     }, args = future.call.arguments)
[08:24:56.874] }
[08:24:56.874] Lazy evaluation: FALSE
[08:24:56.874] Asynchronous evaluation: FALSE
[08:24:56.874] Local evaluation: TRUE
[08:24:56.874] Environment: 0x557b27f43848
[08:24:56.874] Capture standard output: TRUE
[08:24:56.874] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.874] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.874] Packages: <none>
[08:24:56.874] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.874] Resolved: TRUE
[08:24:56.874] Value: 1.39 KiB of class ‘list’
[08:24:56.874] Early signaling: FALSE
[08:24:56.874] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.874] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.875] Chunk #1 of 1 ... DONE
[08:24:56.876] Launching 1 futures (chunks) ... DONE
[08:24:56.876] Resolving 1 futures (chunks) ...
[08:24:56.876] resolve() on list ...
[08:24:56.876]  recursive: 0
[08:24:56.876]  length: 1
[08:24:56.876] 
[08:24:56.876] resolved() for ‘SequentialFuture’ ...
[08:24:56.876] - state: ‘finished’
[08:24:56.876] - run: TRUE
[08:24:56.876] - result: ‘FutureResult’
[08:24:56.876] resolved() for ‘SequentialFuture’ ... done
[08:24:56.877] Future #1
[08:24:56.877] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.877] - nx: 1
[08:24:56.877] - relay: TRUE
[08:24:56.877] - stdout: TRUE
[08:24:56.877] - signal: TRUE
[08:24:56.877] - resignal: FALSE
[08:24:56.877] - force: TRUE
[08:24:56.877] - relayed: [n=1] FALSE
[08:24:56.877] - queued futures: [n=1] FALSE
[08:24:56.877]  - until=1
[08:24:56.878]  - relaying element #1
[08:24:56.878] - relayed: [n=1] TRUE
[08:24:56.878] - queued futures: [n=1] TRUE
[08:24:56.878] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.878]  length: 0 (resolved future 1)
[08:24:56.878] Relaying remaining futures
[08:24:56.878] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.878] - nx: 1
[08:24:56.878] - relay: TRUE
[08:24:56.878] - stdout: TRUE
[08:24:56.879] - signal: TRUE
[08:24:56.879] - resignal: FALSE
[08:24:56.879] - force: TRUE
[08:24:56.879] - relayed: [n=1] TRUE
[08:24:56.879] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.879] - relayed: [n=1] TRUE
[08:24:56.879] - queued futures: [n=1] TRUE
[08:24:56.879] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.879] resolve() on list ... DONE
[08:24:56.879]  - Number of value chunks collected: 1
[08:24:56.880] Resolving 1 futures (chunks) ... DONE
[08:24:56.880] Reducing values from 1 chunks ...
[08:24:56.880]  - Number of values collected after concatenation: 3
[08:24:56.880]  - Number of values expected: 3
[08:24:56.880] Reducing values from 1 chunks ... DONE
[08:24:56.880] future_lapply() ... DONE
[08:24:56.880] future_by_internal() ... DONE
[08:24:56.881] future_by_internal() ...
- plan('multisession') ...
[08:24:56.881] plan(): Setting new future strategy stack:
[08:24:56.882] List of future strategies:
[08:24:56.882] 1. multisession:
[08:24:56.882]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:56.882]    - tweaked: FALSE
[08:24:56.882]    - call: plan(strategy)
[08:24:56.882] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:24:56.882] multisession:
[08:24:56.882] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:56.882] - tweaked: FALSE
[08:24:56.882] - call: plan(strategy)
[08:24:56.884] getGlobalsAndPackages() ...
[08:24:56.884] Not searching for globals
[08:24:56.884] - globals: [0] <none>
[08:24:56.884] getGlobalsAndPackages() ... DONE
[08:24:56.884] Packages needed by the future expression (n = 0): <none>
[08:24:56.885] Packages needed by future strategies (n = 0): <none>
[08:24:56.885] {
[08:24:56.885]     {
[08:24:56.885]         {
[08:24:56.885]             ...future.startTime <- base::Sys.time()
[08:24:56.885]             {
[08:24:56.885]                 {
[08:24:56.885]                   {
[08:24:56.885]                     base::local({
[08:24:56.885]                       has_future <- base::requireNamespace("future", 
[08:24:56.885]                         quietly = TRUE)
[08:24:56.885]                       if (has_future) {
[08:24:56.885]                         ns <- base::getNamespace("future")
[08:24:56.885]                         version <- ns[[".package"]][["version"]]
[08:24:56.885]                         if (is.null(version)) 
[08:24:56.885]                           version <- utils::packageVersion("future")
[08:24:56.885]                       }
[08:24:56.885]                       else {
[08:24:56.885]                         version <- NULL
[08:24:56.885]                       }
[08:24:56.885]                       if (!has_future || version < "1.8.0") {
[08:24:56.885]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.885]                           "", base::R.version$version.string), 
[08:24:56.885]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.885]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.885]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.885]                             "release", "version")], collapse = " "), 
[08:24:56.885]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.885]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.885]                           info)
[08:24:56.885]                         info <- base::paste(info, collapse = "; ")
[08:24:56.885]                         if (!has_future) {
[08:24:56.885]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.885]                             info)
[08:24:56.885]                         }
[08:24:56.885]                         else {
[08:24:56.885]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.885]                             info, version)
[08:24:56.885]                         }
[08:24:56.885]                         base::stop(msg)
[08:24:56.885]                       }
[08:24:56.885]                     })
[08:24:56.885]                   }
[08:24:56.885]                   ...future.strategy.old <- future::plan("list")
[08:24:56.885]                   options(future.plan = NULL)
[08:24:56.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.885]                 }
[08:24:56.885]                 ...future.workdir <- getwd()
[08:24:56.885]             }
[08:24:56.885]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.885]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.885]         }
[08:24:56.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.885]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.885]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.885]             base::names(...future.oldOptions))
[08:24:56.885]     }
[08:24:56.885]     if (FALSE) {
[08:24:56.885]     }
[08:24:56.885]     else {
[08:24:56.885]         if (TRUE) {
[08:24:56.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.885]                 open = "w")
[08:24:56.885]         }
[08:24:56.885]         else {
[08:24:56.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.885]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.885]         }
[08:24:56.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.885]             base::sink(type = "output", split = FALSE)
[08:24:56.885]             base::close(...future.stdout)
[08:24:56.885]         }, add = TRUE)
[08:24:56.885]     }
[08:24:56.885]     ...future.frame <- base::sys.nframe()
[08:24:56.885]     ...future.conditions <- base::list()
[08:24:56.885]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.885]     if (FALSE) {
[08:24:56.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.885]     }
[08:24:56.885]     ...future.result <- base::tryCatch({
[08:24:56.885]         base::withCallingHandlers({
[08:24:56.885]             ...future.value <- base::withVisible(base::local(NA))
[08:24:56.885]             future::FutureResult(value = ...future.value$value, 
[08:24:56.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.885]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.885]                     ...future.globalenv.names))
[08:24:56.885]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.885]         }, condition = base::local({
[08:24:56.885]             c <- base::c
[08:24:56.885]             inherits <- base::inherits
[08:24:56.885]             invokeRestart <- base::invokeRestart
[08:24:56.885]             length <- base::length
[08:24:56.885]             list <- base::list
[08:24:56.885]             seq.int <- base::seq.int
[08:24:56.885]             signalCondition <- base::signalCondition
[08:24:56.885]             sys.calls <- base::sys.calls
[08:24:56.885]             `[[` <- base::`[[`
[08:24:56.885]             `+` <- base::`+`
[08:24:56.885]             `<<-` <- base::`<<-`
[08:24:56.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.885]                   3L)]
[08:24:56.885]             }
[08:24:56.885]             function(cond) {
[08:24:56.885]                 is_error <- inherits(cond, "error")
[08:24:56.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.885]                   NULL)
[08:24:56.885]                 if (is_error) {
[08:24:56.885]                   sessionInformation <- function() {
[08:24:56.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.885]                       search = base::search(), system = base::Sys.info())
[08:24:56.885]                   }
[08:24:56.885]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.885]                     cond$call), session = sessionInformation(), 
[08:24:56.885]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.885]                   signalCondition(cond)
[08:24:56.885]                 }
[08:24:56.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.885]                 "immediateCondition"))) {
[08:24:56.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.885]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.885]                   if (TRUE && !signal) {
[08:24:56.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.885]                     {
[08:24:56.885]                       inherits <- base::inherits
[08:24:56.885]                       invokeRestart <- base::invokeRestart
[08:24:56.885]                       is.null <- base::is.null
[08:24:56.885]                       muffled <- FALSE
[08:24:56.885]                       if (inherits(cond, "message")) {
[08:24:56.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.885]                         if (muffled) 
[08:24:56.885]                           invokeRestart("muffleMessage")
[08:24:56.885]                       }
[08:24:56.885]                       else if (inherits(cond, "warning")) {
[08:24:56.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.885]                         if (muffled) 
[08:24:56.885]                           invokeRestart("muffleWarning")
[08:24:56.885]                       }
[08:24:56.885]                       else if (inherits(cond, "condition")) {
[08:24:56.885]                         if (!is.null(pattern)) {
[08:24:56.885]                           computeRestarts <- base::computeRestarts
[08:24:56.885]                           grepl <- base::grepl
[08:24:56.885]                           restarts <- computeRestarts(cond)
[08:24:56.885]                           for (restart in restarts) {
[08:24:56.885]                             name <- restart$name
[08:24:56.885]                             if (is.null(name)) 
[08:24:56.885]                               next
[08:24:56.885]                             if (!grepl(pattern, name)) 
[08:24:56.885]                               next
[08:24:56.885]                             invokeRestart(restart)
[08:24:56.885]                             muffled <- TRUE
[08:24:56.885]                             break
[08:24:56.885]                           }
[08:24:56.885]                         }
[08:24:56.885]                       }
[08:24:56.885]                       invisible(muffled)
[08:24:56.885]                     }
[08:24:56.885]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.885]                   }
[08:24:56.885]                 }
[08:24:56.885]                 else {
[08:24:56.885]                   if (TRUE) {
[08:24:56.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.885]                     {
[08:24:56.885]                       inherits <- base::inherits
[08:24:56.885]                       invokeRestart <- base::invokeRestart
[08:24:56.885]                       is.null <- base::is.null
[08:24:56.885]                       muffled <- FALSE
[08:24:56.885]                       if (inherits(cond, "message")) {
[08:24:56.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.885]                         if (muffled) 
[08:24:56.885]                           invokeRestart("muffleMessage")
[08:24:56.885]                       }
[08:24:56.885]                       else if (inherits(cond, "warning")) {
[08:24:56.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.885]                         if (muffled) 
[08:24:56.885]                           invokeRestart("muffleWarning")
[08:24:56.885]                       }
[08:24:56.885]                       else if (inherits(cond, "condition")) {
[08:24:56.885]                         if (!is.null(pattern)) {
[08:24:56.885]                           computeRestarts <- base::computeRestarts
[08:24:56.885]                           grepl <- base::grepl
[08:24:56.885]                           restarts <- computeRestarts(cond)
[08:24:56.885]                           for (restart in restarts) {
[08:24:56.885]                             name <- restart$name
[08:24:56.885]                             if (is.null(name)) 
[08:24:56.885]                               next
[08:24:56.885]                             if (!grepl(pattern, name)) 
[08:24:56.885]                               next
[08:24:56.885]                             invokeRestart(restart)
[08:24:56.885]                             muffled <- TRUE
[08:24:56.885]                             break
[08:24:56.885]                           }
[08:24:56.885]                         }
[08:24:56.885]                       }
[08:24:56.885]                       invisible(muffled)
[08:24:56.885]                     }
[08:24:56.885]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.885]                   }
[08:24:56.885]                 }
[08:24:56.885]             }
[08:24:56.885]         }))
[08:24:56.885]     }, error = function(ex) {
[08:24:56.885]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.885]                 ...future.rng), started = ...future.startTime, 
[08:24:56.885]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.885]             version = "1.8"), class = "FutureResult")
[08:24:56.885]     }, finally = {
[08:24:56.885]         if (!identical(...future.workdir, getwd())) 
[08:24:56.885]             setwd(...future.workdir)
[08:24:56.885]         {
[08:24:56.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.885]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.885]             }
[08:24:56.885]             base::options(...future.oldOptions)
[08:24:56.885]             if (.Platform$OS.type == "windows") {
[08:24:56.885]                 old_names <- names(...future.oldEnvVars)
[08:24:56.885]                 envs <- base::Sys.getenv()
[08:24:56.885]                 names <- names(envs)
[08:24:56.885]                 common <- intersect(names, old_names)
[08:24:56.885]                 added <- setdiff(names, old_names)
[08:24:56.885]                 removed <- setdiff(old_names, names)
[08:24:56.885]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.885]                   envs[common]]
[08:24:56.885]                 NAMES <- toupper(changed)
[08:24:56.885]                 args <- list()
[08:24:56.885]                 for (kk in seq_along(NAMES)) {
[08:24:56.885]                   name <- changed[[kk]]
[08:24:56.885]                   NAME <- NAMES[[kk]]
[08:24:56.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.885]                     next
[08:24:56.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.885]                 }
[08:24:56.885]                 NAMES <- toupper(added)
[08:24:56.885]                 for (kk in seq_along(NAMES)) {
[08:24:56.885]                   name <- added[[kk]]
[08:24:56.885]                   NAME <- NAMES[[kk]]
[08:24:56.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.885]                     next
[08:24:56.885]                   args[[name]] <- ""
[08:24:56.885]                 }
[08:24:56.885]                 NAMES <- toupper(removed)
[08:24:56.885]                 for (kk in seq_along(NAMES)) {
[08:24:56.885]                   name <- removed[[kk]]
[08:24:56.885]                   NAME <- NAMES[[kk]]
[08:24:56.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.885]                     next
[08:24:56.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.885]                 }
[08:24:56.885]                 if (length(args) > 0) 
[08:24:56.885]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.885]             }
[08:24:56.885]             else {
[08:24:56.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.885]             }
[08:24:56.885]             {
[08:24:56.885]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.885]                   0L) {
[08:24:56.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.885]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.885]                   base::options(opts)
[08:24:56.885]                 }
[08:24:56.885]                 {
[08:24:56.885]                   {
[08:24:56.885]                     NULL
[08:24:56.885]                     RNGkind("Mersenne-Twister")
[08:24:56.885]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.885]                       inherits = FALSE)
[08:24:56.885]                   }
[08:24:56.885]                   options(future.plan = NULL)
[08:24:56.885]                   if (is.na(NA_character_)) 
[08:24:56.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.885]                     .init = FALSE)
[08:24:56.885]                 }
[08:24:56.885]             }
[08:24:56.885]         }
[08:24:56.885]     })
[08:24:56.885]     if (TRUE) {
[08:24:56.885]         base::sink(type = "output", split = FALSE)
[08:24:56.885]         if (TRUE) {
[08:24:56.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.885]         }
[08:24:56.885]         else {
[08:24:56.885]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.885]         }
[08:24:56.885]         base::close(...future.stdout)
[08:24:56.885]         ...future.stdout <- NULL
[08:24:56.885]     }
[08:24:56.885]     ...future.result$conditions <- ...future.conditions
[08:24:56.885]     ...future.result$finished <- base::Sys.time()
[08:24:56.885]     ...future.result
[08:24:56.885] }
[08:24:56.887] plan(): Setting new future strategy stack:
[08:24:56.887] List of future strategies:
[08:24:56.887] 1. sequential:
[08:24:56.887]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.887]    - tweaked: FALSE
[08:24:56.887]    - call: NULL
[08:24:56.887] plan(): nbrOfWorkers() = 1
[08:24:56.888] plan(): Setting new future strategy stack:
[08:24:56.888] List of future strategies:
[08:24:56.888] 1. multisession:
[08:24:56.888]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:56.888]    - tweaked: FALSE
[08:24:56.888]    - call: plan(strategy)
[08:24:56.890] plan(): nbrOfWorkers() = 1
[08:24:56.890] SequentialFuture started (and completed)
[08:24:56.890] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:24:56.892] plan(): nbrOfWorkers() = 1
[08:24:56.892] future_by_internal() ...
[08:24:56.892] future_lapply() ...
[08:24:56.896] Number of chunks: 1
[08:24:56.896] getGlobalsAndPackagesXApply() ...
[08:24:56.896]  - future.globals: TRUE
[08:24:56.896] getGlobalsAndPackages() ...
[08:24:56.896] Searching for globals...
[08:24:56.898] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.898] Searching for globals ... DONE
[08:24:56.898] Resolving globals: FALSE
[08:24:56.898] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.899] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.899] - globals: [1] ‘FUN’
[08:24:56.899] 
[08:24:56.899] getGlobalsAndPackages() ... DONE
[08:24:56.899]  - globals found/used: [n=1] ‘FUN’
[08:24:56.899]  - needed namespaces: [n=0] 
[08:24:56.899] Finding globals ... DONE
[08:24:56.899]  - use_args: TRUE
[08:24:56.899]  - Getting '...' globals ...
[08:24:56.900] resolve() on list ...
[08:24:56.900]  recursive: 0
[08:24:56.900]  length: 1
[08:24:56.900]  elements: ‘...’
[08:24:56.900]  length: 0 (resolved future 1)
[08:24:56.900] resolve() on list ... DONE
[08:24:56.900]    - '...' content: [n=0] 
[08:24:56.900] List of 1
[08:24:56.900]  $ ...: list()
[08:24:56.900]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.900]  - attr(*, "where")=List of 1
[08:24:56.900]   ..$ ...:<environment: 0x557b2846b6b0> 
[08:24:56.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.900]  - attr(*, "resolved")= logi TRUE
[08:24:56.900]  - attr(*, "total_size")= num NA
[08:24:56.903]  - Getting '...' globals ... DONE
[08:24:56.903] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.903] List of 2
[08:24:56.903]  $ ...future.FUN:function (object, ...)  
[08:24:56.903]  $ ...          : list()
[08:24:56.903]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.903]  - attr(*, "where")=List of 2
[08:24:56.903]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.903]   ..$ ...          :<environment: 0x557b2846b6b0> 
[08:24:56.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.903]  - attr(*, "resolved")= logi FALSE
[08:24:56.903]  - attr(*, "total_size")= num 15670
[08:24:56.906] Packages to be attached in all futures: [n=0] 
[08:24:56.906] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.906] Number of futures (= number of chunks): 1
[08:24:56.906] Launching 1 futures (chunks) ...
[08:24:56.906] Chunk #1 of 1 ...
[08:24:56.907]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.907] getGlobalsAndPackages() ...
[08:24:56.907] Searching for globals...
[08:24:56.907] 
[08:24:56.907] Searching for globals ... DONE
[08:24:56.907] - globals: [0] <none>
[08:24:56.908] getGlobalsAndPackages() ... DONE
[08:24:56.908]    + additional globals found: [n=0] 
[08:24:56.908]    + additional namespaces needed: [n=0] 
[08:24:56.908]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.908]  - seeds: <none>
[08:24:56.908]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.908] getGlobalsAndPackages() ...
[08:24:56.908] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.908] Resolving globals: FALSE
[08:24:56.908] Tweak future expression to call with '...' arguments ...
[08:24:56.908] {
[08:24:56.908]     do.call(function(...) {
[08:24:56.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.908]             on.exit(options(oopts), add = TRUE)
[08:24:56.908]         }
[08:24:56.908]         {
[08:24:56.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.908]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.908]             })
[08:24:56.908]         }
[08:24:56.908]     }, args = future.call.arguments)
[08:24:56.908] }
[08:24:56.909] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.909] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.909] 
[08:24:56.909] getGlobalsAndPackages() ... DONE
[08:24:56.910] run() for ‘Future’ ...
[08:24:56.910] - state: ‘created’
[08:24:56.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:56.911] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.911] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.912]   - Field: ‘label’
[08:24:56.912]   - Field: ‘local’
[08:24:56.912]   - Field: ‘owner’
[08:24:56.912]   - Field: ‘envir’
[08:24:56.912]   - Field: ‘packages’
[08:24:56.912]   - Field: ‘gc’
[08:24:56.912]   - Field: ‘conditions’
[08:24:56.912]   - Field: ‘expr’
[08:24:56.912]   - Field: ‘uuid’
[08:24:56.912]   - Field: ‘seed’
[08:24:56.913]   - Field: ‘version’
[08:24:56.913]   - Field: ‘result’
[08:24:56.913]   - Field: ‘asynchronous’
[08:24:56.913]   - Field: ‘calls’
[08:24:56.913]   - Field: ‘globals’
[08:24:56.913]   - Field: ‘stdout’
[08:24:56.913]   - Field: ‘earlySignal’
[08:24:56.913]   - Field: ‘lazy’
[08:24:56.913]   - Field: ‘state’
[08:24:56.913] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.913] - Launch lazy future ...
[08:24:56.914] Packages needed by the future expression (n = 0): <none>
[08:24:56.914] Packages needed by future strategies (n = 0): <none>
[08:24:56.914] {
[08:24:56.914]     {
[08:24:56.914]         {
[08:24:56.914]             ...future.startTime <- base::Sys.time()
[08:24:56.914]             {
[08:24:56.914]                 {
[08:24:56.914]                   {
[08:24:56.914]                     base::local({
[08:24:56.914]                       has_future <- base::requireNamespace("future", 
[08:24:56.914]                         quietly = TRUE)
[08:24:56.914]                       if (has_future) {
[08:24:56.914]                         ns <- base::getNamespace("future")
[08:24:56.914]                         version <- ns[[".package"]][["version"]]
[08:24:56.914]                         if (is.null(version)) 
[08:24:56.914]                           version <- utils::packageVersion("future")
[08:24:56.914]                       }
[08:24:56.914]                       else {
[08:24:56.914]                         version <- NULL
[08:24:56.914]                       }
[08:24:56.914]                       if (!has_future || version < "1.8.0") {
[08:24:56.914]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.914]                           "", base::R.version$version.string), 
[08:24:56.914]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.914]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.914]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.914]                             "release", "version")], collapse = " "), 
[08:24:56.914]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.914]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.914]                           info)
[08:24:56.914]                         info <- base::paste(info, collapse = "; ")
[08:24:56.914]                         if (!has_future) {
[08:24:56.914]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.914]                             info)
[08:24:56.914]                         }
[08:24:56.914]                         else {
[08:24:56.914]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.914]                             info, version)
[08:24:56.914]                         }
[08:24:56.914]                         base::stop(msg)
[08:24:56.914]                       }
[08:24:56.914]                     })
[08:24:56.914]                   }
[08:24:56.914]                   ...future.strategy.old <- future::plan("list")
[08:24:56.914]                   options(future.plan = NULL)
[08:24:56.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.914]                 }
[08:24:56.914]                 ...future.workdir <- getwd()
[08:24:56.914]             }
[08:24:56.914]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.914]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.914]         }
[08:24:56.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.914]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.914]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.914]             base::names(...future.oldOptions))
[08:24:56.914]     }
[08:24:56.914]     if (FALSE) {
[08:24:56.914]     }
[08:24:56.914]     else {
[08:24:56.914]         if (TRUE) {
[08:24:56.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.914]                 open = "w")
[08:24:56.914]         }
[08:24:56.914]         else {
[08:24:56.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.914]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.914]         }
[08:24:56.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.914]             base::sink(type = "output", split = FALSE)
[08:24:56.914]             base::close(...future.stdout)
[08:24:56.914]         }, add = TRUE)
[08:24:56.914]     }
[08:24:56.914]     ...future.frame <- base::sys.nframe()
[08:24:56.914]     ...future.conditions <- base::list()
[08:24:56.914]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.914]     if (FALSE) {
[08:24:56.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.914]     }
[08:24:56.914]     ...future.result <- base::tryCatch({
[08:24:56.914]         base::withCallingHandlers({
[08:24:56.914]             ...future.value <- base::withVisible(base::local({
[08:24:56.914]                 do.call(function(...) {
[08:24:56.914]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.914]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.914]                     ...future.globals.maxSize)) {
[08:24:56.914]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.914]                     on.exit(options(oopts), add = TRUE)
[08:24:56.914]                   }
[08:24:56.914]                   {
[08:24:56.914]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.914]                       FUN = function(jj) {
[08:24:56.914]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.914]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.914]                       })
[08:24:56.914]                   }
[08:24:56.914]                 }, args = future.call.arguments)
[08:24:56.914]             }))
[08:24:56.914]             future::FutureResult(value = ...future.value$value, 
[08:24:56.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.914]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.914]                     ...future.globalenv.names))
[08:24:56.914]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.914]         }, condition = base::local({
[08:24:56.914]             c <- base::c
[08:24:56.914]             inherits <- base::inherits
[08:24:56.914]             invokeRestart <- base::invokeRestart
[08:24:56.914]             length <- base::length
[08:24:56.914]             list <- base::list
[08:24:56.914]             seq.int <- base::seq.int
[08:24:56.914]             signalCondition <- base::signalCondition
[08:24:56.914]             sys.calls <- base::sys.calls
[08:24:56.914]             `[[` <- base::`[[`
[08:24:56.914]             `+` <- base::`+`
[08:24:56.914]             `<<-` <- base::`<<-`
[08:24:56.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.914]                   3L)]
[08:24:56.914]             }
[08:24:56.914]             function(cond) {
[08:24:56.914]                 is_error <- inherits(cond, "error")
[08:24:56.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.914]                   NULL)
[08:24:56.914]                 if (is_error) {
[08:24:56.914]                   sessionInformation <- function() {
[08:24:56.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.914]                       search = base::search(), system = base::Sys.info())
[08:24:56.914]                   }
[08:24:56.914]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.914]                     cond$call), session = sessionInformation(), 
[08:24:56.914]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.914]                   signalCondition(cond)
[08:24:56.914]                 }
[08:24:56.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.914]                 "immediateCondition"))) {
[08:24:56.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.914]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.914]                   if (TRUE && !signal) {
[08:24:56.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.914]                     {
[08:24:56.914]                       inherits <- base::inherits
[08:24:56.914]                       invokeRestart <- base::invokeRestart
[08:24:56.914]                       is.null <- base::is.null
[08:24:56.914]                       muffled <- FALSE
[08:24:56.914]                       if (inherits(cond, "message")) {
[08:24:56.914]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.914]                         if (muffled) 
[08:24:56.914]                           invokeRestart("muffleMessage")
[08:24:56.914]                       }
[08:24:56.914]                       else if (inherits(cond, "warning")) {
[08:24:56.914]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.914]                         if (muffled) 
[08:24:56.914]                           invokeRestart("muffleWarning")
[08:24:56.914]                       }
[08:24:56.914]                       else if (inherits(cond, "condition")) {
[08:24:56.914]                         if (!is.null(pattern)) {
[08:24:56.914]                           computeRestarts <- base::computeRestarts
[08:24:56.914]                           grepl <- base::grepl
[08:24:56.914]                           restarts <- computeRestarts(cond)
[08:24:56.914]                           for (restart in restarts) {
[08:24:56.914]                             name <- restart$name
[08:24:56.914]                             if (is.null(name)) 
[08:24:56.914]                               next
[08:24:56.914]                             if (!grepl(pattern, name)) 
[08:24:56.914]                               next
[08:24:56.914]                             invokeRestart(restart)
[08:24:56.914]                             muffled <- TRUE
[08:24:56.914]                             break
[08:24:56.914]                           }
[08:24:56.914]                         }
[08:24:56.914]                       }
[08:24:56.914]                       invisible(muffled)
[08:24:56.914]                     }
[08:24:56.914]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.914]                   }
[08:24:56.914]                 }
[08:24:56.914]                 else {
[08:24:56.914]                   if (TRUE) {
[08:24:56.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.914]                     {
[08:24:56.914]                       inherits <- base::inherits
[08:24:56.914]                       invokeRestart <- base::invokeRestart
[08:24:56.914]                       is.null <- base::is.null
[08:24:56.914]                       muffled <- FALSE
[08:24:56.914]                       if (inherits(cond, "message")) {
[08:24:56.914]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.914]                         if (muffled) 
[08:24:56.914]                           invokeRestart("muffleMessage")
[08:24:56.914]                       }
[08:24:56.914]                       else if (inherits(cond, "warning")) {
[08:24:56.914]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.914]                         if (muffled) 
[08:24:56.914]                           invokeRestart("muffleWarning")
[08:24:56.914]                       }
[08:24:56.914]                       else if (inherits(cond, "condition")) {
[08:24:56.914]                         if (!is.null(pattern)) {
[08:24:56.914]                           computeRestarts <- base::computeRestarts
[08:24:56.914]                           grepl <- base::grepl
[08:24:56.914]                           restarts <- computeRestarts(cond)
[08:24:56.914]                           for (restart in restarts) {
[08:24:56.914]                             name <- restart$name
[08:24:56.914]                             if (is.null(name)) 
[08:24:56.914]                               next
[08:24:56.914]                             if (!grepl(pattern, name)) 
[08:24:56.914]                               next
[08:24:56.914]                             invokeRestart(restart)
[08:24:56.914]                             muffled <- TRUE
[08:24:56.914]                             break
[08:24:56.914]                           }
[08:24:56.914]                         }
[08:24:56.914]                       }
[08:24:56.914]                       invisible(muffled)
[08:24:56.914]                     }
[08:24:56.914]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.914]                   }
[08:24:56.914]                 }
[08:24:56.914]             }
[08:24:56.914]         }))
[08:24:56.914]     }, error = function(ex) {
[08:24:56.914]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.914]                 ...future.rng), started = ...future.startTime, 
[08:24:56.914]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.914]             version = "1.8"), class = "FutureResult")
[08:24:56.914]     }, finally = {
[08:24:56.914]         if (!identical(...future.workdir, getwd())) 
[08:24:56.914]             setwd(...future.workdir)
[08:24:56.914]         {
[08:24:56.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.914]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.914]             }
[08:24:56.914]             base::options(...future.oldOptions)
[08:24:56.914]             if (.Platform$OS.type == "windows") {
[08:24:56.914]                 old_names <- names(...future.oldEnvVars)
[08:24:56.914]                 envs <- base::Sys.getenv()
[08:24:56.914]                 names <- names(envs)
[08:24:56.914]                 common <- intersect(names, old_names)
[08:24:56.914]                 added <- setdiff(names, old_names)
[08:24:56.914]                 removed <- setdiff(old_names, names)
[08:24:56.914]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.914]                   envs[common]]
[08:24:56.914]                 NAMES <- toupper(changed)
[08:24:56.914]                 args <- list()
[08:24:56.914]                 for (kk in seq_along(NAMES)) {
[08:24:56.914]                   name <- changed[[kk]]
[08:24:56.914]                   NAME <- NAMES[[kk]]
[08:24:56.914]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.914]                     next
[08:24:56.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.914]                 }
[08:24:56.914]                 NAMES <- toupper(added)
[08:24:56.914]                 for (kk in seq_along(NAMES)) {
[08:24:56.914]                   name <- added[[kk]]
[08:24:56.914]                   NAME <- NAMES[[kk]]
[08:24:56.914]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.914]                     next
[08:24:56.914]                   args[[name]] <- ""
[08:24:56.914]                 }
[08:24:56.914]                 NAMES <- toupper(removed)
[08:24:56.914]                 for (kk in seq_along(NAMES)) {
[08:24:56.914]                   name <- removed[[kk]]
[08:24:56.914]                   NAME <- NAMES[[kk]]
[08:24:56.914]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.914]                     next
[08:24:56.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.914]                 }
[08:24:56.914]                 if (length(args) > 0) 
[08:24:56.914]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.914]             }
[08:24:56.914]             else {
[08:24:56.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.914]             }
[08:24:56.914]             {
[08:24:56.914]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.914]                   0L) {
[08:24:56.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.914]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.914]                   base::options(opts)
[08:24:56.914]                 }
[08:24:56.914]                 {
[08:24:56.914]                   {
[08:24:56.914]                     NULL
[08:24:56.914]                     RNGkind("Mersenne-Twister")
[08:24:56.914]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.914]                       inherits = FALSE)
[08:24:56.914]                   }
[08:24:56.914]                   options(future.plan = NULL)
[08:24:56.914]                   if (is.na(NA_character_)) 
[08:24:56.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.914]                     .init = FALSE)
[08:24:56.914]                 }
[08:24:56.914]             }
[08:24:56.914]         }
[08:24:56.914]     })
[08:24:56.914]     if (TRUE) {
[08:24:56.914]         base::sink(type = "output", split = FALSE)
[08:24:56.914]         if (TRUE) {
[08:24:56.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.914]         }
[08:24:56.914]         else {
[08:24:56.914]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.914]         }
[08:24:56.914]         base::close(...future.stdout)
[08:24:56.914]         ...future.stdout <- NULL
[08:24:56.914]     }
[08:24:56.914]     ...future.result$conditions <- ...future.conditions
[08:24:56.914]     ...future.result$finished <- base::Sys.time()
[08:24:56.914]     ...future.result
[08:24:56.914] }
[08:24:56.916] assign_globals() ...
[08:24:56.916] List of 5
[08:24:56.916]  $ ...future.FUN            :function (object, ...)  
[08:24:56.916]  $ future.call.arguments    : list()
[08:24:56.916]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.916]  $ ...future.elements_ii    :List of 3
[08:24:56.916]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.916]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:56.916]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.916]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.916]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:56.916]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.916]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:56.916]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:56.916]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:56.916]  $ ...future.seeds_ii       : NULL
[08:24:56.916]  $ ...future.globals.maxSize: NULL
[08:24:56.916]  - attr(*, "where")=List of 5
[08:24:56.916]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.916]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.916]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.916]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.916]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.916]  - attr(*, "resolved")= logi FALSE
[08:24:56.916]  - attr(*, "total_size")= num 15670
[08:24:56.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.916]  - attr(*, "already-done")= logi TRUE
[08:24:56.926] - copied ‘...future.FUN’ to environment
[08:24:56.926] - copied ‘future.call.arguments’ to environment
[08:24:56.926] - copied ‘...future.elements_ii’ to environment
[08:24:56.926] - copied ‘...future.seeds_ii’ to environment
[08:24:56.926] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.926] assign_globals() ... done
[08:24:56.927] plan(): Setting new future strategy stack:
[08:24:56.927] List of future strategies:
[08:24:56.927] 1. sequential:
[08:24:56.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.927]    - tweaked: FALSE
[08:24:56.927]    - call: NULL
[08:24:56.927] plan(): nbrOfWorkers() = 1
[08:24:56.929] plan(): Setting new future strategy stack:
[08:24:56.929] List of future strategies:
[08:24:56.929] 1. multisession:
[08:24:56.929]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:56.929]    - tweaked: FALSE
[08:24:56.929]    - call: plan(strategy)
[08:24:56.931] plan(): nbrOfWorkers() = 1
[08:24:56.931] SequentialFuture started (and completed)
[08:24:56.931] - Launch lazy future ... done
[08:24:56.931] run() for ‘SequentialFuture’ ... done
[08:24:56.932] Created future:
[08:24:56.932] SequentialFuture:
[08:24:56.932] Label: ‘future_by-1’
[08:24:56.932] Expression:
[08:24:56.932] {
[08:24:56.932]     do.call(function(...) {
[08:24:56.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.932]             on.exit(options(oopts), add = TRUE)
[08:24:56.932]         }
[08:24:56.932]         {
[08:24:56.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.932]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.932]             })
[08:24:56.932]         }
[08:24:56.932]     }, args = future.call.arguments)
[08:24:56.932] }
[08:24:56.932] Lazy evaluation: FALSE
[08:24:56.932] Asynchronous evaluation: FALSE
[08:24:56.932] Local evaluation: TRUE
[08:24:56.932] Environment: R_GlobalEnv
[08:24:56.932] Capture standard output: TRUE
[08:24:56.932] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.932] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.932] Packages: <none>
[08:24:56.932] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.932] Resolved: TRUE
[08:24:56.932] Value: 1.16 KiB of class ‘list’
[08:24:56.932] Early signaling: FALSE
[08:24:56.932] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.932] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.933] Chunk #1 of 1 ... DONE
[08:24:56.933] Launching 1 futures (chunks) ... DONE
[08:24:56.933] Resolving 1 futures (chunks) ...
[08:24:56.933] resolve() on list ...
[08:24:56.933]  recursive: 0
[08:24:56.933]  length: 1
[08:24:56.933] 
[08:24:56.933] resolved() for ‘SequentialFuture’ ...
[08:24:56.933] - state: ‘finished’
[08:24:56.933] - run: TRUE
[08:24:56.933] - result: ‘FutureResult’
[08:24:56.934] resolved() for ‘SequentialFuture’ ... done
[08:24:56.934] Future #1
[08:24:56.934] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.934] - nx: 1
[08:24:56.934] - relay: TRUE
[08:24:56.934] - stdout: TRUE
[08:24:56.934] - signal: TRUE
[08:24:56.934] - resignal: FALSE
[08:24:56.934] - force: TRUE
[08:24:56.934] - relayed: [n=1] FALSE
[08:24:56.934] - queued futures: [n=1] FALSE
[08:24:56.935]  - until=1
[08:24:56.935]  - relaying element #1
[08:24:56.935] - relayed: [n=1] TRUE
[08:24:56.935] - queued futures: [n=1] TRUE
[08:24:56.935] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.935]  length: 0 (resolved future 1)
[08:24:56.935] Relaying remaining futures
[08:24:56.935] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.935] - nx: 1
[08:24:56.935] - relay: TRUE
[08:24:56.935] - stdout: TRUE
[08:24:56.936] - signal: TRUE
[08:24:56.936] - resignal: FALSE
[08:24:56.936] - force: TRUE
[08:24:56.936] - relayed: [n=1] TRUE
[08:24:56.936] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.936] - relayed: [n=1] TRUE
[08:24:56.936] - queued futures: [n=1] TRUE
[08:24:56.936] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.936] resolve() on list ... DONE
[08:24:56.936]  - Number of value chunks collected: 1
[08:24:56.937] Resolving 1 futures (chunks) ... DONE
[08:24:56.937] Reducing values from 1 chunks ...
[08:24:56.937]  - Number of values collected after concatenation: 3
[08:24:56.937]  - Number of values expected: 3
[08:24:56.937] Reducing values from 1 chunks ... DONE
[08:24:56.937] future_lapply() ... DONE
[08:24:56.937] future_by_internal() ... DONE
[08:24:56.937] future_by_internal() ...
[08:24:56.938] future_lapply() ...
[08:24:56.939] Number of chunks: 1
[08:24:56.940] getGlobalsAndPackagesXApply() ...
[08:24:56.940]  - future.globals: TRUE
[08:24:56.940] getGlobalsAndPackages() ...
[08:24:56.940] Searching for globals...
[08:24:56.941] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:56.941] Searching for globals ... DONE
[08:24:56.941] Resolving globals: FALSE
[08:24:56.943] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:56.944] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:56.944] - globals: [1] ‘FUN’
[08:24:56.944] 
[08:24:56.944] getGlobalsAndPackages() ... DONE
[08:24:56.944]  - globals found/used: [n=1] ‘FUN’
[08:24:56.944]  - needed namespaces: [n=0] 
[08:24:56.944] Finding globals ... DONE
[08:24:56.945]  - use_args: TRUE
[08:24:56.945]  - Getting '...' globals ...
[08:24:56.945] resolve() on list ...
[08:24:56.945]  recursive: 0
[08:24:56.945]  length: 1
[08:24:56.945]  elements: ‘...’
[08:24:56.945]  length: 0 (resolved future 1)
[08:24:56.946] resolve() on list ... DONE
[08:24:56.946]    - '...' content: [n=1] ‘digits’
[08:24:56.946] List of 1
[08:24:56.946]  $ ...:List of 1
[08:24:56.946]   ..$ digits: int 2
[08:24:56.946]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.946]  - attr(*, "where")=List of 1
[08:24:56.946]   ..$ ...:<environment: 0x557b2829c690> 
[08:24:56.946]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.946]  - attr(*, "resolved")= logi TRUE
[08:24:56.946]  - attr(*, "total_size")= num NA
[08:24:56.949]  - Getting '...' globals ... DONE
[08:24:56.949] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.949] List of 2
[08:24:56.949]  $ ...future.FUN:function (object, ...)  
[08:24:56.949]  $ ...          :List of 1
[08:24:56.949]   ..$ digits: int 2
[08:24:56.949]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.949]  - attr(*, "where")=List of 2
[08:24:56.949]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.949]   ..$ ...          :<environment: 0x557b2829c690> 
[08:24:56.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.949]  - attr(*, "resolved")= logi FALSE
[08:24:56.949]  - attr(*, "total_size")= num 13284
[08:24:56.952] Packages to be attached in all futures: [n=0] 
[08:24:56.952] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.952] Number of futures (= number of chunks): 1
[08:24:56.952] Launching 1 futures (chunks) ...
[08:24:56.952] Chunk #1 of 1 ...
[08:24:56.953]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.953] getGlobalsAndPackages() ...
[08:24:56.953] Searching for globals...
[08:24:56.953] 
[08:24:56.953] Searching for globals ... DONE
[08:24:56.953] - globals: [0] <none>
[08:24:56.953] getGlobalsAndPackages() ... DONE
[08:24:56.953]    + additional globals found: [n=0] 
[08:24:56.953]    + additional namespaces needed: [n=0] 
[08:24:56.954]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:56.954]  - seeds: <none>
[08:24:56.954]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.954] getGlobalsAndPackages() ...
[08:24:56.954] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.954] Resolving globals: FALSE
[08:24:56.954] Tweak future expression to call with '...' arguments ...
[08:24:56.954] {
[08:24:56.954]     do.call(function(...) {
[08:24:56.954]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.954]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.954]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.954]             on.exit(options(oopts), add = TRUE)
[08:24:56.954]         }
[08:24:56.954]         {
[08:24:56.954]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.954]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.954]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.954]             })
[08:24:56.954]         }
[08:24:56.954]     }, args = future.call.arguments)
[08:24:56.954] }
[08:24:56.954] Tweak future expression to call with '...' arguments ... DONE
[08:24:56.955] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:56.955] 
[08:24:56.955] getGlobalsAndPackages() ... DONE
[08:24:56.955] run() for ‘Future’ ...
[08:24:56.955] - state: ‘created’
[08:24:56.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:56.957] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.957] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:56.957]   - Field: ‘label’
[08:24:56.957]   - Field: ‘local’
[08:24:56.957]   - Field: ‘owner’
[08:24:56.958]   - Field: ‘envir’
[08:24:56.958]   - Field: ‘packages’
[08:24:56.958]   - Field: ‘gc’
[08:24:56.958]   - Field: ‘conditions’
[08:24:56.958]   - Field: ‘expr’
[08:24:56.958]   - Field: ‘uuid’
[08:24:56.958]   - Field: ‘seed’
[08:24:56.958]   - Field: ‘version’
[08:24:56.958]   - Field: ‘result’
[08:24:56.958]   - Field: ‘asynchronous’
[08:24:56.958]   - Field: ‘calls’
[08:24:56.959]   - Field: ‘globals’
[08:24:56.959]   - Field: ‘stdout’
[08:24:56.959]   - Field: ‘earlySignal’
[08:24:56.959]   - Field: ‘lazy’
[08:24:56.959]   - Field: ‘state’
[08:24:56.959] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:56.959] - Launch lazy future ...
[08:24:56.959] Packages needed by the future expression (n = 0): <none>
[08:24:56.959] Packages needed by future strategies (n = 0): <none>
[08:24:56.960] {
[08:24:56.960]     {
[08:24:56.960]         {
[08:24:56.960]             ...future.startTime <- base::Sys.time()
[08:24:56.960]             {
[08:24:56.960]                 {
[08:24:56.960]                   {
[08:24:56.960]                     base::local({
[08:24:56.960]                       has_future <- base::requireNamespace("future", 
[08:24:56.960]                         quietly = TRUE)
[08:24:56.960]                       if (has_future) {
[08:24:56.960]                         ns <- base::getNamespace("future")
[08:24:56.960]                         version <- ns[[".package"]][["version"]]
[08:24:56.960]                         if (is.null(version)) 
[08:24:56.960]                           version <- utils::packageVersion("future")
[08:24:56.960]                       }
[08:24:56.960]                       else {
[08:24:56.960]                         version <- NULL
[08:24:56.960]                       }
[08:24:56.960]                       if (!has_future || version < "1.8.0") {
[08:24:56.960]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:56.960]                           "", base::R.version$version.string), 
[08:24:56.960]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:56.960]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:56.960]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:56.960]                             "release", "version")], collapse = " "), 
[08:24:56.960]                           hostname = base::Sys.info()[["nodename"]])
[08:24:56.960]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:56.960]                           info)
[08:24:56.960]                         info <- base::paste(info, collapse = "; ")
[08:24:56.960]                         if (!has_future) {
[08:24:56.960]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:56.960]                             info)
[08:24:56.960]                         }
[08:24:56.960]                         else {
[08:24:56.960]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:56.960]                             info, version)
[08:24:56.960]                         }
[08:24:56.960]                         base::stop(msg)
[08:24:56.960]                       }
[08:24:56.960]                     })
[08:24:56.960]                   }
[08:24:56.960]                   ...future.strategy.old <- future::plan("list")
[08:24:56.960]                   options(future.plan = NULL)
[08:24:56.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:56.960]                 }
[08:24:56.960]                 ...future.workdir <- getwd()
[08:24:56.960]             }
[08:24:56.960]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:56.960]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:56.960]         }
[08:24:56.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:56.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:56.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:56.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:56.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:56.960]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:56.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:56.960]             base::names(...future.oldOptions))
[08:24:56.960]     }
[08:24:56.960]     if (FALSE) {
[08:24:56.960]     }
[08:24:56.960]     else {
[08:24:56.960]         if (TRUE) {
[08:24:56.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:56.960]                 open = "w")
[08:24:56.960]         }
[08:24:56.960]         else {
[08:24:56.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:56.960]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:56.960]         }
[08:24:56.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:56.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:56.960]             base::sink(type = "output", split = FALSE)
[08:24:56.960]             base::close(...future.stdout)
[08:24:56.960]         }, add = TRUE)
[08:24:56.960]     }
[08:24:56.960]     ...future.frame <- base::sys.nframe()
[08:24:56.960]     ...future.conditions <- base::list()
[08:24:56.960]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:56.960]     if (FALSE) {
[08:24:56.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:56.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:56.960]     }
[08:24:56.960]     ...future.result <- base::tryCatch({
[08:24:56.960]         base::withCallingHandlers({
[08:24:56.960]             ...future.value <- base::withVisible(base::local({
[08:24:56.960]                 do.call(function(...) {
[08:24:56.960]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.960]                   if (!identical(...future.globals.maxSize.org, 
[08:24:56.960]                     ...future.globals.maxSize)) {
[08:24:56.960]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.960]                     on.exit(options(oopts), add = TRUE)
[08:24:56.960]                   }
[08:24:56.960]                   {
[08:24:56.960]                     lapply(seq_along(...future.elements_ii), 
[08:24:56.960]                       FUN = function(jj) {
[08:24:56.960]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.960]                         ...future.FUN(...future.X_jj, ...)
[08:24:56.960]                       })
[08:24:56.960]                   }
[08:24:56.960]                 }, args = future.call.arguments)
[08:24:56.960]             }))
[08:24:56.960]             future::FutureResult(value = ...future.value$value, 
[08:24:56.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.960]                   ...future.rng), globalenv = if (FALSE) 
[08:24:56.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:56.960]                     ...future.globalenv.names))
[08:24:56.960]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:56.960]         }, condition = base::local({
[08:24:56.960]             c <- base::c
[08:24:56.960]             inherits <- base::inherits
[08:24:56.960]             invokeRestart <- base::invokeRestart
[08:24:56.960]             length <- base::length
[08:24:56.960]             list <- base::list
[08:24:56.960]             seq.int <- base::seq.int
[08:24:56.960]             signalCondition <- base::signalCondition
[08:24:56.960]             sys.calls <- base::sys.calls
[08:24:56.960]             `[[` <- base::`[[`
[08:24:56.960]             `+` <- base::`+`
[08:24:56.960]             `<<-` <- base::`<<-`
[08:24:56.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:56.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:56.960]                   3L)]
[08:24:56.960]             }
[08:24:56.960]             function(cond) {
[08:24:56.960]                 is_error <- inherits(cond, "error")
[08:24:56.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:56.960]                   NULL)
[08:24:56.960]                 if (is_error) {
[08:24:56.960]                   sessionInformation <- function() {
[08:24:56.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:56.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:56.960]                       search = base::search(), system = base::Sys.info())
[08:24:56.960]                   }
[08:24:56.960]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:56.960]                     cond$call), session = sessionInformation(), 
[08:24:56.960]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:56.960]                   signalCondition(cond)
[08:24:56.960]                 }
[08:24:56.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:56.960]                 "immediateCondition"))) {
[08:24:56.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:56.960]                   ...future.conditions[[length(...future.conditions) + 
[08:24:56.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:56.960]                   if (TRUE && !signal) {
[08:24:56.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.960]                     {
[08:24:56.960]                       inherits <- base::inherits
[08:24:56.960]                       invokeRestart <- base::invokeRestart
[08:24:56.960]                       is.null <- base::is.null
[08:24:56.960]                       muffled <- FALSE
[08:24:56.960]                       if (inherits(cond, "message")) {
[08:24:56.960]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.960]                         if (muffled) 
[08:24:56.960]                           invokeRestart("muffleMessage")
[08:24:56.960]                       }
[08:24:56.960]                       else if (inherits(cond, "warning")) {
[08:24:56.960]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.960]                         if (muffled) 
[08:24:56.960]                           invokeRestart("muffleWarning")
[08:24:56.960]                       }
[08:24:56.960]                       else if (inherits(cond, "condition")) {
[08:24:56.960]                         if (!is.null(pattern)) {
[08:24:56.960]                           computeRestarts <- base::computeRestarts
[08:24:56.960]                           grepl <- base::grepl
[08:24:56.960]                           restarts <- computeRestarts(cond)
[08:24:56.960]                           for (restart in restarts) {
[08:24:56.960]                             name <- restart$name
[08:24:56.960]                             if (is.null(name)) 
[08:24:56.960]                               next
[08:24:56.960]                             if (!grepl(pattern, name)) 
[08:24:56.960]                               next
[08:24:56.960]                             invokeRestart(restart)
[08:24:56.960]                             muffled <- TRUE
[08:24:56.960]                             break
[08:24:56.960]                           }
[08:24:56.960]                         }
[08:24:56.960]                       }
[08:24:56.960]                       invisible(muffled)
[08:24:56.960]                     }
[08:24:56.960]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.960]                   }
[08:24:56.960]                 }
[08:24:56.960]                 else {
[08:24:56.960]                   if (TRUE) {
[08:24:56.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:56.960]                     {
[08:24:56.960]                       inherits <- base::inherits
[08:24:56.960]                       invokeRestart <- base::invokeRestart
[08:24:56.960]                       is.null <- base::is.null
[08:24:56.960]                       muffled <- FALSE
[08:24:56.960]                       if (inherits(cond, "message")) {
[08:24:56.960]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:56.960]                         if (muffled) 
[08:24:56.960]                           invokeRestart("muffleMessage")
[08:24:56.960]                       }
[08:24:56.960]                       else if (inherits(cond, "warning")) {
[08:24:56.960]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:56.960]                         if (muffled) 
[08:24:56.960]                           invokeRestart("muffleWarning")
[08:24:56.960]                       }
[08:24:56.960]                       else if (inherits(cond, "condition")) {
[08:24:56.960]                         if (!is.null(pattern)) {
[08:24:56.960]                           computeRestarts <- base::computeRestarts
[08:24:56.960]                           grepl <- base::grepl
[08:24:56.960]                           restarts <- computeRestarts(cond)
[08:24:56.960]                           for (restart in restarts) {
[08:24:56.960]                             name <- restart$name
[08:24:56.960]                             if (is.null(name)) 
[08:24:56.960]                               next
[08:24:56.960]                             if (!grepl(pattern, name)) 
[08:24:56.960]                               next
[08:24:56.960]                             invokeRestart(restart)
[08:24:56.960]                             muffled <- TRUE
[08:24:56.960]                             break
[08:24:56.960]                           }
[08:24:56.960]                         }
[08:24:56.960]                       }
[08:24:56.960]                       invisible(muffled)
[08:24:56.960]                     }
[08:24:56.960]                     muffleCondition(cond, pattern = "^muffle")
[08:24:56.960]                   }
[08:24:56.960]                 }
[08:24:56.960]             }
[08:24:56.960]         }))
[08:24:56.960]     }, error = function(ex) {
[08:24:56.960]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:56.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:56.960]                 ...future.rng), started = ...future.startTime, 
[08:24:56.960]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:56.960]             version = "1.8"), class = "FutureResult")
[08:24:56.960]     }, finally = {
[08:24:56.960]         if (!identical(...future.workdir, getwd())) 
[08:24:56.960]             setwd(...future.workdir)
[08:24:56.960]         {
[08:24:56.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:56.960]                 ...future.oldOptions$nwarnings <- NULL
[08:24:56.960]             }
[08:24:56.960]             base::options(...future.oldOptions)
[08:24:56.960]             if (.Platform$OS.type == "windows") {
[08:24:56.960]                 old_names <- names(...future.oldEnvVars)
[08:24:56.960]                 envs <- base::Sys.getenv()
[08:24:56.960]                 names <- names(envs)
[08:24:56.960]                 common <- intersect(names, old_names)
[08:24:56.960]                 added <- setdiff(names, old_names)
[08:24:56.960]                 removed <- setdiff(old_names, names)
[08:24:56.960]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:56.960]                   envs[common]]
[08:24:56.960]                 NAMES <- toupper(changed)
[08:24:56.960]                 args <- list()
[08:24:56.960]                 for (kk in seq_along(NAMES)) {
[08:24:56.960]                   name <- changed[[kk]]
[08:24:56.960]                   NAME <- NAMES[[kk]]
[08:24:56.960]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.960]                     next
[08:24:56.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.960]                 }
[08:24:56.960]                 NAMES <- toupper(added)
[08:24:56.960]                 for (kk in seq_along(NAMES)) {
[08:24:56.960]                   name <- added[[kk]]
[08:24:56.960]                   NAME <- NAMES[[kk]]
[08:24:56.960]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.960]                     next
[08:24:56.960]                   args[[name]] <- ""
[08:24:56.960]                 }
[08:24:56.960]                 NAMES <- toupper(removed)
[08:24:56.960]                 for (kk in seq_along(NAMES)) {
[08:24:56.960]                   name <- removed[[kk]]
[08:24:56.960]                   NAME <- NAMES[[kk]]
[08:24:56.960]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:56.960]                     next
[08:24:56.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:56.960]                 }
[08:24:56.960]                 if (length(args) > 0) 
[08:24:56.960]                   base::do.call(base::Sys.setenv, args = args)
[08:24:56.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:56.960]             }
[08:24:56.960]             else {
[08:24:56.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:56.960]             }
[08:24:56.960]             {
[08:24:56.960]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:56.960]                   0L) {
[08:24:56.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:56.960]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:56.960]                   base::options(opts)
[08:24:56.960]                 }
[08:24:56.960]                 {
[08:24:56.960]                   {
[08:24:56.960]                     NULL
[08:24:56.960]                     RNGkind("Mersenne-Twister")
[08:24:56.960]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:56.960]                       inherits = FALSE)
[08:24:56.960]                   }
[08:24:56.960]                   options(future.plan = NULL)
[08:24:56.960]                   if (is.na(NA_character_)) 
[08:24:56.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:56.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:56.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:56.960]                     .init = FALSE)
[08:24:56.960]                 }
[08:24:56.960]             }
[08:24:56.960]         }
[08:24:56.960]     })
[08:24:56.960]     if (TRUE) {
[08:24:56.960]         base::sink(type = "output", split = FALSE)
[08:24:56.960]         if (TRUE) {
[08:24:56.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:56.960]         }
[08:24:56.960]         else {
[08:24:56.960]             ...future.result["stdout"] <- base::list(NULL)
[08:24:56.960]         }
[08:24:56.960]         base::close(...future.stdout)
[08:24:56.960]         ...future.stdout <- NULL
[08:24:56.960]     }
[08:24:56.960]     ...future.result$conditions <- ...future.conditions
[08:24:56.960]     ...future.result$finished <- base::Sys.time()
[08:24:56.960]     ...future.result
[08:24:56.960] }
[08:24:56.962] assign_globals() ...
[08:24:56.962] List of 5
[08:24:56.962]  $ ...future.FUN            :function (object, ...)  
[08:24:56.962]  $ future.call.arguments    :List of 1
[08:24:56.962]   ..$ digits: int 2
[08:24:56.962]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.962]  $ ...future.elements_ii    :List of 6
[08:24:56.962]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[08:24:56.962]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[08:24:56.962]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[08:24:56.962]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[08:24:56.962]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[08:24:56.962]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[08:24:56.962]  $ ...future.seeds_ii       : NULL
[08:24:56.962]  $ ...future.globals.maxSize: NULL
[08:24:56.962]  - attr(*, "where")=List of 5
[08:24:56.962]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:56.962]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:56.962]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:56.962]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:56.962]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:56.962]  - attr(*, "resolved")= logi FALSE
[08:24:56.962]  - attr(*, "total_size")= num 13284
[08:24:56.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.962]  - attr(*, "already-done")= logi TRUE
[08:24:56.971] - copied ‘...future.FUN’ to environment
[08:24:56.971] - copied ‘future.call.arguments’ to environment
[08:24:56.971] - copied ‘...future.elements_ii’ to environment
[08:24:56.971] - copied ‘...future.seeds_ii’ to environment
[08:24:56.971] - copied ‘...future.globals.maxSize’ to environment
[08:24:56.971] assign_globals() ... done
[08:24:56.971] plan(): Setting new future strategy stack:
[08:24:56.971] List of future strategies:
[08:24:56.971] 1. sequential:
[08:24:56.971]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:56.971]    - tweaked: FALSE
[08:24:56.971]    - call: NULL
[08:24:56.972] plan(): nbrOfWorkers() = 1
[08:24:56.973] plan(): Setting new future strategy stack:
[08:24:56.973] List of future strategies:
[08:24:56.973] 1. multisession:
[08:24:56.973]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:56.973]    - tweaked: FALSE
[08:24:56.973]    - call: plan(strategy)
[08:24:56.975] plan(): nbrOfWorkers() = 1
[08:24:56.975] SequentialFuture started (and completed)
[08:24:56.975] - Launch lazy future ... done
[08:24:56.975] run() for ‘SequentialFuture’ ... done
[08:24:56.976] Created future:
[08:24:56.976] SequentialFuture:
[08:24:56.976] Label: ‘future_by-1’
[08:24:56.976] Expression:
[08:24:56.976] {
[08:24:56.976]     do.call(function(...) {
[08:24:56.976]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:56.976]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:56.976]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:56.976]             on.exit(options(oopts), add = TRUE)
[08:24:56.976]         }
[08:24:56.976]         {
[08:24:56.976]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:56.976]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:56.976]                 ...future.FUN(...future.X_jj, ...)
[08:24:56.976]             })
[08:24:56.976]         }
[08:24:56.976]     }, args = future.call.arguments)
[08:24:56.976] }
[08:24:56.976] Lazy evaluation: FALSE
[08:24:56.976] Asynchronous evaluation: FALSE
[08:24:56.976] Local evaluation: TRUE
[08:24:56.976] Environment: R_GlobalEnv
[08:24:56.976] Capture standard output: TRUE
[08:24:56.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:56.976] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:56.976] Packages: <none>
[08:24:56.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:56.976] Resolved: TRUE
[08:24:56.976] Value: 1.27 KiB of class ‘list’
[08:24:56.976] Early signaling: FALSE
[08:24:56.976] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:56.976] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:56.977] Chunk #1 of 1 ... DONE
[08:24:56.977] Launching 1 futures (chunks) ... DONE
[08:24:56.977] Resolving 1 futures (chunks) ...
[08:24:56.977] resolve() on list ...
[08:24:56.977]  recursive: 0
[08:24:56.977]  length: 1
[08:24:56.977] 
[08:24:56.977] resolved() for ‘SequentialFuture’ ...
[08:24:56.977] - state: ‘finished’
[08:24:56.977] - run: TRUE
[08:24:56.978] - result: ‘FutureResult’
[08:24:56.978] resolved() for ‘SequentialFuture’ ... done
[08:24:56.978] Future #1
[08:24:56.978] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:56.978] - nx: 1
[08:24:56.978] - relay: TRUE
[08:24:56.978] - stdout: TRUE
[08:24:56.978] - signal: TRUE
[08:24:56.978] - resignal: FALSE
[08:24:56.978] - force: TRUE
[08:24:56.978] - relayed: [n=1] FALSE
[08:24:56.979] - queued futures: [n=1] FALSE
[08:24:56.979]  - until=1
[08:24:56.979]  - relaying element #1
[08:24:56.979] - relayed: [n=1] TRUE
[08:24:56.979] - queued futures: [n=1] TRUE
[08:24:56.979] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:56.979]  length: 0 (resolved future 1)
[08:24:56.979] Relaying remaining futures
[08:24:56.979] signalConditionsASAP(NULL, pos=0) ...
[08:24:56.979] - nx: 1
[08:24:56.980] - relay: TRUE
[08:24:56.980] - stdout: TRUE
[08:24:56.980] - signal: TRUE
[08:24:56.980] - resignal: FALSE
[08:24:56.980] - force: TRUE
[08:24:56.980] - relayed: [n=1] TRUE
[08:24:56.980] - queued futures: [n=1] TRUE
 - flush all
[08:24:56.980] - relayed: [n=1] TRUE
[08:24:56.980] - queued futures: [n=1] TRUE
[08:24:56.980] signalConditionsASAP(NULL, pos=0) ... done
[08:24:56.980] resolve() on list ... DONE
[08:24:56.981]  - Number of value chunks collected: 1
[08:24:56.981] Resolving 1 futures (chunks) ... DONE
[08:24:56.981] Reducing values from 1 chunks ...
[08:24:56.981]  - Number of values collected after concatenation: 6
[08:24:56.981]  - Number of values expected: 6
[08:24:56.981] Reducing values from 1 chunks ... DONE
[08:24:56.981] future_lapply() ... DONE
[08:24:56.981] future_by_internal() ... DONE
[08:24:56.982] future_by_internal() ...
[08:24:56.983] future_lapply() ...
[08:24:56.985] Number of chunks: 1
[08:24:56.985] getGlobalsAndPackagesXApply() ...
[08:24:56.985]  - future.globals: TRUE
[08:24:56.985] getGlobalsAndPackages() ...
[08:24:56.985] Searching for globals...
[08:24:56.988] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:56.989] Searching for globals ... DONE
[08:24:56.989] Resolving globals: FALSE
[08:24:56.989] The total size of the 1 globals is 762 bytes (762 bytes)
[08:24:56.990] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[08:24:56.990] - globals: [1] ‘FUN’
[08:24:56.990] - packages: [1] ‘stats’
[08:24:56.990] getGlobalsAndPackages() ... DONE
[08:24:56.990]  - globals found/used: [n=1] ‘FUN’
[08:24:56.990]  - needed namespaces: [n=1] ‘stats’
[08:24:56.990] Finding globals ... DONE
[08:24:56.990]  - use_args: TRUE
[08:24:56.991]  - Getting '...' globals ...
[08:24:56.991] resolve() on list ...
[08:24:56.991]  recursive: 0
[08:24:56.991]  length: 1
[08:24:56.991]  elements: ‘...’
[08:24:56.991]  length: 0 (resolved future 1)
[08:24:56.991] resolve() on list ... DONE
[08:24:56.991]    - '...' content: [n=1] ‘singular.ok’
[08:24:56.992] List of 1
[08:24:56.992]  $ ...:List of 1
[08:24:56.992]   ..$ singular.ok: logi FALSE
[08:24:56.992]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.992]  - attr(*, "where")=List of 1
[08:24:56.992]   ..$ ...:<environment: 0x557b28186380> 
[08:24:56.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.992]  - attr(*, "resolved")= logi TRUE
[08:24:56.992]  - attr(*, "total_size")= num NA
[08:24:56.994]  - Getting '...' globals ... DONE
[08:24:56.995] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:56.995] List of 2
[08:24:56.995]  $ ...future.FUN:function (x, ...)  
[08:24:56.995]  $ ...          :List of 1
[08:24:56.995]   ..$ singular.ok: logi FALSE
[08:24:56.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:56.995]  - attr(*, "where")=List of 2
[08:24:56.995]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:56.995]   ..$ ...          :<environment: 0x557b28186380> 
[08:24:56.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:56.995]  - attr(*, "resolved")= logi FALSE
[08:24:56.995]  - attr(*, "total_size")= num 19977
[08:24:56.998] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:56.998] getGlobalsAndPackagesXApply() ... DONE
[08:24:56.998] Number of futures (= number of chunks): 1
[08:24:56.998] Launching 1 futures (chunks) ...
[08:24:56.998] Chunk #1 of 1 ...
[08:24:56.998]  - Finding globals in 'X' for chunk #1 ...
[08:24:56.999] getGlobalsAndPackages() ...
[08:24:56.999] Searching for globals...
[08:24:56.999] 
[08:24:56.999] Searching for globals ... DONE
[08:24:56.999] - globals: [0] <none>
[08:24:56.999] getGlobalsAndPackages() ... DONE
[08:24:56.999]    + additional globals found: [n=0] 
[08:24:57.000]    + additional namespaces needed: [n=0] 
[08:24:57.000]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.000]  - seeds: <none>
[08:24:57.000]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.000] getGlobalsAndPackages() ...
[08:24:57.000] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.000] Resolving globals: FALSE
[08:24:57.000] Tweak future expression to call with '...' arguments ...
[08:24:57.000] {
[08:24:57.000]     do.call(function(...) {
[08:24:57.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.000]             on.exit(options(oopts), add = TRUE)
[08:24:57.000]         }
[08:24:57.000]         {
[08:24:57.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.000]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.000]             })
[08:24:57.000]         }
[08:24:57.000]     }, args = future.call.arguments)
[08:24:57.000] }
[08:24:57.001] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.001] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.001] 
[08:24:57.001] getGlobalsAndPackages() ... DONE
[08:24:57.001] run() for ‘Future’ ...
[08:24:57.002] - state: ‘created’
[08:24:57.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.003] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.003]   - Field: ‘label’
[08:24:57.004]   - Field: ‘local’
[08:24:57.004]   - Field: ‘owner’
[08:24:57.004]   - Field: ‘envir’
[08:24:57.004]   - Field: ‘packages’
[08:24:57.004]   - Field: ‘gc’
[08:24:57.004]   - Field: ‘conditions’
[08:24:57.004]   - Field: ‘expr’
[08:24:57.004]   - Field: ‘uuid’
[08:24:57.004]   - Field: ‘seed’
[08:24:57.004]   - Field: ‘version’
[08:24:57.004]   - Field: ‘result’
[08:24:57.005]   - Field: ‘asynchronous’
[08:24:57.005]   - Field: ‘calls’
[08:24:57.005]   - Field: ‘globals’
[08:24:57.005]   - Field: ‘stdout’
[08:24:57.005]   - Field: ‘earlySignal’
[08:24:57.005]   - Field: ‘lazy’
[08:24:57.005]   - Field: ‘state’
[08:24:57.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.005] - Launch lazy future ...
[08:24:57.005] Packages needed by the future expression (n = 1): ‘stats’
[08:24:57.006] Packages needed by future strategies (n = 0): <none>
[08:24:57.006] {
[08:24:57.006]     {
[08:24:57.006]         {
[08:24:57.006]             ...future.startTime <- base::Sys.time()
[08:24:57.006]             {
[08:24:57.006]                 {
[08:24:57.006]                   {
[08:24:57.006]                     {
[08:24:57.006]                       base::local({
[08:24:57.006]                         has_future <- base::requireNamespace("future", 
[08:24:57.006]                           quietly = TRUE)
[08:24:57.006]                         if (has_future) {
[08:24:57.006]                           ns <- base::getNamespace("future")
[08:24:57.006]                           version <- ns[[".package"]][["version"]]
[08:24:57.006]                           if (is.null(version)) 
[08:24:57.006]                             version <- utils::packageVersion("future")
[08:24:57.006]                         }
[08:24:57.006]                         else {
[08:24:57.006]                           version <- NULL
[08:24:57.006]                         }
[08:24:57.006]                         if (!has_future || version < "1.8.0") {
[08:24:57.006]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.006]                             "", base::R.version$version.string), 
[08:24:57.006]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:57.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.006]                               "release", "version")], collapse = " "), 
[08:24:57.006]                             hostname = base::Sys.info()[["nodename"]])
[08:24:57.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.006]                             info)
[08:24:57.006]                           info <- base::paste(info, collapse = "; ")
[08:24:57.006]                           if (!has_future) {
[08:24:57.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.006]                               info)
[08:24:57.006]                           }
[08:24:57.006]                           else {
[08:24:57.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.006]                               info, version)
[08:24:57.006]                           }
[08:24:57.006]                           base::stop(msg)
[08:24:57.006]                         }
[08:24:57.006]                       })
[08:24:57.006]                     }
[08:24:57.006]                     base::local({
[08:24:57.006]                       for (pkg in "stats") {
[08:24:57.006]                         base::loadNamespace(pkg)
[08:24:57.006]                         base::library(pkg, character.only = TRUE)
[08:24:57.006]                       }
[08:24:57.006]                     })
[08:24:57.006]                   }
[08:24:57.006]                   ...future.strategy.old <- future::plan("list")
[08:24:57.006]                   options(future.plan = NULL)
[08:24:57.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.006]                 }
[08:24:57.006]                 ...future.workdir <- getwd()
[08:24:57.006]             }
[08:24:57.006]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.006]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.006]         }
[08:24:57.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.006]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.006]             base::names(...future.oldOptions))
[08:24:57.006]     }
[08:24:57.006]     if (FALSE) {
[08:24:57.006]     }
[08:24:57.006]     else {
[08:24:57.006]         if (TRUE) {
[08:24:57.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.006]                 open = "w")
[08:24:57.006]         }
[08:24:57.006]         else {
[08:24:57.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.006]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.006]         }
[08:24:57.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.006]             base::sink(type = "output", split = FALSE)
[08:24:57.006]             base::close(...future.stdout)
[08:24:57.006]         }, add = TRUE)
[08:24:57.006]     }
[08:24:57.006]     ...future.frame <- base::sys.nframe()
[08:24:57.006]     ...future.conditions <- base::list()
[08:24:57.006]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.006]     if (FALSE) {
[08:24:57.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.006]     }
[08:24:57.006]     ...future.result <- base::tryCatch({
[08:24:57.006]         base::withCallingHandlers({
[08:24:57.006]             ...future.value <- base::withVisible(base::local({
[08:24:57.006]                 do.call(function(...) {
[08:24:57.006]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.006]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.006]                     ...future.globals.maxSize)) {
[08:24:57.006]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.006]                     on.exit(options(oopts), add = TRUE)
[08:24:57.006]                   }
[08:24:57.006]                   {
[08:24:57.006]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.006]                       FUN = function(jj) {
[08:24:57.006]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.006]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.006]                       })
[08:24:57.006]                   }
[08:24:57.006]                 }, args = future.call.arguments)
[08:24:57.006]             }))
[08:24:57.006]             future::FutureResult(value = ...future.value$value, 
[08:24:57.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.006]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.006]                     ...future.globalenv.names))
[08:24:57.006]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.006]         }, condition = base::local({
[08:24:57.006]             c <- base::c
[08:24:57.006]             inherits <- base::inherits
[08:24:57.006]             invokeRestart <- base::invokeRestart
[08:24:57.006]             length <- base::length
[08:24:57.006]             list <- base::list
[08:24:57.006]             seq.int <- base::seq.int
[08:24:57.006]             signalCondition <- base::signalCondition
[08:24:57.006]             sys.calls <- base::sys.calls
[08:24:57.006]             `[[` <- base::`[[`
[08:24:57.006]             `+` <- base::`+`
[08:24:57.006]             `<<-` <- base::`<<-`
[08:24:57.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.006]                   3L)]
[08:24:57.006]             }
[08:24:57.006]             function(cond) {
[08:24:57.006]                 is_error <- inherits(cond, "error")
[08:24:57.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.006]                   NULL)
[08:24:57.006]                 if (is_error) {
[08:24:57.006]                   sessionInformation <- function() {
[08:24:57.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.006]                       search = base::search(), system = base::Sys.info())
[08:24:57.006]                   }
[08:24:57.006]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.006]                     cond$call), session = sessionInformation(), 
[08:24:57.006]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.006]                   signalCondition(cond)
[08:24:57.006]                 }
[08:24:57.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.006]                 "immediateCondition"))) {
[08:24:57.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.006]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.006]                   if (TRUE && !signal) {
[08:24:57.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.006]                     {
[08:24:57.006]                       inherits <- base::inherits
[08:24:57.006]                       invokeRestart <- base::invokeRestart
[08:24:57.006]                       is.null <- base::is.null
[08:24:57.006]                       muffled <- FALSE
[08:24:57.006]                       if (inherits(cond, "message")) {
[08:24:57.006]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.006]                         if (muffled) 
[08:24:57.006]                           invokeRestart("muffleMessage")
[08:24:57.006]                       }
[08:24:57.006]                       else if (inherits(cond, "warning")) {
[08:24:57.006]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.006]                         if (muffled) 
[08:24:57.006]                           invokeRestart("muffleWarning")
[08:24:57.006]                       }
[08:24:57.006]                       else if (inherits(cond, "condition")) {
[08:24:57.006]                         if (!is.null(pattern)) {
[08:24:57.006]                           computeRestarts <- base::computeRestarts
[08:24:57.006]                           grepl <- base::grepl
[08:24:57.006]                           restarts <- computeRestarts(cond)
[08:24:57.006]                           for (restart in restarts) {
[08:24:57.006]                             name <- restart$name
[08:24:57.006]                             if (is.null(name)) 
[08:24:57.006]                               next
[08:24:57.006]                             if (!grepl(pattern, name)) 
[08:24:57.006]                               next
[08:24:57.006]                             invokeRestart(restart)
[08:24:57.006]                             muffled <- TRUE
[08:24:57.006]                             break
[08:24:57.006]                           }
[08:24:57.006]                         }
[08:24:57.006]                       }
[08:24:57.006]                       invisible(muffled)
[08:24:57.006]                     }
[08:24:57.006]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.006]                   }
[08:24:57.006]                 }
[08:24:57.006]                 else {
[08:24:57.006]                   if (TRUE) {
[08:24:57.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.006]                     {
[08:24:57.006]                       inherits <- base::inherits
[08:24:57.006]                       invokeRestart <- base::invokeRestart
[08:24:57.006]                       is.null <- base::is.null
[08:24:57.006]                       muffled <- FALSE
[08:24:57.006]                       if (inherits(cond, "message")) {
[08:24:57.006]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.006]                         if (muffled) 
[08:24:57.006]                           invokeRestart("muffleMessage")
[08:24:57.006]                       }
[08:24:57.006]                       else if (inherits(cond, "warning")) {
[08:24:57.006]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.006]                         if (muffled) 
[08:24:57.006]                           invokeRestart("muffleWarning")
[08:24:57.006]                       }
[08:24:57.006]                       else if (inherits(cond, "condition")) {
[08:24:57.006]                         if (!is.null(pattern)) {
[08:24:57.006]                           computeRestarts <- base::computeRestarts
[08:24:57.006]                           grepl <- base::grepl
[08:24:57.006]                           restarts <- computeRestarts(cond)
[08:24:57.006]                           for (restart in restarts) {
[08:24:57.006]                             name <- restart$name
[08:24:57.006]                             if (is.null(name)) 
[08:24:57.006]                               next
[08:24:57.006]                             if (!grepl(pattern, name)) 
[08:24:57.006]                               next
[08:24:57.006]                             invokeRestart(restart)
[08:24:57.006]                             muffled <- TRUE
[08:24:57.006]                             break
[08:24:57.006]                           }
[08:24:57.006]                         }
[08:24:57.006]                       }
[08:24:57.006]                       invisible(muffled)
[08:24:57.006]                     }
[08:24:57.006]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.006]                   }
[08:24:57.006]                 }
[08:24:57.006]             }
[08:24:57.006]         }))
[08:24:57.006]     }, error = function(ex) {
[08:24:57.006]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.006]                 ...future.rng), started = ...future.startTime, 
[08:24:57.006]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.006]             version = "1.8"), class = "FutureResult")
[08:24:57.006]     }, finally = {
[08:24:57.006]         if (!identical(...future.workdir, getwd())) 
[08:24:57.006]             setwd(...future.workdir)
[08:24:57.006]         {
[08:24:57.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.006]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.006]             }
[08:24:57.006]             base::options(...future.oldOptions)
[08:24:57.006]             if (.Platform$OS.type == "windows") {
[08:24:57.006]                 old_names <- names(...future.oldEnvVars)
[08:24:57.006]                 envs <- base::Sys.getenv()
[08:24:57.006]                 names <- names(envs)
[08:24:57.006]                 common <- intersect(names, old_names)
[08:24:57.006]                 added <- setdiff(names, old_names)
[08:24:57.006]                 removed <- setdiff(old_names, names)
[08:24:57.006]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.006]                   envs[common]]
[08:24:57.006]                 NAMES <- toupper(changed)
[08:24:57.006]                 args <- list()
[08:24:57.006]                 for (kk in seq_along(NAMES)) {
[08:24:57.006]                   name <- changed[[kk]]
[08:24:57.006]                   NAME <- NAMES[[kk]]
[08:24:57.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.006]                     next
[08:24:57.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.006]                 }
[08:24:57.006]                 NAMES <- toupper(added)
[08:24:57.006]                 for (kk in seq_along(NAMES)) {
[08:24:57.006]                   name <- added[[kk]]
[08:24:57.006]                   NAME <- NAMES[[kk]]
[08:24:57.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.006]                     next
[08:24:57.006]                   args[[name]] <- ""
[08:24:57.006]                 }
[08:24:57.006]                 NAMES <- toupper(removed)
[08:24:57.006]                 for (kk in seq_along(NAMES)) {
[08:24:57.006]                   name <- removed[[kk]]
[08:24:57.006]                   NAME <- NAMES[[kk]]
[08:24:57.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.006]                     next
[08:24:57.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.006]                 }
[08:24:57.006]                 if (length(args) > 0) 
[08:24:57.006]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.006]             }
[08:24:57.006]             else {
[08:24:57.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.006]             }
[08:24:57.006]             {
[08:24:57.006]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.006]                   0L) {
[08:24:57.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.006]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.006]                   base::options(opts)
[08:24:57.006]                 }
[08:24:57.006]                 {
[08:24:57.006]                   {
[08:24:57.006]                     NULL
[08:24:57.006]                     RNGkind("Mersenne-Twister")
[08:24:57.006]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.006]                       inherits = FALSE)
[08:24:57.006]                   }
[08:24:57.006]                   options(future.plan = NULL)
[08:24:57.006]                   if (is.na(NA_character_)) 
[08:24:57.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.006]                     .init = FALSE)
[08:24:57.006]                 }
[08:24:57.006]             }
[08:24:57.006]         }
[08:24:57.006]     })
[08:24:57.006]     if (TRUE) {
[08:24:57.006]         base::sink(type = "output", split = FALSE)
[08:24:57.006]         if (TRUE) {
[08:24:57.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.006]         }
[08:24:57.006]         else {
[08:24:57.006]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.006]         }
[08:24:57.006]         base::close(...future.stdout)
[08:24:57.006]         ...future.stdout <- NULL
[08:24:57.006]     }
[08:24:57.006]     ...future.result$conditions <- ...future.conditions
[08:24:57.006]     ...future.result$finished <- base::Sys.time()
[08:24:57.006]     ...future.result
[08:24:57.006] }
[08:24:57.008] assign_globals() ...
[08:24:57.008] List of 5
[08:24:57.008]  $ ...future.FUN            :function (x, ...)  
[08:24:57.008]  $ future.call.arguments    :List of 1
[08:24:57.008]   ..$ singular.ok: logi FALSE
[08:24:57.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.008]  $ ...future.elements_ii    :List of 3
[08:24:57.008]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.008]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.008]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.008]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.008]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.008]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.008]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.008]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.008]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.008]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.008]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.008]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.008]  $ ...future.seeds_ii       : NULL
[08:24:57.008]  $ ...future.globals.maxSize: NULL
[08:24:57.008]  - attr(*, "where")=List of 5
[08:24:57.008]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.008]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.008]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.008]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.008]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.008]  - attr(*, "resolved")= logi FALSE
[08:24:57.008]  - attr(*, "total_size")= num 19977
[08:24:57.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.008]  - attr(*, "already-done")= logi TRUE
[08:24:57.019] - reassign environment for ‘...future.FUN’
[08:24:57.019] - copied ‘...future.FUN’ to environment
[08:24:57.019] - copied ‘future.call.arguments’ to environment
[08:24:57.020] - copied ‘...future.elements_ii’ to environment
[08:24:57.020] - copied ‘...future.seeds_ii’ to environment
[08:24:57.020] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.020] assign_globals() ... done
[08:24:57.020] plan(): Setting new future strategy stack:
[08:24:57.020] List of future strategies:
[08:24:57.020] 1. sequential:
[08:24:57.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.020]    - tweaked: FALSE
[08:24:57.020]    - call: NULL
[08:24:57.021] plan(): nbrOfWorkers() = 1
[08:24:57.024] plan(): Setting new future strategy stack:
[08:24:57.024] List of future strategies:
[08:24:57.024] 1. multisession:
[08:24:57.024]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:57.024]    - tweaked: FALSE
[08:24:57.024]    - call: plan(strategy)
[08:24:57.025] plan(): nbrOfWorkers() = 1
[08:24:57.026] SequentialFuture started (and completed)
[08:24:57.026] - Launch lazy future ... done
[08:24:57.026] run() for ‘SequentialFuture’ ... done
[08:24:57.026] Created future:
[08:24:57.026] SequentialFuture:
[08:24:57.026] Label: ‘future_by-1’
[08:24:57.026] Expression:
[08:24:57.026] {
[08:24:57.026]     do.call(function(...) {
[08:24:57.026]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.026]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.026]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.026]             on.exit(options(oopts), add = TRUE)
[08:24:57.026]         }
[08:24:57.026]         {
[08:24:57.026]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.026]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.026]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.026]             })
[08:24:57.026]         }
[08:24:57.026]     }, args = future.call.arguments)
[08:24:57.026] }
[08:24:57.026] Lazy evaluation: FALSE
[08:24:57.026] Asynchronous evaluation: FALSE
[08:24:57.026] Local evaluation: TRUE
[08:24:57.026] Environment: R_GlobalEnv
[08:24:57.026] Capture standard output: TRUE
[08:24:57.026] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.026] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.026] Packages: 1 packages (‘stats’)
[08:24:57.026] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.026] Resolved: TRUE
[08:24:57.026] Value: 81.14 KiB of class ‘list’
[08:24:57.026] Early signaling: FALSE
[08:24:57.026] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.026] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.027] Chunk #1 of 1 ... DONE
[08:24:57.028] Launching 1 futures (chunks) ... DONE
[08:24:57.028] Resolving 1 futures (chunks) ...
[08:24:57.028] resolve() on list ...
[08:24:57.028]  recursive: 0
[08:24:57.028]  length: 1
[08:24:57.028] 
[08:24:57.028] resolved() for ‘SequentialFuture’ ...
[08:24:57.028] - state: ‘finished’
[08:24:57.028] - run: TRUE
[08:24:57.028] - result: ‘FutureResult’
[08:24:57.028] resolved() for ‘SequentialFuture’ ... done
[08:24:57.029] Future #1
[08:24:57.029] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.029] - nx: 1
[08:24:57.029] - relay: TRUE
[08:24:57.029] - stdout: TRUE
[08:24:57.029] - signal: TRUE
[08:24:57.029] - resignal: FALSE
[08:24:57.029] - force: TRUE
[08:24:57.029] - relayed: [n=1] FALSE
[08:24:57.029] - queued futures: [n=1] FALSE
[08:24:57.030]  - until=1
[08:24:57.030]  - relaying element #1
[08:24:57.030] - relayed: [n=1] TRUE
[08:24:57.030] - queued futures: [n=1] TRUE
[08:24:57.030] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.030]  length: 0 (resolved future 1)
[08:24:57.030] Relaying remaining futures
[08:24:57.030] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.030] - nx: 1
[08:24:57.030] - relay: TRUE
[08:24:57.030] - stdout: TRUE
[08:24:57.031] - signal: TRUE
[08:24:57.031] - resignal: FALSE
[08:24:57.031] - force: TRUE
[08:24:57.031] - relayed: [n=1] TRUE
[08:24:57.031] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.031] - relayed: [n=1] TRUE
[08:24:57.031] - queued futures: [n=1] TRUE
[08:24:57.031] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.031] resolve() on list ... DONE
[08:24:57.031]  - Number of value chunks collected: 1
[08:24:57.032] Resolving 1 futures (chunks) ... DONE
[08:24:57.032] Reducing values from 1 chunks ...
[08:24:57.032]  - Number of values collected after concatenation: 3
[08:24:57.032]  - Number of values expected: 3
[08:24:57.032] Reducing values from 1 chunks ... DONE
[08:24:57.032] future_lapply() ... DONE
[08:24:57.034] future_by_internal() ... DONE
[08:24:57.038] future_by_internal() ...
[08:24:57.039] future_lapply() ...
[08:24:57.041] Number of chunks: 1
[08:24:57.041] getGlobalsAndPackagesXApply() ...
[08:24:57.041]  - future.globals: TRUE
[08:24:57.041] getGlobalsAndPackages() ...
[08:24:57.041] Searching for globals...
[08:24:57.043] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:57.043] Searching for globals ... DONE
[08:24:57.043] Resolving globals: FALSE
[08:24:57.044] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[08:24:57.044] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[08:24:57.044] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:57.044] - packages: [1] ‘stats’
[08:24:57.044] getGlobalsAndPackages() ... DONE
[08:24:57.044]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:57.045]  - needed namespaces: [n=1] ‘stats’
[08:24:57.045] Finding globals ... DONE
[08:24:57.045]  - use_args: TRUE
[08:24:57.045]  - Getting '...' globals ...
[08:24:57.045] resolve() on list ...
[08:24:57.045]  recursive: 0
[08:24:57.045]  length: 1
[08:24:57.045]  elements: ‘...’
[08:24:57.046]  length: 0 (resolved future 1)
[08:24:57.046] resolve() on list ... DONE
[08:24:57.046]    - '...' content: [n=0] 
[08:24:57.046] List of 1
[08:24:57.046]  $ ...: list()
[08:24:57.046]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.046]  - attr(*, "where")=List of 1
[08:24:57.046]   ..$ ...:<environment: 0x557b25d58948> 
[08:24:57.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.046]  - attr(*, "resolved")= logi TRUE
[08:24:57.046]  - attr(*, "total_size")= num NA
[08:24:57.048]  - Getting '...' globals ... DONE
[08:24:57.049] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[08:24:57.049] List of 4
[08:24:57.049]  $ ...future.FUN:function (x)  
[08:24:57.049]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:57.049]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.049]  $ ...          : list()
[08:24:57.049]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.049]  - attr(*, "where")=List of 4
[08:24:57.049]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.049]   ..$ breaks       :<environment: R_EmptyEnv> 
[08:24:57.049]   ..$ wool         :<environment: R_EmptyEnv> 
[08:24:57.049]   ..$ ...          :<environment: 0x557b25d58948> 
[08:24:57.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.049]  - attr(*, "resolved")= logi FALSE
[08:24:57.049]  - attr(*, "total_size")= num 18867
[08:24:57.055] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:57.055] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.055] Number of futures (= number of chunks): 1
[08:24:57.055] Launching 1 futures (chunks) ...
[08:24:57.055] Chunk #1 of 1 ...
[08:24:57.055]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.056] getGlobalsAndPackages() ...
[08:24:57.056] Searching for globals...
[08:24:57.056] 
[08:24:57.056] Searching for globals ... DONE
[08:24:57.056] - globals: [0] <none>
[08:24:57.056] getGlobalsAndPackages() ... DONE
[08:24:57.056]    + additional globals found: [n=0] 
[08:24:57.057]    + additional namespaces needed: [n=0] 
[08:24:57.057]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.057]  - seeds: <none>
[08:24:57.057]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.057] getGlobalsAndPackages() ...
[08:24:57.057] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.057] Resolving globals: FALSE
[08:24:57.057] Tweak future expression to call with '...' arguments ...
[08:24:57.057] {
[08:24:57.057]     do.call(function(...) {
[08:24:57.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.057]             on.exit(options(oopts), add = TRUE)
[08:24:57.057]         }
[08:24:57.057]         {
[08:24:57.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.057]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.057]             })
[08:24:57.057]         }
[08:24:57.057]     }, args = future.call.arguments)
[08:24:57.057] }
[08:24:57.058] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.058] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.058] 
[08:24:57.058] getGlobalsAndPackages() ... DONE
[08:24:57.059] run() for ‘Future’ ...
[08:24:57.059] - state: ‘created’
[08:24:57.059] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.060] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.061]   - Field: ‘label’
[08:24:57.061]   - Field: ‘local’
[08:24:57.061]   - Field: ‘owner’
[08:24:57.061]   - Field: ‘envir’
[08:24:57.061]   - Field: ‘packages’
[08:24:57.061]   - Field: ‘gc’
[08:24:57.061]   - Field: ‘conditions’
[08:24:57.061]   - Field: ‘expr’
[08:24:57.061]   - Field: ‘uuid’
[08:24:57.062]   - Field: ‘seed’
[08:24:57.062]   - Field: ‘version’
[08:24:57.062]   - Field: ‘result’
[08:24:57.062]   - Field: ‘asynchronous’
[08:24:57.062]   - Field: ‘calls’
[08:24:57.062]   - Field: ‘globals’
[08:24:57.062]   - Field: ‘stdout’
[08:24:57.062]   - Field: ‘earlySignal’
[08:24:57.062]   - Field: ‘lazy’
[08:24:57.062]   - Field: ‘state’
[08:24:57.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.063] - Launch lazy future ...
[08:24:57.063] Packages needed by the future expression (n = 1): ‘stats’
[08:24:57.063] Packages needed by future strategies (n = 0): <none>
[08:24:57.063] {
[08:24:57.063]     {
[08:24:57.063]         {
[08:24:57.063]             ...future.startTime <- base::Sys.time()
[08:24:57.063]             {
[08:24:57.063]                 {
[08:24:57.063]                   {
[08:24:57.063]                     {
[08:24:57.063]                       base::local({
[08:24:57.063]                         has_future <- base::requireNamespace("future", 
[08:24:57.063]                           quietly = TRUE)
[08:24:57.063]                         if (has_future) {
[08:24:57.063]                           ns <- base::getNamespace("future")
[08:24:57.063]                           version <- ns[[".package"]][["version"]]
[08:24:57.063]                           if (is.null(version)) 
[08:24:57.063]                             version <- utils::packageVersion("future")
[08:24:57.063]                         }
[08:24:57.063]                         else {
[08:24:57.063]                           version <- NULL
[08:24:57.063]                         }
[08:24:57.063]                         if (!has_future || version < "1.8.0") {
[08:24:57.063]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.063]                             "", base::R.version$version.string), 
[08:24:57.063]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:57.063]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.063]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.063]                               "release", "version")], collapse = " "), 
[08:24:57.063]                             hostname = base::Sys.info()[["nodename"]])
[08:24:57.063]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.063]                             info)
[08:24:57.063]                           info <- base::paste(info, collapse = "; ")
[08:24:57.063]                           if (!has_future) {
[08:24:57.063]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.063]                               info)
[08:24:57.063]                           }
[08:24:57.063]                           else {
[08:24:57.063]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.063]                               info, version)
[08:24:57.063]                           }
[08:24:57.063]                           base::stop(msg)
[08:24:57.063]                         }
[08:24:57.063]                       })
[08:24:57.063]                     }
[08:24:57.063]                     base::local({
[08:24:57.063]                       for (pkg in "stats") {
[08:24:57.063]                         base::loadNamespace(pkg)
[08:24:57.063]                         base::library(pkg, character.only = TRUE)
[08:24:57.063]                       }
[08:24:57.063]                     })
[08:24:57.063]                   }
[08:24:57.063]                   ...future.strategy.old <- future::plan("list")
[08:24:57.063]                   options(future.plan = NULL)
[08:24:57.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.063]                 }
[08:24:57.063]                 ...future.workdir <- getwd()
[08:24:57.063]             }
[08:24:57.063]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.063]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.063]         }
[08:24:57.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.063]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.063]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.063]             base::names(...future.oldOptions))
[08:24:57.063]     }
[08:24:57.063]     if (FALSE) {
[08:24:57.063]     }
[08:24:57.063]     else {
[08:24:57.063]         if (TRUE) {
[08:24:57.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.063]                 open = "w")
[08:24:57.063]         }
[08:24:57.063]         else {
[08:24:57.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.063]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.063]         }
[08:24:57.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.063]             base::sink(type = "output", split = FALSE)
[08:24:57.063]             base::close(...future.stdout)
[08:24:57.063]         }, add = TRUE)
[08:24:57.063]     }
[08:24:57.063]     ...future.frame <- base::sys.nframe()
[08:24:57.063]     ...future.conditions <- base::list()
[08:24:57.063]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.063]     if (FALSE) {
[08:24:57.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.063]     }
[08:24:57.063]     ...future.result <- base::tryCatch({
[08:24:57.063]         base::withCallingHandlers({
[08:24:57.063]             ...future.value <- base::withVisible(base::local({
[08:24:57.063]                 do.call(function(...) {
[08:24:57.063]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.063]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.063]                     ...future.globals.maxSize)) {
[08:24:57.063]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.063]                     on.exit(options(oopts), add = TRUE)
[08:24:57.063]                   }
[08:24:57.063]                   {
[08:24:57.063]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.063]                       FUN = function(jj) {
[08:24:57.063]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.063]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.063]                       })
[08:24:57.063]                   }
[08:24:57.063]                 }, args = future.call.arguments)
[08:24:57.063]             }))
[08:24:57.063]             future::FutureResult(value = ...future.value$value, 
[08:24:57.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.063]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.063]                     ...future.globalenv.names))
[08:24:57.063]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.063]         }, condition = base::local({
[08:24:57.063]             c <- base::c
[08:24:57.063]             inherits <- base::inherits
[08:24:57.063]             invokeRestart <- base::invokeRestart
[08:24:57.063]             length <- base::length
[08:24:57.063]             list <- base::list
[08:24:57.063]             seq.int <- base::seq.int
[08:24:57.063]             signalCondition <- base::signalCondition
[08:24:57.063]             sys.calls <- base::sys.calls
[08:24:57.063]             `[[` <- base::`[[`
[08:24:57.063]             `+` <- base::`+`
[08:24:57.063]             `<<-` <- base::`<<-`
[08:24:57.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.063]                   3L)]
[08:24:57.063]             }
[08:24:57.063]             function(cond) {
[08:24:57.063]                 is_error <- inherits(cond, "error")
[08:24:57.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.063]                   NULL)
[08:24:57.063]                 if (is_error) {
[08:24:57.063]                   sessionInformation <- function() {
[08:24:57.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.063]                       search = base::search(), system = base::Sys.info())
[08:24:57.063]                   }
[08:24:57.063]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.063]                     cond$call), session = sessionInformation(), 
[08:24:57.063]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.063]                   signalCondition(cond)
[08:24:57.063]                 }
[08:24:57.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.063]                 "immediateCondition"))) {
[08:24:57.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.063]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.063]                   if (TRUE && !signal) {
[08:24:57.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.063]                     {
[08:24:57.063]                       inherits <- base::inherits
[08:24:57.063]                       invokeRestart <- base::invokeRestart
[08:24:57.063]                       is.null <- base::is.null
[08:24:57.063]                       muffled <- FALSE
[08:24:57.063]                       if (inherits(cond, "message")) {
[08:24:57.063]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.063]                         if (muffled) 
[08:24:57.063]                           invokeRestart("muffleMessage")
[08:24:57.063]                       }
[08:24:57.063]                       else if (inherits(cond, "warning")) {
[08:24:57.063]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.063]                         if (muffled) 
[08:24:57.063]                           invokeRestart("muffleWarning")
[08:24:57.063]                       }
[08:24:57.063]                       else if (inherits(cond, "condition")) {
[08:24:57.063]                         if (!is.null(pattern)) {
[08:24:57.063]                           computeRestarts <- base::computeRestarts
[08:24:57.063]                           grepl <- base::grepl
[08:24:57.063]                           restarts <- computeRestarts(cond)
[08:24:57.063]                           for (restart in restarts) {
[08:24:57.063]                             name <- restart$name
[08:24:57.063]                             if (is.null(name)) 
[08:24:57.063]                               next
[08:24:57.063]                             if (!grepl(pattern, name)) 
[08:24:57.063]                               next
[08:24:57.063]                             invokeRestart(restart)
[08:24:57.063]                             muffled <- TRUE
[08:24:57.063]                             break
[08:24:57.063]                           }
[08:24:57.063]                         }
[08:24:57.063]                       }
[08:24:57.063]                       invisible(muffled)
[08:24:57.063]                     }
[08:24:57.063]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.063]                   }
[08:24:57.063]                 }
[08:24:57.063]                 else {
[08:24:57.063]                   if (TRUE) {
[08:24:57.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.063]                     {
[08:24:57.063]                       inherits <- base::inherits
[08:24:57.063]                       invokeRestart <- base::invokeRestart
[08:24:57.063]                       is.null <- base::is.null
[08:24:57.063]                       muffled <- FALSE
[08:24:57.063]                       if (inherits(cond, "message")) {
[08:24:57.063]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.063]                         if (muffled) 
[08:24:57.063]                           invokeRestart("muffleMessage")
[08:24:57.063]                       }
[08:24:57.063]                       else if (inherits(cond, "warning")) {
[08:24:57.063]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.063]                         if (muffled) 
[08:24:57.063]                           invokeRestart("muffleWarning")
[08:24:57.063]                       }
[08:24:57.063]                       else if (inherits(cond, "condition")) {
[08:24:57.063]                         if (!is.null(pattern)) {
[08:24:57.063]                           computeRestarts <- base::computeRestarts
[08:24:57.063]                           grepl <- base::grepl
[08:24:57.063]                           restarts <- computeRestarts(cond)
[08:24:57.063]                           for (restart in restarts) {
[08:24:57.063]                             name <- restart$name
[08:24:57.063]                             if (is.null(name)) 
[08:24:57.063]                               next
[08:24:57.063]                             if (!grepl(pattern, name)) 
[08:24:57.063]                               next
[08:24:57.063]                             invokeRestart(restart)
[08:24:57.063]                             muffled <- TRUE
[08:24:57.063]                             break
[08:24:57.063]                           }
[08:24:57.063]                         }
[08:24:57.063]                       }
[08:24:57.063]                       invisible(muffled)
[08:24:57.063]                     }
[08:24:57.063]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.063]                   }
[08:24:57.063]                 }
[08:24:57.063]             }
[08:24:57.063]         }))
[08:24:57.063]     }, error = function(ex) {
[08:24:57.063]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.063]                 ...future.rng), started = ...future.startTime, 
[08:24:57.063]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.063]             version = "1.8"), class = "FutureResult")
[08:24:57.063]     }, finally = {
[08:24:57.063]         if (!identical(...future.workdir, getwd())) 
[08:24:57.063]             setwd(...future.workdir)
[08:24:57.063]         {
[08:24:57.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.063]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.063]             }
[08:24:57.063]             base::options(...future.oldOptions)
[08:24:57.063]             if (.Platform$OS.type == "windows") {
[08:24:57.063]                 old_names <- names(...future.oldEnvVars)
[08:24:57.063]                 envs <- base::Sys.getenv()
[08:24:57.063]                 names <- names(envs)
[08:24:57.063]                 common <- intersect(names, old_names)
[08:24:57.063]                 added <- setdiff(names, old_names)
[08:24:57.063]                 removed <- setdiff(old_names, names)
[08:24:57.063]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.063]                   envs[common]]
[08:24:57.063]                 NAMES <- toupper(changed)
[08:24:57.063]                 args <- list()
[08:24:57.063]                 for (kk in seq_along(NAMES)) {
[08:24:57.063]                   name <- changed[[kk]]
[08:24:57.063]                   NAME <- NAMES[[kk]]
[08:24:57.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.063]                     next
[08:24:57.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.063]                 }
[08:24:57.063]                 NAMES <- toupper(added)
[08:24:57.063]                 for (kk in seq_along(NAMES)) {
[08:24:57.063]                   name <- added[[kk]]
[08:24:57.063]                   NAME <- NAMES[[kk]]
[08:24:57.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.063]                     next
[08:24:57.063]                   args[[name]] <- ""
[08:24:57.063]                 }
[08:24:57.063]                 NAMES <- toupper(removed)
[08:24:57.063]                 for (kk in seq_along(NAMES)) {
[08:24:57.063]                   name <- removed[[kk]]
[08:24:57.063]                   NAME <- NAMES[[kk]]
[08:24:57.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.063]                     next
[08:24:57.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.063]                 }
[08:24:57.063]                 if (length(args) > 0) 
[08:24:57.063]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.063]             }
[08:24:57.063]             else {
[08:24:57.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.063]             }
[08:24:57.063]             {
[08:24:57.063]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.063]                   0L) {
[08:24:57.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.063]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.063]                   base::options(opts)
[08:24:57.063]                 }
[08:24:57.063]                 {
[08:24:57.063]                   {
[08:24:57.063]                     NULL
[08:24:57.063]                     RNGkind("Mersenne-Twister")
[08:24:57.063]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.063]                       inherits = FALSE)
[08:24:57.063]                   }
[08:24:57.063]                   options(future.plan = NULL)
[08:24:57.063]                   if (is.na(NA_character_)) 
[08:24:57.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.063]                     .init = FALSE)
[08:24:57.063]                 }
[08:24:57.063]             }
[08:24:57.063]         }
[08:24:57.063]     })
[08:24:57.063]     if (TRUE) {
[08:24:57.063]         base::sink(type = "output", split = FALSE)
[08:24:57.063]         if (TRUE) {
[08:24:57.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.063]         }
[08:24:57.063]         else {
[08:24:57.063]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.063]         }
[08:24:57.063]         base::close(...future.stdout)
[08:24:57.063]         ...future.stdout <- NULL
[08:24:57.063]     }
[08:24:57.063]     ...future.result$conditions <- ...future.conditions
[08:24:57.063]     ...future.result$finished <- base::Sys.time()
[08:24:57.063]     ...future.result
[08:24:57.063] }
[08:24:57.065] assign_globals() ...
[08:24:57.065] List of 7
[08:24:57.065]  $ ...future.FUN            :function (x)  
[08:24:57.065]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:57.065]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.065]  $ future.call.arguments    : list()
[08:24:57.065]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.065]  $ ...future.elements_ii    :List of 3
[08:24:57.065]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.065]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.065]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.065]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.065]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.065]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.065]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.065]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.065]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.065]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.065]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.065]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.065]  $ ...future.seeds_ii       : NULL
[08:24:57.065]  $ ...future.globals.maxSize: NULL
[08:24:57.065]  - attr(*, "where")=List of 7
[08:24:57.065]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.065]   ..$ breaks                   :<environment: R_EmptyEnv> 
[08:24:57.065]   ..$ wool                     :<environment: R_EmptyEnv> 
[08:24:57.065]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.065]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.065]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.065]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.065]  - attr(*, "resolved")= logi FALSE
[08:24:57.065]  - attr(*, "total_size")= num 18867
[08:24:57.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.065]  - attr(*, "already-done")= logi TRUE
[08:24:57.077] - reassign environment for ‘...future.FUN’
[08:24:57.077] - copied ‘...future.FUN’ to environment
[08:24:57.078] - copied ‘breaks’ to environment
[08:24:57.078] - copied ‘wool’ to environment
[08:24:57.078] - copied ‘future.call.arguments’ to environment
[08:24:57.078] - copied ‘...future.elements_ii’ to environment
[08:24:57.078] - copied ‘...future.seeds_ii’ to environment
[08:24:57.078] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.078] assign_globals() ... done
[08:24:57.079] plan(): Setting new future strategy stack:
[08:24:57.079] List of future strategies:
[08:24:57.079] 1. sequential:
[08:24:57.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.079]    - tweaked: FALSE
[08:24:57.079]    - call: NULL
[08:24:57.079] plan(): nbrOfWorkers() = 1
[08:24:57.082] plan(): Setting new future strategy stack:
[08:24:57.082] List of future strategies:
[08:24:57.082] 1. multisession:
[08:24:57.082]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:57.082]    - tweaked: FALSE
[08:24:57.082]    - call: plan(strategy)
[08:24:57.084] plan(): nbrOfWorkers() = 1
[08:24:57.084] SequentialFuture started (and completed)
[08:24:57.084] - Launch lazy future ... done
[08:24:57.084] run() for ‘SequentialFuture’ ... done
[08:24:57.085] Created future:
[08:24:57.085] SequentialFuture:
[08:24:57.085] Label: ‘future_by-1’
[08:24:57.085] Expression:
[08:24:57.085] {
[08:24:57.085]     do.call(function(...) {
[08:24:57.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.085]             on.exit(options(oopts), add = TRUE)
[08:24:57.085]         }
[08:24:57.085]         {
[08:24:57.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.085]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.085]             })
[08:24:57.085]         }
[08:24:57.085]     }, args = future.call.arguments)
[08:24:57.085] }
[08:24:57.085] Lazy evaluation: FALSE
[08:24:57.085] Asynchronous evaluation: FALSE
[08:24:57.085] Local evaluation: TRUE
[08:24:57.085] Environment: 0x557b26166bd0
[08:24:57.085] Capture standard output: TRUE
[08:24:57.085] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.085] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[08:24:57.085] Packages: 1 packages (‘stats’)
[08:24:57.085] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.085] Resolved: TRUE
[08:24:57.085] Value: 82.51 KiB of class ‘list’
[08:24:57.085] Early signaling: FALSE
[08:24:57.085] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.085] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.086] Chunk #1 of 1 ... DONE
[08:24:57.086] Launching 1 futures (chunks) ... DONE
[08:24:57.086] Resolving 1 futures (chunks) ...
[08:24:57.086] resolve() on list ...
[08:24:57.087]  recursive: 0
[08:24:57.087]  length: 1
[08:24:57.087] 
[08:24:57.087] resolved() for ‘SequentialFuture’ ...
[08:24:57.087] - state: ‘finished’
[08:24:57.087] - run: TRUE
[08:24:57.087] - result: ‘FutureResult’
[08:24:57.087] resolved() for ‘SequentialFuture’ ... done
[08:24:57.087] Future #1
[08:24:57.087] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.088] - nx: 1
[08:24:57.088] - relay: TRUE
[08:24:57.088] - stdout: TRUE
[08:24:57.088] - signal: TRUE
[08:24:57.088] - resignal: FALSE
[08:24:57.088] - force: TRUE
[08:24:57.088] - relayed: [n=1] FALSE
[08:24:57.088] - queued futures: [n=1] FALSE
[08:24:57.088]  - until=1
[08:24:57.088]  - relaying element #1
[08:24:57.089] - relayed: [n=1] TRUE
[08:24:57.089] - queued futures: [n=1] TRUE
[08:24:57.089] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.089]  length: 0 (resolved future 1)
[08:24:57.089] Relaying remaining futures
[08:24:57.089] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.089] - nx: 1
[08:24:57.089] - relay: TRUE
[08:24:57.089] - stdout: TRUE
[08:24:57.089] - signal: TRUE
[08:24:57.089] - resignal: FALSE
[08:24:57.089] - force: TRUE
[08:24:57.090] - relayed: [n=1] TRUE
[08:24:57.090] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.090] - relayed: [n=1] TRUE
[08:24:57.090] - queued futures: [n=1] TRUE
[08:24:57.090] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.090] resolve() on list ... DONE
[08:24:57.090]  - Number of value chunks collected: 1
[08:24:57.090] Resolving 1 futures (chunks) ... DONE
[08:24:57.090] Reducing values from 1 chunks ...
[08:24:57.090]  - Number of values collected after concatenation: 3
[08:24:57.090]  - Number of values expected: 3
[08:24:57.091] Reducing values from 1 chunks ... DONE
[08:24:57.091] future_lapply() ... DONE
[08:24:57.091] future_by_internal() ... DONE
[08:24:57.091] future_by_internal() ...
[08:24:57.092] future_lapply() ...
[08:24:57.093] Number of chunks: 1
[08:24:57.093] getGlobalsAndPackagesXApply() ...
[08:24:57.094]  - future.globals: TRUE
[08:24:57.094] getGlobalsAndPackages() ...
[08:24:57.094] Searching for globals...
[08:24:57.095] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:57.095] Searching for globals ... DONE
[08:24:57.095] Resolving globals: FALSE
[08:24:57.095] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:57.096] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:57.096] - globals: [1] ‘FUN’
[08:24:57.096] 
[08:24:57.096] getGlobalsAndPackages() ... DONE
[08:24:57.096]  - globals found/used: [n=1] ‘FUN’
[08:24:57.096]  - needed namespaces: [n=0] 
[08:24:57.096] Finding globals ... DONE
[08:24:57.096]  - use_args: TRUE
[08:24:57.096]  - Getting '...' globals ...
[08:24:57.097] resolve() on list ...
[08:24:57.097]  recursive: 0
[08:24:57.097]  length: 1
[08:24:57.097]  elements: ‘...’
[08:24:57.097]  length: 0 (resolved future 1)
[08:24:57.097] resolve() on list ... DONE
[08:24:57.097]    - '...' content: [n=0] 
[08:24:57.099] List of 1
[08:24:57.099]  $ ...: list()
[08:24:57.099]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.099]  - attr(*, "where")=List of 1
[08:24:57.099]   ..$ ...:<environment: 0x557b2807c928> 
[08:24:57.099]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.099]  - attr(*, "resolved")= logi TRUE
[08:24:57.099]  - attr(*, "total_size")= num NA
[08:24:57.102]  - Getting '...' globals ... DONE
[08:24:57.102] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.103] List of 2
[08:24:57.103]  $ ...future.FUN:function (object, ...)  
[08:24:57.103]  $ ...          : list()
[08:24:57.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.103]  - attr(*, "where")=List of 2
[08:24:57.103]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.103]   ..$ ...          :<environment: 0x557b2807c928> 
[08:24:57.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.103]  - attr(*, "resolved")= logi FALSE
[08:24:57.103]  - attr(*, "total_size")= num 19278
[08:24:57.105] Packages to be attached in all futures: [n=0] 
[08:24:57.105] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.106] Number of futures (= number of chunks): 1
[08:24:57.106] Launching 1 futures (chunks) ...
[08:24:57.106] Chunk #1 of 1 ...
[08:24:57.106]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.106] getGlobalsAndPackages() ...
[08:24:57.106] Searching for globals...
[08:24:57.107] 
[08:24:57.107] Searching for globals ... DONE
[08:24:57.107] - globals: [0] <none>
[08:24:57.107] getGlobalsAndPackages() ... DONE
[08:24:57.107]    + additional globals found: [n=0] 
[08:24:57.107]    + additional namespaces needed: [n=0] 
[08:24:57.107]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.107]  - seeds: <none>
[08:24:57.107]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.107] getGlobalsAndPackages() ...
[08:24:57.107] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.108] Resolving globals: FALSE
[08:24:57.108] Tweak future expression to call with '...' arguments ...
[08:24:57.108] {
[08:24:57.108]     do.call(function(...) {
[08:24:57.108]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.108]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.108]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.108]             on.exit(options(oopts), add = TRUE)
[08:24:57.108]         }
[08:24:57.108]         {
[08:24:57.108]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.108]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.108]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.108]             })
[08:24:57.108]         }
[08:24:57.108]     }, args = future.call.arguments)
[08:24:57.108] }
[08:24:57.108] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.108] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.109] 
[08:24:57.109] getGlobalsAndPackages() ... DONE
[08:24:57.109] run() for ‘Future’ ...
[08:24:57.109] - state: ‘created’
[08:24:57.109] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.111] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.111]   - Field: ‘label’
[08:24:57.111]   - Field: ‘local’
[08:24:57.111]   - Field: ‘owner’
[08:24:57.111]   - Field: ‘envir’
[08:24:57.111]   - Field: ‘packages’
[08:24:57.111]   - Field: ‘gc’
[08:24:57.112]   - Field: ‘conditions’
[08:24:57.112]   - Field: ‘expr’
[08:24:57.112]   - Field: ‘uuid’
[08:24:57.112]   - Field: ‘seed’
[08:24:57.112]   - Field: ‘version’
[08:24:57.112]   - Field: ‘result’
[08:24:57.112]   - Field: ‘asynchronous’
[08:24:57.112]   - Field: ‘calls’
[08:24:57.112]   - Field: ‘globals’
[08:24:57.112]   - Field: ‘stdout’
[08:24:57.112]   - Field: ‘earlySignal’
[08:24:57.113]   - Field: ‘lazy’
[08:24:57.113]   - Field: ‘state’
[08:24:57.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.113] - Launch lazy future ...
[08:24:57.113] Packages needed by the future expression (n = 0): <none>
[08:24:57.113] Packages needed by future strategies (n = 0): <none>
[08:24:57.114] {
[08:24:57.114]     {
[08:24:57.114]         {
[08:24:57.114]             ...future.startTime <- base::Sys.time()
[08:24:57.114]             {
[08:24:57.114]                 {
[08:24:57.114]                   {
[08:24:57.114]                     base::local({
[08:24:57.114]                       has_future <- base::requireNamespace("future", 
[08:24:57.114]                         quietly = TRUE)
[08:24:57.114]                       if (has_future) {
[08:24:57.114]                         ns <- base::getNamespace("future")
[08:24:57.114]                         version <- ns[[".package"]][["version"]]
[08:24:57.114]                         if (is.null(version)) 
[08:24:57.114]                           version <- utils::packageVersion("future")
[08:24:57.114]                       }
[08:24:57.114]                       else {
[08:24:57.114]                         version <- NULL
[08:24:57.114]                       }
[08:24:57.114]                       if (!has_future || version < "1.8.0") {
[08:24:57.114]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.114]                           "", base::R.version$version.string), 
[08:24:57.114]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:57.114]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.114]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.114]                             "release", "version")], collapse = " "), 
[08:24:57.114]                           hostname = base::Sys.info()[["nodename"]])
[08:24:57.114]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.114]                           info)
[08:24:57.114]                         info <- base::paste(info, collapse = "; ")
[08:24:57.114]                         if (!has_future) {
[08:24:57.114]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.114]                             info)
[08:24:57.114]                         }
[08:24:57.114]                         else {
[08:24:57.114]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.114]                             info, version)
[08:24:57.114]                         }
[08:24:57.114]                         base::stop(msg)
[08:24:57.114]                       }
[08:24:57.114]                     })
[08:24:57.114]                   }
[08:24:57.114]                   ...future.strategy.old <- future::plan("list")
[08:24:57.114]                   options(future.plan = NULL)
[08:24:57.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.114]                 }
[08:24:57.114]                 ...future.workdir <- getwd()
[08:24:57.114]             }
[08:24:57.114]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.114]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.114]         }
[08:24:57.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.114]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.114]             base::names(...future.oldOptions))
[08:24:57.114]     }
[08:24:57.114]     if (FALSE) {
[08:24:57.114]     }
[08:24:57.114]     else {
[08:24:57.114]         if (TRUE) {
[08:24:57.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.114]                 open = "w")
[08:24:57.114]         }
[08:24:57.114]         else {
[08:24:57.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.114]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.114]         }
[08:24:57.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.114]             base::sink(type = "output", split = FALSE)
[08:24:57.114]             base::close(...future.stdout)
[08:24:57.114]         }, add = TRUE)
[08:24:57.114]     }
[08:24:57.114]     ...future.frame <- base::sys.nframe()
[08:24:57.114]     ...future.conditions <- base::list()
[08:24:57.114]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.114]     if (FALSE) {
[08:24:57.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.114]     }
[08:24:57.114]     ...future.result <- base::tryCatch({
[08:24:57.114]         base::withCallingHandlers({
[08:24:57.114]             ...future.value <- base::withVisible(base::local({
[08:24:57.114]                 do.call(function(...) {
[08:24:57.114]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.114]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.114]                     ...future.globals.maxSize)) {
[08:24:57.114]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.114]                     on.exit(options(oopts), add = TRUE)
[08:24:57.114]                   }
[08:24:57.114]                   {
[08:24:57.114]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.114]                       FUN = function(jj) {
[08:24:57.114]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.114]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.114]                       })
[08:24:57.114]                   }
[08:24:57.114]                 }, args = future.call.arguments)
[08:24:57.114]             }))
[08:24:57.114]             future::FutureResult(value = ...future.value$value, 
[08:24:57.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.114]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.114]                     ...future.globalenv.names))
[08:24:57.114]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.114]         }, condition = base::local({
[08:24:57.114]             c <- base::c
[08:24:57.114]             inherits <- base::inherits
[08:24:57.114]             invokeRestart <- base::invokeRestart
[08:24:57.114]             length <- base::length
[08:24:57.114]             list <- base::list
[08:24:57.114]             seq.int <- base::seq.int
[08:24:57.114]             signalCondition <- base::signalCondition
[08:24:57.114]             sys.calls <- base::sys.calls
[08:24:57.114]             `[[` <- base::`[[`
[08:24:57.114]             `+` <- base::`+`
[08:24:57.114]             `<<-` <- base::`<<-`
[08:24:57.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.114]                   3L)]
[08:24:57.114]             }
[08:24:57.114]             function(cond) {
[08:24:57.114]                 is_error <- inherits(cond, "error")
[08:24:57.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.114]                   NULL)
[08:24:57.114]                 if (is_error) {
[08:24:57.114]                   sessionInformation <- function() {
[08:24:57.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.114]                       search = base::search(), system = base::Sys.info())
[08:24:57.114]                   }
[08:24:57.114]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.114]                     cond$call), session = sessionInformation(), 
[08:24:57.114]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.114]                   signalCondition(cond)
[08:24:57.114]                 }
[08:24:57.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.114]                 "immediateCondition"))) {
[08:24:57.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.114]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.114]                   if (TRUE && !signal) {
[08:24:57.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.114]                     {
[08:24:57.114]                       inherits <- base::inherits
[08:24:57.114]                       invokeRestart <- base::invokeRestart
[08:24:57.114]                       is.null <- base::is.null
[08:24:57.114]                       muffled <- FALSE
[08:24:57.114]                       if (inherits(cond, "message")) {
[08:24:57.114]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.114]                         if (muffled) 
[08:24:57.114]                           invokeRestart("muffleMessage")
[08:24:57.114]                       }
[08:24:57.114]                       else if (inherits(cond, "warning")) {
[08:24:57.114]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.114]                         if (muffled) 
[08:24:57.114]                           invokeRestart("muffleWarning")
[08:24:57.114]                       }
[08:24:57.114]                       else if (inherits(cond, "condition")) {
[08:24:57.114]                         if (!is.null(pattern)) {
[08:24:57.114]                           computeRestarts <- base::computeRestarts
[08:24:57.114]                           grepl <- base::grepl
[08:24:57.114]                           restarts <- computeRestarts(cond)
[08:24:57.114]                           for (restart in restarts) {
[08:24:57.114]                             name <- restart$name
[08:24:57.114]                             if (is.null(name)) 
[08:24:57.114]                               next
[08:24:57.114]                             if (!grepl(pattern, name)) 
[08:24:57.114]                               next
[08:24:57.114]                             invokeRestart(restart)
[08:24:57.114]                             muffled <- TRUE
[08:24:57.114]                             break
[08:24:57.114]                           }
[08:24:57.114]                         }
[08:24:57.114]                       }
[08:24:57.114]                       invisible(muffled)
[08:24:57.114]                     }
[08:24:57.114]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.114]                   }
[08:24:57.114]                 }
[08:24:57.114]                 else {
[08:24:57.114]                   if (TRUE) {
[08:24:57.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.114]                     {
[08:24:57.114]                       inherits <- base::inherits
[08:24:57.114]                       invokeRestart <- base::invokeRestart
[08:24:57.114]                       is.null <- base::is.null
[08:24:57.114]                       muffled <- FALSE
[08:24:57.114]                       if (inherits(cond, "message")) {
[08:24:57.114]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.114]                         if (muffled) 
[08:24:57.114]                           invokeRestart("muffleMessage")
[08:24:57.114]                       }
[08:24:57.114]                       else if (inherits(cond, "warning")) {
[08:24:57.114]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.114]                         if (muffled) 
[08:24:57.114]                           invokeRestart("muffleWarning")
[08:24:57.114]                       }
[08:24:57.114]                       else if (inherits(cond, "condition")) {
[08:24:57.114]                         if (!is.null(pattern)) {
[08:24:57.114]                           computeRestarts <- base::computeRestarts
[08:24:57.114]                           grepl <- base::grepl
[08:24:57.114]                           restarts <- computeRestarts(cond)
[08:24:57.114]                           for (restart in restarts) {
[08:24:57.114]                             name <- restart$name
[08:24:57.114]                             if (is.null(name)) 
[08:24:57.114]                               next
[08:24:57.114]                             if (!grepl(pattern, name)) 
[08:24:57.114]                               next
[08:24:57.114]                             invokeRestart(restart)
[08:24:57.114]                             muffled <- TRUE
[08:24:57.114]                             break
[08:24:57.114]                           }
[08:24:57.114]                         }
[08:24:57.114]                       }
[08:24:57.114]                       invisible(muffled)
[08:24:57.114]                     }
[08:24:57.114]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.114]                   }
[08:24:57.114]                 }
[08:24:57.114]             }
[08:24:57.114]         }))
[08:24:57.114]     }, error = function(ex) {
[08:24:57.114]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.114]                 ...future.rng), started = ...future.startTime, 
[08:24:57.114]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.114]             version = "1.8"), class = "FutureResult")
[08:24:57.114]     }, finally = {
[08:24:57.114]         if (!identical(...future.workdir, getwd())) 
[08:24:57.114]             setwd(...future.workdir)
[08:24:57.114]         {
[08:24:57.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.114]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.114]             }
[08:24:57.114]             base::options(...future.oldOptions)
[08:24:57.114]             if (.Platform$OS.type == "windows") {
[08:24:57.114]                 old_names <- names(...future.oldEnvVars)
[08:24:57.114]                 envs <- base::Sys.getenv()
[08:24:57.114]                 names <- names(envs)
[08:24:57.114]                 common <- intersect(names, old_names)
[08:24:57.114]                 added <- setdiff(names, old_names)
[08:24:57.114]                 removed <- setdiff(old_names, names)
[08:24:57.114]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.114]                   envs[common]]
[08:24:57.114]                 NAMES <- toupper(changed)
[08:24:57.114]                 args <- list()
[08:24:57.114]                 for (kk in seq_along(NAMES)) {
[08:24:57.114]                   name <- changed[[kk]]
[08:24:57.114]                   NAME <- NAMES[[kk]]
[08:24:57.114]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.114]                     next
[08:24:57.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.114]                 }
[08:24:57.114]                 NAMES <- toupper(added)
[08:24:57.114]                 for (kk in seq_along(NAMES)) {
[08:24:57.114]                   name <- added[[kk]]
[08:24:57.114]                   NAME <- NAMES[[kk]]
[08:24:57.114]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.114]                     next
[08:24:57.114]                   args[[name]] <- ""
[08:24:57.114]                 }
[08:24:57.114]                 NAMES <- toupper(removed)
[08:24:57.114]                 for (kk in seq_along(NAMES)) {
[08:24:57.114]                   name <- removed[[kk]]
[08:24:57.114]                   NAME <- NAMES[[kk]]
[08:24:57.114]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.114]                     next
[08:24:57.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.114]                 }
[08:24:57.114]                 if (length(args) > 0) 
[08:24:57.114]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.114]             }
[08:24:57.114]             else {
[08:24:57.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.114]             }
[08:24:57.114]             {
[08:24:57.114]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.114]                   0L) {
[08:24:57.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.114]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.114]                   base::options(opts)
[08:24:57.114]                 }
[08:24:57.114]                 {
[08:24:57.114]                   {
[08:24:57.114]                     NULL
[08:24:57.114]                     RNGkind("Mersenne-Twister")
[08:24:57.114]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.114]                       inherits = FALSE)
[08:24:57.114]                   }
[08:24:57.114]                   options(future.plan = NULL)
[08:24:57.114]                   if (is.na(NA_character_)) 
[08:24:57.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.114]                     .init = FALSE)
[08:24:57.114]                 }
[08:24:57.114]             }
[08:24:57.114]         }
[08:24:57.114]     })
[08:24:57.114]     if (TRUE) {
[08:24:57.114]         base::sink(type = "output", split = FALSE)
[08:24:57.114]         if (TRUE) {
[08:24:57.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.114]         }
[08:24:57.114]         else {
[08:24:57.114]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.114]         }
[08:24:57.114]         base::close(...future.stdout)
[08:24:57.114]         ...future.stdout <- NULL
[08:24:57.114]     }
[08:24:57.114]     ...future.result$conditions <- ...future.conditions
[08:24:57.114]     ...future.result$finished <- base::Sys.time()
[08:24:57.114]     ...future.result
[08:24:57.114] }
[08:24:57.115] assign_globals() ...
[08:24:57.115] List of 5
[08:24:57.115]  $ ...future.FUN            :function (object, ...)  
[08:24:57.115]  $ future.call.arguments    : list()
[08:24:57.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.115]  $ ...future.elements_ii    :List of 3
[08:24:57.115]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.115]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.115]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.115]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.115]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.115]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.115]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.115]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.115]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.115]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.115]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.115]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.115]  $ ...future.seeds_ii       : NULL
[08:24:57.115]  $ ...future.globals.maxSize: NULL
[08:24:57.115]  - attr(*, "where")=List of 5
[08:24:57.115]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.115]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.115]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.115]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.115]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.115]  - attr(*, "resolved")= logi FALSE
[08:24:57.115]  - attr(*, "total_size")= num 19278
[08:24:57.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.115]  - attr(*, "already-done")= logi TRUE
[08:24:57.126] - copied ‘...future.FUN’ to environment
[08:24:57.126] - copied ‘future.call.arguments’ to environment
[08:24:57.127] - copied ‘...future.elements_ii’ to environment
[08:24:57.127] - copied ‘...future.seeds_ii’ to environment
[08:24:57.127] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.127] assign_globals() ... done
[08:24:57.127] plan(): Setting new future strategy stack:
[08:24:57.127] List of future strategies:
[08:24:57.127] 1. sequential:
[08:24:57.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.127]    - tweaked: FALSE
[08:24:57.127]    - call: NULL
[08:24:57.128] plan(): nbrOfWorkers() = 1
[08:24:57.130] plan(): Setting new future strategy stack:
[08:24:57.130] List of future strategies:
[08:24:57.130] 1. multisession:
[08:24:57.130]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:57.130]    - tweaked: FALSE
[08:24:57.130]    - call: plan(strategy)
[08:24:57.132] plan(): nbrOfWorkers() = 1
[08:24:57.132] SequentialFuture started (and completed)
[08:24:57.132] - Launch lazy future ... done
[08:24:57.132] run() for ‘SequentialFuture’ ... done
[08:24:57.132] Created future:
[08:24:57.132] SequentialFuture:
[08:24:57.132] Label: ‘future_by-1’
[08:24:57.132] Expression:
[08:24:57.132] {
[08:24:57.132]     do.call(function(...) {
[08:24:57.132]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.132]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.132]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.132]             on.exit(options(oopts), add = TRUE)
[08:24:57.132]         }
[08:24:57.132]         {
[08:24:57.132]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.132]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.132]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.132]             })
[08:24:57.132]         }
[08:24:57.132]     }, args = future.call.arguments)
[08:24:57.132] }
[08:24:57.132] Lazy evaluation: FALSE
[08:24:57.132] Asynchronous evaluation: FALSE
[08:24:57.132] Local evaluation: TRUE
[08:24:57.132] Environment: 0x557b27f95c50
[08:24:57.132] Capture standard output: TRUE
[08:24:57.132] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.132] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.132] Packages: <none>
[08:24:57.132] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.132] Resolved: TRUE
[08:24:57.132] Value: 1.39 KiB of class ‘list’
[08:24:57.132] Early signaling: FALSE
[08:24:57.132] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.132] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.133] Chunk #1 of 1 ... DONE
[08:24:57.134] Launching 1 futures (chunks) ... DONE
[08:24:57.134] Resolving 1 futures (chunks) ...
[08:24:57.134] resolve() on list ...
[08:24:57.134]  recursive: 0
[08:24:57.134]  length: 1
[08:24:57.134] 
[08:24:57.134] resolved() for ‘SequentialFuture’ ...
[08:24:57.134] - state: ‘finished’
[08:24:57.134] - run: TRUE
[08:24:57.134] - result: ‘FutureResult’
[08:24:57.134] resolved() for ‘SequentialFuture’ ... done
[08:24:57.135] Future #1
[08:24:57.135] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.135] - nx: 1
[08:24:57.135] - relay: TRUE
[08:24:57.135] - stdout: TRUE
[08:24:57.135] - signal: TRUE
[08:24:57.135] - resignal: FALSE
[08:24:57.135] - force: TRUE
[08:24:57.135] - relayed: [n=1] FALSE
[08:24:57.135] - queued futures: [n=1] FALSE
[08:24:57.135]  - until=1
[08:24:57.136]  - relaying element #1
[08:24:57.136] - relayed: [n=1] TRUE
[08:24:57.136] - queued futures: [n=1] TRUE
[08:24:57.136] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.136]  length: 0 (resolved future 1)
[08:24:57.136] Relaying remaining futures
[08:24:57.136] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.136] - nx: 1
[08:24:57.136] - relay: TRUE
[08:24:57.136] - stdout: TRUE
[08:24:57.136] - signal: TRUE
[08:24:57.137] - resignal: FALSE
[08:24:57.137] - force: TRUE
[08:24:57.137] - relayed: [n=1] TRUE
[08:24:57.137] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.137] - relayed: [n=1] TRUE
[08:24:57.137] - queued futures: [n=1] TRUE
[08:24:57.137] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.137] resolve() on list ... DONE
[08:24:57.137]  - Number of value chunks collected: 1
[08:24:57.137] Resolving 1 futures (chunks) ... DONE
[08:24:57.138] Reducing values from 1 chunks ...
[08:24:57.138]  - Number of values collected after concatenation: 3
[08:24:57.138]  - Number of values expected: 3
[08:24:57.138] Reducing values from 1 chunks ... DONE
[08:24:57.138] future_lapply() ... DONE
[08:24:57.138] future_by_internal() ... DONE
[08:24:57.139] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[08:24:57.139] future_lapply() ...
[08:24:57.141] Number of chunks: 1
[08:24:57.141] getGlobalsAndPackagesXApply() ...
[08:24:57.141]  - future.globals: TRUE
[08:24:57.141] getGlobalsAndPackages() ...
[08:24:57.141] Searching for globals...
[08:24:57.144] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:57.145] Searching for globals ... DONE
[08:24:57.145] Resolving globals: FALSE
[08:24:57.145] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:57.146] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:57.146] - globals: [1] ‘FUN’
[08:24:57.146] 
[08:24:57.146] getGlobalsAndPackages() ... DONE
[08:24:57.146]  - globals found/used: [n=1] ‘FUN’
[08:24:57.146]  - needed namespaces: [n=0] 
[08:24:57.146] Finding globals ... DONE
[08:24:57.146]  - use_args: TRUE
[08:24:57.146]  - Getting '...' globals ...
[08:24:57.147] resolve() on list ...
[08:24:57.147]  recursive: 0
[08:24:57.147]  length: 1
[08:24:57.147]  elements: ‘...’
[08:24:57.147]  length: 0 (resolved future 1)
[08:24:57.147] resolve() on list ... DONE
[08:24:57.147]    - '...' content: [n=0] 
[08:24:57.147] List of 1
[08:24:57.147]  $ ...: list()
[08:24:57.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.147]  - attr(*, "where")=List of 1
[08:24:57.147]   ..$ ...:<environment: 0x557b282b9100> 
[08:24:57.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.147]  - attr(*, "resolved")= logi TRUE
[08:24:57.147]  - attr(*, "total_size")= num NA
[08:24:57.150]  - Getting '...' globals ... DONE
[08:24:57.150] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.150] List of 2
[08:24:57.150]  $ ...future.FUN:function (object, ...)  
[08:24:57.150]  $ ...          : list()
[08:24:57.150]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.150]  - attr(*, "where")=List of 2
[08:24:57.150]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.150]   ..$ ...          :<environment: 0x557b282b9100> 
[08:24:57.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.150]  - attr(*, "resolved")= logi FALSE
[08:24:57.150]  - attr(*, "total_size")= num 18647
[08:24:57.153] Packages to be attached in all futures: [n=0] 
[08:24:57.153] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.153] Number of futures (= number of chunks): 1
[08:24:57.153] Launching 1 futures (chunks) ...
[08:24:57.153] Chunk #1 of 1 ...
[08:24:57.153]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.154] getGlobalsAndPackages() ...
[08:24:57.154] Searching for globals...
[08:24:57.154] 
[08:24:57.154] Searching for globals ... DONE
[08:24:57.154] - globals: [0] <none>
[08:24:57.154] getGlobalsAndPackages() ... DONE
[08:24:57.154]    + additional globals found: [n=0] 
[08:24:57.155]    + additional namespaces needed: [n=0] 
[08:24:57.155]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.155]  - seeds: <none>
[08:24:57.155]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.155] getGlobalsAndPackages() ...
[08:24:57.155] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.155] Resolving globals: FALSE
[08:24:57.155] Tweak future expression to call with '...' arguments ...
[08:24:57.155] {
[08:24:57.155]     do.call(function(...) {
[08:24:57.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.155]             on.exit(options(oopts), add = TRUE)
[08:24:57.155]         }
[08:24:57.155]         {
[08:24:57.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.155]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.155]             })
[08:24:57.155]         }
[08:24:57.155]     }, args = future.call.arguments)
[08:24:57.155] }
[08:24:57.156] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.156] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.156] 
[08:24:57.156] getGlobalsAndPackages() ... DONE
[08:24:57.156] run() for ‘Future’ ...
[08:24:57.157] - state: ‘created’
[08:24:57.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.158] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.158]   - Field: ‘label’
[08:24:57.159]   - Field: ‘local’
[08:24:57.159]   - Field: ‘owner’
[08:24:57.159]   - Field: ‘envir’
[08:24:57.159]   - Field: ‘packages’
[08:24:57.159]   - Field: ‘gc’
[08:24:57.159]   - Field: ‘conditions’
[08:24:57.159]   - Field: ‘expr’
[08:24:57.159]   - Field: ‘uuid’
[08:24:57.159]   - Field: ‘seed’
[08:24:57.159]   - Field: ‘version’
[08:24:57.159]   - Field: ‘result’
[08:24:57.160]   - Field: ‘asynchronous’
[08:24:57.160]   - Field: ‘calls’
[08:24:57.160]   - Field: ‘globals’
[08:24:57.160]   - Field: ‘stdout’
[08:24:57.160]   - Field: ‘earlySignal’
[08:24:57.160]   - Field: ‘lazy’
[08:24:57.160]   - Field: ‘state’
[08:24:57.160] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.160] - Launch lazy future ...
[08:24:57.160] Packages needed by the future expression (n = 0): <none>
[08:24:57.161] Packages needed by future strategies (n = 0): <none>
[08:24:57.161] {
[08:24:57.161]     {
[08:24:57.161]         {
[08:24:57.161]             ...future.startTime <- base::Sys.time()
[08:24:57.161]             {
[08:24:57.161]                 {
[08:24:57.161]                   {
[08:24:57.161]                     base::local({
[08:24:57.161]                       has_future <- base::requireNamespace("future", 
[08:24:57.161]                         quietly = TRUE)
[08:24:57.161]                       if (has_future) {
[08:24:57.161]                         ns <- base::getNamespace("future")
[08:24:57.161]                         version <- ns[[".package"]][["version"]]
[08:24:57.161]                         if (is.null(version)) 
[08:24:57.161]                           version <- utils::packageVersion("future")
[08:24:57.161]                       }
[08:24:57.161]                       else {
[08:24:57.161]                         version <- NULL
[08:24:57.161]                       }
[08:24:57.161]                       if (!has_future || version < "1.8.0") {
[08:24:57.161]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.161]                           "", base::R.version$version.string), 
[08:24:57.161]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:57.161]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.161]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.161]                             "release", "version")], collapse = " "), 
[08:24:57.161]                           hostname = base::Sys.info()[["nodename"]])
[08:24:57.161]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.161]                           info)
[08:24:57.161]                         info <- base::paste(info, collapse = "; ")
[08:24:57.161]                         if (!has_future) {
[08:24:57.161]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.161]                             info)
[08:24:57.161]                         }
[08:24:57.161]                         else {
[08:24:57.161]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.161]                             info, version)
[08:24:57.161]                         }
[08:24:57.161]                         base::stop(msg)
[08:24:57.161]                       }
[08:24:57.161]                     })
[08:24:57.161]                   }
[08:24:57.161]                   ...future.strategy.old <- future::plan("list")
[08:24:57.161]                   options(future.plan = NULL)
[08:24:57.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.161]                 }
[08:24:57.161]                 ...future.workdir <- getwd()
[08:24:57.161]             }
[08:24:57.161]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.161]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.161]         }
[08:24:57.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.161]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.161]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.161]             base::names(...future.oldOptions))
[08:24:57.161]     }
[08:24:57.161]     if (FALSE) {
[08:24:57.161]     }
[08:24:57.161]     else {
[08:24:57.161]         if (TRUE) {
[08:24:57.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.161]                 open = "w")
[08:24:57.161]         }
[08:24:57.161]         else {
[08:24:57.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.161]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.161]         }
[08:24:57.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.161]             base::sink(type = "output", split = FALSE)
[08:24:57.161]             base::close(...future.stdout)
[08:24:57.161]         }, add = TRUE)
[08:24:57.161]     }
[08:24:57.161]     ...future.frame <- base::sys.nframe()
[08:24:57.161]     ...future.conditions <- base::list()
[08:24:57.161]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.161]     if (FALSE) {
[08:24:57.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.161]     }
[08:24:57.161]     ...future.result <- base::tryCatch({
[08:24:57.161]         base::withCallingHandlers({
[08:24:57.161]             ...future.value <- base::withVisible(base::local({
[08:24:57.161]                 do.call(function(...) {
[08:24:57.161]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.161]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.161]                     ...future.globals.maxSize)) {
[08:24:57.161]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.161]                     on.exit(options(oopts), add = TRUE)
[08:24:57.161]                   }
[08:24:57.161]                   {
[08:24:57.161]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.161]                       FUN = function(jj) {
[08:24:57.161]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.161]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.161]                       })
[08:24:57.161]                   }
[08:24:57.161]                 }, args = future.call.arguments)
[08:24:57.161]             }))
[08:24:57.161]             future::FutureResult(value = ...future.value$value, 
[08:24:57.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.161]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.161]                     ...future.globalenv.names))
[08:24:57.161]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.161]         }, condition = base::local({
[08:24:57.161]             c <- base::c
[08:24:57.161]             inherits <- base::inherits
[08:24:57.161]             invokeRestart <- base::invokeRestart
[08:24:57.161]             length <- base::length
[08:24:57.161]             list <- base::list
[08:24:57.161]             seq.int <- base::seq.int
[08:24:57.161]             signalCondition <- base::signalCondition
[08:24:57.161]             sys.calls <- base::sys.calls
[08:24:57.161]             `[[` <- base::`[[`
[08:24:57.161]             `+` <- base::`+`
[08:24:57.161]             `<<-` <- base::`<<-`
[08:24:57.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.161]                   3L)]
[08:24:57.161]             }
[08:24:57.161]             function(cond) {
[08:24:57.161]                 is_error <- inherits(cond, "error")
[08:24:57.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.161]                   NULL)
[08:24:57.161]                 if (is_error) {
[08:24:57.161]                   sessionInformation <- function() {
[08:24:57.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.161]                       search = base::search(), system = base::Sys.info())
[08:24:57.161]                   }
[08:24:57.161]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.161]                     cond$call), session = sessionInformation(), 
[08:24:57.161]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.161]                   signalCondition(cond)
[08:24:57.161]                 }
[08:24:57.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.161]                 "immediateCondition"))) {
[08:24:57.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.161]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.161]                   if (TRUE && !signal) {
[08:24:57.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.161]                     {
[08:24:57.161]                       inherits <- base::inherits
[08:24:57.161]                       invokeRestart <- base::invokeRestart
[08:24:57.161]                       is.null <- base::is.null
[08:24:57.161]                       muffled <- FALSE
[08:24:57.161]                       if (inherits(cond, "message")) {
[08:24:57.161]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.161]                         if (muffled) 
[08:24:57.161]                           invokeRestart("muffleMessage")
[08:24:57.161]                       }
[08:24:57.161]                       else if (inherits(cond, "warning")) {
[08:24:57.161]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.161]                         if (muffled) 
[08:24:57.161]                           invokeRestart("muffleWarning")
[08:24:57.161]                       }
[08:24:57.161]                       else if (inherits(cond, "condition")) {
[08:24:57.161]                         if (!is.null(pattern)) {
[08:24:57.161]                           computeRestarts <- base::computeRestarts
[08:24:57.161]                           grepl <- base::grepl
[08:24:57.161]                           restarts <- computeRestarts(cond)
[08:24:57.161]                           for (restart in restarts) {
[08:24:57.161]                             name <- restart$name
[08:24:57.161]                             if (is.null(name)) 
[08:24:57.161]                               next
[08:24:57.161]                             if (!grepl(pattern, name)) 
[08:24:57.161]                               next
[08:24:57.161]                             invokeRestart(restart)
[08:24:57.161]                             muffled <- TRUE
[08:24:57.161]                             break
[08:24:57.161]                           }
[08:24:57.161]                         }
[08:24:57.161]                       }
[08:24:57.161]                       invisible(muffled)
[08:24:57.161]                     }
[08:24:57.161]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.161]                   }
[08:24:57.161]                 }
[08:24:57.161]                 else {
[08:24:57.161]                   if (TRUE) {
[08:24:57.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.161]                     {
[08:24:57.161]                       inherits <- base::inherits
[08:24:57.161]                       invokeRestart <- base::invokeRestart
[08:24:57.161]                       is.null <- base::is.null
[08:24:57.161]                       muffled <- FALSE
[08:24:57.161]                       if (inherits(cond, "message")) {
[08:24:57.161]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.161]                         if (muffled) 
[08:24:57.161]                           invokeRestart("muffleMessage")
[08:24:57.161]                       }
[08:24:57.161]                       else if (inherits(cond, "warning")) {
[08:24:57.161]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.161]                         if (muffled) 
[08:24:57.161]                           invokeRestart("muffleWarning")
[08:24:57.161]                       }
[08:24:57.161]                       else if (inherits(cond, "condition")) {
[08:24:57.161]                         if (!is.null(pattern)) {
[08:24:57.161]                           computeRestarts <- base::computeRestarts
[08:24:57.161]                           grepl <- base::grepl
[08:24:57.161]                           restarts <- computeRestarts(cond)
[08:24:57.161]                           for (restart in restarts) {
[08:24:57.161]                             name <- restart$name
[08:24:57.161]                             if (is.null(name)) 
[08:24:57.161]                               next
[08:24:57.161]                             if (!grepl(pattern, name)) 
[08:24:57.161]                               next
[08:24:57.161]                             invokeRestart(restart)
[08:24:57.161]                             muffled <- TRUE
[08:24:57.161]                             break
[08:24:57.161]                           }
[08:24:57.161]                         }
[08:24:57.161]                       }
[08:24:57.161]                       invisible(muffled)
[08:24:57.161]                     }
[08:24:57.161]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.161]                   }
[08:24:57.161]                 }
[08:24:57.161]             }
[08:24:57.161]         }))
[08:24:57.161]     }, error = function(ex) {
[08:24:57.161]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.161]                 ...future.rng), started = ...future.startTime, 
[08:24:57.161]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.161]             version = "1.8"), class = "FutureResult")
[08:24:57.161]     }, finally = {
[08:24:57.161]         if (!identical(...future.workdir, getwd())) 
[08:24:57.161]             setwd(...future.workdir)
[08:24:57.161]         {
[08:24:57.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.161]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.161]             }
[08:24:57.161]             base::options(...future.oldOptions)
[08:24:57.161]             if (.Platform$OS.type == "windows") {
[08:24:57.161]                 old_names <- names(...future.oldEnvVars)
[08:24:57.161]                 envs <- base::Sys.getenv()
[08:24:57.161]                 names <- names(envs)
[08:24:57.161]                 common <- intersect(names, old_names)
[08:24:57.161]                 added <- setdiff(names, old_names)
[08:24:57.161]                 removed <- setdiff(old_names, names)
[08:24:57.161]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.161]                   envs[common]]
[08:24:57.161]                 NAMES <- toupper(changed)
[08:24:57.161]                 args <- list()
[08:24:57.161]                 for (kk in seq_along(NAMES)) {
[08:24:57.161]                   name <- changed[[kk]]
[08:24:57.161]                   NAME <- NAMES[[kk]]
[08:24:57.161]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.161]                     next
[08:24:57.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.161]                 }
[08:24:57.161]                 NAMES <- toupper(added)
[08:24:57.161]                 for (kk in seq_along(NAMES)) {
[08:24:57.161]                   name <- added[[kk]]
[08:24:57.161]                   NAME <- NAMES[[kk]]
[08:24:57.161]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.161]                     next
[08:24:57.161]                   args[[name]] <- ""
[08:24:57.161]                 }
[08:24:57.161]                 NAMES <- toupper(removed)
[08:24:57.161]                 for (kk in seq_along(NAMES)) {
[08:24:57.161]                   name <- removed[[kk]]
[08:24:57.161]                   NAME <- NAMES[[kk]]
[08:24:57.161]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.161]                     next
[08:24:57.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.161]                 }
[08:24:57.161]                 if (length(args) > 0) 
[08:24:57.161]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.161]             }
[08:24:57.161]             else {
[08:24:57.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.161]             }
[08:24:57.161]             {
[08:24:57.161]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.161]                   0L) {
[08:24:57.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.161]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.161]                   base::options(opts)
[08:24:57.161]                 }
[08:24:57.161]                 {
[08:24:57.161]                   {
[08:24:57.161]                     NULL
[08:24:57.161]                     RNGkind("Mersenne-Twister")
[08:24:57.161]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.161]                       inherits = FALSE)
[08:24:57.161]                   }
[08:24:57.161]                   options(future.plan = NULL)
[08:24:57.161]                   if (is.na(NA_character_)) 
[08:24:57.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.161]                     .init = FALSE)
[08:24:57.161]                 }
[08:24:57.161]             }
[08:24:57.161]         }
[08:24:57.161]     })
[08:24:57.161]     if (TRUE) {
[08:24:57.161]         base::sink(type = "output", split = FALSE)
[08:24:57.161]         if (TRUE) {
[08:24:57.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.161]         }
[08:24:57.161]         else {
[08:24:57.161]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.161]         }
[08:24:57.161]         base::close(...future.stdout)
[08:24:57.161]         ...future.stdout <- NULL
[08:24:57.161]     }
[08:24:57.161]     ...future.result$conditions <- ...future.conditions
[08:24:57.161]     ...future.result$finished <- base::Sys.time()
[08:24:57.161]     ...future.result
[08:24:57.161] }
[08:24:57.163] assign_globals() ...
[08:24:57.163] List of 5
[08:24:57.163]  $ ...future.FUN            :function (object, ...)  
[08:24:57.163]  $ future.call.arguments    : list()
[08:24:57.163]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.163]  $ ...future.elements_ii    :List of 3
[08:24:57.163]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.163]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.163]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.163]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.163]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.163]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.163]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.163]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.163]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.163]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.163]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.163]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.163]  $ ...future.seeds_ii       : NULL
[08:24:57.163]  $ ...future.globals.maxSize: NULL
[08:24:57.163]  - attr(*, "where")=List of 5
[08:24:57.163]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.163]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.163]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.163]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.163]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.163]  - attr(*, "resolved")= logi FALSE
[08:24:57.163]  - attr(*, "total_size")= num 18647
[08:24:57.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.163]  - attr(*, "already-done")= logi TRUE
[08:24:57.174] - copied ‘...future.FUN’ to environment
[08:24:57.174] - copied ‘future.call.arguments’ to environment
[08:24:57.174] - copied ‘...future.elements_ii’ to environment
[08:24:57.174] - copied ‘...future.seeds_ii’ to environment
[08:24:57.174] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.174] assign_globals() ... done
[08:24:57.175] plan(): Setting new future strategy stack:
[08:24:57.175] List of future strategies:
[08:24:57.175] 1. sequential:
[08:24:57.175]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.175]    - tweaked: FALSE
[08:24:57.175]    - call: NULL
[08:24:57.175] plan(): nbrOfWorkers() = 1
[08:24:57.178] plan(): Setting new future strategy stack:
[08:24:57.178] List of future strategies:
[08:24:57.178] 1. multisession:
[08:24:57.178]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:57.178]    - tweaked: FALSE
[08:24:57.178]    - call: plan(strategy)
[08:24:57.179] plan(): nbrOfWorkers() = 1
[08:24:57.180] SequentialFuture started (and completed)
[08:24:57.180] - Launch lazy future ... done
[08:24:57.180] run() for ‘SequentialFuture’ ... done
[08:24:57.180] Created future:
[08:24:57.180] SequentialFuture:
[08:24:57.180] Label: ‘future_by-1’
[08:24:57.180] Expression:
[08:24:57.180] {
[08:24:57.180]     do.call(function(...) {
[08:24:57.180]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.180]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.180]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.180]             on.exit(options(oopts), add = TRUE)
[08:24:57.180]         }
[08:24:57.180]         {
[08:24:57.180]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.180]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.180]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.180]             })
[08:24:57.180]         }
[08:24:57.180]     }, args = future.call.arguments)
[08:24:57.180] }
[08:24:57.180] Lazy evaluation: FALSE
[08:24:57.180] Asynchronous evaluation: FALSE
[08:24:57.180] Local evaluation: TRUE
[08:24:57.180] Environment: 0x557b28258980
[08:24:57.180] Capture standard output: TRUE
[08:24:57.180] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.180] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.180] Packages: <none>
[08:24:57.180] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.180] Resolved: TRUE
[08:24:57.180] Value: 1.39 KiB of class ‘list’
[08:24:57.180] Early signaling: FALSE
[08:24:57.180] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.180] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.181] Chunk #1 of 1 ... DONE
[08:24:57.181] Launching 1 futures (chunks) ... DONE
[08:24:57.181] Resolving 1 futures (chunks) ...
[08:24:57.182] resolve() on list ...
[08:24:57.182]  recursive: 0
[08:24:57.182]  length: 1
[08:24:57.182] 
[08:24:57.182] resolved() for ‘SequentialFuture’ ...
[08:24:57.182] - state: ‘finished’
[08:24:57.182] - run: TRUE
[08:24:57.182] - result: ‘FutureResult’
[08:24:57.182] resolved() for ‘SequentialFuture’ ... done
[08:24:57.182] Future #1
[08:24:57.183] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.183] - nx: 1
[08:24:57.183] - relay: TRUE
[08:24:57.183] - stdout: TRUE
[08:24:57.183] - signal: TRUE
[08:24:57.183] - resignal: FALSE
[08:24:57.183] - force: TRUE
[08:24:57.183] - relayed: [n=1] FALSE
[08:24:57.183] - queued futures: [n=1] FALSE
[08:24:57.183]  - until=1
[08:24:57.183]  - relaying element #1
[08:24:57.184] - relayed: [n=1] TRUE
[08:24:57.184] - queued futures: [n=1] TRUE
[08:24:57.184] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.184]  length: 0 (resolved future 1)
[08:24:57.184] Relaying remaining futures
[08:24:57.184] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.184] - nx: 1
[08:24:57.184] - relay: TRUE
[08:24:57.184] - stdout: TRUE
[08:24:57.184] - signal: TRUE
[08:24:57.184] - resignal: FALSE
[08:24:57.184] - force: TRUE
[08:24:57.185] - relayed: [n=1] TRUE
[08:24:57.185] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.185] - relayed: [n=1] TRUE
[08:24:57.185] - queued futures: [n=1] TRUE
[08:24:57.185] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.185] resolve() on list ... DONE
[08:24:57.189]  - Number of value chunks collected: 1
[08:24:57.190] Resolving 1 futures (chunks) ... DONE
[08:24:57.190] Reducing values from 1 chunks ...
[08:24:57.190]  - Number of values collected after concatenation: 3
[08:24:57.190]  - Number of values expected: 3
[08:24:57.190] Reducing values from 1 chunks ... DONE
[08:24:57.190] future_lapply() ... DONE
[08:24:57.190] future_by_internal() ... DONE
[08:24:57.191] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[08:24:57.192] plan(): Setting new future strategy stack:
[08:24:57.192] List of future strategies:
[08:24:57.192] 1. sequential:
[08:24:57.192]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.192]    - tweaked: FALSE
[08:24:57.192]    - call: plan(strategy)
[08:24:57.193] plan(): nbrOfWorkers() = 1
[08:24:57.193] future_by_internal() ...
[08:24:57.194] future_lapply() ...
[08:24:57.194] Number of chunks: 1
[08:24:57.195] getGlobalsAndPackagesXApply() ...
[08:24:57.195]  - future.globals: TRUE
[08:24:57.195] getGlobalsAndPackages() ...
[08:24:57.195] Searching for globals...
[08:24:57.196] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:57.196] Searching for globals ... DONE
[08:24:57.196] Resolving globals: FALSE
[08:24:57.197] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:57.197] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:57.197] - globals: [1] ‘FUN’
[08:24:57.197] 
[08:24:57.197] getGlobalsAndPackages() ... DONE
[08:24:57.197]  - globals found/used: [n=1] ‘FUN’
[08:24:57.197]  - needed namespaces: [n=0] 
[08:24:57.198] Finding globals ... DONE
[08:24:57.198]  - use_args: TRUE
[08:24:57.198]  - Getting '...' globals ...
[08:24:57.198] resolve() on list ...
[08:24:57.198]  recursive: 0
[08:24:57.198]  length: 1
[08:24:57.198]  elements: ‘...’
[08:24:57.198]  length: 0 (resolved future 1)
[08:24:57.199] resolve() on list ... DONE
[08:24:57.199]    - '...' content: [n=0] 
[08:24:57.199] List of 1
[08:24:57.199]  $ ...: list()
[08:24:57.199]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.199]  - attr(*, "where")=List of 1
[08:24:57.199]   ..$ ...:<environment: 0x557b284006a8> 
[08:24:57.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.199]  - attr(*, "resolved")= logi TRUE
[08:24:57.199]  - attr(*, "total_size")= num NA
[08:24:57.201]  - Getting '...' globals ... DONE
[08:24:57.202] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.202] List of 2
[08:24:57.202]  $ ...future.FUN:function (object, ...)  
[08:24:57.202]  $ ...          : list()
[08:24:57.202]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.202]  - attr(*, "where")=List of 2
[08:24:57.202]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.202]   ..$ ...          :<environment: 0x557b284006a8> 
[08:24:57.202]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.202]  - attr(*, "resolved")= logi FALSE
[08:24:57.202]  - attr(*, "total_size")= num 15670
[08:24:57.204] Packages to be attached in all futures: [n=0] 
[08:24:57.204] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.205] Number of futures (= number of chunks): 1
[08:24:57.205] Launching 1 futures (chunks) ...
[08:24:57.205] Chunk #1 of 1 ...
[08:24:57.205]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.205] getGlobalsAndPackages() ...
[08:24:57.205] Searching for globals...
[08:24:57.206] 
[08:24:57.206] Searching for globals ... DONE
[08:24:57.206] - globals: [0] <none>
[08:24:57.206] getGlobalsAndPackages() ... DONE
[08:24:57.206]    + additional globals found: [n=0] 
[08:24:57.206]    + additional namespaces needed: [n=0] 
[08:24:57.206]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.206]  - seeds: <none>
[08:24:57.206]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.207] getGlobalsAndPackages() ...
[08:24:57.207] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.207] Resolving globals: FALSE
[08:24:57.207] Tweak future expression to call with '...' arguments ...
[08:24:57.207] {
[08:24:57.207]     do.call(function(...) {
[08:24:57.207]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.207]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.207]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.207]             on.exit(options(oopts), add = TRUE)
[08:24:57.207]         }
[08:24:57.207]         {
[08:24:57.207]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.207]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.207]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.207]             })
[08:24:57.207]         }
[08:24:57.207]     }, args = future.call.arguments)
[08:24:57.207] }
[08:24:57.207] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.208] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.208] 
[08:24:57.208] getGlobalsAndPackages() ... DONE
[08:24:57.208] run() for ‘Future’ ...
[08:24:57.208] - state: ‘created’
[08:24:57.208] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:57.209] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.209] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.209]   - Field: ‘label’
[08:24:57.209]   - Field: ‘local’
[08:24:57.209]   - Field: ‘owner’
[08:24:57.209]   - Field: ‘envir’
[08:24:57.209]   - Field: ‘packages’
[08:24:57.209]   - Field: ‘gc’
[08:24:57.209]   - Field: ‘conditions’
[08:24:57.209]   - Field: ‘expr’
[08:24:57.210]   - Field: ‘uuid’
[08:24:57.210]   - Field: ‘seed’
[08:24:57.210]   - Field: ‘version’
[08:24:57.210]   - Field: ‘result’
[08:24:57.210]   - Field: ‘asynchronous’
[08:24:57.210]   - Field: ‘calls’
[08:24:57.210]   - Field: ‘globals’
[08:24:57.210]   - Field: ‘stdout’
[08:24:57.210]   - Field: ‘earlySignal’
[08:24:57.210]   - Field: ‘lazy’
[08:24:57.210]   - Field: ‘state’
[08:24:57.211] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.211] - Launch lazy future ...
[08:24:57.211] Packages needed by the future expression (n = 0): <none>
[08:24:57.211] Packages needed by future strategies (n = 0): <none>
[08:24:57.211] {
[08:24:57.211]     {
[08:24:57.211]         {
[08:24:57.211]             ...future.startTime <- base::Sys.time()
[08:24:57.211]             {
[08:24:57.211]                 {
[08:24:57.211]                   {
[08:24:57.211]                     base::local({
[08:24:57.211]                       has_future <- base::requireNamespace("future", 
[08:24:57.211]                         quietly = TRUE)
[08:24:57.211]                       if (has_future) {
[08:24:57.211]                         ns <- base::getNamespace("future")
[08:24:57.211]                         version <- ns[[".package"]][["version"]]
[08:24:57.211]                         if (is.null(version)) 
[08:24:57.211]                           version <- utils::packageVersion("future")
[08:24:57.211]                       }
[08:24:57.211]                       else {
[08:24:57.211]                         version <- NULL
[08:24:57.211]                       }
[08:24:57.211]                       if (!has_future || version < "1.8.0") {
[08:24:57.211]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.211]                           "", base::R.version$version.string), 
[08:24:57.211]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:57.211]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.211]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.211]                             "release", "version")], collapse = " "), 
[08:24:57.211]                           hostname = base::Sys.info()[["nodename"]])
[08:24:57.211]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.211]                           info)
[08:24:57.211]                         info <- base::paste(info, collapse = "; ")
[08:24:57.211]                         if (!has_future) {
[08:24:57.211]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.211]                             info)
[08:24:57.211]                         }
[08:24:57.211]                         else {
[08:24:57.211]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.211]                             info, version)
[08:24:57.211]                         }
[08:24:57.211]                         base::stop(msg)
[08:24:57.211]                       }
[08:24:57.211]                     })
[08:24:57.211]                   }
[08:24:57.211]                   ...future.strategy.old <- future::plan("list")
[08:24:57.211]                   options(future.plan = NULL)
[08:24:57.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.211]                 }
[08:24:57.211]                 ...future.workdir <- getwd()
[08:24:57.211]             }
[08:24:57.211]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.211]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.211]         }
[08:24:57.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.211]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.211]             base::names(...future.oldOptions))
[08:24:57.211]     }
[08:24:57.211]     if (FALSE) {
[08:24:57.211]     }
[08:24:57.211]     else {
[08:24:57.211]         if (TRUE) {
[08:24:57.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.211]                 open = "w")
[08:24:57.211]         }
[08:24:57.211]         else {
[08:24:57.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.211]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.211]         }
[08:24:57.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.211]             base::sink(type = "output", split = FALSE)
[08:24:57.211]             base::close(...future.stdout)
[08:24:57.211]         }, add = TRUE)
[08:24:57.211]     }
[08:24:57.211]     ...future.frame <- base::sys.nframe()
[08:24:57.211]     ...future.conditions <- base::list()
[08:24:57.211]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.211]     if (FALSE) {
[08:24:57.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.211]     }
[08:24:57.211]     ...future.result <- base::tryCatch({
[08:24:57.211]         base::withCallingHandlers({
[08:24:57.211]             ...future.value <- base::withVisible(base::local({
[08:24:57.211]                 do.call(function(...) {
[08:24:57.211]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.211]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.211]                     ...future.globals.maxSize)) {
[08:24:57.211]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.211]                     on.exit(options(oopts), add = TRUE)
[08:24:57.211]                   }
[08:24:57.211]                   {
[08:24:57.211]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.211]                       FUN = function(jj) {
[08:24:57.211]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.211]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.211]                       })
[08:24:57.211]                   }
[08:24:57.211]                 }, args = future.call.arguments)
[08:24:57.211]             }))
[08:24:57.211]             future::FutureResult(value = ...future.value$value, 
[08:24:57.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.211]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.211]                     ...future.globalenv.names))
[08:24:57.211]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.211]         }, condition = base::local({
[08:24:57.211]             c <- base::c
[08:24:57.211]             inherits <- base::inherits
[08:24:57.211]             invokeRestart <- base::invokeRestart
[08:24:57.211]             length <- base::length
[08:24:57.211]             list <- base::list
[08:24:57.211]             seq.int <- base::seq.int
[08:24:57.211]             signalCondition <- base::signalCondition
[08:24:57.211]             sys.calls <- base::sys.calls
[08:24:57.211]             `[[` <- base::`[[`
[08:24:57.211]             `+` <- base::`+`
[08:24:57.211]             `<<-` <- base::`<<-`
[08:24:57.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.211]                   3L)]
[08:24:57.211]             }
[08:24:57.211]             function(cond) {
[08:24:57.211]                 is_error <- inherits(cond, "error")
[08:24:57.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.211]                   NULL)
[08:24:57.211]                 if (is_error) {
[08:24:57.211]                   sessionInformation <- function() {
[08:24:57.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.211]                       search = base::search(), system = base::Sys.info())
[08:24:57.211]                   }
[08:24:57.211]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.211]                     cond$call), session = sessionInformation(), 
[08:24:57.211]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.211]                   signalCondition(cond)
[08:24:57.211]                 }
[08:24:57.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.211]                 "immediateCondition"))) {
[08:24:57.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.211]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.211]                   if (TRUE && !signal) {
[08:24:57.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.211]                     {
[08:24:57.211]                       inherits <- base::inherits
[08:24:57.211]                       invokeRestart <- base::invokeRestart
[08:24:57.211]                       is.null <- base::is.null
[08:24:57.211]                       muffled <- FALSE
[08:24:57.211]                       if (inherits(cond, "message")) {
[08:24:57.211]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.211]                         if (muffled) 
[08:24:57.211]                           invokeRestart("muffleMessage")
[08:24:57.211]                       }
[08:24:57.211]                       else if (inherits(cond, "warning")) {
[08:24:57.211]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.211]                         if (muffled) 
[08:24:57.211]                           invokeRestart("muffleWarning")
[08:24:57.211]                       }
[08:24:57.211]                       else if (inherits(cond, "condition")) {
[08:24:57.211]                         if (!is.null(pattern)) {
[08:24:57.211]                           computeRestarts <- base::computeRestarts
[08:24:57.211]                           grepl <- base::grepl
[08:24:57.211]                           restarts <- computeRestarts(cond)
[08:24:57.211]                           for (restart in restarts) {
[08:24:57.211]                             name <- restart$name
[08:24:57.211]                             if (is.null(name)) 
[08:24:57.211]                               next
[08:24:57.211]                             if (!grepl(pattern, name)) 
[08:24:57.211]                               next
[08:24:57.211]                             invokeRestart(restart)
[08:24:57.211]                             muffled <- TRUE
[08:24:57.211]                             break
[08:24:57.211]                           }
[08:24:57.211]                         }
[08:24:57.211]                       }
[08:24:57.211]                       invisible(muffled)
[08:24:57.211]                     }
[08:24:57.211]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.211]                   }
[08:24:57.211]                 }
[08:24:57.211]                 else {
[08:24:57.211]                   if (TRUE) {
[08:24:57.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.211]                     {
[08:24:57.211]                       inherits <- base::inherits
[08:24:57.211]                       invokeRestart <- base::invokeRestart
[08:24:57.211]                       is.null <- base::is.null
[08:24:57.211]                       muffled <- FALSE
[08:24:57.211]                       if (inherits(cond, "message")) {
[08:24:57.211]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.211]                         if (muffled) 
[08:24:57.211]                           invokeRestart("muffleMessage")
[08:24:57.211]                       }
[08:24:57.211]                       else if (inherits(cond, "warning")) {
[08:24:57.211]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.211]                         if (muffled) 
[08:24:57.211]                           invokeRestart("muffleWarning")
[08:24:57.211]                       }
[08:24:57.211]                       else if (inherits(cond, "condition")) {
[08:24:57.211]                         if (!is.null(pattern)) {
[08:24:57.211]                           computeRestarts <- base::computeRestarts
[08:24:57.211]                           grepl <- base::grepl
[08:24:57.211]                           restarts <- computeRestarts(cond)
[08:24:57.211]                           for (restart in restarts) {
[08:24:57.211]                             name <- restart$name
[08:24:57.211]                             if (is.null(name)) 
[08:24:57.211]                               next
[08:24:57.211]                             if (!grepl(pattern, name)) 
[08:24:57.211]                               next
[08:24:57.211]                             invokeRestart(restart)
[08:24:57.211]                             muffled <- TRUE
[08:24:57.211]                             break
[08:24:57.211]                           }
[08:24:57.211]                         }
[08:24:57.211]                       }
[08:24:57.211]                       invisible(muffled)
[08:24:57.211]                     }
[08:24:57.211]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.211]                   }
[08:24:57.211]                 }
[08:24:57.211]             }
[08:24:57.211]         }))
[08:24:57.211]     }, error = function(ex) {
[08:24:57.211]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.211]                 ...future.rng), started = ...future.startTime, 
[08:24:57.211]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.211]             version = "1.8"), class = "FutureResult")
[08:24:57.211]     }, finally = {
[08:24:57.211]         if (!identical(...future.workdir, getwd())) 
[08:24:57.211]             setwd(...future.workdir)
[08:24:57.211]         {
[08:24:57.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.211]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.211]             }
[08:24:57.211]             base::options(...future.oldOptions)
[08:24:57.211]             if (.Platform$OS.type == "windows") {
[08:24:57.211]                 old_names <- names(...future.oldEnvVars)
[08:24:57.211]                 envs <- base::Sys.getenv()
[08:24:57.211]                 names <- names(envs)
[08:24:57.211]                 common <- intersect(names, old_names)
[08:24:57.211]                 added <- setdiff(names, old_names)
[08:24:57.211]                 removed <- setdiff(old_names, names)
[08:24:57.211]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.211]                   envs[common]]
[08:24:57.211]                 NAMES <- toupper(changed)
[08:24:57.211]                 args <- list()
[08:24:57.211]                 for (kk in seq_along(NAMES)) {
[08:24:57.211]                   name <- changed[[kk]]
[08:24:57.211]                   NAME <- NAMES[[kk]]
[08:24:57.211]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.211]                     next
[08:24:57.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.211]                 }
[08:24:57.211]                 NAMES <- toupper(added)
[08:24:57.211]                 for (kk in seq_along(NAMES)) {
[08:24:57.211]                   name <- added[[kk]]
[08:24:57.211]                   NAME <- NAMES[[kk]]
[08:24:57.211]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.211]                     next
[08:24:57.211]                   args[[name]] <- ""
[08:24:57.211]                 }
[08:24:57.211]                 NAMES <- toupper(removed)
[08:24:57.211]                 for (kk in seq_along(NAMES)) {
[08:24:57.211]                   name <- removed[[kk]]
[08:24:57.211]                   NAME <- NAMES[[kk]]
[08:24:57.211]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.211]                     next
[08:24:57.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.211]                 }
[08:24:57.211]                 if (length(args) > 0) 
[08:24:57.211]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.211]             }
[08:24:57.211]             else {
[08:24:57.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.211]             }
[08:24:57.211]             {
[08:24:57.211]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.211]                   0L) {
[08:24:57.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.211]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.211]                   base::options(opts)
[08:24:57.211]                 }
[08:24:57.211]                 {
[08:24:57.211]                   {
[08:24:57.211]                     NULL
[08:24:57.211]                     RNGkind("Mersenne-Twister")
[08:24:57.211]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.211]                       inherits = FALSE)
[08:24:57.211]                   }
[08:24:57.211]                   options(future.plan = NULL)
[08:24:57.211]                   if (is.na(NA_character_)) 
[08:24:57.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.211]                     .init = FALSE)
[08:24:57.211]                 }
[08:24:57.211]             }
[08:24:57.211]         }
[08:24:57.211]     })
[08:24:57.211]     if (TRUE) {
[08:24:57.211]         base::sink(type = "output", split = FALSE)
[08:24:57.211]         if (TRUE) {
[08:24:57.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.211]         }
[08:24:57.211]         else {
[08:24:57.211]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.211]         }
[08:24:57.211]         base::close(...future.stdout)
[08:24:57.211]         ...future.stdout <- NULL
[08:24:57.211]     }
[08:24:57.211]     ...future.result$conditions <- ...future.conditions
[08:24:57.211]     ...future.result$finished <- base::Sys.time()
[08:24:57.211]     ...future.result
[08:24:57.211] }
[08:24:57.215] assign_globals() ...
[08:24:57.215] List of 5
[08:24:57.215]  $ ...future.FUN            :function (object, ...)  
[08:24:57.215]  $ future.call.arguments    : list()
[08:24:57.215]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.215]  $ ...future.elements_ii    :List of 3
[08:24:57.215]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:57.215]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.215]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.215]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:57.215]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.215]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.215]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:57.215]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.215]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.215]  $ ...future.seeds_ii       : NULL
[08:24:57.215]  $ ...future.globals.maxSize: NULL
[08:24:57.215]  - attr(*, "where")=List of 5
[08:24:57.215]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.215]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.215]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.215]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.215]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.215]  - attr(*, "resolved")= logi FALSE
[08:24:57.215]  - attr(*, "total_size")= num 15670
[08:24:57.215]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.215]  - attr(*, "already-done")= logi TRUE
[08:24:57.224] - copied ‘...future.FUN’ to environment
[08:24:57.224] - copied ‘future.call.arguments’ to environment
[08:24:57.224] - copied ‘...future.elements_ii’ to environment
[08:24:57.224] - copied ‘...future.seeds_ii’ to environment
[08:24:57.224] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.225] assign_globals() ... done
[08:24:57.225] plan(): Setting new future strategy stack:
[08:24:57.225] List of future strategies:
[08:24:57.225] 1. sequential:
[08:24:57.225]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.225]    - tweaked: FALSE
[08:24:57.225]    - call: NULL
[08:24:57.225] plan(): nbrOfWorkers() = 1
[08:24:57.227] plan(): Setting new future strategy stack:
[08:24:57.228] List of future strategies:
[08:24:57.228] 1. sequential:
[08:24:57.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.228]    - tweaked: FALSE
[08:24:57.228]    - call: plan(strategy)
[08:24:57.228] plan(): nbrOfWorkers() = 1
[08:24:57.228] SequentialFuture started (and completed)
[08:24:57.228] - Launch lazy future ... done
[08:24:57.228] run() for ‘SequentialFuture’ ... done
[08:24:57.229] Created future:
[08:24:57.229] SequentialFuture:
[08:24:57.229] Label: ‘future_by-1’
[08:24:57.229] Expression:
[08:24:57.229] {
[08:24:57.229]     do.call(function(...) {
[08:24:57.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.229]             on.exit(options(oopts), add = TRUE)
[08:24:57.229]         }
[08:24:57.229]         {
[08:24:57.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.229]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.229]             })
[08:24:57.229]         }
[08:24:57.229]     }, args = future.call.arguments)
[08:24:57.229] }
[08:24:57.229] Lazy evaluation: FALSE
[08:24:57.229] Asynchronous evaluation: FALSE
[08:24:57.229] Local evaluation: TRUE
[08:24:57.229] Environment: R_GlobalEnv
[08:24:57.229] Capture standard output: TRUE
[08:24:57.229] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.229] Globals: 5 objects totaling 1.90 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.48 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.229] Packages: <none>
[08:24:57.229] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.229] Resolved: TRUE
[08:24:57.229] Value: 1.16 KiB of class ‘list’
[08:24:57.229] Early signaling: FALSE
[08:24:57.229] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.229] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.230] Chunk #1 of 1 ... DONE
[08:24:57.230] Launching 1 futures (chunks) ... DONE
[08:24:57.230] Resolving 1 futures (chunks) ...
[08:24:57.230] resolve() on list ...
[08:24:57.230]  recursive: 0
[08:24:57.230]  length: 1
[08:24:57.230] 
[08:24:57.230] resolved() for ‘SequentialFuture’ ...
[08:24:57.230] - state: ‘finished’
[08:24:57.230] - run: TRUE
[08:24:57.231] - result: ‘FutureResult’
[08:24:57.231] resolved() for ‘SequentialFuture’ ... done
[08:24:57.231] Future #1
[08:24:57.231] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.231] - nx: 1
[08:24:57.231] - relay: TRUE
[08:24:57.231] - stdout: TRUE
[08:24:57.231] - signal: TRUE
[08:24:57.231] - resignal: FALSE
[08:24:57.231] - force: TRUE
[08:24:57.231] - relayed: [n=1] FALSE
[08:24:57.232] - queued futures: [n=1] FALSE
[08:24:57.232]  - until=1
[08:24:57.232]  - relaying element #1
[08:24:57.232] - relayed: [n=1] TRUE
[08:24:57.232] - queued futures: [n=1] TRUE
[08:24:57.232] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.232]  length: 0 (resolved future 1)
[08:24:57.232] Relaying remaining futures
[08:24:57.232] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.232] - nx: 1
[08:24:57.233] - relay: TRUE
[08:24:57.233] - stdout: TRUE
[08:24:57.233] - signal: TRUE
[08:24:57.233] - resignal: FALSE
[08:24:57.233] - force: TRUE
[08:24:57.233] - relayed: [n=1] TRUE
[08:24:57.233] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.233] - relayed: [n=1] TRUE
[08:24:57.233] - queued futures: [n=1] TRUE
[08:24:57.233] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.233] resolve() on list ... DONE
[08:24:57.234]  - Number of value chunks collected: 1
[08:24:57.234] Resolving 1 futures (chunks) ... DONE
[08:24:57.234] Reducing values from 1 chunks ...
[08:24:57.234]  - Number of values collected after concatenation: 3
[08:24:57.234]  - Number of values expected: 3
[08:24:57.234] Reducing values from 1 chunks ... DONE
[08:24:57.234] future_lapply() ... DONE
[08:24:57.234] future_by_internal() ... DONE
[08:24:57.234] future_by_internal() ...
[08:24:57.235] future_lapply() ...
[08:24:57.235] Number of chunks: 1
[08:24:57.235] getGlobalsAndPackagesXApply() ...
[08:24:57.235]  - future.globals: TRUE
[08:24:57.236] getGlobalsAndPackages() ...
[08:24:57.236] Searching for globals...
[08:24:57.237] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:57.239] Searching for globals ... DONE
[08:24:57.239] Resolving globals: FALSE
[08:24:57.239] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:57.240] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:57.240] - globals: [1] ‘FUN’
[08:24:57.240] 
[08:24:57.240] getGlobalsAndPackages() ... DONE
[08:24:57.240]  - globals found/used: [n=1] ‘FUN’
[08:24:57.240]  - needed namespaces: [n=0] 
[08:24:57.241] Finding globals ... DONE
[08:24:57.241]  - use_args: TRUE
[08:24:57.241]  - Getting '...' globals ...
[08:24:57.241] resolve() on list ...
[08:24:57.241]  recursive: 0
[08:24:57.241]  length: 1
[08:24:57.242]  elements: ‘...’
[08:24:57.242]  length: 0 (resolved future 1)
[08:24:57.242] resolve() on list ... DONE
[08:24:57.242]    - '...' content: [n=1] ‘digits’
[08:24:57.242] List of 1
[08:24:57.242]  $ ...:List of 1
[08:24:57.242]   ..$ digits: int 2
[08:24:57.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.242]  - attr(*, "where")=List of 1
[08:24:57.242]   ..$ ...:<environment: 0x557b2826ff38> 
[08:24:57.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.242]  - attr(*, "resolved")= logi TRUE
[08:24:57.242]  - attr(*, "total_size")= num NA
[08:24:57.246]  - Getting '...' globals ... DONE
[08:24:57.246] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.246] List of 2
[08:24:57.246]  $ ...future.FUN:function (object, ...)  
[08:24:57.246]  $ ...          :List of 1
[08:24:57.246]   ..$ digits: int 2
[08:24:57.246]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.246]  - attr(*, "where")=List of 2
[08:24:57.246]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.246]   ..$ ...          :<environment: 0x557b2826ff38> 
[08:24:57.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.246]  - attr(*, "resolved")= logi FALSE
[08:24:57.246]  - attr(*, "total_size")= num 13284
[08:24:57.249] Packages to be attached in all futures: [n=0] 
[08:24:57.249] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.249] Number of futures (= number of chunks): 1
[08:24:57.249] Launching 1 futures (chunks) ...
[08:24:57.250] Chunk #1 of 1 ...
[08:24:57.250]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.250] getGlobalsAndPackages() ...
[08:24:57.250] Searching for globals...
[08:24:57.250] 
[08:24:57.250] Searching for globals ... DONE
[08:24:57.250] - globals: [0] <none>
[08:24:57.250] getGlobalsAndPackages() ... DONE
[08:24:57.251]    + additional globals found: [n=0] 
[08:24:57.251]    + additional namespaces needed: [n=0] 
[08:24:57.251]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.251]  - seeds: <none>
[08:24:57.251]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.251] getGlobalsAndPackages() ...
[08:24:57.251] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.251] Resolving globals: FALSE
[08:24:57.251] Tweak future expression to call with '...' arguments ...
[08:24:57.251] {
[08:24:57.251]     do.call(function(...) {
[08:24:57.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.251]             on.exit(options(oopts), add = TRUE)
[08:24:57.251]         }
[08:24:57.251]         {
[08:24:57.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.251]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.251]             })
[08:24:57.251]         }
[08:24:57.251]     }, args = future.call.arguments)
[08:24:57.251] }
[08:24:57.252] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.252] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.252] 
[08:24:57.252] getGlobalsAndPackages() ... DONE
[08:24:57.253] run() for ‘Future’ ...
[08:24:57.253] - state: ‘created’
[08:24:57.253] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:57.253] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.253] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.253]   - Field: ‘label’
[08:24:57.253]   - Field: ‘local’
[08:24:57.254]   - Field: ‘owner’
[08:24:57.254]   - Field: ‘envir’
[08:24:57.254]   - Field: ‘packages’
[08:24:57.254]   - Field: ‘gc’
[08:24:57.254]   - Field: ‘conditions’
[08:24:57.254]   - Field: ‘expr’
[08:24:57.254]   - Field: ‘uuid’
[08:24:57.254]   - Field: ‘seed’
[08:24:57.254]   - Field: ‘version’
[08:24:57.254]   - Field: ‘result’
[08:24:57.254]   - Field: ‘asynchronous’
[08:24:57.255]   - Field: ‘calls’
[08:24:57.255]   - Field: ‘globals’
[08:24:57.255]   - Field: ‘stdout’
[08:24:57.255]   - Field: ‘earlySignal’
[08:24:57.255]   - Field: ‘lazy’
[08:24:57.255]   - Field: ‘state’
[08:24:57.255] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.255] - Launch lazy future ...
[08:24:57.255] Packages needed by the future expression (n = 0): <none>
[08:24:57.255] Packages needed by future strategies (n = 0): <none>
[08:24:57.256] {
[08:24:57.256]     {
[08:24:57.256]         {
[08:24:57.256]             ...future.startTime <- base::Sys.time()
[08:24:57.256]             {
[08:24:57.256]                 {
[08:24:57.256]                   {
[08:24:57.256]                     base::local({
[08:24:57.256]                       has_future <- base::requireNamespace("future", 
[08:24:57.256]                         quietly = TRUE)
[08:24:57.256]                       if (has_future) {
[08:24:57.256]                         ns <- base::getNamespace("future")
[08:24:57.256]                         version <- ns[[".package"]][["version"]]
[08:24:57.256]                         if (is.null(version)) 
[08:24:57.256]                           version <- utils::packageVersion("future")
[08:24:57.256]                       }
[08:24:57.256]                       else {
[08:24:57.256]                         version <- NULL
[08:24:57.256]                       }
[08:24:57.256]                       if (!has_future || version < "1.8.0") {
[08:24:57.256]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.256]                           "", base::R.version$version.string), 
[08:24:57.256]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:57.256]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.256]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.256]                             "release", "version")], collapse = " "), 
[08:24:57.256]                           hostname = base::Sys.info()[["nodename"]])
[08:24:57.256]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.256]                           info)
[08:24:57.256]                         info <- base::paste(info, collapse = "; ")
[08:24:57.256]                         if (!has_future) {
[08:24:57.256]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.256]                             info)
[08:24:57.256]                         }
[08:24:57.256]                         else {
[08:24:57.256]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.256]                             info, version)
[08:24:57.256]                         }
[08:24:57.256]                         base::stop(msg)
[08:24:57.256]                       }
[08:24:57.256]                     })
[08:24:57.256]                   }
[08:24:57.256]                   ...future.strategy.old <- future::plan("list")
[08:24:57.256]                   options(future.plan = NULL)
[08:24:57.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.256]                 }
[08:24:57.256]                 ...future.workdir <- getwd()
[08:24:57.256]             }
[08:24:57.256]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.256]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.256]         }
[08:24:57.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.256]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.256]             base::names(...future.oldOptions))
[08:24:57.256]     }
[08:24:57.256]     if (FALSE) {
[08:24:57.256]     }
[08:24:57.256]     else {
[08:24:57.256]         if (TRUE) {
[08:24:57.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.256]                 open = "w")
[08:24:57.256]         }
[08:24:57.256]         else {
[08:24:57.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.256]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.256]         }
[08:24:57.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.256]             base::sink(type = "output", split = FALSE)
[08:24:57.256]             base::close(...future.stdout)
[08:24:57.256]         }, add = TRUE)
[08:24:57.256]     }
[08:24:57.256]     ...future.frame <- base::sys.nframe()
[08:24:57.256]     ...future.conditions <- base::list()
[08:24:57.256]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.256]     if (FALSE) {
[08:24:57.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.256]     }
[08:24:57.256]     ...future.result <- base::tryCatch({
[08:24:57.256]         base::withCallingHandlers({
[08:24:57.256]             ...future.value <- base::withVisible(base::local({
[08:24:57.256]                 do.call(function(...) {
[08:24:57.256]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.256]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.256]                     ...future.globals.maxSize)) {
[08:24:57.256]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.256]                     on.exit(options(oopts), add = TRUE)
[08:24:57.256]                   }
[08:24:57.256]                   {
[08:24:57.256]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.256]                       FUN = function(jj) {
[08:24:57.256]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.256]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.256]                       })
[08:24:57.256]                   }
[08:24:57.256]                 }, args = future.call.arguments)
[08:24:57.256]             }))
[08:24:57.256]             future::FutureResult(value = ...future.value$value, 
[08:24:57.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.256]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.256]                     ...future.globalenv.names))
[08:24:57.256]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.256]         }, condition = base::local({
[08:24:57.256]             c <- base::c
[08:24:57.256]             inherits <- base::inherits
[08:24:57.256]             invokeRestart <- base::invokeRestart
[08:24:57.256]             length <- base::length
[08:24:57.256]             list <- base::list
[08:24:57.256]             seq.int <- base::seq.int
[08:24:57.256]             signalCondition <- base::signalCondition
[08:24:57.256]             sys.calls <- base::sys.calls
[08:24:57.256]             `[[` <- base::`[[`
[08:24:57.256]             `+` <- base::`+`
[08:24:57.256]             `<<-` <- base::`<<-`
[08:24:57.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.256]                   3L)]
[08:24:57.256]             }
[08:24:57.256]             function(cond) {
[08:24:57.256]                 is_error <- inherits(cond, "error")
[08:24:57.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.256]                   NULL)
[08:24:57.256]                 if (is_error) {
[08:24:57.256]                   sessionInformation <- function() {
[08:24:57.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.256]                       search = base::search(), system = base::Sys.info())
[08:24:57.256]                   }
[08:24:57.256]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.256]                     cond$call), session = sessionInformation(), 
[08:24:57.256]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.256]                   signalCondition(cond)
[08:24:57.256]                 }
[08:24:57.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.256]                 "immediateCondition"))) {
[08:24:57.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.256]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.256]                   if (TRUE && !signal) {
[08:24:57.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.256]                     {
[08:24:57.256]                       inherits <- base::inherits
[08:24:57.256]                       invokeRestart <- base::invokeRestart
[08:24:57.256]                       is.null <- base::is.null
[08:24:57.256]                       muffled <- FALSE
[08:24:57.256]                       if (inherits(cond, "message")) {
[08:24:57.256]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.256]                         if (muffled) 
[08:24:57.256]                           invokeRestart("muffleMessage")
[08:24:57.256]                       }
[08:24:57.256]                       else if (inherits(cond, "warning")) {
[08:24:57.256]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.256]                         if (muffled) 
[08:24:57.256]                           invokeRestart("muffleWarning")
[08:24:57.256]                       }
[08:24:57.256]                       else if (inherits(cond, "condition")) {
[08:24:57.256]                         if (!is.null(pattern)) {
[08:24:57.256]                           computeRestarts <- base::computeRestarts
[08:24:57.256]                           grepl <- base::grepl
[08:24:57.256]                           restarts <- computeRestarts(cond)
[08:24:57.256]                           for (restart in restarts) {
[08:24:57.256]                             name <- restart$name
[08:24:57.256]                             if (is.null(name)) 
[08:24:57.256]                               next
[08:24:57.256]                             if (!grepl(pattern, name)) 
[08:24:57.256]                               next
[08:24:57.256]                             invokeRestart(restart)
[08:24:57.256]                             muffled <- TRUE
[08:24:57.256]                             break
[08:24:57.256]                           }
[08:24:57.256]                         }
[08:24:57.256]                       }
[08:24:57.256]                       invisible(muffled)
[08:24:57.256]                     }
[08:24:57.256]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.256]                   }
[08:24:57.256]                 }
[08:24:57.256]                 else {
[08:24:57.256]                   if (TRUE) {
[08:24:57.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.256]                     {
[08:24:57.256]                       inherits <- base::inherits
[08:24:57.256]                       invokeRestart <- base::invokeRestart
[08:24:57.256]                       is.null <- base::is.null
[08:24:57.256]                       muffled <- FALSE
[08:24:57.256]                       if (inherits(cond, "message")) {
[08:24:57.256]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.256]                         if (muffled) 
[08:24:57.256]                           invokeRestart("muffleMessage")
[08:24:57.256]                       }
[08:24:57.256]                       else if (inherits(cond, "warning")) {
[08:24:57.256]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.256]                         if (muffled) 
[08:24:57.256]                           invokeRestart("muffleWarning")
[08:24:57.256]                       }
[08:24:57.256]                       else if (inherits(cond, "condition")) {
[08:24:57.256]                         if (!is.null(pattern)) {
[08:24:57.256]                           computeRestarts <- base::computeRestarts
[08:24:57.256]                           grepl <- base::grepl
[08:24:57.256]                           restarts <- computeRestarts(cond)
[08:24:57.256]                           for (restart in restarts) {
[08:24:57.256]                             name <- restart$name
[08:24:57.256]                             if (is.null(name)) 
[08:24:57.256]                               next
[08:24:57.256]                             if (!grepl(pattern, name)) 
[08:24:57.256]                               next
[08:24:57.256]                             invokeRestart(restart)
[08:24:57.256]                             muffled <- TRUE
[08:24:57.256]                             break
[08:24:57.256]                           }
[08:24:57.256]                         }
[08:24:57.256]                       }
[08:24:57.256]                       invisible(muffled)
[08:24:57.256]                     }
[08:24:57.256]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.256]                   }
[08:24:57.256]                 }
[08:24:57.256]             }
[08:24:57.256]         }))
[08:24:57.256]     }, error = function(ex) {
[08:24:57.256]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.256]                 ...future.rng), started = ...future.startTime, 
[08:24:57.256]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.256]             version = "1.8"), class = "FutureResult")
[08:24:57.256]     }, finally = {
[08:24:57.256]         if (!identical(...future.workdir, getwd())) 
[08:24:57.256]             setwd(...future.workdir)
[08:24:57.256]         {
[08:24:57.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.256]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.256]             }
[08:24:57.256]             base::options(...future.oldOptions)
[08:24:57.256]             if (.Platform$OS.type == "windows") {
[08:24:57.256]                 old_names <- names(...future.oldEnvVars)
[08:24:57.256]                 envs <- base::Sys.getenv()
[08:24:57.256]                 names <- names(envs)
[08:24:57.256]                 common <- intersect(names, old_names)
[08:24:57.256]                 added <- setdiff(names, old_names)
[08:24:57.256]                 removed <- setdiff(old_names, names)
[08:24:57.256]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.256]                   envs[common]]
[08:24:57.256]                 NAMES <- toupper(changed)
[08:24:57.256]                 args <- list()
[08:24:57.256]                 for (kk in seq_along(NAMES)) {
[08:24:57.256]                   name <- changed[[kk]]
[08:24:57.256]                   NAME <- NAMES[[kk]]
[08:24:57.256]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.256]                     next
[08:24:57.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.256]                 }
[08:24:57.256]                 NAMES <- toupper(added)
[08:24:57.256]                 for (kk in seq_along(NAMES)) {
[08:24:57.256]                   name <- added[[kk]]
[08:24:57.256]                   NAME <- NAMES[[kk]]
[08:24:57.256]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.256]                     next
[08:24:57.256]                   args[[name]] <- ""
[08:24:57.256]                 }
[08:24:57.256]                 NAMES <- toupper(removed)
[08:24:57.256]                 for (kk in seq_along(NAMES)) {
[08:24:57.256]                   name <- removed[[kk]]
[08:24:57.256]                   NAME <- NAMES[[kk]]
[08:24:57.256]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.256]                     next
[08:24:57.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.256]                 }
[08:24:57.256]                 if (length(args) > 0) 
[08:24:57.256]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.256]             }
[08:24:57.256]             else {
[08:24:57.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.256]             }
[08:24:57.256]             {
[08:24:57.256]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.256]                   0L) {
[08:24:57.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.256]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.256]                   base::options(opts)
[08:24:57.256]                 }
[08:24:57.256]                 {
[08:24:57.256]                   {
[08:24:57.256]                     NULL
[08:24:57.256]                     RNGkind("Mersenne-Twister")
[08:24:57.256]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.256]                       inherits = FALSE)
[08:24:57.256]                   }
[08:24:57.256]                   options(future.plan = NULL)
[08:24:57.256]                   if (is.na(NA_character_)) 
[08:24:57.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.256]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.256]                     .init = FALSE)
[08:24:57.256]                 }
[08:24:57.256]             }
[08:24:57.256]         }
[08:24:57.256]     })
[08:24:57.256]     if (TRUE) {
[08:24:57.256]         base::sink(type = "output", split = FALSE)
[08:24:57.256]         if (TRUE) {
[08:24:57.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.256]         }
[08:24:57.256]         else {
[08:24:57.256]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.256]         }
[08:24:57.256]         base::close(...future.stdout)
[08:24:57.256]         ...future.stdout <- NULL
[08:24:57.256]     }
[08:24:57.256]     ...future.result$conditions <- ...future.conditions
[08:24:57.256]     ...future.result$finished <- base::Sys.time()
[08:24:57.256]     ...future.result
[08:24:57.256] }
[08:24:57.258] assign_globals() ...
[08:24:57.258] List of 5
[08:24:57.258]  $ ...future.FUN            :function (object, ...)  
[08:24:57.258]  $ future.call.arguments    :List of 1
[08:24:57.258]   ..$ digits: int 2
[08:24:57.258]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.258]  $ ...future.elements_ii    :List of 6
[08:24:57.258]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[08:24:57.258]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[08:24:57.258]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[08:24:57.258]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[08:24:57.258]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[08:24:57.258]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[08:24:57.258]  $ ...future.seeds_ii       : NULL
[08:24:57.258]  $ ...future.globals.maxSize: NULL
[08:24:57.258]  - attr(*, "where")=List of 5
[08:24:57.258]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.258]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.258]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.258]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.258]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.258]  - attr(*, "resolved")= logi FALSE
[08:24:57.258]  - attr(*, "total_size")= num 13284
[08:24:57.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.258]  - attr(*, "already-done")= logi TRUE
[08:24:57.268] - copied ‘...future.FUN’ to environment
[08:24:57.268] - copied ‘future.call.arguments’ to environment
[08:24:57.268] - copied ‘...future.elements_ii’ to environment
[08:24:57.268] - copied ‘...future.seeds_ii’ to environment
[08:24:57.268] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.268] assign_globals() ... done
[08:24:57.269] plan(): Setting new future strategy stack:
[08:24:57.269] List of future strategies:
[08:24:57.269] 1. sequential:
[08:24:57.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.269]    - tweaked: FALSE
[08:24:57.269]    - call: NULL
[08:24:57.269] plan(): nbrOfWorkers() = 1
[08:24:57.271] plan(): Setting new future strategy stack:
[08:24:57.271] List of future strategies:
[08:24:57.271] 1. sequential:
[08:24:57.271]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.271]    - tweaked: FALSE
[08:24:57.271]    - call: plan(strategy)
[08:24:57.271] plan(): nbrOfWorkers() = 1
[08:24:57.272] SequentialFuture started (and completed)
[08:24:57.272] - Launch lazy future ... done
[08:24:57.272] run() for ‘SequentialFuture’ ... done
[08:24:57.272] Created future:
[08:24:57.272] SequentialFuture:
[08:24:57.272] Label: ‘future_by-1’
[08:24:57.272] Expression:
[08:24:57.272] {
[08:24:57.272]     do.call(function(...) {
[08:24:57.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.272]             on.exit(options(oopts), add = TRUE)
[08:24:57.272]         }
[08:24:57.272]         {
[08:24:57.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.272]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.272]             })
[08:24:57.272]         }
[08:24:57.272]     }, args = future.call.arguments)
[08:24:57.272] }
[08:24:57.272] Lazy evaluation: FALSE
[08:24:57.272] Asynchronous evaluation: FALSE
[08:24:57.272] Local evaluation: TRUE
[08:24:57.272] Environment: R_GlobalEnv
[08:24:57.272] Capture standard output: TRUE
[08:24:57.272] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.272] Globals: 5 objects totaling 998 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 511 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.272] Packages: <none>
[08:24:57.272] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.272] Resolved: TRUE
[08:24:57.272] Value: 1.27 KiB of class ‘list’
[08:24:57.272] Early signaling: FALSE
[08:24:57.272] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.272] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.273] Chunk #1 of 1 ... DONE
[08:24:57.273] Launching 1 futures (chunks) ... DONE
[08:24:57.273] Resolving 1 futures (chunks) ...
[08:24:57.273] resolve() on list ...
[08:24:57.273]  recursive: 0
[08:24:57.273]  length: 1
[08:24:57.273] 
[08:24:57.273] resolved() for ‘SequentialFuture’ ...
[08:24:57.274] - state: ‘finished’
[08:24:57.274] - run: TRUE
[08:24:57.274] - result: ‘FutureResult’
[08:24:57.274] resolved() for ‘SequentialFuture’ ... done
[08:24:57.274] Future #1
[08:24:57.274] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.274] - nx: 1
[08:24:57.274] - relay: TRUE
[08:24:57.274] - stdout: TRUE
[08:24:57.274] - signal: TRUE
[08:24:57.275] - resignal: FALSE
[08:24:57.275] - force: TRUE
[08:24:57.275] - relayed: [n=1] FALSE
[08:24:57.275] - queued futures: [n=1] FALSE
[08:24:57.275]  - until=1
[08:24:57.275]  - relaying element #1
[08:24:57.275] - relayed: [n=1] TRUE
[08:24:57.275] - queued futures: [n=1] TRUE
[08:24:57.275] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.275]  length: 0 (resolved future 1)
[08:24:57.276] Relaying remaining futures
[08:24:57.276] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.276] - nx: 1
[08:24:57.276] - relay: TRUE
[08:24:57.276] - stdout: TRUE
[08:24:57.276] - signal: TRUE
[08:24:57.276] - resignal: FALSE
[08:24:57.276] - force: TRUE
[08:24:57.276] - relayed: [n=1] TRUE
[08:24:57.276] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.276] - relayed: [n=1] TRUE
[08:24:57.276] - queued futures: [n=1] TRUE
[08:24:57.277] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.277] resolve() on list ... DONE
[08:24:57.277]  - Number of value chunks collected: 1
[08:24:57.277] Resolving 1 futures (chunks) ... DONE
[08:24:57.277] Reducing values from 1 chunks ...
[08:24:57.277]  - Number of values collected after concatenation: 6
[08:24:57.277]  - Number of values expected: 6
[08:24:57.277] Reducing values from 1 chunks ... DONE
[08:24:57.277] future_lapply() ... DONE
[08:24:57.277] future_by_internal() ... DONE
[08:24:57.279] future_by_internal() ...
[08:24:57.279] future_lapply() ...
[08:24:57.280] Number of chunks: 1
[08:24:57.281] getGlobalsAndPackagesXApply() ...
[08:24:57.281]  - future.globals: TRUE
[08:24:57.281] getGlobalsAndPackages() ...
[08:24:57.281] Searching for globals...
[08:24:57.282] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:57.283] Searching for globals ... DONE
[08:24:57.283] Resolving globals: FALSE
[08:24:57.283] The total size of the 1 globals is 762 bytes (762 bytes)
[08:24:57.283] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[08:24:57.284] - globals: [1] ‘FUN’
[08:24:57.284] - packages: [1] ‘stats’
[08:24:57.284] getGlobalsAndPackages() ... DONE
[08:24:57.284]  - globals found/used: [n=1] ‘FUN’
[08:24:57.284]  - needed namespaces: [n=1] ‘stats’
[08:24:57.284] Finding globals ... DONE
[08:24:57.284]  - use_args: TRUE
[08:24:57.284]  - Getting '...' globals ...
[08:24:57.285] resolve() on list ...
[08:24:57.285]  recursive: 0
[08:24:57.285]  length: 1
[08:24:57.285]  elements: ‘...’
[08:24:57.285]  length: 0 (resolved future 1)
[08:24:57.285] resolve() on list ... DONE
[08:24:57.285]    - '...' content: [n=1] ‘singular.ok’
[08:24:57.285] List of 1
[08:24:57.285]  $ ...:List of 1
[08:24:57.285]   ..$ singular.ok: logi FALSE
[08:24:57.285]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.285]  - attr(*, "where")=List of 1
[08:24:57.285]   ..$ ...:<environment: 0x557b27e2d480> 
[08:24:57.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.285]  - attr(*, "resolved")= logi TRUE
[08:24:57.285]  - attr(*, "total_size")= num NA
[08:24:57.291]  - Getting '...' globals ... DONE
[08:24:57.291] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.291] List of 2
[08:24:57.291]  $ ...future.FUN:function (x, ...)  
[08:24:57.291]  $ ...          :List of 1
[08:24:57.291]   ..$ singular.ok: logi FALSE
[08:24:57.291]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.291]  - attr(*, "where")=List of 2
[08:24:57.291]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.291]   ..$ ...          :<environment: 0x557b27e2d480> 
[08:24:57.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.291]  - attr(*, "resolved")= logi FALSE
[08:24:57.291]  - attr(*, "total_size")= num 19977
[08:24:57.295] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:57.295] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.295] Number of futures (= number of chunks): 1
[08:24:57.295] Launching 1 futures (chunks) ...
[08:24:57.295] Chunk #1 of 1 ...
[08:24:57.295]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.295] getGlobalsAndPackages() ...
[08:24:57.296] Searching for globals...
[08:24:57.296] 
[08:24:57.296] Searching for globals ... DONE
[08:24:57.296] - globals: [0] <none>
[08:24:57.296] getGlobalsAndPackages() ... DONE
[08:24:57.296]    + additional globals found: [n=0] 
[08:24:57.297]    + additional namespaces needed: [n=0] 
[08:24:57.297]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.297]  - seeds: <none>
[08:24:57.297]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.297] getGlobalsAndPackages() ...
[08:24:57.297] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.297] Resolving globals: FALSE
[08:24:57.297] Tweak future expression to call with '...' arguments ...
[08:24:57.297] {
[08:24:57.297]     do.call(function(...) {
[08:24:57.297]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.297]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.297]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.297]             on.exit(options(oopts), add = TRUE)
[08:24:57.297]         }
[08:24:57.297]         {
[08:24:57.297]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.297]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.297]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.297]             })
[08:24:57.297]         }
[08:24:57.297]     }, args = future.call.arguments)
[08:24:57.297] }
[08:24:57.298] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.298] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.298] 
[08:24:57.298] getGlobalsAndPackages() ... DONE
[08:24:57.298] run() for ‘Future’ ...
[08:24:57.299] - state: ‘created’
[08:24:57.299] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:57.299] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.299] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.299]   - Field: ‘label’
[08:24:57.299]   - Field: ‘local’
[08:24:57.299]   - Field: ‘owner’
[08:24:57.300]   - Field: ‘envir’
[08:24:57.300]   - Field: ‘packages’
[08:24:57.300]   - Field: ‘gc’
[08:24:57.300]   - Field: ‘conditions’
[08:24:57.300]   - Field: ‘expr’
[08:24:57.300]   - Field: ‘uuid’
[08:24:57.300]   - Field: ‘seed’
[08:24:57.300]   - Field: ‘version’
[08:24:57.300]   - Field: ‘result’
[08:24:57.300]   - Field: ‘asynchronous’
[08:24:57.300]   - Field: ‘calls’
[08:24:57.301]   - Field: ‘globals’
[08:24:57.301]   - Field: ‘stdout’
[08:24:57.301]   - Field: ‘earlySignal’
[08:24:57.301]   - Field: ‘lazy’
[08:24:57.301]   - Field: ‘state’
[08:24:57.301] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.301] - Launch lazy future ...
[08:24:57.301] Packages needed by the future expression (n = 1): ‘stats’
[08:24:57.301] Packages needed by future strategies (n = 0): <none>
[08:24:57.302] {
[08:24:57.302]     {
[08:24:57.302]         {
[08:24:57.302]             ...future.startTime <- base::Sys.time()
[08:24:57.302]             {
[08:24:57.302]                 {
[08:24:57.302]                   {
[08:24:57.302]                     {
[08:24:57.302]                       base::local({
[08:24:57.302]                         has_future <- base::requireNamespace("future", 
[08:24:57.302]                           quietly = TRUE)
[08:24:57.302]                         if (has_future) {
[08:24:57.302]                           ns <- base::getNamespace("future")
[08:24:57.302]                           version <- ns[[".package"]][["version"]]
[08:24:57.302]                           if (is.null(version)) 
[08:24:57.302]                             version <- utils::packageVersion("future")
[08:24:57.302]                         }
[08:24:57.302]                         else {
[08:24:57.302]                           version <- NULL
[08:24:57.302]                         }
[08:24:57.302]                         if (!has_future || version < "1.8.0") {
[08:24:57.302]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.302]                             "", base::R.version$version.string), 
[08:24:57.302]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:57.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.302]                               "release", "version")], collapse = " "), 
[08:24:57.302]                             hostname = base::Sys.info()[["nodename"]])
[08:24:57.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.302]                             info)
[08:24:57.302]                           info <- base::paste(info, collapse = "; ")
[08:24:57.302]                           if (!has_future) {
[08:24:57.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.302]                               info)
[08:24:57.302]                           }
[08:24:57.302]                           else {
[08:24:57.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.302]                               info, version)
[08:24:57.302]                           }
[08:24:57.302]                           base::stop(msg)
[08:24:57.302]                         }
[08:24:57.302]                       })
[08:24:57.302]                     }
[08:24:57.302]                     base::local({
[08:24:57.302]                       for (pkg in "stats") {
[08:24:57.302]                         base::loadNamespace(pkg)
[08:24:57.302]                         base::library(pkg, character.only = TRUE)
[08:24:57.302]                       }
[08:24:57.302]                     })
[08:24:57.302]                   }
[08:24:57.302]                   ...future.strategy.old <- future::plan("list")
[08:24:57.302]                   options(future.plan = NULL)
[08:24:57.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.302]                 }
[08:24:57.302]                 ...future.workdir <- getwd()
[08:24:57.302]             }
[08:24:57.302]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.302]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.302]         }
[08:24:57.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.302]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.302]             base::names(...future.oldOptions))
[08:24:57.302]     }
[08:24:57.302]     if (FALSE) {
[08:24:57.302]     }
[08:24:57.302]     else {
[08:24:57.302]         if (TRUE) {
[08:24:57.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.302]                 open = "w")
[08:24:57.302]         }
[08:24:57.302]         else {
[08:24:57.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.302]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.302]         }
[08:24:57.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.302]             base::sink(type = "output", split = FALSE)
[08:24:57.302]             base::close(...future.stdout)
[08:24:57.302]         }, add = TRUE)
[08:24:57.302]     }
[08:24:57.302]     ...future.frame <- base::sys.nframe()
[08:24:57.302]     ...future.conditions <- base::list()
[08:24:57.302]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.302]     if (FALSE) {
[08:24:57.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.302]     }
[08:24:57.302]     ...future.result <- base::tryCatch({
[08:24:57.302]         base::withCallingHandlers({
[08:24:57.302]             ...future.value <- base::withVisible(base::local({
[08:24:57.302]                 do.call(function(...) {
[08:24:57.302]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.302]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.302]                     ...future.globals.maxSize)) {
[08:24:57.302]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.302]                     on.exit(options(oopts), add = TRUE)
[08:24:57.302]                   }
[08:24:57.302]                   {
[08:24:57.302]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.302]                       FUN = function(jj) {
[08:24:57.302]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.302]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.302]                       })
[08:24:57.302]                   }
[08:24:57.302]                 }, args = future.call.arguments)
[08:24:57.302]             }))
[08:24:57.302]             future::FutureResult(value = ...future.value$value, 
[08:24:57.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.302]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.302]                     ...future.globalenv.names))
[08:24:57.302]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.302]         }, condition = base::local({
[08:24:57.302]             c <- base::c
[08:24:57.302]             inherits <- base::inherits
[08:24:57.302]             invokeRestart <- base::invokeRestart
[08:24:57.302]             length <- base::length
[08:24:57.302]             list <- base::list
[08:24:57.302]             seq.int <- base::seq.int
[08:24:57.302]             signalCondition <- base::signalCondition
[08:24:57.302]             sys.calls <- base::sys.calls
[08:24:57.302]             `[[` <- base::`[[`
[08:24:57.302]             `+` <- base::`+`
[08:24:57.302]             `<<-` <- base::`<<-`
[08:24:57.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.302]                   3L)]
[08:24:57.302]             }
[08:24:57.302]             function(cond) {
[08:24:57.302]                 is_error <- inherits(cond, "error")
[08:24:57.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.302]                   NULL)
[08:24:57.302]                 if (is_error) {
[08:24:57.302]                   sessionInformation <- function() {
[08:24:57.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.302]                       search = base::search(), system = base::Sys.info())
[08:24:57.302]                   }
[08:24:57.302]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.302]                     cond$call), session = sessionInformation(), 
[08:24:57.302]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.302]                   signalCondition(cond)
[08:24:57.302]                 }
[08:24:57.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.302]                 "immediateCondition"))) {
[08:24:57.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.302]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.302]                   if (TRUE && !signal) {
[08:24:57.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.302]                     {
[08:24:57.302]                       inherits <- base::inherits
[08:24:57.302]                       invokeRestart <- base::invokeRestart
[08:24:57.302]                       is.null <- base::is.null
[08:24:57.302]                       muffled <- FALSE
[08:24:57.302]                       if (inherits(cond, "message")) {
[08:24:57.302]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.302]                         if (muffled) 
[08:24:57.302]                           invokeRestart("muffleMessage")
[08:24:57.302]                       }
[08:24:57.302]                       else if (inherits(cond, "warning")) {
[08:24:57.302]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.302]                         if (muffled) 
[08:24:57.302]                           invokeRestart("muffleWarning")
[08:24:57.302]                       }
[08:24:57.302]                       else if (inherits(cond, "condition")) {
[08:24:57.302]                         if (!is.null(pattern)) {
[08:24:57.302]                           computeRestarts <- base::computeRestarts
[08:24:57.302]                           grepl <- base::grepl
[08:24:57.302]                           restarts <- computeRestarts(cond)
[08:24:57.302]                           for (restart in restarts) {
[08:24:57.302]                             name <- restart$name
[08:24:57.302]                             if (is.null(name)) 
[08:24:57.302]                               next
[08:24:57.302]                             if (!grepl(pattern, name)) 
[08:24:57.302]                               next
[08:24:57.302]                             invokeRestart(restart)
[08:24:57.302]                             muffled <- TRUE
[08:24:57.302]                             break
[08:24:57.302]                           }
[08:24:57.302]                         }
[08:24:57.302]                       }
[08:24:57.302]                       invisible(muffled)
[08:24:57.302]                     }
[08:24:57.302]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.302]                   }
[08:24:57.302]                 }
[08:24:57.302]                 else {
[08:24:57.302]                   if (TRUE) {
[08:24:57.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.302]                     {
[08:24:57.302]                       inherits <- base::inherits
[08:24:57.302]                       invokeRestart <- base::invokeRestart
[08:24:57.302]                       is.null <- base::is.null
[08:24:57.302]                       muffled <- FALSE
[08:24:57.302]                       if (inherits(cond, "message")) {
[08:24:57.302]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.302]                         if (muffled) 
[08:24:57.302]                           invokeRestart("muffleMessage")
[08:24:57.302]                       }
[08:24:57.302]                       else if (inherits(cond, "warning")) {
[08:24:57.302]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.302]                         if (muffled) 
[08:24:57.302]                           invokeRestart("muffleWarning")
[08:24:57.302]                       }
[08:24:57.302]                       else if (inherits(cond, "condition")) {
[08:24:57.302]                         if (!is.null(pattern)) {
[08:24:57.302]                           computeRestarts <- base::computeRestarts
[08:24:57.302]                           grepl <- base::grepl
[08:24:57.302]                           restarts <- computeRestarts(cond)
[08:24:57.302]                           for (restart in restarts) {
[08:24:57.302]                             name <- restart$name
[08:24:57.302]                             if (is.null(name)) 
[08:24:57.302]                               next
[08:24:57.302]                             if (!grepl(pattern, name)) 
[08:24:57.302]                               next
[08:24:57.302]                             invokeRestart(restart)
[08:24:57.302]                             muffled <- TRUE
[08:24:57.302]                             break
[08:24:57.302]                           }
[08:24:57.302]                         }
[08:24:57.302]                       }
[08:24:57.302]                       invisible(muffled)
[08:24:57.302]                     }
[08:24:57.302]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.302]                   }
[08:24:57.302]                 }
[08:24:57.302]             }
[08:24:57.302]         }))
[08:24:57.302]     }, error = function(ex) {
[08:24:57.302]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.302]                 ...future.rng), started = ...future.startTime, 
[08:24:57.302]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.302]             version = "1.8"), class = "FutureResult")
[08:24:57.302]     }, finally = {
[08:24:57.302]         if (!identical(...future.workdir, getwd())) 
[08:24:57.302]             setwd(...future.workdir)
[08:24:57.302]         {
[08:24:57.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.302]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.302]             }
[08:24:57.302]             base::options(...future.oldOptions)
[08:24:57.302]             if (.Platform$OS.type == "windows") {
[08:24:57.302]                 old_names <- names(...future.oldEnvVars)
[08:24:57.302]                 envs <- base::Sys.getenv()
[08:24:57.302]                 names <- names(envs)
[08:24:57.302]                 common <- intersect(names, old_names)
[08:24:57.302]                 added <- setdiff(names, old_names)
[08:24:57.302]                 removed <- setdiff(old_names, names)
[08:24:57.302]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.302]                   envs[common]]
[08:24:57.302]                 NAMES <- toupper(changed)
[08:24:57.302]                 args <- list()
[08:24:57.302]                 for (kk in seq_along(NAMES)) {
[08:24:57.302]                   name <- changed[[kk]]
[08:24:57.302]                   NAME <- NAMES[[kk]]
[08:24:57.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.302]                     next
[08:24:57.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.302]                 }
[08:24:57.302]                 NAMES <- toupper(added)
[08:24:57.302]                 for (kk in seq_along(NAMES)) {
[08:24:57.302]                   name <- added[[kk]]
[08:24:57.302]                   NAME <- NAMES[[kk]]
[08:24:57.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.302]                     next
[08:24:57.302]                   args[[name]] <- ""
[08:24:57.302]                 }
[08:24:57.302]                 NAMES <- toupper(removed)
[08:24:57.302]                 for (kk in seq_along(NAMES)) {
[08:24:57.302]                   name <- removed[[kk]]
[08:24:57.302]                   NAME <- NAMES[[kk]]
[08:24:57.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.302]                     next
[08:24:57.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.302]                 }
[08:24:57.302]                 if (length(args) > 0) 
[08:24:57.302]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.302]             }
[08:24:57.302]             else {
[08:24:57.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.302]             }
[08:24:57.302]             {
[08:24:57.302]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.302]                   0L) {
[08:24:57.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.302]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.302]                   base::options(opts)
[08:24:57.302]                 }
[08:24:57.302]                 {
[08:24:57.302]                   {
[08:24:57.302]                     NULL
[08:24:57.302]                     RNGkind("Mersenne-Twister")
[08:24:57.302]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.302]                       inherits = FALSE)
[08:24:57.302]                   }
[08:24:57.302]                   options(future.plan = NULL)
[08:24:57.302]                   if (is.na(NA_character_)) 
[08:24:57.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.302]                     .init = FALSE)
[08:24:57.302]                 }
[08:24:57.302]             }
[08:24:57.302]         }
[08:24:57.302]     })
[08:24:57.302]     if (TRUE) {
[08:24:57.302]         base::sink(type = "output", split = FALSE)
[08:24:57.302]         if (TRUE) {
[08:24:57.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.302]         }
[08:24:57.302]         else {
[08:24:57.302]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.302]         }
[08:24:57.302]         base::close(...future.stdout)
[08:24:57.302]         ...future.stdout <- NULL
[08:24:57.302]     }
[08:24:57.302]     ...future.result$conditions <- ...future.conditions
[08:24:57.302]     ...future.result$finished <- base::Sys.time()
[08:24:57.302]     ...future.result
[08:24:57.302] }
[08:24:57.304] assign_globals() ...
[08:24:57.304] List of 5
[08:24:57.304]  $ ...future.FUN            :function (x, ...)  
[08:24:57.304]  $ future.call.arguments    :List of 1
[08:24:57.304]   ..$ singular.ok: logi FALSE
[08:24:57.304]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.304]  $ ...future.elements_ii    :List of 3
[08:24:57.304]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.304]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.304]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.304]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.304]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.304]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.304]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.304]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.304]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.304]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.304]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.304]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.304]  $ ...future.seeds_ii       : NULL
[08:24:57.304]  $ ...future.globals.maxSize: NULL
[08:24:57.304]  - attr(*, "where")=List of 5
[08:24:57.304]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.304]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.304]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.304]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.304]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.304]  - attr(*, "resolved")= logi FALSE
[08:24:57.304]  - attr(*, "total_size")= num 19977
[08:24:57.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.304]  - attr(*, "already-done")= logi TRUE
[08:24:57.316] - reassign environment for ‘...future.FUN’
[08:24:57.316] - copied ‘...future.FUN’ to environment
[08:24:57.316] - copied ‘future.call.arguments’ to environment
[08:24:57.316] - copied ‘...future.elements_ii’ to environment
[08:24:57.316] - copied ‘...future.seeds_ii’ to environment
[08:24:57.316] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.317] assign_globals() ... done
[08:24:57.317] plan(): Setting new future strategy stack:
[08:24:57.317] List of future strategies:
[08:24:57.317] 1. sequential:
[08:24:57.317]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.317]    - tweaked: FALSE
[08:24:57.317]    - call: NULL
[08:24:57.318] plan(): nbrOfWorkers() = 1
[08:24:57.321] plan(): Setting new future strategy stack:
[08:24:57.321] List of future strategies:
[08:24:57.321] 1. sequential:
[08:24:57.321]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.321]    - tweaked: FALSE
[08:24:57.321]    - call: plan(strategy)
[08:24:57.321] plan(): nbrOfWorkers() = 1
[08:24:57.321] SequentialFuture started (and completed)
[08:24:57.322] - Launch lazy future ... done
[08:24:57.322] run() for ‘SequentialFuture’ ... done
[08:24:57.322] Created future:
[08:24:57.322] SequentialFuture:
[08:24:57.322] Label: ‘future_by-1’
[08:24:57.322] Expression:
[08:24:57.322] {
[08:24:57.322]     do.call(function(...) {
[08:24:57.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.322]             on.exit(options(oopts), add = TRUE)
[08:24:57.322]         }
[08:24:57.322]         {
[08:24:57.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.322]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.322]             })
[08:24:57.322]         }
[08:24:57.322]     }, args = future.call.arguments)
[08:24:57.322] }
[08:24:57.322] Lazy evaluation: FALSE
[08:24:57.322] Asynchronous evaluation: FALSE
[08:24:57.322] Local evaluation: TRUE
[08:24:57.322] Environment: R_GlobalEnv
[08:24:57.322] Capture standard output: TRUE
[08:24:57.322] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.322] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.322] Packages: 1 packages (‘stats’)
[08:24:57.322] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.322] Resolved: TRUE
[08:24:57.322] Value: 77.05 KiB of class ‘list’
[08:24:57.322] Early signaling: FALSE
[08:24:57.322] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.322] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.323] Chunk #1 of 1 ... DONE
[08:24:57.323] Launching 1 futures (chunks) ... DONE
[08:24:57.323] Resolving 1 futures (chunks) ...
[08:24:57.324] resolve() on list ...
[08:24:57.324]  recursive: 0
[08:24:57.324]  length: 1
[08:24:57.324] 
[08:24:57.324] resolved() for ‘SequentialFuture’ ...
[08:24:57.324] - state: ‘finished’
[08:24:57.324] - run: TRUE
[08:24:57.324] - result: ‘FutureResult’
[08:24:57.324] resolved() for ‘SequentialFuture’ ... done
[08:24:57.324] Future #1
[08:24:57.325] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.325] - nx: 1
[08:24:57.325] - relay: TRUE
[08:24:57.325] - stdout: TRUE
[08:24:57.325] - signal: TRUE
[08:24:57.325] - resignal: FALSE
[08:24:57.325] - force: TRUE
[08:24:57.325] - relayed: [n=1] FALSE
[08:24:57.325] - queued futures: [n=1] FALSE
[08:24:57.325]  - until=1
[08:24:57.325]  - relaying element #1
[08:24:57.326] - relayed: [n=1] TRUE
[08:24:57.326] - queued futures: [n=1] TRUE
[08:24:57.326] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.326]  length: 0 (resolved future 1)
[08:24:57.326] Relaying remaining futures
[08:24:57.326] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.326] - nx: 1
[08:24:57.326] - relay: TRUE
[08:24:57.326] - stdout: TRUE
[08:24:57.326] - signal: TRUE
[08:24:57.326] - resignal: FALSE
[08:24:57.327] - force: TRUE
[08:24:57.327] - relayed: [n=1] TRUE
[08:24:57.327] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.327] - relayed: [n=1] TRUE
[08:24:57.327] - queued futures: [n=1] TRUE
[08:24:57.327] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.327] resolve() on list ... DONE
[08:24:57.327]  - Number of value chunks collected: 1
[08:24:57.327] Resolving 1 futures (chunks) ... DONE
[08:24:57.327] Reducing values from 1 chunks ...
[08:24:57.328]  - Number of values collected after concatenation: 3
[08:24:57.328]  - Number of values expected: 3
[08:24:57.328] Reducing values from 1 chunks ... DONE
[08:24:57.328] future_lapply() ... DONE
[08:24:57.328] future_by_internal() ... DONE
[08:24:57.334] future_by_internal() ...
[08:24:57.334] future_lapply() ...
[08:24:57.336] Number of chunks: 1
[08:24:57.336] getGlobalsAndPackagesXApply() ...
[08:24:57.336]  - future.globals: TRUE
[08:24:57.336] getGlobalsAndPackages() ...
[08:24:57.336] Searching for globals...
[08:24:57.338] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:57.338] Searching for globals ... DONE
[08:24:57.339] Resolving globals: FALSE
[08:24:57.339] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[08:24:57.339] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[08:24:57.340] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:57.340] - packages: [1] ‘stats’
[08:24:57.340] getGlobalsAndPackages() ... DONE
[08:24:57.340]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:57.340]  - needed namespaces: [n=1] ‘stats’
[08:24:57.340] Finding globals ... DONE
[08:24:57.340]  - use_args: TRUE
[08:24:57.340]  - Getting '...' globals ...
[08:24:57.341] resolve() on list ...
[08:24:57.341]  recursive: 0
[08:24:57.341]  length: 1
[08:24:57.341]  elements: ‘...’
[08:24:57.341]  length: 0 (resolved future 1)
[08:24:57.341] resolve() on list ... DONE
[08:24:57.341]    - '...' content: [n=0] 
[08:24:57.341] List of 1
[08:24:57.341]  $ ...: list()
[08:24:57.341]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.341]  - attr(*, "where")=List of 1
[08:24:57.341]   ..$ ...:<environment: 0x557b265daab8> 
[08:24:57.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.341]  - attr(*, "resolved")= logi TRUE
[08:24:57.341]  - attr(*, "total_size")= num NA
[08:24:57.344]  - Getting '...' globals ... DONE
[08:24:57.344] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[08:24:57.344] List of 4
[08:24:57.344]  $ ...future.FUN:function (x)  
[08:24:57.344]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:57.344]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.344]  $ ...          : list()
[08:24:57.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.344]  - attr(*, "where")=List of 4
[08:24:57.344]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.344]   ..$ breaks       :<environment: R_EmptyEnv> 
[08:24:57.344]   ..$ wool         :<environment: R_EmptyEnv> 
[08:24:57.344]   ..$ ...          :<environment: 0x557b265daab8> 
[08:24:57.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.344]  - attr(*, "resolved")= logi FALSE
[08:24:57.344]  - attr(*, "total_size")= num 18867
[08:24:57.348] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:57.348] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.348] Number of futures (= number of chunks): 1
[08:24:57.349] Launching 1 futures (chunks) ...
[08:24:57.349] Chunk #1 of 1 ...
[08:24:57.349]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.349] getGlobalsAndPackages() ...
[08:24:57.349] Searching for globals...
[08:24:57.349] 
[08:24:57.350] Searching for globals ... DONE
[08:24:57.350] - globals: [0] <none>
[08:24:57.350] getGlobalsAndPackages() ... DONE
[08:24:57.350]    + additional globals found: [n=0] 
[08:24:57.350]    + additional namespaces needed: [n=0] 
[08:24:57.350]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.350]  - seeds: <none>
[08:24:57.350]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.350] getGlobalsAndPackages() ...
[08:24:57.350] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.350] Resolving globals: FALSE
[08:24:57.351] Tweak future expression to call with '...' arguments ...
[08:24:57.351] {
[08:24:57.351]     do.call(function(...) {
[08:24:57.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.351]             on.exit(options(oopts), add = TRUE)
[08:24:57.351]         }
[08:24:57.351]         {
[08:24:57.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.351]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.351]             })
[08:24:57.351]         }
[08:24:57.351]     }, args = future.call.arguments)
[08:24:57.351] }
[08:24:57.351] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.351] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.352] 
[08:24:57.352] getGlobalsAndPackages() ... DONE
[08:24:57.352] run() for ‘Future’ ...
[08:24:57.352] - state: ‘created’
[08:24:57.352] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:57.352] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.353] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.353]   - Field: ‘label’
[08:24:57.353]   - Field: ‘local’
[08:24:57.353]   - Field: ‘owner’
[08:24:57.353]   - Field: ‘envir’
[08:24:57.353]   - Field: ‘packages’
[08:24:57.353]   - Field: ‘gc’
[08:24:57.353]   - Field: ‘conditions’
[08:24:57.353]   - Field: ‘expr’
[08:24:57.353]   - Field: ‘uuid’
[08:24:57.354]   - Field: ‘seed’
[08:24:57.354]   - Field: ‘version’
[08:24:57.354]   - Field: ‘result’
[08:24:57.354]   - Field: ‘asynchronous’
[08:24:57.354]   - Field: ‘calls’
[08:24:57.354]   - Field: ‘globals’
[08:24:57.354]   - Field: ‘stdout’
[08:24:57.354]   - Field: ‘earlySignal’
[08:24:57.354]   - Field: ‘lazy’
[08:24:57.354]   - Field: ‘state’
[08:24:57.354] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.357] - Launch lazy future ...
[08:24:57.357] Packages needed by the future expression (n = 1): ‘stats’
[08:24:57.357] Packages needed by future strategies (n = 0): <none>
[08:24:57.358] {
[08:24:57.358]     {
[08:24:57.358]         {
[08:24:57.358]             ...future.startTime <- base::Sys.time()
[08:24:57.358]             {
[08:24:57.358]                 {
[08:24:57.358]                   {
[08:24:57.358]                     {
[08:24:57.358]                       base::local({
[08:24:57.358]                         has_future <- base::requireNamespace("future", 
[08:24:57.358]                           quietly = TRUE)
[08:24:57.358]                         if (has_future) {
[08:24:57.358]                           ns <- base::getNamespace("future")
[08:24:57.358]                           version <- ns[[".package"]][["version"]]
[08:24:57.358]                           if (is.null(version)) 
[08:24:57.358]                             version <- utils::packageVersion("future")
[08:24:57.358]                         }
[08:24:57.358]                         else {
[08:24:57.358]                           version <- NULL
[08:24:57.358]                         }
[08:24:57.358]                         if (!has_future || version < "1.8.0") {
[08:24:57.358]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.358]                             "", base::R.version$version.string), 
[08:24:57.358]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:57.358]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.358]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.358]                               "release", "version")], collapse = " "), 
[08:24:57.358]                             hostname = base::Sys.info()[["nodename"]])
[08:24:57.358]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.358]                             info)
[08:24:57.358]                           info <- base::paste(info, collapse = "; ")
[08:24:57.358]                           if (!has_future) {
[08:24:57.358]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.358]                               info)
[08:24:57.358]                           }
[08:24:57.358]                           else {
[08:24:57.358]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.358]                               info, version)
[08:24:57.358]                           }
[08:24:57.358]                           base::stop(msg)
[08:24:57.358]                         }
[08:24:57.358]                       })
[08:24:57.358]                     }
[08:24:57.358]                     base::local({
[08:24:57.358]                       for (pkg in "stats") {
[08:24:57.358]                         base::loadNamespace(pkg)
[08:24:57.358]                         base::library(pkg, character.only = TRUE)
[08:24:57.358]                       }
[08:24:57.358]                     })
[08:24:57.358]                   }
[08:24:57.358]                   ...future.strategy.old <- future::plan("list")
[08:24:57.358]                   options(future.plan = NULL)
[08:24:57.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.358]                 }
[08:24:57.358]                 ...future.workdir <- getwd()
[08:24:57.358]             }
[08:24:57.358]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.358]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.358]         }
[08:24:57.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.358]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.358]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.358]             base::names(...future.oldOptions))
[08:24:57.358]     }
[08:24:57.358]     if (FALSE) {
[08:24:57.358]     }
[08:24:57.358]     else {
[08:24:57.358]         if (TRUE) {
[08:24:57.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.358]                 open = "w")
[08:24:57.358]         }
[08:24:57.358]         else {
[08:24:57.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.358]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.358]         }
[08:24:57.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.358]             base::sink(type = "output", split = FALSE)
[08:24:57.358]             base::close(...future.stdout)
[08:24:57.358]         }, add = TRUE)
[08:24:57.358]     }
[08:24:57.358]     ...future.frame <- base::sys.nframe()
[08:24:57.358]     ...future.conditions <- base::list()
[08:24:57.358]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.358]     if (FALSE) {
[08:24:57.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.358]     }
[08:24:57.358]     ...future.result <- base::tryCatch({
[08:24:57.358]         base::withCallingHandlers({
[08:24:57.358]             ...future.value <- base::withVisible(base::local({
[08:24:57.358]                 do.call(function(...) {
[08:24:57.358]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.358]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.358]                     ...future.globals.maxSize)) {
[08:24:57.358]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.358]                     on.exit(options(oopts), add = TRUE)
[08:24:57.358]                   }
[08:24:57.358]                   {
[08:24:57.358]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.358]                       FUN = function(jj) {
[08:24:57.358]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.358]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.358]                       })
[08:24:57.358]                   }
[08:24:57.358]                 }, args = future.call.arguments)
[08:24:57.358]             }))
[08:24:57.358]             future::FutureResult(value = ...future.value$value, 
[08:24:57.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.358]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.358]                     ...future.globalenv.names))
[08:24:57.358]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.358]         }, condition = base::local({
[08:24:57.358]             c <- base::c
[08:24:57.358]             inherits <- base::inherits
[08:24:57.358]             invokeRestart <- base::invokeRestart
[08:24:57.358]             length <- base::length
[08:24:57.358]             list <- base::list
[08:24:57.358]             seq.int <- base::seq.int
[08:24:57.358]             signalCondition <- base::signalCondition
[08:24:57.358]             sys.calls <- base::sys.calls
[08:24:57.358]             `[[` <- base::`[[`
[08:24:57.358]             `+` <- base::`+`
[08:24:57.358]             `<<-` <- base::`<<-`
[08:24:57.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.358]                   3L)]
[08:24:57.358]             }
[08:24:57.358]             function(cond) {
[08:24:57.358]                 is_error <- inherits(cond, "error")
[08:24:57.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.358]                   NULL)
[08:24:57.358]                 if (is_error) {
[08:24:57.358]                   sessionInformation <- function() {
[08:24:57.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.358]                       search = base::search(), system = base::Sys.info())
[08:24:57.358]                   }
[08:24:57.358]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.358]                     cond$call), session = sessionInformation(), 
[08:24:57.358]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.358]                   signalCondition(cond)
[08:24:57.358]                 }
[08:24:57.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.358]                 "immediateCondition"))) {
[08:24:57.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.358]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.358]                   if (TRUE && !signal) {
[08:24:57.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.358]                     {
[08:24:57.358]                       inherits <- base::inherits
[08:24:57.358]                       invokeRestart <- base::invokeRestart
[08:24:57.358]                       is.null <- base::is.null
[08:24:57.358]                       muffled <- FALSE
[08:24:57.358]                       if (inherits(cond, "message")) {
[08:24:57.358]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.358]                         if (muffled) 
[08:24:57.358]                           invokeRestart("muffleMessage")
[08:24:57.358]                       }
[08:24:57.358]                       else if (inherits(cond, "warning")) {
[08:24:57.358]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.358]                         if (muffled) 
[08:24:57.358]                           invokeRestart("muffleWarning")
[08:24:57.358]                       }
[08:24:57.358]                       else if (inherits(cond, "condition")) {
[08:24:57.358]                         if (!is.null(pattern)) {
[08:24:57.358]                           computeRestarts <- base::computeRestarts
[08:24:57.358]                           grepl <- base::grepl
[08:24:57.358]                           restarts <- computeRestarts(cond)
[08:24:57.358]                           for (restart in restarts) {
[08:24:57.358]                             name <- restart$name
[08:24:57.358]                             if (is.null(name)) 
[08:24:57.358]                               next
[08:24:57.358]                             if (!grepl(pattern, name)) 
[08:24:57.358]                               next
[08:24:57.358]                             invokeRestart(restart)
[08:24:57.358]                             muffled <- TRUE
[08:24:57.358]                             break
[08:24:57.358]                           }
[08:24:57.358]                         }
[08:24:57.358]                       }
[08:24:57.358]                       invisible(muffled)
[08:24:57.358]                     }
[08:24:57.358]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.358]                   }
[08:24:57.358]                 }
[08:24:57.358]                 else {
[08:24:57.358]                   if (TRUE) {
[08:24:57.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.358]                     {
[08:24:57.358]                       inherits <- base::inherits
[08:24:57.358]                       invokeRestart <- base::invokeRestart
[08:24:57.358]                       is.null <- base::is.null
[08:24:57.358]                       muffled <- FALSE
[08:24:57.358]                       if (inherits(cond, "message")) {
[08:24:57.358]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.358]                         if (muffled) 
[08:24:57.358]                           invokeRestart("muffleMessage")
[08:24:57.358]                       }
[08:24:57.358]                       else if (inherits(cond, "warning")) {
[08:24:57.358]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.358]                         if (muffled) 
[08:24:57.358]                           invokeRestart("muffleWarning")
[08:24:57.358]                       }
[08:24:57.358]                       else if (inherits(cond, "condition")) {
[08:24:57.358]                         if (!is.null(pattern)) {
[08:24:57.358]                           computeRestarts <- base::computeRestarts
[08:24:57.358]                           grepl <- base::grepl
[08:24:57.358]                           restarts <- computeRestarts(cond)
[08:24:57.358]                           for (restart in restarts) {
[08:24:57.358]                             name <- restart$name
[08:24:57.358]                             if (is.null(name)) 
[08:24:57.358]                               next
[08:24:57.358]                             if (!grepl(pattern, name)) 
[08:24:57.358]                               next
[08:24:57.358]                             invokeRestart(restart)
[08:24:57.358]                             muffled <- TRUE
[08:24:57.358]                             break
[08:24:57.358]                           }
[08:24:57.358]                         }
[08:24:57.358]                       }
[08:24:57.358]                       invisible(muffled)
[08:24:57.358]                     }
[08:24:57.358]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.358]                   }
[08:24:57.358]                 }
[08:24:57.358]             }
[08:24:57.358]         }))
[08:24:57.358]     }, error = function(ex) {
[08:24:57.358]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.358]                 ...future.rng), started = ...future.startTime, 
[08:24:57.358]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.358]             version = "1.8"), class = "FutureResult")
[08:24:57.358]     }, finally = {
[08:24:57.358]         if (!identical(...future.workdir, getwd())) 
[08:24:57.358]             setwd(...future.workdir)
[08:24:57.358]         {
[08:24:57.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.358]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.358]             }
[08:24:57.358]             base::options(...future.oldOptions)
[08:24:57.358]             if (.Platform$OS.type == "windows") {
[08:24:57.358]                 old_names <- names(...future.oldEnvVars)
[08:24:57.358]                 envs <- base::Sys.getenv()
[08:24:57.358]                 names <- names(envs)
[08:24:57.358]                 common <- intersect(names, old_names)
[08:24:57.358]                 added <- setdiff(names, old_names)
[08:24:57.358]                 removed <- setdiff(old_names, names)
[08:24:57.358]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.358]                   envs[common]]
[08:24:57.358]                 NAMES <- toupper(changed)
[08:24:57.358]                 args <- list()
[08:24:57.358]                 for (kk in seq_along(NAMES)) {
[08:24:57.358]                   name <- changed[[kk]]
[08:24:57.358]                   NAME <- NAMES[[kk]]
[08:24:57.358]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.358]                     next
[08:24:57.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.358]                 }
[08:24:57.358]                 NAMES <- toupper(added)
[08:24:57.358]                 for (kk in seq_along(NAMES)) {
[08:24:57.358]                   name <- added[[kk]]
[08:24:57.358]                   NAME <- NAMES[[kk]]
[08:24:57.358]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.358]                     next
[08:24:57.358]                   args[[name]] <- ""
[08:24:57.358]                 }
[08:24:57.358]                 NAMES <- toupper(removed)
[08:24:57.358]                 for (kk in seq_along(NAMES)) {
[08:24:57.358]                   name <- removed[[kk]]
[08:24:57.358]                   NAME <- NAMES[[kk]]
[08:24:57.358]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.358]                     next
[08:24:57.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.358]                 }
[08:24:57.358]                 if (length(args) > 0) 
[08:24:57.358]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.358]             }
[08:24:57.358]             else {
[08:24:57.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.358]             }
[08:24:57.358]             {
[08:24:57.358]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.358]                   0L) {
[08:24:57.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.358]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.358]                   base::options(opts)
[08:24:57.358]                 }
[08:24:57.358]                 {
[08:24:57.358]                   {
[08:24:57.358]                     NULL
[08:24:57.358]                     RNGkind("Mersenne-Twister")
[08:24:57.358]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.358]                       inherits = FALSE)
[08:24:57.358]                   }
[08:24:57.358]                   options(future.plan = NULL)
[08:24:57.358]                   if (is.na(NA_character_)) 
[08:24:57.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.358]                     .init = FALSE)
[08:24:57.358]                 }
[08:24:57.358]             }
[08:24:57.358]         }
[08:24:57.358]     })
[08:24:57.358]     if (TRUE) {
[08:24:57.358]         base::sink(type = "output", split = FALSE)
[08:24:57.358]         if (TRUE) {
[08:24:57.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.358]         }
[08:24:57.358]         else {
[08:24:57.358]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.358]         }
[08:24:57.358]         base::close(...future.stdout)
[08:24:57.358]         ...future.stdout <- NULL
[08:24:57.358]     }
[08:24:57.358]     ...future.result$conditions <- ...future.conditions
[08:24:57.358]     ...future.result$finished <- base::Sys.time()
[08:24:57.358]     ...future.result
[08:24:57.358] }
[08:24:57.360] assign_globals() ...
[08:24:57.360] List of 7
[08:24:57.360]  $ ...future.FUN            :function (x)  
[08:24:57.360]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:57.360]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.360]  $ future.call.arguments    : list()
[08:24:57.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.360]  $ ...future.elements_ii    :List of 3
[08:24:57.360]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.360]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.360]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.360]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.360]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.360]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.360]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.360]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.360]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.360]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.360]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.360]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.360]  $ ...future.seeds_ii       : NULL
[08:24:57.360]  $ ...future.globals.maxSize: NULL
[08:24:57.360]  - attr(*, "where")=List of 7
[08:24:57.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.360]   ..$ breaks                   :<environment: R_EmptyEnv> 
[08:24:57.360]   ..$ wool                     :<environment: R_EmptyEnv> 
[08:24:57.360]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.360]  - attr(*, "resolved")= logi FALSE
[08:24:57.360]  - attr(*, "total_size")= num 18867
[08:24:57.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.360]  - attr(*, "already-done")= logi TRUE
[08:24:57.370] - reassign environment for ‘...future.FUN’
[08:24:57.370] - copied ‘...future.FUN’ to environment
[08:24:57.371] - copied ‘breaks’ to environment
[08:24:57.371] - copied ‘wool’ to environment
[08:24:57.371] - copied ‘future.call.arguments’ to environment
[08:24:57.371] - copied ‘...future.elements_ii’ to environment
[08:24:57.371] - copied ‘...future.seeds_ii’ to environment
[08:24:57.371] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.371] assign_globals() ... done
[08:24:57.372] plan(): Setting new future strategy stack:
[08:24:57.372] List of future strategies:
[08:24:57.372] 1. sequential:
[08:24:57.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.372]    - tweaked: FALSE
[08:24:57.372]    - call: NULL
[08:24:57.372] plan(): nbrOfWorkers() = 1
[08:24:57.375] plan(): Setting new future strategy stack:
[08:24:57.375] List of future strategies:
[08:24:57.375] 1. sequential:
[08:24:57.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.375]    - tweaked: FALSE
[08:24:57.375]    - call: plan(strategy)
[08:24:57.376] plan(): nbrOfWorkers() = 1
[08:24:57.376] SequentialFuture started (and completed)
[08:24:57.376] - Launch lazy future ... done
[08:24:57.376] run() for ‘SequentialFuture’ ... done
[08:24:57.376] Created future:
[08:24:57.376] SequentialFuture:
[08:24:57.376] Label: ‘future_by-1’
[08:24:57.376] Expression:
[08:24:57.376] {
[08:24:57.376]     do.call(function(...) {
[08:24:57.376]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.376]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.376]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.376]             on.exit(options(oopts), add = TRUE)
[08:24:57.376]         }
[08:24:57.376]         {
[08:24:57.376]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.376]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.376]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.376]             })
[08:24:57.376]         }
[08:24:57.376]     }, args = future.call.arguments)
[08:24:57.376] }
[08:24:57.376] Lazy evaluation: FALSE
[08:24:57.376] Asynchronous evaluation: FALSE
[08:24:57.376] Local evaluation: TRUE
[08:24:57.376] Environment: 0x557b25c87190
[08:24:57.376] Capture standard output: TRUE
[08:24:57.376] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.376] Globals: 7 objects totaling 4.20 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, ...)
[08:24:57.376] Packages: 1 packages (‘stats’)
[08:24:57.376] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.376] Resolved: TRUE
[08:24:57.376] Value: 78.42 KiB of class ‘list’
[08:24:57.376] Early signaling: FALSE
[08:24:57.376] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.376] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.378] Chunk #1 of 1 ... DONE
[08:24:57.378] Launching 1 futures (chunks) ... DONE
[08:24:57.378] Resolving 1 futures (chunks) ...
[08:24:57.378] resolve() on list ...
[08:24:57.378]  recursive: 0
[08:24:57.378]  length: 1
[08:24:57.378] 
[08:24:57.378] resolved() for ‘SequentialFuture’ ...
[08:24:57.379] - state: ‘finished’
[08:24:57.379] - run: TRUE
[08:24:57.379] - result: ‘FutureResult’
[08:24:57.379] resolved() for ‘SequentialFuture’ ... done
[08:24:57.379] Future #1
[08:24:57.379] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.379] - nx: 1
[08:24:57.381] - relay: TRUE
[08:24:57.381] - stdout: TRUE
[08:24:57.381] - signal: TRUE
[08:24:57.382] - resignal: FALSE
[08:24:57.382] - force: TRUE
[08:24:57.382] - relayed: [n=1] FALSE
[08:24:57.382] - queued futures: [n=1] FALSE
[08:24:57.382]  - until=1
[08:24:57.382]  - relaying element #1
[08:24:57.382] - relayed: [n=1] TRUE
[08:24:57.382] - queued futures: [n=1] TRUE
[08:24:57.383] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.383]  length: 0 (resolved future 1)
[08:24:57.383] Relaying remaining futures
[08:24:57.383] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.383] - nx: 1
[08:24:57.383] - relay: TRUE
[08:24:57.383] - stdout: TRUE
[08:24:57.383] - signal: TRUE
[08:24:57.383] - resignal: FALSE
[08:24:57.383] - force: TRUE
[08:24:57.384] - relayed: [n=1] TRUE
[08:24:57.384] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.384] - relayed: [n=1] TRUE
[08:24:57.384] - queued futures: [n=1] TRUE
[08:24:57.384] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.384] resolve() on list ... DONE
[08:24:57.384]  - Number of value chunks collected: 1
[08:24:57.384] Resolving 1 futures (chunks) ... DONE
[08:24:57.385] Reducing values from 1 chunks ...
[08:24:57.385]  - Number of values collected after concatenation: 3
[08:24:57.385]  - Number of values expected: 3
[08:24:57.385] Reducing values from 1 chunks ... DONE
[08:24:57.385] future_lapply() ... DONE
[08:24:57.385] future_by_internal() ... DONE
[08:24:57.386] future_by_internal() ...
[08:24:57.386] future_lapply() ...
[08:24:57.387] Number of chunks: 1
[08:24:57.387] getGlobalsAndPackagesXApply() ...
[08:24:57.387]  - future.globals: TRUE
[08:24:57.387] getGlobalsAndPackages() ...
[08:24:57.387] Searching for globals...
[08:24:57.388] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:57.388] Searching for globals ... DONE
[08:24:57.388] Resolving globals: FALSE
[08:24:57.389] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:57.389] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:57.389] - globals: [1] ‘FUN’
[08:24:57.389] 
[08:24:57.389] getGlobalsAndPackages() ... DONE
[08:24:57.389]  - globals found/used: [n=1] ‘FUN’
[08:24:57.390]  - needed namespaces: [n=0] 
[08:24:57.390] Finding globals ... DONE
[08:24:57.390]  - use_args: TRUE
[08:24:57.390]  - Getting '...' globals ...
[08:24:57.390] resolve() on list ...
[08:24:57.390]  recursive: 0
[08:24:57.390]  length: 1
[08:24:57.390]  elements: ‘...’
[08:24:57.391]  length: 0 (resolved future 1)
[08:24:57.391] resolve() on list ... DONE
[08:24:57.391]    - '...' content: [n=0] 
[08:24:57.391] List of 1
[08:24:57.391]  $ ...: list()
[08:24:57.391]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.391]  - attr(*, "where")=List of 1
[08:24:57.391]   ..$ ...:<environment: 0x557b27469cf0> 
[08:24:57.391]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.391]  - attr(*, "resolved")= logi TRUE
[08:24:57.391]  - attr(*, "total_size")= num NA
[08:24:57.393]  - Getting '...' globals ... DONE
[08:24:57.393] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.394] List of 2
[08:24:57.394]  $ ...future.FUN:function (object, ...)  
[08:24:57.394]  $ ...          : list()
[08:24:57.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.394]  - attr(*, "where")=List of 2
[08:24:57.394]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.394]   ..$ ...          :<environment: 0x557b27469cf0> 
[08:24:57.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.394]  - attr(*, "resolved")= logi FALSE
[08:24:57.394]  - attr(*, "total_size")= num 19278
[08:24:57.396] Packages to be attached in all futures: [n=0] 
[08:24:57.396] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.396] Number of futures (= number of chunks): 1
[08:24:57.397] Launching 1 futures (chunks) ...
[08:24:57.397] Chunk #1 of 1 ...
[08:24:57.397]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.397] getGlobalsAndPackages() ...
[08:24:57.397] Searching for globals...
[08:24:57.397] 
[08:24:57.398] Searching for globals ... DONE
[08:24:57.398] - globals: [0] <none>
[08:24:57.398] getGlobalsAndPackages() ... DONE
[08:24:57.398]    + additional globals found: [n=0] 
[08:24:57.398]    + additional namespaces needed: [n=0] 
[08:24:57.398]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.398]  - seeds: <none>
[08:24:57.398]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.398] getGlobalsAndPackages() ...
[08:24:57.398] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.398] Resolving globals: FALSE
[08:24:57.399] Tweak future expression to call with '...' arguments ...
[08:24:57.399] {
[08:24:57.399]     do.call(function(...) {
[08:24:57.399]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.399]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.399]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.399]             on.exit(options(oopts), add = TRUE)
[08:24:57.399]         }
[08:24:57.399]         {
[08:24:57.399]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.399]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.399]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.399]             })
[08:24:57.399]         }
[08:24:57.399]     }, args = future.call.arguments)
[08:24:57.399] }
[08:24:57.399] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.399] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.399] 
[08:24:57.399] getGlobalsAndPackages() ... DONE
[08:24:57.400] run() for ‘Future’ ...
[08:24:57.400] - state: ‘created’
[08:24:57.400] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:57.400] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.401]   - Field: ‘label’
[08:24:57.401]   - Field: ‘local’
[08:24:57.401]   - Field: ‘owner’
[08:24:57.401]   - Field: ‘envir’
[08:24:57.401]   - Field: ‘packages’
[08:24:57.401]   - Field: ‘gc’
[08:24:57.401]   - Field: ‘conditions’
[08:24:57.401]   - Field: ‘expr’
[08:24:57.403]   - Field: ‘uuid’
[08:24:57.403]   - Field: ‘seed’
[08:24:57.403]   - Field: ‘version’
[08:24:57.403]   - Field: ‘result’
[08:24:57.404]   - Field: ‘asynchronous’
[08:24:57.404]   - Field: ‘calls’
[08:24:57.404]   - Field: ‘globals’
[08:24:57.404]   - Field: ‘stdout’
[08:24:57.404]   - Field: ‘earlySignal’
[08:24:57.404]   - Field: ‘lazy’
[08:24:57.404]   - Field: ‘state’
[08:24:57.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.404] - Launch lazy future ...
[08:24:57.405] Packages needed by the future expression (n = 0): <none>
[08:24:57.405] Packages needed by future strategies (n = 0): <none>
[08:24:57.405] {
[08:24:57.405]     {
[08:24:57.405]         {
[08:24:57.405]             ...future.startTime <- base::Sys.time()
[08:24:57.405]             {
[08:24:57.405]                 {
[08:24:57.405]                   {
[08:24:57.405]                     base::local({
[08:24:57.405]                       has_future <- base::requireNamespace("future", 
[08:24:57.405]                         quietly = TRUE)
[08:24:57.405]                       if (has_future) {
[08:24:57.405]                         ns <- base::getNamespace("future")
[08:24:57.405]                         version <- ns[[".package"]][["version"]]
[08:24:57.405]                         if (is.null(version)) 
[08:24:57.405]                           version <- utils::packageVersion("future")
[08:24:57.405]                       }
[08:24:57.405]                       else {
[08:24:57.405]                         version <- NULL
[08:24:57.405]                       }
[08:24:57.405]                       if (!has_future || version < "1.8.0") {
[08:24:57.405]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.405]                           "", base::R.version$version.string), 
[08:24:57.405]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:57.405]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.405]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.405]                             "release", "version")], collapse = " "), 
[08:24:57.405]                           hostname = base::Sys.info()[["nodename"]])
[08:24:57.405]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.405]                           info)
[08:24:57.405]                         info <- base::paste(info, collapse = "; ")
[08:24:57.405]                         if (!has_future) {
[08:24:57.405]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.405]                             info)
[08:24:57.405]                         }
[08:24:57.405]                         else {
[08:24:57.405]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.405]                             info, version)
[08:24:57.405]                         }
[08:24:57.405]                         base::stop(msg)
[08:24:57.405]                       }
[08:24:57.405]                     })
[08:24:57.405]                   }
[08:24:57.405]                   ...future.strategy.old <- future::plan("list")
[08:24:57.405]                   options(future.plan = NULL)
[08:24:57.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.405]                 }
[08:24:57.405]                 ...future.workdir <- getwd()
[08:24:57.405]             }
[08:24:57.405]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.405]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.405]         }
[08:24:57.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.405]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.405]             base::names(...future.oldOptions))
[08:24:57.405]     }
[08:24:57.405]     if (FALSE) {
[08:24:57.405]     }
[08:24:57.405]     else {
[08:24:57.405]         if (TRUE) {
[08:24:57.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.405]                 open = "w")
[08:24:57.405]         }
[08:24:57.405]         else {
[08:24:57.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.405]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.405]         }
[08:24:57.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.405]             base::sink(type = "output", split = FALSE)
[08:24:57.405]             base::close(...future.stdout)
[08:24:57.405]         }, add = TRUE)
[08:24:57.405]     }
[08:24:57.405]     ...future.frame <- base::sys.nframe()
[08:24:57.405]     ...future.conditions <- base::list()
[08:24:57.405]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.405]     if (FALSE) {
[08:24:57.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.405]     }
[08:24:57.405]     ...future.result <- base::tryCatch({
[08:24:57.405]         base::withCallingHandlers({
[08:24:57.405]             ...future.value <- base::withVisible(base::local({
[08:24:57.405]                 do.call(function(...) {
[08:24:57.405]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.405]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.405]                     ...future.globals.maxSize)) {
[08:24:57.405]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.405]                     on.exit(options(oopts), add = TRUE)
[08:24:57.405]                   }
[08:24:57.405]                   {
[08:24:57.405]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.405]                       FUN = function(jj) {
[08:24:57.405]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.405]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.405]                       })
[08:24:57.405]                   }
[08:24:57.405]                 }, args = future.call.arguments)
[08:24:57.405]             }))
[08:24:57.405]             future::FutureResult(value = ...future.value$value, 
[08:24:57.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.405]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.405]                     ...future.globalenv.names))
[08:24:57.405]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.405]         }, condition = base::local({
[08:24:57.405]             c <- base::c
[08:24:57.405]             inherits <- base::inherits
[08:24:57.405]             invokeRestart <- base::invokeRestart
[08:24:57.405]             length <- base::length
[08:24:57.405]             list <- base::list
[08:24:57.405]             seq.int <- base::seq.int
[08:24:57.405]             signalCondition <- base::signalCondition
[08:24:57.405]             sys.calls <- base::sys.calls
[08:24:57.405]             `[[` <- base::`[[`
[08:24:57.405]             `+` <- base::`+`
[08:24:57.405]             `<<-` <- base::`<<-`
[08:24:57.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.405]                   3L)]
[08:24:57.405]             }
[08:24:57.405]             function(cond) {
[08:24:57.405]                 is_error <- inherits(cond, "error")
[08:24:57.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.405]                   NULL)
[08:24:57.405]                 if (is_error) {
[08:24:57.405]                   sessionInformation <- function() {
[08:24:57.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.405]                       search = base::search(), system = base::Sys.info())
[08:24:57.405]                   }
[08:24:57.405]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.405]                     cond$call), session = sessionInformation(), 
[08:24:57.405]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.405]                   signalCondition(cond)
[08:24:57.405]                 }
[08:24:57.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.405]                 "immediateCondition"))) {
[08:24:57.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.405]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.405]                   if (TRUE && !signal) {
[08:24:57.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.405]                     {
[08:24:57.405]                       inherits <- base::inherits
[08:24:57.405]                       invokeRestart <- base::invokeRestart
[08:24:57.405]                       is.null <- base::is.null
[08:24:57.405]                       muffled <- FALSE
[08:24:57.405]                       if (inherits(cond, "message")) {
[08:24:57.405]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.405]                         if (muffled) 
[08:24:57.405]                           invokeRestart("muffleMessage")
[08:24:57.405]                       }
[08:24:57.405]                       else if (inherits(cond, "warning")) {
[08:24:57.405]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.405]                         if (muffled) 
[08:24:57.405]                           invokeRestart("muffleWarning")
[08:24:57.405]                       }
[08:24:57.405]                       else if (inherits(cond, "condition")) {
[08:24:57.405]                         if (!is.null(pattern)) {
[08:24:57.405]                           computeRestarts <- base::computeRestarts
[08:24:57.405]                           grepl <- base::grepl
[08:24:57.405]                           restarts <- computeRestarts(cond)
[08:24:57.405]                           for (restart in restarts) {
[08:24:57.405]                             name <- restart$name
[08:24:57.405]                             if (is.null(name)) 
[08:24:57.405]                               next
[08:24:57.405]                             if (!grepl(pattern, name)) 
[08:24:57.405]                               next
[08:24:57.405]                             invokeRestart(restart)
[08:24:57.405]                             muffled <- TRUE
[08:24:57.405]                             break
[08:24:57.405]                           }
[08:24:57.405]                         }
[08:24:57.405]                       }
[08:24:57.405]                       invisible(muffled)
[08:24:57.405]                     }
[08:24:57.405]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.405]                   }
[08:24:57.405]                 }
[08:24:57.405]                 else {
[08:24:57.405]                   if (TRUE) {
[08:24:57.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.405]                     {
[08:24:57.405]                       inherits <- base::inherits
[08:24:57.405]                       invokeRestart <- base::invokeRestart
[08:24:57.405]                       is.null <- base::is.null
[08:24:57.405]                       muffled <- FALSE
[08:24:57.405]                       if (inherits(cond, "message")) {
[08:24:57.405]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.405]                         if (muffled) 
[08:24:57.405]                           invokeRestart("muffleMessage")
[08:24:57.405]                       }
[08:24:57.405]                       else if (inherits(cond, "warning")) {
[08:24:57.405]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.405]                         if (muffled) 
[08:24:57.405]                           invokeRestart("muffleWarning")
[08:24:57.405]                       }
[08:24:57.405]                       else if (inherits(cond, "condition")) {
[08:24:57.405]                         if (!is.null(pattern)) {
[08:24:57.405]                           computeRestarts <- base::computeRestarts
[08:24:57.405]                           grepl <- base::grepl
[08:24:57.405]                           restarts <- computeRestarts(cond)
[08:24:57.405]                           for (restart in restarts) {
[08:24:57.405]                             name <- restart$name
[08:24:57.405]                             if (is.null(name)) 
[08:24:57.405]                               next
[08:24:57.405]                             if (!grepl(pattern, name)) 
[08:24:57.405]                               next
[08:24:57.405]                             invokeRestart(restart)
[08:24:57.405]                             muffled <- TRUE
[08:24:57.405]                             break
[08:24:57.405]                           }
[08:24:57.405]                         }
[08:24:57.405]                       }
[08:24:57.405]                       invisible(muffled)
[08:24:57.405]                     }
[08:24:57.405]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.405]                   }
[08:24:57.405]                 }
[08:24:57.405]             }
[08:24:57.405]         }))
[08:24:57.405]     }, error = function(ex) {
[08:24:57.405]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.405]                 ...future.rng), started = ...future.startTime, 
[08:24:57.405]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.405]             version = "1.8"), class = "FutureResult")
[08:24:57.405]     }, finally = {
[08:24:57.405]         if (!identical(...future.workdir, getwd())) 
[08:24:57.405]             setwd(...future.workdir)
[08:24:57.405]         {
[08:24:57.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.405]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.405]             }
[08:24:57.405]             base::options(...future.oldOptions)
[08:24:57.405]             if (.Platform$OS.type == "windows") {
[08:24:57.405]                 old_names <- names(...future.oldEnvVars)
[08:24:57.405]                 envs <- base::Sys.getenv()
[08:24:57.405]                 names <- names(envs)
[08:24:57.405]                 common <- intersect(names, old_names)
[08:24:57.405]                 added <- setdiff(names, old_names)
[08:24:57.405]                 removed <- setdiff(old_names, names)
[08:24:57.405]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.405]                   envs[common]]
[08:24:57.405]                 NAMES <- toupper(changed)
[08:24:57.405]                 args <- list()
[08:24:57.405]                 for (kk in seq_along(NAMES)) {
[08:24:57.405]                   name <- changed[[kk]]
[08:24:57.405]                   NAME <- NAMES[[kk]]
[08:24:57.405]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.405]                     next
[08:24:57.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.405]                 }
[08:24:57.405]                 NAMES <- toupper(added)
[08:24:57.405]                 for (kk in seq_along(NAMES)) {
[08:24:57.405]                   name <- added[[kk]]
[08:24:57.405]                   NAME <- NAMES[[kk]]
[08:24:57.405]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.405]                     next
[08:24:57.405]                   args[[name]] <- ""
[08:24:57.405]                 }
[08:24:57.405]                 NAMES <- toupper(removed)
[08:24:57.405]                 for (kk in seq_along(NAMES)) {
[08:24:57.405]                   name <- removed[[kk]]
[08:24:57.405]                   NAME <- NAMES[[kk]]
[08:24:57.405]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.405]                     next
[08:24:57.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.405]                 }
[08:24:57.405]                 if (length(args) > 0) 
[08:24:57.405]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.405]             }
[08:24:57.405]             else {
[08:24:57.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.405]             }
[08:24:57.405]             {
[08:24:57.405]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.405]                   0L) {
[08:24:57.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.405]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.405]                   base::options(opts)
[08:24:57.405]                 }
[08:24:57.405]                 {
[08:24:57.405]                   {
[08:24:57.405]                     NULL
[08:24:57.405]                     RNGkind("Mersenne-Twister")
[08:24:57.405]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.405]                       inherits = FALSE)
[08:24:57.405]                   }
[08:24:57.405]                   options(future.plan = NULL)
[08:24:57.405]                   if (is.na(NA_character_)) 
[08:24:57.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.405]                     .init = FALSE)
[08:24:57.405]                 }
[08:24:57.405]             }
[08:24:57.405]         }
[08:24:57.405]     })
[08:24:57.405]     if (TRUE) {
[08:24:57.405]         base::sink(type = "output", split = FALSE)
[08:24:57.405]         if (TRUE) {
[08:24:57.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.405]         }
[08:24:57.405]         else {
[08:24:57.405]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.405]         }
[08:24:57.405]         base::close(...future.stdout)
[08:24:57.405]         ...future.stdout <- NULL
[08:24:57.405]     }
[08:24:57.405]     ...future.result$conditions <- ...future.conditions
[08:24:57.405]     ...future.result$finished <- base::Sys.time()
[08:24:57.405]     ...future.result
[08:24:57.405] }
[08:24:57.407] assign_globals() ...
[08:24:57.407] List of 5
[08:24:57.407]  $ ...future.FUN            :function (object, ...)  
[08:24:57.407]  $ future.call.arguments    : list()
[08:24:57.407]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.407]  $ ...future.elements_ii    :List of 3
[08:24:57.407]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.407]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.407]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.407]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.407]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.407]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.407]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.407]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.407]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.407]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.407]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.407]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.407]  $ ...future.seeds_ii       : NULL
[08:24:57.407]  $ ...future.globals.maxSize: NULL
[08:24:57.407]  - attr(*, "where")=List of 5
[08:24:57.407]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.407]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.407]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.407]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.407]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.407]  - attr(*, "resolved")= logi FALSE
[08:24:57.407]  - attr(*, "total_size")= num 19278
[08:24:57.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.407]  - attr(*, "already-done")= logi TRUE
[08:24:57.416] - copied ‘...future.FUN’ to environment
[08:24:57.416] - copied ‘future.call.arguments’ to environment
[08:24:57.416] - copied ‘...future.elements_ii’ to environment
[08:24:57.416] - copied ‘...future.seeds_ii’ to environment
[08:24:57.416] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.417] assign_globals() ... done
[08:24:57.417] plan(): Setting new future strategy stack:
[08:24:57.417] List of future strategies:
[08:24:57.417] 1. sequential:
[08:24:57.417]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.417]    - tweaked: FALSE
[08:24:57.417]    - call: NULL
[08:24:57.417] plan(): nbrOfWorkers() = 1
[08:24:57.420] plan(): Setting new future strategy stack:
[08:24:57.420] List of future strategies:
[08:24:57.420] 1. sequential:
[08:24:57.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.420]    - tweaked: FALSE
[08:24:57.420]    - call: plan(strategy)
[08:24:57.420] plan(): nbrOfWorkers() = 1
[08:24:57.420] SequentialFuture started (and completed)
[08:24:57.421] - Launch lazy future ... done
[08:24:57.421] run() for ‘SequentialFuture’ ... done
[08:24:57.421] Created future:
[08:24:57.421] SequentialFuture:
[08:24:57.421] Label: ‘future_by-1’
[08:24:57.421] Expression:
[08:24:57.421] {
[08:24:57.421]     do.call(function(...) {
[08:24:57.421]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.421]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.421]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.421]             on.exit(options(oopts), add = TRUE)
[08:24:57.421]         }
[08:24:57.421]         {
[08:24:57.421]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.421]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.421]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.421]             })
[08:24:57.421]         }
[08:24:57.421]     }, args = future.call.arguments)
[08:24:57.421] }
[08:24:57.421] Lazy evaluation: FALSE
[08:24:57.421] Asynchronous evaluation: FALSE
[08:24:57.421] Local evaluation: TRUE
[08:24:57.421] Environment: 0x557b25d47ac8
[08:24:57.421] Capture standard output: TRUE
[08:24:57.421] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.421] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.421] Packages: <none>
[08:24:57.421] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.421] Resolved: TRUE
[08:24:57.421] Value: 1.39 KiB of class ‘list’
[08:24:57.421] Early signaling: FALSE
[08:24:57.421] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.421] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.422] Chunk #1 of 1 ... DONE
[08:24:57.422] Launching 1 futures (chunks) ... DONE
[08:24:57.422] Resolving 1 futures (chunks) ...
[08:24:57.422] resolve() on list ...
[08:24:57.422]  recursive: 0
[08:24:57.422]  length: 1
[08:24:57.422] 
[08:24:57.422] resolved() for ‘SequentialFuture’ ...
[08:24:57.423] - state: ‘finished’
[08:24:57.423] - run: TRUE
[08:24:57.423] - result: ‘FutureResult’
[08:24:57.423] resolved() for ‘SequentialFuture’ ... done
[08:24:57.423] Future #1
[08:24:57.423] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.423] - nx: 1
[08:24:57.423] - relay: TRUE
[08:24:57.423] - stdout: TRUE
[08:24:57.423] - signal: TRUE
[08:24:57.423] - resignal: FALSE
[08:24:57.424] - force: TRUE
[08:24:57.424] - relayed: [n=1] FALSE
[08:24:57.424] - queued futures: [n=1] FALSE
[08:24:57.424]  - until=1
[08:24:57.424]  - relaying element #1
[08:24:57.424] - relayed: [n=1] TRUE
[08:24:57.424] - queued futures: [n=1] TRUE
[08:24:57.424] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.424]  length: 0 (resolved future 1)
[08:24:57.426] Relaying remaining futures
[08:24:57.426] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.427] - nx: 1
[08:24:57.427] - relay: TRUE
[08:24:57.427] - stdout: TRUE
[08:24:57.427] - signal: TRUE
[08:24:57.427] - resignal: FALSE
[08:24:57.427] - force: TRUE
[08:24:57.427] - relayed: [n=1] TRUE
[08:24:57.427] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.427] - relayed: [n=1] TRUE
[08:24:57.427] - queued futures: [n=1] TRUE
[08:24:57.428] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.428] resolve() on list ... DONE
[08:24:57.428]  - Number of value chunks collected: 1
[08:24:57.428] Resolving 1 futures (chunks) ... DONE
[08:24:57.428] Reducing values from 1 chunks ...
[08:24:57.428]  - Number of values collected after concatenation: 3
[08:24:57.428]  - Number of values expected: 3
[08:24:57.428] Reducing values from 1 chunks ... DONE
[08:24:57.428] future_lapply() ... DONE
[08:24:57.429] future_by_internal() ... DONE
[08:24:57.430] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[08:24:57.430] future_lapply() ...
[08:24:57.431] Number of chunks: 1
[08:24:57.431] getGlobalsAndPackagesXApply() ...
[08:24:57.431]  - future.globals: TRUE
[08:24:57.431] getGlobalsAndPackages() ...
[08:24:57.431] Searching for globals...
[08:24:57.432] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:57.432] Searching for globals ... DONE
[08:24:57.432] Resolving globals: FALSE
[08:24:57.433] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:57.433] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:57.433] - globals: [1] ‘FUN’
[08:24:57.433] 
[08:24:57.433] getGlobalsAndPackages() ... DONE
[08:24:57.434]  - globals found/used: [n=1] ‘FUN’
[08:24:57.434]  - needed namespaces: [n=0] 
[08:24:57.434] Finding globals ... DONE
[08:24:57.434]  - use_args: TRUE
[08:24:57.434]  - Getting '...' globals ...
[08:24:57.434] resolve() on list ...
[08:24:57.434]  recursive: 0
[08:24:57.434]  length: 1
[08:24:57.434]  elements: ‘...’
[08:24:57.435]  length: 0 (resolved future 1)
[08:24:57.435] resolve() on list ... DONE
[08:24:57.435]    - '...' content: [n=0] 
[08:24:57.435] List of 1
[08:24:57.435]  $ ...: list()
[08:24:57.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.435]  - attr(*, "where")=List of 1
[08:24:57.435]   ..$ ...:<environment: 0x557b2847f988> 
[08:24:57.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.435]  - attr(*, "resolved")= logi TRUE
[08:24:57.435]  - attr(*, "total_size")= num NA
[08:24:57.437]  - Getting '...' globals ... DONE
[08:24:57.438] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.438] List of 2
[08:24:57.438]  $ ...future.FUN:function (object, ...)  
[08:24:57.438]  $ ...          : list()
[08:24:57.438]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.438]  - attr(*, "where")=List of 2
[08:24:57.438]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.438]   ..$ ...          :<environment: 0x557b2847f988> 
[08:24:57.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.438]  - attr(*, "resolved")= logi FALSE
[08:24:57.438]  - attr(*, "total_size")= num 18647
[08:24:57.440] Packages to be attached in all futures: [n=0] 
[08:24:57.441] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.441] Number of futures (= number of chunks): 1
[08:24:57.441] Launching 1 futures (chunks) ...
[08:24:57.441] Chunk #1 of 1 ...
[08:24:57.441]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.441] getGlobalsAndPackages() ...
[08:24:57.441] Searching for globals...
[08:24:57.442] 
[08:24:57.442] Searching for globals ... DONE
[08:24:57.442] - globals: [0] <none>
[08:24:57.442] getGlobalsAndPackages() ... DONE
[08:24:57.442]    + additional globals found: [n=0] 
[08:24:57.442]    + additional namespaces needed: [n=0] 
[08:24:57.442]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.442]  - seeds: <none>
[08:24:57.442]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.443] getGlobalsAndPackages() ...
[08:24:57.443] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.443] Resolving globals: FALSE
[08:24:57.443] Tweak future expression to call with '...' arguments ...
[08:24:57.443] {
[08:24:57.443]     do.call(function(...) {
[08:24:57.443]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.443]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.443]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.443]             on.exit(options(oopts), add = TRUE)
[08:24:57.443]         }
[08:24:57.443]         {
[08:24:57.443]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.443]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.443]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.443]             })
[08:24:57.443]         }
[08:24:57.443]     }, args = future.call.arguments)
[08:24:57.443] }
[08:24:57.443] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.444] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.444] 
[08:24:57.444] getGlobalsAndPackages() ... DONE
[08:24:57.444] run() for ‘Future’ ...
[08:24:57.444] - state: ‘created’
[08:24:57.444] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:57.445] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:57.445]   - Field: ‘label’
[08:24:57.445]   - Field: ‘local’
[08:24:57.445]   - Field: ‘owner’
[08:24:57.445]   - Field: ‘envir’
[08:24:57.445]   - Field: ‘packages’
[08:24:57.445]   - Field: ‘gc’
[08:24:57.445]   - Field: ‘conditions’
[08:24:57.445]   - Field: ‘expr’
[08:24:57.446]   - Field: ‘uuid’
[08:24:57.446]   - Field: ‘seed’
[08:24:57.446]   - Field: ‘version’
[08:24:57.446]   - Field: ‘result’
[08:24:57.448]   - Field: ‘asynchronous’
[08:24:57.448]   - Field: ‘calls’
[08:24:57.448]   - Field: ‘globals’
[08:24:57.448]   - Field: ‘stdout’
[08:24:57.448]   - Field: ‘earlySignal’
[08:24:57.448]   - Field: ‘lazy’
[08:24:57.449]   - Field: ‘state’
[08:24:57.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:57.449] - Launch lazy future ...
[08:24:57.449] Packages needed by the future expression (n = 0): <none>
[08:24:57.449] Packages needed by future strategies (n = 0): <none>
[08:24:57.450] {
[08:24:57.450]     {
[08:24:57.450]         {
[08:24:57.450]             ...future.startTime <- base::Sys.time()
[08:24:57.450]             {
[08:24:57.450]                 {
[08:24:57.450]                   {
[08:24:57.450]                     base::local({
[08:24:57.450]                       has_future <- base::requireNamespace("future", 
[08:24:57.450]                         quietly = TRUE)
[08:24:57.450]                       if (has_future) {
[08:24:57.450]                         ns <- base::getNamespace("future")
[08:24:57.450]                         version <- ns[[".package"]][["version"]]
[08:24:57.450]                         if (is.null(version)) 
[08:24:57.450]                           version <- utils::packageVersion("future")
[08:24:57.450]                       }
[08:24:57.450]                       else {
[08:24:57.450]                         version <- NULL
[08:24:57.450]                       }
[08:24:57.450]                       if (!has_future || version < "1.8.0") {
[08:24:57.450]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.450]                           "", base::R.version$version.string), 
[08:24:57.450]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:57.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.450]                             "release", "version")], collapse = " "), 
[08:24:57.450]                           hostname = base::Sys.info()[["nodename"]])
[08:24:57.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.450]                           info)
[08:24:57.450]                         info <- base::paste(info, collapse = "; ")
[08:24:57.450]                         if (!has_future) {
[08:24:57.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.450]                             info)
[08:24:57.450]                         }
[08:24:57.450]                         else {
[08:24:57.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.450]                             info, version)
[08:24:57.450]                         }
[08:24:57.450]                         base::stop(msg)
[08:24:57.450]                       }
[08:24:57.450]                     })
[08:24:57.450]                   }
[08:24:57.450]                   ...future.strategy.old <- future::plan("list")
[08:24:57.450]                   options(future.plan = NULL)
[08:24:57.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.450]                 }
[08:24:57.450]                 ...future.workdir <- getwd()
[08:24:57.450]             }
[08:24:57.450]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.450]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.450]         }
[08:24:57.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:57.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.450]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.450]             base::names(...future.oldOptions))
[08:24:57.450]     }
[08:24:57.450]     if (FALSE) {
[08:24:57.450]     }
[08:24:57.450]     else {
[08:24:57.450]         if (TRUE) {
[08:24:57.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.450]                 open = "w")
[08:24:57.450]         }
[08:24:57.450]         else {
[08:24:57.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.450]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.450]         }
[08:24:57.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.450]             base::sink(type = "output", split = FALSE)
[08:24:57.450]             base::close(...future.stdout)
[08:24:57.450]         }, add = TRUE)
[08:24:57.450]     }
[08:24:57.450]     ...future.frame <- base::sys.nframe()
[08:24:57.450]     ...future.conditions <- base::list()
[08:24:57.450]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.450]     if (FALSE) {
[08:24:57.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.450]     }
[08:24:57.450]     ...future.result <- base::tryCatch({
[08:24:57.450]         base::withCallingHandlers({
[08:24:57.450]             ...future.value <- base::withVisible(base::local({
[08:24:57.450]                 do.call(function(...) {
[08:24:57.450]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.450]                   if (!identical(...future.globals.maxSize.org, 
[08:24:57.450]                     ...future.globals.maxSize)) {
[08:24:57.450]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.450]                     on.exit(options(oopts), add = TRUE)
[08:24:57.450]                   }
[08:24:57.450]                   {
[08:24:57.450]                     lapply(seq_along(...future.elements_ii), 
[08:24:57.450]                       FUN = function(jj) {
[08:24:57.450]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.450]                         ...future.FUN(...future.X_jj, ...)
[08:24:57.450]                       })
[08:24:57.450]                   }
[08:24:57.450]                 }, args = future.call.arguments)
[08:24:57.450]             }))
[08:24:57.450]             future::FutureResult(value = ...future.value$value, 
[08:24:57.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.450]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.450]                     ...future.globalenv.names))
[08:24:57.450]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.450]         }, condition = base::local({
[08:24:57.450]             c <- base::c
[08:24:57.450]             inherits <- base::inherits
[08:24:57.450]             invokeRestart <- base::invokeRestart
[08:24:57.450]             length <- base::length
[08:24:57.450]             list <- base::list
[08:24:57.450]             seq.int <- base::seq.int
[08:24:57.450]             signalCondition <- base::signalCondition
[08:24:57.450]             sys.calls <- base::sys.calls
[08:24:57.450]             `[[` <- base::`[[`
[08:24:57.450]             `+` <- base::`+`
[08:24:57.450]             `<<-` <- base::`<<-`
[08:24:57.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.450]                   3L)]
[08:24:57.450]             }
[08:24:57.450]             function(cond) {
[08:24:57.450]                 is_error <- inherits(cond, "error")
[08:24:57.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.450]                   NULL)
[08:24:57.450]                 if (is_error) {
[08:24:57.450]                   sessionInformation <- function() {
[08:24:57.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.450]                       search = base::search(), system = base::Sys.info())
[08:24:57.450]                   }
[08:24:57.450]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.450]                     cond$call), session = sessionInformation(), 
[08:24:57.450]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.450]                   signalCondition(cond)
[08:24:57.450]                 }
[08:24:57.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.450]                 "immediateCondition"))) {
[08:24:57.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.450]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.450]                   if (TRUE && !signal) {
[08:24:57.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.450]                     {
[08:24:57.450]                       inherits <- base::inherits
[08:24:57.450]                       invokeRestart <- base::invokeRestart
[08:24:57.450]                       is.null <- base::is.null
[08:24:57.450]                       muffled <- FALSE
[08:24:57.450]                       if (inherits(cond, "message")) {
[08:24:57.450]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.450]                         if (muffled) 
[08:24:57.450]                           invokeRestart("muffleMessage")
[08:24:57.450]                       }
[08:24:57.450]                       else if (inherits(cond, "warning")) {
[08:24:57.450]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.450]                         if (muffled) 
[08:24:57.450]                           invokeRestart("muffleWarning")
[08:24:57.450]                       }
[08:24:57.450]                       else if (inherits(cond, "condition")) {
[08:24:57.450]                         if (!is.null(pattern)) {
[08:24:57.450]                           computeRestarts <- base::computeRestarts
[08:24:57.450]                           grepl <- base::grepl
[08:24:57.450]                           restarts <- computeRestarts(cond)
[08:24:57.450]                           for (restart in restarts) {
[08:24:57.450]                             name <- restart$name
[08:24:57.450]                             if (is.null(name)) 
[08:24:57.450]                               next
[08:24:57.450]                             if (!grepl(pattern, name)) 
[08:24:57.450]                               next
[08:24:57.450]                             invokeRestart(restart)
[08:24:57.450]                             muffled <- TRUE
[08:24:57.450]                             break
[08:24:57.450]                           }
[08:24:57.450]                         }
[08:24:57.450]                       }
[08:24:57.450]                       invisible(muffled)
[08:24:57.450]                     }
[08:24:57.450]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.450]                   }
[08:24:57.450]                 }
[08:24:57.450]                 else {
[08:24:57.450]                   if (TRUE) {
[08:24:57.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.450]                     {
[08:24:57.450]                       inherits <- base::inherits
[08:24:57.450]                       invokeRestart <- base::invokeRestart
[08:24:57.450]                       is.null <- base::is.null
[08:24:57.450]                       muffled <- FALSE
[08:24:57.450]                       if (inherits(cond, "message")) {
[08:24:57.450]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.450]                         if (muffled) 
[08:24:57.450]                           invokeRestart("muffleMessage")
[08:24:57.450]                       }
[08:24:57.450]                       else if (inherits(cond, "warning")) {
[08:24:57.450]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.450]                         if (muffled) 
[08:24:57.450]                           invokeRestart("muffleWarning")
[08:24:57.450]                       }
[08:24:57.450]                       else if (inherits(cond, "condition")) {
[08:24:57.450]                         if (!is.null(pattern)) {
[08:24:57.450]                           computeRestarts <- base::computeRestarts
[08:24:57.450]                           grepl <- base::grepl
[08:24:57.450]                           restarts <- computeRestarts(cond)
[08:24:57.450]                           for (restart in restarts) {
[08:24:57.450]                             name <- restart$name
[08:24:57.450]                             if (is.null(name)) 
[08:24:57.450]                               next
[08:24:57.450]                             if (!grepl(pattern, name)) 
[08:24:57.450]                               next
[08:24:57.450]                             invokeRestart(restart)
[08:24:57.450]                             muffled <- TRUE
[08:24:57.450]                             break
[08:24:57.450]                           }
[08:24:57.450]                         }
[08:24:57.450]                       }
[08:24:57.450]                       invisible(muffled)
[08:24:57.450]                     }
[08:24:57.450]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.450]                   }
[08:24:57.450]                 }
[08:24:57.450]             }
[08:24:57.450]         }))
[08:24:57.450]     }, error = function(ex) {
[08:24:57.450]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.450]                 ...future.rng), started = ...future.startTime, 
[08:24:57.450]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.450]             version = "1.8"), class = "FutureResult")
[08:24:57.450]     }, finally = {
[08:24:57.450]         if (!identical(...future.workdir, getwd())) 
[08:24:57.450]             setwd(...future.workdir)
[08:24:57.450]         {
[08:24:57.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.450]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.450]             }
[08:24:57.450]             base::options(...future.oldOptions)
[08:24:57.450]             if (.Platform$OS.type == "windows") {
[08:24:57.450]                 old_names <- names(...future.oldEnvVars)
[08:24:57.450]                 envs <- base::Sys.getenv()
[08:24:57.450]                 names <- names(envs)
[08:24:57.450]                 common <- intersect(names, old_names)
[08:24:57.450]                 added <- setdiff(names, old_names)
[08:24:57.450]                 removed <- setdiff(old_names, names)
[08:24:57.450]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.450]                   envs[common]]
[08:24:57.450]                 NAMES <- toupper(changed)
[08:24:57.450]                 args <- list()
[08:24:57.450]                 for (kk in seq_along(NAMES)) {
[08:24:57.450]                   name <- changed[[kk]]
[08:24:57.450]                   NAME <- NAMES[[kk]]
[08:24:57.450]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.450]                     next
[08:24:57.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.450]                 }
[08:24:57.450]                 NAMES <- toupper(added)
[08:24:57.450]                 for (kk in seq_along(NAMES)) {
[08:24:57.450]                   name <- added[[kk]]
[08:24:57.450]                   NAME <- NAMES[[kk]]
[08:24:57.450]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.450]                     next
[08:24:57.450]                   args[[name]] <- ""
[08:24:57.450]                 }
[08:24:57.450]                 NAMES <- toupper(removed)
[08:24:57.450]                 for (kk in seq_along(NAMES)) {
[08:24:57.450]                   name <- removed[[kk]]
[08:24:57.450]                   NAME <- NAMES[[kk]]
[08:24:57.450]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.450]                     next
[08:24:57.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.450]                 }
[08:24:57.450]                 if (length(args) > 0) 
[08:24:57.450]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.450]             }
[08:24:57.450]             else {
[08:24:57.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.450]             }
[08:24:57.450]             {
[08:24:57.450]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.450]                   0L) {
[08:24:57.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.450]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.450]                   base::options(opts)
[08:24:57.450]                 }
[08:24:57.450]                 {
[08:24:57.450]                   {
[08:24:57.450]                     NULL
[08:24:57.450]                     RNGkind("Mersenne-Twister")
[08:24:57.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:57.450]                       inherits = FALSE)
[08:24:57.450]                   }
[08:24:57.450]                   options(future.plan = NULL)
[08:24:57.450]                   if (is.na(NA_character_)) 
[08:24:57.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.450]                     .init = FALSE)
[08:24:57.450]                 }
[08:24:57.450]             }
[08:24:57.450]         }
[08:24:57.450]     })
[08:24:57.450]     if (TRUE) {
[08:24:57.450]         base::sink(type = "output", split = FALSE)
[08:24:57.450]         if (TRUE) {
[08:24:57.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.450]         }
[08:24:57.450]         else {
[08:24:57.450]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.450]         }
[08:24:57.450]         base::close(...future.stdout)
[08:24:57.450]         ...future.stdout <- NULL
[08:24:57.450]     }
[08:24:57.450]     ...future.result$conditions <- ...future.conditions
[08:24:57.450]     ...future.result$finished <- base::Sys.time()
[08:24:57.450]     ...future.result
[08:24:57.450] }
[08:24:57.452] assign_globals() ...
[08:24:57.452] List of 5
[08:24:57.452]  $ ...future.FUN            :function (object, ...)  
[08:24:57.452]  $ future.call.arguments    : list()
[08:24:57.452]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.452]  $ ...future.elements_ii    :List of 3
[08:24:57.452]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.452]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.452]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.452]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.452]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.452]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.452]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.452]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.452]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.452]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.452]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.452]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.452]  $ ...future.seeds_ii       : NULL
[08:24:57.452]  $ ...future.globals.maxSize: NULL
[08:24:57.452]  - attr(*, "where")=List of 5
[08:24:57.452]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.452]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.452]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.452]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.452]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.452]  - attr(*, "resolved")= logi FALSE
[08:24:57.452]  - attr(*, "total_size")= num 18647
[08:24:57.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.452]  - attr(*, "already-done")= logi TRUE
[08:24:57.461] - copied ‘...future.FUN’ to environment
[08:24:57.461] - copied ‘future.call.arguments’ to environment
[08:24:57.461] - copied ‘...future.elements_ii’ to environment
[08:24:57.461] - copied ‘...future.seeds_ii’ to environment
[08:24:57.461] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.461] assign_globals() ... done
[08:24:57.461] plan(): Setting new future strategy stack:
[08:24:57.461] List of future strategies:
[08:24:57.461] 1. sequential:
[08:24:57.461]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.461]    - tweaked: FALSE
[08:24:57.461]    - call: NULL
[08:24:57.462] plan(): nbrOfWorkers() = 1
[08:24:57.464] plan(): Setting new future strategy stack:
[08:24:57.464] List of future strategies:
[08:24:57.464] 1. sequential:
[08:24:57.464]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.464]    - tweaked: FALSE
[08:24:57.464]    - call: plan(strategy)
[08:24:57.465] plan(): nbrOfWorkers() = 1
[08:24:57.465] SequentialFuture started (and completed)
[08:24:57.465] - Launch lazy future ... done
[08:24:57.465] run() for ‘SequentialFuture’ ... done
[08:24:57.465] Created future:
[08:24:57.465] SequentialFuture:
[08:24:57.465] Label: ‘future_by-1’
[08:24:57.465] Expression:
[08:24:57.465] {
[08:24:57.465]     do.call(function(...) {
[08:24:57.465]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.465]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.465]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.465]             on.exit(options(oopts), add = TRUE)
[08:24:57.465]         }
[08:24:57.465]         {
[08:24:57.465]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.465]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.465]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.465]             })
[08:24:57.465]         }
[08:24:57.465]     }, args = future.call.arguments)
[08:24:57.465] }
[08:24:57.465] Lazy evaluation: FALSE
[08:24:57.465] Asynchronous evaluation: FALSE
[08:24:57.465] Local evaluation: TRUE
[08:24:57.465] Environment: 0x557b2749c400
[08:24:57.465] Capture standard output: TRUE
[08:24:57.465] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.465] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.98 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.465] Packages: <none>
[08:24:57.465] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.465] Resolved: TRUE
[08:24:57.465] Value: 1.39 KiB of class ‘list’
[08:24:57.465] Early signaling: FALSE
[08:24:57.465] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.465] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:57.466] Chunk #1 of 1 ... DONE
[08:24:57.466] Launching 1 futures (chunks) ... DONE
[08:24:57.466] Resolving 1 futures (chunks) ...
[08:24:57.467] resolve() on list ...
[08:24:57.467]  recursive: 0
[08:24:57.467]  length: 1
[08:24:57.467] 
[08:24:57.467] resolved() for ‘SequentialFuture’ ...
[08:24:57.467] - state: ‘finished’
[08:24:57.467] - run: TRUE
[08:24:57.467] - result: ‘FutureResult’
[08:24:57.467] resolved() for ‘SequentialFuture’ ... done
[08:24:57.467] Future #1
[08:24:57.468] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:57.468] - nx: 1
[08:24:57.468] - relay: TRUE
[08:24:57.468] - stdout: TRUE
[08:24:57.468] - signal: TRUE
[08:24:57.468] - resignal: FALSE
[08:24:57.468] - force: TRUE
[08:24:57.468] - relayed: [n=1] FALSE
[08:24:57.468] - queued futures: [n=1] FALSE
[08:24:57.468]  - until=1
[08:24:57.468]  - relaying element #1
[08:24:57.469] - relayed: [n=1] TRUE
[08:24:57.469] - queued futures: [n=1] TRUE
[08:24:57.469] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:57.469]  length: 0 (resolved future 1)
[08:24:57.469] Relaying remaining futures
[08:24:57.471] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.471] - nx: 1
[08:24:57.471] - relay: TRUE
[08:24:57.471] - stdout: TRUE
[08:24:57.471] - signal: TRUE
[08:24:57.471] - resignal: FALSE
[08:24:57.472] - force: TRUE
[08:24:57.472] - relayed: [n=1] TRUE
[08:24:57.472] - queued futures: [n=1] TRUE
 - flush all
[08:24:57.472] - relayed: [n=1] TRUE
[08:24:57.472] - queued futures: [n=1] TRUE
[08:24:57.472] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.472] resolve() on list ... DONE
[08:24:57.472]  - Number of value chunks collected: 1
[08:24:57.473] Resolving 1 futures (chunks) ... DONE
[08:24:57.473] Reducing values from 1 chunks ...
[08:24:57.473]  - Number of values collected after concatenation: 3
[08:24:57.473]  - Number of values expected: 3
[08:24:57.473] Reducing values from 1 chunks ... DONE
[08:24:57.473] future_lapply() ... DONE
[08:24:57.473] future_by_internal() ... DONE
[08:24:57.474] future_by_internal() ...
- plan('multicore') ...
[08:24:57.475] plan(): Setting new future strategy stack:
[08:24:57.475] List of future strategies:
[08:24:57.475] 1. multicore:
[08:24:57.475]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.475]    - tweaked: FALSE
[08:24:57.475]    - call: plan(strategy)
[08:24:57.477] plan(): nbrOfWorkers() = 2
[08:24:57.477] future_by_internal() ...
[08:24:57.477] future_lapply() ...
[08:24:57.480] Number of chunks: 2
[08:24:57.480] getGlobalsAndPackagesXApply() ...
[08:24:57.480]  - future.globals: TRUE
[08:24:57.480] getGlobalsAndPackages() ...
[08:24:57.480] Searching for globals...
[08:24:57.481] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:57.481] Searching for globals ... DONE
[08:24:57.481] Resolving globals: FALSE
[08:24:57.482] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:57.482] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:57.482] - globals: [1] ‘FUN’
[08:24:57.482] 
[08:24:57.482] getGlobalsAndPackages() ... DONE
[08:24:57.483]  - globals found/used: [n=1] ‘FUN’
[08:24:57.483]  - needed namespaces: [n=0] 
[08:24:57.483] Finding globals ... DONE
[08:24:57.483]  - use_args: TRUE
[08:24:57.483]  - Getting '...' globals ...
[08:24:57.483] resolve() on list ...
[08:24:57.483]  recursive: 0
[08:24:57.483]  length: 1
[08:24:57.483]  elements: ‘...’
[08:24:57.484]  length: 0 (resolved future 1)
[08:24:57.484] resolve() on list ... DONE
[08:24:57.484]    - '...' content: [n=0] 
[08:24:57.484] List of 1
[08:24:57.484]  $ ...: list()
[08:24:57.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.484]  - attr(*, "where")=List of 1
[08:24:57.484]   ..$ ...:<environment: 0x557b273f9ab0> 
[08:24:57.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.484]  - attr(*, "resolved")= logi TRUE
[08:24:57.484]  - attr(*, "total_size")= num NA
[08:24:57.486]  - Getting '...' globals ... DONE
[08:24:57.487] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.487] List of 2
[08:24:57.487]  $ ...future.FUN:function (object, ...)  
[08:24:57.487]  $ ...          : list()
[08:24:57.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.487]  - attr(*, "where")=List of 2
[08:24:57.487]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.487]   ..$ ...          :<environment: 0x557b273f9ab0> 
[08:24:57.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.487]  - attr(*, "resolved")= logi FALSE
[08:24:57.487]  - attr(*, "total_size")= num 15670
[08:24:57.489] Packages to be attached in all futures: [n=0] 
[08:24:57.490] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.490] Number of futures (= number of chunks): 2
[08:24:57.490] Launching 2 futures (chunks) ...
[08:24:57.490] Chunk #1 of 2 ...
[08:24:57.490]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.490] getGlobalsAndPackages() ...
[08:24:57.490] Searching for globals...
[08:24:57.491] 
[08:24:57.491] Searching for globals ... DONE
[08:24:57.491] - globals: [0] <none>
[08:24:57.491] getGlobalsAndPackages() ... DONE
[08:24:57.491]    + additional globals found: [n=0] 
[08:24:57.491]    + additional namespaces needed: [n=0] 
[08:24:57.491]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:57.491]  - seeds: <none>
[08:24:57.491]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.492] getGlobalsAndPackages() ...
[08:24:57.492] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.492] Resolving globals: FALSE
[08:24:57.492] Tweak future expression to call with '...' arguments ...
[08:24:57.494] {
[08:24:57.494]     do.call(function(...) {
[08:24:57.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.494]             on.exit(options(oopts), add = TRUE)
[08:24:57.494]         }
[08:24:57.494]         {
[08:24:57.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.494]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.494]             })
[08:24:57.494]         }
[08:24:57.494]     }, args = future.call.arguments)
[08:24:57.494] }
[08:24:57.494] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.495] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.495] 
[08:24:57.495] getGlobalsAndPackages() ... DONE
[08:24:57.495] run() for ‘Future’ ...
[08:24:57.495] - state: ‘created’
[08:24:57.495] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.497] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:57.498]   - Field: ‘label’
[08:24:57.498]   - Field: ‘local’
[08:24:57.498]   - Field: ‘owner’
[08:24:57.498]   - Field: ‘envir’
[08:24:57.498]   - Field: ‘workers’
[08:24:57.498]   - Field: ‘packages’
[08:24:57.498]   - Field: ‘gc’
[08:24:57.498]   - Field: ‘job’
[08:24:57.498]   - Field: ‘conditions’
[08:24:57.499]   - Field: ‘expr’
[08:24:57.499]   - Field: ‘uuid’
[08:24:57.499]   - Field: ‘seed’
[08:24:57.499]   - Field: ‘version’
[08:24:57.499]   - Field: ‘result’
[08:24:57.499]   - Field: ‘asynchronous’
[08:24:57.499]   - Field: ‘calls’
[08:24:57.499]   - Field: ‘globals’
[08:24:57.499]   - Field: ‘stdout’
[08:24:57.499]   - Field: ‘earlySignal’
[08:24:57.500]   - Field: ‘lazy’
[08:24:57.500]   - Field: ‘state’
[08:24:57.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:57.500] - Launch lazy future ...
[08:24:57.501] Packages needed by the future expression (n = 0): <none>
[08:24:57.501] Packages needed by future strategies (n = 0): <none>
[08:24:57.501] {
[08:24:57.501]     {
[08:24:57.501]         {
[08:24:57.501]             ...future.startTime <- base::Sys.time()
[08:24:57.501]             {
[08:24:57.501]                 {
[08:24:57.501]                   {
[08:24:57.501]                     {
[08:24:57.501]                       base::local({
[08:24:57.501]                         has_future <- base::requireNamespace("future", 
[08:24:57.501]                           quietly = TRUE)
[08:24:57.501]                         if (has_future) {
[08:24:57.501]                           ns <- base::getNamespace("future")
[08:24:57.501]                           version <- ns[[".package"]][["version"]]
[08:24:57.501]                           if (is.null(version)) 
[08:24:57.501]                             version <- utils::packageVersion("future")
[08:24:57.501]                         }
[08:24:57.501]                         else {
[08:24:57.501]                           version <- NULL
[08:24:57.501]                         }
[08:24:57.501]                         if (!has_future || version < "1.8.0") {
[08:24:57.501]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.501]                             "", base::R.version$version.string), 
[08:24:57.501]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:57.501]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.501]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.501]                               "release", "version")], collapse = " "), 
[08:24:57.501]                             hostname = base::Sys.info()[["nodename"]])
[08:24:57.501]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.501]                             info)
[08:24:57.501]                           info <- base::paste(info, collapse = "; ")
[08:24:57.501]                           if (!has_future) {
[08:24:57.501]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.501]                               info)
[08:24:57.501]                           }
[08:24:57.501]                           else {
[08:24:57.501]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.501]                               info, version)
[08:24:57.501]                           }
[08:24:57.501]                           base::stop(msg)
[08:24:57.501]                         }
[08:24:57.501]                       })
[08:24:57.501]                     }
[08:24:57.501]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:57.501]                     base::options(mc.cores = 1L)
[08:24:57.501]                   }
[08:24:57.501]                   ...future.strategy.old <- future::plan("list")
[08:24:57.501]                   options(future.plan = NULL)
[08:24:57.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.501]                 }
[08:24:57.501]                 ...future.workdir <- getwd()
[08:24:57.501]             }
[08:24:57.501]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.501]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.501]         }
[08:24:57.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.501]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:57.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.501]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.501]             base::names(...future.oldOptions))
[08:24:57.501]     }
[08:24:57.501]     if (FALSE) {
[08:24:57.501]     }
[08:24:57.501]     else {
[08:24:57.501]         if (TRUE) {
[08:24:57.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.501]                 open = "w")
[08:24:57.501]         }
[08:24:57.501]         else {
[08:24:57.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.501]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.501]         }
[08:24:57.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.501]             base::sink(type = "output", split = FALSE)
[08:24:57.501]             base::close(...future.stdout)
[08:24:57.501]         }, add = TRUE)
[08:24:57.501]     }
[08:24:57.501]     ...future.frame <- base::sys.nframe()
[08:24:57.501]     ...future.conditions <- base::list()
[08:24:57.501]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.501]     if (FALSE) {
[08:24:57.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.501]     }
[08:24:57.501]     ...future.result <- base::tryCatch({
[08:24:57.501]         base::withCallingHandlers({
[08:24:57.501]             ...future.value <- base::withVisible(base::local({
[08:24:57.501]                 withCallingHandlers({
[08:24:57.501]                   {
[08:24:57.501]                     do.call(function(...) {
[08:24:57.501]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.501]                       if (!identical(...future.globals.maxSize.org, 
[08:24:57.501]                         ...future.globals.maxSize)) {
[08:24:57.501]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.501]                         on.exit(options(oopts), add = TRUE)
[08:24:57.501]                       }
[08:24:57.501]                       {
[08:24:57.501]                         lapply(seq_along(...future.elements_ii), 
[08:24:57.501]                           FUN = function(jj) {
[08:24:57.501]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.501]                             ...future.FUN(...future.X_jj, ...)
[08:24:57.501]                           })
[08:24:57.501]                       }
[08:24:57.501]                     }, args = future.call.arguments)
[08:24:57.501]                   }
[08:24:57.501]                 }, immediateCondition = function(cond) {
[08:24:57.501]                   save_rds <- function (object, pathname, ...) 
[08:24:57.501]                   {
[08:24:57.501]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:57.501]                     if (file_test("-f", pathname_tmp)) {
[08:24:57.501]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.501]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:57.501]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.501]                         fi_tmp[["mtime"]])
[08:24:57.501]                     }
[08:24:57.501]                     tryCatch({
[08:24:57.501]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:57.501]                     }, error = function(ex) {
[08:24:57.501]                       msg <- conditionMessage(ex)
[08:24:57.501]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.501]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:57.501]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.501]                         fi_tmp[["mtime"]], msg)
[08:24:57.501]                       ex$message <- msg
[08:24:57.501]                       stop(ex)
[08:24:57.501]                     })
[08:24:57.501]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:57.501]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:57.501]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:57.501]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.501]                       fi <- file.info(pathname)
[08:24:57.501]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:57.501]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.501]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:57.501]                         fi[["size"]], fi[["mtime"]])
[08:24:57.501]                       stop(msg)
[08:24:57.501]                     }
[08:24:57.501]                     invisible(pathname)
[08:24:57.501]                   }
[08:24:57.501]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:57.501]                     rootPath = tempdir()) 
[08:24:57.501]                   {
[08:24:57.501]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:57.501]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:57.501]                       tmpdir = path, fileext = ".rds")
[08:24:57.501]                     save_rds(obj, file)
[08:24:57.501]                   }
[08:24:57.501]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:57.501]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.501]                   {
[08:24:57.501]                     inherits <- base::inherits
[08:24:57.501]                     invokeRestart <- base::invokeRestart
[08:24:57.501]                     is.null <- base::is.null
[08:24:57.501]                     muffled <- FALSE
[08:24:57.501]                     if (inherits(cond, "message")) {
[08:24:57.501]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:57.501]                       if (muffled) 
[08:24:57.501]                         invokeRestart("muffleMessage")
[08:24:57.501]                     }
[08:24:57.501]                     else if (inherits(cond, "warning")) {
[08:24:57.501]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:57.501]                       if (muffled) 
[08:24:57.501]                         invokeRestart("muffleWarning")
[08:24:57.501]                     }
[08:24:57.501]                     else if (inherits(cond, "condition")) {
[08:24:57.501]                       if (!is.null(pattern)) {
[08:24:57.501]                         computeRestarts <- base::computeRestarts
[08:24:57.501]                         grepl <- base::grepl
[08:24:57.501]                         restarts <- computeRestarts(cond)
[08:24:57.501]                         for (restart in restarts) {
[08:24:57.501]                           name <- restart$name
[08:24:57.501]                           if (is.null(name)) 
[08:24:57.501]                             next
[08:24:57.501]                           if (!grepl(pattern, name)) 
[08:24:57.501]                             next
[08:24:57.501]                           invokeRestart(restart)
[08:24:57.501]                           muffled <- TRUE
[08:24:57.501]                           break
[08:24:57.501]                         }
[08:24:57.501]                       }
[08:24:57.501]                     }
[08:24:57.501]                     invisible(muffled)
[08:24:57.501]                   }
[08:24:57.501]                   muffleCondition(cond)
[08:24:57.501]                 })
[08:24:57.501]             }))
[08:24:57.501]             future::FutureResult(value = ...future.value$value, 
[08:24:57.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.501]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.501]                     ...future.globalenv.names))
[08:24:57.501]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.501]         }, condition = base::local({
[08:24:57.501]             c <- base::c
[08:24:57.501]             inherits <- base::inherits
[08:24:57.501]             invokeRestart <- base::invokeRestart
[08:24:57.501]             length <- base::length
[08:24:57.501]             list <- base::list
[08:24:57.501]             seq.int <- base::seq.int
[08:24:57.501]             signalCondition <- base::signalCondition
[08:24:57.501]             sys.calls <- base::sys.calls
[08:24:57.501]             `[[` <- base::`[[`
[08:24:57.501]             `+` <- base::`+`
[08:24:57.501]             `<<-` <- base::`<<-`
[08:24:57.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.501]                   3L)]
[08:24:57.501]             }
[08:24:57.501]             function(cond) {
[08:24:57.501]                 is_error <- inherits(cond, "error")
[08:24:57.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.501]                   NULL)
[08:24:57.501]                 if (is_error) {
[08:24:57.501]                   sessionInformation <- function() {
[08:24:57.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.501]                       search = base::search(), system = base::Sys.info())
[08:24:57.501]                   }
[08:24:57.501]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.501]                     cond$call), session = sessionInformation(), 
[08:24:57.501]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.501]                   signalCondition(cond)
[08:24:57.501]                 }
[08:24:57.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.501]                 "immediateCondition"))) {
[08:24:57.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.501]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.501]                   if (TRUE && !signal) {
[08:24:57.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.501]                     {
[08:24:57.501]                       inherits <- base::inherits
[08:24:57.501]                       invokeRestart <- base::invokeRestart
[08:24:57.501]                       is.null <- base::is.null
[08:24:57.501]                       muffled <- FALSE
[08:24:57.501]                       if (inherits(cond, "message")) {
[08:24:57.501]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.501]                         if (muffled) 
[08:24:57.501]                           invokeRestart("muffleMessage")
[08:24:57.501]                       }
[08:24:57.501]                       else if (inherits(cond, "warning")) {
[08:24:57.501]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.501]                         if (muffled) 
[08:24:57.501]                           invokeRestart("muffleWarning")
[08:24:57.501]                       }
[08:24:57.501]                       else if (inherits(cond, "condition")) {
[08:24:57.501]                         if (!is.null(pattern)) {
[08:24:57.501]                           computeRestarts <- base::computeRestarts
[08:24:57.501]                           grepl <- base::grepl
[08:24:57.501]                           restarts <- computeRestarts(cond)
[08:24:57.501]                           for (restart in restarts) {
[08:24:57.501]                             name <- restart$name
[08:24:57.501]                             if (is.null(name)) 
[08:24:57.501]                               next
[08:24:57.501]                             if (!grepl(pattern, name)) 
[08:24:57.501]                               next
[08:24:57.501]                             invokeRestart(restart)
[08:24:57.501]                             muffled <- TRUE
[08:24:57.501]                             break
[08:24:57.501]                           }
[08:24:57.501]                         }
[08:24:57.501]                       }
[08:24:57.501]                       invisible(muffled)
[08:24:57.501]                     }
[08:24:57.501]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.501]                   }
[08:24:57.501]                 }
[08:24:57.501]                 else {
[08:24:57.501]                   if (TRUE) {
[08:24:57.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.501]                     {
[08:24:57.501]                       inherits <- base::inherits
[08:24:57.501]                       invokeRestart <- base::invokeRestart
[08:24:57.501]                       is.null <- base::is.null
[08:24:57.501]                       muffled <- FALSE
[08:24:57.501]                       if (inherits(cond, "message")) {
[08:24:57.501]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.501]                         if (muffled) 
[08:24:57.501]                           invokeRestart("muffleMessage")
[08:24:57.501]                       }
[08:24:57.501]                       else if (inherits(cond, "warning")) {
[08:24:57.501]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.501]                         if (muffled) 
[08:24:57.501]                           invokeRestart("muffleWarning")
[08:24:57.501]                       }
[08:24:57.501]                       else if (inherits(cond, "condition")) {
[08:24:57.501]                         if (!is.null(pattern)) {
[08:24:57.501]                           computeRestarts <- base::computeRestarts
[08:24:57.501]                           grepl <- base::grepl
[08:24:57.501]                           restarts <- computeRestarts(cond)
[08:24:57.501]                           for (restart in restarts) {
[08:24:57.501]                             name <- restart$name
[08:24:57.501]                             if (is.null(name)) 
[08:24:57.501]                               next
[08:24:57.501]                             if (!grepl(pattern, name)) 
[08:24:57.501]                               next
[08:24:57.501]                             invokeRestart(restart)
[08:24:57.501]                             muffled <- TRUE
[08:24:57.501]                             break
[08:24:57.501]                           }
[08:24:57.501]                         }
[08:24:57.501]                       }
[08:24:57.501]                       invisible(muffled)
[08:24:57.501]                     }
[08:24:57.501]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.501]                   }
[08:24:57.501]                 }
[08:24:57.501]             }
[08:24:57.501]         }))
[08:24:57.501]     }, error = function(ex) {
[08:24:57.501]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.501]                 ...future.rng), started = ...future.startTime, 
[08:24:57.501]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.501]             version = "1.8"), class = "FutureResult")
[08:24:57.501]     }, finally = {
[08:24:57.501]         if (!identical(...future.workdir, getwd())) 
[08:24:57.501]             setwd(...future.workdir)
[08:24:57.501]         {
[08:24:57.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.501]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.501]             }
[08:24:57.501]             base::options(...future.oldOptions)
[08:24:57.501]             if (.Platform$OS.type == "windows") {
[08:24:57.501]                 old_names <- names(...future.oldEnvVars)
[08:24:57.501]                 envs <- base::Sys.getenv()
[08:24:57.501]                 names <- names(envs)
[08:24:57.501]                 common <- intersect(names, old_names)
[08:24:57.501]                 added <- setdiff(names, old_names)
[08:24:57.501]                 removed <- setdiff(old_names, names)
[08:24:57.501]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.501]                   envs[common]]
[08:24:57.501]                 NAMES <- toupper(changed)
[08:24:57.501]                 args <- list()
[08:24:57.501]                 for (kk in seq_along(NAMES)) {
[08:24:57.501]                   name <- changed[[kk]]
[08:24:57.501]                   NAME <- NAMES[[kk]]
[08:24:57.501]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.501]                     next
[08:24:57.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.501]                 }
[08:24:57.501]                 NAMES <- toupper(added)
[08:24:57.501]                 for (kk in seq_along(NAMES)) {
[08:24:57.501]                   name <- added[[kk]]
[08:24:57.501]                   NAME <- NAMES[[kk]]
[08:24:57.501]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.501]                     next
[08:24:57.501]                   args[[name]] <- ""
[08:24:57.501]                 }
[08:24:57.501]                 NAMES <- toupper(removed)
[08:24:57.501]                 for (kk in seq_along(NAMES)) {
[08:24:57.501]                   name <- removed[[kk]]
[08:24:57.501]                   NAME <- NAMES[[kk]]
[08:24:57.501]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.501]                     next
[08:24:57.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.501]                 }
[08:24:57.501]                 if (length(args) > 0) 
[08:24:57.501]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.501]             }
[08:24:57.501]             else {
[08:24:57.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.501]             }
[08:24:57.501]             {
[08:24:57.501]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.501]                   0L) {
[08:24:57.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.501]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.501]                   base::options(opts)
[08:24:57.501]                 }
[08:24:57.501]                 {
[08:24:57.501]                   {
[08:24:57.501]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:57.501]                     NULL
[08:24:57.501]                   }
[08:24:57.501]                   options(future.plan = NULL)
[08:24:57.501]                   if (is.na(NA_character_)) 
[08:24:57.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.501]                     .init = FALSE)
[08:24:57.501]                 }
[08:24:57.501]             }
[08:24:57.501]         }
[08:24:57.501]     })
[08:24:57.501]     if (TRUE) {
[08:24:57.501]         base::sink(type = "output", split = FALSE)
[08:24:57.501]         if (TRUE) {
[08:24:57.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.501]         }
[08:24:57.501]         else {
[08:24:57.501]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.501]         }
[08:24:57.501]         base::close(...future.stdout)
[08:24:57.501]         ...future.stdout <- NULL
[08:24:57.501]     }
[08:24:57.501]     ...future.result$conditions <- ...future.conditions
[08:24:57.501]     ...future.result$finished <- base::Sys.time()
[08:24:57.501]     ...future.result
[08:24:57.501] }
[08:24:57.504] assign_globals() ...
[08:24:57.504] List of 5
[08:24:57.504]  $ ...future.FUN            :function (object, ...)  
[08:24:57.504]  $ future.call.arguments    : list()
[08:24:57.504]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.504]  $ ...future.elements_ii    :List of 1
[08:24:57.504]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:57.504]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.504]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.504]  $ ...future.seeds_ii       : NULL
[08:24:57.504]  $ ...future.globals.maxSize: NULL
[08:24:57.504]  - attr(*, "where")=List of 5
[08:24:57.504]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.504]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.504]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.504]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.504]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.504]  - attr(*, "resolved")= logi FALSE
[08:24:57.504]  - attr(*, "total_size")= num 15670
[08:24:57.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.504]  - attr(*, "already-done")= logi TRUE
[08:24:57.509] - copied ‘...future.FUN’ to environment
[08:24:57.510] - copied ‘future.call.arguments’ to environment
[08:24:57.510] - copied ‘...future.elements_ii’ to environment
[08:24:57.510] - copied ‘...future.seeds_ii’ to environment
[08:24:57.510] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.510] assign_globals() ... done
[08:24:57.510] requestCore(): workers = 2
[08:24:57.513] MulticoreFuture started
[08:24:57.514] - Launch lazy future ... done
[08:24:57.514] plan(): Setting new future strategy stack:
[08:24:57.514] run() for ‘MulticoreFuture’ ... done
[08:24:57.514] Created future:
[08:24:57.514] List of future strategies:
[08:24:57.514] 1. sequential:
[08:24:57.514]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.514]    - tweaked: FALSE
[08:24:57.514]    - call: NULL
[08:24:57.515] plan(): nbrOfWorkers() = 1
[08:24:57.519] plan(): Setting new future strategy stack:
[08:24:57.519] List of future strategies:
[08:24:57.519] 1. multicore:
[08:24:57.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.519]    - tweaked: FALSE
[08:24:57.519]    - call: plan(strategy)
[08:24:57.522] plan(): nbrOfWorkers() = 2
[08:24:57.515] MulticoreFuture:
[08:24:57.515] Label: ‘future_by-1’
[08:24:57.515] Expression:
[08:24:57.515] {
[08:24:57.515]     do.call(function(...) {
[08:24:57.515]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.515]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.515]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.515]             on.exit(options(oopts), add = TRUE)
[08:24:57.515]         }
[08:24:57.515]         {
[08:24:57.515]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.515]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.515]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.515]             })
[08:24:57.515]         }
[08:24:57.515]     }, args = future.call.arguments)
[08:24:57.515] }
[08:24:57.515] Lazy evaluation: FALSE
[08:24:57.515] Asynchronous evaluation: TRUE
[08:24:57.515] Local evaluation: TRUE
[08:24:57.515] Environment: R_GlobalEnv
[08:24:57.515] Capture standard output: TRUE
[08:24:57.515] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.515] Globals: 5 objects totaling 996 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 564 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.515] Packages: <none>
[08:24:57.515] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.515] Resolved: TRUE
[08:24:57.515] Value: <not collected>
[08:24:57.515] Conditions captured: <none>
[08:24:57.515] Early signaling: FALSE
[08:24:57.515] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.515] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.523] Chunk #1 of 2 ... DONE
[08:24:57.524] Chunk #2 of 2 ...
[08:24:57.524]  - Finding globals in 'X' for chunk #2 ...
[08:24:57.524] getGlobalsAndPackages() ...
[08:24:57.524] Searching for globals...
[08:24:57.525] 
[08:24:57.525] Searching for globals ... DONE
[08:24:57.525] - globals: [0] <none>
[08:24:57.526] getGlobalsAndPackages() ... DONE
[08:24:57.526]    + additional globals found: [n=0] 
[08:24:57.526]    + additional namespaces needed: [n=0] 
[08:24:57.526]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:57.526]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:57.526]  - seeds: <none>
[08:24:57.527]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.527] getGlobalsAndPackages() ...
[08:24:57.527] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.527] Resolving globals: FALSE
[08:24:57.527] Tweak future expression to call with '...' arguments ...
[08:24:57.528] {
[08:24:57.528]     do.call(function(...) {
[08:24:57.528]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.528]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.528]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.528]             on.exit(options(oopts), add = TRUE)
[08:24:57.528]         }
[08:24:57.528]         {
[08:24:57.528]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.528]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.528]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.528]             })
[08:24:57.528]         }
[08:24:57.528]     }, args = future.call.arguments)
[08:24:57.528] }
[08:24:57.528] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.529] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.529] 
[08:24:57.529] getGlobalsAndPackages() ... DONE
[08:24:57.530] run() for ‘Future’ ...
[08:24:57.530] - state: ‘created’
[08:24:57.530] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:57.542]   - Field: ‘label’
[08:24:57.542]   - Field: ‘local’
[08:24:57.542]   - Field: ‘owner’
[08:24:57.543]   - Field: ‘envir’
[08:24:57.543]   - Field: ‘workers’
[08:24:57.543]   - Field: ‘packages’
[08:24:57.543]   - Field: ‘gc’
[08:24:57.544]   - Field: ‘job’
[08:24:57.544]   - Field: ‘conditions’
[08:24:57.544]   - Field: ‘expr’
[08:24:57.545]   - Field: ‘uuid’
[08:24:57.545]   - Field: ‘seed’
[08:24:57.545]   - Field: ‘version’
[08:24:57.545]   - Field: ‘result’
[08:24:57.546]   - Field: ‘asynchronous’
[08:24:57.546]   - Field: ‘calls’
[08:24:57.546]   - Field: ‘globals’
[08:24:57.546]   - Field: ‘stdout’
[08:24:57.547]   - Field: ‘earlySignal’
[08:24:57.547]   - Field: ‘lazy’
[08:24:57.548]   - Field: ‘state’
[08:24:57.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:57.548] - Launch lazy future ...
[08:24:57.549] Packages needed by the future expression (n = 0): <none>
[08:24:57.549] Packages needed by future strategies (n = 0): <none>
[08:24:57.550] {
[08:24:57.550]     {
[08:24:57.550]         {
[08:24:57.550]             ...future.startTime <- base::Sys.time()
[08:24:57.550]             {
[08:24:57.550]                 {
[08:24:57.550]                   {
[08:24:57.550]                     {
[08:24:57.550]                       base::local({
[08:24:57.550]                         has_future <- base::requireNamespace("future", 
[08:24:57.550]                           quietly = TRUE)
[08:24:57.550]                         if (has_future) {
[08:24:57.550]                           ns <- base::getNamespace("future")
[08:24:57.550]                           version <- ns[[".package"]][["version"]]
[08:24:57.550]                           if (is.null(version)) 
[08:24:57.550]                             version <- utils::packageVersion("future")
[08:24:57.550]                         }
[08:24:57.550]                         else {
[08:24:57.550]                           version <- NULL
[08:24:57.550]                         }
[08:24:57.550]                         if (!has_future || version < "1.8.0") {
[08:24:57.550]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.550]                             "", base::R.version$version.string), 
[08:24:57.550]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:57.550]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.550]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.550]                               "release", "version")], collapse = " "), 
[08:24:57.550]                             hostname = base::Sys.info()[["nodename"]])
[08:24:57.550]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.550]                             info)
[08:24:57.550]                           info <- base::paste(info, collapse = "; ")
[08:24:57.550]                           if (!has_future) {
[08:24:57.550]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.550]                               info)
[08:24:57.550]                           }
[08:24:57.550]                           else {
[08:24:57.550]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.550]                               info, version)
[08:24:57.550]                           }
[08:24:57.550]                           base::stop(msg)
[08:24:57.550]                         }
[08:24:57.550]                       })
[08:24:57.550]                     }
[08:24:57.550]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:57.550]                     base::options(mc.cores = 1L)
[08:24:57.550]                   }
[08:24:57.550]                   ...future.strategy.old <- future::plan("list")
[08:24:57.550]                   options(future.plan = NULL)
[08:24:57.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.550]                 }
[08:24:57.550]                 ...future.workdir <- getwd()
[08:24:57.550]             }
[08:24:57.550]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.550]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.550]         }
[08:24:57.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.550]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:57.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.550]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.550]             base::names(...future.oldOptions))
[08:24:57.550]     }
[08:24:57.550]     if (FALSE) {
[08:24:57.550]     }
[08:24:57.550]     else {
[08:24:57.550]         if (TRUE) {
[08:24:57.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.550]                 open = "w")
[08:24:57.550]         }
[08:24:57.550]         else {
[08:24:57.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.550]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.550]         }
[08:24:57.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.550]             base::sink(type = "output", split = FALSE)
[08:24:57.550]             base::close(...future.stdout)
[08:24:57.550]         }, add = TRUE)
[08:24:57.550]     }
[08:24:57.550]     ...future.frame <- base::sys.nframe()
[08:24:57.550]     ...future.conditions <- base::list()
[08:24:57.550]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.550]     if (FALSE) {
[08:24:57.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.550]     }
[08:24:57.550]     ...future.result <- base::tryCatch({
[08:24:57.550]         base::withCallingHandlers({
[08:24:57.550]             ...future.value <- base::withVisible(base::local({
[08:24:57.550]                 withCallingHandlers({
[08:24:57.550]                   {
[08:24:57.550]                     do.call(function(...) {
[08:24:57.550]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.550]                       if (!identical(...future.globals.maxSize.org, 
[08:24:57.550]                         ...future.globals.maxSize)) {
[08:24:57.550]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.550]                         on.exit(options(oopts), add = TRUE)
[08:24:57.550]                       }
[08:24:57.550]                       {
[08:24:57.550]                         lapply(seq_along(...future.elements_ii), 
[08:24:57.550]                           FUN = function(jj) {
[08:24:57.550]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.550]                             ...future.FUN(...future.X_jj, ...)
[08:24:57.550]                           })
[08:24:57.550]                       }
[08:24:57.550]                     }, args = future.call.arguments)
[08:24:57.550]                   }
[08:24:57.550]                 }, immediateCondition = function(cond) {
[08:24:57.550]                   save_rds <- function (object, pathname, ...) 
[08:24:57.550]                   {
[08:24:57.550]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:57.550]                     if (file_test("-f", pathname_tmp)) {
[08:24:57.550]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.550]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:57.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.550]                         fi_tmp[["mtime"]])
[08:24:57.550]                     }
[08:24:57.550]                     tryCatch({
[08:24:57.550]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:57.550]                     }, error = function(ex) {
[08:24:57.550]                       msg <- conditionMessage(ex)
[08:24:57.550]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.550]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:57.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.550]                         fi_tmp[["mtime"]], msg)
[08:24:57.550]                       ex$message <- msg
[08:24:57.550]                       stop(ex)
[08:24:57.550]                     })
[08:24:57.550]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:57.550]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:57.550]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:57.550]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.550]                       fi <- file.info(pathname)
[08:24:57.550]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:57.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.550]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:57.550]                         fi[["size"]], fi[["mtime"]])
[08:24:57.550]                       stop(msg)
[08:24:57.550]                     }
[08:24:57.550]                     invisible(pathname)
[08:24:57.550]                   }
[08:24:57.550]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:57.550]                     rootPath = tempdir()) 
[08:24:57.550]                   {
[08:24:57.550]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:57.550]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:57.550]                       tmpdir = path, fileext = ".rds")
[08:24:57.550]                     save_rds(obj, file)
[08:24:57.550]                   }
[08:24:57.550]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:57.550]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.550]                   {
[08:24:57.550]                     inherits <- base::inherits
[08:24:57.550]                     invokeRestart <- base::invokeRestart
[08:24:57.550]                     is.null <- base::is.null
[08:24:57.550]                     muffled <- FALSE
[08:24:57.550]                     if (inherits(cond, "message")) {
[08:24:57.550]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:57.550]                       if (muffled) 
[08:24:57.550]                         invokeRestart("muffleMessage")
[08:24:57.550]                     }
[08:24:57.550]                     else if (inherits(cond, "warning")) {
[08:24:57.550]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:57.550]                       if (muffled) 
[08:24:57.550]                         invokeRestart("muffleWarning")
[08:24:57.550]                     }
[08:24:57.550]                     else if (inherits(cond, "condition")) {
[08:24:57.550]                       if (!is.null(pattern)) {
[08:24:57.550]                         computeRestarts <- base::computeRestarts
[08:24:57.550]                         grepl <- base::grepl
[08:24:57.550]                         restarts <- computeRestarts(cond)
[08:24:57.550]                         for (restart in restarts) {
[08:24:57.550]                           name <- restart$name
[08:24:57.550]                           if (is.null(name)) 
[08:24:57.550]                             next
[08:24:57.550]                           if (!grepl(pattern, name)) 
[08:24:57.550]                             next
[08:24:57.550]                           invokeRestart(restart)
[08:24:57.550]                           muffled <- TRUE
[08:24:57.550]                           break
[08:24:57.550]                         }
[08:24:57.550]                       }
[08:24:57.550]                     }
[08:24:57.550]                     invisible(muffled)
[08:24:57.550]                   }
[08:24:57.550]                   muffleCondition(cond)
[08:24:57.550]                 })
[08:24:57.550]             }))
[08:24:57.550]             future::FutureResult(value = ...future.value$value, 
[08:24:57.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.550]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.550]                     ...future.globalenv.names))
[08:24:57.550]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.550]         }, condition = base::local({
[08:24:57.550]             c <- base::c
[08:24:57.550]             inherits <- base::inherits
[08:24:57.550]             invokeRestart <- base::invokeRestart
[08:24:57.550]             length <- base::length
[08:24:57.550]             list <- base::list
[08:24:57.550]             seq.int <- base::seq.int
[08:24:57.550]             signalCondition <- base::signalCondition
[08:24:57.550]             sys.calls <- base::sys.calls
[08:24:57.550]             `[[` <- base::`[[`
[08:24:57.550]             `+` <- base::`+`
[08:24:57.550]             `<<-` <- base::`<<-`
[08:24:57.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.550]                   3L)]
[08:24:57.550]             }
[08:24:57.550]             function(cond) {
[08:24:57.550]                 is_error <- inherits(cond, "error")
[08:24:57.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.550]                   NULL)
[08:24:57.550]                 if (is_error) {
[08:24:57.550]                   sessionInformation <- function() {
[08:24:57.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.550]                       search = base::search(), system = base::Sys.info())
[08:24:57.550]                   }
[08:24:57.550]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.550]                     cond$call), session = sessionInformation(), 
[08:24:57.550]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.550]                   signalCondition(cond)
[08:24:57.550]                 }
[08:24:57.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.550]                 "immediateCondition"))) {
[08:24:57.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.550]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.550]                   if (TRUE && !signal) {
[08:24:57.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.550]                     {
[08:24:57.550]                       inherits <- base::inherits
[08:24:57.550]                       invokeRestart <- base::invokeRestart
[08:24:57.550]                       is.null <- base::is.null
[08:24:57.550]                       muffled <- FALSE
[08:24:57.550]                       if (inherits(cond, "message")) {
[08:24:57.550]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.550]                         if (muffled) 
[08:24:57.550]                           invokeRestart("muffleMessage")
[08:24:57.550]                       }
[08:24:57.550]                       else if (inherits(cond, "warning")) {
[08:24:57.550]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.550]                         if (muffled) 
[08:24:57.550]                           invokeRestart("muffleWarning")
[08:24:57.550]                       }
[08:24:57.550]                       else if (inherits(cond, "condition")) {
[08:24:57.550]                         if (!is.null(pattern)) {
[08:24:57.550]                           computeRestarts <- base::computeRestarts
[08:24:57.550]                           grepl <- base::grepl
[08:24:57.550]                           restarts <- computeRestarts(cond)
[08:24:57.550]                           for (restart in restarts) {
[08:24:57.550]                             name <- restart$name
[08:24:57.550]                             if (is.null(name)) 
[08:24:57.550]                               next
[08:24:57.550]                             if (!grepl(pattern, name)) 
[08:24:57.550]                               next
[08:24:57.550]                             invokeRestart(restart)
[08:24:57.550]                             muffled <- TRUE
[08:24:57.550]                             break
[08:24:57.550]                           }
[08:24:57.550]                         }
[08:24:57.550]                       }
[08:24:57.550]                       invisible(muffled)
[08:24:57.550]                     }
[08:24:57.550]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.550]                   }
[08:24:57.550]                 }
[08:24:57.550]                 else {
[08:24:57.550]                   if (TRUE) {
[08:24:57.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.550]                     {
[08:24:57.550]                       inherits <- base::inherits
[08:24:57.550]                       invokeRestart <- base::invokeRestart
[08:24:57.550]                       is.null <- base::is.null
[08:24:57.550]                       muffled <- FALSE
[08:24:57.550]                       if (inherits(cond, "message")) {
[08:24:57.550]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.550]                         if (muffled) 
[08:24:57.550]                           invokeRestart("muffleMessage")
[08:24:57.550]                       }
[08:24:57.550]                       else if (inherits(cond, "warning")) {
[08:24:57.550]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.550]                         if (muffled) 
[08:24:57.550]                           invokeRestart("muffleWarning")
[08:24:57.550]                       }
[08:24:57.550]                       else if (inherits(cond, "condition")) {
[08:24:57.550]                         if (!is.null(pattern)) {
[08:24:57.550]                           computeRestarts <- base::computeRestarts
[08:24:57.550]                           grepl <- base::grepl
[08:24:57.550]                           restarts <- computeRestarts(cond)
[08:24:57.550]                           for (restart in restarts) {
[08:24:57.550]                             name <- restart$name
[08:24:57.550]                             if (is.null(name)) 
[08:24:57.550]                               next
[08:24:57.550]                             if (!grepl(pattern, name)) 
[08:24:57.550]                               next
[08:24:57.550]                             invokeRestart(restart)
[08:24:57.550]                             muffled <- TRUE
[08:24:57.550]                             break
[08:24:57.550]                           }
[08:24:57.550]                         }
[08:24:57.550]                       }
[08:24:57.550]                       invisible(muffled)
[08:24:57.550]                     }
[08:24:57.550]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.550]                   }
[08:24:57.550]                 }
[08:24:57.550]             }
[08:24:57.550]         }))
[08:24:57.550]     }, error = function(ex) {
[08:24:57.550]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.550]                 ...future.rng), started = ...future.startTime, 
[08:24:57.550]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.550]             version = "1.8"), class = "FutureResult")
[08:24:57.550]     }, finally = {
[08:24:57.550]         if (!identical(...future.workdir, getwd())) 
[08:24:57.550]             setwd(...future.workdir)
[08:24:57.550]         {
[08:24:57.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.550]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.550]             }
[08:24:57.550]             base::options(...future.oldOptions)
[08:24:57.550]             if (.Platform$OS.type == "windows") {
[08:24:57.550]                 old_names <- names(...future.oldEnvVars)
[08:24:57.550]                 envs <- base::Sys.getenv()
[08:24:57.550]                 names <- names(envs)
[08:24:57.550]                 common <- intersect(names, old_names)
[08:24:57.550]                 added <- setdiff(names, old_names)
[08:24:57.550]                 removed <- setdiff(old_names, names)
[08:24:57.550]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.550]                   envs[common]]
[08:24:57.550]                 NAMES <- toupper(changed)
[08:24:57.550]                 args <- list()
[08:24:57.550]                 for (kk in seq_along(NAMES)) {
[08:24:57.550]                   name <- changed[[kk]]
[08:24:57.550]                   NAME <- NAMES[[kk]]
[08:24:57.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.550]                     next
[08:24:57.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.550]                 }
[08:24:57.550]                 NAMES <- toupper(added)
[08:24:57.550]                 for (kk in seq_along(NAMES)) {
[08:24:57.550]                   name <- added[[kk]]
[08:24:57.550]                   NAME <- NAMES[[kk]]
[08:24:57.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.550]                     next
[08:24:57.550]                   args[[name]] <- ""
[08:24:57.550]                 }
[08:24:57.550]                 NAMES <- toupper(removed)
[08:24:57.550]                 for (kk in seq_along(NAMES)) {
[08:24:57.550]                   name <- removed[[kk]]
[08:24:57.550]                   NAME <- NAMES[[kk]]
[08:24:57.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.550]                     next
[08:24:57.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.550]                 }
[08:24:57.550]                 if (length(args) > 0) 
[08:24:57.550]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.550]             }
[08:24:57.550]             else {
[08:24:57.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.550]             }
[08:24:57.550]             {
[08:24:57.550]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.550]                   0L) {
[08:24:57.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.550]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.550]                   base::options(opts)
[08:24:57.550]                 }
[08:24:57.550]                 {
[08:24:57.550]                   {
[08:24:57.550]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:57.550]                     NULL
[08:24:57.550]                   }
[08:24:57.550]                   options(future.plan = NULL)
[08:24:57.550]                   if (is.na(NA_character_)) 
[08:24:57.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.550]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.550]                     .init = FALSE)
[08:24:57.550]                 }
[08:24:57.550]             }
[08:24:57.550]         }
[08:24:57.550]     })
[08:24:57.550]     if (TRUE) {
[08:24:57.550]         base::sink(type = "output", split = FALSE)
[08:24:57.550]         if (TRUE) {
[08:24:57.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.550]         }
[08:24:57.550]         else {
[08:24:57.550]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.550]         }
[08:24:57.550]         base::close(...future.stdout)
[08:24:57.550]         ...future.stdout <- NULL
[08:24:57.550]     }
[08:24:57.550]     ...future.result$conditions <- ...future.conditions
[08:24:57.550]     ...future.result$finished <- base::Sys.time()
[08:24:57.550]     ...future.result
[08:24:57.550] }
[08:24:57.553] assign_globals() ...
[08:24:57.553] List of 5
[08:24:57.553]  $ ...future.FUN            :function (object, ...)  
[08:24:57.553]  $ future.call.arguments    : list()
[08:24:57.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.553]  $ ...future.elements_ii    :List of 2
[08:24:57.553]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:57.553]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.553]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.553]   ..$ :'data.frame':	18 obs. of  2 variables:
[08:24:57.553]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.553]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.553]  $ ...future.seeds_ii       : NULL
[08:24:57.553]  $ ...future.globals.maxSize: NULL
[08:24:57.553]  - attr(*, "where")=List of 5
[08:24:57.553]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.553]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.553]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.553]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.553]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.553]  - attr(*, "resolved")= logi FALSE
[08:24:57.553]  - attr(*, "total_size")= num 15670
[08:24:57.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.553]  - attr(*, "already-done")= logi TRUE
[08:24:57.564] - copied ‘...future.FUN’ to environment
[08:24:57.564] - copied ‘future.call.arguments’ to environment
[08:24:57.565] - copied ‘...future.elements_ii’ to environment
[08:24:57.565] - copied ‘...future.seeds_ii’ to environment
[08:24:57.565] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.565] assign_globals() ... done
[08:24:57.565] requestCore(): workers = 2
[08:24:57.571] MulticoreFuture started
[08:24:57.572] - Launch lazy future ... done
[08:24:57.572] run() for ‘MulticoreFuture’ ... done
[08:24:57.572] plan(): Setting new future strategy stack:
[08:24:57.572] Created future:
[08:24:57.572] List of future strategies:
[08:24:57.572] 1. sequential:
[08:24:57.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.572]    - tweaked: FALSE
[08:24:57.572]    - call: NULL
[08:24:57.573] plan(): nbrOfWorkers() = 1
[08:24:57.577] plan(): Setting new future strategy stack:
[08:24:57.578] List of future strategies:
[08:24:57.578] 1. multicore:
[08:24:57.578]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.578]    - tweaked: FALSE
[08:24:57.578]    - call: plan(strategy)
[08:24:57.585] plan(): nbrOfWorkers() = 2
[08:24:57.573] MulticoreFuture:
[08:24:57.573] Label: ‘future_by-2’
[08:24:57.573] Expression:
[08:24:57.573] {
[08:24:57.573]     do.call(function(...) {
[08:24:57.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.573]             on.exit(options(oopts), add = TRUE)
[08:24:57.573]         }
[08:24:57.573]         {
[08:24:57.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.573]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.573]             })
[08:24:57.573]         }
[08:24:57.573]     }, args = future.call.arguments)
[08:24:57.573] }
[08:24:57.573] Lazy evaluation: FALSE
[08:24:57.573] Asynchronous evaluation: TRUE
[08:24:57.573] Local evaluation: TRUE
[08:24:57.573] Environment: R_GlobalEnv
[08:24:57.573] Capture standard output: TRUE
[08:24:57.573] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.573] Globals: 5 objects totaling 1.44 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.02 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.573] Packages: <none>
[08:24:57.573] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.573] Resolved: FALSE
[08:24:57.573] Value: <not collected>
[08:24:57.573] Conditions captured: <none>
[08:24:57.573] Early signaling: FALSE
[08:24:57.573] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.573] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.585] Chunk #2 of 2 ... DONE
[08:24:57.586] Launching 2 futures (chunks) ... DONE
[08:24:57.586] Resolving 2 futures (chunks) ...
[08:24:57.586] resolve() on list ...
[08:24:57.586]  recursive: 0
[08:24:57.586]  length: 2
[08:24:57.586] 
[08:24:57.587] Future #1
[08:24:57.587] result() for MulticoreFuture ...
[08:24:57.589] result() for MulticoreFuture ...
[08:24:57.589] result() for MulticoreFuture ... done
[08:24:57.589] result() for MulticoreFuture ... done
[08:24:57.590] result() for MulticoreFuture ...
[08:24:57.590] result() for MulticoreFuture ... done
[08:24:57.592] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:57.593] - nx: 2
[08:24:57.593] - relay: TRUE
[08:24:57.593] - stdout: TRUE
[08:24:57.594] - signal: TRUE
[08:24:57.594] - resignal: FALSE
[08:24:57.594] - force: TRUE
[08:24:57.595] - relayed: [n=2] FALSE, FALSE
[08:24:57.595] - queued futures: [n=2] FALSE, FALSE
[08:24:57.595]  - until=1
[08:24:57.596]  - relaying element #1
[08:24:57.596] result() for MulticoreFuture ...
[08:24:57.596] result() for MulticoreFuture ... done
[08:24:57.596] result() for MulticoreFuture ...
[08:24:57.597] result() for MulticoreFuture ... done
[08:24:57.597] result() for MulticoreFuture ...
[08:24:57.597] result() for MulticoreFuture ... done
[08:24:57.597] result() for MulticoreFuture ...
[08:24:57.598] result() for MulticoreFuture ... done
[08:24:57.598] - relayed: [n=2] TRUE, FALSE
[08:24:57.598] - queued futures: [n=2] TRUE, FALSE
[08:24:57.598] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:57.599]  length: 1 (resolved future 1)
[08:24:57.599] Future #2
[08:24:57.599] result() for MulticoreFuture ...
[08:24:57.601] result() for MulticoreFuture ...
[08:24:57.601] result() for MulticoreFuture ... done
[08:24:57.601] result() for MulticoreFuture ... done
[08:24:57.601] result() for MulticoreFuture ...
[08:24:57.602] result() for MulticoreFuture ... done
[08:24:57.602] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:57.602] - nx: 2
[08:24:57.602] - relay: TRUE
[08:24:57.602] - stdout: TRUE
[08:24:57.602] - signal: TRUE
[08:24:57.602] - resignal: FALSE
[08:24:57.603] - force: TRUE
[08:24:57.603] - relayed: [n=2] TRUE, FALSE
[08:24:57.603] - queued futures: [n=2] TRUE, FALSE
[08:24:57.603]  - until=2
[08:24:57.603]  - relaying element #2
[08:24:57.603] result() for MulticoreFuture ...
[08:24:57.603] result() for MulticoreFuture ... done
[08:24:57.604] result() for MulticoreFuture ...
[08:24:57.604] result() for MulticoreFuture ... done
[08:24:57.604] result() for MulticoreFuture ...
[08:24:57.604] result() for MulticoreFuture ... done
[08:24:57.604] result() for MulticoreFuture ...
[08:24:57.604] result() for MulticoreFuture ... done
[08:24:57.604] - relayed: [n=2] TRUE, TRUE
[08:24:57.604] - queued futures: [n=2] TRUE, TRUE
[08:24:57.604] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:57.605]  length: 0 (resolved future 2)
[08:24:57.605] Relaying remaining futures
[08:24:57.605] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.605] - nx: 2
[08:24:57.605] - relay: TRUE
[08:24:57.605] - stdout: TRUE
[08:24:57.605] - signal: TRUE
[08:24:57.605] - resignal: FALSE
[08:24:57.605] - force: TRUE
[08:24:57.606] - relayed: [n=2] TRUE, TRUE
[08:24:57.606] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:57.606] - relayed: [n=2] TRUE, TRUE
[08:24:57.606] - queued futures: [n=2] TRUE, TRUE
[08:24:57.606] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.606] resolve() on list ... DONE
[08:24:57.606] result() for MulticoreFuture ...
[08:24:57.606] result() for MulticoreFuture ... done
[08:24:57.607] result() for MulticoreFuture ...
[08:24:57.607] result() for MulticoreFuture ... done
[08:24:57.607] result() for MulticoreFuture ...
[08:24:57.607] result() for MulticoreFuture ... done
[08:24:57.607] result() for MulticoreFuture ...
[08:24:57.607] result() for MulticoreFuture ... done
[08:24:57.607]  - Number of value chunks collected: 2
[08:24:57.607] Resolving 2 futures (chunks) ... DONE
[08:24:57.607] Reducing values from 2 chunks ...
[08:24:57.608]  - Number of values collected after concatenation: 3
[08:24:57.608]  - Number of values expected: 3
[08:24:57.608] Reducing values from 2 chunks ... DONE
[08:24:57.608] future_lapply() ... DONE
[08:24:57.608] future_by_internal() ... DONE
[08:24:57.608] future_by_internal() ...
[08:24:57.609] future_lapply() ...
[08:24:57.611] Number of chunks: 2
[08:24:57.612] getGlobalsAndPackagesXApply() ...
[08:24:57.612]  - future.globals: TRUE
[08:24:57.612] getGlobalsAndPackages() ...
[08:24:57.612] Searching for globals...
[08:24:57.613] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:57.613] Searching for globals ... DONE
[08:24:57.613] Resolving globals: FALSE
[08:24:57.614] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:57.614] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:57.614] - globals: [1] ‘FUN’
[08:24:57.614] 
[08:24:57.615] getGlobalsAndPackages() ... DONE
[08:24:57.615]  - globals found/used: [n=1] ‘FUN’
[08:24:57.615]  - needed namespaces: [n=0] 
[08:24:57.615] Finding globals ... DONE
[08:24:57.615]  - use_args: TRUE
[08:24:57.615]  - Getting '...' globals ...
[08:24:57.615] resolve() on list ...
[08:24:57.616]  recursive: 0
[08:24:57.616]  length: 1
[08:24:57.616]  elements: ‘...’
[08:24:57.616]  length: 0 (resolved future 1)
[08:24:57.616] resolve() on list ... DONE
[08:24:57.616]    - '...' content: [n=1] ‘digits’
[08:24:57.616] List of 1
[08:24:57.616]  $ ...:List of 1
[08:24:57.616]   ..$ digits: int 2
[08:24:57.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.616]  - attr(*, "where")=List of 1
[08:24:57.616]   ..$ ...:<environment: 0x557b25c0a370> 
[08:24:57.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.616]  - attr(*, "resolved")= logi TRUE
[08:24:57.616]  - attr(*, "total_size")= num NA
[08:24:57.619]  - Getting '...' globals ... DONE
[08:24:57.622] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.622] List of 2
[08:24:57.622]  $ ...future.FUN:function (object, ...)  
[08:24:57.622]  $ ...          :List of 1
[08:24:57.622]   ..$ digits: int 2
[08:24:57.622]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.622]  - attr(*, "where")=List of 2
[08:24:57.622]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.622]   ..$ ...          :<environment: 0x557b25c0a370> 
[08:24:57.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.622]  - attr(*, "resolved")= logi FALSE
[08:24:57.622]  - attr(*, "total_size")= num 13284
[08:24:57.626] Packages to be attached in all futures: [n=0] 
[08:24:57.626] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.626] Number of futures (= number of chunks): 2
[08:24:57.626] Launching 2 futures (chunks) ...
[08:24:57.626] Chunk #1 of 2 ...
[08:24:57.626]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.627] getGlobalsAndPackages() ...
[08:24:57.627] Searching for globals...
[08:24:57.627] 
[08:24:57.627] Searching for globals ... DONE
[08:24:57.627] - globals: [0] <none>
[08:24:57.627] getGlobalsAndPackages() ... DONE
[08:24:57.627]    + additional globals found: [n=0] 
[08:24:57.627]    + additional namespaces needed: [n=0] 
[08:24:57.627]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.628]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:57.628]  - seeds: <none>
[08:24:57.628]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.628] getGlobalsAndPackages() ...
[08:24:57.628] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.628] Resolving globals: FALSE
[08:24:57.628] Tweak future expression to call with '...' arguments ...
[08:24:57.628] {
[08:24:57.628]     do.call(function(...) {
[08:24:57.628]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.628]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.628]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.628]             on.exit(options(oopts), add = TRUE)
[08:24:57.628]         }
[08:24:57.628]         {
[08:24:57.628]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.628]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.628]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.628]             })
[08:24:57.628]         }
[08:24:57.628]     }, args = future.call.arguments)
[08:24:57.628] }
[08:24:57.629] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.629] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.629] 
[08:24:57.629] getGlobalsAndPackages() ... DONE
[08:24:57.630] run() for ‘Future’ ...
[08:24:57.630] - state: ‘created’
[08:24:57.630] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.631] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:57.632]   - Field: ‘label’
[08:24:57.632]   - Field: ‘local’
[08:24:57.632]   - Field: ‘owner’
[08:24:57.632]   - Field: ‘envir’
[08:24:57.632]   - Field: ‘workers’
[08:24:57.632]   - Field: ‘packages’
[08:24:57.632]   - Field: ‘gc’
[08:24:57.632]   - Field: ‘job’
[08:24:57.632]   - Field: ‘conditions’
[08:24:57.633]   - Field: ‘expr’
[08:24:57.633]   - Field: ‘uuid’
[08:24:57.633]   - Field: ‘seed’
[08:24:57.633]   - Field: ‘version’
[08:24:57.633]   - Field: ‘result’
[08:24:57.633]   - Field: ‘asynchronous’
[08:24:57.633]   - Field: ‘calls’
[08:24:57.633]   - Field: ‘globals’
[08:24:57.633]   - Field: ‘stdout’
[08:24:57.633]   - Field: ‘earlySignal’
[08:24:57.633]   - Field: ‘lazy’
[08:24:57.634]   - Field: ‘state’
[08:24:57.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:57.634] - Launch lazy future ...
[08:24:57.634] Packages needed by the future expression (n = 0): <none>
[08:24:57.634] Packages needed by future strategies (n = 0): <none>
[08:24:57.635] {
[08:24:57.635]     {
[08:24:57.635]         {
[08:24:57.635]             ...future.startTime <- base::Sys.time()
[08:24:57.635]             {
[08:24:57.635]                 {
[08:24:57.635]                   {
[08:24:57.635]                     {
[08:24:57.635]                       base::local({
[08:24:57.635]                         has_future <- base::requireNamespace("future", 
[08:24:57.635]                           quietly = TRUE)
[08:24:57.635]                         if (has_future) {
[08:24:57.635]                           ns <- base::getNamespace("future")
[08:24:57.635]                           version <- ns[[".package"]][["version"]]
[08:24:57.635]                           if (is.null(version)) 
[08:24:57.635]                             version <- utils::packageVersion("future")
[08:24:57.635]                         }
[08:24:57.635]                         else {
[08:24:57.635]                           version <- NULL
[08:24:57.635]                         }
[08:24:57.635]                         if (!has_future || version < "1.8.0") {
[08:24:57.635]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.635]                             "", base::R.version$version.string), 
[08:24:57.635]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:57.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.635]                               "release", "version")], collapse = " "), 
[08:24:57.635]                             hostname = base::Sys.info()[["nodename"]])
[08:24:57.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.635]                             info)
[08:24:57.635]                           info <- base::paste(info, collapse = "; ")
[08:24:57.635]                           if (!has_future) {
[08:24:57.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.635]                               info)
[08:24:57.635]                           }
[08:24:57.635]                           else {
[08:24:57.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.635]                               info, version)
[08:24:57.635]                           }
[08:24:57.635]                           base::stop(msg)
[08:24:57.635]                         }
[08:24:57.635]                       })
[08:24:57.635]                     }
[08:24:57.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:57.635]                     base::options(mc.cores = 1L)
[08:24:57.635]                   }
[08:24:57.635]                   ...future.strategy.old <- future::plan("list")
[08:24:57.635]                   options(future.plan = NULL)
[08:24:57.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.635]                 }
[08:24:57.635]                 ...future.workdir <- getwd()
[08:24:57.635]             }
[08:24:57.635]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.635]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.635]         }
[08:24:57.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.635]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:57.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.635]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.635]             base::names(...future.oldOptions))
[08:24:57.635]     }
[08:24:57.635]     if (FALSE) {
[08:24:57.635]     }
[08:24:57.635]     else {
[08:24:57.635]         if (TRUE) {
[08:24:57.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.635]                 open = "w")
[08:24:57.635]         }
[08:24:57.635]         else {
[08:24:57.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.635]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.635]         }
[08:24:57.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.635]             base::sink(type = "output", split = FALSE)
[08:24:57.635]             base::close(...future.stdout)
[08:24:57.635]         }, add = TRUE)
[08:24:57.635]     }
[08:24:57.635]     ...future.frame <- base::sys.nframe()
[08:24:57.635]     ...future.conditions <- base::list()
[08:24:57.635]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.635]     if (FALSE) {
[08:24:57.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.635]     }
[08:24:57.635]     ...future.result <- base::tryCatch({
[08:24:57.635]         base::withCallingHandlers({
[08:24:57.635]             ...future.value <- base::withVisible(base::local({
[08:24:57.635]                 withCallingHandlers({
[08:24:57.635]                   {
[08:24:57.635]                     do.call(function(...) {
[08:24:57.635]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.635]                       if (!identical(...future.globals.maxSize.org, 
[08:24:57.635]                         ...future.globals.maxSize)) {
[08:24:57.635]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.635]                         on.exit(options(oopts), add = TRUE)
[08:24:57.635]                       }
[08:24:57.635]                       {
[08:24:57.635]                         lapply(seq_along(...future.elements_ii), 
[08:24:57.635]                           FUN = function(jj) {
[08:24:57.635]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.635]                             ...future.FUN(...future.X_jj, ...)
[08:24:57.635]                           })
[08:24:57.635]                       }
[08:24:57.635]                     }, args = future.call.arguments)
[08:24:57.635]                   }
[08:24:57.635]                 }, immediateCondition = function(cond) {
[08:24:57.635]                   save_rds <- function (object, pathname, ...) 
[08:24:57.635]                   {
[08:24:57.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:57.635]                     if (file_test("-f", pathname_tmp)) {
[08:24:57.635]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:57.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.635]                         fi_tmp[["mtime"]])
[08:24:57.635]                     }
[08:24:57.635]                     tryCatch({
[08:24:57.635]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:57.635]                     }, error = function(ex) {
[08:24:57.635]                       msg <- conditionMessage(ex)
[08:24:57.635]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:57.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.635]                         fi_tmp[["mtime"]], msg)
[08:24:57.635]                       ex$message <- msg
[08:24:57.635]                       stop(ex)
[08:24:57.635]                     })
[08:24:57.635]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:57.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:57.635]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:57.635]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.635]                       fi <- file.info(pathname)
[08:24:57.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:57.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:57.635]                         fi[["size"]], fi[["mtime"]])
[08:24:57.635]                       stop(msg)
[08:24:57.635]                     }
[08:24:57.635]                     invisible(pathname)
[08:24:57.635]                   }
[08:24:57.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:57.635]                     rootPath = tempdir()) 
[08:24:57.635]                   {
[08:24:57.635]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:57.635]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:57.635]                       tmpdir = path, fileext = ".rds")
[08:24:57.635]                     save_rds(obj, file)
[08:24:57.635]                   }
[08:24:57.635]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:57.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.635]                   {
[08:24:57.635]                     inherits <- base::inherits
[08:24:57.635]                     invokeRestart <- base::invokeRestart
[08:24:57.635]                     is.null <- base::is.null
[08:24:57.635]                     muffled <- FALSE
[08:24:57.635]                     if (inherits(cond, "message")) {
[08:24:57.635]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:57.635]                       if (muffled) 
[08:24:57.635]                         invokeRestart("muffleMessage")
[08:24:57.635]                     }
[08:24:57.635]                     else if (inherits(cond, "warning")) {
[08:24:57.635]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:57.635]                       if (muffled) 
[08:24:57.635]                         invokeRestart("muffleWarning")
[08:24:57.635]                     }
[08:24:57.635]                     else if (inherits(cond, "condition")) {
[08:24:57.635]                       if (!is.null(pattern)) {
[08:24:57.635]                         computeRestarts <- base::computeRestarts
[08:24:57.635]                         grepl <- base::grepl
[08:24:57.635]                         restarts <- computeRestarts(cond)
[08:24:57.635]                         for (restart in restarts) {
[08:24:57.635]                           name <- restart$name
[08:24:57.635]                           if (is.null(name)) 
[08:24:57.635]                             next
[08:24:57.635]                           if (!grepl(pattern, name)) 
[08:24:57.635]                             next
[08:24:57.635]                           invokeRestart(restart)
[08:24:57.635]                           muffled <- TRUE
[08:24:57.635]                           break
[08:24:57.635]                         }
[08:24:57.635]                       }
[08:24:57.635]                     }
[08:24:57.635]                     invisible(muffled)
[08:24:57.635]                   }
[08:24:57.635]                   muffleCondition(cond)
[08:24:57.635]                 })
[08:24:57.635]             }))
[08:24:57.635]             future::FutureResult(value = ...future.value$value, 
[08:24:57.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.635]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.635]                     ...future.globalenv.names))
[08:24:57.635]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.635]         }, condition = base::local({
[08:24:57.635]             c <- base::c
[08:24:57.635]             inherits <- base::inherits
[08:24:57.635]             invokeRestart <- base::invokeRestart
[08:24:57.635]             length <- base::length
[08:24:57.635]             list <- base::list
[08:24:57.635]             seq.int <- base::seq.int
[08:24:57.635]             signalCondition <- base::signalCondition
[08:24:57.635]             sys.calls <- base::sys.calls
[08:24:57.635]             `[[` <- base::`[[`
[08:24:57.635]             `+` <- base::`+`
[08:24:57.635]             `<<-` <- base::`<<-`
[08:24:57.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.635]                   3L)]
[08:24:57.635]             }
[08:24:57.635]             function(cond) {
[08:24:57.635]                 is_error <- inherits(cond, "error")
[08:24:57.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.635]                   NULL)
[08:24:57.635]                 if (is_error) {
[08:24:57.635]                   sessionInformation <- function() {
[08:24:57.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.635]                       search = base::search(), system = base::Sys.info())
[08:24:57.635]                   }
[08:24:57.635]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.635]                     cond$call), session = sessionInformation(), 
[08:24:57.635]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.635]                   signalCondition(cond)
[08:24:57.635]                 }
[08:24:57.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.635]                 "immediateCondition"))) {
[08:24:57.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.635]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.635]                   if (TRUE && !signal) {
[08:24:57.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.635]                     {
[08:24:57.635]                       inherits <- base::inherits
[08:24:57.635]                       invokeRestart <- base::invokeRestart
[08:24:57.635]                       is.null <- base::is.null
[08:24:57.635]                       muffled <- FALSE
[08:24:57.635]                       if (inherits(cond, "message")) {
[08:24:57.635]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.635]                         if (muffled) 
[08:24:57.635]                           invokeRestart("muffleMessage")
[08:24:57.635]                       }
[08:24:57.635]                       else if (inherits(cond, "warning")) {
[08:24:57.635]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.635]                         if (muffled) 
[08:24:57.635]                           invokeRestart("muffleWarning")
[08:24:57.635]                       }
[08:24:57.635]                       else if (inherits(cond, "condition")) {
[08:24:57.635]                         if (!is.null(pattern)) {
[08:24:57.635]                           computeRestarts <- base::computeRestarts
[08:24:57.635]                           grepl <- base::grepl
[08:24:57.635]                           restarts <- computeRestarts(cond)
[08:24:57.635]                           for (restart in restarts) {
[08:24:57.635]                             name <- restart$name
[08:24:57.635]                             if (is.null(name)) 
[08:24:57.635]                               next
[08:24:57.635]                             if (!grepl(pattern, name)) 
[08:24:57.635]                               next
[08:24:57.635]                             invokeRestart(restart)
[08:24:57.635]                             muffled <- TRUE
[08:24:57.635]                             break
[08:24:57.635]                           }
[08:24:57.635]                         }
[08:24:57.635]                       }
[08:24:57.635]                       invisible(muffled)
[08:24:57.635]                     }
[08:24:57.635]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.635]                   }
[08:24:57.635]                 }
[08:24:57.635]                 else {
[08:24:57.635]                   if (TRUE) {
[08:24:57.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.635]                     {
[08:24:57.635]                       inherits <- base::inherits
[08:24:57.635]                       invokeRestart <- base::invokeRestart
[08:24:57.635]                       is.null <- base::is.null
[08:24:57.635]                       muffled <- FALSE
[08:24:57.635]                       if (inherits(cond, "message")) {
[08:24:57.635]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.635]                         if (muffled) 
[08:24:57.635]                           invokeRestart("muffleMessage")
[08:24:57.635]                       }
[08:24:57.635]                       else if (inherits(cond, "warning")) {
[08:24:57.635]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.635]                         if (muffled) 
[08:24:57.635]                           invokeRestart("muffleWarning")
[08:24:57.635]                       }
[08:24:57.635]                       else if (inherits(cond, "condition")) {
[08:24:57.635]                         if (!is.null(pattern)) {
[08:24:57.635]                           computeRestarts <- base::computeRestarts
[08:24:57.635]                           grepl <- base::grepl
[08:24:57.635]                           restarts <- computeRestarts(cond)
[08:24:57.635]                           for (restart in restarts) {
[08:24:57.635]                             name <- restart$name
[08:24:57.635]                             if (is.null(name)) 
[08:24:57.635]                               next
[08:24:57.635]                             if (!grepl(pattern, name)) 
[08:24:57.635]                               next
[08:24:57.635]                             invokeRestart(restart)
[08:24:57.635]                             muffled <- TRUE
[08:24:57.635]                             break
[08:24:57.635]                           }
[08:24:57.635]                         }
[08:24:57.635]                       }
[08:24:57.635]                       invisible(muffled)
[08:24:57.635]                     }
[08:24:57.635]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.635]                   }
[08:24:57.635]                 }
[08:24:57.635]             }
[08:24:57.635]         }))
[08:24:57.635]     }, error = function(ex) {
[08:24:57.635]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.635]                 ...future.rng), started = ...future.startTime, 
[08:24:57.635]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.635]             version = "1.8"), class = "FutureResult")
[08:24:57.635]     }, finally = {
[08:24:57.635]         if (!identical(...future.workdir, getwd())) 
[08:24:57.635]             setwd(...future.workdir)
[08:24:57.635]         {
[08:24:57.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.635]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.635]             }
[08:24:57.635]             base::options(...future.oldOptions)
[08:24:57.635]             if (.Platform$OS.type == "windows") {
[08:24:57.635]                 old_names <- names(...future.oldEnvVars)
[08:24:57.635]                 envs <- base::Sys.getenv()
[08:24:57.635]                 names <- names(envs)
[08:24:57.635]                 common <- intersect(names, old_names)
[08:24:57.635]                 added <- setdiff(names, old_names)
[08:24:57.635]                 removed <- setdiff(old_names, names)
[08:24:57.635]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.635]                   envs[common]]
[08:24:57.635]                 NAMES <- toupper(changed)
[08:24:57.635]                 args <- list()
[08:24:57.635]                 for (kk in seq_along(NAMES)) {
[08:24:57.635]                   name <- changed[[kk]]
[08:24:57.635]                   NAME <- NAMES[[kk]]
[08:24:57.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.635]                     next
[08:24:57.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.635]                 }
[08:24:57.635]                 NAMES <- toupper(added)
[08:24:57.635]                 for (kk in seq_along(NAMES)) {
[08:24:57.635]                   name <- added[[kk]]
[08:24:57.635]                   NAME <- NAMES[[kk]]
[08:24:57.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.635]                     next
[08:24:57.635]                   args[[name]] <- ""
[08:24:57.635]                 }
[08:24:57.635]                 NAMES <- toupper(removed)
[08:24:57.635]                 for (kk in seq_along(NAMES)) {
[08:24:57.635]                   name <- removed[[kk]]
[08:24:57.635]                   NAME <- NAMES[[kk]]
[08:24:57.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.635]                     next
[08:24:57.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.635]                 }
[08:24:57.635]                 if (length(args) > 0) 
[08:24:57.635]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.635]             }
[08:24:57.635]             else {
[08:24:57.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.635]             }
[08:24:57.635]             {
[08:24:57.635]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.635]                   0L) {
[08:24:57.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.635]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.635]                   base::options(opts)
[08:24:57.635]                 }
[08:24:57.635]                 {
[08:24:57.635]                   {
[08:24:57.635]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:57.635]                     NULL
[08:24:57.635]                   }
[08:24:57.635]                   options(future.plan = NULL)
[08:24:57.635]                   if (is.na(NA_character_)) 
[08:24:57.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.635]                     .init = FALSE)
[08:24:57.635]                 }
[08:24:57.635]             }
[08:24:57.635]         }
[08:24:57.635]     })
[08:24:57.635]     if (TRUE) {
[08:24:57.635]         base::sink(type = "output", split = FALSE)
[08:24:57.635]         if (TRUE) {
[08:24:57.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.635]         }
[08:24:57.635]         else {
[08:24:57.635]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.635]         }
[08:24:57.635]         base::close(...future.stdout)
[08:24:57.635]         ...future.stdout <- NULL
[08:24:57.635]     }
[08:24:57.635]     ...future.result$conditions <- ...future.conditions
[08:24:57.635]     ...future.result$finished <- base::Sys.time()
[08:24:57.635]     ...future.result
[08:24:57.635] }
[08:24:57.637] assign_globals() ...
[08:24:57.637] List of 5
[08:24:57.637]  $ ...future.FUN            :function (object, ...)  
[08:24:57.637]  $ future.call.arguments    :List of 1
[08:24:57.637]   ..$ digits: int 2
[08:24:57.637]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.637]  $ ...future.elements_ii    :List of 3
[08:24:57.637]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[08:24:57.637]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[08:24:57.637]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[08:24:57.637]  $ ...future.seeds_ii       : NULL
[08:24:57.637]  $ ...future.globals.maxSize: NULL
[08:24:57.637]  - attr(*, "where")=List of 5
[08:24:57.637]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.637]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.637]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.637]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.637]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.637]  - attr(*, "resolved")= logi FALSE
[08:24:57.637]  - attr(*, "total_size")= num 13284
[08:24:57.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.637]  - attr(*, "already-done")= logi TRUE
[08:24:57.645] - copied ‘...future.FUN’ to environment
[08:24:57.645] - copied ‘future.call.arguments’ to environment
[08:24:57.646] - copied ‘...future.elements_ii’ to environment
[08:24:57.646] - copied ‘...future.seeds_ii’ to environment
[08:24:57.646] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.646] assign_globals() ... done
[08:24:57.646] requestCore(): workers = 2
[08:24:57.649] MulticoreFuture started
[08:24:57.649] - Launch lazy future ... done
[08:24:57.650] run() for ‘MulticoreFuture’ ... done
[08:24:57.650] plan(): Setting new future strategy stack:
[08:24:57.650] Created future:
[08:24:57.650] List of future strategies:
[08:24:57.650] 1. sequential:
[08:24:57.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.650]    - tweaked: FALSE
[08:24:57.650]    - call: NULL
[08:24:57.652] plan(): nbrOfWorkers() = 1
[08:24:57.657] plan(): Setting new future strategy stack:
[08:24:57.657] List of future strategies:
[08:24:57.657] 1. multicore:
[08:24:57.657]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.657]    - tweaked: FALSE
[08:24:57.657]    - call: plan(strategy)
[08:24:57.661] plan(): nbrOfWorkers() = 2
[08:24:57.651] MulticoreFuture:
[08:24:57.651] Label: ‘future_by-1’
[08:24:57.651] Expression:
[08:24:57.651] {
[08:24:57.651]     do.call(function(...) {
[08:24:57.651]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.651]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.651]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.651]             on.exit(options(oopts), add = TRUE)
[08:24:57.651]         }
[08:24:57.651]         {
[08:24:57.651]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.651]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.651]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.651]             })
[08:24:57.651]         }
[08:24:57.651]     }, args = future.call.arguments)
[08:24:57.651] }
[08:24:57.651] Lazy evaluation: FALSE
[08:24:57.651] Asynchronous evaluation: TRUE
[08:24:57.651] Local evaluation: TRUE
[08:24:57.651] Environment: R_GlobalEnv
[08:24:57.651] Capture standard output: TRUE
[08:24:57.651] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.651] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.651] Packages: <none>
[08:24:57.651] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.651] Resolved: TRUE
[08:24:57.651] Value: <not collected>
[08:24:57.651] Conditions captured: <none>
[08:24:57.651] Early signaling: FALSE
[08:24:57.651] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.651] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.663] Chunk #1 of 2 ... DONE
[08:24:57.663] Chunk #2 of 2 ...
[08:24:57.663]  - Finding globals in 'X' for chunk #2 ...
[08:24:57.663] getGlobalsAndPackages() ...
[08:24:57.664] Searching for globals...
[08:24:57.664] 
[08:24:57.665] Searching for globals ... DONE
[08:24:57.665] - globals: [0] <none>
[08:24:57.665] getGlobalsAndPackages() ... DONE
[08:24:57.665]    + additional globals found: [n=0] 
[08:24:57.665]    + additional namespaces needed: [n=0] 
[08:24:57.666]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:57.666]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:57.666]  - seeds: <none>
[08:24:57.666]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.666] getGlobalsAndPackages() ...
[08:24:57.666] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.667] Resolving globals: FALSE
[08:24:57.667] Tweak future expression to call with '...' arguments ...
[08:24:57.667] {
[08:24:57.667]     do.call(function(...) {
[08:24:57.667]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.667]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.667]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.667]             on.exit(options(oopts), add = TRUE)
[08:24:57.667]         }
[08:24:57.667]         {
[08:24:57.667]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.667]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.667]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.667]             })
[08:24:57.667]         }
[08:24:57.667]     }, args = future.call.arguments)
[08:24:57.667] }
[08:24:57.667] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.668] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.668] 
[08:24:57.668] getGlobalsAndPackages() ... DONE
[08:24:57.669] run() for ‘Future’ ...
[08:24:57.669] - state: ‘created’
[08:24:57.669] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.672] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:57.673]   - Field: ‘label’
[08:24:57.673]   - Field: ‘local’
[08:24:57.673]   - Field: ‘owner’
[08:24:57.673]   - Field: ‘envir’
[08:24:57.673]   - Field: ‘workers’
[08:24:57.673]   - Field: ‘packages’
[08:24:57.674]   - Field: ‘gc’
[08:24:57.674]   - Field: ‘job’
[08:24:57.674]   - Field: ‘conditions’
[08:24:57.674]   - Field: ‘expr’
[08:24:57.674]   - Field: ‘uuid’
[08:24:57.674]   - Field: ‘seed’
[08:24:57.674]   - Field: ‘version’
[08:24:57.674]   - Field: ‘result’
[08:24:57.675]   - Field: ‘asynchronous’
[08:24:57.675]   - Field: ‘calls’
[08:24:57.675]   - Field: ‘globals’
[08:24:57.675]   - Field: ‘stdout’
[08:24:57.675]   - Field: ‘earlySignal’
[08:24:57.675]   - Field: ‘lazy’
[08:24:57.675]   - Field: ‘state’
[08:24:57.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:57.676] - Launch lazy future ...
[08:24:57.676] Packages needed by the future expression (n = 0): <none>
[08:24:57.676] Packages needed by future strategies (n = 0): <none>
[08:24:57.677] {
[08:24:57.677]     {
[08:24:57.677]         {
[08:24:57.677]             ...future.startTime <- base::Sys.time()
[08:24:57.677]             {
[08:24:57.677]                 {
[08:24:57.677]                   {
[08:24:57.677]                     {
[08:24:57.677]                       base::local({
[08:24:57.677]                         has_future <- base::requireNamespace("future", 
[08:24:57.677]                           quietly = TRUE)
[08:24:57.677]                         if (has_future) {
[08:24:57.677]                           ns <- base::getNamespace("future")
[08:24:57.677]                           version <- ns[[".package"]][["version"]]
[08:24:57.677]                           if (is.null(version)) 
[08:24:57.677]                             version <- utils::packageVersion("future")
[08:24:57.677]                         }
[08:24:57.677]                         else {
[08:24:57.677]                           version <- NULL
[08:24:57.677]                         }
[08:24:57.677]                         if (!has_future || version < "1.8.0") {
[08:24:57.677]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.677]                             "", base::R.version$version.string), 
[08:24:57.677]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:57.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:57.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.677]                               "release", "version")], collapse = " "), 
[08:24:57.677]                             hostname = base::Sys.info()[["nodename"]])
[08:24:57.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.677]                             info)
[08:24:57.677]                           info <- base::paste(info, collapse = "; ")
[08:24:57.677]                           if (!has_future) {
[08:24:57.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.677]                               info)
[08:24:57.677]                           }
[08:24:57.677]                           else {
[08:24:57.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.677]                               info, version)
[08:24:57.677]                           }
[08:24:57.677]                           base::stop(msg)
[08:24:57.677]                         }
[08:24:57.677]                       })
[08:24:57.677]                     }
[08:24:57.677]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:57.677]                     base::options(mc.cores = 1L)
[08:24:57.677]                   }
[08:24:57.677]                   ...future.strategy.old <- future::plan("list")
[08:24:57.677]                   options(future.plan = NULL)
[08:24:57.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.677]                 }
[08:24:57.677]                 ...future.workdir <- getwd()
[08:24:57.677]             }
[08:24:57.677]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.677]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.677]         }
[08:24:57.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.677]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:57.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.677]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.677]             base::names(...future.oldOptions))
[08:24:57.677]     }
[08:24:57.677]     if (FALSE) {
[08:24:57.677]     }
[08:24:57.677]     else {
[08:24:57.677]         if (TRUE) {
[08:24:57.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.677]                 open = "w")
[08:24:57.677]         }
[08:24:57.677]         else {
[08:24:57.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.677]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.677]         }
[08:24:57.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.677]             base::sink(type = "output", split = FALSE)
[08:24:57.677]             base::close(...future.stdout)
[08:24:57.677]         }, add = TRUE)
[08:24:57.677]     }
[08:24:57.677]     ...future.frame <- base::sys.nframe()
[08:24:57.677]     ...future.conditions <- base::list()
[08:24:57.677]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.677]     if (FALSE) {
[08:24:57.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.677]     }
[08:24:57.677]     ...future.result <- base::tryCatch({
[08:24:57.677]         base::withCallingHandlers({
[08:24:57.677]             ...future.value <- base::withVisible(base::local({
[08:24:57.677]                 withCallingHandlers({
[08:24:57.677]                   {
[08:24:57.677]                     do.call(function(...) {
[08:24:57.677]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.677]                       if (!identical(...future.globals.maxSize.org, 
[08:24:57.677]                         ...future.globals.maxSize)) {
[08:24:57.677]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.677]                         on.exit(options(oopts), add = TRUE)
[08:24:57.677]                       }
[08:24:57.677]                       {
[08:24:57.677]                         lapply(seq_along(...future.elements_ii), 
[08:24:57.677]                           FUN = function(jj) {
[08:24:57.677]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.677]                             ...future.FUN(...future.X_jj, ...)
[08:24:57.677]                           })
[08:24:57.677]                       }
[08:24:57.677]                     }, args = future.call.arguments)
[08:24:57.677]                   }
[08:24:57.677]                 }, immediateCondition = function(cond) {
[08:24:57.677]                   save_rds <- function (object, pathname, ...) 
[08:24:57.677]                   {
[08:24:57.677]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:57.677]                     if (file_test("-f", pathname_tmp)) {
[08:24:57.677]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.677]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:57.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.677]                         fi_tmp[["mtime"]])
[08:24:57.677]                     }
[08:24:57.677]                     tryCatch({
[08:24:57.677]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:57.677]                     }, error = function(ex) {
[08:24:57.677]                       msg <- conditionMessage(ex)
[08:24:57.677]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.677]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:57.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.677]                         fi_tmp[["mtime"]], msg)
[08:24:57.677]                       ex$message <- msg
[08:24:57.677]                       stop(ex)
[08:24:57.677]                     })
[08:24:57.677]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:57.677]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:57.677]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:57.677]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.677]                       fi <- file.info(pathname)
[08:24:57.677]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:57.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.677]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:57.677]                         fi[["size"]], fi[["mtime"]])
[08:24:57.677]                       stop(msg)
[08:24:57.677]                     }
[08:24:57.677]                     invisible(pathname)
[08:24:57.677]                   }
[08:24:57.677]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:57.677]                     rootPath = tempdir()) 
[08:24:57.677]                   {
[08:24:57.677]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:57.677]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:57.677]                       tmpdir = path, fileext = ".rds")
[08:24:57.677]                     save_rds(obj, file)
[08:24:57.677]                   }
[08:24:57.677]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:57.677]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.677]                   {
[08:24:57.677]                     inherits <- base::inherits
[08:24:57.677]                     invokeRestart <- base::invokeRestart
[08:24:57.677]                     is.null <- base::is.null
[08:24:57.677]                     muffled <- FALSE
[08:24:57.677]                     if (inherits(cond, "message")) {
[08:24:57.677]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:57.677]                       if (muffled) 
[08:24:57.677]                         invokeRestart("muffleMessage")
[08:24:57.677]                     }
[08:24:57.677]                     else if (inherits(cond, "warning")) {
[08:24:57.677]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:57.677]                       if (muffled) 
[08:24:57.677]                         invokeRestart("muffleWarning")
[08:24:57.677]                     }
[08:24:57.677]                     else if (inherits(cond, "condition")) {
[08:24:57.677]                       if (!is.null(pattern)) {
[08:24:57.677]                         computeRestarts <- base::computeRestarts
[08:24:57.677]                         grepl <- base::grepl
[08:24:57.677]                         restarts <- computeRestarts(cond)
[08:24:57.677]                         for (restart in restarts) {
[08:24:57.677]                           name <- restart$name
[08:24:57.677]                           if (is.null(name)) 
[08:24:57.677]                             next
[08:24:57.677]                           if (!grepl(pattern, name)) 
[08:24:57.677]                             next
[08:24:57.677]                           invokeRestart(restart)
[08:24:57.677]                           muffled <- TRUE
[08:24:57.677]                           break
[08:24:57.677]                         }
[08:24:57.677]                       }
[08:24:57.677]                     }
[08:24:57.677]                     invisible(muffled)
[08:24:57.677]                   }
[08:24:57.677]                   muffleCondition(cond)
[08:24:57.677]                 })
[08:24:57.677]             }))
[08:24:57.677]             future::FutureResult(value = ...future.value$value, 
[08:24:57.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.677]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.677]                     ...future.globalenv.names))
[08:24:57.677]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.677]         }, condition = base::local({
[08:24:57.677]             c <- base::c
[08:24:57.677]             inherits <- base::inherits
[08:24:57.677]             invokeRestart <- base::invokeRestart
[08:24:57.677]             length <- base::length
[08:24:57.677]             list <- base::list
[08:24:57.677]             seq.int <- base::seq.int
[08:24:57.677]             signalCondition <- base::signalCondition
[08:24:57.677]             sys.calls <- base::sys.calls
[08:24:57.677]             `[[` <- base::`[[`
[08:24:57.677]             `+` <- base::`+`
[08:24:57.677]             `<<-` <- base::`<<-`
[08:24:57.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.677]                   3L)]
[08:24:57.677]             }
[08:24:57.677]             function(cond) {
[08:24:57.677]                 is_error <- inherits(cond, "error")
[08:24:57.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.677]                   NULL)
[08:24:57.677]                 if (is_error) {
[08:24:57.677]                   sessionInformation <- function() {
[08:24:57.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.677]                       search = base::search(), system = base::Sys.info())
[08:24:57.677]                   }
[08:24:57.677]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.677]                     cond$call), session = sessionInformation(), 
[08:24:57.677]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.677]                   signalCondition(cond)
[08:24:57.677]                 }
[08:24:57.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.677]                 "immediateCondition"))) {
[08:24:57.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.677]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.677]                   if (TRUE && !signal) {
[08:24:57.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.677]                     {
[08:24:57.677]                       inherits <- base::inherits
[08:24:57.677]                       invokeRestart <- base::invokeRestart
[08:24:57.677]                       is.null <- base::is.null
[08:24:57.677]                       muffled <- FALSE
[08:24:57.677]                       if (inherits(cond, "message")) {
[08:24:57.677]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.677]                         if (muffled) 
[08:24:57.677]                           invokeRestart("muffleMessage")
[08:24:57.677]                       }
[08:24:57.677]                       else if (inherits(cond, "warning")) {
[08:24:57.677]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.677]                         if (muffled) 
[08:24:57.677]                           invokeRestart("muffleWarning")
[08:24:57.677]                       }
[08:24:57.677]                       else if (inherits(cond, "condition")) {
[08:24:57.677]                         if (!is.null(pattern)) {
[08:24:57.677]                           computeRestarts <- base::computeRestarts
[08:24:57.677]                           grepl <- base::grepl
[08:24:57.677]                           restarts <- computeRestarts(cond)
[08:24:57.677]                           for (restart in restarts) {
[08:24:57.677]                             name <- restart$name
[08:24:57.677]                             if (is.null(name)) 
[08:24:57.677]                               next
[08:24:57.677]                             if (!grepl(pattern, name)) 
[08:24:57.677]                               next
[08:24:57.677]                             invokeRestart(restart)
[08:24:57.677]                             muffled <- TRUE
[08:24:57.677]                             break
[08:24:57.677]                           }
[08:24:57.677]                         }
[08:24:57.677]                       }
[08:24:57.677]                       invisible(muffled)
[08:24:57.677]                     }
[08:24:57.677]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.677]                   }
[08:24:57.677]                 }
[08:24:57.677]                 else {
[08:24:57.677]                   if (TRUE) {
[08:24:57.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.677]                     {
[08:24:57.677]                       inherits <- base::inherits
[08:24:57.677]                       invokeRestart <- base::invokeRestart
[08:24:57.677]                       is.null <- base::is.null
[08:24:57.677]                       muffled <- FALSE
[08:24:57.677]                       if (inherits(cond, "message")) {
[08:24:57.677]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.677]                         if (muffled) 
[08:24:57.677]                           invokeRestart("muffleMessage")
[08:24:57.677]                       }
[08:24:57.677]                       else if (inherits(cond, "warning")) {
[08:24:57.677]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.677]                         if (muffled) 
[08:24:57.677]                           invokeRestart("muffleWarning")
[08:24:57.677]                       }
[08:24:57.677]                       else if (inherits(cond, "condition")) {
[08:24:57.677]                         if (!is.null(pattern)) {
[08:24:57.677]                           computeRestarts <- base::computeRestarts
[08:24:57.677]                           grepl <- base::grepl
[08:24:57.677]                           restarts <- computeRestarts(cond)
[08:24:57.677]                           for (restart in restarts) {
[08:24:57.677]                             name <- restart$name
[08:24:57.677]                             if (is.null(name)) 
[08:24:57.677]                               next
[08:24:57.677]                             if (!grepl(pattern, name)) 
[08:24:57.677]                               next
[08:24:57.677]                             invokeRestart(restart)
[08:24:57.677]                             muffled <- TRUE
[08:24:57.677]                             break
[08:24:57.677]                           }
[08:24:57.677]                         }
[08:24:57.677]                       }
[08:24:57.677]                       invisible(muffled)
[08:24:57.677]                     }
[08:24:57.677]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.677]                   }
[08:24:57.677]                 }
[08:24:57.677]             }
[08:24:57.677]         }))
[08:24:57.677]     }, error = function(ex) {
[08:24:57.677]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.677]                 ...future.rng), started = ...future.startTime, 
[08:24:57.677]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.677]             version = "1.8"), class = "FutureResult")
[08:24:57.677]     }, finally = {
[08:24:57.677]         if (!identical(...future.workdir, getwd())) 
[08:24:57.677]             setwd(...future.workdir)
[08:24:57.677]         {
[08:24:57.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.677]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.677]             }
[08:24:57.677]             base::options(...future.oldOptions)
[08:24:57.677]             if (.Platform$OS.type == "windows") {
[08:24:57.677]                 old_names <- names(...future.oldEnvVars)
[08:24:57.677]                 envs <- base::Sys.getenv()
[08:24:57.677]                 names <- names(envs)
[08:24:57.677]                 common <- intersect(names, old_names)
[08:24:57.677]                 added <- setdiff(names, old_names)
[08:24:57.677]                 removed <- setdiff(old_names, names)
[08:24:57.677]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.677]                   envs[common]]
[08:24:57.677]                 NAMES <- toupper(changed)
[08:24:57.677]                 args <- list()
[08:24:57.677]                 for (kk in seq_along(NAMES)) {
[08:24:57.677]                   name <- changed[[kk]]
[08:24:57.677]                   NAME <- NAMES[[kk]]
[08:24:57.677]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.677]                     next
[08:24:57.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.677]                 }
[08:24:57.677]                 NAMES <- toupper(added)
[08:24:57.677]                 for (kk in seq_along(NAMES)) {
[08:24:57.677]                   name <- added[[kk]]
[08:24:57.677]                   NAME <- NAMES[[kk]]
[08:24:57.677]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.677]                     next
[08:24:57.677]                   args[[name]] <- ""
[08:24:57.677]                 }
[08:24:57.677]                 NAMES <- toupper(removed)
[08:24:57.677]                 for (kk in seq_along(NAMES)) {
[08:24:57.677]                   name <- removed[[kk]]
[08:24:57.677]                   NAME <- NAMES[[kk]]
[08:24:57.677]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.677]                     next
[08:24:57.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.677]                 }
[08:24:57.677]                 if (length(args) > 0) 
[08:24:57.677]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.677]             }
[08:24:57.677]             else {
[08:24:57.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.677]             }
[08:24:57.677]             {
[08:24:57.677]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.677]                   0L) {
[08:24:57.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.677]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.677]                   base::options(opts)
[08:24:57.677]                 }
[08:24:57.677]                 {
[08:24:57.677]                   {
[08:24:57.677]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:57.677]                     NULL
[08:24:57.677]                   }
[08:24:57.677]                   options(future.plan = NULL)
[08:24:57.677]                   if (is.na(NA_character_)) 
[08:24:57.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.677]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.677]                     .init = FALSE)
[08:24:57.677]                 }
[08:24:57.677]             }
[08:24:57.677]         }
[08:24:57.677]     })
[08:24:57.677]     if (TRUE) {
[08:24:57.677]         base::sink(type = "output", split = FALSE)
[08:24:57.677]         if (TRUE) {
[08:24:57.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.677]         }
[08:24:57.677]         else {
[08:24:57.677]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.677]         }
[08:24:57.677]         base::close(...future.stdout)
[08:24:57.677]         ...future.stdout <- NULL
[08:24:57.677]     }
[08:24:57.677]     ...future.result$conditions <- ...future.conditions
[08:24:57.677]     ...future.result$finished <- base::Sys.time()
[08:24:57.677]     ...future.result
[08:24:57.677] }
[08:24:57.680] assign_globals() ...
[08:24:57.680] List of 5
[08:24:57.680]  $ ...future.FUN            :function (object, ...)  
[08:24:57.680]  $ future.call.arguments    :List of 1
[08:24:57.680]   ..$ digits: int 2
[08:24:57.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.680]  $ ...future.elements_ii    :List of 3
[08:24:57.680]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[08:24:57.680]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[08:24:57.680]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[08:24:57.680]  $ ...future.seeds_ii       : NULL
[08:24:57.680]  $ ...future.globals.maxSize: NULL
[08:24:57.680]  - attr(*, "where")=List of 5
[08:24:57.680]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.680]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.680]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.680]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.680]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.680]  - attr(*, "resolved")= logi FALSE
[08:24:57.680]  - attr(*, "total_size")= num 13284
[08:24:57.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.680]  - attr(*, "already-done")= logi TRUE
[08:24:57.688] - copied ‘...future.FUN’ to environment
[08:24:57.689] - copied ‘future.call.arguments’ to environment
[08:24:57.689] - copied ‘...future.elements_ii’ to environment
[08:24:57.689] - copied ‘...future.seeds_ii’ to environment
[08:24:57.689] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.691] assign_globals() ... done
[08:24:57.692] requestCore(): workers = 2
[08:24:57.694] MulticoreFuture started
[08:24:57.695] - Launch lazy future ... done
[08:24:57.696] run() for ‘MulticoreFuture’ ... done
[08:24:57.696] plan(): Setting new future strategy stack:
[08:24:57.696] Created future:
[08:24:57.696] List of future strategies:
[08:24:57.696] 1. sequential:
[08:24:57.696]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.696]    - tweaked: FALSE
[08:24:57.696]    - call: NULL
[08:24:57.698] plan(): nbrOfWorkers() = 1
[08:24:57.703] plan(): Setting new future strategy stack:
[08:24:57.703] List of future strategies:
[08:24:57.703] 1. multicore:
[08:24:57.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.703]    - tweaked: FALSE
[08:24:57.703]    - call: plan(strategy)
[08:24:57.708] plan(): nbrOfWorkers() = 2
[08:24:57.697] MulticoreFuture:
[08:24:57.697] Label: ‘future_by-2’
[08:24:57.697] Expression:
[08:24:57.697] {
[08:24:57.697]     do.call(function(...) {
[08:24:57.697]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.697]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.697]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.697]             on.exit(options(oopts), add = TRUE)
[08:24:57.697]         }
[08:24:57.697]         {
[08:24:57.697]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.697]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.697]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.697]             })
[08:24:57.697]         }
[08:24:57.697]     }, args = future.call.arguments)
[08:24:57.697] }
[08:24:57.697] Lazy evaluation: FALSE
[08:24:57.697] Asynchronous evaluation: TRUE
[08:24:57.697] Local evaluation: TRUE
[08:24:57.697] Environment: R_GlobalEnv
[08:24:57.697] Capture standard output: TRUE
[08:24:57.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.697] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.697] Packages: <none>
[08:24:57.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.697] Resolved: TRUE
[08:24:57.697] Value: <not collected>
[08:24:57.697] Conditions captured: <none>
[08:24:57.697] Early signaling: FALSE
[08:24:57.697] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.697] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.709] Chunk #2 of 2 ... DONE
[08:24:57.709] Launching 2 futures (chunks) ... DONE
[08:24:57.709] Resolving 2 futures (chunks) ...
[08:24:57.710] resolve() on list ...
[08:24:57.710]  recursive: 0
[08:24:57.710]  length: 2
[08:24:57.710] 
[08:24:57.711] Future #1
[08:24:57.711] result() for MulticoreFuture ...
[08:24:57.712] result() for MulticoreFuture ...
[08:24:57.712] result() for MulticoreFuture ... done
[08:24:57.712] result() for MulticoreFuture ... done
[08:24:57.713] result() for MulticoreFuture ...
[08:24:57.713] result() for MulticoreFuture ... done
[08:24:57.713] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:57.713] - nx: 2
[08:24:57.713] - relay: TRUE
[08:24:57.714] - stdout: TRUE
[08:24:57.714] - signal: TRUE
[08:24:57.714] - resignal: FALSE
[08:24:57.714] - force: TRUE
[08:24:57.714] - relayed: [n=2] FALSE, FALSE
[08:24:57.714] - queued futures: [n=2] FALSE, FALSE
[08:24:57.715]  - until=1
[08:24:57.715]  - relaying element #1
[08:24:57.715] result() for MulticoreFuture ...
[08:24:57.715] result() for MulticoreFuture ... done
[08:24:57.715] result() for MulticoreFuture ...
[08:24:57.715] result() for MulticoreFuture ... done
[08:24:57.716] result() for MulticoreFuture ...
[08:24:57.716] result() for MulticoreFuture ... done
[08:24:57.716] result() for MulticoreFuture ...
[08:24:57.716] result() for MulticoreFuture ... done
[08:24:57.716] - relayed: [n=2] TRUE, FALSE
[08:24:57.716] - queued futures: [n=2] TRUE, FALSE
[08:24:57.717] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:57.717]  length: 1 (resolved future 1)
[08:24:57.717] Future #2
[08:24:57.717] result() for MulticoreFuture ...
[08:24:57.718] result() for MulticoreFuture ...
[08:24:57.718] result() for MulticoreFuture ... done
[08:24:57.718] result() for MulticoreFuture ... done
[08:24:57.719] result() for MulticoreFuture ...
[08:24:57.719] result() for MulticoreFuture ... done
[08:24:57.719] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:57.719] - nx: 2
[08:24:57.719] - relay: TRUE
[08:24:57.719] - stdout: TRUE
[08:24:57.719] - signal: TRUE
[08:24:57.720] - resignal: FALSE
[08:24:57.720] - force: TRUE
[08:24:57.720] - relayed: [n=2] TRUE, FALSE
[08:24:57.720] - queued futures: [n=2] TRUE, FALSE
[08:24:57.720]  - until=2
[08:24:57.720]  - relaying element #2
[08:24:57.720] result() for MulticoreFuture ...
[08:24:57.720] result() for MulticoreFuture ... done
[08:24:57.720] result() for MulticoreFuture ...
[08:24:57.721] result() for MulticoreFuture ... done
[08:24:57.721] result() for MulticoreFuture ...
[08:24:57.721] result() for MulticoreFuture ... done
[08:24:57.721] result() for MulticoreFuture ...
[08:24:57.721] result() for MulticoreFuture ... done
[08:24:57.721] - relayed: [n=2] TRUE, TRUE
[08:24:57.721] - queued futures: [n=2] TRUE, TRUE
[08:24:57.721] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:57.721]  length: 0 (resolved future 2)
[08:24:57.722] Relaying remaining futures
[08:24:57.722] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.722] - nx: 2
[08:24:57.722] - relay: TRUE
[08:24:57.722] - stdout: TRUE
[08:24:57.722] - signal: TRUE
[08:24:57.722] - resignal: FALSE
[08:24:57.722] - force: TRUE
[08:24:57.722] - relayed: [n=2] TRUE, TRUE
[08:24:57.722] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:57.723] - relayed: [n=2] TRUE, TRUE
[08:24:57.723] - queued futures: [n=2] TRUE, TRUE
[08:24:57.723] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.723] resolve() on list ... DONE
[08:24:57.723] result() for MulticoreFuture ...
[08:24:57.723] result() for MulticoreFuture ... done
[08:24:57.723] result() for MulticoreFuture ...
[08:24:57.723] result() for MulticoreFuture ... done
[08:24:57.723] result() for MulticoreFuture ...
[08:24:57.724] result() for MulticoreFuture ... done
[08:24:57.724] result() for MulticoreFuture ...
[08:24:57.724] result() for MulticoreFuture ... done
[08:24:57.724]  - Number of value chunks collected: 2
[08:24:57.724] Resolving 2 futures (chunks) ... DONE
[08:24:57.724] Reducing values from 2 chunks ...
[08:24:57.724]  - Number of values collected after concatenation: 6
[08:24:57.724]  - Number of values expected: 6
[08:24:57.724] Reducing values from 2 chunks ... DONE
[08:24:57.725] future_lapply() ... DONE
[08:24:57.725] future_by_internal() ... DONE
[08:24:57.726] future_by_internal() ...
[08:24:57.726] future_lapply() ...
[08:24:57.729] Number of chunks: 2
[08:24:57.729] getGlobalsAndPackagesXApply() ...
[08:24:57.730]  - future.globals: TRUE
[08:24:57.730] getGlobalsAndPackages() ...
[08:24:57.730] Searching for globals...
[08:24:57.737] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:57.737] Searching for globals ... DONE
[08:24:57.737] Resolving globals: FALSE
[08:24:57.738] The total size of the 1 globals is 762 bytes (762 bytes)
[08:24:57.738] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[08:24:57.738] - globals: [1] ‘FUN’
[08:24:57.738] - packages: [1] ‘stats’
[08:24:57.738] getGlobalsAndPackages() ... DONE
[08:24:57.739]  - globals found/used: [n=1] ‘FUN’
[08:24:57.739]  - needed namespaces: [n=1] ‘stats’
[08:24:57.739] Finding globals ... DONE
[08:24:57.739]  - use_args: TRUE
[08:24:57.739]  - Getting '...' globals ...
[08:24:57.739] resolve() on list ...
[08:24:57.740]  recursive: 0
[08:24:57.740]  length: 1
[08:24:57.740]  elements: ‘...’
[08:24:57.740]  length: 0 (resolved future 1)
[08:24:57.740] resolve() on list ... DONE
[08:24:57.740]    - '...' content: [n=1] ‘singular.ok’
[08:24:57.740] List of 1
[08:24:57.740]  $ ...:List of 1
[08:24:57.740]   ..$ singular.ok: logi FALSE
[08:24:57.740]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.740]  - attr(*, "where")=List of 1
[08:24:57.740]   ..$ ...:<environment: 0x557b27eded68> 
[08:24:57.740]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.740]  - attr(*, "resolved")= logi TRUE
[08:24:57.740]  - attr(*, "total_size")= num NA
[08:24:57.744]  - Getting '...' globals ... DONE
[08:24:57.744] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:57.744] List of 2
[08:24:57.744]  $ ...future.FUN:function (x, ...)  
[08:24:57.744]  $ ...          :List of 1
[08:24:57.744]   ..$ singular.ok: logi FALSE
[08:24:57.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.744]  - attr(*, "where")=List of 2
[08:24:57.744]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.744]   ..$ ...          :<environment: 0x557b27eded68> 
[08:24:57.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.744]  - attr(*, "resolved")= logi FALSE
[08:24:57.744]  - attr(*, "total_size")= num 19977
[08:24:57.747] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:57.748] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.748] Number of futures (= number of chunks): 2
[08:24:57.748] Launching 2 futures (chunks) ...
[08:24:57.748] Chunk #1 of 2 ...
[08:24:57.748]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.748] getGlobalsAndPackages() ...
[08:24:57.748] Searching for globals...
[08:24:57.749] 
[08:24:57.749] Searching for globals ... DONE
[08:24:57.749] - globals: [0] <none>
[08:24:57.749] getGlobalsAndPackages() ... DONE
[08:24:57.749]    + additional globals found: [n=0] 
[08:24:57.749]    + additional namespaces needed: [n=0] 
[08:24:57.749]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.749]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:57.749]  - seeds: <none>
[08:24:57.749]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.750] getGlobalsAndPackages() ...
[08:24:57.750] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.750] Resolving globals: FALSE
[08:24:57.750] Tweak future expression to call with '...' arguments ...
[08:24:57.750] {
[08:24:57.750]     do.call(function(...) {
[08:24:57.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.750]             on.exit(options(oopts), add = TRUE)
[08:24:57.750]         }
[08:24:57.750]         {
[08:24:57.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.750]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.750]             })
[08:24:57.750]         }
[08:24:57.750]     }, args = future.call.arguments)
[08:24:57.750] }
[08:24:57.750] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.751] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.751] 
[08:24:57.751] getGlobalsAndPackages() ... DONE
[08:24:57.751] run() for ‘Future’ ...
[08:24:57.751] - state: ‘created’
[08:24:57.751] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.753] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:57.754]   - Field: ‘label’
[08:24:57.754]   - Field: ‘local’
[08:24:57.754]   - Field: ‘owner’
[08:24:57.754]   - Field: ‘envir’
[08:24:57.754]   - Field: ‘workers’
[08:24:57.754]   - Field: ‘packages’
[08:24:57.754]   - Field: ‘gc’
[08:24:57.754]   - Field: ‘job’
[08:24:57.754]   - Field: ‘conditions’
[08:24:57.754]   - Field: ‘expr’
[08:24:57.754]   - Field: ‘uuid’
[08:24:57.755]   - Field: ‘seed’
[08:24:57.755]   - Field: ‘version’
[08:24:57.755]   - Field: ‘result’
[08:24:57.755]   - Field: ‘asynchronous’
[08:24:57.755]   - Field: ‘calls’
[08:24:57.755]   - Field: ‘globals’
[08:24:57.755]   - Field: ‘stdout’
[08:24:57.755]   - Field: ‘earlySignal’
[08:24:57.755]   - Field: ‘lazy’
[08:24:57.755]   - Field: ‘state’
[08:24:57.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:57.756] - Launch lazy future ...
[08:24:57.756] Packages needed by the future expression (n = 1): ‘stats’
[08:24:57.756] Packages needed by future strategies (n = 0): <none>
[08:24:57.757] {
[08:24:57.757]     {
[08:24:57.757]         {
[08:24:57.757]             ...future.startTime <- base::Sys.time()
[08:24:57.757]             {
[08:24:57.757]                 {
[08:24:57.757]                   {
[08:24:57.757]                     {
[08:24:57.757]                       {
[08:24:57.757]                         base::local({
[08:24:57.757]                           has_future <- base::requireNamespace("future", 
[08:24:57.757]                             quietly = TRUE)
[08:24:57.757]                           if (has_future) {
[08:24:57.757]                             ns <- base::getNamespace("future")
[08:24:57.757]                             version <- ns[[".package"]][["version"]]
[08:24:57.757]                             if (is.null(version)) 
[08:24:57.757]                               version <- utils::packageVersion("future")
[08:24:57.757]                           }
[08:24:57.757]                           else {
[08:24:57.757]                             version <- NULL
[08:24:57.757]                           }
[08:24:57.757]                           if (!has_future || version < "1.8.0") {
[08:24:57.757]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.757]                               "", base::R.version$version.string), 
[08:24:57.757]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:57.757]                                 base::R.version$platform, 8 * 
[08:24:57.757]                                   base::.Machine$sizeof.pointer), 
[08:24:57.757]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.757]                                 "release", "version")], collapse = " "), 
[08:24:57.757]                               hostname = base::Sys.info()[["nodename"]])
[08:24:57.757]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.757]                               info)
[08:24:57.757]                             info <- base::paste(info, collapse = "; ")
[08:24:57.757]                             if (!has_future) {
[08:24:57.757]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.757]                                 info)
[08:24:57.757]                             }
[08:24:57.757]                             else {
[08:24:57.757]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.757]                                 info, version)
[08:24:57.757]                             }
[08:24:57.757]                             base::stop(msg)
[08:24:57.757]                           }
[08:24:57.757]                         })
[08:24:57.757]                       }
[08:24:57.757]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:57.757]                       base::options(mc.cores = 1L)
[08:24:57.757]                     }
[08:24:57.757]                     base::local({
[08:24:57.757]                       for (pkg in "stats") {
[08:24:57.757]                         base::loadNamespace(pkg)
[08:24:57.757]                         base::library(pkg, character.only = TRUE)
[08:24:57.757]                       }
[08:24:57.757]                     })
[08:24:57.757]                   }
[08:24:57.757]                   ...future.strategy.old <- future::plan("list")
[08:24:57.757]                   options(future.plan = NULL)
[08:24:57.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.757]                 }
[08:24:57.757]                 ...future.workdir <- getwd()
[08:24:57.757]             }
[08:24:57.757]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.757]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.757]         }
[08:24:57.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.757]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:57.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.757]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.757]             base::names(...future.oldOptions))
[08:24:57.757]     }
[08:24:57.757]     if (FALSE) {
[08:24:57.757]     }
[08:24:57.757]     else {
[08:24:57.757]         if (TRUE) {
[08:24:57.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.757]                 open = "w")
[08:24:57.757]         }
[08:24:57.757]         else {
[08:24:57.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.757]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.757]         }
[08:24:57.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.757]             base::sink(type = "output", split = FALSE)
[08:24:57.757]             base::close(...future.stdout)
[08:24:57.757]         }, add = TRUE)
[08:24:57.757]     }
[08:24:57.757]     ...future.frame <- base::sys.nframe()
[08:24:57.757]     ...future.conditions <- base::list()
[08:24:57.757]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.757]     if (FALSE) {
[08:24:57.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.757]     }
[08:24:57.757]     ...future.result <- base::tryCatch({
[08:24:57.757]         base::withCallingHandlers({
[08:24:57.757]             ...future.value <- base::withVisible(base::local({
[08:24:57.757]                 withCallingHandlers({
[08:24:57.757]                   {
[08:24:57.757]                     do.call(function(...) {
[08:24:57.757]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.757]                       if (!identical(...future.globals.maxSize.org, 
[08:24:57.757]                         ...future.globals.maxSize)) {
[08:24:57.757]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.757]                         on.exit(options(oopts), add = TRUE)
[08:24:57.757]                       }
[08:24:57.757]                       {
[08:24:57.757]                         lapply(seq_along(...future.elements_ii), 
[08:24:57.757]                           FUN = function(jj) {
[08:24:57.757]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.757]                             ...future.FUN(...future.X_jj, ...)
[08:24:57.757]                           })
[08:24:57.757]                       }
[08:24:57.757]                     }, args = future.call.arguments)
[08:24:57.757]                   }
[08:24:57.757]                 }, immediateCondition = function(cond) {
[08:24:57.757]                   save_rds <- function (object, pathname, ...) 
[08:24:57.757]                   {
[08:24:57.757]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:57.757]                     if (file_test("-f", pathname_tmp)) {
[08:24:57.757]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.757]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:57.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.757]                         fi_tmp[["mtime"]])
[08:24:57.757]                     }
[08:24:57.757]                     tryCatch({
[08:24:57.757]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:57.757]                     }, error = function(ex) {
[08:24:57.757]                       msg <- conditionMessage(ex)
[08:24:57.757]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.757]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:57.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.757]                         fi_tmp[["mtime"]], msg)
[08:24:57.757]                       ex$message <- msg
[08:24:57.757]                       stop(ex)
[08:24:57.757]                     })
[08:24:57.757]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:57.757]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:57.757]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:57.757]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.757]                       fi <- file.info(pathname)
[08:24:57.757]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:57.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.757]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:57.757]                         fi[["size"]], fi[["mtime"]])
[08:24:57.757]                       stop(msg)
[08:24:57.757]                     }
[08:24:57.757]                     invisible(pathname)
[08:24:57.757]                   }
[08:24:57.757]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:57.757]                     rootPath = tempdir()) 
[08:24:57.757]                   {
[08:24:57.757]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:57.757]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:57.757]                       tmpdir = path, fileext = ".rds")
[08:24:57.757]                     save_rds(obj, file)
[08:24:57.757]                   }
[08:24:57.757]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:57.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.757]                   {
[08:24:57.757]                     inherits <- base::inherits
[08:24:57.757]                     invokeRestart <- base::invokeRestart
[08:24:57.757]                     is.null <- base::is.null
[08:24:57.757]                     muffled <- FALSE
[08:24:57.757]                     if (inherits(cond, "message")) {
[08:24:57.757]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:57.757]                       if (muffled) 
[08:24:57.757]                         invokeRestart("muffleMessage")
[08:24:57.757]                     }
[08:24:57.757]                     else if (inherits(cond, "warning")) {
[08:24:57.757]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:57.757]                       if (muffled) 
[08:24:57.757]                         invokeRestart("muffleWarning")
[08:24:57.757]                     }
[08:24:57.757]                     else if (inherits(cond, "condition")) {
[08:24:57.757]                       if (!is.null(pattern)) {
[08:24:57.757]                         computeRestarts <- base::computeRestarts
[08:24:57.757]                         grepl <- base::grepl
[08:24:57.757]                         restarts <- computeRestarts(cond)
[08:24:57.757]                         for (restart in restarts) {
[08:24:57.757]                           name <- restart$name
[08:24:57.757]                           if (is.null(name)) 
[08:24:57.757]                             next
[08:24:57.757]                           if (!grepl(pattern, name)) 
[08:24:57.757]                             next
[08:24:57.757]                           invokeRestart(restart)
[08:24:57.757]                           muffled <- TRUE
[08:24:57.757]                           break
[08:24:57.757]                         }
[08:24:57.757]                       }
[08:24:57.757]                     }
[08:24:57.757]                     invisible(muffled)
[08:24:57.757]                   }
[08:24:57.757]                   muffleCondition(cond)
[08:24:57.757]                 })
[08:24:57.757]             }))
[08:24:57.757]             future::FutureResult(value = ...future.value$value, 
[08:24:57.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.757]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.757]                     ...future.globalenv.names))
[08:24:57.757]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.757]         }, condition = base::local({
[08:24:57.757]             c <- base::c
[08:24:57.757]             inherits <- base::inherits
[08:24:57.757]             invokeRestart <- base::invokeRestart
[08:24:57.757]             length <- base::length
[08:24:57.757]             list <- base::list
[08:24:57.757]             seq.int <- base::seq.int
[08:24:57.757]             signalCondition <- base::signalCondition
[08:24:57.757]             sys.calls <- base::sys.calls
[08:24:57.757]             `[[` <- base::`[[`
[08:24:57.757]             `+` <- base::`+`
[08:24:57.757]             `<<-` <- base::`<<-`
[08:24:57.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.757]                   3L)]
[08:24:57.757]             }
[08:24:57.757]             function(cond) {
[08:24:57.757]                 is_error <- inherits(cond, "error")
[08:24:57.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.757]                   NULL)
[08:24:57.757]                 if (is_error) {
[08:24:57.757]                   sessionInformation <- function() {
[08:24:57.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.757]                       search = base::search(), system = base::Sys.info())
[08:24:57.757]                   }
[08:24:57.757]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.757]                     cond$call), session = sessionInformation(), 
[08:24:57.757]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.757]                   signalCondition(cond)
[08:24:57.757]                 }
[08:24:57.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.757]                 "immediateCondition"))) {
[08:24:57.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.757]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.757]                   if (TRUE && !signal) {
[08:24:57.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.757]                     {
[08:24:57.757]                       inherits <- base::inherits
[08:24:57.757]                       invokeRestart <- base::invokeRestart
[08:24:57.757]                       is.null <- base::is.null
[08:24:57.757]                       muffled <- FALSE
[08:24:57.757]                       if (inherits(cond, "message")) {
[08:24:57.757]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.757]                         if (muffled) 
[08:24:57.757]                           invokeRestart("muffleMessage")
[08:24:57.757]                       }
[08:24:57.757]                       else if (inherits(cond, "warning")) {
[08:24:57.757]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.757]                         if (muffled) 
[08:24:57.757]                           invokeRestart("muffleWarning")
[08:24:57.757]                       }
[08:24:57.757]                       else if (inherits(cond, "condition")) {
[08:24:57.757]                         if (!is.null(pattern)) {
[08:24:57.757]                           computeRestarts <- base::computeRestarts
[08:24:57.757]                           grepl <- base::grepl
[08:24:57.757]                           restarts <- computeRestarts(cond)
[08:24:57.757]                           for (restart in restarts) {
[08:24:57.757]                             name <- restart$name
[08:24:57.757]                             if (is.null(name)) 
[08:24:57.757]                               next
[08:24:57.757]                             if (!grepl(pattern, name)) 
[08:24:57.757]                               next
[08:24:57.757]                             invokeRestart(restart)
[08:24:57.757]                             muffled <- TRUE
[08:24:57.757]                             break
[08:24:57.757]                           }
[08:24:57.757]                         }
[08:24:57.757]                       }
[08:24:57.757]                       invisible(muffled)
[08:24:57.757]                     }
[08:24:57.757]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.757]                   }
[08:24:57.757]                 }
[08:24:57.757]                 else {
[08:24:57.757]                   if (TRUE) {
[08:24:57.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.757]                     {
[08:24:57.757]                       inherits <- base::inherits
[08:24:57.757]                       invokeRestart <- base::invokeRestart
[08:24:57.757]                       is.null <- base::is.null
[08:24:57.757]                       muffled <- FALSE
[08:24:57.757]                       if (inherits(cond, "message")) {
[08:24:57.757]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.757]                         if (muffled) 
[08:24:57.757]                           invokeRestart("muffleMessage")
[08:24:57.757]                       }
[08:24:57.757]                       else if (inherits(cond, "warning")) {
[08:24:57.757]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.757]                         if (muffled) 
[08:24:57.757]                           invokeRestart("muffleWarning")
[08:24:57.757]                       }
[08:24:57.757]                       else if (inherits(cond, "condition")) {
[08:24:57.757]                         if (!is.null(pattern)) {
[08:24:57.757]                           computeRestarts <- base::computeRestarts
[08:24:57.757]                           grepl <- base::grepl
[08:24:57.757]                           restarts <- computeRestarts(cond)
[08:24:57.757]                           for (restart in restarts) {
[08:24:57.757]                             name <- restart$name
[08:24:57.757]                             if (is.null(name)) 
[08:24:57.757]                               next
[08:24:57.757]                             if (!grepl(pattern, name)) 
[08:24:57.757]                               next
[08:24:57.757]                             invokeRestart(restart)
[08:24:57.757]                             muffled <- TRUE
[08:24:57.757]                             break
[08:24:57.757]                           }
[08:24:57.757]                         }
[08:24:57.757]                       }
[08:24:57.757]                       invisible(muffled)
[08:24:57.757]                     }
[08:24:57.757]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.757]                   }
[08:24:57.757]                 }
[08:24:57.757]             }
[08:24:57.757]         }))
[08:24:57.757]     }, error = function(ex) {
[08:24:57.757]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.757]                 ...future.rng), started = ...future.startTime, 
[08:24:57.757]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.757]             version = "1.8"), class = "FutureResult")
[08:24:57.757]     }, finally = {
[08:24:57.757]         if (!identical(...future.workdir, getwd())) 
[08:24:57.757]             setwd(...future.workdir)
[08:24:57.757]         {
[08:24:57.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.757]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.757]             }
[08:24:57.757]             base::options(...future.oldOptions)
[08:24:57.757]             if (.Platform$OS.type == "windows") {
[08:24:57.757]                 old_names <- names(...future.oldEnvVars)
[08:24:57.757]                 envs <- base::Sys.getenv()
[08:24:57.757]                 names <- names(envs)
[08:24:57.757]                 common <- intersect(names, old_names)
[08:24:57.757]                 added <- setdiff(names, old_names)
[08:24:57.757]                 removed <- setdiff(old_names, names)
[08:24:57.757]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.757]                   envs[common]]
[08:24:57.757]                 NAMES <- toupper(changed)
[08:24:57.757]                 args <- list()
[08:24:57.757]                 for (kk in seq_along(NAMES)) {
[08:24:57.757]                   name <- changed[[kk]]
[08:24:57.757]                   NAME <- NAMES[[kk]]
[08:24:57.757]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.757]                     next
[08:24:57.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.757]                 }
[08:24:57.757]                 NAMES <- toupper(added)
[08:24:57.757]                 for (kk in seq_along(NAMES)) {
[08:24:57.757]                   name <- added[[kk]]
[08:24:57.757]                   NAME <- NAMES[[kk]]
[08:24:57.757]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.757]                     next
[08:24:57.757]                   args[[name]] <- ""
[08:24:57.757]                 }
[08:24:57.757]                 NAMES <- toupper(removed)
[08:24:57.757]                 for (kk in seq_along(NAMES)) {
[08:24:57.757]                   name <- removed[[kk]]
[08:24:57.757]                   NAME <- NAMES[[kk]]
[08:24:57.757]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.757]                     next
[08:24:57.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.757]                 }
[08:24:57.757]                 if (length(args) > 0) 
[08:24:57.757]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.757]             }
[08:24:57.757]             else {
[08:24:57.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.757]             }
[08:24:57.757]             {
[08:24:57.757]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.757]                   0L) {
[08:24:57.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.757]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.757]                   base::options(opts)
[08:24:57.757]                 }
[08:24:57.757]                 {
[08:24:57.757]                   {
[08:24:57.757]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:57.757]                     NULL
[08:24:57.757]                   }
[08:24:57.757]                   options(future.plan = NULL)
[08:24:57.757]                   if (is.na(NA_character_)) 
[08:24:57.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.757]                     .init = FALSE)
[08:24:57.757]                 }
[08:24:57.757]             }
[08:24:57.757]         }
[08:24:57.757]     })
[08:24:57.757]     if (TRUE) {
[08:24:57.757]         base::sink(type = "output", split = FALSE)
[08:24:57.757]         if (TRUE) {
[08:24:57.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.757]         }
[08:24:57.757]         else {
[08:24:57.757]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.757]         }
[08:24:57.757]         base::close(...future.stdout)
[08:24:57.757]         ...future.stdout <- NULL
[08:24:57.757]     }
[08:24:57.757]     ...future.result$conditions <- ...future.conditions
[08:24:57.757]     ...future.result$finished <- base::Sys.time()
[08:24:57.757]     ...future.result
[08:24:57.757] }
[08:24:57.759] assign_globals() ...
[08:24:57.759] List of 5
[08:24:57.759]  $ ...future.FUN            :function (x, ...)  
[08:24:57.759]  $ future.call.arguments    :List of 1
[08:24:57.759]   ..$ singular.ok: logi FALSE
[08:24:57.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.759]  $ ...future.elements_ii    :List of 1
[08:24:57.759]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.759]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.759]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.759]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.759]  $ ...future.seeds_ii       : NULL
[08:24:57.759]  $ ...future.globals.maxSize: NULL
[08:24:57.759]  - attr(*, "where")=List of 5
[08:24:57.759]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.759]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.759]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.759]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.759]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.759]  - attr(*, "resolved")= logi FALSE
[08:24:57.759]  - attr(*, "total_size")= num 19977
[08:24:57.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.759]  - attr(*, "already-done")= logi TRUE
[08:24:57.769] - reassign environment for ‘...future.FUN’
[08:24:57.769] - copied ‘...future.FUN’ to environment
[08:24:57.769] - copied ‘future.call.arguments’ to environment
[08:24:57.769] - copied ‘...future.elements_ii’ to environment
[08:24:57.769] - copied ‘...future.seeds_ii’ to environment
[08:24:57.769] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.769] assign_globals() ... done
[08:24:57.769] requestCore(): workers = 2
[08:24:57.772] MulticoreFuture started
[08:24:57.772] - Launch lazy future ... done
[08:24:57.773] run() for ‘MulticoreFuture’ ... done
[08:24:57.773] Created future:
[08:24:57.773] plan(): Setting new future strategy stack:
[08:24:57.774] List of future strategies:
[08:24:57.774] 1. sequential:
[08:24:57.774]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.774]    - tweaked: FALSE
[08:24:57.774]    - call: NULL
[08:24:57.775] plan(): nbrOfWorkers() = 1
[08:24:57.779] plan(): Setting new future strategy stack:
[08:24:57.779] List of future strategies:
[08:24:57.779] 1. multicore:
[08:24:57.779]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.779]    - tweaked: FALSE
[08:24:57.779]    - call: plan(strategy)
[08:24:57.783] plan(): nbrOfWorkers() = 2
[08:24:57.773] MulticoreFuture:
[08:24:57.773] Label: ‘future_by-1’
[08:24:57.773] Expression:
[08:24:57.773] {
[08:24:57.773]     do.call(function(...) {
[08:24:57.773]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.773]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.773]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.773]             on.exit(options(oopts), add = TRUE)
[08:24:57.773]         }
[08:24:57.773]         {
[08:24:57.773]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.773]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.773]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.773]             })
[08:24:57.773]         }
[08:24:57.773]     }, args = future.call.arguments)
[08:24:57.773] }
[08:24:57.773] Lazy evaluation: FALSE
[08:24:57.773] Asynchronous evaluation: TRUE
[08:24:57.773] Local evaluation: TRUE
[08:24:57.773] Environment: R_GlobalEnv
[08:24:57.773] Capture standard output: TRUE
[08:24:57.773] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.773] Globals: 5 objects totaling 1.67 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.773] Packages: 1 packages (‘stats’)
[08:24:57.773] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.773] Resolved: TRUE
[08:24:57.773] Value: <not collected>
[08:24:57.773] Conditions captured: <none>
[08:24:57.773] Early signaling: FALSE
[08:24:57.773] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.773] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.785] Chunk #1 of 2 ... DONE
[08:24:57.785] Chunk #2 of 2 ...
[08:24:57.785]  - Finding globals in 'X' for chunk #2 ...
[08:24:57.785] getGlobalsAndPackages() ...
[08:24:57.785] Searching for globals...
[08:24:57.786] 
[08:24:57.786] Searching for globals ... DONE
[08:24:57.787] - globals: [0] <none>
[08:24:57.787] getGlobalsAndPackages() ... DONE
[08:24:57.787]    + additional globals found: [n=0] 
[08:24:57.787]    + additional namespaces needed: [n=0] 
[08:24:57.787]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:57.787]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:57.787]  - seeds: <none>
[08:24:57.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.788] getGlobalsAndPackages() ...
[08:24:57.788] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.788] Resolving globals: FALSE
[08:24:57.788] Tweak future expression to call with '...' arguments ...
[08:24:57.788] {
[08:24:57.788]     do.call(function(...) {
[08:24:57.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.788]             on.exit(options(oopts), add = TRUE)
[08:24:57.788]         }
[08:24:57.788]         {
[08:24:57.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.788]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.788]             })
[08:24:57.788]         }
[08:24:57.788]     }, args = future.call.arguments)
[08:24:57.788] }
[08:24:57.789] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.789] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.789] 
[08:24:57.789] getGlobalsAndPackages() ... DONE
[08:24:57.790] run() for ‘Future’ ...
[08:24:57.790] - state: ‘created’
[08:24:57.790] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.793] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:57.794]   - Field: ‘label’
[08:24:57.794]   - Field: ‘local’
[08:24:57.794]   - Field: ‘owner’
[08:24:57.794]   - Field: ‘envir’
[08:24:57.794]   - Field: ‘workers’
[08:24:57.794]   - Field: ‘packages’
[08:24:57.795]   - Field: ‘gc’
[08:24:57.795]   - Field: ‘job’
[08:24:57.795]   - Field: ‘conditions’
[08:24:57.795]   - Field: ‘expr’
[08:24:57.795]   - Field: ‘uuid’
[08:24:57.795]   - Field: ‘seed’
[08:24:57.795]   - Field: ‘version’
[08:24:57.796]   - Field: ‘result’
[08:24:57.796]   - Field: ‘asynchronous’
[08:24:57.796]   - Field: ‘calls’
[08:24:57.796]   - Field: ‘globals’
[08:24:57.796]   - Field: ‘stdout’
[08:24:57.796]   - Field: ‘earlySignal’
[08:24:57.797]   - Field: ‘lazy’
[08:24:57.797]   - Field: ‘state’
[08:24:57.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:57.797] - Launch lazy future ...
[08:24:57.797] Packages needed by the future expression (n = 1): ‘stats’
[08:24:57.798] Packages needed by future strategies (n = 0): <none>
[08:24:57.798] {
[08:24:57.798]     {
[08:24:57.798]         {
[08:24:57.798]             ...future.startTime <- base::Sys.time()
[08:24:57.798]             {
[08:24:57.798]                 {
[08:24:57.798]                   {
[08:24:57.798]                     {
[08:24:57.798]                       {
[08:24:57.798]                         base::local({
[08:24:57.798]                           has_future <- base::requireNamespace("future", 
[08:24:57.798]                             quietly = TRUE)
[08:24:57.798]                           if (has_future) {
[08:24:57.798]                             ns <- base::getNamespace("future")
[08:24:57.798]                             version <- ns[[".package"]][["version"]]
[08:24:57.798]                             if (is.null(version)) 
[08:24:57.798]                               version <- utils::packageVersion("future")
[08:24:57.798]                           }
[08:24:57.798]                           else {
[08:24:57.798]                             version <- NULL
[08:24:57.798]                           }
[08:24:57.798]                           if (!has_future || version < "1.8.0") {
[08:24:57.798]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.798]                               "", base::R.version$version.string), 
[08:24:57.798]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:57.798]                                 base::R.version$platform, 8 * 
[08:24:57.798]                                   base::.Machine$sizeof.pointer), 
[08:24:57.798]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.798]                                 "release", "version")], collapse = " "), 
[08:24:57.798]                               hostname = base::Sys.info()[["nodename"]])
[08:24:57.798]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.798]                               info)
[08:24:57.798]                             info <- base::paste(info, collapse = "; ")
[08:24:57.798]                             if (!has_future) {
[08:24:57.798]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.798]                                 info)
[08:24:57.798]                             }
[08:24:57.798]                             else {
[08:24:57.798]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.798]                                 info, version)
[08:24:57.798]                             }
[08:24:57.798]                             base::stop(msg)
[08:24:57.798]                           }
[08:24:57.798]                         })
[08:24:57.798]                       }
[08:24:57.798]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:57.798]                       base::options(mc.cores = 1L)
[08:24:57.798]                     }
[08:24:57.798]                     base::local({
[08:24:57.798]                       for (pkg in "stats") {
[08:24:57.798]                         base::loadNamespace(pkg)
[08:24:57.798]                         base::library(pkg, character.only = TRUE)
[08:24:57.798]                       }
[08:24:57.798]                     })
[08:24:57.798]                   }
[08:24:57.798]                   ...future.strategy.old <- future::plan("list")
[08:24:57.798]                   options(future.plan = NULL)
[08:24:57.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.798]                 }
[08:24:57.798]                 ...future.workdir <- getwd()
[08:24:57.798]             }
[08:24:57.798]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.798]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.798]         }
[08:24:57.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.798]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:57.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.798]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.798]             base::names(...future.oldOptions))
[08:24:57.798]     }
[08:24:57.798]     if (FALSE) {
[08:24:57.798]     }
[08:24:57.798]     else {
[08:24:57.798]         if (TRUE) {
[08:24:57.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.798]                 open = "w")
[08:24:57.798]         }
[08:24:57.798]         else {
[08:24:57.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.798]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.798]         }
[08:24:57.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.798]             base::sink(type = "output", split = FALSE)
[08:24:57.798]             base::close(...future.stdout)
[08:24:57.798]         }, add = TRUE)
[08:24:57.798]     }
[08:24:57.798]     ...future.frame <- base::sys.nframe()
[08:24:57.798]     ...future.conditions <- base::list()
[08:24:57.798]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.798]     if (FALSE) {
[08:24:57.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.798]     }
[08:24:57.798]     ...future.result <- base::tryCatch({
[08:24:57.798]         base::withCallingHandlers({
[08:24:57.798]             ...future.value <- base::withVisible(base::local({
[08:24:57.798]                 withCallingHandlers({
[08:24:57.798]                   {
[08:24:57.798]                     do.call(function(...) {
[08:24:57.798]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.798]                       if (!identical(...future.globals.maxSize.org, 
[08:24:57.798]                         ...future.globals.maxSize)) {
[08:24:57.798]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.798]                         on.exit(options(oopts), add = TRUE)
[08:24:57.798]                       }
[08:24:57.798]                       {
[08:24:57.798]                         lapply(seq_along(...future.elements_ii), 
[08:24:57.798]                           FUN = function(jj) {
[08:24:57.798]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.798]                             ...future.FUN(...future.X_jj, ...)
[08:24:57.798]                           })
[08:24:57.798]                       }
[08:24:57.798]                     }, args = future.call.arguments)
[08:24:57.798]                   }
[08:24:57.798]                 }, immediateCondition = function(cond) {
[08:24:57.798]                   save_rds <- function (object, pathname, ...) 
[08:24:57.798]                   {
[08:24:57.798]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:57.798]                     if (file_test("-f", pathname_tmp)) {
[08:24:57.798]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.798]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:57.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.798]                         fi_tmp[["mtime"]])
[08:24:57.798]                     }
[08:24:57.798]                     tryCatch({
[08:24:57.798]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:57.798]                     }, error = function(ex) {
[08:24:57.798]                       msg <- conditionMessage(ex)
[08:24:57.798]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.798]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:57.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.798]                         fi_tmp[["mtime"]], msg)
[08:24:57.798]                       ex$message <- msg
[08:24:57.798]                       stop(ex)
[08:24:57.798]                     })
[08:24:57.798]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:57.798]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:57.798]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:57.798]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.798]                       fi <- file.info(pathname)
[08:24:57.798]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:57.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.798]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:57.798]                         fi[["size"]], fi[["mtime"]])
[08:24:57.798]                       stop(msg)
[08:24:57.798]                     }
[08:24:57.798]                     invisible(pathname)
[08:24:57.798]                   }
[08:24:57.798]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:57.798]                     rootPath = tempdir()) 
[08:24:57.798]                   {
[08:24:57.798]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:57.798]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:57.798]                       tmpdir = path, fileext = ".rds")
[08:24:57.798]                     save_rds(obj, file)
[08:24:57.798]                   }
[08:24:57.798]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:57.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.798]                   {
[08:24:57.798]                     inherits <- base::inherits
[08:24:57.798]                     invokeRestart <- base::invokeRestart
[08:24:57.798]                     is.null <- base::is.null
[08:24:57.798]                     muffled <- FALSE
[08:24:57.798]                     if (inherits(cond, "message")) {
[08:24:57.798]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:57.798]                       if (muffled) 
[08:24:57.798]                         invokeRestart("muffleMessage")
[08:24:57.798]                     }
[08:24:57.798]                     else if (inherits(cond, "warning")) {
[08:24:57.798]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:57.798]                       if (muffled) 
[08:24:57.798]                         invokeRestart("muffleWarning")
[08:24:57.798]                     }
[08:24:57.798]                     else if (inherits(cond, "condition")) {
[08:24:57.798]                       if (!is.null(pattern)) {
[08:24:57.798]                         computeRestarts <- base::computeRestarts
[08:24:57.798]                         grepl <- base::grepl
[08:24:57.798]                         restarts <- computeRestarts(cond)
[08:24:57.798]                         for (restart in restarts) {
[08:24:57.798]                           name <- restart$name
[08:24:57.798]                           if (is.null(name)) 
[08:24:57.798]                             next
[08:24:57.798]                           if (!grepl(pattern, name)) 
[08:24:57.798]                             next
[08:24:57.798]                           invokeRestart(restart)
[08:24:57.798]                           muffled <- TRUE
[08:24:57.798]                           break
[08:24:57.798]                         }
[08:24:57.798]                       }
[08:24:57.798]                     }
[08:24:57.798]                     invisible(muffled)
[08:24:57.798]                   }
[08:24:57.798]                   muffleCondition(cond)
[08:24:57.798]                 })
[08:24:57.798]             }))
[08:24:57.798]             future::FutureResult(value = ...future.value$value, 
[08:24:57.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.798]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.798]                     ...future.globalenv.names))
[08:24:57.798]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.798]         }, condition = base::local({
[08:24:57.798]             c <- base::c
[08:24:57.798]             inherits <- base::inherits
[08:24:57.798]             invokeRestart <- base::invokeRestart
[08:24:57.798]             length <- base::length
[08:24:57.798]             list <- base::list
[08:24:57.798]             seq.int <- base::seq.int
[08:24:57.798]             signalCondition <- base::signalCondition
[08:24:57.798]             sys.calls <- base::sys.calls
[08:24:57.798]             `[[` <- base::`[[`
[08:24:57.798]             `+` <- base::`+`
[08:24:57.798]             `<<-` <- base::`<<-`
[08:24:57.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.798]                   3L)]
[08:24:57.798]             }
[08:24:57.798]             function(cond) {
[08:24:57.798]                 is_error <- inherits(cond, "error")
[08:24:57.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.798]                   NULL)
[08:24:57.798]                 if (is_error) {
[08:24:57.798]                   sessionInformation <- function() {
[08:24:57.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.798]                       search = base::search(), system = base::Sys.info())
[08:24:57.798]                   }
[08:24:57.798]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.798]                     cond$call), session = sessionInformation(), 
[08:24:57.798]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.798]                   signalCondition(cond)
[08:24:57.798]                 }
[08:24:57.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.798]                 "immediateCondition"))) {
[08:24:57.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.798]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.798]                   if (TRUE && !signal) {
[08:24:57.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.798]                     {
[08:24:57.798]                       inherits <- base::inherits
[08:24:57.798]                       invokeRestart <- base::invokeRestart
[08:24:57.798]                       is.null <- base::is.null
[08:24:57.798]                       muffled <- FALSE
[08:24:57.798]                       if (inherits(cond, "message")) {
[08:24:57.798]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.798]                         if (muffled) 
[08:24:57.798]                           invokeRestart("muffleMessage")
[08:24:57.798]                       }
[08:24:57.798]                       else if (inherits(cond, "warning")) {
[08:24:57.798]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.798]                         if (muffled) 
[08:24:57.798]                           invokeRestart("muffleWarning")
[08:24:57.798]                       }
[08:24:57.798]                       else if (inherits(cond, "condition")) {
[08:24:57.798]                         if (!is.null(pattern)) {
[08:24:57.798]                           computeRestarts <- base::computeRestarts
[08:24:57.798]                           grepl <- base::grepl
[08:24:57.798]                           restarts <- computeRestarts(cond)
[08:24:57.798]                           for (restart in restarts) {
[08:24:57.798]                             name <- restart$name
[08:24:57.798]                             if (is.null(name)) 
[08:24:57.798]                               next
[08:24:57.798]                             if (!grepl(pattern, name)) 
[08:24:57.798]                               next
[08:24:57.798]                             invokeRestart(restart)
[08:24:57.798]                             muffled <- TRUE
[08:24:57.798]                             break
[08:24:57.798]                           }
[08:24:57.798]                         }
[08:24:57.798]                       }
[08:24:57.798]                       invisible(muffled)
[08:24:57.798]                     }
[08:24:57.798]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.798]                   }
[08:24:57.798]                 }
[08:24:57.798]                 else {
[08:24:57.798]                   if (TRUE) {
[08:24:57.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.798]                     {
[08:24:57.798]                       inherits <- base::inherits
[08:24:57.798]                       invokeRestart <- base::invokeRestart
[08:24:57.798]                       is.null <- base::is.null
[08:24:57.798]                       muffled <- FALSE
[08:24:57.798]                       if (inherits(cond, "message")) {
[08:24:57.798]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.798]                         if (muffled) 
[08:24:57.798]                           invokeRestart("muffleMessage")
[08:24:57.798]                       }
[08:24:57.798]                       else if (inherits(cond, "warning")) {
[08:24:57.798]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.798]                         if (muffled) 
[08:24:57.798]                           invokeRestart("muffleWarning")
[08:24:57.798]                       }
[08:24:57.798]                       else if (inherits(cond, "condition")) {
[08:24:57.798]                         if (!is.null(pattern)) {
[08:24:57.798]                           computeRestarts <- base::computeRestarts
[08:24:57.798]                           grepl <- base::grepl
[08:24:57.798]                           restarts <- computeRestarts(cond)
[08:24:57.798]                           for (restart in restarts) {
[08:24:57.798]                             name <- restart$name
[08:24:57.798]                             if (is.null(name)) 
[08:24:57.798]                               next
[08:24:57.798]                             if (!grepl(pattern, name)) 
[08:24:57.798]                               next
[08:24:57.798]                             invokeRestart(restart)
[08:24:57.798]                             muffled <- TRUE
[08:24:57.798]                             break
[08:24:57.798]                           }
[08:24:57.798]                         }
[08:24:57.798]                       }
[08:24:57.798]                       invisible(muffled)
[08:24:57.798]                     }
[08:24:57.798]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.798]                   }
[08:24:57.798]                 }
[08:24:57.798]             }
[08:24:57.798]         }))
[08:24:57.798]     }, error = function(ex) {
[08:24:57.798]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.798]                 ...future.rng), started = ...future.startTime, 
[08:24:57.798]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.798]             version = "1.8"), class = "FutureResult")
[08:24:57.798]     }, finally = {
[08:24:57.798]         if (!identical(...future.workdir, getwd())) 
[08:24:57.798]             setwd(...future.workdir)
[08:24:57.798]         {
[08:24:57.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.798]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.798]             }
[08:24:57.798]             base::options(...future.oldOptions)
[08:24:57.798]             if (.Platform$OS.type == "windows") {
[08:24:57.798]                 old_names <- names(...future.oldEnvVars)
[08:24:57.798]                 envs <- base::Sys.getenv()
[08:24:57.798]                 names <- names(envs)
[08:24:57.798]                 common <- intersect(names, old_names)
[08:24:57.798]                 added <- setdiff(names, old_names)
[08:24:57.798]                 removed <- setdiff(old_names, names)
[08:24:57.798]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.798]                   envs[common]]
[08:24:57.798]                 NAMES <- toupper(changed)
[08:24:57.798]                 args <- list()
[08:24:57.798]                 for (kk in seq_along(NAMES)) {
[08:24:57.798]                   name <- changed[[kk]]
[08:24:57.798]                   NAME <- NAMES[[kk]]
[08:24:57.798]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.798]                     next
[08:24:57.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.798]                 }
[08:24:57.798]                 NAMES <- toupper(added)
[08:24:57.798]                 for (kk in seq_along(NAMES)) {
[08:24:57.798]                   name <- added[[kk]]
[08:24:57.798]                   NAME <- NAMES[[kk]]
[08:24:57.798]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.798]                     next
[08:24:57.798]                   args[[name]] <- ""
[08:24:57.798]                 }
[08:24:57.798]                 NAMES <- toupper(removed)
[08:24:57.798]                 for (kk in seq_along(NAMES)) {
[08:24:57.798]                   name <- removed[[kk]]
[08:24:57.798]                   NAME <- NAMES[[kk]]
[08:24:57.798]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.798]                     next
[08:24:57.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.798]                 }
[08:24:57.798]                 if (length(args) > 0) 
[08:24:57.798]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.798]             }
[08:24:57.798]             else {
[08:24:57.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.798]             }
[08:24:57.798]             {
[08:24:57.798]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.798]                   0L) {
[08:24:57.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.798]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.798]                   base::options(opts)
[08:24:57.798]                 }
[08:24:57.798]                 {
[08:24:57.798]                   {
[08:24:57.798]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:57.798]                     NULL
[08:24:57.798]                   }
[08:24:57.798]                   options(future.plan = NULL)
[08:24:57.798]                   if (is.na(NA_character_)) 
[08:24:57.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.798]                     .init = FALSE)
[08:24:57.798]                 }
[08:24:57.798]             }
[08:24:57.798]         }
[08:24:57.798]     })
[08:24:57.798]     if (TRUE) {
[08:24:57.798]         base::sink(type = "output", split = FALSE)
[08:24:57.798]         if (TRUE) {
[08:24:57.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.798]         }
[08:24:57.798]         else {
[08:24:57.798]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.798]         }
[08:24:57.798]         base::close(...future.stdout)
[08:24:57.798]         ...future.stdout <- NULL
[08:24:57.798]     }
[08:24:57.798]     ...future.result$conditions <- ...future.conditions
[08:24:57.798]     ...future.result$finished <- base::Sys.time()
[08:24:57.798]     ...future.result
[08:24:57.798] }
[08:24:57.802] assign_globals() ...
[08:24:57.802] List of 5
[08:24:57.802]  $ ...future.FUN            :function (x, ...)  
[08:24:57.802]  $ future.call.arguments    :List of 1
[08:24:57.802]   ..$ singular.ok: logi FALSE
[08:24:57.802]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.802]  $ ...future.elements_ii    :List of 2
[08:24:57.802]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.802]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.802]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.802]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.802]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.802]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.802]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.802]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.802]  $ ...future.seeds_ii       : NULL
[08:24:57.802]  $ ...future.globals.maxSize: NULL
[08:24:57.802]  - attr(*, "where")=List of 5
[08:24:57.802]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.802]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.802]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.802]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.802]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.802]  - attr(*, "resolved")= logi FALSE
[08:24:57.802]  - attr(*, "total_size")= num 19977
[08:24:57.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.802]  - attr(*, "already-done")= logi TRUE
[08:24:57.819] - reassign environment for ‘...future.FUN’
[08:24:57.819] - copied ‘...future.FUN’ to environment
[08:24:57.819] - copied ‘future.call.arguments’ to environment
[08:24:57.819] - copied ‘...future.elements_ii’ to environment
[08:24:57.819] - copied ‘...future.seeds_ii’ to environment
[08:24:57.819] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.820] assign_globals() ... done
[08:24:57.820] requestCore(): workers = 2
[08:24:57.822] MulticoreFuture started
[08:24:57.823] - Launch lazy future ... done
[08:24:57.823] run() for ‘MulticoreFuture’ ... done
[08:24:57.823] Created future:
[08:24:57.824] plan(): Setting new future strategy stack:
[08:24:57.824] List of future strategies:
[08:24:57.824] 1. sequential:
[08:24:57.824]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.824]    - tweaked: FALSE
[08:24:57.824]    - call: NULL
[08:24:57.825] plan(): nbrOfWorkers() = 1
[08:24:57.831] plan(): Setting new future strategy stack:
[08:24:57.831] List of future strategies:
[08:24:57.831] 1. multicore:
[08:24:57.831]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.831]    - tweaked: FALSE
[08:24:57.831]    - call: plan(strategy)
[08:24:57.834] plan(): nbrOfWorkers() = 2
[08:24:57.823] MulticoreFuture:
[08:24:57.823] Label: ‘future_by-2’
[08:24:57.823] Expression:
[08:24:57.823] {
[08:24:57.823]     do.call(function(...) {
[08:24:57.823]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.823]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.823]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.823]             on.exit(options(oopts), add = TRUE)
[08:24:57.823]         }
[08:24:57.823]         {
[08:24:57.823]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.823]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.823]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.823]             })
[08:24:57.823]         }
[08:24:57.823]     }, args = future.call.arguments)
[08:24:57.823] }
[08:24:57.823] Lazy evaluation: FALSE
[08:24:57.823] Asynchronous evaluation: TRUE
[08:24:57.823] Local evaluation: TRUE
[08:24:57.823] Environment: R_GlobalEnv
[08:24:57.823] Capture standard output: TRUE
[08:24:57.823] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.823] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:57.823] Packages: 1 packages (‘stats’)
[08:24:57.823] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.823] Resolved: TRUE
[08:24:57.823] Value: <not collected>
[08:24:57.823] Conditions captured: <none>
[08:24:57.823] Early signaling: FALSE
[08:24:57.823] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.823] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.836] Chunk #2 of 2 ... DONE
[08:24:57.836] Launching 2 futures (chunks) ... DONE
[08:24:57.836] Resolving 2 futures (chunks) ...
[08:24:57.837] resolve() on list ...
[08:24:57.837]  recursive: 0
[08:24:57.837]  length: 2
[08:24:57.837] 
[08:24:57.837] Future #1
[08:24:57.838] result() for MulticoreFuture ...
[08:24:57.839] result() for MulticoreFuture ...
[08:24:57.839] result() for MulticoreFuture ... done
[08:24:57.840] result() for MulticoreFuture ... done
[08:24:57.840] result() for MulticoreFuture ...
[08:24:57.840] result() for MulticoreFuture ... done
[08:24:57.840] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:57.840] - nx: 2
[08:24:57.840] - relay: TRUE
[08:24:57.840] - stdout: TRUE
[08:24:57.840] - signal: TRUE
[08:24:57.841] - resignal: FALSE
[08:24:57.841] - force: TRUE
[08:24:57.841] - relayed: [n=2] FALSE, FALSE
[08:24:57.841] - queued futures: [n=2] FALSE, FALSE
[08:24:57.841]  - until=1
[08:24:57.841]  - relaying element #1
[08:24:57.841] result() for MulticoreFuture ...
[08:24:57.841] result() for MulticoreFuture ... done
[08:24:57.842] result() for MulticoreFuture ...
[08:24:57.842] result() for MulticoreFuture ... done
[08:24:57.842] result() for MulticoreFuture ...
[08:24:57.842] result() for MulticoreFuture ... done
[08:24:57.842] result() for MulticoreFuture ...
[08:24:57.842] result() for MulticoreFuture ... done
[08:24:57.843] - relayed: [n=2] TRUE, FALSE
[08:24:57.843] - queued futures: [n=2] TRUE, FALSE
[08:24:57.843] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:57.843]  length: 1 (resolved future 1)
[08:24:57.844] Future #2
[08:24:57.844] result() for MulticoreFuture ...
[08:24:57.845] result() for MulticoreFuture ...
[08:24:57.845] result() for MulticoreFuture ... done
[08:24:57.845] result() for MulticoreFuture ... done
[08:24:57.846] result() for MulticoreFuture ...
[08:24:57.846] result() for MulticoreFuture ... done
[08:24:57.846] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:57.846] - nx: 2
[08:24:57.846] - relay: TRUE
[08:24:57.846] - stdout: TRUE
[08:24:57.846] - signal: TRUE
[08:24:57.847] - resignal: FALSE
[08:24:57.847] - force: TRUE
[08:24:57.847] - relayed: [n=2] TRUE, FALSE
[08:24:57.847] - queued futures: [n=2] TRUE, FALSE
[08:24:57.847]  - until=2
[08:24:57.847]  - relaying element #2
[08:24:57.847] result() for MulticoreFuture ...
[08:24:57.847] result() for MulticoreFuture ... done
[08:24:57.848] result() for MulticoreFuture ...
[08:24:57.848] result() for MulticoreFuture ... done
[08:24:57.848] result() for MulticoreFuture ...
[08:24:57.848] result() for MulticoreFuture ... done
[08:24:57.848] result() for MulticoreFuture ...
[08:24:57.848] result() for MulticoreFuture ... done
[08:24:57.848] - relayed: [n=2] TRUE, TRUE
[08:24:57.848] - queued futures: [n=2] TRUE, TRUE
[08:24:57.849] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:57.849]  length: 0 (resolved future 2)
[08:24:57.849] Relaying remaining futures
[08:24:57.849] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.849] - nx: 2
[08:24:57.849] - relay: TRUE
[08:24:57.849] - stdout: TRUE
[08:24:57.849] - signal: TRUE
[08:24:57.849] - resignal: FALSE
[08:24:57.849] - force: TRUE
[08:24:57.850] - relayed: [n=2] TRUE, TRUE
[08:24:57.850] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:57.850] - relayed: [n=2] TRUE, TRUE
[08:24:57.850] - queued futures: [n=2] TRUE, TRUE
[08:24:57.850] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.850] resolve() on list ... DONE
[08:24:57.850] result() for MulticoreFuture ...
[08:24:57.850] result() for MulticoreFuture ... done
[08:24:57.851] result() for MulticoreFuture ...
[08:24:57.854] result() for MulticoreFuture ... done
[08:24:57.854] result() for MulticoreFuture ...
[08:24:57.854] result() for MulticoreFuture ... done
[08:24:57.854] result() for MulticoreFuture ...
[08:24:57.854] result() for MulticoreFuture ... done
[08:24:57.854]  - Number of value chunks collected: 2
[08:24:57.855] Resolving 2 futures (chunks) ... DONE
[08:24:57.855] Reducing values from 2 chunks ...
[08:24:57.855]  - Number of values collected after concatenation: 3
[08:24:57.855]  - Number of values expected: 3
[08:24:57.855] Reducing values from 2 chunks ... DONE
[08:24:57.855] future_lapply() ... DONE
[08:24:57.856] future_by_internal() ... DONE
[08:24:57.862] future_by_internal() ...
[08:24:57.863] future_lapply() ...
[08:24:57.866] Number of chunks: 2
[08:24:57.866] getGlobalsAndPackagesXApply() ...
[08:24:57.866]  - future.globals: TRUE
[08:24:57.866] getGlobalsAndPackages() ...
[08:24:57.866] Searching for globals...
[08:24:57.868] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:57.868] Searching for globals ... DONE
[08:24:57.868] Resolving globals: FALSE
[08:24:57.869] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[08:24:57.869] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[08:24:57.869] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:57.869] - packages: [1] ‘stats’
[08:24:57.869] getGlobalsAndPackages() ... DONE
[08:24:57.870]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:57.870]  - needed namespaces: [n=1] ‘stats’
[08:24:57.870] Finding globals ... DONE
[08:24:57.870]  - use_args: TRUE
[08:24:57.870]  - Getting '...' globals ...
[08:24:57.870] resolve() on list ...
[08:24:57.870]  recursive: 0
[08:24:57.871]  length: 1
[08:24:57.871]  elements: ‘...’
[08:24:57.871]  length: 0 (resolved future 1)
[08:24:57.871] resolve() on list ... DONE
[08:24:57.871]    - '...' content: [n=0] 
[08:24:57.871] List of 1
[08:24:57.871]  $ ...: list()
[08:24:57.871]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.871]  - attr(*, "where")=List of 1
[08:24:57.871]   ..$ ...:<environment: 0x557b26aeed28> 
[08:24:57.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.871]  - attr(*, "resolved")= logi TRUE
[08:24:57.871]  - attr(*, "total_size")= num NA
[08:24:57.874]  - Getting '...' globals ... DONE
[08:24:57.874] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[08:24:57.874] List of 4
[08:24:57.874]  $ ...future.FUN:function (x)  
[08:24:57.874]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:57.874]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.874]  $ ...          : list()
[08:24:57.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.874]  - attr(*, "where")=List of 4
[08:24:57.874]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:57.874]   ..$ breaks       :<environment: R_EmptyEnv> 
[08:24:57.874]   ..$ wool         :<environment: R_EmptyEnv> 
[08:24:57.874]   ..$ ...          :<environment: 0x557b26aeed28> 
[08:24:57.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.874]  - attr(*, "resolved")= logi FALSE
[08:24:57.874]  - attr(*, "total_size")= num 18867
[08:24:57.881] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:57.881] getGlobalsAndPackagesXApply() ... DONE
[08:24:57.881] Number of futures (= number of chunks): 2
[08:24:57.882] Launching 2 futures (chunks) ...
[08:24:57.882] Chunk #1 of 2 ...
[08:24:57.882]  - Finding globals in 'X' for chunk #1 ...
[08:24:57.882] getGlobalsAndPackages() ...
[08:24:57.882] Searching for globals...
[08:24:57.882] 
[08:24:57.883] Searching for globals ... DONE
[08:24:57.883] - globals: [0] <none>
[08:24:57.883] getGlobalsAndPackages() ... DONE
[08:24:57.883]    + additional globals found: [n=0] 
[08:24:57.883]    + additional namespaces needed: [n=0] 
[08:24:57.883]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:57.883]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:57.883]  - seeds: <none>
[08:24:57.883]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.884] getGlobalsAndPackages() ...
[08:24:57.884] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.884] Resolving globals: FALSE
[08:24:57.884] Tweak future expression to call with '...' arguments ...
[08:24:57.884] {
[08:24:57.884]     do.call(function(...) {
[08:24:57.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.884]             on.exit(options(oopts), add = TRUE)
[08:24:57.884]         }
[08:24:57.884]         {
[08:24:57.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.884]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.884]             })
[08:24:57.884]         }
[08:24:57.884]     }, args = future.call.arguments)
[08:24:57.884] }
[08:24:57.884] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.885] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.885] 
[08:24:57.885] getGlobalsAndPackages() ... DONE
[08:24:57.885] run() for ‘Future’ ...
[08:24:57.885] - state: ‘created’
[08:24:57.886] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.887] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:57.888]   - Field: ‘label’
[08:24:57.888]   - Field: ‘local’
[08:24:57.888]   - Field: ‘owner’
[08:24:57.888]   - Field: ‘envir’
[08:24:57.888]   - Field: ‘workers’
[08:24:57.888]   - Field: ‘packages’
[08:24:57.888]   - Field: ‘gc’
[08:24:57.888]   - Field: ‘job’
[08:24:57.888]   - Field: ‘conditions’
[08:24:57.888]   - Field: ‘expr’
[08:24:57.889]   - Field: ‘uuid’
[08:24:57.889]   - Field: ‘seed’
[08:24:57.889]   - Field: ‘version’
[08:24:57.889]   - Field: ‘result’
[08:24:57.889]   - Field: ‘asynchronous’
[08:24:57.889]   - Field: ‘calls’
[08:24:57.889]   - Field: ‘globals’
[08:24:57.889]   - Field: ‘stdout’
[08:24:57.889]   - Field: ‘earlySignal’
[08:24:57.889]   - Field: ‘lazy’
[08:24:57.889]   - Field: ‘state’
[08:24:57.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:57.890] - Launch lazy future ...
[08:24:57.890] Packages needed by the future expression (n = 1): ‘stats’
[08:24:57.890] Packages needed by future strategies (n = 0): <none>
[08:24:57.891] {
[08:24:57.891]     {
[08:24:57.891]         {
[08:24:57.891]             ...future.startTime <- base::Sys.time()
[08:24:57.891]             {
[08:24:57.891]                 {
[08:24:57.891]                   {
[08:24:57.891]                     {
[08:24:57.891]                       {
[08:24:57.891]                         base::local({
[08:24:57.891]                           has_future <- base::requireNamespace("future", 
[08:24:57.891]                             quietly = TRUE)
[08:24:57.891]                           if (has_future) {
[08:24:57.891]                             ns <- base::getNamespace("future")
[08:24:57.891]                             version <- ns[[".package"]][["version"]]
[08:24:57.891]                             if (is.null(version)) 
[08:24:57.891]                               version <- utils::packageVersion("future")
[08:24:57.891]                           }
[08:24:57.891]                           else {
[08:24:57.891]                             version <- NULL
[08:24:57.891]                           }
[08:24:57.891]                           if (!has_future || version < "1.8.0") {
[08:24:57.891]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.891]                               "", base::R.version$version.string), 
[08:24:57.891]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:57.891]                                 base::R.version$platform, 8 * 
[08:24:57.891]                                   base::.Machine$sizeof.pointer), 
[08:24:57.891]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.891]                                 "release", "version")], collapse = " "), 
[08:24:57.891]                               hostname = base::Sys.info()[["nodename"]])
[08:24:57.891]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.891]                               info)
[08:24:57.891]                             info <- base::paste(info, collapse = "; ")
[08:24:57.891]                             if (!has_future) {
[08:24:57.891]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.891]                                 info)
[08:24:57.891]                             }
[08:24:57.891]                             else {
[08:24:57.891]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.891]                                 info, version)
[08:24:57.891]                             }
[08:24:57.891]                             base::stop(msg)
[08:24:57.891]                           }
[08:24:57.891]                         })
[08:24:57.891]                       }
[08:24:57.891]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:57.891]                       base::options(mc.cores = 1L)
[08:24:57.891]                     }
[08:24:57.891]                     base::local({
[08:24:57.891]                       for (pkg in "stats") {
[08:24:57.891]                         base::loadNamespace(pkg)
[08:24:57.891]                         base::library(pkg, character.only = TRUE)
[08:24:57.891]                       }
[08:24:57.891]                     })
[08:24:57.891]                   }
[08:24:57.891]                   ...future.strategy.old <- future::plan("list")
[08:24:57.891]                   options(future.plan = NULL)
[08:24:57.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.891]                 }
[08:24:57.891]                 ...future.workdir <- getwd()
[08:24:57.891]             }
[08:24:57.891]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.891]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.891]         }
[08:24:57.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.891]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:57.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.891]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.891]             base::names(...future.oldOptions))
[08:24:57.891]     }
[08:24:57.891]     if (FALSE) {
[08:24:57.891]     }
[08:24:57.891]     else {
[08:24:57.891]         if (TRUE) {
[08:24:57.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.891]                 open = "w")
[08:24:57.891]         }
[08:24:57.891]         else {
[08:24:57.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.891]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.891]         }
[08:24:57.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.891]             base::sink(type = "output", split = FALSE)
[08:24:57.891]             base::close(...future.stdout)
[08:24:57.891]         }, add = TRUE)
[08:24:57.891]     }
[08:24:57.891]     ...future.frame <- base::sys.nframe()
[08:24:57.891]     ...future.conditions <- base::list()
[08:24:57.891]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.891]     if (FALSE) {
[08:24:57.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.891]     }
[08:24:57.891]     ...future.result <- base::tryCatch({
[08:24:57.891]         base::withCallingHandlers({
[08:24:57.891]             ...future.value <- base::withVisible(base::local({
[08:24:57.891]                 withCallingHandlers({
[08:24:57.891]                   {
[08:24:57.891]                     do.call(function(...) {
[08:24:57.891]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.891]                       if (!identical(...future.globals.maxSize.org, 
[08:24:57.891]                         ...future.globals.maxSize)) {
[08:24:57.891]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.891]                         on.exit(options(oopts), add = TRUE)
[08:24:57.891]                       }
[08:24:57.891]                       {
[08:24:57.891]                         lapply(seq_along(...future.elements_ii), 
[08:24:57.891]                           FUN = function(jj) {
[08:24:57.891]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.891]                             ...future.FUN(...future.X_jj, ...)
[08:24:57.891]                           })
[08:24:57.891]                       }
[08:24:57.891]                     }, args = future.call.arguments)
[08:24:57.891]                   }
[08:24:57.891]                 }, immediateCondition = function(cond) {
[08:24:57.891]                   save_rds <- function (object, pathname, ...) 
[08:24:57.891]                   {
[08:24:57.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:57.891]                     if (file_test("-f", pathname_tmp)) {
[08:24:57.891]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:57.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.891]                         fi_tmp[["mtime"]])
[08:24:57.891]                     }
[08:24:57.891]                     tryCatch({
[08:24:57.891]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:57.891]                     }, error = function(ex) {
[08:24:57.891]                       msg <- conditionMessage(ex)
[08:24:57.891]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:57.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.891]                         fi_tmp[["mtime"]], msg)
[08:24:57.891]                       ex$message <- msg
[08:24:57.891]                       stop(ex)
[08:24:57.891]                     })
[08:24:57.891]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:57.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:57.891]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:57.891]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.891]                       fi <- file.info(pathname)
[08:24:57.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:57.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:57.891]                         fi[["size"]], fi[["mtime"]])
[08:24:57.891]                       stop(msg)
[08:24:57.891]                     }
[08:24:57.891]                     invisible(pathname)
[08:24:57.891]                   }
[08:24:57.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:57.891]                     rootPath = tempdir()) 
[08:24:57.891]                   {
[08:24:57.891]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:57.891]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:57.891]                       tmpdir = path, fileext = ".rds")
[08:24:57.891]                     save_rds(obj, file)
[08:24:57.891]                   }
[08:24:57.891]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:57.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.891]                   {
[08:24:57.891]                     inherits <- base::inherits
[08:24:57.891]                     invokeRestart <- base::invokeRestart
[08:24:57.891]                     is.null <- base::is.null
[08:24:57.891]                     muffled <- FALSE
[08:24:57.891]                     if (inherits(cond, "message")) {
[08:24:57.891]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:57.891]                       if (muffled) 
[08:24:57.891]                         invokeRestart("muffleMessage")
[08:24:57.891]                     }
[08:24:57.891]                     else if (inherits(cond, "warning")) {
[08:24:57.891]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:57.891]                       if (muffled) 
[08:24:57.891]                         invokeRestart("muffleWarning")
[08:24:57.891]                     }
[08:24:57.891]                     else if (inherits(cond, "condition")) {
[08:24:57.891]                       if (!is.null(pattern)) {
[08:24:57.891]                         computeRestarts <- base::computeRestarts
[08:24:57.891]                         grepl <- base::grepl
[08:24:57.891]                         restarts <- computeRestarts(cond)
[08:24:57.891]                         for (restart in restarts) {
[08:24:57.891]                           name <- restart$name
[08:24:57.891]                           if (is.null(name)) 
[08:24:57.891]                             next
[08:24:57.891]                           if (!grepl(pattern, name)) 
[08:24:57.891]                             next
[08:24:57.891]                           invokeRestart(restart)
[08:24:57.891]                           muffled <- TRUE
[08:24:57.891]                           break
[08:24:57.891]                         }
[08:24:57.891]                       }
[08:24:57.891]                     }
[08:24:57.891]                     invisible(muffled)
[08:24:57.891]                   }
[08:24:57.891]                   muffleCondition(cond)
[08:24:57.891]                 })
[08:24:57.891]             }))
[08:24:57.891]             future::FutureResult(value = ...future.value$value, 
[08:24:57.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.891]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.891]                     ...future.globalenv.names))
[08:24:57.891]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.891]         }, condition = base::local({
[08:24:57.891]             c <- base::c
[08:24:57.891]             inherits <- base::inherits
[08:24:57.891]             invokeRestart <- base::invokeRestart
[08:24:57.891]             length <- base::length
[08:24:57.891]             list <- base::list
[08:24:57.891]             seq.int <- base::seq.int
[08:24:57.891]             signalCondition <- base::signalCondition
[08:24:57.891]             sys.calls <- base::sys.calls
[08:24:57.891]             `[[` <- base::`[[`
[08:24:57.891]             `+` <- base::`+`
[08:24:57.891]             `<<-` <- base::`<<-`
[08:24:57.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.891]                   3L)]
[08:24:57.891]             }
[08:24:57.891]             function(cond) {
[08:24:57.891]                 is_error <- inherits(cond, "error")
[08:24:57.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.891]                   NULL)
[08:24:57.891]                 if (is_error) {
[08:24:57.891]                   sessionInformation <- function() {
[08:24:57.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.891]                       search = base::search(), system = base::Sys.info())
[08:24:57.891]                   }
[08:24:57.891]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.891]                     cond$call), session = sessionInformation(), 
[08:24:57.891]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.891]                   signalCondition(cond)
[08:24:57.891]                 }
[08:24:57.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.891]                 "immediateCondition"))) {
[08:24:57.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.891]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.891]                   if (TRUE && !signal) {
[08:24:57.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.891]                     {
[08:24:57.891]                       inherits <- base::inherits
[08:24:57.891]                       invokeRestart <- base::invokeRestart
[08:24:57.891]                       is.null <- base::is.null
[08:24:57.891]                       muffled <- FALSE
[08:24:57.891]                       if (inherits(cond, "message")) {
[08:24:57.891]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.891]                         if (muffled) 
[08:24:57.891]                           invokeRestart("muffleMessage")
[08:24:57.891]                       }
[08:24:57.891]                       else if (inherits(cond, "warning")) {
[08:24:57.891]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.891]                         if (muffled) 
[08:24:57.891]                           invokeRestart("muffleWarning")
[08:24:57.891]                       }
[08:24:57.891]                       else if (inherits(cond, "condition")) {
[08:24:57.891]                         if (!is.null(pattern)) {
[08:24:57.891]                           computeRestarts <- base::computeRestarts
[08:24:57.891]                           grepl <- base::grepl
[08:24:57.891]                           restarts <- computeRestarts(cond)
[08:24:57.891]                           for (restart in restarts) {
[08:24:57.891]                             name <- restart$name
[08:24:57.891]                             if (is.null(name)) 
[08:24:57.891]                               next
[08:24:57.891]                             if (!grepl(pattern, name)) 
[08:24:57.891]                               next
[08:24:57.891]                             invokeRestart(restart)
[08:24:57.891]                             muffled <- TRUE
[08:24:57.891]                             break
[08:24:57.891]                           }
[08:24:57.891]                         }
[08:24:57.891]                       }
[08:24:57.891]                       invisible(muffled)
[08:24:57.891]                     }
[08:24:57.891]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.891]                   }
[08:24:57.891]                 }
[08:24:57.891]                 else {
[08:24:57.891]                   if (TRUE) {
[08:24:57.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.891]                     {
[08:24:57.891]                       inherits <- base::inherits
[08:24:57.891]                       invokeRestart <- base::invokeRestart
[08:24:57.891]                       is.null <- base::is.null
[08:24:57.891]                       muffled <- FALSE
[08:24:57.891]                       if (inherits(cond, "message")) {
[08:24:57.891]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.891]                         if (muffled) 
[08:24:57.891]                           invokeRestart("muffleMessage")
[08:24:57.891]                       }
[08:24:57.891]                       else if (inherits(cond, "warning")) {
[08:24:57.891]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.891]                         if (muffled) 
[08:24:57.891]                           invokeRestart("muffleWarning")
[08:24:57.891]                       }
[08:24:57.891]                       else if (inherits(cond, "condition")) {
[08:24:57.891]                         if (!is.null(pattern)) {
[08:24:57.891]                           computeRestarts <- base::computeRestarts
[08:24:57.891]                           grepl <- base::grepl
[08:24:57.891]                           restarts <- computeRestarts(cond)
[08:24:57.891]                           for (restart in restarts) {
[08:24:57.891]                             name <- restart$name
[08:24:57.891]                             if (is.null(name)) 
[08:24:57.891]                               next
[08:24:57.891]                             if (!grepl(pattern, name)) 
[08:24:57.891]                               next
[08:24:57.891]                             invokeRestart(restart)
[08:24:57.891]                             muffled <- TRUE
[08:24:57.891]                             break
[08:24:57.891]                           }
[08:24:57.891]                         }
[08:24:57.891]                       }
[08:24:57.891]                       invisible(muffled)
[08:24:57.891]                     }
[08:24:57.891]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.891]                   }
[08:24:57.891]                 }
[08:24:57.891]             }
[08:24:57.891]         }))
[08:24:57.891]     }, error = function(ex) {
[08:24:57.891]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.891]                 ...future.rng), started = ...future.startTime, 
[08:24:57.891]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.891]             version = "1.8"), class = "FutureResult")
[08:24:57.891]     }, finally = {
[08:24:57.891]         if (!identical(...future.workdir, getwd())) 
[08:24:57.891]             setwd(...future.workdir)
[08:24:57.891]         {
[08:24:57.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.891]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.891]             }
[08:24:57.891]             base::options(...future.oldOptions)
[08:24:57.891]             if (.Platform$OS.type == "windows") {
[08:24:57.891]                 old_names <- names(...future.oldEnvVars)
[08:24:57.891]                 envs <- base::Sys.getenv()
[08:24:57.891]                 names <- names(envs)
[08:24:57.891]                 common <- intersect(names, old_names)
[08:24:57.891]                 added <- setdiff(names, old_names)
[08:24:57.891]                 removed <- setdiff(old_names, names)
[08:24:57.891]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.891]                   envs[common]]
[08:24:57.891]                 NAMES <- toupper(changed)
[08:24:57.891]                 args <- list()
[08:24:57.891]                 for (kk in seq_along(NAMES)) {
[08:24:57.891]                   name <- changed[[kk]]
[08:24:57.891]                   NAME <- NAMES[[kk]]
[08:24:57.891]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.891]                     next
[08:24:57.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.891]                 }
[08:24:57.891]                 NAMES <- toupper(added)
[08:24:57.891]                 for (kk in seq_along(NAMES)) {
[08:24:57.891]                   name <- added[[kk]]
[08:24:57.891]                   NAME <- NAMES[[kk]]
[08:24:57.891]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.891]                     next
[08:24:57.891]                   args[[name]] <- ""
[08:24:57.891]                 }
[08:24:57.891]                 NAMES <- toupper(removed)
[08:24:57.891]                 for (kk in seq_along(NAMES)) {
[08:24:57.891]                   name <- removed[[kk]]
[08:24:57.891]                   NAME <- NAMES[[kk]]
[08:24:57.891]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.891]                     next
[08:24:57.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.891]                 }
[08:24:57.891]                 if (length(args) > 0) 
[08:24:57.891]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.891]             }
[08:24:57.891]             else {
[08:24:57.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.891]             }
[08:24:57.891]             {
[08:24:57.891]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.891]                   0L) {
[08:24:57.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.891]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.891]                   base::options(opts)
[08:24:57.891]                 }
[08:24:57.891]                 {
[08:24:57.891]                   {
[08:24:57.891]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:57.891]                     NULL
[08:24:57.891]                   }
[08:24:57.891]                   options(future.plan = NULL)
[08:24:57.891]                   if (is.na(NA_character_)) 
[08:24:57.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.891]                     .init = FALSE)
[08:24:57.891]                 }
[08:24:57.891]             }
[08:24:57.891]         }
[08:24:57.891]     })
[08:24:57.891]     if (TRUE) {
[08:24:57.891]         base::sink(type = "output", split = FALSE)
[08:24:57.891]         if (TRUE) {
[08:24:57.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.891]         }
[08:24:57.891]         else {
[08:24:57.891]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.891]         }
[08:24:57.891]         base::close(...future.stdout)
[08:24:57.891]         ...future.stdout <- NULL
[08:24:57.891]     }
[08:24:57.891]     ...future.result$conditions <- ...future.conditions
[08:24:57.891]     ...future.result$finished <- base::Sys.time()
[08:24:57.891]     ...future.result
[08:24:57.891] }
[08:24:57.893] assign_globals() ...
[08:24:57.893] List of 7
[08:24:57.893]  $ ...future.FUN            :function (x)  
[08:24:57.893]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:57.893]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.893]  $ future.call.arguments    : list()
[08:24:57.893]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.893]  $ ...future.elements_ii    :List of 1
[08:24:57.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.893]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:57.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.893]  $ ...future.seeds_ii       : NULL
[08:24:57.893]  $ ...future.globals.maxSize: NULL
[08:24:57.893]  - attr(*, "where")=List of 7
[08:24:57.893]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.893]   ..$ breaks                   :<environment: R_EmptyEnv> 
[08:24:57.893]   ..$ wool                     :<environment: R_EmptyEnv> 
[08:24:57.893]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.893]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.893]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.893]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.893]  - attr(*, "resolved")= logi FALSE
[08:24:57.893]  - attr(*, "total_size")= num 18867
[08:24:57.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.893]  - attr(*, "already-done")= logi TRUE
[08:24:57.903] - reassign environment for ‘...future.FUN’
[08:24:57.903] - copied ‘...future.FUN’ to environment
[08:24:57.903] - copied ‘breaks’ to environment
[08:24:57.904] - copied ‘wool’ to environment
[08:24:57.904] - copied ‘future.call.arguments’ to environment
[08:24:57.904] - copied ‘...future.elements_ii’ to environment
[08:24:57.904] - copied ‘...future.seeds_ii’ to environment
[08:24:57.904] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.904] assign_globals() ... done
[08:24:57.904] requestCore(): workers = 2
[08:24:57.907] MulticoreFuture started
[08:24:57.908] - Launch lazy future ... done
[08:24:57.908] run() for ‘MulticoreFuture’ ... done
[08:24:57.909] Created future:
[08:24:57.909] plan(): Setting new future strategy stack:
[08:24:57.909] List of future strategies:
[08:24:57.909] 1. sequential:
[08:24:57.909]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.909]    - tweaked: FALSE
[08:24:57.909]    - call: NULL
[08:24:57.911] plan(): nbrOfWorkers() = 1
[08:24:57.917] plan(): Setting new future strategy stack:
[08:24:57.917] List of future strategies:
[08:24:57.917] 1. multicore:
[08:24:57.917]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.917]    - tweaked: FALSE
[08:24:57.917]    - call: plan(strategy)
[08:24:57.921] plan(): nbrOfWorkers() = 2
[08:24:57.909] MulticoreFuture:
[08:24:57.909] Label: ‘future_by-1’
[08:24:57.909] Expression:
[08:24:57.909] {
[08:24:57.909]     do.call(function(...) {
[08:24:57.909]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.909]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.909]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.909]             on.exit(options(oopts), add = TRUE)
[08:24:57.909]         }
[08:24:57.909]         {
[08:24:57.909]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.909]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.909]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.909]             })
[08:24:57.909]         }
[08:24:57.909]     }, args = future.call.arguments)
[08:24:57.909] }
[08:24:57.909] Lazy evaluation: FALSE
[08:24:57.909] Asynchronous evaluation: TRUE
[08:24:57.909] Local evaluation: TRUE
[08:24:57.909] Environment: 0x557b27226580
[08:24:57.909] Capture standard output: TRUE
[08:24:57.909] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.909] Globals: 7 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, ...)
[08:24:57.909] Packages: 1 packages (‘stats’)
[08:24:57.909] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.909] Resolved: TRUE
[08:24:57.909] Value: <not collected>
[08:24:57.909] Conditions captured: <none>
[08:24:57.909] Early signaling: FALSE
[08:24:57.909] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.909] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.923] Chunk #1 of 2 ... DONE
[08:24:57.923] Chunk #2 of 2 ...
[08:24:57.923]  - Finding globals in 'X' for chunk #2 ...
[08:24:57.924] getGlobalsAndPackages() ...
[08:24:57.924] Searching for globals...
[08:24:57.925] 
[08:24:57.925] Searching for globals ... DONE
[08:24:57.925] - globals: [0] <none>
[08:24:57.926] getGlobalsAndPackages() ... DONE
[08:24:57.926]    + additional globals found: [n=0] 
[08:24:57.926]    + additional namespaces needed: [n=0] 
[08:24:57.926]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:57.926]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:57.926]  - seeds: <none>
[08:24:57.926]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.927] getGlobalsAndPackages() ...
[08:24:57.927] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.927] Resolving globals: FALSE
[08:24:57.927] Tweak future expression to call with '...' arguments ...
[08:24:57.927] {
[08:24:57.927]     do.call(function(...) {
[08:24:57.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.927]             on.exit(options(oopts), add = TRUE)
[08:24:57.927]         }
[08:24:57.927]         {
[08:24:57.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.927]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.927]             })
[08:24:57.927]         }
[08:24:57.927]     }, args = future.call.arguments)
[08:24:57.927] }
[08:24:57.928] Tweak future expression to call with '...' arguments ... DONE
[08:24:57.928] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:57.929] 
[08:24:57.929] getGlobalsAndPackages() ... DONE
[08:24:57.929] run() for ‘Future’ ...
[08:24:57.930] - state: ‘created’
[08:24:57.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:57.932] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.933] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:57.933]   - Field: ‘label’
[08:24:57.933]   - Field: ‘local’
[08:24:57.933]   - Field: ‘owner’
[08:24:57.933]   - Field: ‘envir’
[08:24:57.933]   - Field: ‘workers’
[08:24:57.933]   - Field: ‘packages’
[08:24:57.934]   - Field: ‘gc’
[08:24:57.934]   - Field: ‘job’
[08:24:57.934]   - Field: ‘conditions’
[08:24:57.934]   - Field: ‘expr’
[08:24:57.934]   - Field: ‘uuid’
[08:24:57.934]   - Field: ‘seed’
[08:24:57.934]   - Field: ‘version’
[08:24:57.935]   - Field: ‘result’
[08:24:57.935]   - Field: ‘asynchronous’
[08:24:57.935]   - Field: ‘calls’
[08:24:57.935]   - Field: ‘globals’
[08:24:57.935]   - Field: ‘stdout’
[08:24:57.935]   - Field: ‘earlySignal’
[08:24:57.935]   - Field: ‘lazy’
[08:24:57.935]   - Field: ‘state’
[08:24:57.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:57.936] - Launch lazy future ...
[08:24:57.936] Packages needed by the future expression (n = 1): ‘stats’
[08:24:57.936] Packages needed by future strategies (n = 0): <none>
[08:24:57.937] {
[08:24:57.937]     {
[08:24:57.937]         {
[08:24:57.937]             ...future.startTime <- base::Sys.time()
[08:24:57.937]             {
[08:24:57.937]                 {
[08:24:57.937]                   {
[08:24:57.937]                     {
[08:24:57.937]                       {
[08:24:57.937]                         base::local({
[08:24:57.937]                           has_future <- base::requireNamespace("future", 
[08:24:57.937]                             quietly = TRUE)
[08:24:57.937]                           if (has_future) {
[08:24:57.937]                             ns <- base::getNamespace("future")
[08:24:57.937]                             version <- ns[[".package"]][["version"]]
[08:24:57.937]                             if (is.null(version)) 
[08:24:57.937]                               version <- utils::packageVersion("future")
[08:24:57.937]                           }
[08:24:57.937]                           else {
[08:24:57.937]                             version <- NULL
[08:24:57.937]                           }
[08:24:57.937]                           if (!has_future || version < "1.8.0") {
[08:24:57.937]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:57.937]                               "", base::R.version$version.string), 
[08:24:57.937]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:57.937]                                 base::R.version$platform, 8 * 
[08:24:57.937]                                   base::.Machine$sizeof.pointer), 
[08:24:57.937]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:57.937]                                 "release", "version")], collapse = " "), 
[08:24:57.937]                               hostname = base::Sys.info()[["nodename"]])
[08:24:57.937]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:57.937]                               info)
[08:24:57.937]                             info <- base::paste(info, collapse = "; ")
[08:24:57.937]                             if (!has_future) {
[08:24:57.937]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:57.937]                                 info)
[08:24:57.937]                             }
[08:24:57.937]                             else {
[08:24:57.937]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:57.937]                                 info, version)
[08:24:57.937]                             }
[08:24:57.937]                             base::stop(msg)
[08:24:57.937]                           }
[08:24:57.937]                         })
[08:24:57.937]                       }
[08:24:57.937]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:57.937]                       base::options(mc.cores = 1L)
[08:24:57.937]                     }
[08:24:57.937]                     base::local({
[08:24:57.937]                       for (pkg in "stats") {
[08:24:57.937]                         base::loadNamespace(pkg)
[08:24:57.937]                         base::library(pkg, character.only = TRUE)
[08:24:57.937]                       }
[08:24:57.937]                     })
[08:24:57.937]                   }
[08:24:57.937]                   ...future.strategy.old <- future::plan("list")
[08:24:57.937]                   options(future.plan = NULL)
[08:24:57.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:57.937]                 }
[08:24:57.937]                 ...future.workdir <- getwd()
[08:24:57.937]             }
[08:24:57.937]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:57.937]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:57.937]         }
[08:24:57.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:57.937]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:57.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:57.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:57.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:57.937]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:57.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:57.937]             base::names(...future.oldOptions))
[08:24:57.937]     }
[08:24:57.937]     if (FALSE) {
[08:24:57.937]     }
[08:24:57.937]     else {
[08:24:57.937]         if (TRUE) {
[08:24:57.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:57.937]                 open = "w")
[08:24:57.937]         }
[08:24:57.937]         else {
[08:24:57.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:57.937]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:57.937]         }
[08:24:57.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:57.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:57.937]             base::sink(type = "output", split = FALSE)
[08:24:57.937]             base::close(...future.stdout)
[08:24:57.937]         }, add = TRUE)
[08:24:57.937]     }
[08:24:57.937]     ...future.frame <- base::sys.nframe()
[08:24:57.937]     ...future.conditions <- base::list()
[08:24:57.937]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:57.937]     if (FALSE) {
[08:24:57.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:57.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:57.937]     }
[08:24:57.937]     ...future.result <- base::tryCatch({
[08:24:57.937]         base::withCallingHandlers({
[08:24:57.937]             ...future.value <- base::withVisible(base::local({
[08:24:57.937]                 withCallingHandlers({
[08:24:57.937]                   {
[08:24:57.937]                     do.call(function(...) {
[08:24:57.937]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.937]                       if (!identical(...future.globals.maxSize.org, 
[08:24:57.937]                         ...future.globals.maxSize)) {
[08:24:57.937]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.937]                         on.exit(options(oopts), add = TRUE)
[08:24:57.937]                       }
[08:24:57.937]                       {
[08:24:57.937]                         lapply(seq_along(...future.elements_ii), 
[08:24:57.937]                           FUN = function(jj) {
[08:24:57.937]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.937]                             ...future.FUN(...future.X_jj, ...)
[08:24:57.937]                           })
[08:24:57.937]                       }
[08:24:57.937]                     }, args = future.call.arguments)
[08:24:57.937]                   }
[08:24:57.937]                 }, immediateCondition = function(cond) {
[08:24:57.937]                   save_rds <- function (object, pathname, ...) 
[08:24:57.937]                   {
[08:24:57.937]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:57.937]                     if (file_test("-f", pathname_tmp)) {
[08:24:57.937]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.937]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:57.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.937]                         fi_tmp[["mtime"]])
[08:24:57.937]                     }
[08:24:57.937]                     tryCatch({
[08:24:57.937]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:57.937]                     }, error = function(ex) {
[08:24:57.937]                       msg <- conditionMessage(ex)
[08:24:57.937]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.937]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:57.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.937]                         fi_tmp[["mtime"]], msg)
[08:24:57.937]                       ex$message <- msg
[08:24:57.937]                       stop(ex)
[08:24:57.937]                     })
[08:24:57.937]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:57.937]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:57.937]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:57.937]                       fi_tmp <- file.info(pathname_tmp)
[08:24:57.937]                       fi <- file.info(pathname)
[08:24:57.937]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:57.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:57.937]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:57.937]                         fi[["size"]], fi[["mtime"]])
[08:24:57.937]                       stop(msg)
[08:24:57.937]                     }
[08:24:57.937]                     invisible(pathname)
[08:24:57.937]                   }
[08:24:57.937]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:57.937]                     rootPath = tempdir()) 
[08:24:57.937]                   {
[08:24:57.937]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:57.937]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:57.937]                       tmpdir = path, fileext = ".rds")
[08:24:57.937]                     save_rds(obj, file)
[08:24:57.937]                   }
[08:24:57.937]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:57.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.937]                   {
[08:24:57.937]                     inherits <- base::inherits
[08:24:57.937]                     invokeRestart <- base::invokeRestart
[08:24:57.937]                     is.null <- base::is.null
[08:24:57.937]                     muffled <- FALSE
[08:24:57.937]                     if (inherits(cond, "message")) {
[08:24:57.937]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:57.937]                       if (muffled) 
[08:24:57.937]                         invokeRestart("muffleMessage")
[08:24:57.937]                     }
[08:24:57.937]                     else if (inherits(cond, "warning")) {
[08:24:57.937]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:57.937]                       if (muffled) 
[08:24:57.937]                         invokeRestart("muffleWarning")
[08:24:57.937]                     }
[08:24:57.937]                     else if (inherits(cond, "condition")) {
[08:24:57.937]                       if (!is.null(pattern)) {
[08:24:57.937]                         computeRestarts <- base::computeRestarts
[08:24:57.937]                         grepl <- base::grepl
[08:24:57.937]                         restarts <- computeRestarts(cond)
[08:24:57.937]                         for (restart in restarts) {
[08:24:57.937]                           name <- restart$name
[08:24:57.937]                           if (is.null(name)) 
[08:24:57.937]                             next
[08:24:57.937]                           if (!grepl(pattern, name)) 
[08:24:57.937]                             next
[08:24:57.937]                           invokeRestart(restart)
[08:24:57.937]                           muffled <- TRUE
[08:24:57.937]                           break
[08:24:57.937]                         }
[08:24:57.937]                       }
[08:24:57.937]                     }
[08:24:57.937]                     invisible(muffled)
[08:24:57.937]                   }
[08:24:57.937]                   muffleCondition(cond)
[08:24:57.937]                 })
[08:24:57.937]             }))
[08:24:57.937]             future::FutureResult(value = ...future.value$value, 
[08:24:57.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.937]                   ...future.rng), globalenv = if (FALSE) 
[08:24:57.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:57.937]                     ...future.globalenv.names))
[08:24:57.937]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:57.937]         }, condition = base::local({
[08:24:57.937]             c <- base::c
[08:24:57.937]             inherits <- base::inherits
[08:24:57.937]             invokeRestart <- base::invokeRestart
[08:24:57.937]             length <- base::length
[08:24:57.937]             list <- base::list
[08:24:57.937]             seq.int <- base::seq.int
[08:24:57.937]             signalCondition <- base::signalCondition
[08:24:57.937]             sys.calls <- base::sys.calls
[08:24:57.937]             `[[` <- base::`[[`
[08:24:57.937]             `+` <- base::`+`
[08:24:57.937]             `<<-` <- base::`<<-`
[08:24:57.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:57.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:57.937]                   3L)]
[08:24:57.937]             }
[08:24:57.937]             function(cond) {
[08:24:57.937]                 is_error <- inherits(cond, "error")
[08:24:57.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:57.937]                   NULL)
[08:24:57.937]                 if (is_error) {
[08:24:57.937]                   sessionInformation <- function() {
[08:24:57.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:57.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:57.937]                       search = base::search(), system = base::Sys.info())
[08:24:57.937]                   }
[08:24:57.937]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:57.937]                     cond$call), session = sessionInformation(), 
[08:24:57.937]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:57.937]                   signalCondition(cond)
[08:24:57.937]                 }
[08:24:57.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:57.937]                 "immediateCondition"))) {
[08:24:57.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:57.937]                   ...future.conditions[[length(...future.conditions) + 
[08:24:57.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:57.937]                   if (TRUE && !signal) {
[08:24:57.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.937]                     {
[08:24:57.937]                       inherits <- base::inherits
[08:24:57.937]                       invokeRestart <- base::invokeRestart
[08:24:57.937]                       is.null <- base::is.null
[08:24:57.937]                       muffled <- FALSE
[08:24:57.937]                       if (inherits(cond, "message")) {
[08:24:57.937]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.937]                         if (muffled) 
[08:24:57.937]                           invokeRestart("muffleMessage")
[08:24:57.937]                       }
[08:24:57.937]                       else if (inherits(cond, "warning")) {
[08:24:57.937]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.937]                         if (muffled) 
[08:24:57.937]                           invokeRestart("muffleWarning")
[08:24:57.937]                       }
[08:24:57.937]                       else if (inherits(cond, "condition")) {
[08:24:57.937]                         if (!is.null(pattern)) {
[08:24:57.937]                           computeRestarts <- base::computeRestarts
[08:24:57.937]                           grepl <- base::grepl
[08:24:57.937]                           restarts <- computeRestarts(cond)
[08:24:57.937]                           for (restart in restarts) {
[08:24:57.937]                             name <- restart$name
[08:24:57.937]                             if (is.null(name)) 
[08:24:57.937]                               next
[08:24:57.937]                             if (!grepl(pattern, name)) 
[08:24:57.937]                               next
[08:24:57.937]                             invokeRestart(restart)
[08:24:57.937]                             muffled <- TRUE
[08:24:57.937]                             break
[08:24:57.937]                           }
[08:24:57.937]                         }
[08:24:57.937]                       }
[08:24:57.937]                       invisible(muffled)
[08:24:57.937]                     }
[08:24:57.937]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.937]                   }
[08:24:57.937]                 }
[08:24:57.937]                 else {
[08:24:57.937]                   if (TRUE) {
[08:24:57.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:57.937]                     {
[08:24:57.937]                       inherits <- base::inherits
[08:24:57.937]                       invokeRestart <- base::invokeRestart
[08:24:57.937]                       is.null <- base::is.null
[08:24:57.937]                       muffled <- FALSE
[08:24:57.937]                       if (inherits(cond, "message")) {
[08:24:57.937]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:57.937]                         if (muffled) 
[08:24:57.937]                           invokeRestart("muffleMessage")
[08:24:57.937]                       }
[08:24:57.937]                       else if (inherits(cond, "warning")) {
[08:24:57.937]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:57.937]                         if (muffled) 
[08:24:57.937]                           invokeRestart("muffleWarning")
[08:24:57.937]                       }
[08:24:57.937]                       else if (inherits(cond, "condition")) {
[08:24:57.937]                         if (!is.null(pattern)) {
[08:24:57.937]                           computeRestarts <- base::computeRestarts
[08:24:57.937]                           grepl <- base::grepl
[08:24:57.937]                           restarts <- computeRestarts(cond)
[08:24:57.937]                           for (restart in restarts) {
[08:24:57.937]                             name <- restart$name
[08:24:57.937]                             if (is.null(name)) 
[08:24:57.937]                               next
[08:24:57.937]                             if (!grepl(pattern, name)) 
[08:24:57.937]                               next
[08:24:57.937]                             invokeRestart(restart)
[08:24:57.937]                             muffled <- TRUE
[08:24:57.937]                             break
[08:24:57.937]                           }
[08:24:57.937]                         }
[08:24:57.937]                       }
[08:24:57.937]                       invisible(muffled)
[08:24:57.937]                     }
[08:24:57.937]                     muffleCondition(cond, pattern = "^muffle")
[08:24:57.937]                   }
[08:24:57.937]                 }
[08:24:57.937]             }
[08:24:57.937]         }))
[08:24:57.937]     }, error = function(ex) {
[08:24:57.937]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:57.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:57.937]                 ...future.rng), started = ...future.startTime, 
[08:24:57.937]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:57.937]             version = "1.8"), class = "FutureResult")
[08:24:57.937]     }, finally = {
[08:24:57.937]         if (!identical(...future.workdir, getwd())) 
[08:24:57.937]             setwd(...future.workdir)
[08:24:57.937]         {
[08:24:57.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:57.937]                 ...future.oldOptions$nwarnings <- NULL
[08:24:57.937]             }
[08:24:57.937]             base::options(...future.oldOptions)
[08:24:57.937]             if (.Platform$OS.type == "windows") {
[08:24:57.937]                 old_names <- names(...future.oldEnvVars)
[08:24:57.937]                 envs <- base::Sys.getenv()
[08:24:57.937]                 names <- names(envs)
[08:24:57.937]                 common <- intersect(names, old_names)
[08:24:57.937]                 added <- setdiff(names, old_names)
[08:24:57.937]                 removed <- setdiff(old_names, names)
[08:24:57.937]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:57.937]                   envs[common]]
[08:24:57.937]                 NAMES <- toupper(changed)
[08:24:57.937]                 args <- list()
[08:24:57.937]                 for (kk in seq_along(NAMES)) {
[08:24:57.937]                   name <- changed[[kk]]
[08:24:57.937]                   NAME <- NAMES[[kk]]
[08:24:57.937]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.937]                     next
[08:24:57.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.937]                 }
[08:24:57.937]                 NAMES <- toupper(added)
[08:24:57.937]                 for (kk in seq_along(NAMES)) {
[08:24:57.937]                   name <- added[[kk]]
[08:24:57.937]                   NAME <- NAMES[[kk]]
[08:24:57.937]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.937]                     next
[08:24:57.937]                   args[[name]] <- ""
[08:24:57.937]                 }
[08:24:57.937]                 NAMES <- toupper(removed)
[08:24:57.937]                 for (kk in seq_along(NAMES)) {
[08:24:57.937]                   name <- removed[[kk]]
[08:24:57.937]                   NAME <- NAMES[[kk]]
[08:24:57.937]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:57.937]                     next
[08:24:57.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:57.937]                 }
[08:24:57.937]                 if (length(args) > 0) 
[08:24:57.937]                   base::do.call(base::Sys.setenv, args = args)
[08:24:57.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:57.937]             }
[08:24:57.937]             else {
[08:24:57.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:57.937]             }
[08:24:57.937]             {
[08:24:57.937]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:57.937]                   0L) {
[08:24:57.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:57.937]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:57.937]                   base::options(opts)
[08:24:57.937]                 }
[08:24:57.937]                 {
[08:24:57.937]                   {
[08:24:57.937]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:57.937]                     NULL
[08:24:57.937]                   }
[08:24:57.937]                   options(future.plan = NULL)
[08:24:57.937]                   if (is.na(NA_character_)) 
[08:24:57.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:57.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:57.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:57.937]                     .init = FALSE)
[08:24:57.937]                 }
[08:24:57.937]             }
[08:24:57.937]         }
[08:24:57.937]     })
[08:24:57.937]     if (TRUE) {
[08:24:57.937]         base::sink(type = "output", split = FALSE)
[08:24:57.937]         if (TRUE) {
[08:24:57.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:57.937]         }
[08:24:57.937]         else {
[08:24:57.937]             ...future.result["stdout"] <- base::list(NULL)
[08:24:57.937]         }
[08:24:57.937]         base::close(...future.stdout)
[08:24:57.937]         ...future.stdout <- NULL
[08:24:57.937]     }
[08:24:57.937]     ...future.result$conditions <- ...future.conditions
[08:24:57.937]     ...future.result$finished <- base::Sys.time()
[08:24:57.937]     ...future.result
[08:24:57.937] }
[08:24:57.941] assign_globals() ...
[08:24:57.941] List of 7
[08:24:57.941]  $ ...future.FUN            :function (x)  
[08:24:57.941]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:57.941]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:57.941]  $ future.call.arguments    : list()
[08:24:57.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:57.941]  $ ...future.elements_ii    :List of 2
[08:24:57.941]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.941]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:57.941]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.941]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:57.941]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:57.941]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:57.941]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:57.941]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:57.941]  $ ...future.seeds_ii       : NULL
[08:24:57.941]  $ ...future.globals.maxSize: NULL
[08:24:57.941]  - attr(*, "where")=List of 7
[08:24:57.941]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:57.941]   ..$ breaks                   :<environment: R_EmptyEnv> 
[08:24:57.941]   ..$ wool                     :<environment: R_EmptyEnv> 
[08:24:57.941]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:57.941]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:57.941]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:57.941]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:57.941]  - attr(*, "resolved")= logi FALSE
[08:24:57.941]  - attr(*, "total_size")= num 18867
[08:24:57.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:57.941]  - attr(*, "already-done")= logi TRUE
[08:24:57.956] - reassign environment for ‘...future.FUN’
[08:24:57.956] - copied ‘...future.FUN’ to environment
[08:24:57.956] - copied ‘breaks’ to environment
[08:24:57.956] - copied ‘wool’ to environment
[08:24:57.956] - copied ‘future.call.arguments’ to environment
[08:24:57.956] - copied ‘...future.elements_ii’ to environment
[08:24:57.957] - copied ‘...future.seeds_ii’ to environment
[08:24:57.957] - copied ‘...future.globals.maxSize’ to environment
[08:24:57.957] assign_globals() ... done
[08:24:57.957] requestCore(): workers = 2
[08:24:57.959] MulticoreFuture started
[08:24:57.960] - Launch lazy future ... done
[08:24:57.960] run() for ‘MulticoreFuture’ ... done
[08:24:57.961] Created future:
[08:24:57.961] plan(): Setting new future strategy stack:
[08:24:57.961] List of future strategies:
[08:24:57.961] 1. sequential:
[08:24:57.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:57.961]    - tweaked: FALSE
[08:24:57.961]    - call: NULL
[08:24:57.963] plan(): nbrOfWorkers() = 1
[08:24:57.969] plan(): Setting new future strategy stack:
[08:24:57.969] List of future strategies:
[08:24:57.969] 1. multicore:
[08:24:57.969]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:57.969]    - tweaked: FALSE
[08:24:57.969]    - call: plan(strategy)
[08:24:57.972] plan(): nbrOfWorkers() = 2
[08:24:57.961] MulticoreFuture:
[08:24:57.961] Label: ‘future_by-2’
[08:24:57.961] Expression:
[08:24:57.961] {
[08:24:57.961]     do.call(function(...) {
[08:24:57.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:57.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:57.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:57.961]             on.exit(options(oopts), add = TRUE)
[08:24:57.961]         }
[08:24:57.961]         {
[08:24:57.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:57.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:57.961]                 ...future.FUN(...future.X_jj, ...)
[08:24:57.961]             })
[08:24:57.961]         }
[08:24:57.961]     }, args = future.call.arguments)
[08:24:57.961] }
[08:24:57.961] Lazy evaluation: FALSE
[08:24:57.961] Asynchronous evaluation: TRUE
[08:24:57.961] Local evaluation: TRUE
[08:24:57.961] Environment: 0x557b27226580
[08:24:57.961] Capture standard output: TRUE
[08:24:57.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:57.961] Globals: 7 objects totaling 3.57 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, ...)
[08:24:57.961] Packages: 1 packages (‘stats’)
[08:24:57.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:57.961] Resolved: FALSE
[08:24:57.961] Value: <not collected>
[08:24:57.961] Conditions captured: <none>
[08:24:57.961] Early signaling: FALSE
[08:24:57.961] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:57.961] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:57.974] Chunk #2 of 2 ... DONE
[08:24:57.975] Launching 2 futures (chunks) ... DONE
[08:24:57.975] Resolving 2 futures (chunks) ...
[08:24:57.975] resolve() on list ...
[08:24:57.975]  recursive: 0
[08:24:57.975]  length: 2
[08:24:57.975] 
[08:24:57.976] Future #1
[08:24:57.976] result() for MulticoreFuture ...
[08:24:57.978] result() for MulticoreFuture ...
[08:24:57.978] result() for MulticoreFuture ... done
[08:24:57.978] result() for MulticoreFuture ... done
[08:24:57.978] result() for MulticoreFuture ...
[08:24:57.978] result() for MulticoreFuture ... done
[08:24:57.978] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:57.979] - nx: 2
[08:24:57.979] - relay: TRUE
[08:24:57.979] - stdout: TRUE
[08:24:57.979] - signal: TRUE
[08:24:57.979] - resignal: FALSE
[08:24:57.979] - force: TRUE
[08:24:57.979] - relayed: [n=2] FALSE, FALSE
[08:24:57.979] - queued futures: [n=2] FALSE, FALSE
[08:24:57.980]  - until=1
[08:24:57.980]  - relaying element #1
[08:24:57.980] result() for MulticoreFuture ...
[08:24:57.980] result() for MulticoreFuture ... done
[08:24:57.980] result() for MulticoreFuture ...
[08:24:57.980] result() for MulticoreFuture ... done
[08:24:57.980] result() for MulticoreFuture ...
[08:24:57.981] result() for MulticoreFuture ... done
[08:24:57.981] result() for MulticoreFuture ...
[08:24:57.981] result() for MulticoreFuture ... done
[08:24:57.981] - relayed: [n=2] TRUE, FALSE
[08:24:57.981] - queued futures: [n=2] TRUE, FALSE
[08:24:57.981] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:57.982]  length: 1 (resolved future 1)
[08:24:57.982] Future #2
[08:24:57.982] result() for MulticoreFuture ...
[08:24:57.984] result() for MulticoreFuture ...
[08:24:57.984] result() for MulticoreFuture ... done
[08:24:57.984] result() for MulticoreFuture ... done
[08:24:57.984] result() for MulticoreFuture ...
[08:24:57.984] result() for MulticoreFuture ... done
[08:24:57.985] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:57.985] - nx: 2
[08:24:57.985] - relay: TRUE
[08:24:57.985] - stdout: TRUE
[08:24:57.985] - signal: TRUE
[08:24:57.985] - resignal: FALSE
[08:24:57.985] - force: TRUE
[08:24:57.985] - relayed: [n=2] TRUE, FALSE
[08:24:57.986] - queued futures: [n=2] TRUE, FALSE
[08:24:57.986]  - until=2
[08:24:57.986]  - relaying element #2
[08:24:57.986] result() for MulticoreFuture ...
[08:24:57.986] result() for MulticoreFuture ... done
[08:24:57.986] result() for MulticoreFuture ...
[08:24:57.986] result() for MulticoreFuture ... done
[08:24:57.987] result() for MulticoreFuture ...
[08:24:57.987] result() for MulticoreFuture ... done
[08:24:57.987] result() for MulticoreFuture ...
[08:24:57.987] result() for MulticoreFuture ... done
[08:24:57.987] - relayed: [n=2] TRUE, TRUE
[08:24:57.987] - queued futures: [n=2] TRUE, TRUE
[08:24:57.987] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:57.987]  length: 0 (resolved future 2)
[08:24:57.987] Relaying remaining futures
[08:24:57.988] signalConditionsASAP(NULL, pos=0) ...
[08:24:57.988] - nx: 2
[08:24:57.988] - relay: TRUE
[08:24:57.988] - stdout: TRUE
[08:24:57.988] - signal: TRUE
[08:24:57.988] - resignal: FALSE
[08:24:57.988] - force: TRUE
[08:24:57.988] - relayed: [n=2] TRUE, TRUE
[08:24:57.988] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:57.989] - relayed: [n=2] TRUE, TRUE
[08:24:57.989] - queued futures: [n=2] TRUE, TRUE
[08:24:57.989] signalConditionsASAP(NULL, pos=0) ... done
[08:24:57.989] resolve() on list ... DONE
[08:24:57.989] result() for MulticoreFuture ...
[08:24:57.989] result() for MulticoreFuture ... done
[08:24:57.989] result() for MulticoreFuture ...
[08:24:57.989] result() for MulticoreFuture ... done
[08:24:57.990] result() for MulticoreFuture ...
[08:24:57.990] result() for MulticoreFuture ... done
[08:24:57.990] result() for MulticoreFuture ...
[08:24:57.990] result() for MulticoreFuture ... done
[08:24:57.990]  - Number of value chunks collected: 2
[08:24:57.990] Resolving 2 futures (chunks) ... DONE
[08:24:57.993] Reducing values from 2 chunks ...
[08:24:57.994]  - Number of values collected after concatenation: 3
[08:24:57.994]  - Number of values expected: 3
[08:24:57.994] Reducing values from 2 chunks ... DONE
[08:24:57.994] future_lapply() ... DONE
[08:24:57.994] future_by_internal() ... DONE
[08:24:57.995] future_by_internal() ...
[08:24:57.996] future_lapply() ...
[08:24:57.999] Number of chunks: 2
[08:24:57.999] getGlobalsAndPackagesXApply() ...
[08:24:57.999]  - future.globals: TRUE
[08:24:57.999] getGlobalsAndPackages() ...
[08:24:57.999] Searching for globals...
[08:24:58.001] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:58.001] Searching for globals ... DONE
[08:24:58.001] Resolving globals: FALSE
[08:24:58.002] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:58.002] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:58.003] - globals: [1] ‘FUN’
[08:24:58.003] 
[08:24:58.003] getGlobalsAndPackages() ... DONE
[08:24:58.003]  - globals found/used: [n=1] ‘FUN’
[08:24:58.003]  - needed namespaces: [n=0] 
[08:24:58.003] Finding globals ... DONE
[08:24:58.004]  - use_args: TRUE
[08:24:58.004]  - Getting '...' globals ...
[08:24:58.004] resolve() on list ...
[08:24:58.004]  recursive: 0
[08:24:58.004]  length: 1
[08:24:58.004]  elements: ‘...’
[08:24:58.005]  length: 0 (resolved future 1)
[08:24:58.005] resolve() on list ... DONE
[08:24:58.005]    - '...' content: [n=0] 
[08:24:58.005] List of 1
[08:24:58.005]  $ ...: list()
[08:24:58.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.005]  - attr(*, "where")=List of 1
[08:24:58.005]   ..$ ...:<environment: 0x557b27d61c18> 
[08:24:58.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.005]  - attr(*, "resolved")= logi TRUE
[08:24:58.005]  - attr(*, "total_size")= num NA
[08:24:58.008]  - Getting '...' globals ... DONE
[08:24:58.008] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:58.008] List of 2
[08:24:58.008]  $ ...future.FUN:function (object, ...)  
[08:24:58.008]  $ ...          : list()
[08:24:58.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.008]  - attr(*, "where")=List of 2
[08:24:58.008]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:58.008]   ..$ ...          :<environment: 0x557b27d61c18> 
[08:24:58.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.008]  - attr(*, "resolved")= logi FALSE
[08:24:58.008]  - attr(*, "total_size")= num 19278
[08:24:58.011] Packages to be attached in all futures: [n=0] 
[08:24:58.011] getGlobalsAndPackagesXApply() ... DONE
[08:24:58.011] Number of futures (= number of chunks): 2
[08:24:58.011] Launching 2 futures (chunks) ...
[08:24:58.012] Chunk #1 of 2 ...
[08:24:58.012]  - Finding globals in 'X' for chunk #1 ...
[08:24:58.012] getGlobalsAndPackages() ...
[08:24:58.012] Searching for globals...
[08:24:58.013] 
[08:24:58.013] Searching for globals ... DONE
[08:24:58.013] - globals: [0] <none>
[08:24:58.013] getGlobalsAndPackages() ... DONE
[08:24:58.013]    + additional globals found: [n=0] 
[08:24:58.013]    + additional namespaces needed: [n=0] 
[08:24:58.014]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:58.014]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:58.014]  - seeds: <none>
[08:24:58.014]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.014] getGlobalsAndPackages() ...
[08:24:58.014] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.014] Resolving globals: FALSE
[08:24:58.015] Tweak future expression to call with '...' arguments ...
[08:24:58.015] {
[08:24:58.015]     do.call(function(...) {
[08:24:58.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.015]             on.exit(options(oopts), add = TRUE)
[08:24:58.015]         }
[08:24:58.015]         {
[08:24:58.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.015]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.015]             })
[08:24:58.015]         }
[08:24:58.015]     }, args = future.call.arguments)
[08:24:58.015] }
[08:24:58.015] Tweak future expression to call with '...' arguments ... DONE
[08:24:58.015] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.015] 
[08:24:58.016] getGlobalsAndPackages() ... DONE
[08:24:58.016] run() for ‘Future’ ...
[08:24:58.016] - state: ‘created’
[08:24:58.016] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:58.068] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:58.068]   - Field: ‘label’
[08:24:58.068]   - Field: ‘local’
[08:24:58.068]   - Field: ‘owner’
[08:24:58.068]   - Field: ‘envir’
[08:24:58.068]   - Field: ‘workers’
[08:24:58.068]   - Field: ‘packages’
[08:24:58.068]   - Field: ‘gc’
[08:24:58.069]   - Field: ‘job’
[08:24:58.069]   - Field: ‘conditions’
[08:24:58.069]   - Field: ‘expr’
[08:24:58.069]   - Field: ‘uuid’
[08:24:58.069]   - Field: ‘seed’
[08:24:58.069]   - Field: ‘version’
[08:24:58.069]   - Field: ‘result’
[08:24:58.069]   - Field: ‘asynchronous’
[08:24:58.069]   - Field: ‘calls’
[08:24:58.069]   - Field: ‘globals’
[08:24:58.069]   - Field: ‘stdout’
[08:24:58.070]   - Field: ‘earlySignal’
[08:24:58.070]   - Field: ‘lazy’
[08:24:58.070]   - Field: ‘state’
[08:24:58.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:58.070] - Launch lazy future ...
[08:24:58.070] Packages needed by the future expression (n = 0): <none>
[08:24:58.070] Packages needed by future strategies (n = 0): <none>
[08:24:58.071] {
[08:24:58.071]     {
[08:24:58.071]         {
[08:24:58.071]             ...future.startTime <- base::Sys.time()
[08:24:58.071]             {
[08:24:58.071]                 {
[08:24:58.071]                   {
[08:24:58.071]                     {
[08:24:58.071]                       base::local({
[08:24:58.071]                         has_future <- base::requireNamespace("future", 
[08:24:58.071]                           quietly = TRUE)
[08:24:58.071]                         if (has_future) {
[08:24:58.071]                           ns <- base::getNamespace("future")
[08:24:58.071]                           version <- ns[[".package"]][["version"]]
[08:24:58.071]                           if (is.null(version)) 
[08:24:58.071]                             version <- utils::packageVersion("future")
[08:24:58.071]                         }
[08:24:58.071]                         else {
[08:24:58.071]                           version <- NULL
[08:24:58.071]                         }
[08:24:58.071]                         if (!has_future || version < "1.8.0") {
[08:24:58.071]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:58.071]                             "", base::R.version$version.string), 
[08:24:58.071]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:58.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:58.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:58.071]                               "release", "version")], collapse = " "), 
[08:24:58.071]                             hostname = base::Sys.info()[["nodename"]])
[08:24:58.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:58.071]                             info)
[08:24:58.071]                           info <- base::paste(info, collapse = "; ")
[08:24:58.071]                           if (!has_future) {
[08:24:58.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:58.071]                               info)
[08:24:58.071]                           }
[08:24:58.071]                           else {
[08:24:58.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:58.071]                               info, version)
[08:24:58.071]                           }
[08:24:58.071]                           base::stop(msg)
[08:24:58.071]                         }
[08:24:58.071]                       })
[08:24:58.071]                     }
[08:24:58.071]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:58.071]                     base::options(mc.cores = 1L)
[08:24:58.071]                   }
[08:24:58.071]                   ...future.strategy.old <- future::plan("list")
[08:24:58.071]                   options(future.plan = NULL)
[08:24:58.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:58.071]                 }
[08:24:58.071]                 ...future.workdir <- getwd()
[08:24:58.071]             }
[08:24:58.071]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:58.071]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:58.071]         }
[08:24:58.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:58.071]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:58.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:58.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:58.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:58.071]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:58.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:58.071]             base::names(...future.oldOptions))
[08:24:58.071]     }
[08:24:58.071]     if (FALSE) {
[08:24:58.071]     }
[08:24:58.071]     else {
[08:24:58.071]         if (TRUE) {
[08:24:58.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:58.071]                 open = "w")
[08:24:58.071]         }
[08:24:58.071]         else {
[08:24:58.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:58.071]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:58.071]         }
[08:24:58.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:58.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:58.071]             base::sink(type = "output", split = FALSE)
[08:24:58.071]             base::close(...future.stdout)
[08:24:58.071]         }, add = TRUE)
[08:24:58.071]     }
[08:24:58.071]     ...future.frame <- base::sys.nframe()
[08:24:58.071]     ...future.conditions <- base::list()
[08:24:58.071]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:58.071]     if (FALSE) {
[08:24:58.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:58.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:58.071]     }
[08:24:58.071]     ...future.result <- base::tryCatch({
[08:24:58.071]         base::withCallingHandlers({
[08:24:58.071]             ...future.value <- base::withVisible(base::local({
[08:24:58.071]                 withCallingHandlers({
[08:24:58.071]                   {
[08:24:58.071]                     do.call(function(...) {
[08:24:58.071]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.071]                       if (!identical(...future.globals.maxSize.org, 
[08:24:58.071]                         ...future.globals.maxSize)) {
[08:24:58.071]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.071]                         on.exit(options(oopts), add = TRUE)
[08:24:58.071]                       }
[08:24:58.071]                       {
[08:24:58.071]                         lapply(seq_along(...future.elements_ii), 
[08:24:58.071]                           FUN = function(jj) {
[08:24:58.071]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.071]                             ...future.FUN(...future.X_jj, ...)
[08:24:58.071]                           })
[08:24:58.071]                       }
[08:24:58.071]                     }, args = future.call.arguments)
[08:24:58.071]                   }
[08:24:58.071]                 }, immediateCondition = function(cond) {
[08:24:58.071]                   save_rds <- function (object, pathname, ...) 
[08:24:58.071]                   {
[08:24:58.071]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:58.071]                     if (file_test("-f", pathname_tmp)) {
[08:24:58.071]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.071]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:58.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.071]                         fi_tmp[["mtime"]])
[08:24:58.071]                     }
[08:24:58.071]                     tryCatch({
[08:24:58.071]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:58.071]                     }, error = function(ex) {
[08:24:58.071]                       msg <- conditionMessage(ex)
[08:24:58.071]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.071]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:58.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.071]                         fi_tmp[["mtime"]], msg)
[08:24:58.071]                       ex$message <- msg
[08:24:58.071]                       stop(ex)
[08:24:58.071]                     })
[08:24:58.071]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:58.071]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:58.071]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:58.071]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.071]                       fi <- file.info(pathname)
[08:24:58.071]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:58.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.071]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:58.071]                         fi[["size"]], fi[["mtime"]])
[08:24:58.071]                       stop(msg)
[08:24:58.071]                     }
[08:24:58.071]                     invisible(pathname)
[08:24:58.071]                   }
[08:24:58.071]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:58.071]                     rootPath = tempdir()) 
[08:24:58.071]                   {
[08:24:58.071]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:58.071]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:58.071]                       tmpdir = path, fileext = ".rds")
[08:24:58.071]                     save_rds(obj, file)
[08:24:58.071]                   }
[08:24:58.071]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:58.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.071]                   {
[08:24:58.071]                     inherits <- base::inherits
[08:24:58.071]                     invokeRestart <- base::invokeRestart
[08:24:58.071]                     is.null <- base::is.null
[08:24:58.071]                     muffled <- FALSE
[08:24:58.071]                     if (inherits(cond, "message")) {
[08:24:58.071]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:58.071]                       if (muffled) 
[08:24:58.071]                         invokeRestart("muffleMessage")
[08:24:58.071]                     }
[08:24:58.071]                     else if (inherits(cond, "warning")) {
[08:24:58.071]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:58.071]                       if (muffled) 
[08:24:58.071]                         invokeRestart("muffleWarning")
[08:24:58.071]                     }
[08:24:58.071]                     else if (inherits(cond, "condition")) {
[08:24:58.071]                       if (!is.null(pattern)) {
[08:24:58.071]                         computeRestarts <- base::computeRestarts
[08:24:58.071]                         grepl <- base::grepl
[08:24:58.071]                         restarts <- computeRestarts(cond)
[08:24:58.071]                         for (restart in restarts) {
[08:24:58.071]                           name <- restart$name
[08:24:58.071]                           if (is.null(name)) 
[08:24:58.071]                             next
[08:24:58.071]                           if (!grepl(pattern, name)) 
[08:24:58.071]                             next
[08:24:58.071]                           invokeRestart(restart)
[08:24:58.071]                           muffled <- TRUE
[08:24:58.071]                           break
[08:24:58.071]                         }
[08:24:58.071]                       }
[08:24:58.071]                     }
[08:24:58.071]                     invisible(muffled)
[08:24:58.071]                   }
[08:24:58.071]                   muffleCondition(cond)
[08:24:58.071]                 })
[08:24:58.071]             }))
[08:24:58.071]             future::FutureResult(value = ...future.value$value, 
[08:24:58.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.071]                   ...future.rng), globalenv = if (FALSE) 
[08:24:58.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:58.071]                     ...future.globalenv.names))
[08:24:58.071]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:58.071]         }, condition = base::local({
[08:24:58.071]             c <- base::c
[08:24:58.071]             inherits <- base::inherits
[08:24:58.071]             invokeRestart <- base::invokeRestart
[08:24:58.071]             length <- base::length
[08:24:58.071]             list <- base::list
[08:24:58.071]             seq.int <- base::seq.int
[08:24:58.071]             signalCondition <- base::signalCondition
[08:24:58.071]             sys.calls <- base::sys.calls
[08:24:58.071]             `[[` <- base::`[[`
[08:24:58.071]             `+` <- base::`+`
[08:24:58.071]             `<<-` <- base::`<<-`
[08:24:58.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:58.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:58.071]                   3L)]
[08:24:58.071]             }
[08:24:58.071]             function(cond) {
[08:24:58.071]                 is_error <- inherits(cond, "error")
[08:24:58.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:58.071]                   NULL)
[08:24:58.071]                 if (is_error) {
[08:24:58.071]                   sessionInformation <- function() {
[08:24:58.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:58.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:58.071]                       search = base::search(), system = base::Sys.info())
[08:24:58.071]                   }
[08:24:58.071]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:58.071]                     cond$call), session = sessionInformation(), 
[08:24:58.071]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:58.071]                   signalCondition(cond)
[08:24:58.071]                 }
[08:24:58.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:58.071]                 "immediateCondition"))) {
[08:24:58.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:58.071]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:58.071]                   if (TRUE && !signal) {
[08:24:58.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.071]                     {
[08:24:58.071]                       inherits <- base::inherits
[08:24:58.071]                       invokeRestart <- base::invokeRestart
[08:24:58.071]                       is.null <- base::is.null
[08:24:58.071]                       muffled <- FALSE
[08:24:58.071]                       if (inherits(cond, "message")) {
[08:24:58.071]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.071]                         if (muffled) 
[08:24:58.071]                           invokeRestart("muffleMessage")
[08:24:58.071]                       }
[08:24:58.071]                       else if (inherits(cond, "warning")) {
[08:24:58.071]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.071]                         if (muffled) 
[08:24:58.071]                           invokeRestart("muffleWarning")
[08:24:58.071]                       }
[08:24:58.071]                       else if (inherits(cond, "condition")) {
[08:24:58.071]                         if (!is.null(pattern)) {
[08:24:58.071]                           computeRestarts <- base::computeRestarts
[08:24:58.071]                           grepl <- base::grepl
[08:24:58.071]                           restarts <- computeRestarts(cond)
[08:24:58.071]                           for (restart in restarts) {
[08:24:58.071]                             name <- restart$name
[08:24:58.071]                             if (is.null(name)) 
[08:24:58.071]                               next
[08:24:58.071]                             if (!grepl(pattern, name)) 
[08:24:58.071]                               next
[08:24:58.071]                             invokeRestart(restart)
[08:24:58.071]                             muffled <- TRUE
[08:24:58.071]                             break
[08:24:58.071]                           }
[08:24:58.071]                         }
[08:24:58.071]                       }
[08:24:58.071]                       invisible(muffled)
[08:24:58.071]                     }
[08:24:58.071]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.071]                   }
[08:24:58.071]                 }
[08:24:58.071]                 else {
[08:24:58.071]                   if (TRUE) {
[08:24:58.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.071]                     {
[08:24:58.071]                       inherits <- base::inherits
[08:24:58.071]                       invokeRestart <- base::invokeRestart
[08:24:58.071]                       is.null <- base::is.null
[08:24:58.071]                       muffled <- FALSE
[08:24:58.071]                       if (inherits(cond, "message")) {
[08:24:58.071]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.071]                         if (muffled) 
[08:24:58.071]                           invokeRestart("muffleMessage")
[08:24:58.071]                       }
[08:24:58.071]                       else if (inherits(cond, "warning")) {
[08:24:58.071]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.071]                         if (muffled) 
[08:24:58.071]                           invokeRestart("muffleWarning")
[08:24:58.071]                       }
[08:24:58.071]                       else if (inherits(cond, "condition")) {
[08:24:58.071]                         if (!is.null(pattern)) {
[08:24:58.071]                           computeRestarts <- base::computeRestarts
[08:24:58.071]                           grepl <- base::grepl
[08:24:58.071]                           restarts <- computeRestarts(cond)
[08:24:58.071]                           for (restart in restarts) {
[08:24:58.071]                             name <- restart$name
[08:24:58.071]                             if (is.null(name)) 
[08:24:58.071]                               next
[08:24:58.071]                             if (!grepl(pattern, name)) 
[08:24:58.071]                               next
[08:24:58.071]                             invokeRestart(restart)
[08:24:58.071]                             muffled <- TRUE
[08:24:58.071]                             break
[08:24:58.071]                           }
[08:24:58.071]                         }
[08:24:58.071]                       }
[08:24:58.071]                       invisible(muffled)
[08:24:58.071]                     }
[08:24:58.071]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.071]                   }
[08:24:58.071]                 }
[08:24:58.071]             }
[08:24:58.071]         }))
[08:24:58.071]     }, error = function(ex) {
[08:24:58.071]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:58.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.071]                 ...future.rng), started = ...future.startTime, 
[08:24:58.071]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:58.071]             version = "1.8"), class = "FutureResult")
[08:24:58.071]     }, finally = {
[08:24:58.071]         if (!identical(...future.workdir, getwd())) 
[08:24:58.071]             setwd(...future.workdir)
[08:24:58.071]         {
[08:24:58.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:58.071]                 ...future.oldOptions$nwarnings <- NULL
[08:24:58.071]             }
[08:24:58.071]             base::options(...future.oldOptions)
[08:24:58.071]             if (.Platform$OS.type == "windows") {
[08:24:58.071]                 old_names <- names(...future.oldEnvVars)
[08:24:58.071]                 envs <- base::Sys.getenv()
[08:24:58.071]                 names <- names(envs)
[08:24:58.071]                 common <- intersect(names, old_names)
[08:24:58.071]                 added <- setdiff(names, old_names)
[08:24:58.071]                 removed <- setdiff(old_names, names)
[08:24:58.071]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:58.071]                   envs[common]]
[08:24:58.071]                 NAMES <- toupper(changed)
[08:24:58.071]                 args <- list()
[08:24:58.071]                 for (kk in seq_along(NAMES)) {
[08:24:58.071]                   name <- changed[[kk]]
[08:24:58.071]                   NAME <- NAMES[[kk]]
[08:24:58.071]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.071]                     next
[08:24:58.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.071]                 }
[08:24:58.071]                 NAMES <- toupper(added)
[08:24:58.071]                 for (kk in seq_along(NAMES)) {
[08:24:58.071]                   name <- added[[kk]]
[08:24:58.071]                   NAME <- NAMES[[kk]]
[08:24:58.071]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.071]                     next
[08:24:58.071]                   args[[name]] <- ""
[08:24:58.071]                 }
[08:24:58.071]                 NAMES <- toupper(removed)
[08:24:58.071]                 for (kk in seq_along(NAMES)) {
[08:24:58.071]                   name <- removed[[kk]]
[08:24:58.071]                   NAME <- NAMES[[kk]]
[08:24:58.071]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.071]                     next
[08:24:58.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.071]                 }
[08:24:58.071]                 if (length(args) > 0) 
[08:24:58.071]                   base::do.call(base::Sys.setenv, args = args)
[08:24:58.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:58.071]             }
[08:24:58.071]             else {
[08:24:58.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:58.071]             }
[08:24:58.071]             {
[08:24:58.071]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:58.071]                   0L) {
[08:24:58.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:58.071]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:58.071]                   base::options(opts)
[08:24:58.071]                 }
[08:24:58.071]                 {
[08:24:58.071]                   {
[08:24:58.071]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:58.071]                     NULL
[08:24:58.071]                   }
[08:24:58.071]                   options(future.plan = NULL)
[08:24:58.071]                   if (is.na(NA_character_)) 
[08:24:58.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:58.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:58.071]                     .init = FALSE)
[08:24:58.071]                 }
[08:24:58.071]             }
[08:24:58.071]         }
[08:24:58.071]     })
[08:24:58.071]     if (TRUE) {
[08:24:58.071]         base::sink(type = "output", split = FALSE)
[08:24:58.071]         if (TRUE) {
[08:24:58.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:58.071]         }
[08:24:58.071]         else {
[08:24:58.071]             ...future.result["stdout"] <- base::list(NULL)
[08:24:58.071]         }
[08:24:58.071]         base::close(...future.stdout)
[08:24:58.071]         ...future.stdout <- NULL
[08:24:58.071]     }
[08:24:58.071]     ...future.result$conditions <- ...future.conditions
[08:24:58.071]     ...future.result$finished <- base::Sys.time()
[08:24:58.071]     ...future.result
[08:24:58.071] }
[08:24:58.073] assign_globals() ...
[08:24:58.073] List of 5
[08:24:58.073]  $ ...future.FUN            :function (object, ...)  
[08:24:58.073]  $ future.call.arguments    : list()
[08:24:58.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.073]  $ ...future.elements_ii    :List of 1
[08:24:58.073]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:58.073]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:58.073]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:58.073]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:58.073]  $ ...future.seeds_ii       : NULL
[08:24:58.073]  $ ...future.globals.maxSize: NULL
[08:24:58.073]  - attr(*, "where")=List of 5
[08:24:58.073]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:58.073]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:58.073]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:58.073]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:58.073]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:58.073]  - attr(*, "resolved")= logi FALSE
[08:24:58.073]  - attr(*, "total_size")= num 19278
[08:24:58.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.073]  - attr(*, "already-done")= logi TRUE
[08:24:58.079] - copied ‘...future.FUN’ to environment
[08:24:58.079] - copied ‘future.call.arguments’ to environment
[08:24:58.079] - copied ‘...future.elements_ii’ to environment
[08:24:58.079] - copied ‘...future.seeds_ii’ to environment
[08:24:58.079] - copied ‘...future.globals.maxSize’ to environment
[08:24:58.079] assign_globals() ... done
[08:24:58.080] requestCore(): workers = 2
[08:24:58.082] MulticoreFuture started
[08:24:58.082] - Launch lazy future ... done
[08:24:58.082] run() for ‘MulticoreFuture’ ... done
[08:24:58.083] Created future:
[08:24:58.083] plan(): Setting new future strategy stack:
[08:24:58.083] List of future strategies:
[08:24:58.083] 1. sequential:
[08:24:58.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:58.083]    - tweaked: FALSE
[08:24:58.083]    - call: NULL
[08:24:58.084] plan(): nbrOfWorkers() = 1
[08:24:58.088] plan(): Setting new future strategy stack:
[08:24:58.088] List of future strategies:
[08:24:58.088] 1. multicore:
[08:24:58.088]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:58.088]    - tweaked: FALSE
[08:24:58.088]    - call: plan(strategy)
[08:24:58.091] plan(): nbrOfWorkers() = 2
[08:24:58.083] MulticoreFuture:
[08:24:58.083] Label: ‘future_by-1’
[08:24:58.083] Expression:
[08:24:58.083] {
[08:24:58.083]     do.call(function(...) {
[08:24:58.083]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.083]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.083]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.083]             on.exit(options(oopts), add = TRUE)
[08:24:58.083]         }
[08:24:58.083]         {
[08:24:58.083]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.083]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.083]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.083]             })
[08:24:58.083]         }
[08:24:58.083]     }, args = future.call.arguments)
[08:24:58.083] }
[08:24:58.083] Lazy evaluation: FALSE
[08:24:58.083] Asynchronous evaluation: TRUE
[08:24:58.083] Local evaluation: TRUE
[08:24:58.083] Environment: 0x557b287f8408
[08:24:58.083] Capture standard output: TRUE
[08:24:58.083] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:58.083] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:58.083] Packages: <none>
[08:24:58.083] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:58.083] Resolved: TRUE
[08:24:58.083] Value: <not collected>
[08:24:58.083] Conditions captured: <none>
[08:24:58.083] Early signaling: FALSE
[08:24:58.083] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:58.083] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.092] Chunk #1 of 2 ... DONE
[08:24:58.092] Chunk #2 of 2 ...
[08:24:58.092]  - Finding globals in 'X' for chunk #2 ...
[08:24:58.092] getGlobalsAndPackages() ...
[08:24:58.093] Searching for globals...
[08:24:58.093] 
[08:24:58.093] Searching for globals ... DONE
[08:24:58.094] - globals: [0] <none>
[08:24:58.094] getGlobalsAndPackages() ... DONE
[08:24:58.094]    + additional globals found: [n=0] 
[08:24:58.094]    + additional namespaces needed: [n=0] 
[08:24:58.094]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:58.094]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:58.094]  - seeds: <none>
[08:24:58.094]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.095] getGlobalsAndPackages() ...
[08:24:58.095] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.095] Resolving globals: FALSE
[08:24:58.095] Tweak future expression to call with '...' arguments ...
[08:24:58.095] {
[08:24:58.095]     do.call(function(...) {
[08:24:58.095]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.095]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.095]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.095]             on.exit(options(oopts), add = TRUE)
[08:24:58.095]         }
[08:24:58.095]         {
[08:24:58.095]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.095]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.095]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.095]             })
[08:24:58.095]         }
[08:24:58.095]     }, args = future.call.arguments)
[08:24:58.095] }
[08:24:58.096] Tweak future expression to call with '...' arguments ... DONE
[08:24:58.096] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.096] 
[08:24:58.096] getGlobalsAndPackages() ... DONE
[08:24:58.097] run() for ‘Future’ ...
[08:24:58.097] - state: ‘created’
[08:24:58.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:58.100] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.100] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:58.101]   - Field: ‘label’
[08:24:58.101]   - Field: ‘local’
[08:24:58.101]   - Field: ‘owner’
[08:24:58.101]   - Field: ‘envir’
[08:24:58.101]   - Field: ‘workers’
[08:24:58.101]   - Field: ‘packages’
[08:24:58.102]   - Field: ‘gc’
[08:24:58.102]   - Field: ‘job’
[08:24:58.102]   - Field: ‘conditions’
[08:24:58.102]   - Field: ‘expr’
[08:24:58.102]   - Field: ‘uuid’
[08:24:58.102]   - Field: ‘seed’
[08:24:58.103]   - Field: ‘version’
[08:24:58.103]   - Field: ‘result’
[08:24:58.103]   - Field: ‘asynchronous’
[08:24:58.103]   - Field: ‘calls’
[08:24:58.103]   - Field: ‘globals’
[08:24:58.103]   - Field: ‘stdout’
[08:24:58.103]   - Field: ‘earlySignal’
[08:24:58.103]   - Field: ‘lazy’
[08:24:58.104]   - Field: ‘state’
[08:24:58.104] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:58.104] - Launch lazy future ...
[08:24:58.104] Packages needed by the future expression (n = 0): <none>
[08:24:58.105] Packages needed by future strategies (n = 0): <none>
[08:24:58.105] {
[08:24:58.105]     {
[08:24:58.105]         {
[08:24:58.105]             ...future.startTime <- base::Sys.time()
[08:24:58.105]             {
[08:24:58.105]                 {
[08:24:58.105]                   {
[08:24:58.105]                     {
[08:24:58.105]                       base::local({
[08:24:58.105]                         has_future <- base::requireNamespace("future", 
[08:24:58.105]                           quietly = TRUE)
[08:24:58.105]                         if (has_future) {
[08:24:58.105]                           ns <- base::getNamespace("future")
[08:24:58.105]                           version <- ns[[".package"]][["version"]]
[08:24:58.105]                           if (is.null(version)) 
[08:24:58.105]                             version <- utils::packageVersion("future")
[08:24:58.105]                         }
[08:24:58.105]                         else {
[08:24:58.105]                           version <- NULL
[08:24:58.105]                         }
[08:24:58.105]                         if (!has_future || version < "1.8.0") {
[08:24:58.105]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:58.105]                             "", base::R.version$version.string), 
[08:24:58.105]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:58.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:58.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:58.105]                               "release", "version")], collapse = " "), 
[08:24:58.105]                             hostname = base::Sys.info()[["nodename"]])
[08:24:58.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:58.105]                             info)
[08:24:58.105]                           info <- base::paste(info, collapse = "; ")
[08:24:58.105]                           if (!has_future) {
[08:24:58.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:58.105]                               info)
[08:24:58.105]                           }
[08:24:58.105]                           else {
[08:24:58.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:58.105]                               info, version)
[08:24:58.105]                           }
[08:24:58.105]                           base::stop(msg)
[08:24:58.105]                         }
[08:24:58.105]                       })
[08:24:58.105]                     }
[08:24:58.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:58.105]                     base::options(mc.cores = 1L)
[08:24:58.105]                   }
[08:24:58.105]                   ...future.strategy.old <- future::plan("list")
[08:24:58.105]                   options(future.plan = NULL)
[08:24:58.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:58.105]                 }
[08:24:58.105]                 ...future.workdir <- getwd()
[08:24:58.105]             }
[08:24:58.105]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:58.105]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:58.105]         }
[08:24:58.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:58.105]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:58.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:58.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:58.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:58.105]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:58.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:58.105]             base::names(...future.oldOptions))
[08:24:58.105]     }
[08:24:58.105]     if (FALSE) {
[08:24:58.105]     }
[08:24:58.105]     else {
[08:24:58.105]         if (TRUE) {
[08:24:58.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:58.105]                 open = "w")
[08:24:58.105]         }
[08:24:58.105]         else {
[08:24:58.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:58.105]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:58.105]         }
[08:24:58.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:58.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:58.105]             base::sink(type = "output", split = FALSE)
[08:24:58.105]             base::close(...future.stdout)
[08:24:58.105]         }, add = TRUE)
[08:24:58.105]     }
[08:24:58.105]     ...future.frame <- base::sys.nframe()
[08:24:58.105]     ...future.conditions <- base::list()
[08:24:58.105]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:58.105]     if (FALSE) {
[08:24:58.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:58.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:58.105]     }
[08:24:58.105]     ...future.result <- base::tryCatch({
[08:24:58.105]         base::withCallingHandlers({
[08:24:58.105]             ...future.value <- base::withVisible(base::local({
[08:24:58.105]                 withCallingHandlers({
[08:24:58.105]                   {
[08:24:58.105]                     do.call(function(...) {
[08:24:58.105]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.105]                       if (!identical(...future.globals.maxSize.org, 
[08:24:58.105]                         ...future.globals.maxSize)) {
[08:24:58.105]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.105]                         on.exit(options(oopts), add = TRUE)
[08:24:58.105]                       }
[08:24:58.105]                       {
[08:24:58.105]                         lapply(seq_along(...future.elements_ii), 
[08:24:58.105]                           FUN = function(jj) {
[08:24:58.105]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.105]                             ...future.FUN(...future.X_jj, ...)
[08:24:58.105]                           })
[08:24:58.105]                       }
[08:24:58.105]                     }, args = future.call.arguments)
[08:24:58.105]                   }
[08:24:58.105]                 }, immediateCondition = function(cond) {
[08:24:58.105]                   save_rds <- function (object, pathname, ...) 
[08:24:58.105]                   {
[08:24:58.105]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:58.105]                     if (file_test("-f", pathname_tmp)) {
[08:24:58.105]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.105]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:58.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.105]                         fi_tmp[["mtime"]])
[08:24:58.105]                     }
[08:24:58.105]                     tryCatch({
[08:24:58.105]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:58.105]                     }, error = function(ex) {
[08:24:58.105]                       msg <- conditionMessage(ex)
[08:24:58.105]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.105]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:58.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.105]                         fi_tmp[["mtime"]], msg)
[08:24:58.105]                       ex$message <- msg
[08:24:58.105]                       stop(ex)
[08:24:58.105]                     })
[08:24:58.105]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:58.105]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:58.105]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:58.105]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.105]                       fi <- file.info(pathname)
[08:24:58.105]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:58.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.105]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:58.105]                         fi[["size"]], fi[["mtime"]])
[08:24:58.105]                       stop(msg)
[08:24:58.105]                     }
[08:24:58.105]                     invisible(pathname)
[08:24:58.105]                   }
[08:24:58.105]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:58.105]                     rootPath = tempdir()) 
[08:24:58.105]                   {
[08:24:58.105]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:58.105]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:58.105]                       tmpdir = path, fileext = ".rds")
[08:24:58.105]                     save_rds(obj, file)
[08:24:58.105]                   }
[08:24:58.105]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:58.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.105]                   {
[08:24:58.105]                     inherits <- base::inherits
[08:24:58.105]                     invokeRestart <- base::invokeRestart
[08:24:58.105]                     is.null <- base::is.null
[08:24:58.105]                     muffled <- FALSE
[08:24:58.105]                     if (inherits(cond, "message")) {
[08:24:58.105]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:58.105]                       if (muffled) 
[08:24:58.105]                         invokeRestart("muffleMessage")
[08:24:58.105]                     }
[08:24:58.105]                     else if (inherits(cond, "warning")) {
[08:24:58.105]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:58.105]                       if (muffled) 
[08:24:58.105]                         invokeRestart("muffleWarning")
[08:24:58.105]                     }
[08:24:58.105]                     else if (inherits(cond, "condition")) {
[08:24:58.105]                       if (!is.null(pattern)) {
[08:24:58.105]                         computeRestarts <- base::computeRestarts
[08:24:58.105]                         grepl <- base::grepl
[08:24:58.105]                         restarts <- computeRestarts(cond)
[08:24:58.105]                         for (restart in restarts) {
[08:24:58.105]                           name <- restart$name
[08:24:58.105]                           if (is.null(name)) 
[08:24:58.105]                             next
[08:24:58.105]                           if (!grepl(pattern, name)) 
[08:24:58.105]                             next
[08:24:58.105]                           invokeRestart(restart)
[08:24:58.105]                           muffled <- TRUE
[08:24:58.105]                           break
[08:24:58.105]                         }
[08:24:58.105]                       }
[08:24:58.105]                     }
[08:24:58.105]                     invisible(muffled)
[08:24:58.105]                   }
[08:24:58.105]                   muffleCondition(cond)
[08:24:58.105]                 })
[08:24:58.105]             }))
[08:24:58.105]             future::FutureResult(value = ...future.value$value, 
[08:24:58.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.105]                   ...future.rng), globalenv = if (FALSE) 
[08:24:58.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:58.105]                     ...future.globalenv.names))
[08:24:58.105]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:58.105]         }, condition = base::local({
[08:24:58.105]             c <- base::c
[08:24:58.105]             inherits <- base::inherits
[08:24:58.105]             invokeRestart <- base::invokeRestart
[08:24:58.105]             length <- base::length
[08:24:58.105]             list <- base::list
[08:24:58.105]             seq.int <- base::seq.int
[08:24:58.105]             signalCondition <- base::signalCondition
[08:24:58.105]             sys.calls <- base::sys.calls
[08:24:58.105]             `[[` <- base::`[[`
[08:24:58.105]             `+` <- base::`+`
[08:24:58.105]             `<<-` <- base::`<<-`
[08:24:58.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:58.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:58.105]                   3L)]
[08:24:58.105]             }
[08:24:58.105]             function(cond) {
[08:24:58.105]                 is_error <- inherits(cond, "error")
[08:24:58.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:58.105]                   NULL)
[08:24:58.105]                 if (is_error) {
[08:24:58.105]                   sessionInformation <- function() {
[08:24:58.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:58.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:58.105]                       search = base::search(), system = base::Sys.info())
[08:24:58.105]                   }
[08:24:58.105]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:58.105]                     cond$call), session = sessionInformation(), 
[08:24:58.105]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:58.105]                   signalCondition(cond)
[08:24:58.105]                 }
[08:24:58.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:58.105]                 "immediateCondition"))) {
[08:24:58.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:58.105]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:58.105]                   if (TRUE && !signal) {
[08:24:58.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.105]                     {
[08:24:58.105]                       inherits <- base::inherits
[08:24:58.105]                       invokeRestart <- base::invokeRestart
[08:24:58.105]                       is.null <- base::is.null
[08:24:58.105]                       muffled <- FALSE
[08:24:58.105]                       if (inherits(cond, "message")) {
[08:24:58.105]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.105]                         if (muffled) 
[08:24:58.105]                           invokeRestart("muffleMessage")
[08:24:58.105]                       }
[08:24:58.105]                       else if (inherits(cond, "warning")) {
[08:24:58.105]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.105]                         if (muffled) 
[08:24:58.105]                           invokeRestart("muffleWarning")
[08:24:58.105]                       }
[08:24:58.105]                       else if (inherits(cond, "condition")) {
[08:24:58.105]                         if (!is.null(pattern)) {
[08:24:58.105]                           computeRestarts <- base::computeRestarts
[08:24:58.105]                           grepl <- base::grepl
[08:24:58.105]                           restarts <- computeRestarts(cond)
[08:24:58.105]                           for (restart in restarts) {
[08:24:58.105]                             name <- restart$name
[08:24:58.105]                             if (is.null(name)) 
[08:24:58.105]                               next
[08:24:58.105]                             if (!grepl(pattern, name)) 
[08:24:58.105]                               next
[08:24:58.105]                             invokeRestart(restart)
[08:24:58.105]                             muffled <- TRUE
[08:24:58.105]                             break
[08:24:58.105]                           }
[08:24:58.105]                         }
[08:24:58.105]                       }
[08:24:58.105]                       invisible(muffled)
[08:24:58.105]                     }
[08:24:58.105]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.105]                   }
[08:24:58.105]                 }
[08:24:58.105]                 else {
[08:24:58.105]                   if (TRUE) {
[08:24:58.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.105]                     {
[08:24:58.105]                       inherits <- base::inherits
[08:24:58.105]                       invokeRestart <- base::invokeRestart
[08:24:58.105]                       is.null <- base::is.null
[08:24:58.105]                       muffled <- FALSE
[08:24:58.105]                       if (inherits(cond, "message")) {
[08:24:58.105]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.105]                         if (muffled) 
[08:24:58.105]                           invokeRestart("muffleMessage")
[08:24:58.105]                       }
[08:24:58.105]                       else if (inherits(cond, "warning")) {
[08:24:58.105]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.105]                         if (muffled) 
[08:24:58.105]                           invokeRestart("muffleWarning")
[08:24:58.105]                       }
[08:24:58.105]                       else if (inherits(cond, "condition")) {
[08:24:58.105]                         if (!is.null(pattern)) {
[08:24:58.105]                           computeRestarts <- base::computeRestarts
[08:24:58.105]                           grepl <- base::grepl
[08:24:58.105]                           restarts <- computeRestarts(cond)
[08:24:58.105]                           for (restart in restarts) {
[08:24:58.105]                             name <- restart$name
[08:24:58.105]                             if (is.null(name)) 
[08:24:58.105]                               next
[08:24:58.105]                             if (!grepl(pattern, name)) 
[08:24:58.105]                               next
[08:24:58.105]                             invokeRestart(restart)
[08:24:58.105]                             muffled <- TRUE
[08:24:58.105]                             break
[08:24:58.105]                           }
[08:24:58.105]                         }
[08:24:58.105]                       }
[08:24:58.105]                       invisible(muffled)
[08:24:58.105]                     }
[08:24:58.105]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.105]                   }
[08:24:58.105]                 }
[08:24:58.105]             }
[08:24:58.105]         }))
[08:24:58.105]     }, error = function(ex) {
[08:24:58.105]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:58.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.105]                 ...future.rng), started = ...future.startTime, 
[08:24:58.105]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:58.105]             version = "1.8"), class = "FutureResult")
[08:24:58.105]     }, finally = {
[08:24:58.105]         if (!identical(...future.workdir, getwd())) 
[08:24:58.105]             setwd(...future.workdir)
[08:24:58.105]         {
[08:24:58.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:58.105]                 ...future.oldOptions$nwarnings <- NULL
[08:24:58.105]             }
[08:24:58.105]             base::options(...future.oldOptions)
[08:24:58.105]             if (.Platform$OS.type == "windows") {
[08:24:58.105]                 old_names <- names(...future.oldEnvVars)
[08:24:58.105]                 envs <- base::Sys.getenv()
[08:24:58.105]                 names <- names(envs)
[08:24:58.105]                 common <- intersect(names, old_names)
[08:24:58.105]                 added <- setdiff(names, old_names)
[08:24:58.105]                 removed <- setdiff(old_names, names)
[08:24:58.105]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:58.105]                   envs[common]]
[08:24:58.105]                 NAMES <- toupper(changed)
[08:24:58.105]                 args <- list()
[08:24:58.105]                 for (kk in seq_along(NAMES)) {
[08:24:58.105]                   name <- changed[[kk]]
[08:24:58.105]                   NAME <- NAMES[[kk]]
[08:24:58.105]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.105]                     next
[08:24:58.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.105]                 }
[08:24:58.105]                 NAMES <- toupper(added)
[08:24:58.105]                 for (kk in seq_along(NAMES)) {
[08:24:58.105]                   name <- added[[kk]]
[08:24:58.105]                   NAME <- NAMES[[kk]]
[08:24:58.105]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.105]                     next
[08:24:58.105]                   args[[name]] <- ""
[08:24:58.105]                 }
[08:24:58.105]                 NAMES <- toupper(removed)
[08:24:58.105]                 for (kk in seq_along(NAMES)) {
[08:24:58.105]                   name <- removed[[kk]]
[08:24:58.105]                   NAME <- NAMES[[kk]]
[08:24:58.105]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.105]                     next
[08:24:58.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.105]                 }
[08:24:58.105]                 if (length(args) > 0) 
[08:24:58.105]                   base::do.call(base::Sys.setenv, args = args)
[08:24:58.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:58.105]             }
[08:24:58.105]             else {
[08:24:58.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:58.105]             }
[08:24:58.105]             {
[08:24:58.105]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:58.105]                   0L) {
[08:24:58.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:58.105]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:58.105]                   base::options(opts)
[08:24:58.105]                 }
[08:24:58.105]                 {
[08:24:58.105]                   {
[08:24:58.105]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:58.105]                     NULL
[08:24:58.105]                   }
[08:24:58.105]                   options(future.plan = NULL)
[08:24:58.105]                   if (is.na(NA_character_)) 
[08:24:58.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:58.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:58.105]                     .init = FALSE)
[08:24:58.105]                 }
[08:24:58.105]             }
[08:24:58.105]         }
[08:24:58.105]     })
[08:24:58.105]     if (TRUE) {
[08:24:58.105]         base::sink(type = "output", split = FALSE)
[08:24:58.105]         if (TRUE) {
[08:24:58.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:58.105]         }
[08:24:58.105]         else {
[08:24:58.105]             ...future.result["stdout"] <- base::list(NULL)
[08:24:58.105]         }
[08:24:58.105]         base::close(...future.stdout)
[08:24:58.105]         ...future.stdout <- NULL
[08:24:58.105]     }
[08:24:58.105]     ...future.result$conditions <- ...future.conditions
[08:24:58.105]     ...future.result$finished <- base::Sys.time()
[08:24:58.105]     ...future.result
[08:24:58.105] }
[08:24:58.109] assign_globals() ...
[08:24:58.109] List of 5
[08:24:58.109]  $ ...future.FUN            :function (object, ...)  
[08:24:58.109]  $ future.call.arguments    : list()
[08:24:58.109]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.109]  $ ...future.elements_ii    :List of 2
[08:24:58.109]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:58.109]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:58.109]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:58.109]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:58.109]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:58.109]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:58.109]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:58.109]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:58.109]  $ ...future.seeds_ii       : NULL
[08:24:58.109]  $ ...future.globals.maxSize: NULL
[08:24:58.109]  - attr(*, "where")=List of 5
[08:24:58.109]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:58.109]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:58.109]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:58.109]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:58.109]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:58.109]  - attr(*, "resolved")= logi FALSE
[08:24:58.109]  - attr(*, "total_size")= num 19278
[08:24:58.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.109]  - attr(*, "already-done")= logi TRUE
[08:24:58.121] - copied ‘...future.FUN’ to environment
[08:24:58.121] - copied ‘future.call.arguments’ to environment
[08:24:58.121] - copied ‘...future.elements_ii’ to environment
[08:24:58.121] - copied ‘...future.seeds_ii’ to environment
[08:24:58.121] - copied ‘...future.globals.maxSize’ to environment
[08:24:58.121] assign_globals() ... done
[08:24:58.122] requestCore(): workers = 2
[08:24:58.124] MulticoreFuture started
[08:24:58.124] - Launch lazy future ... done
[08:24:58.124] run() for ‘MulticoreFuture’ ... done
[08:24:58.125] Created future:
[08:24:58.125] plan(): Setting new future strategy stack:
[08:24:58.125] List of future strategies:
[08:24:58.125] 1. sequential:
[08:24:58.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:58.125]    - tweaked: FALSE
[08:24:58.125]    - call: NULL
[08:24:58.126] plan(): nbrOfWorkers() = 1
[08:24:58.131] plan(): Setting new future strategy stack:
[08:24:58.131] List of future strategies:
[08:24:58.131] 1. multicore:
[08:24:58.131]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:58.131]    - tweaked: FALSE
[08:24:58.131]    - call: plan(strategy)
[08:24:58.134] plan(): nbrOfWorkers() = 2
[08:24:58.125] MulticoreFuture:
[08:24:58.125] Label: ‘future_by-2’
[08:24:58.125] Expression:
[08:24:58.125] {
[08:24:58.125]     do.call(function(...) {
[08:24:58.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.125]             on.exit(options(oopts), add = TRUE)
[08:24:58.125]         }
[08:24:58.125]         {
[08:24:58.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.125]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.125]             })
[08:24:58.125]         }
[08:24:58.125]     }, args = future.call.arguments)
[08:24:58.125] }
[08:24:58.125] Lazy evaluation: FALSE
[08:24:58.125] Asynchronous evaluation: TRUE
[08:24:58.125] Local evaluation: TRUE
[08:24:58.125] Environment: 0x557b287f8408
[08:24:58.125] Capture standard output: TRUE
[08:24:58.125] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:58.125] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:58.125] Packages: <none>
[08:24:58.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:58.125] Resolved: TRUE
[08:24:58.125] Value: <not collected>
[08:24:58.125] Conditions captured: <none>
[08:24:58.125] Early signaling: FALSE
[08:24:58.125] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:58.125] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.135] Chunk #2 of 2 ... DONE
[08:24:58.135] Launching 2 futures (chunks) ... DONE
[08:24:58.135] Resolving 2 futures (chunks) ...
[08:24:58.135] resolve() on list ...
[08:24:58.135]  recursive: 0
[08:24:58.136]  length: 2
[08:24:58.136] 
[08:24:58.136] Future #1
[08:24:58.136] result() for MulticoreFuture ...
[08:24:58.137] result() for MulticoreFuture ...
[08:24:58.137] result() for MulticoreFuture ... done
[08:24:58.137] result() for MulticoreFuture ... done
[08:24:58.138] result() for MulticoreFuture ...
[08:24:58.138] result() for MulticoreFuture ... done
[08:24:58.138] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:58.138] - nx: 2
[08:24:58.138] - relay: TRUE
[08:24:58.138] - stdout: TRUE
[08:24:58.138] - signal: TRUE
[08:24:58.138] - resignal: FALSE
[08:24:58.139] - force: TRUE
[08:24:58.139] - relayed: [n=2] FALSE, FALSE
[08:24:58.139] - queued futures: [n=2] FALSE, FALSE
[08:24:58.139]  - until=1
[08:24:58.139]  - relaying element #1
[08:24:58.139] result() for MulticoreFuture ...
[08:24:58.139] result() for MulticoreFuture ... done
[08:24:58.139] result() for MulticoreFuture ...
[08:24:58.140] result() for MulticoreFuture ... done
[08:24:58.140] result() for MulticoreFuture ...
[08:24:58.140] result() for MulticoreFuture ... done
[08:24:58.140] result() for MulticoreFuture ...
[08:24:58.140] result() for MulticoreFuture ... done
[08:24:58.140] - relayed: [n=2] TRUE, FALSE
[08:24:58.140] - queued futures: [n=2] TRUE, FALSE
[08:24:58.140] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:58.141]  length: 1 (resolved future 1)
[08:24:58.141] Future #2
[08:24:58.141] result() for MulticoreFuture ...
[08:24:58.142] result() for MulticoreFuture ...
[08:24:58.142] result() for MulticoreFuture ... done
[08:24:58.142] result() for MulticoreFuture ... done
[08:24:58.142] result() for MulticoreFuture ...
[08:24:58.142] result() for MulticoreFuture ... done
[08:24:58.142] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:58.142] - nx: 2
[08:24:58.142] - relay: TRUE
[08:24:58.143] - stdout: TRUE
[08:24:58.143] - signal: TRUE
[08:24:58.143] - resignal: FALSE
[08:24:58.143] - force: TRUE
[08:24:58.143] - relayed: [n=2] TRUE, FALSE
[08:24:58.143] - queued futures: [n=2] TRUE, FALSE
[08:24:58.143]  - until=2
[08:24:58.143]  - relaying element #2
[08:24:58.143] result() for MulticoreFuture ...
[08:24:58.144] result() for MulticoreFuture ... done
[08:24:58.144] result() for MulticoreFuture ...
[08:24:58.144] result() for MulticoreFuture ... done
[08:24:58.144] result() for MulticoreFuture ...
[08:24:58.144] result() for MulticoreFuture ... done
[08:24:58.144] result() for MulticoreFuture ...
[08:24:58.144] result() for MulticoreFuture ... done
[08:24:58.144] - relayed: [n=2] TRUE, TRUE
[08:24:58.144] - queued futures: [n=2] TRUE, TRUE
[08:24:58.145] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:58.145]  length: 0 (resolved future 2)
[08:24:58.145] Relaying remaining futures
[08:24:58.145] signalConditionsASAP(NULL, pos=0) ...
[08:24:58.145] - nx: 2
[08:24:58.145] - relay: TRUE
[08:24:58.145] - stdout: TRUE
[08:24:58.145] - signal: TRUE
[08:24:58.145] - resignal: FALSE
[08:24:58.146] - force: TRUE
[08:24:58.146] - relayed: [n=2] TRUE, TRUE
[08:24:58.146] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:58.146] - relayed: [n=2] TRUE, TRUE
[08:24:58.146] - queued futures: [n=2] TRUE, TRUE
[08:24:58.146] signalConditionsASAP(NULL, pos=0) ... done
[08:24:58.146] resolve() on list ... DONE
[08:24:58.146] result() for MulticoreFuture ...
[08:24:58.147] result() for MulticoreFuture ... done
[08:24:58.147] result() for MulticoreFuture ...
[08:24:58.147] result() for MulticoreFuture ... done
[08:24:58.147] result() for MulticoreFuture ...
[08:24:58.147] result() for MulticoreFuture ... done
[08:24:58.147] result() for MulticoreFuture ...
[08:24:58.147] result() for MulticoreFuture ... done
[08:24:58.147]  - Number of value chunks collected: 2
[08:24:58.147] Resolving 2 futures (chunks) ... DONE
[08:24:58.148] Reducing values from 2 chunks ...
[08:24:58.148]  - Number of values collected after concatenation: 3
[08:24:58.148]  - Number of values expected: 3
[08:24:58.148] Reducing values from 2 chunks ... DONE
[08:24:58.148] future_lapply() ... DONE
[08:24:58.148] future_by_internal() ... DONE
[08:24:58.149] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[08:24:58.150] future_lapply() ...
[08:24:58.153] Number of chunks: 2
[08:24:58.153] getGlobalsAndPackagesXApply() ...
[08:24:58.154]  - future.globals: TRUE
[08:24:58.154] getGlobalsAndPackages() ...
[08:24:58.154] Searching for globals...
[08:24:58.155] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:58.155] Searching for globals ... DONE
[08:24:58.155] Resolving globals: FALSE
[08:24:58.156] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:58.156] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:58.156] - globals: [1] ‘FUN’
[08:24:58.157] 
[08:24:58.157] getGlobalsAndPackages() ... DONE
[08:24:58.157]  - globals found/used: [n=1] ‘FUN’
[08:24:58.157]  - needed namespaces: [n=0] 
[08:24:58.157] Finding globals ... DONE
[08:24:58.157]  - use_args: TRUE
[08:24:58.157]  - Getting '...' globals ...
[08:24:58.158] resolve() on list ...
[08:24:58.158]  recursive: 0
[08:24:58.158]  length: 1
[08:24:58.158]  elements: ‘...’
[08:24:58.158]  length: 0 (resolved future 1)
[08:24:58.158] resolve() on list ... DONE
[08:24:58.159]    - '...' content: [n=0] 
[08:24:58.159] List of 1
[08:24:58.159]  $ ...: list()
[08:24:58.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.159]  - attr(*, "where")=List of 1
[08:24:58.159]   ..$ ...:<environment: 0x557b2972d310> 
[08:24:58.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.159]  - attr(*, "resolved")= logi TRUE
[08:24:58.159]  - attr(*, "total_size")= num NA
[08:24:58.162]  - Getting '...' globals ... DONE
[08:24:58.162] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:58.162] List of 2
[08:24:58.162]  $ ...future.FUN:function (object, ...)  
[08:24:58.162]  $ ...          : list()
[08:24:58.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.162]  - attr(*, "where")=List of 2
[08:24:58.162]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:58.162]   ..$ ...          :<environment: 0x557b2972d310> 
[08:24:58.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.162]  - attr(*, "resolved")= logi FALSE
[08:24:58.162]  - attr(*, "total_size")= num 18647
[08:24:58.166] Packages to be attached in all futures: [n=0] 
[08:24:58.166] getGlobalsAndPackagesXApply() ... DONE
[08:24:58.166] Number of futures (= number of chunks): 2
[08:24:58.166] Launching 2 futures (chunks) ...
[08:24:58.166] Chunk #1 of 2 ...
[08:24:58.166]  - Finding globals in 'X' for chunk #1 ...
[08:24:58.167] getGlobalsAndPackages() ...
[08:24:58.167] Searching for globals...
[08:24:58.167] 
[08:24:58.167] Searching for globals ... DONE
[08:24:58.167] - globals: [0] <none>
[08:24:58.167] getGlobalsAndPackages() ... DONE
[08:24:58.168]    + additional globals found: [n=0] 
[08:24:58.168]    + additional namespaces needed: [n=0] 
[08:24:58.168]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:58.168]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:58.168]  - seeds: <none>
[08:24:58.168]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.168] getGlobalsAndPackages() ...
[08:24:58.168] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.168] Resolving globals: FALSE
[08:24:58.169] Tweak future expression to call with '...' arguments ...
[08:24:58.169] {
[08:24:58.169]     do.call(function(...) {
[08:24:58.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.169]             on.exit(options(oopts), add = TRUE)
[08:24:58.169]         }
[08:24:58.169]         {
[08:24:58.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.169]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.169]             })
[08:24:58.169]         }
[08:24:58.169]     }, args = future.call.arguments)
[08:24:58.169] }
[08:24:58.169] Tweak future expression to call with '...' arguments ... DONE
[08:24:58.169] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.170] 
[08:24:58.170] getGlobalsAndPackages() ... DONE
[08:24:58.170] run() for ‘Future’ ...
[08:24:58.170] - state: ‘created’
[08:24:58.170] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:58.173] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:58.173]   - Field: ‘label’
[08:24:58.173]   - Field: ‘local’
[08:24:58.173]   - Field: ‘owner’
[08:24:58.173]   - Field: ‘envir’
[08:24:58.173]   - Field: ‘workers’
[08:24:58.173]   - Field: ‘packages’
[08:24:58.174]   - Field: ‘gc’
[08:24:58.174]   - Field: ‘job’
[08:24:58.174]   - Field: ‘conditions’
[08:24:58.174]   - Field: ‘expr’
[08:24:58.174]   - Field: ‘uuid’
[08:24:58.174]   - Field: ‘seed’
[08:24:58.174]   - Field: ‘version’
[08:24:58.174]   - Field: ‘result’
[08:24:58.174]   - Field: ‘asynchronous’
[08:24:58.175]   - Field: ‘calls’
[08:24:58.175]   - Field: ‘globals’
[08:24:58.175]   - Field: ‘stdout’
[08:24:58.175]   - Field: ‘earlySignal’
[08:24:58.175]   - Field: ‘lazy’
[08:24:58.175]   - Field: ‘state’
[08:24:58.175] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:58.175] - Launch lazy future ...
[08:24:58.176] Packages needed by the future expression (n = 0): <none>
[08:24:58.176] Packages needed by future strategies (n = 0): <none>
[08:24:58.176] {
[08:24:58.176]     {
[08:24:58.176]         {
[08:24:58.176]             ...future.startTime <- base::Sys.time()
[08:24:58.176]             {
[08:24:58.176]                 {
[08:24:58.176]                   {
[08:24:58.176]                     {
[08:24:58.176]                       base::local({
[08:24:58.176]                         has_future <- base::requireNamespace("future", 
[08:24:58.176]                           quietly = TRUE)
[08:24:58.176]                         if (has_future) {
[08:24:58.176]                           ns <- base::getNamespace("future")
[08:24:58.176]                           version <- ns[[".package"]][["version"]]
[08:24:58.176]                           if (is.null(version)) 
[08:24:58.176]                             version <- utils::packageVersion("future")
[08:24:58.176]                         }
[08:24:58.176]                         else {
[08:24:58.176]                           version <- NULL
[08:24:58.176]                         }
[08:24:58.176]                         if (!has_future || version < "1.8.0") {
[08:24:58.176]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:58.176]                             "", base::R.version$version.string), 
[08:24:58.176]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:58.176]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:58.176]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:58.176]                               "release", "version")], collapse = " "), 
[08:24:58.176]                             hostname = base::Sys.info()[["nodename"]])
[08:24:58.176]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:58.176]                             info)
[08:24:58.176]                           info <- base::paste(info, collapse = "; ")
[08:24:58.176]                           if (!has_future) {
[08:24:58.176]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:58.176]                               info)
[08:24:58.176]                           }
[08:24:58.176]                           else {
[08:24:58.176]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:58.176]                               info, version)
[08:24:58.176]                           }
[08:24:58.176]                           base::stop(msg)
[08:24:58.176]                         }
[08:24:58.176]                       })
[08:24:58.176]                     }
[08:24:58.176]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:58.176]                     base::options(mc.cores = 1L)
[08:24:58.176]                   }
[08:24:58.176]                   ...future.strategy.old <- future::plan("list")
[08:24:58.176]                   options(future.plan = NULL)
[08:24:58.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:58.176]                 }
[08:24:58.176]                 ...future.workdir <- getwd()
[08:24:58.176]             }
[08:24:58.176]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:58.176]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:58.176]         }
[08:24:58.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:58.176]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:58.176]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:58.176]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:58.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:58.176]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:58.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:58.176]             base::names(...future.oldOptions))
[08:24:58.176]     }
[08:24:58.176]     if (FALSE) {
[08:24:58.176]     }
[08:24:58.176]     else {
[08:24:58.176]         if (TRUE) {
[08:24:58.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:58.176]                 open = "w")
[08:24:58.176]         }
[08:24:58.176]         else {
[08:24:58.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:58.176]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:58.176]         }
[08:24:58.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:58.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:58.176]             base::sink(type = "output", split = FALSE)
[08:24:58.176]             base::close(...future.stdout)
[08:24:58.176]         }, add = TRUE)
[08:24:58.176]     }
[08:24:58.176]     ...future.frame <- base::sys.nframe()
[08:24:58.176]     ...future.conditions <- base::list()
[08:24:58.176]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:58.176]     if (FALSE) {
[08:24:58.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:58.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:58.176]     }
[08:24:58.176]     ...future.result <- base::tryCatch({
[08:24:58.176]         base::withCallingHandlers({
[08:24:58.176]             ...future.value <- base::withVisible(base::local({
[08:24:58.176]                 withCallingHandlers({
[08:24:58.176]                   {
[08:24:58.176]                     do.call(function(...) {
[08:24:58.176]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.176]                       if (!identical(...future.globals.maxSize.org, 
[08:24:58.176]                         ...future.globals.maxSize)) {
[08:24:58.176]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.176]                         on.exit(options(oopts), add = TRUE)
[08:24:58.176]                       }
[08:24:58.176]                       {
[08:24:58.176]                         lapply(seq_along(...future.elements_ii), 
[08:24:58.176]                           FUN = function(jj) {
[08:24:58.176]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.176]                             ...future.FUN(...future.X_jj, ...)
[08:24:58.176]                           })
[08:24:58.176]                       }
[08:24:58.176]                     }, args = future.call.arguments)
[08:24:58.176]                   }
[08:24:58.176]                 }, immediateCondition = function(cond) {
[08:24:58.176]                   save_rds <- function (object, pathname, ...) 
[08:24:58.176]                   {
[08:24:58.176]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:58.176]                     if (file_test("-f", pathname_tmp)) {
[08:24:58.176]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.176]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:58.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.176]                         fi_tmp[["mtime"]])
[08:24:58.176]                     }
[08:24:58.176]                     tryCatch({
[08:24:58.176]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:58.176]                     }, error = function(ex) {
[08:24:58.176]                       msg <- conditionMessage(ex)
[08:24:58.176]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.176]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:58.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.176]                         fi_tmp[["mtime"]], msg)
[08:24:58.176]                       ex$message <- msg
[08:24:58.176]                       stop(ex)
[08:24:58.176]                     })
[08:24:58.176]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:58.176]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:58.176]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:58.176]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.176]                       fi <- file.info(pathname)
[08:24:58.176]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:58.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.176]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:58.176]                         fi[["size"]], fi[["mtime"]])
[08:24:58.176]                       stop(msg)
[08:24:58.176]                     }
[08:24:58.176]                     invisible(pathname)
[08:24:58.176]                   }
[08:24:58.176]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:58.176]                     rootPath = tempdir()) 
[08:24:58.176]                   {
[08:24:58.176]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:58.176]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:58.176]                       tmpdir = path, fileext = ".rds")
[08:24:58.176]                     save_rds(obj, file)
[08:24:58.176]                   }
[08:24:58.176]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:58.176]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.176]                   {
[08:24:58.176]                     inherits <- base::inherits
[08:24:58.176]                     invokeRestart <- base::invokeRestart
[08:24:58.176]                     is.null <- base::is.null
[08:24:58.176]                     muffled <- FALSE
[08:24:58.176]                     if (inherits(cond, "message")) {
[08:24:58.176]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:58.176]                       if (muffled) 
[08:24:58.176]                         invokeRestart("muffleMessage")
[08:24:58.176]                     }
[08:24:58.176]                     else if (inherits(cond, "warning")) {
[08:24:58.176]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:58.176]                       if (muffled) 
[08:24:58.176]                         invokeRestart("muffleWarning")
[08:24:58.176]                     }
[08:24:58.176]                     else if (inherits(cond, "condition")) {
[08:24:58.176]                       if (!is.null(pattern)) {
[08:24:58.176]                         computeRestarts <- base::computeRestarts
[08:24:58.176]                         grepl <- base::grepl
[08:24:58.176]                         restarts <- computeRestarts(cond)
[08:24:58.176]                         for (restart in restarts) {
[08:24:58.176]                           name <- restart$name
[08:24:58.176]                           if (is.null(name)) 
[08:24:58.176]                             next
[08:24:58.176]                           if (!grepl(pattern, name)) 
[08:24:58.176]                             next
[08:24:58.176]                           invokeRestart(restart)
[08:24:58.176]                           muffled <- TRUE
[08:24:58.176]                           break
[08:24:58.176]                         }
[08:24:58.176]                       }
[08:24:58.176]                     }
[08:24:58.176]                     invisible(muffled)
[08:24:58.176]                   }
[08:24:58.176]                   muffleCondition(cond)
[08:24:58.176]                 })
[08:24:58.176]             }))
[08:24:58.176]             future::FutureResult(value = ...future.value$value, 
[08:24:58.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.176]                   ...future.rng), globalenv = if (FALSE) 
[08:24:58.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:58.176]                     ...future.globalenv.names))
[08:24:58.176]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:58.176]         }, condition = base::local({
[08:24:58.176]             c <- base::c
[08:24:58.176]             inherits <- base::inherits
[08:24:58.176]             invokeRestart <- base::invokeRestart
[08:24:58.176]             length <- base::length
[08:24:58.176]             list <- base::list
[08:24:58.176]             seq.int <- base::seq.int
[08:24:58.176]             signalCondition <- base::signalCondition
[08:24:58.176]             sys.calls <- base::sys.calls
[08:24:58.176]             `[[` <- base::`[[`
[08:24:58.176]             `+` <- base::`+`
[08:24:58.176]             `<<-` <- base::`<<-`
[08:24:58.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:58.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:58.176]                   3L)]
[08:24:58.176]             }
[08:24:58.176]             function(cond) {
[08:24:58.176]                 is_error <- inherits(cond, "error")
[08:24:58.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:58.176]                   NULL)
[08:24:58.176]                 if (is_error) {
[08:24:58.176]                   sessionInformation <- function() {
[08:24:58.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:58.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:58.176]                       search = base::search(), system = base::Sys.info())
[08:24:58.176]                   }
[08:24:58.176]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:58.176]                     cond$call), session = sessionInformation(), 
[08:24:58.176]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:58.176]                   signalCondition(cond)
[08:24:58.176]                 }
[08:24:58.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:58.176]                 "immediateCondition"))) {
[08:24:58.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:58.176]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:58.176]                   if (TRUE && !signal) {
[08:24:58.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.176]                     {
[08:24:58.176]                       inherits <- base::inherits
[08:24:58.176]                       invokeRestart <- base::invokeRestart
[08:24:58.176]                       is.null <- base::is.null
[08:24:58.176]                       muffled <- FALSE
[08:24:58.176]                       if (inherits(cond, "message")) {
[08:24:58.176]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.176]                         if (muffled) 
[08:24:58.176]                           invokeRestart("muffleMessage")
[08:24:58.176]                       }
[08:24:58.176]                       else if (inherits(cond, "warning")) {
[08:24:58.176]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.176]                         if (muffled) 
[08:24:58.176]                           invokeRestart("muffleWarning")
[08:24:58.176]                       }
[08:24:58.176]                       else if (inherits(cond, "condition")) {
[08:24:58.176]                         if (!is.null(pattern)) {
[08:24:58.176]                           computeRestarts <- base::computeRestarts
[08:24:58.176]                           grepl <- base::grepl
[08:24:58.176]                           restarts <- computeRestarts(cond)
[08:24:58.176]                           for (restart in restarts) {
[08:24:58.176]                             name <- restart$name
[08:24:58.176]                             if (is.null(name)) 
[08:24:58.176]                               next
[08:24:58.176]                             if (!grepl(pattern, name)) 
[08:24:58.176]                               next
[08:24:58.176]                             invokeRestart(restart)
[08:24:58.176]                             muffled <- TRUE
[08:24:58.176]                             break
[08:24:58.176]                           }
[08:24:58.176]                         }
[08:24:58.176]                       }
[08:24:58.176]                       invisible(muffled)
[08:24:58.176]                     }
[08:24:58.176]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.176]                   }
[08:24:58.176]                 }
[08:24:58.176]                 else {
[08:24:58.176]                   if (TRUE) {
[08:24:58.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.176]                     {
[08:24:58.176]                       inherits <- base::inherits
[08:24:58.176]                       invokeRestart <- base::invokeRestart
[08:24:58.176]                       is.null <- base::is.null
[08:24:58.176]                       muffled <- FALSE
[08:24:58.176]                       if (inherits(cond, "message")) {
[08:24:58.176]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.176]                         if (muffled) 
[08:24:58.176]                           invokeRestart("muffleMessage")
[08:24:58.176]                       }
[08:24:58.176]                       else if (inherits(cond, "warning")) {
[08:24:58.176]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.176]                         if (muffled) 
[08:24:58.176]                           invokeRestart("muffleWarning")
[08:24:58.176]                       }
[08:24:58.176]                       else if (inherits(cond, "condition")) {
[08:24:58.176]                         if (!is.null(pattern)) {
[08:24:58.176]                           computeRestarts <- base::computeRestarts
[08:24:58.176]                           grepl <- base::grepl
[08:24:58.176]                           restarts <- computeRestarts(cond)
[08:24:58.176]                           for (restart in restarts) {
[08:24:58.176]                             name <- restart$name
[08:24:58.176]                             if (is.null(name)) 
[08:24:58.176]                               next
[08:24:58.176]                             if (!grepl(pattern, name)) 
[08:24:58.176]                               next
[08:24:58.176]                             invokeRestart(restart)
[08:24:58.176]                             muffled <- TRUE
[08:24:58.176]                             break
[08:24:58.176]                           }
[08:24:58.176]                         }
[08:24:58.176]                       }
[08:24:58.176]                       invisible(muffled)
[08:24:58.176]                     }
[08:24:58.176]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.176]                   }
[08:24:58.176]                 }
[08:24:58.176]             }
[08:24:58.176]         }))
[08:24:58.176]     }, error = function(ex) {
[08:24:58.176]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:58.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.176]                 ...future.rng), started = ...future.startTime, 
[08:24:58.176]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:58.176]             version = "1.8"), class = "FutureResult")
[08:24:58.176]     }, finally = {
[08:24:58.176]         if (!identical(...future.workdir, getwd())) 
[08:24:58.176]             setwd(...future.workdir)
[08:24:58.176]         {
[08:24:58.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:58.176]                 ...future.oldOptions$nwarnings <- NULL
[08:24:58.176]             }
[08:24:58.176]             base::options(...future.oldOptions)
[08:24:58.176]             if (.Platform$OS.type == "windows") {
[08:24:58.176]                 old_names <- names(...future.oldEnvVars)
[08:24:58.176]                 envs <- base::Sys.getenv()
[08:24:58.176]                 names <- names(envs)
[08:24:58.176]                 common <- intersect(names, old_names)
[08:24:58.176]                 added <- setdiff(names, old_names)
[08:24:58.176]                 removed <- setdiff(old_names, names)
[08:24:58.176]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:58.176]                   envs[common]]
[08:24:58.176]                 NAMES <- toupper(changed)
[08:24:58.176]                 args <- list()
[08:24:58.176]                 for (kk in seq_along(NAMES)) {
[08:24:58.176]                   name <- changed[[kk]]
[08:24:58.176]                   NAME <- NAMES[[kk]]
[08:24:58.176]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.176]                     next
[08:24:58.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.176]                 }
[08:24:58.176]                 NAMES <- toupper(added)
[08:24:58.176]                 for (kk in seq_along(NAMES)) {
[08:24:58.176]                   name <- added[[kk]]
[08:24:58.176]                   NAME <- NAMES[[kk]]
[08:24:58.176]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.176]                     next
[08:24:58.176]                   args[[name]] <- ""
[08:24:58.176]                 }
[08:24:58.176]                 NAMES <- toupper(removed)
[08:24:58.176]                 for (kk in seq_along(NAMES)) {
[08:24:58.176]                   name <- removed[[kk]]
[08:24:58.176]                   NAME <- NAMES[[kk]]
[08:24:58.176]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.176]                     next
[08:24:58.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.176]                 }
[08:24:58.176]                 if (length(args) > 0) 
[08:24:58.176]                   base::do.call(base::Sys.setenv, args = args)
[08:24:58.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:58.176]             }
[08:24:58.176]             else {
[08:24:58.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:58.176]             }
[08:24:58.176]             {
[08:24:58.176]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:58.176]                   0L) {
[08:24:58.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:58.176]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:58.176]                   base::options(opts)
[08:24:58.176]                 }
[08:24:58.176]                 {
[08:24:58.176]                   {
[08:24:58.176]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:58.176]                     NULL
[08:24:58.176]                   }
[08:24:58.176]                   options(future.plan = NULL)
[08:24:58.176]                   if (is.na(NA_character_)) 
[08:24:58.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:58.176]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:58.176]                     .init = FALSE)
[08:24:58.176]                 }
[08:24:58.176]             }
[08:24:58.176]         }
[08:24:58.176]     })
[08:24:58.176]     if (TRUE) {
[08:24:58.176]         base::sink(type = "output", split = FALSE)
[08:24:58.176]         if (TRUE) {
[08:24:58.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:58.176]         }
[08:24:58.176]         else {
[08:24:58.176]             ...future.result["stdout"] <- base::list(NULL)
[08:24:58.176]         }
[08:24:58.176]         base::close(...future.stdout)
[08:24:58.176]         ...future.stdout <- NULL
[08:24:58.176]     }
[08:24:58.176]     ...future.result$conditions <- ...future.conditions
[08:24:58.176]     ...future.result$finished <- base::Sys.time()
[08:24:58.176]     ...future.result
[08:24:58.176] }
[08:24:58.179] assign_globals() ...
[08:24:58.179] List of 5
[08:24:58.179]  $ ...future.FUN            :function (object, ...)  
[08:24:58.179]  $ future.call.arguments    : list()
[08:24:58.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.179]  $ ...future.elements_ii    :List of 1
[08:24:58.179]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:58.179]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[08:24:58.179]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:58.179]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:58.179]  $ ...future.seeds_ii       : NULL
[08:24:58.179]  $ ...future.globals.maxSize: NULL
[08:24:58.179]  - attr(*, "where")=List of 5
[08:24:58.179]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:58.179]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:58.179]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:58.179]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:58.179]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:58.179]  - attr(*, "resolved")= logi FALSE
[08:24:58.179]  - attr(*, "total_size")= num 18647
[08:24:58.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.179]  - attr(*, "already-done")= logi TRUE
[08:24:58.187] - copied ‘...future.FUN’ to environment
[08:24:58.187] - copied ‘future.call.arguments’ to environment
[08:24:58.187] - copied ‘...future.elements_ii’ to environment
[08:24:58.187] - copied ‘...future.seeds_ii’ to environment
[08:24:58.187] - copied ‘...future.globals.maxSize’ to environment
[08:24:58.187] assign_globals() ... done
[08:24:58.188] requestCore(): workers = 2
[08:24:58.190] MulticoreFuture started
[08:24:58.191] - Launch lazy future ... done
[08:24:58.191] run() for ‘MulticoreFuture’ ... done
[08:24:58.191] Created future:
[08:24:58.191] plan(): Setting new future strategy stack:
[08:24:58.192] List of future strategies:
[08:24:58.192] 1. sequential:
[08:24:58.192]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:58.192]    - tweaked: FALSE
[08:24:58.192]    - call: NULL
[08:24:58.193] plan(): nbrOfWorkers() = 1
[08:24:58.196] plan(): Setting new future strategy stack:
[08:24:58.196] List of future strategies:
[08:24:58.196] 1. multicore:
[08:24:58.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:58.196]    - tweaked: FALSE
[08:24:58.196]    - call: plan(strategy)
[08:24:58.199] plan(): nbrOfWorkers() = 2
[08:24:58.191] MulticoreFuture:
[08:24:58.191] Label: ‘future_by-1’
[08:24:58.191] Expression:
[08:24:58.191] {
[08:24:58.191]     do.call(function(...) {
[08:24:58.191]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.191]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.191]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.191]             on.exit(options(oopts), add = TRUE)
[08:24:58.191]         }
[08:24:58.191]         {
[08:24:58.191]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.191]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.191]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.191]             })
[08:24:58.191]         }
[08:24:58.191]     }, args = future.call.arguments)
[08:24:58.191] }
[08:24:58.191] Lazy evaluation: FALSE
[08:24:58.191] Asynchronous evaluation: TRUE
[08:24:58.191] Local evaluation: TRUE
[08:24:58.191] Environment: 0x557b296fab58
[08:24:58.191] Capture standard output: TRUE
[08:24:58.191] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:58.191] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:58.191] Packages: <none>
[08:24:58.191] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:58.191] Resolved: TRUE
[08:24:58.191] Value: <not collected>
[08:24:58.191] Conditions captured: <none>
[08:24:58.191] Early signaling: FALSE
[08:24:58.191] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:58.191] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.200] Chunk #1 of 2 ... DONE
[08:24:58.200] Chunk #2 of 2 ...
[08:24:58.200]  - Finding globals in 'X' for chunk #2 ...
[08:24:58.201] getGlobalsAndPackages() ...
[08:24:58.201] Searching for globals...
[08:24:58.202] 
[08:24:58.202] Searching for globals ... DONE
[08:24:58.202] - globals: [0] <none>
[08:24:58.202] getGlobalsAndPackages() ... DONE
[08:24:58.202]    + additional globals found: [n=0] 
[08:24:58.202]    + additional namespaces needed: [n=0] 
[08:24:58.202]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:58.202]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:58.203]  - seeds: <none>
[08:24:58.203]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.203] getGlobalsAndPackages() ...
[08:24:58.203] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.203] Resolving globals: FALSE
[08:24:58.203] Tweak future expression to call with '...' arguments ...
[08:24:58.203] {
[08:24:58.203]     do.call(function(...) {
[08:24:58.203]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.203]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.203]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.203]             on.exit(options(oopts), add = TRUE)
[08:24:58.203]         }
[08:24:58.203]         {
[08:24:58.203]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.203]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.203]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.203]             })
[08:24:58.203]         }
[08:24:58.203]     }, args = future.call.arguments)
[08:24:58.203] }
[08:24:58.204] Tweak future expression to call with '...' arguments ... DONE
[08:24:58.204] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.204] 
[08:24:58.205] getGlobalsAndPackages() ... DONE
[08:24:58.205] run() for ‘Future’ ...
[08:24:58.205] - state: ‘created’
[08:24:58.205] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:58.208] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.208] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:58.208]   - Field: ‘label’
[08:24:58.208]   - Field: ‘local’
[08:24:58.208]   - Field: ‘owner’
[08:24:58.208]   - Field: ‘envir’
[08:24:58.209]   - Field: ‘workers’
[08:24:58.209]   - Field: ‘packages’
[08:24:58.209]   - Field: ‘gc’
[08:24:58.209]   - Field: ‘job’
[08:24:58.209]   - Field: ‘conditions’
[08:24:58.209]   - Field: ‘expr’
[08:24:58.209]   - Field: ‘uuid’
[08:24:58.209]   - Field: ‘seed’
[08:24:58.210]   - Field: ‘version’
[08:24:58.210]   - Field: ‘result’
[08:24:58.210]   - Field: ‘asynchronous’
[08:24:58.210]   - Field: ‘calls’
[08:24:58.210]   - Field: ‘globals’
[08:24:58.210]   - Field: ‘stdout’
[08:24:58.210]   - Field: ‘earlySignal’
[08:24:58.210]   - Field: ‘lazy’
[08:24:58.210]   - Field: ‘state’
[08:24:58.211] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:58.211] - Launch lazy future ...
[08:24:58.211] Packages needed by the future expression (n = 0): <none>
[08:24:58.211] Packages needed by future strategies (n = 0): <none>
[08:24:58.212] {
[08:24:58.212]     {
[08:24:58.212]         {
[08:24:58.212]             ...future.startTime <- base::Sys.time()
[08:24:58.212]             {
[08:24:58.212]                 {
[08:24:58.212]                   {
[08:24:58.212]                     {
[08:24:58.212]                       base::local({
[08:24:58.212]                         has_future <- base::requireNamespace("future", 
[08:24:58.212]                           quietly = TRUE)
[08:24:58.212]                         if (has_future) {
[08:24:58.212]                           ns <- base::getNamespace("future")
[08:24:58.212]                           version <- ns[[".package"]][["version"]]
[08:24:58.212]                           if (is.null(version)) 
[08:24:58.212]                             version <- utils::packageVersion("future")
[08:24:58.212]                         }
[08:24:58.212]                         else {
[08:24:58.212]                           version <- NULL
[08:24:58.212]                         }
[08:24:58.212]                         if (!has_future || version < "1.8.0") {
[08:24:58.212]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:58.212]                             "", base::R.version$version.string), 
[08:24:58.212]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:58.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:58.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:58.212]                               "release", "version")], collapse = " "), 
[08:24:58.212]                             hostname = base::Sys.info()[["nodename"]])
[08:24:58.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:58.212]                             info)
[08:24:58.212]                           info <- base::paste(info, collapse = "; ")
[08:24:58.212]                           if (!has_future) {
[08:24:58.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:58.212]                               info)
[08:24:58.212]                           }
[08:24:58.212]                           else {
[08:24:58.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:58.212]                               info, version)
[08:24:58.212]                           }
[08:24:58.212]                           base::stop(msg)
[08:24:58.212]                         }
[08:24:58.212]                       })
[08:24:58.212]                     }
[08:24:58.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:58.212]                     base::options(mc.cores = 1L)
[08:24:58.212]                   }
[08:24:58.212]                   ...future.strategy.old <- future::plan("list")
[08:24:58.212]                   options(future.plan = NULL)
[08:24:58.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:58.212]                 }
[08:24:58.212]                 ...future.workdir <- getwd()
[08:24:58.212]             }
[08:24:58.212]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:58.212]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:58.212]         }
[08:24:58.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:58.212]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:58.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:58.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:58.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:58.212]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:58.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:58.212]             base::names(...future.oldOptions))
[08:24:58.212]     }
[08:24:58.212]     if (FALSE) {
[08:24:58.212]     }
[08:24:58.212]     else {
[08:24:58.212]         if (TRUE) {
[08:24:58.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:58.212]                 open = "w")
[08:24:58.212]         }
[08:24:58.212]         else {
[08:24:58.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:58.212]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:58.212]         }
[08:24:58.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:58.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:58.212]             base::sink(type = "output", split = FALSE)
[08:24:58.212]             base::close(...future.stdout)
[08:24:58.212]         }, add = TRUE)
[08:24:58.212]     }
[08:24:58.212]     ...future.frame <- base::sys.nframe()
[08:24:58.212]     ...future.conditions <- base::list()
[08:24:58.212]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:58.212]     if (FALSE) {
[08:24:58.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:58.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:58.212]     }
[08:24:58.212]     ...future.result <- base::tryCatch({
[08:24:58.212]         base::withCallingHandlers({
[08:24:58.212]             ...future.value <- base::withVisible(base::local({
[08:24:58.212]                 withCallingHandlers({
[08:24:58.212]                   {
[08:24:58.212]                     do.call(function(...) {
[08:24:58.212]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.212]                       if (!identical(...future.globals.maxSize.org, 
[08:24:58.212]                         ...future.globals.maxSize)) {
[08:24:58.212]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.212]                         on.exit(options(oopts), add = TRUE)
[08:24:58.212]                       }
[08:24:58.212]                       {
[08:24:58.212]                         lapply(seq_along(...future.elements_ii), 
[08:24:58.212]                           FUN = function(jj) {
[08:24:58.212]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.212]                             ...future.FUN(...future.X_jj, ...)
[08:24:58.212]                           })
[08:24:58.212]                       }
[08:24:58.212]                     }, args = future.call.arguments)
[08:24:58.212]                   }
[08:24:58.212]                 }, immediateCondition = function(cond) {
[08:24:58.212]                   save_rds <- function (object, pathname, ...) 
[08:24:58.212]                   {
[08:24:58.212]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:58.212]                     if (file_test("-f", pathname_tmp)) {
[08:24:58.212]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.212]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:58.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.212]                         fi_tmp[["mtime"]])
[08:24:58.212]                     }
[08:24:58.212]                     tryCatch({
[08:24:58.212]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:58.212]                     }, error = function(ex) {
[08:24:58.212]                       msg <- conditionMessage(ex)
[08:24:58.212]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.212]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:58.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.212]                         fi_tmp[["mtime"]], msg)
[08:24:58.212]                       ex$message <- msg
[08:24:58.212]                       stop(ex)
[08:24:58.212]                     })
[08:24:58.212]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:58.212]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:58.212]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:58.212]                       fi_tmp <- file.info(pathname_tmp)
[08:24:58.212]                       fi <- file.info(pathname)
[08:24:58.212]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:58.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:58.212]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:58.212]                         fi[["size"]], fi[["mtime"]])
[08:24:58.212]                       stop(msg)
[08:24:58.212]                     }
[08:24:58.212]                     invisible(pathname)
[08:24:58.212]                   }
[08:24:58.212]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:58.212]                     rootPath = tempdir()) 
[08:24:58.212]                   {
[08:24:58.212]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:58.212]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:58.212]                       tmpdir = path, fileext = ".rds")
[08:24:58.212]                     save_rds(obj, file)
[08:24:58.212]                   }
[08:24:58.212]                   saveImmediateCondition(cond, path = "/tmp/Rtmptgt6kx/.future/immediateConditions")
[08:24:58.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.212]                   {
[08:24:58.212]                     inherits <- base::inherits
[08:24:58.212]                     invokeRestart <- base::invokeRestart
[08:24:58.212]                     is.null <- base::is.null
[08:24:58.212]                     muffled <- FALSE
[08:24:58.212]                     if (inherits(cond, "message")) {
[08:24:58.212]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:58.212]                       if (muffled) 
[08:24:58.212]                         invokeRestart("muffleMessage")
[08:24:58.212]                     }
[08:24:58.212]                     else if (inherits(cond, "warning")) {
[08:24:58.212]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:58.212]                       if (muffled) 
[08:24:58.212]                         invokeRestart("muffleWarning")
[08:24:58.212]                     }
[08:24:58.212]                     else if (inherits(cond, "condition")) {
[08:24:58.212]                       if (!is.null(pattern)) {
[08:24:58.212]                         computeRestarts <- base::computeRestarts
[08:24:58.212]                         grepl <- base::grepl
[08:24:58.212]                         restarts <- computeRestarts(cond)
[08:24:58.212]                         for (restart in restarts) {
[08:24:58.212]                           name <- restart$name
[08:24:58.212]                           if (is.null(name)) 
[08:24:58.212]                             next
[08:24:58.212]                           if (!grepl(pattern, name)) 
[08:24:58.212]                             next
[08:24:58.212]                           invokeRestart(restart)
[08:24:58.212]                           muffled <- TRUE
[08:24:58.212]                           break
[08:24:58.212]                         }
[08:24:58.212]                       }
[08:24:58.212]                     }
[08:24:58.212]                     invisible(muffled)
[08:24:58.212]                   }
[08:24:58.212]                   muffleCondition(cond)
[08:24:58.212]                 })
[08:24:58.212]             }))
[08:24:58.212]             future::FutureResult(value = ...future.value$value, 
[08:24:58.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.212]                   ...future.rng), globalenv = if (FALSE) 
[08:24:58.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:58.212]                     ...future.globalenv.names))
[08:24:58.212]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:58.212]         }, condition = base::local({
[08:24:58.212]             c <- base::c
[08:24:58.212]             inherits <- base::inherits
[08:24:58.212]             invokeRestart <- base::invokeRestart
[08:24:58.212]             length <- base::length
[08:24:58.212]             list <- base::list
[08:24:58.212]             seq.int <- base::seq.int
[08:24:58.212]             signalCondition <- base::signalCondition
[08:24:58.212]             sys.calls <- base::sys.calls
[08:24:58.212]             `[[` <- base::`[[`
[08:24:58.212]             `+` <- base::`+`
[08:24:58.212]             `<<-` <- base::`<<-`
[08:24:58.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:58.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:58.212]                   3L)]
[08:24:58.212]             }
[08:24:58.212]             function(cond) {
[08:24:58.212]                 is_error <- inherits(cond, "error")
[08:24:58.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:58.212]                   NULL)
[08:24:58.212]                 if (is_error) {
[08:24:58.212]                   sessionInformation <- function() {
[08:24:58.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:58.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:58.212]                       search = base::search(), system = base::Sys.info())
[08:24:58.212]                   }
[08:24:58.212]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:58.212]                     cond$call), session = sessionInformation(), 
[08:24:58.212]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:58.212]                   signalCondition(cond)
[08:24:58.212]                 }
[08:24:58.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:58.212]                 "immediateCondition"))) {
[08:24:58.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:58.212]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:58.212]                   if (TRUE && !signal) {
[08:24:58.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.212]                     {
[08:24:58.212]                       inherits <- base::inherits
[08:24:58.212]                       invokeRestart <- base::invokeRestart
[08:24:58.212]                       is.null <- base::is.null
[08:24:58.212]                       muffled <- FALSE
[08:24:58.212]                       if (inherits(cond, "message")) {
[08:24:58.212]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.212]                         if (muffled) 
[08:24:58.212]                           invokeRestart("muffleMessage")
[08:24:58.212]                       }
[08:24:58.212]                       else if (inherits(cond, "warning")) {
[08:24:58.212]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.212]                         if (muffled) 
[08:24:58.212]                           invokeRestart("muffleWarning")
[08:24:58.212]                       }
[08:24:58.212]                       else if (inherits(cond, "condition")) {
[08:24:58.212]                         if (!is.null(pattern)) {
[08:24:58.212]                           computeRestarts <- base::computeRestarts
[08:24:58.212]                           grepl <- base::grepl
[08:24:58.212]                           restarts <- computeRestarts(cond)
[08:24:58.212]                           for (restart in restarts) {
[08:24:58.212]                             name <- restart$name
[08:24:58.212]                             if (is.null(name)) 
[08:24:58.212]                               next
[08:24:58.212]                             if (!grepl(pattern, name)) 
[08:24:58.212]                               next
[08:24:58.212]                             invokeRestart(restart)
[08:24:58.212]                             muffled <- TRUE
[08:24:58.212]                             break
[08:24:58.212]                           }
[08:24:58.212]                         }
[08:24:58.212]                       }
[08:24:58.212]                       invisible(muffled)
[08:24:58.212]                     }
[08:24:58.212]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.212]                   }
[08:24:58.212]                 }
[08:24:58.212]                 else {
[08:24:58.212]                   if (TRUE) {
[08:24:58.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.212]                     {
[08:24:58.212]                       inherits <- base::inherits
[08:24:58.212]                       invokeRestart <- base::invokeRestart
[08:24:58.212]                       is.null <- base::is.null
[08:24:58.212]                       muffled <- FALSE
[08:24:58.212]                       if (inherits(cond, "message")) {
[08:24:58.212]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.212]                         if (muffled) 
[08:24:58.212]                           invokeRestart("muffleMessage")
[08:24:58.212]                       }
[08:24:58.212]                       else if (inherits(cond, "warning")) {
[08:24:58.212]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.212]                         if (muffled) 
[08:24:58.212]                           invokeRestart("muffleWarning")
[08:24:58.212]                       }
[08:24:58.212]                       else if (inherits(cond, "condition")) {
[08:24:58.212]                         if (!is.null(pattern)) {
[08:24:58.212]                           computeRestarts <- base::computeRestarts
[08:24:58.212]                           grepl <- base::grepl
[08:24:58.212]                           restarts <- computeRestarts(cond)
[08:24:58.212]                           for (restart in restarts) {
[08:24:58.212]                             name <- restart$name
[08:24:58.212]                             if (is.null(name)) 
[08:24:58.212]                               next
[08:24:58.212]                             if (!grepl(pattern, name)) 
[08:24:58.212]                               next
[08:24:58.212]                             invokeRestart(restart)
[08:24:58.212]                             muffled <- TRUE
[08:24:58.212]                             break
[08:24:58.212]                           }
[08:24:58.212]                         }
[08:24:58.212]                       }
[08:24:58.212]                       invisible(muffled)
[08:24:58.212]                     }
[08:24:58.212]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.212]                   }
[08:24:58.212]                 }
[08:24:58.212]             }
[08:24:58.212]         }))
[08:24:58.212]     }, error = function(ex) {
[08:24:58.212]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:58.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.212]                 ...future.rng), started = ...future.startTime, 
[08:24:58.212]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:58.212]             version = "1.8"), class = "FutureResult")
[08:24:58.212]     }, finally = {
[08:24:58.212]         if (!identical(...future.workdir, getwd())) 
[08:24:58.212]             setwd(...future.workdir)
[08:24:58.212]         {
[08:24:58.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:58.212]                 ...future.oldOptions$nwarnings <- NULL
[08:24:58.212]             }
[08:24:58.212]             base::options(...future.oldOptions)
[08:24:58.212]             if (.Platform$OS.type == "windows") {
[08:24:58.212]                 old_names <- names(...future.oldEnvVars)
[08:24:58.212]                 envs <- base::Sys.getenv()
[08:24:58.212]                 names <- names(envs)
[08:24:58.212]                 common <- intersect(names, old_names)
[08:24:58.212]                 added <- setdiff(names, old_names)
[08:24:58.212]                 removed <- setdiff(old_names, names)
[08:24:58.212]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:58.212]                   envs[common]]
[08:24:58.212]                 NAMES <- toupper(changed)
[08:24:58.212]                 args <- list()
[08:24:58.212]                 for (kk in seq_along(NAMES)) {
[08:24:58.212]                   name <- changed[[kk]]
[08:24:58.212]                   NAME <- NAMES[[kk]]
[08:24:58.212]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.212]                     next
[08:24:58.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.212]                 }
[08:24:58.212]                 NAMES <- toupper(added)
[08:24:58.212]                 for (kk in seq_along(NAMES)) {
[08:24:58.212]                   name <- added[[kk]]
[08:24:58.212]                   NAME <- NAMES[[kk]]
[08:24:58.212]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.212]                     next
[08:24:58.212]                   args[[name]] <- ""
[08:24:58.212]                 }
[08:24:58.212]                 NAMES <- toupper(removed)
[08:24:58.212]                 for (kk in seq_along(NAMES)) {
[08:24:58.212]                   name <- removed[[kk]]
[08:24:58.212]                   NAME <- NAMES[[kk]]
[08:24:58.212]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.212]                     next
[08:24:58.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.212]                 }
[08:24:58.212]                 if (length(args) > 0) 
[08:24:58.212]                   base::do.call(base::Sys.setenv, args = args)
[08:24:58.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:58.212]             }
[08:24:58.212]             else {
[08:24:58.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:58.212]             }
[08:24:58.212]             {
[08:24:58.212]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:58.212]                   0L) {
[08:24:58.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:58.212]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:58.212]                   base::options(opts)
[08:24:58.212]                 }
[08:24:58.212]                 {
[08:24:58.212]                   {
[08:24:58.212]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:58.212]                     NULL
[08:24:58.212]                   }
[08:24:58.212]                   options(future.plan = NULL)
[08:24:58.212]                   if (is.na(NA_character_)) 
[08:24:58.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:58.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:58.212]                     .init = FALSE)
[08:24:58.212]                 }
[08:24:58.212]             }
[08:24:58.212]         }
[08:24:58.212]     })
[08:24:58.212]     if (TRUE) {
[08:24:58.212]         base::sink(type = "output", split = FALSE)
[08:24:58.212]         if (TRUE) {
[08:24:58.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:58.212]         }
[08:24:58.212]         else {
[08:24:58.212]             ...future.result["stdout"] <- base::list(NULL)
[08:24:58.212]         }
[08:24:58.212]         base::close(...future.stdout)
[08:24:58.212]         ...future.stdout <- NULL
[08:24:58.212]     }
[08:24:58.212]     ...future.result$conditions <- ...future.conditions
[08:24:58.212]     ...future.result$finished <- base::Sys.time()
[08:24:58.212]     ...future.result
[08:24:58.212] }
[08:24:58.215] assign_globals() ...
[08:24:58.215] List of 5
[08:24:58.215]  $ ...future.FUN            :function (object, ...)  
[08:24:58.215]  $ future.call.arguments    : list()
[08:24:58.215]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.215]  $ ...future.elements_ii    :List of 2
[08:24:58.215]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:58.215]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[08:24:58.215]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:58.215]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[08:24:58.215]   ..$ :'data.frame':	18 obs. of  3 variables:
[08:24:58.215]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[08:24:58.215]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[08:24:58.215]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[08:24:58.215]  $ ...future.seeds_ii       : NULL
[08:24:58.215]  $ ...future.globals.maxSize: NULL
[08:24:58.215]  - attr(*, "where")=List of 5
[08:24:58.215]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:58.215]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:58.215]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:58.215]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:58.215]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:58.215]  - attr(*, "resolved")= logi FALSE
[08:24:58.215]  - attr(*, "total_size")= num 18647
[08:24:58.215]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.215]  - attr(*, "already-done")= logi TRUE
[08:24:58.231] - copied ‘...future.FUN’ to environment
[08:24:58.231] - copied ‘future.call.arguments’ to environment
[08:24:58.231] - copied ‘...future.elements_ii’ to environment
[08:24:58.231] - copied ‘...future.seeds_ii’ to environment
[08:24:58.231] - copied ‘...future.globals.maxSize’ to environment
[08:24:58.231] assign_globals() ... done
[08:24:58.232] requestCore(): workers = 2
[08:24:58.234] MulticoreFuture started
[08:24:58.235] - Launch lazy future ... done
[08:24:58.235] run() for ‘MulticoreFuture’ ... done
[08:24:58.235] Created future:
[08:24:58.236] plan(): Setting new future strategy stack:
[08:24:58.236] List of future strategies:
[08:24:58.236] 1. sequential:
[08:24:58.236]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:58.236]    - tweaked: FALSE
[08:24:58.236]    - call: NULL
[08:24:58.237] plan(): nbrOfWorkers() = 1
[08:24:58.241] plan(): Setting new future strategy stack:
[08:24:58.241] List of future strategies:
[08:24:58.241] 1. multicore:
[08:24:58.241]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:58.241]    - tweaked: FALSE
[08:24:58.241]    - call: plan(strategy)
[08:24:58.244] plan(): nbrOfWorkers() = 2
[08:24:58.235] MulticoreFuture:
[08:24:58.235] Label: ‘future_by-2’
[08:24:58.235] Expression:
[08:24:58.235] {
[08:24:58.235]     do.call(function(...) {
[08:24:58.235]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.235]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.235]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.235]             on.exit(options(oopts), add = TRUE)
[08:24:58.235]         }
[08:24:58.235]         {
[08:24:58.235]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.235]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.235]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.235]             })
[08:24:58.235]         }
[08:24:58.235]     }, args = future.call.arguments)
[08:24:58.235] }
[08:24:58.235] Lazy evaluation: FALSE
[08:24:58.235] Asynchronous evaluation: TRUE
[08:24:58.235] Local evaluation: TRUE
[08:24:58.235] Environment: 0x557b296fab58
[08:24:58.235] Capture standard output: TRUE
[08:24:58.235] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:58.235] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:58.235] Packages: <none>
[08:24:58.235] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:58.235] Resolved: TRUE
[08:24:58.235] Value: <not collected>
[08:24:58.235] Conditions captured: <none>
[08:24:58.235] Early signaling: FALSE
[08:24:58.235] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:58.235] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.245] Chunk #2 of 2 ... DONE
[08:24:58.246] Launching 2 futures (chunks) ... DONE
[08:24:58.246] Resolving 2 futures (chunks) ...
[08:24:58.246] resolve() on list ...
[08:24:58.246]  recursive: 0
[08:24:58.246]  length: 2
[08:24:58.246] 
[08:24:58.247] Future #1
[08:24:58.247] result() for MulticoreFuture ...
[08:24:58.248] result() for MulticoreFuture ...
[08:24:58.248] result() for MulticoreFuture ... done
[08:24:58.248] result() for MulticoreFuture ... done
[08:24:58.248] result() for MulticoreFuture ...
[08:24:58.248] result() for MulticoreFuture ... done
[08:24:58.249] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:58.249] - nx: 2
[08:24:58.249] - relay: TRUE
[08:24:58.249] - stdout: TRUE
[08:24:58.249] - signal: TRUE
[08:24:58.249] - resignal: FALSE
[08:24:58.249] - force: TRUE
[08:24:58.249] - relayed: [n=2] FALSE, FALSE
[08:24:58.250] - queued futures: [n=2] FALSE, FALSE
[08:24:58.250]  - until=1
[08:24:58.250]  - relaying element #1
[08:24:58.250] result() for MulticoreFuture ...
[08:24:58.250] result() for MulticoreFuture ... done
[08:24:58.250] result() for MulticoreFuture ...
[08:24:58.250] result() for MulticoreFuture ... done
[08:24:58.251] result() for MulticoreFuture ...
[08:24:58.251] result() for MulticoreFuture ... done
[08:24:58.251] result() for MulticoreFuture ...
[08:24:58.251] result() for MulticoreFuture ... done
[08:24:58.251] - relayed: [n=2] TRUE, FALSE
[08:24:58.251] - queued futures: [n=2] TRUE, FALSE
[08:24:58.251] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:58.251]  length: 1 (resolved future 1)
[08:24:58.252] Future #2
[08:24:58.252] result() for MulticoreFuture ...
[08:24:58.253] result() for MulticoreFuture ...
[08:24:58.253] result() for MulticoreFuture ... done
[08:24:58.253] result() for MulticoreFuture ... done
[08:24:58.253] result() for MulticoreFuture ...
[08:24:58.253] result() for MulticoreFuture ... done
[08:24:58.253] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:58.254] - nx: 2
[08:24:58.254] - relay: TRUE
[08:24:58.254] - stdout: TRUE
[08:24:58.254] - signal: TRUE
[08:24:58.254] - resignal: FALSE
[08:24:58.254] - force: TRUE
[08:24:58.254] - relayed: [n=2] TRUE, FALSE
[08:24:58.254] - queued futures: [n=2] TRUE, FALSE
[08:24:58.254]  - until=2
[08:24:58.255]  - relaying element #2
[08:24:58.255] result() for MulticoreFuture ...
[08:24:58.255] result() for MulticoreFuture ... done
[08:24:58.255] result() for MulticoreFuture ...
[08:24:58.255] result() for MulticoreFuture ... done
[08:24:58.255] result() for MulticoreFuture ...
[08:24:58.255] result() for MulticoreFuture ... done
[08:24:58.255] result() for MulticoreFuture ...
[08:24:58.256] result() for MulticoreFuture ... done
[08:24:58.256] - relayed: [n=2] TRUE, TRUE
[08:24:58.256] - queued futures: [n=2] TRUE, TRUE
[08:24:58.256] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:58.256]  length: 0 (resolved future 2)
[08:24:58.256] Relaying remaining futures
[08:24:58.256] signalConditionsASAP(NULL, pos=0) ...
[08:24:58.256] - nx: 2
[08:24:58.256] - relay: TRUE
[08:24:58.257] - stdout: TRUE
[08:24:58.257] - signal: TRUE
[08:24:58.257] - resignal: FALSE
[08:24:58.257] - force: TRUE
[08:24:58.257] - relayed: [n=2] TRUE, TRUE
[08:24:58.257] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:58.257] - relayed: [n=2] TRUE, TRUE
[08:24:58.257] - queued futures: [n=2] TRUE, TRUE
[08:24:58.257] signalConditionsASAP(NULL, pos=0) ... done
[08:24:58.258] resolve() on list ... DONE
[08:24:58.258] result() for MulticoreFuture ...
[08:24:58.258] result() for MulticoreFuture ... done
[08:24:58.258] result() for MulticoreFuture ...
[08:24:58.258] result() for MulticoreFuture ... done
[08:24:58.258] result() for MulticoreFuture ...
[08:24:58.258] result() for MulticoreFuture ... done
[08:24:58.258] result() for MulticoreFuture ...
[08:24:58.259] result() for MulticoreFuture ... done
[08:24:58.259]  - Number of value chunks collected: 2
[08:24:58.259] Resolving 2 futures (chunks) ... DONE
[08:24:58.259] Reducing values from 2 chunks ...
[08:24:58.259]  - Number of values collected after concatenation: 3
[08:24:58.259]  - Number of values expected: 3
[08:24:58.259] Reducing values from 2 chunks ... DONE
[08:24:58.259] future_lapply() ... DONE
[08:24:58.259] future_by_internal() ... DONE
[08:24:58.261] future_by_internal() ...
- plan('multisession') ...
[08:24:58.261] plan(): Setting new future strategy stack:
[08:24:58.262] List of future strategies:
[08:24:58.262] 1. multisession:
[08:24:58.262]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:58.262]    - tweaked: FALSE
[08:24:58.262]    - call: plan(strategy)
[08:24:58.262] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:24:58.262] multisession:
[08:24:58.262] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:58.262] - tweaked: FALSE
[08:24:58.262] - call: plan(strategy)
[08:24:58.267] getGlobalsAndPackages() ...
[08:24:58.267] Not searching for globals
[08:24:58.267] - globals: [0] <none>
[08:24:58.268] getGlobalsAndPackages() ... DONE
[08:24:58.763] Packages needed by the future expression (n = 0): <none>
[08:24:58.763] Packages needed by future strategies (n = 0): <none>
[08:24:58.763] {
[08:24:58.763]     {
[08:24:58.763]         {
[08:24:58.763]             ...future.startTime <- base::Sys.time()
[08:24:58.763]             {
[08:24:58.763]                 {
[08:24:58.763]                   {
[08:24:58.763]                     {
[08:24:58.763]                       base::local({
[08:24:58.763]                         has_future <- base::requireNamespace("future", 
[08:24:58.763]                           quietly = TRUE)
[08:24:58.763]                         if (has_future) {
[08:24:58.763]                           ns <- base::getNamespace("future")
[08:24:58.763]                           version <- ns[[".package"]][["version"]]
[08:24:58.763]                           if (is.null(version)) 
[08:24:58.763]                             version <- utils::packageVersion("future")
[08:24:58.763]                         }
[08:24:58.763]                         else {
[08:24:58.763]                           version <- NULL
[08:24:58.763]                         }
[08:24:58.763]                         if (!has_future || version < "1.8.0") {
[08:24:58.763]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:58.763]                             "", base::R.version$version.string), 
[08:24:58.763]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:58.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:58.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:58.763]                               "release", "version")], collapse = " "), 
[08:24:58.763]                             hostname = base::Sys.info()[["nodename"]])
[08:24:58.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:58.763]                             info)
[08:24:58.763]                           info <- base::paste(info, collapse = "; ")
[08:24:58.763]                           if (!has_future) {
[08:24:58.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:58.763]                               info)
[08:24:58.763]                           }
[08:24:58.763]                           else {
[08:24:58.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:58.763]                               info, version)
[08:24:58.763]                           }
[08:24:58.763]                           base::stop(msg)
[08:24:58.763]                         }
[08:24:58.763]                       })
[08:24:58.763]                     }
[08:24:58.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:58.763]                     base::options(mc.cores = 1L)
[08:24:58.763]                   }
[08:24:58.763]                   ...future.strategy.old <- future::plan("list")
[08:24:58.763]                   options(future.plan = NULL)
[08:24:58.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:58.763]                 }
[08:24:58.763]                 ...future.workdir <- getwd()
[08:24:58.763]             }
[08:24:58.763]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:58.763]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:58.763]         }
[08:24:58.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:58.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:58.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:58.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:58.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:58.763]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:58.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:58.763]             base::names(...future.oldOptions))
[08:24:58.763]     }
[08:24:58.763]     if (FALSE) {
[08:24:58.763]     }
[08:24:58.763]     else {
[08:24:58.763]         if (TRUE) {
[08:24:58.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:58.763]                 open = "w")
[08:24:58.763]         }
[08:24:58.763]         else {
[08:24:58.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:58.763]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:58.763]         }
[08:24:58.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:58.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:58.763]             base::sink(type = "output", split = FALSE)
[08:24:58.763]             base::close(...future.stdout)
[08:24:58.763]         }, add = TRUE)
[08:24:58.763]     }
[08:24:58.763]     ...future.frame <- base::sys.nframe()
[08:24:58.763]     ...future.conditions <- base::list()
[08:24:58.763]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:58.763]     if (FALSE) {
[08:24:58.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:58.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:58.763]     }
[08:24:58.763]     ...future.result <- base::tryCatch({
[08:24:58.763]         base::withCallingHandlers({
[08:24:58.763]             ...future.value <- base::withVisible(base::local({
[08:24:58.763]                 ...future.makeSendCondition <- base::local({
[08:24:58.763]                   sendCondition <- NULL
[08:24:58.763]                   function(frame = 1L) {
[08:24:58.763]                     if (is.function(sendCondition)) 
[08:24:58.763]                       return(sendCondition)
[08:24:58.763]                     ns <- getNamespace("parallel")
[08:24:58.763]                     if (exists("sendData", mode = "function", 
[08:24:58.763]                       envir = ns)) {
[08:24:58.763]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:58.763]                         envir = ns)
[08:24:58.763]                       envir <- sys.frame(frame)
[08:24:58.763]                       master <- NULL
[08:24:58.763]                       while (!identical(envir, .GlobalEnv) && 
[08:24:58.763]                         !identical(envir, emptyenv())) {
[08:24:58.763]                         if (exists("master", mode = "list", envir = envir, 
[08:24:58.763]                           inherits = FALSE)) {
[08:24:58.763]                           master <- get("master", mode = "list", 
[08:24:58.763]                             envir = envir, inherits = FALSE)
[08:24:58.763]                           if (inherits(master, c("SOCKnode", 
[08:24:58.763]                             "SOCK0node"))) {
[08:24:58.763]                             sendCondition <<- function(cond) {
[08:24:58.763]                               data <- list(type = "VALUE", value = cond, 
[08:24:58.763]                                 success = TRUE)
[08:24:58.763]                               parallel_sendData(master, data)
[08:24:58.763]                             }
[08:24:58.763]                             return(sendCondition)
[08:24:58.763]                           }
[08:24:58.763]                         }
[08:24:58.763]                         frame <- frame + 1L
[08:24:58.763]                         envir <- sys.frame(frame)
[08:24:58.763]                       }
[08:24:58.763]                     }
[08:24:58.763]                     sendCondition <<- function(cond) NULL
[08:24:58.763]                   }
[08:24:58.763]                 })
[08:24:58.763]                 withCallingHandlers({
[08:24:58.763]                   NA
[08:24:58.763]                 }, immediateCondition = function(cond) {
[08:24:58.763]                   sendCondition <- ...future.makeSendCondition()
[08:24:58.763]                   sendCondition(cond)
[08:24:58.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.763]                   {
[08:24:58.763]                     inherits <- base::inherits
[08:24:58.763]                     invokeRestart <- base::invokeRestart
[08:24:58.763]                     is.null <- base::is.null
[08:24:58.763]                     muffled <- FALSE
[08:24:58.763]                     if (inherits(cond, "message")) {
[08:24:58.763]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:58.763]                       if (muffled) 
[08:24:58.763]                         invokeRestart("muffleMessage")
[08:24:58.763]                     }
[08:24:58.763]                     else if (inherits(cond, "warning")) {
[08:24:58.763]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:58.763]                       if (muffled) 
[08:24:58.763]                         invokeRestart("muffleWarning")
[08:24:58.763]                     }
[08:24:58.763]                     else if (inherits(cond, "condition")) {
[08:24:58.763]                       if (!is.null(pattern)) {
[08:24:58.763]                         computeRestarts <- base::computeRestarts
[08:24:58.763]                         grepl <- base::grepl
[08:24:58.763]                         restarts <- computeRestarts(cond)
[08:24:58.763]                         for (restart in restarts) {
[08:24:58.763]                           name <- restart$name
[08:24:58.763]                           if (is.null(name)) 
[08:24:58.763]                             next
[08:24:58.763]                           if (!grepl(pattern, name)) 
[08:24:58.763]                             next
[08:24:58.763]                           invokeRestart(restart)
[08:24:58.763]                           muffled <- TRUE
[08:24:58.763]                           break
[08:24:58.763]                         }
[08:24:58.763]                       }
[08:24:58.763]                     }
[08:24:58.763]                     invisible(muffled)
[08:24:58.763]                   }
[08:24:58.763]                   muffleCondition(cond)
[08:24:58.763]                 })
[08:24:58.763]             }))
[08:24:58.763]             future::FutureResult(value = ...future.value$value, 
[08:24:58.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.763]                   ...future.rng), globalenv = if (FALSE) 
[08:24:58.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:58.763]                     ...future.globalenv.names))
[08:24:58.763]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:58.763]         }, condition = base::local({
[08:24:58.763]             c <- base::c
[08:24:58.763]             inherits <- base::inherits
[08:24:58.763]             invokeRestart <- base::invokeRestart
[08:24:58.763]             length <- base::length
[08:24:58.763]             list <- base::list
[08:24:58.763]             seq.int <- base::seq.int
[08:24:58.763]             signalCondition <- base::signalCondition
[08:24:58.763]             sys.calls <- base::sys.calls
[08:24:58.763]             `[[` <- base::`[[`
[08:24:58.763]             `+` <- base::`+`
[08:24:58.763]             `<<-` <- base::`<<-`
[08:24:58.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:58.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:58.763]                   3L)]
[08:24:58.763]             }
[08:24:58.763]             function(cond) {
[08:24:58.763]                 is_error <- inherits(cond, "error")
[08:24:58.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:58.763]                   NULL)
[08:24:58.763]                 if (is_error) {
[08:24:58.763]                   sessionInformation <- function() {
[08:24:58.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:58.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:58.763]                       search = base::search(), system = base::Sys.info())
[08:24:58.763]                   }
[08:24:58.763]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:58.763]                     cond$call), session = sessionInformation(), 
[08:24:58.763]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:58.763]                   signalCondition(cond)
[08:24:58.763]                 }
[08:24:58.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:58.763]                 "immediateCondition"))) {
[08:24:58.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:58.763]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:58.763]                   if (TRUE && !signal) {
[08:24:58.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.763]                     {
[08:24:58.763]                       inherits <- base::inherits
[08:24:58.763]                       invokeRestart <- base::invokeRestart
[08:24:58.763]                       is.null <- base::is.null
[08:24:58.763]                       muffled <- FALSE
[08:24:58.763]                       if (inherits(cond, "message")) {
[08:24:58.763]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.763]                         if (muffled) 
[08:24:58.763]                           invokeRestart("muffleMessage")
[08:24:58.763]                       }
[08:24:58.763]                       else if (inherits(cond, "warning")) {
[08:24:58.763]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.763]                         if (muffled) 
[08:24:58.763]                           invokeRestart("muffleWarning")
[08:24:58.763]                       }
[08:24:58.763]                       else if (inherits(cond, "condition")) {
[08:24:58.763]                         if (!is.null(pattern)) {
[08:24:58.763]                           computeRestarts <- base::computeRestarts
[08:24:58.763]                           grepl <- base::grepl
[08:24:58.763]                           restarts <- computeRestarts(cond)
[08:24:58.763]                           for (restart in restarts) {
[08:24:58.763]                             name <- restart$name
[08:24:58.763]                             if (is.null(name)) 
[08:24:58.763]                               next
[08:24:58.763]                             if (!grepl(pattern, name)) 
[08:24:58.763]                               next
[08:24:58.763]                             invokeRestart(restart)
[08:24:58.763]                             muffled <- TRUE
[08:24:58.763]                             break
[08:24:58.763]                           }
[08:24:58.763]                         }
[08:24:58.763]                       }
[08:24:58.763]                       invisible(muffled)
[08:24:58.763]                     }
[08:24:58.763]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.763]                   }
[08:24:58.763]                 }
[08:24:58.763]                 else {
[08:24:58.763]                   if (TRUE) {
[08:24:58.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.763]                     {
[08:24:58.763]                       inherits <- base::inherits
[08:24:58.763]                       invokeRestart <- base::invokeRestart
[08:24:58.763]                       is.null <- base::is.null
[08:24:58.763]                       muffled <- FALSE
[08:24:58.763]                       if (inherits(cond, "message")) {
[08:24:58.763]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.763]                         if (muffled) 
[08:24:58.763]                           invokeRestart("muffleMessage")
[08:24:58.763]                       }
[08:24:58.763]                       else if (inherits(cond, "warning")) {
[08:24:58.763]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.763]                         if (muffled) 
[08:24:58.763]                           invokeRestart("muffleWarning")
[08:24:58.763]                       }
[08:24:58.763]                       else if (inherits(cond, "condition")) {
[08:24:58.763]                         if (!is.null(pattern)) {
[08:24:58.763]                           computeRestarts <- base::computeRestarts
[08:24:58.763]                           grepl <- base::grepl
[08:24:58.763]                           restarts <- computeRestarts(cond)
[08:24:58.763]                           for (restart in restarts) {
[08:24:58.763]                             name <- restart$name
[08:24:58.763]                             if (is.null(name)) 
[08:24:58.763]                               next
[08:24:58.763]                             if (!grepl(pattern, name)) 
[08:24:58.763]                               next
[08:24:58.763]                             invokeRestart(restart)
[08:24:58.763]                             muffled <- TRUE
[08:24:58.763]                             break
[08:24:58.763]                           }
[08:24:58.763]                         }
[08:24:58.763]                       }
[08:24:58.763]                       invisible(muffled)
[08:24:58.763]                     }
[08:24:58.763]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.763]                   }
[08:24:58.763]                 }
[08:24:58.763]             }
[08:24:58.763]         }))
[08:24:58.763]     }, error = function(ex) {
[08:24:58.763]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:58.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.763]                 ...future.rng), started = ...future.startTime, 
[08:24:58.763]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:58.763]             version = "1.8"), class = "FutureResult")
[08:24:58.763]     }, finally = {
[08:24:58.763]         if (!identical(...future.workdir, getwd())) 
[08:24:58.763]             setwd(...future.workdir)
[08:24:58.763]         {
[08:24:58.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:58.763]                 ...future.oldOptions$nwarnings <- NULL
[08:24:58.763]             }
[08:24:58.763]             base::options(...future.oldOptions)
[08:24:58.763]             if (.Platform$OS.type == "windows") {
[08:24:58.763]                 old_names <- names(...future.oldEnvVars)
[08:24:58.763]                 envs <- base::Sys.getenv()
[08:24:58.763]                 names <- names(envs)
[08:24:58.763]                 common <- intersect(names, old_names)
[08:24:58.763]                 added <- setdiff(names, old_names)
[08:24:58.763]                 removed <- setdiff(old_names, names)
[08:24:58.763]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:58.763]                   envs[common]]
[08:24:58.763]                 NAMES <- toupper(changed)
[08:24:58.763]                 args <- list()
[08:24:58.763]                 for (kk in seq_along(NAMES)) {
[08:24:58.763]                   name <- changed[[kk]]
[08:24:58.763]                   NAME <- NAMES[[kk]]
[08:24:58.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.763]                     next
[08:24:58.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.763]                 }
[08:24:58.763]                 NAMES <- toupper(added)
[08:24:58.763]                 for (kk in seq_along(NAMES)) {
[08:24:58.763]                   name <- added[[kk]]
[08:24:58.763]                   NAME <- NAMES[[kk]]
[08:24:58.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.763]                     next
[08:24:58.763]                   args[[name]] <- ""
[08:24:58.763]                 }
[08:24:58.763]                 NAMES <- toupper(removed)
[08:24:58.763]                 for (kk in seq_along(NAMES)) {
[08:24:58.763]                   name <- removed[[kk]]
[08:24:58.763]                   NAME <- NAMES[[kk]]
[08:24:58.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.763]                     next
[08:24:58.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.763]                 }
[08:24:58.763]                 if (length(args) > 0) 
[08:24:58.763]                   base::do.call(base::Sys.setenv, args = args)
[08:24:58.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:58.763]             }
[08:24:58.763]             else {
[08:24:58.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:58.763]             }
[08:24:58.763]             {
[08:24:58.763]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:58.763]                   0L) {
[08:24:58.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:58.763]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:58.763]                   base::options(opts)
[08:24:58.763]                 }
[08:24:58.763]                 {
[08:24:58.763]                   {
[08:24:58.763]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:58.763]                     NULL
[08:24:58.763]                   }
[08:24:58.763]                   options(future.plan = NULL)
[08:24:58.763]                   if (is.na(NA_character_)) 
[08:24:58.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:58.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:58.763]                     .init = FALSE)
[08:24:58.763]                 }
[08:24:58.763]             }
[08:24:58.763]         }
[08:24:58.763]     })
[08:24:58.763]     if (TRUE) {
[08:24:58.763]         base::sink(type = "output", split = FALSE)
[08:24:58.763]         if (TRUE) {
[08:24:58.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:58.763]         }
[08:24:58.763]         else {
[08:24:58.763]             ...future.result["stdout"] <- base::list(NULL)
[08:24:58.763]         }
[08:24:58.763]         base::close(...future.stdout)
[08:24:58.763]         ...future.stdout <- NULL
[08:24:58.763]     }
[08:24:58.763]     ...future.result$conditions <- ...future.conditions
[08:24:58.763]     ...future.result$finished <- base::Sys.time()
[08:24:58.763]     ...future.result
[08:24:58.763] }
[08:24:58.818] MultisessionFuture started
[08:24:58.818] result() for ClusterFuture ...
[08:24:58.818] receiveMessageFromWorker() for ClusterFuture ...
[08:24:58.819] - Validating connection of MultisessionFuture
[08:24:58.850] - received message: FutureResult
[08:24:58.850] - Received FutureResult
[08:24:58.850] - Erased future from FutureRegistry
[08:24:58.850] result() for ClusterFuture ...
[08:24:58.850] - result already collected: FutureResult
[08:24:58.850] result() for ClusterFuture ... done
[08:24:58.850] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:58.850] result() for ClusterFuture ... done
[08:24:58.851] result() for ClusterFuture ...
[08:24:58.851] - result already collected: FutureResult
[08:24:58.851] result() for ClusterFuture ... done
[08:24:58.851] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:24:58.852] plan(): nbrOfWorkers() = 2
[08:24:58.853] future_by_internal() ...
[08:24:58.853] future_lapply() ...
[08:24:58.855] Number of chunks: 2
[08:24:58.855] getGlobalsAndPackagesXApply() ...
[08:24:58.855]  - future.globals: TRUE
[08:24:58.855] getGlobalsAndPackages() ...
[08:24:58.855] Searching for globals...
[08:24:58.857] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:58.857] Searching for globals ... DONE
[08:24:58.857] Resolving globals: FALSE
[08:24:58.857] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:58.858] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:58.858] - globals: [1] ‘FUN’
[08:24:58.858] 
[08:24:58.858] getGlobalsAndPackages() ... DONE
[08:24:58.858]  - globals found/used: [n=1] ‘FUN’
[08:24:58.858]  - needed namespaces: [n=0] 
[08:24:58.858] Finding globals ... DONE
[08:24:58.858]  - use_args: TRUE
[08:24:58.858]  - Getting '...' globals ...
[08:24:58.859] resolve() on list ...
[08:24:58.859]  recursive: 0
[08:24:58.859]  length: 1
[08:24:58.859]  elements: ‘...’
[08:24:58.859]  length: 0 (resolved future 1)
[08:24:58.859] resolve() on list ... DONE
[08:24:58.859]    - '...' content: [n=0] 
[08:24:58.859] List of 1
[08:24:58.859]  $ ...: list()
[08:24:58.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.859]  - attr(*, "where")=List of 1
[08:24:58.859]   ..$ ...:<environment: 0x557b2a38a930> 
[08:24:58.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.859]  - attr(*, "resolved")= logi TRUE
[08:24:58.859]  - attr(*, "total_size")= num NA
[08:24:58.862]  - Getting '...' globals ... DONE
[08:24:58.862] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:58.862] List of 2
[08:24:58.862]  $ ...future.FUN:function (object, ...)  
[08:24:58.862]  $ ...          : list()
[08:24:58.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:58.862]  - attr(*, "where")=List of 2
[08:24:58.862]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:58.862]   ..$ ...          :<environment: 0x557b2a38a930> 
[08:24:58.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:58.862]  - attr(*, "resolved")= logi FALSE
[08:24:58.862]  - attr(*, "total_size")= num 15670
[08:24:58.865] Packages to be attached in all futures: [n=0] 
[08:24:58.865] getGlobalsAndPackagesXApply() ... DONE
[08:24:58.865] Number of futures (= number of chunks): 2
[08:24:58.865] Launching 2 futures (chunks) ...
[08:24:58.865] Chunk #1 of 2 ...
[08:24:58.865]  - Finding globals in 'X' for chunk #1 ...
[08:24:58.865] getGlobalsAndPackages() ...
[08:24:58.865] Searching for globals...
[08:24:58.866] 
[08:24:58.866] Searching for globals ... DONE
[08:24:58.866] - globals: [0] <none>
[08:24:58.866] getGlobalsAndPackages() ... DONE
[08:24:58.866]    + additional globals found: [n=0] 
[08:24:58.866]    + additional namespaces needed: [n=0] 
[08:24:58.866]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:58.866]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:58.866]  - seeds: <none>
[08:24:58.866]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.867] getGlobalsAndPackages() ...
[08:24:58.867] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.867] Resolving globals: FALSE
[08:24:58.867] Tweak future expression to call with '...' arguments ...
[08:24:58.867] {
[08:24:58.867]     do.call(function(...) {
[08:24:58.867]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.867]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.867]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.867]             on.exit(options(oopts), add = TRUE)
[08:24:58.867]         }
[08:24:58.867]         {
[08:24:58.867]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.867]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.867]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.867]             })
[08:24:58.867]         }
[08:24:58.867]     }, args = future.call.arguments)
[08:24:58.867] }
[08:24:58.867] Tweak future expression to call with '...' arguments ... DONE
[08:24:58.868] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.868] 
[08:24:58.868] getGlobalsAndPackages() ... DONE
[08:24:58.868] run() for ‘Future’ ...
[08:24:58.868] - state: ‘created’
[08:24:58.868] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:58.882] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.882] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:58.882]   - Field: ‘node’
[08:24:58.883]   - Field: ‘label’
[08:24:58.883]   - Field: ‘local’
[08:24:58.883]   - Field: ‘owner’
[08:24:58.883]   - Field: ‘envir’
[08:24:58.883]   - Field: ‘workers’
[08:24:58.883]   - Field: ‘packages’
[08:24:58.883]   - Field: ‘gc’
[08:24:58.883]   - Field: ‘conditions’
[08:24:58.883]   - Field: ‘persistent’
[08:24:58.883]   - Field: ‘expr’
[08:24:58.883]   - Field: ‘uuid’
[08:24:58.883]   - Field: ‘seed’
[08:24:58.884]   - Field: ‘version’
[08:24:58.884]   - Field: ‘result’
[08:24:58.884]   - Field: ‘asynchronous’
[08:24:58.884]   - Field: ‘calls’
[08:24:58.884]   - Field: ‘globals’
[08:24:58.884]   - Field: ‘stdout’
[08:24:58.884]   - Field: ‘earlySignal’
[08:24:58.884]   - Field: ‘lazy’
[08:24:58.884]   - Field: ‘state’
[08:24:58.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:58.884] - Launch lazy future ...
[08:24:58.885] Packages needed by the future expression (n = 0): <none>
[08:24:58.885] Packages needed by future strategies (n = 0): <none>
[08:24:58.885] {
[08:24:58.885]     {
[08:24:58.885]         {
[08:24:58.885]             ...future.startTime <- base::Sys.time()
[08:24:58.885]             {
[08:24:58.885]                 {
[08:24:58.885]                   {
[08:24:58.885]                     {
[08:24:58.885]                       base::local({
[08:24:58.885]                         has_future <- base::requireNamespace("future", 
[08:24:58.885]                           quietly = TRUE)
[08:24:58.885]                         if (has_future) {
[08:24:58.885]                           ns <- base::getNamespace("future")
[08:24:58.885]                           version <- ns[[".package"]][["version"]]
[08:24:58.885]                           if (is.null(version)) 
[08:24:58.885]                             version <- utils::packageVersion("future")
[08:24:58.885]                         }
[08:24:58.885]                         else {
[08:24:58.885]                           version <- NULL
[08:24:58.885]                         }
[08:24:58.885]                         if (!has_future || version < "1.8.0") {
[08:24:58.885]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:58.885]                             "", base::R.version$version.string), 
[08:24:58.885]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:58.885]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:58.885]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:58.885]                               "release", "version")], collapse = " "), 
[08:24:58.885]                             hostname = base::Sys.info()[["nodename"]])
[08:24:58.885]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:58.885]                             info)
[08:24:58.885]                           info <- base::paste(info, collapse = "; ")
[08:24:58.885]                           if (!has_future) {
[08:24:58.885]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:58.885]                               info)
[08:24:58.885]                           }
[08:24:58.885]                           else {
[08:24:58.885]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:58.885]                               info, version)
[08:24:58.885]                           }
[08:24:58.885]                           base::stop(msg)
[08:24:58.885]                         }
[08:24:58.885]                       })
[08:24:58.885]                     }
[08:24:58.885]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:58.885]                     base::options(mc.cores = 1L)
[08:24:58.885]                   }
[08:24:58.885]                   ...future.strategy.old <- future::plan("list")
[08:24:58.885]                   options(future.plan = NULL)
[08:24:58.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:58.885]                 }
[08:24:58.885]                 ...future.workdir <- getwd()
[08:24:58.885]             }
[08:24:58.885]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:58.885]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:58.885]         }
[08:24:58.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:58.885]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:58.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:58.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:58.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:58.885]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:58.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:58.885]             base::names(...future.oldOptions))
[08:24:58.885]     }
[08:24:58.885]     if (FALSE) {
[08:24:58.885]     }
[08:24:58.885]     else {
[08:24:58.885]         if (TRUE) {
[08:24:58.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:58.885]                 open = "w")
[08:24:58.885]         }
[08:24:58.885]         else {
[08:24:58.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:58.885]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:58.885]         }
[08:24:58.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:58.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:58.885]             base::sink(type = "output", split = FALSE)
[08:24:58.885]             base::close(...future.stdout)
[08:24:58.885]         }, add = TRUE)
[08:24:58.885]     }
[08:24:58.885]     ...future.frame <- base::sys.nframe()
[08:24:58.885]     ...future.conditions <- base::list()
[08:24:58.885]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:58.885]     if (FALSE) {
[08:24:58.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:58.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:58.885]     }
[08:24:58.885]     ...future.result <- base::tryCatch({
[08:24:58.885]         base::withCallingHandlers({
[08:24:58.885]             ...future.value <- base::withVisible(base::local({
[08:24:58.885]                 ...future.makeSendCondition <- base::local({
[08:24:58.885]                   sendCondition <- NULL
[08:24:58.885]                   function(frame = 1L) {
[08:24:58.885]                     if (is.function(sendCondition)) 
[08:24:58.885]                       return(sendCondition)
[08:24:58.885]                     ns <- getNamespace("parallel")
[08:24:58.885]                     if (exists("sendData", mode = "function", 
[08:24:58.885]                       envir = ns)) {
[08:24:58.885]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:58.885]                         envir = ns)
[08:24:58.885]                       envir <- sys.frame(frame)
[08:24:58.885]                       master <- NULL
[08:24:58.885]                       while (!identical(envir, .GlobalEnv) && 
[08:24:58.885]                         !identical(envir, emptyenv())) {
[08:24:58.885]                         if (exists("master", mode = "list", envir = envir, 
[08:24:58.885]                           inherits = FALSE)) {
[08:24:58.885]                           master <- get("master", mode = "list", 
[08:24:58.885]                             envir = envir, inherits = FALSE)
[08:24:58.885]                           if (inherits(master, c("SOCKnode", 
[08:24:58.885]                             "SOCK0node"))) {
[08:24:58.885]                             sendCondition <<- function(cond) {
[08:24:58.885]                               data <- list(type = "VALUE", value = cond, 
[08:24:58.885]                                 success = TRUE)
[08:24:58.885]                               parallel_sendData(master, data)
[08:24:58.885]                             }
[08:24:58.885]                             return(sendCondition)
[08:24:58.885]                           }
[08:24:58.885]                         }
[08:24:58.885]                         frame <- frame + 1L
[08:24:58.885]                         envir <- sys.frame(frame)
[08:24:58.885]                       }
[08:24:58.885]                     }
[08:24:58.885]                     sendCondition <<- function(cond) NULL
[08:24:58.885]                   }
[08:24:58.885]                 })
[08:24:58.885]                 withCallingHandlers({
[08:24:58.885]                   {
[08:24:58.885]                     do.call(function(...) {
[08:24:58.885]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.885]                       if (!identical(...future.globals.maxSize.org, 
[08:24:58.885]                         ...future.globals.maxSize)) {
[08:24:58.885]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.885]                         on.exit(options(oopts), add = TRUE)
[08:24:58.885]                       }
[08:24:58.885]                       {
[08:24:58.885]                         lapply(seq_along(...future.elements_ii), 
[08:24:58.885]                           FUN = function(jj) {
[08:24:58.885]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.885]                             ...future.FUN(...future.X_jj, ...)
[08:24:58.885]                           })
[08:24:58.885]                       }
[08:24:58.885]                     }, args = future.call.arguments)
[08:24:58.885]                   }
[08:24:58.885]                 }, immediateCondition = function(cond) {
[08:24:58.885]                   sendCondition <- ...future.makeSendCondition()
[08:24:58.885]                   sendCondition(cond)
[08:24:58.885]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.885]                   {
[08:24:58.885]                     inherits <- base::inherits
[08:24:58.885]                     invokeRestart <- base::invokeRestart
[08:24:58.885]                     is.null <- base::is.null
[08:24:58.885]                     muffled <- FALSE
[08:24:58.885]                     if (inherits(cond, "message")) {
[08:24:58.885]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:58.885]                       if (muffled) 
[08:24:58.885]                         invokeRestart("muffleMessage")
[08:24:58.885]                     }
[08:24:58.885]                     else if (inherits(cond, "warning")) {
[08:24:58.885]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:58.885]                       if (muffled) 
[08:24:58.885]                         invokeRestart("muffleWarning")
[08:24:58.885]                     }
[08:24:58.885]                     else if (inherits(cond, "condition")) {
[08:24:58.885]                       if (!is.null(pattern)) {
[08:24:58.885]                         computeRestarts <- base::computeRestarts
[08:24:58.885]                         grepl <- base::grepl
[08:24:58.885]                         restarts <- computeRestarts(cond)
[08:24:58.885]                         for (restart in restarts) {
[08:24:58.885]                           name <- restart$name
[08:24:58.885]                           if (is.null(name)) 
[08:24:58.885]                             next
[08:24:58.885]                           if (!grepl(pattern, name)) 
[08:24:58.885]                             next
[08:24:58.885]                           invokeRestart(restart)
[08:24:58.885]                           muffled <- TRUE
[08:24:58.885]                           break
[08:24:58.885]                         }
[08:24:58.885]                       }
[08:24:58.885]                     }
[08:24:58.885]                     invisible(muffled)
[08:24:58.885]                   }
[08:24:58.885]                   muffleCondition(cond)
[08:24:58.885]                 })
[08:24:58.885]             }))
[08:24:58.885]             future::FutureResult(value = ...future.value$value, 
[08:24:58.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.885]                   ...future.rng), globalenv = if (FALSE) 
[08:24:58.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:58.885]                     ...future.globalenv.names))
[08:24:58.885]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:58.885]         }, condition = base::local({
[08:24:58.885]             c <- base::c
[08:24:58.885]             inherits <- base::inherits
[08:24:58.885]             invokeRestart <- base::invokeRestart
[08:24:58.885]             length <- base::length
[08:24:58.885]             list <- base::list
[08:24:58.885]             seq.int <- base::seq.int
[08:24:58.885]             signalCondition <- base::signalCondition
[08:24:58.885]             sys.calls <- base::sys.calls
[08:24:58.885]             `[[` <- base::`[[`
[08:24:58.885]             `+` <- base::`+`
[08:24:58.885]             `<<-` <- base::`<<-`
[08:24:58.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:58.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:58.885]                   3L)]
[08:24:58.885]             }
[08:24:58.885]             function(cond) {
[08:24:58.885]                 is_error <- inherits(cond, "error")
[08:24:58.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:58.885]                   NULL)
[08:24:58.885]                 if (is_error) {
[08:24:58.885]                   sessionInformation <- function() {
[08:24:58.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:58.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:58.885]                       search = base::search(), system = base::Sys.info())
[08:24:58.885]                   }
[08:24:58.885]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:58.885]                     cond$call), session = sessionInformation(), 
[08:24:58.885]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:58.885]                   signalCondition(cond)
[08:24:58.885]                 }
[08:24:58.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:58.885]                 "immediateCondition"))) {
[08:24:58.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:58.885]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:58.885]                   if (TRUE && !signal) {
[08:24:58.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.885]                     {
[08:24:58.885]                       inherits <- base::inherits
[08:24:58.885]                       invokeRestart <- base::invokeRestart
[08:24:58.885]                       is.null <- base::is.null
[08:24:58.885]                       muffled <- FALSE
[08:24:58.885]                       if (inherits(cond, "message")) {
[08:24:58.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.885]                         if (muffled) 
[08:24:58.885]                           invokeRestart("muffleMessage")
[08:24:58.885]                       }
[08:24:58.885]                       else if (inherits(cond, "warning")) {
[08:24:58.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.885]                         if (muffled) 
[08:24:58.885]                           invokeRestart("muffleWarning")
[08:24:58.885]                       }
[08:24:58.885]                       else if (inherits(cond, "condition")) {
[08:24:58.885]                         if (!is.null(pattern)) {
[08:24:58.885]                           computeRestarts <- base::computeRestarts
[08:24:58.885]                           grepl <- base::grepl
[08:24:58.885]                           restarts <- computeRestarts(cond)
[08:24:58.885]                           for (restart in restarts) {
[08:24:58.885]                             name <- restart$name
[08:24:58.885]                             if (is.null(name)) 
[08:24:58.885]                               next
[08:24:58.885]                             if (!grepl(pattern, name)) 
[08:24:58.885]                               next
[08:24:58.885]                             invokeRestart(restart)
[08:24:58.885]                             muffled <- TRUE
[08:24:58.885]                             break
[08:24:58.885]                           }
[08:24:58.885]                         }
[08:24:58.885]                       }
[08:24:58.885]                       invisible(muffled)
[08:24:58.885]                     }
[08:24:58.885]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.885]                   }
[08:24:58.885]                 }
[08:24:58.885]                 else {
[08:24:58.885]                   if (TRUE) {
[08:24:58.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.885]                     {
[08:24:58.885]                       inherits <- base::inherits
[08:24:58.885]                       invokeRestart <- base::invokeRestart
[08:24:58.885]                       is.null <- base::is.null
[08:24:58.885]                       muffled <- FALSE
[08:24:58.885]                       if (inherits(cond, "message")) {
[08:24:58.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.885]                         if (muffled) 
[08:24:58.885]                           invokeRestart("muffleMessage")
[08:24:58.885]                       }
[08:24:58.885]                       else if (inherits(cond, "warning")) {
[08:24:58.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.885]                         if (muffled) 
[08:24:58.885]                           invokeRestart("muffleWarning")
[08:24:58.885]                       }
[08:24:58.885]                       else if (inherits(cond, "condition")) {
[08:24:58.885]                         if (!is.null(pattern)) {
[08:24:58.885]                           computeRestarts <- base::computeRestarts
[08:24:58.885]                           grepl <- base::grepl
[08:24:58.885]                           restarts <- computeRestarts(cond)
[08:24:58.885]                           for (restart in restarts) {
[08:24:58.885]                             name <- restart$name
[08:24:58.885]                             if (is.null(name)) 
[08:24:58.885]                               next
[08:24:58.885]                             if (!grepl(pattern, name)) 
[08:24:58.885]                               next
[08:24:58.885]                             invokeRestart(restart)
[08:24:58.885]                             muffled <- TRUE
[08:24:58.885]                             break
[08:24:58.885]                           }
[08:24:58.885]                         }
[08:24:58.885]                       }
[08:24:58.885]                       invisible(muffled)
[08:24:58.885]                     }
[08:24:58.885]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.885]                   }
[08:24:58.885]                 }
[08:24:58.885]             }
[08:24:58.885]         }))
[08:24:58.885]     }, error = function(ex) {
[08:24:58.885]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:58.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.885]                 ...future.rng), started = ...future.startTime, 
[08:24:58.885]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:58.885]             version = "1.8"), class = "FutureResult")
[08:24:58.885]     }, finally = {
[08:24:58.885]         if (!identical(...future.workdir, getwd())) 
[08:24:58.885]             setwd(...future.workdir)
[08:24:58.885]         {
[08:24:58.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:58.885]                 ...future.oldOptions$nwarnings <- NULL
[08:24:58.885]             }
[08:24:58.885]             base::options(...future.oldOptions)
[08:24:58.885]             if (.Platform$OS.type == "windows") {
[08:24:58.885]                 old_names <- names(...future.oldEnvVars)
[08:24:58.885]                 envs <- base::Sys.getenv()
[08:24:58.885]                 names <- names(envs)
[08:24:58.885]                 common <- intersect(names, old_names)
[08:24:58.885]                 added <- setdiff(names, old_names)
[08:24:58.885]                 removed <- setdiff(old_names, names)
[08:24:58.885]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:58.885]                   envs[common]]
[08:24:58.885]                 NAMES <- toupper(changed)
[08:24:58.885]                 args <- list()
[08:24:58.885]                 for (kk in seq_along(NAMES)) {
[08:24:58.885]                   name <- changed[[kk]]
[08:24:58.885]                   NAME <- NAMES[[kk]]
[08:24:58.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.885]                     next
[08:24:58.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.885]                 }
[08:24:58.885]                 NAMES <- toupper(added)
[08:24:58.885]                 for (kk in seq_along(NAMES)) {
[08:24:58.885]                   name <- added[[kk]]
[08:24:58.885]                   NAME <- NAMES[[kk]]
[08:24:58.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.885]                     next
[08:24:58.885]                   args[[name]] <- ""
[08:24:58.885]                 }
[08:24:58.885]                 NAMES <- toupper(removed)
[08:24:58.885]                 for (kk in seq_along(NAMES)) {
[08:24:58.885]                   name <- removed[[kk]]
[08:24:58.885]                   NAME <- NAMES[[kk]]
[08:24:58.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.885]                     next
[08:24:58.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.885]                 }
[08:24:58.885]                 if (length(args) > 0) 
[08:24:58.885]                   base::do.call(base::Sys.setenv, args = args)
[08:24:58.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:58.885]             }
[08:24:58.885]             else {
[08:24:58.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:58.885]             }
[08:24:58.885]             {
[08:24:58.885]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:58.885]                   0L) {
[08:24:58.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:58.885]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:58.885]                   base::options(opts)
[08:24:58.885]                 }
[08:24:58.885]                 {
[08:24:58.885]                   {
[08:24:58.885]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:58.885]                     NULL
[08:24:58.885]                   }
[08:24:58.885]                   options(future.plan = NULL)
[08:24:58.885]                   if (is.na(NA_character_)) 
[08:24:58.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:58.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:58.885]                     .init = FALSE)
[08:24:58.885]                 }
[08:24:58.885]             }
[08:24:58.885]         }
[08:24:58.885]     })
[08:24:58.885]     if (TRUE) {
[08:24:58.885]         base::sink(type = "output", split = FALSE)
[08:24:58.885]         if (TRUE) {
[08:24:58.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:58.885]         }
[08:24:58.885]         else {
[08:24:58.885]             ...future.result["stdout"] <- base::list(NULL)
[08:24:58.885]         }
[08:24:58.885]         base::close(...future.stdout)
[08:24:58.885]         ...future.stdout <- NULL
[08:24:58.885]     }
[08:24:58.885]     ...future.result$conditions <- ...future.conditions
[08:24:58.885]     ...future.result$finished <- base::Sys.time()
[08:24:58.885]     ...future.result
[08:24:58.885] }
[08:24:58.888] Exporting 5 global objects (1.40 KiB) to cluster node #1 ...
[08:24:58.888] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[08:24:58.889] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[08:24:58.889] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:58.889] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:58.889] Exporting ‘...future.elements_ii’ (564 bytes) to cluster node #1 ...
[08:24:58.890] Exporting ‘...future.elements_ii’ (564 bytes) to cluster node #1 ... DONE
[08:24:58.890] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:58.890] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:58.890] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:24:58.890] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:24:58.891] Exporting 5 global objects (1.40 KiB) to cluster node #1 ... DONE
[08:24:58.891] MultisessionFuture started
[08:24:58.891] - Launch lazy future ... done
[08:24:58.891] run() for ‘MultisessionFuture’ ... done
[08:24:58.891] Created future:
[08:24:58.891] MultisessionFuture:
[08:24:58.891] Label: ‘future_by-1’
[08:24:58.891] Expression:
[08:24:58.891] {
[08:24:58.891]     do.call(function(...) {
[08:24:58.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.891]             on.exit(options(oopts), add = TRUE)
[08:24:58.891]         }
[08:24:58.891]         {
[08:24:58.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.891]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.891]             })
[08:24:58.891]         }
[08:24:58.891]     }, args = future.call.arguments)
[08:24:58.891] }
[08:24:58.891] Lazy evaluation: FALSE
[08:24:58.891] Asynchronous evaluation: TRUE
[08:24:58.891] Local evaluation: TRUE
[08:24:58.891] Environment: R_GlobalEnv
[08:24:58.891] Capture standard output: TRUE
[08:24:58.891] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:58.891] Globals: 5 objects totaling 996 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 564 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:58.891] Packages: <none>
[08:24:58.891] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:58.891] Resolved: FALSE
[08:24:58.891] Value: <not collected>
[08:24:58.891] Conditions captured: <none>
[08:24:58.891] Early signaling: FALSE
[08:24:58.891] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:58.891] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.903] Chunk #1 of 2 ... DONE
[08:24:58.903] Chunk #2 of 2 ...
[08:24:58.903]  - Finding globals in 'X' for chunk #2 ...
[08:24:58.904] getGlobalsAndPackages() ...
[08:24:58.904] Searching for globals...
[08:24:58.904] 
[08:24:58.904] Searching for globals ... DONE
[08:24:58.904] - globals: [0] <none>
[08:24:58.904] getGlobalsAndPackages() ... DONE
[08:24:58.905]    + additional globals found: [n=0] 
[08:24:58.905]    + additional namespaces needed: [n=0] 
[08:24:58.905]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:58.905]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:58.905]  - seeds: <none>
[08:24:58.905]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.905] getGlobalsAndPackages() ...
[08:24:58.905] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.905] Resolving globals: FALSE
[08:24:58.905] Tweak future expression to call with '...' arguments ...
[08:24:58.905] {
[08:24:58.905]     do.call(function(...) {
[08:24:58.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.905]             on.exit(options(oopts), add = TRUE)
[08:24:58.905]         }
[08:24:58.905]         {
[08:24:58.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.905]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.905]             })
[08:24:58.905]         }
[08:24:58.905]     }, args = future.call.arguments)
[08:24:58.905] }
[08:24:58.906] Tweak future expression to call with '...' arguments ... DONE
[08:24:58.906] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:58.906] 
[08:24:58.906] getGlobalsAndPackages() ... DONE
[08:24:58.907] run() for ‘Future’ ...
[08:24:58.907] - state: ‘created’
[08:24:58.907] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:58.921] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.921] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:58.921]   - Field: ‘node’
[08:24:58.921]   - Field: ‘label’
[08:24:58.921]   - Field: ‘local’
[08:24:58.921]   - Field: ‘owner’
[08:24:58.921]   - Field: ‘envir’
[08:24:58.921]   - Field: ‘workers’
[08:24:58.921]   - Field: ‘packages’
[08:24:58.921]   - Field: ‘gc’
[08:24:58.922]   - Field: ‘conditions’
[08:24:58.922]   - Field: ‘persistent’
[08:24:58.922]   - Field: ‘expr’
[08:24:58.922]   - Field: ‘uuid’
[08:24:58.922]   - Field: ‘seed’
[08:24:58.922]   - Field: ‘version’
[08:24:58.922]   - Field: ‘result’
[08:24:58.922]   - Field: ‘asynchronous’
[08:24:58.922]   - Field: ‘calls’
[08:24:58.922]   - Field: ‘globals’
[08:24:58.922]   - Field: ‘stdout’
[08:24:58.922]   - Field: ‘earlySignal’
[08:24:58.923]   - Field: ‘lazy’
[08:24:58.923]   - Field: ‘state’
[08:24:58.923] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:58.923] - Launch lazy future ...
[08:24:58.923] Packages needed by the future expression (n = 0): <none>
[08:24:58.923] Packages needed by future strategies (n = 0): <none>
[08:24:58.924] {
[08:24:58.924]     {
[08:24:58.924]         {
[08:24:58.924]             ...future.startTime <- base::Sys.time()
[08:24:58.924]             {
[08:24:58.924]                 {
[08:24:58.924]                   {
[08:24:58.924]                     {
[08:24:58.924]                       base::local({
[08:24:58.924]                         has_future <- base::requireNamespace("future", 
[08:24:58.924]                           quietly = TRUE)
[08:24:58.924]                         if (has_future) {
[08:24:58.924]                           ns <- base::getNamespace("future")
[08:24:58.924]                           version <- ns[[".package"]][["version"]]
[08:24:58.924]                           if (is.null(version)) 
[08:24:58.924]                             version <- utils::packageVersion("future")
[08:24:58.924]                         }
[08:24:58.924]                         else {
[08:24:58.924]                           version <- NULL
[08:24:58.924]                         }
[08:24:58.924]                         if (!has_future || version < "1.8.0") {
[08:24:58.924]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:58.924]                             "", base::R.version$version.string), 
[08:24:58.924]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:58.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:58.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:58.924]                               "release", "version")], collapse = " "), 
[08:24:58.924]                             hostname = base::Sys.info()[["nodename"]])
[08:24:58.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:58.924]                             info)
[08:24:58.924]                           info <- base::paste(info, collapse = "; ")
[08:24:58.924]                           if (!has_future) {
[08:24:58.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:58.924]                               info)
[08:24:58.924]                           }
[08:24:58.924]                           else {
[08:24:58.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:58.924]                               info, version)
[08:24:58.924]                           }
[08:24:58.924]                           base::stop(msg)
[08:24:58.924]                         }
[08:24:58.924]                       })
[08:24:58.924]                     }
[08:24:58.924]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:58.924]                     base::options(mc.cores = 1L)
[08:24:58.924]                   }
[08:24:58.924]                   ...future.strategy.old <- future::plan("list")
[08:24:58.924]                   options(future.plan = NULL)
[08:24:58.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:58.924]                 }
[08:24:58.924]                 ...future.workdir <- getwd()
[08:24:58.924]             }
[08:24:58.924]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:58.924]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:58.924]         }
[08:24:58.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:58.924]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:58.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:58.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:58.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:58.924]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:58.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:58.924]             base::names(...future.oldOptions))
[08:24:58.924]     }
[08:24:58.924]     if (FALSE) {
[08:24:58.924]     }
[08:24:58.924]     else {
[08:24:58.924]         if (TRUE) {
[08:24:58.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:58.924]                 open = "w")
[08:24:58.924]         }
[08:24:58.924]         else {
[08:24:58.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:58.924]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:58.924]         }
[08:24:58.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:58.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:58.924]             base::sink(type = "output", split = FALSE)
[08:24:58.924]             base::close(...future.stdout)
[08:24:58.924]         }, add = TRUE)
[08:24:58.924]     }
[08:24:58.924]     ...future.frame <- base::sys.nframe()
[08:24:58.924]     ...future.conditions <- base::list()
[08:24:58.924]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:58.924]     if (FALSE) {
[08:24:58.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:58.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:58.924]     }
[08:24:58.924]     ...future.result <- base::tryCatch({
[08:24:58.924]         base::withCallingHandlers({
[08:24:58.924]             ...future.value <- base::withVisible(base::local({
[08:24:58.924]                 ...future.makeSendCondition <- base::local({
[08:24:58.924]                   sendCondition <- NULL
[08:24:58.924]                   function(frame = 1L) {
[08:24:58.924]                     if (is.function(sendCondition)) 
[08:24:58.924]                       return(sendCondition)
[08:24:58.924]                     ns <- getNamespace("parallel")
[08:24:58.924]                     if (exists("sendData", mode = "function", 
[08:24:58.924]                       envir = ns)) {
[08:24:58.924]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:58.924]                         envir = ns)
[08:24:58.924]                       envir <- sys.frame(frame)
[08:24:58.924]                       master <- NULL
[08:24:58.924]                       while (!identical(envir, .GlobalEnv) && 
[08:24:58.924]                         !identical(envir, emptyenv())) {
[08:24:58.924]                         if (exists("master", mode = "list", envir = envir, 
[08:24:58.924]                           inherits = FALSE)) {
[08:24:58.924]                           master <- get("master", mode = "list", 
[08:24:58.924]                             envir = envir, inherits = FALSE)
[08:24:58.924]                           if (inherits(master, c("SOCKnode", 
[08:24:58.924]                             "SOCK0node"))) {
[08:24:58.924]                             sendCondition <<- function(cond) {
[08:24:58.924]                               data <- list(type = "VALUE", value = cond, 
[08:24:58.924]                                 success = TRUE)
[08:24:58.924]                               parallel_sendData(master, data)
[08:24:58.924]                             }
[08:24:58.924]                             return(sendCondition)
[08:24:58.924]                           }
[08:24:58.924]                         }
[08:24:58.924]                         frame <- frame + 1L
[08:24:58.924]                         envir <- sys.frame(frame)
[08:24:58.924]                       }
[08:24:58.924]                     }
[08:24:58.924]                     sendCondition <<- function(cond) NULL
[08:24:58.924]                   }
[08:24:58.924]                 })
[08:24:58.924]                 withCallingHandlers({
[08:24:58.924]                   {
[08:24:58.924]                     do.call(function(...) {
[08:24:58.924]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.924]                       if (!identical(...future.globals.maxSize.org, 
[08:24:58.924]                         ...future.globals.maxSize)) {
[08:24:58.924]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.924]                         on.exit(options(oopts), add = TRUE)
[08:24:58.924]                       }
[08:24:58.924]                       {
[08:24:58.924]                         lapply(seq_along(...future.elements_ii), 
[08:24:58.924]                           FUN = function(jj) {
[08:24:58.924]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.924]                             ...future.FUN(...future.X_jj, ...)
[08:24:58.924]                           })
[08:24:58.924]                       }
[08:24:58.924]                     }, args = future.call.arguments)
[08:24:58.924]                   }
[08:24:58.924]                 }, immediateCondition = function(cond) {
[08:24:58.924]                   sendCondition <- ...future.makeSendCondition()
[08:24:58.924]                   sendCondition(cond)
[08:24:58.924]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.924]                   {
[08:24:58.924]                     inherits <- base::inherits
[08:24:58.924]                     invokeRestart <- base::invokeRestart
[08:24:58.924]                     is.null <- base::is.null
[08:24:58.924]                     muffled <- FALSE
[08:24:58.924]                     if (inherits(cond, "message")) {
[08:24:58.924]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:58.924]                       if (muffled) 
[08:24:58.924]                         invokeRestart("muffleMessage")
[08:24:58.924]                     }
[08:24:58.924]                     else if (inherits(cond, "warning")) {
[08:24:58.924]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:58.924]                       if (muffled) 
[08:24:58.924]                         invokeRestart("muffleWarning")
[08:24:58.924]                     }
[08:24:58.924]                     else if (inherits(cond, "condition")) {
[08:24:58.924]                       if (!is.null(pattern)) {
[08:24:58.924]                         computeRestarts <- base::computeRestarts
[08:24:58.924]                         grepl <- base::grepl
[08:24:58.924]                         restarts <- computeRestarts(cond)
[08:24:58.924]                         for (restart in restarts) {
[08:24:58.924]                           name <- restart$name
[08:24:58.924]                           if (is.null(name)) 
[08:24:58.924]                             next
[08:24:58.924]                           if (!grepl(pattern, name)) 
[08:24:58.924]                             next
[08:24:58.924]                           invokeRestart(restart)
[08:24:58.924]                           muffled <- TRUE
[08:24:58.924]                           break
[08:24:58.924]                         }
[08:24:58.924]                       }
[08:24:58.924]                     }
[08:24:58.924]                     invisible(muffled)
[08:24:58.924]                   }
[08:24:58.924]                   muffleCondition(cond)
[08:24:58.924]                 })
[08:24:58.924]             }))
[08:24:58.924]             future::FutureResult(value = ...future.value$value, 
[08:24:58.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.924]                   ...future.rng), globalenv = if (FALSE) 
[08:24:58.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:58.924]                     ...future.globalenv.names))
[08:24:58.924]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:58.924]         }, condition = base::local({
[08:24:58.924]             c <- base::c
[08:24:58.924]             inherits <- base::inherits
[08:24:58.924]             invokeRestart <- base::invokeRestart
[08:24:58.924]             length <- base::length
[08:24:58.924]             list <- base::list
[08:24:58.924]             seq.int <- base::seq.int
[08:24:58.924]             signalCondition <- base::signalCondition
[08:24:58.924]             sys.calls <- base::sys.calls
[08:24:58.924]             `[[` <- base::`[[`
[08:24:58.924]             `+` <- base::`+`
[08:24:58.924]             `<<-` <- base::`<<-`
[08:24:58.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:58.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:58.924]                   3L)]
[08:24:58.924]             }
[08:24:58.924]             function(cond) {
[08:24:58.924]                 is_error <- inherits(cond, "error")
[08:24:58.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:58.924]                   NULL)
[08:24:58.924]                 if (is_error) {
[08:24:58.924]                   sessionInformation <- function() {
[08:24:58.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:58.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:58.924]                       search = base::search(), system = base::Sys.info())
[08:24:58.924]                   }
[08:24:58.924]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:58.924]                     cond$call), session = sessionInformation(), 
[08:24:58.924]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:58.924]                   signalCondition(cond)
[08:24:58.924]                 }
[08:24:58.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:58.924]                 "immediateCondition"))) {
[08:24:58.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:58.924]                   ...future.conditions[[length(...future.conditions) + 
[08:24:58.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:58.924]                   if (TRUE && !signal) {
[08:24:58.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.924]                     {
[08:24:58.924]                       inherits <- base::inherits
[08:24:58.924]                       invokeRestart <- base::invokeRestart
[08:24:58.924]                       is.null <- base::is.null
[08:24:58.924]                       muffled <- FALSE
[08:24:58.924]                       if (inherits(cond, "message")) {
[08:24:58.924]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.924]                         if (muffled) 
[08:24:58.924]                           invokeRestart("muffleMessage")
[08:24:58.924]                       }
[08:24:58.924]                       else if (inherits(cond, "warning")) {
[08:24:58.924]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.924]                         if (muffled) 
[08:24:58.924]                           invokeRestart("muffleWarning")
[08:24:58.924]                       }
[08:24:58.924]                       else if (inherits(cond, "condition")) {
[08:24:58.924]                         if (!is.null(pattern)) {
[08:24:58.924]                           computeRestarts <- base::computeRestarts
[08:24:58.924]                           grepl <- base::grepl
[08:24:58.924]                           restarts <- computeRestarts(cond)
[08:24:58.924]                           for (restart in restarts) {
[08:24:58.924]                             name <- restart$name
[08:24:58.924]                             if (is.null(name)) 
[08:24:58.924]                               next
[08:24:58.924]                             if (!grepl(pattern, name)) 
[08:24:58.924]                               next
[08:24:58.924]                             invokeRestart(restart)
[08:24:58.924]                             muffled <- TRUE
[08:24:58.924]                             break
[08:24:58.924]                           }
[08:24:58.924]                         }
[08:24:58.924]                       }
[08:24:58.924]                       invisible(muffled)
[08:24:58.924]                     }
[08:24:58.924]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.924]                   }
[08:24:58.924]                 }
[08:24:58.924]                 else {
[08:24:58.924]                   if (TRUE) {
[08:24:58.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:58.924]                     {
[08:24:58.924]                       inherits <- base::inherits
[08:24:58.924]                       invokeRestart <- base::invokeRestart
[08:24:58.924]                       is.null <- base::is.null
[08:24:58.924]                       muffled <- FALSE
[08:24:58.924]                       if (inherits(cond, "message")) {
[08:24:58.924]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:58.924]                         if (muffled) 
[08:24:58.924]                           invokeRestart("muffleMessage")
[08:24:58.924]                       }
[08:24:58.924]                       else if (inherits(cond, "warning")) {
[08:24:58.924]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:58.924]                         if (muffled) 
[08:24:58.924]                           invokeRestart("muffleWarning")
[08:24:58.924]                       }
[08:24:58.924]                       else if (inherits(cond, "condition")) {
[08:24:58.924]                         if (!is.null(pattern)) {
[08:24:58.924]                           computeRestarts <- base::computeRestarts
[08:24:58.924]                           grepl <- base::grepl
[08:24:58.924]                           restarts <- computeRestarts(cond)
[08:24:58.924]                           for (restart in restarts) {
[08:24:58.924]                             name <- restart$name
[08:24:58.924]                             if (is.null(name)) 
[08:24:58.924]                               next
[08:24:58.924]                             if (!grepl(pattern, name)) 
[08:24:58.924]                               next
[08:24:58.924]                             invokeRestart(restart)
[08:24:58.924]                             muffled <- TRUE
[08:24:58.924]                             break
[08:24:58.924]                           }
[08:24:58.924]                         }
[08:24:58.924]                       }
[08:24:58.924]                       invisible(muffled)
[08:24:58.924]                     }
[08:24:58.924]                     muffleCondition(cond, pattern = "^muffle")
[08:24:58.924]                   }
[08:24:58.924]                 }
[08:24:58.924]             }
[08:24:58.924]         }))
[08:24:58.924]     }, error = function(ex) {
[08:24:58.924]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:58.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:58.924]                 ...future.rng), started = ...future.startTime, 
[08:24:58.924]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:58.924]             version = "1.8"), class = "FutureResult")
[08:24:58.924]     }, finally = {
[08:24:58.924]         if (!identical(...future.workdir, getwd())) 
[08:24:58.924]             setwd(...future.workdir)
[08:24:58.924]         {
[08:24:58.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:58.924]                 ...future.oldOptions$nwarnings <- NULL
[08:24:58.924]             }
[08:24:58.924]             base::options(...future.oldOptions)
[08:24:58.924]             if (.Platform$OS.type == "windows") {
[08:24:58.924]                 old_names <- names(...future.oldEnvVars)
[08:24:58.924]                 envs <- base::Sys.getenv()
[08:24:58.924]                 names <- names(envs)
[08:24:58.924]                 common <- intersect(names, old_names)
[08:24:58.924]                 added <- setdiff(names, old_names)
[08:24:58.924]                 removed <- setdiff(old_names, names)
[08:24:58.924]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:58.924]                   envs[common]]
[08:24:58.924]                 NAMES <- toupper(changed)
[08:24:58.924]                 args <- list()
[08:24:58.924]                 for (kk in seq_along(NAMES)) {
[08:24:58.924]                   name <- changed[[kk]]
[08:24:58.924]                   NAME <- NAMES[[kk]]
[08:24:58.924]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.924]                     next
[08:24:58.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.924]                 }
[08:24:58.924]                 NAMES <- toupper(added)
[08:24:58.924]                 for (kk in seq_along(NAMES)) {
[08:24:58.924]                   name <- added[[kk]]
[08:24:58.924]                   NAME <- NAMES[[kk]]
[08:24:58.924]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.924]                     next
[08:24:58.924]                   args[[name]] <- ""
[08:24:58.924]                 }
[08:24:58.924]                 NAMES <- toupper(removed)
[08:24:58.924]                 for (kk in seq_along(NAMES)) {
[08:24:58.924]                   name <- removed[[kk]]
[08:24:58.924]                   NAME <- NAMES[[kk]]
[08:24:58.924]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:58.924]                     next
[08:24:58.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:58.924]                 }
[08:24:58.924]                 if (length(args) > 0) 
[08:24:58.924]                   base::do.call(base::Sys.setenv, args = args)
[08:24:58.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:58.924]             }
[08:24:58.924]             else {
[08:24:58.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:58.924]             }
[08:24:58.924]             {
[08:24:58.924]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:58.924]                   0L) {
[08:24:58.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:58.924]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:58.924]                   base::options(opts)
[08:24:58.924]                 }
[08:24:58.924]                 {
[08:24:58.924]                   {
[08:24:58.924]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:58.924]                     NULL
[08:24:58.924]                   }
[08:24:58.924]                   options(future.plan = NULL)
[08:24:58.924]                   if (is.na(NA_character_)) 
[08:24:58.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:58.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:58.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:58.924]                     .init = FALSE)
[08:24:58.924]                 }
[08:24:58.924]             }
[08:24:58.924]         }
[08:24:58.924]     })
[08:24:58.924]     if (TRUE) {
[08:24:58.924]         base::sink(type = "output", split = FALSE)
[08:24:58.924]         if (TRUE) {
[08:24:58.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:58.924]         }
[08:24:58.924]         else {
[08:24:58.924]             ...future.result["stdout"] <- base::list(NULL)
[08:24:58.924]         }
[08:24:58.924]         base::close(...future.stdout)
[08:24:58.924]         ...future.stdout <- NULL
[08:24:58.924]     }
[08:24:58.924]     ...future.result$conditions <- ...future.conditions
[08:24:58.924]     ...future.result$finished <- base::Sys.time()
[08:24:58.924]     ...future.result
[08:24:58.924] }
[08:24:58.978] Exporting 5 global objects (1.86 KiB) to cluster node #2 ...
[08:24:58.978] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[08:24:58.979] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[08:24:58.979] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:58.979] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:58.979] Exporting ‘...future.elements_ii’ (1.02 KiB) to cluster node #2 ...
[08:24:58.980] Exporting ‘...future.elements_ii’ (1.02 KiB) to cluster node #2 ... DONE
[08:24:58.980] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:58.980] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:58.980] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:24:58.981] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:24:58.981] Exporting 5 global objects (1.86 KiB) to cluster node #2 ... DONE
[08:24:58.981] MultisessionFuture started
[08:24:58.982] - Launch lazy future ... done
[08:24:58.982] run() for ‘MultisessionFuture’ ... done
[08:24:58.982] Created future:
[08:24:58.982] MultisessionFuture:
[08:24:58.982] Label: ‘future_by-2’
[08:24:58.982] Expression:
[08:24:58.982] {
[08:24:58.982]     do.call(function(...) {
[08:24:58.982]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:58.982]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:58.982]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:58.982]             on.exit(options(oopts), add = TRUE)
[08:24:58.982]         }
[08:24:58.982]         {
[08:24:58.982]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:58.982]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:58.982]                 ...future.FUN(...future.X_jj, ...)
[08:24:58.982]             })
[08:24:58.982]         }
[08:24:58.982]     }, args = future.call.arguments)
[08:24:58.982] }
[08:24:58.982] Lazy evaluation: FALSE
[08:24:58.982] Asynchronous evaluation: TRUE
[08:24:58.982] Local evaluation: TRUE
[08:24:58.982] Environment: R_GlobalEnv
[08:24:58.982] Capture standard output: TRUE
[08:24:58.982] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:58.982] Globals: 5 objects totaling 1.44 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.02 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:58.982] Packages: <none>
[08:24:58.982] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:58.982] Resolved: FALSE
[08:24:58.982] Value: <not collected>
[08:24:58.982] Conditions captured: <none>
[08:24:58.982] Early signaling: FALSE
[08:24:58.982] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:58.982] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:58.993] Chunk #2 of 2 ... DONE
[08:24:58.994] Launching 2 futures (chunks) ... DONE
[08:24:58.994] Resolving 2 futures (chunks) ...
[08:24:58.994] resolve() on list ...
[08:24:58.994]  recursive: 0
[08:24:58.994]  length: 2
[08:24:58.994] 
[08:24:58.994] receiveMessageFromWorker() for ClusterFuture ...
[08:24:58.995] - Validating connection of MultisessionFuture
[08:24:58.995] - received message: FutureResult
[08:24:58.995] - Received FutureResult
[08:24:58.995] - Erased future from FutureRegistry
[08:24:58.995] result() for ClusterFuture ...
[08:24:58.995] - result already collected: FutureResult
[08:24:58.995] result() for ClusterFuture ... done
[08:24:58.995] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:58.995] Future #1
[08:24:58.996] result() for ClusterFuture ...
[08:24:58.996] - result already collected: FutureResult
[08:24:58.996] result() for ClusterFuture ... done
[08:24:58.996] result() for ClusterFuture ...
[08:24:58.996] - result already collected: FutureResult
[08:24:58.996] result() for ClusterFuture ... done
[08:24:58.996] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:58.996] - nx: 2
[08:24:58.996] - relay: TRUE
[08:24:58.996] - stdout: TRUE
[08:24:58.996] - signal: TRUE
[08:24:58.996] - resignal: FALSE
[08:24:58.996] - force: TRUE
[08:24:58.997] - relayed: [n=2] FALSE, FALSE
[08:24:58.997] - queued futures: [n=2] FALSE, FALSE
[08:24:58.997]  - until=1
[08:24:58.997]  - relaying element #1
[08:24:58.997] result() for ClusterFuture ...
[08:24:58.997] - result already collected: FutureResult
[08:24:58.997] result() for ClusterFuture ... done
[08:24:58.997] result() for ClusterFuture ...
[08:24:58.997] - result already collected: FutureResult
[08:24:58.997] result() for ClusterFuture ... done
[08:24:58.997] result() for ClusterFuture ...
[08:24:58.998] - result already collected: FutureResult
[08:24:58.998] result() for ClusterFuture ... done
[08:24:58.998] result() for ClusterFuture ...
[08:24:58.998] - result already collected: FutureResult
[08:24:58.998] result() for ClusterFuture ... done
[08:24:58.998] - relayed: [n=2] TRUE, FALSE
[08:24:58.998] - queued futures: [n=2] TRUE, FALSE
[08:24:58.998] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:58.998]  length: 1 (resolved future 1)
[08:24:59.063] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.063] - Validating connection of MultisessionFuture
[08:24:59.063] - received message: FutureResult
[08:24:59.063] - Received FutureResult
[08:24:59.063] - Erased future from FutureRegistry
[08:24:59.063] result() for ClusterFuture ...
[08:24:59.063] - result already collected: FutureResult
[08:24:59.064] result() for ClusterFuture ... done
[08:24:59.064] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.064] Future #2
[08:24:59.064] result() for ClusterFuture ...
[08:24:59.064] - result already collected: FutureResult
[08:24:59.064] result() for ClusterFuture ... done
[08:24:59.064] result() for ClusterFuture ...
[08:24:59.064] - result already collected: FutureResult
[08:24:59.064] result() for ClusterFuture ... done
[08:24:59.064] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:59.064] - nx: 2
[08:24:59.065] - relay: TRUE
[08:24:59.065] - stdout: TRUE
[08:24:59.065] - signal: TRUE
[08:24:59.065] - resignal: FALSE
[08:24:59.065] - force: TRUE
[08:24:59.065] - relayed: [n=2] TRUE, FALSE
[08:24:59.065] - queued futures: [n=2] TRUE, FALSE
[08:24:59.065]  - until=2
[08:24:59.065]  - relaying element #2
[08:24:59.065] result() for ClusterFuture ...
[08:24:59.065] - result already collected: FutureResult
[08:24:59.065] result() for ClusterFuture ... done
[08:24:59.066] result() for ClusterFuture ...
[08:24:59.066] - result already collected: FutureResult
[08:24:59.066] result() for ClusterFuture ... done
[08:24:59.066] result() for ClusterFuture ...
[08:24:59.066] - result already collected: FutureResult
[08:24:59.066] result() for ClusterFuture ... done
[08:24:59.066] result() for ClusterFuture ...
[08:24:59.066] - result already collected: FutureResult
[08:24:59.066] result() for ClusterFuture ... done
[08:24:59.066] - relayed: [n=2] TRUE, TRUE
[08:24:59.066] - queued futures: [n=2] TRUE, TRUE
[08:24:59.066] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:59.067]  length: 0 (resolved future 2)
[08:24:59.067] Relaying remaining futures
[08:24:59.067] signalConditionsASAP(NULL, pos=0) ...
[08:24:59.067] - nx: 2
[08:24:59.067] - relay: TRUE
[08:24:59.067] - stdout: TRUE
[08:24:59.067] - signal: TRUE
[08:24:59.067] - resignal: FALSE
[08:24:59.067] - force: TRUE
[08:24:59.067] - relayed: [n=2] TRUE, TRUE
[08:24:59.067] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:59.067] - relayed: [n=2] TRUE, TRUE
[08:24:59.068] - queued futures: [n=2] TRUE, TRUE
[08:24:59.068] signalConditionsASAP(NULL, pos=0) ... done
[08:24:59.068] resolve() on list ... DONE
[08:24:59.068] result() for ClusterFuture ...
[08:24:59.068] - result already collected: FutureResult
[08:24:59.068] result() for ClusterFuture ... done
[08:24:59.068] result() for ClusterFuture ...
[08:24:59.068] - result already collected: FutureResult
[08:24:59.068] result() for ClusterFuture ... done
[08:24:59.068] result() for ClusterFuture ...
[08:24:59.068] - result already collected: FutureResult
[08:24:59.068] result() for ClusterFuture ... done
[08:24:59.069] result() for ClusterFuture ...
[08:24:59.069] - result already collected: FutureResult
[08:24:59.069] result() for ClusterFuture ... done
[08:24:59.069]  - Number of value chunks collected: 2
[08:24:59.069] Resolving 2 futures (chunks) ... DONE
[08:24:59.069] Reducing values from 2 chunks ...
[08:24:59.069]  - Number of values collected after concatenation: 3
[08:24:59.069]  - Number of values expected: 3
[08:24:59.069] Reducing values from 2 chunks ... DONE
[08:24:59.069] future_lapply() ... DONE
[08:24:59.069] future_by_internal() ... DONE
[08:24:59.070] future_by_internal() ...
[08:24:59.070] future_lapply() ...
[08:24:59.072] Number of chunks: 2
[08:24:59.072] getGlobalsAndPackagesXApply() ...
[08:24:59.072]  - future.globals: TRUE
[08:24:59.072] getGlobalsAndPackages() ...
[08:24:59.073] Searching for globals...
[08:24:59.074] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:59.074] Searching for globals ... DONE
[08:24:59.074] Resolving globals: FALSE
[08:24:59.074] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:59.075] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:59.075] - globals: [1] ‘FUN’
[08:24:59.075] 
[08:24:59.075] getGlobalsAndPackages() ... DONE
[08:24:59.075]  - globals found/used: [n=1] ‘FUN’
[08:24:59.075]  - needed namespaces: [n=0] 
[08:24:59.075] Finding globals ... DONE
[08:24:59.075]  - use_args: TRUE
[08:24:59.075]  - Getting '...' globals ...
[08:24:59.076] resolve() on list ...
[08:24:59.076]  recursive: 0
[08:24:59.076]  length: 1
[08:24:59.076]  elements: ‘...’
[08:24:59.076]  length: 0 (resolved future 1)
[08:24:59.076] resolve() on list ... DONE
[08:24:59.076]    - '...' content: [n=1] ‘digits’
[08:24:59.076] List of 1
[08:24:59.076]  $ ...:List of 1
[08:24:59.076]   ..$ digits: int 2
[08:24:59.076]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.076]  - attr(*, "where")=List of 1
[08:24:59.076]   ..$ ...:<environment: 0x557b284a53e8> 
[08:24:59.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.076]  - attr(*, "resolved")= logi TRUE
[08:24:59.076]  - attr(*, "total_size")= num NA
[08:24:59.079]  - Getting '...' globals ... DONE
[08:24:59.080] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:59.080] List of 2
[08:24:59.080]  $ ...future.FUN:function (object, ...)  
[08:24:59.080]  $ ...          :List of 1
[08:24:59.080]   ..$ digits: int 2
[08:24:59.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.080]  - attr(*, "where")=List of 2
[08:24:59.080]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:59.080]   ..$ ...          :<environment: 0x557b284a53e8> 
[08:24:59.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.080]  - attr(*, "resolved")= logi FALSE
[08:24:59.080]  - attr(*, "total_size")= num 13284
[08:24:59.083] Packages to be attached in all futures: [n=0] 
[08:24:59.083] getGlobalsAndPackagesXApply() ... DONE
[08:24:59.083] Number of futures (= number of chunks): 2
[08:24:59.083] Launching 2 futures (chunks) ...
[08:24:59.083] Chunk #1 of 2 ...
[08:24:59.084]  - Finding globals in 'X' for chunk #1 ...
[08:24:59.084] getGlobalsAndPackages() ...
[08:24:59.084] Searching for globals...
[08:24:59.084] 
[08:24:59.084] Searching for globals ... DONE
[08:24:59.084] - globals: [0] <none>
[08:24:59.084] getGlobalsAndPackages() ... DONE
[08:24:59.084]    + additional globals found: [n=0] 
[08:24:59.084]    + additional namespaces needed: [n=0] 
[08:24:59.085]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:59.085]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.085]  - seeds: <none>
[08:24:59.085]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.085] getGlobalsAndPackages() ...
[08:24:59.085] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.085] Resolving globals: FALSE
[08:24:59.085] Tweak future expression to call with '...' arguments ...
[08:24:59.085] {
[08:24:59.085]     do.call(function(...) {
[08:24:59.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.085]             on.exit(options(oopts), add = TRUE)
[08:24:59.085]         }
[08:24:59.085]         {
[08:24:59.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.085]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.085]             })
[08:24:59.085]         }
[08:24:59.085]     }, args = future.call.arguments)
[08:24:59.085] }
[08:24:59.086] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.086] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.086] 
[08:24:59.086] getGlobalsAndPackages() ... DONE
[08:24:59.087] run() for ‘Future’ ...
[08:24:59.087] - state: ‘created’
[08:24:59.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.103] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.103]   - Field: ‘node’
[08:24:59.103]   - Field: ‘label’
[08:24:59.103]   - Field: ‘local’
[08:24:59.103]   - Field: ‘owner’
[08:24:59.103]   - Field: ‘envir’
[08:24:59.104]   - Field: ‘workers’
[08:24:59.104]   - Field: ‘packages’
[08:24:59.104]   - Field: ‘gc’
[08:24:59.104]   - Field: ‘conditions’
[08:24:59.104]   - Field: ‘persistent’
[08:24:59.104]   - Field: ‘expr’
[08:24:59.104]   - Field: ‘uuid’
[08:24:59.104]   - Field: ‘seed’
[08:24:59.104]   - Field: ‘version’
[08:24:59.104]   - Field: ‘result’
[08:24:59.104]   - Field: ‘asynchronous’
[08:24:59.104]   - Field: ‘calls’
[08:24:59.105]   - Field: ‘globals’
[08:24:59.105]   - Field: ‘stdout’
[08:24:59.105]   - Field: ‘earlySignal’
[08:24:59.105]   - Field: ‘lazy’
[08:24:59.105]   - Field: ‘state’
[08:24:59.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.105] - Launch lazy future ...
[08:24:59.105] Packages needed by the future expression (n = 0): <none>
[08:24:59.105] Packages needed by future strategies (n = 0): <none>
[08:24:59.106] {
[08:24:59.106]     {
[08:24:59.106]         {
[08:24:59.106]             ...future.startTime <- base::Sys.time()
[08:24:59.106]             {
[08:24:59.106]                 {
[08:24:59.106]                   {
[08:24:59.106]                     {
[08:24:59.106]                       base::local({
[08:24:59.106]                         has_future <- base::requireNamespace("future", 
[08:24:59.106]                           quietly = TRUE)
[08:24:59.106]                         if (has_future) {
[08:24:59.106]                           ns <- base::getNamespace("future")
[08:24:59.106]                           version <- ns[[".package"]][["version"]]
[08:24:59.106]                           if (is.null(version)) 
[08:24:59.106]                             version <- utils::packageVersion("future")
[08:24:59.106]                         }
[08:24:59.106]                         else {
[08:24:59.106]                           version <- NULL
[08:24:59.106]                         }
[08:24:59.106]                         if (!has_future || version < "1.8.0") {
[08:24:59.106]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.106]                             "", base::R.version$version.string), 
[08:24:59.106]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:59.106]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:59.106]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.106]                               "release", "version")], collapse = " "), 
[08:24:59.106]                             hostname = base::Sys.info()[["nodename"]])
[08:24:59.106]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.106]                             info)
[08:24:59.106]                           info <- base::paste(info, collapse = "; ")
[08:24:59.106]                           if (!has_future) {
[08:24:59.106]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.106]                               info)
[08:24:59.106]                           }
[08:24:59.106]                           else {
[08:24:59.106]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.106]                               info, version)
[08:24:59.106]                           }
[08:24:59.106]                           base::stop(msg)
[08:24:59.106]                         }
[08:24:59.106]                       })
[08:24:59.106]                     }
[08:24:59.106]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.106]                     base::options(mc.cores = 1L)
[08:24:59.106]                   }
[08:24:59.106]                   ...future.strategy.old <- future::plan("list")
[08:24:59.106]                   options(future.plan = NULL)
[08:24:59.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.106]                 }
[08:24:59.106]                 ...future.workdir <- getwd()
[08:24:59.106]             }
[08:24:59.106]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.106]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.106]         }
[08:24:59.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.106]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.106]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.106]             base::names(...future.oldOptions))
[08:24:59.106]     }
[08:24:59.106]     if (FALSE) {
[08:24:59.106]     }
[08:24:59.106]     else {
[08:24:59.106]         if (TRUE) {
[08:24:59.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.106]                 open = "w")
[08:24:59.106]         }
[08:24:59.106]         else {
[08:24:59.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.106]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.106]         }
[08:24:59.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.106]             base::sink(type = "output", split = FALSE)
[08:24:59.106]             base::close(...future.stdout)
[08:24:59.106]         }, add = TRUE)
[08:24:59.106]     }
[08:24:59.106]     ...future.frame <- base::sys.nframe()
[08:24:59.106]     ...future.conditions <- base::list()
[08:24:59.106]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.106]     if (FALSE) {
[08:24:59.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.106]     }
[08:24:59.106]     ...future.result <- base::tryCatch({
[08:24:59.106]         base::withCallingHandlers({
[08:24:59.106]             ...future.value <- base::withVisible(base::local({
[08:24:59.106]                 ...future.makeSendCondition <- base::local({
[08:24:59.106]                   sendCondition <- NULL
[08:24:59.106]                   function(frame = 1L) {
[08:24:59.106]                     if (is.function(sendCondition)) 
[08:24:59.106]                       return(sendCondition)
[08:24:59.106]                     ns <- getNamespace("parallel")
[08:24:59.106]                     if (exists("sendData", mode = "function", 
[08:24:59.106]                       envir = ns)) {
[08:24:59.106]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.106]                         envir = ns)
[08:24:59.106]                       envir <- sys.frame(frame)
[08:24:59.106]                       master <- NULL
[08:24:59.106]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.106]                         !identical(envir, emptyenv())) {
[08:24:59.106]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.106]                           inherits = FALSE)) {
[08:24:59.106]                           master <- get("master", mode = "list", 
[08:24:59.106]                             envir = envir, inherits = FALSE)
[08:24:59.106]                           if (inherits(master, c("SOCKnode", 
[08:24:59.106]                             "SOCK0node"))) {
[08:24:59.106]                             sendCondition <<- function(cond) {
[08:24:59.106]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.106]                                 success = TRUE)
[08:24:59.106]                               parallel_sendData(master, data)
[08:24:59.106]                             }
[08:24:59.106]                             return(sendCondition)
[08:24:59.106]                           }
[08:24:59.106]                         }
[08:24:59.106]                         frame <- frame + 1L
[08:24:59.106]                         envir <- sys.frame(frame)
[08:24:59.106]                       }
[08:24:59.106]                     }
[08:24:59.106]                     sendCondition <<- function(cond) NULL
[08:24:59.106]                   }
[08:24:59.106]                 })
[08:24:59.106]                 withCallingHandlers({
[08:24:59.106]                   {
[08:24:59.106]                     do.call(function(...) {
[08:24:59.106]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.106]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.106]                         ...future.globals.maxSize)) {
[08:24:59.106]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.106]                         on.exit(options(oopts), add = TRUE)
[08:24:59.106]                       }
[08:24:59.106]                       {
[08:24:59.106]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.106]                           FUN = function(jj) {
[08:24:59.106]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.106]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.106]                           })
[08:24:59.106]                       }
[08:24:59.106]                     }, args = future.call.arguments)
[08:24:59.106]                   }
[08:24:59.106]                 }, immediateCondition = function(cond) {
[08:24:59.106]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.106]                   sendCondition(cond)
[08:24:59.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.106]                   {
[08:24:59.106]                     inherits <- base::inherits
[08:24:59.106]                     invokeRestart <- base::invokeRestart
[08:24:59.106]                     is.null <- base::is.null
[08:24:59.106]                     muffled <- FALSE
[08:24:59.106]                     if (inherits(cond, "message")) {
[08:24:59.106]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.106]                       if (muffled) 
[08:24:59.106]                         invokeRestart("muffleMessage")
[08:24:59.106]                     }
[08:24:59.106]                     else if (inherits(cond, "warning")) {
[08:24:59.106]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.106]                       if (muffled) 
[08:24:59.106]                         invokeRestart("muffleWarning")
[08:24:59.106]                     }
[08:24:59.106]                     else if (inherits(cond, "condition")) {
[08:24:59.106]                       if (!is.null(pattern)) {
[08:24:59.106]                         computeRestarts <- base::computeRestarts
[08:24:59.106]                         grepl <- base::grepl
[08:24:59.106]                         restarts <- computeRestarts(cond)
[08:24:59.106]                         for (restart in restarts) {
[08:24:59.106]                           name <- restart$name
[08:24:59.106]                           if (is.null(name)) 
[08:24:59.106]                             next
[08:24:59.106]                           if (!grepl(pattern, name)) 
[08:24:59.106]                             next
[08:24:59.106]                           invokeRestart(restart)
[08:24:59.106]                           muffled <- TRUE
[08:24:59.106]                           break
[08:24:59.106]                         }
[08:24:59.106]                       }
[08:24:59.106]                     }
[08:24:59.106]                     invisible(muffled)
[08:24:59.106]                   }
[08:24:59.106]                   muffleCondition(cond)
[08:24:59.106]                 })
[08:24:59.106]             }))
[08:24:59.106]             future::FutureResult(value = ...future.value$value, 
[08:24:59.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.106]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.106]                     ...future.globalenv.names))
[08:24:59.106]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.106]         }, condition = base::local({
[08:24:59.106]             c <- base::c
[08:24:59.106]             inherits <- base::inherits
[08:24:59.106]             invokeRestart <- base::invokeRestart
[08:24:59.106]             length <- base::length
[08:24:59.106]             list <- base::list
[08:24:59.106]             seq.int <- base::seq.int
[08:24:59.106]             signalCondition <- base::signalCondition
[08:24:59.106]             sys.calls <- base::sys.calls
[08:24:59.106]             `[[` <- base::`[[`
[08:24:59.106]             `+` <- base::`+`
[08:24:59.106]             `<<-` <- base::`<<-`
[08:24:59.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.106]                   3L)]
[08:24:59.106]             }
[08:24:59.106]             function(cond) {
[08:24:59.106]                 is_error <- inherits(cond, "error")
[08:24:59.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.106]                   NULL)
[08:24:59.106]                 if (is_error) {
[08:24:59.106]                   sessionInformation <- function() {
[08:24:59.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.106]                       search = base::search(), system = base::Sys.info())
[08:24:59.106]                   }
[08:24:59.106]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.106]                     cond$call), session = sessionInformation(), 
[08:24:59.106]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.106]                   signalCondition(cond)
[08:24:59.106]                 }
[08:24:59.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.106]                 "immediateCondition"))) {
[08:24:59.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.106]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.106]                   if (TRUE && !signal) {
[08:24:59.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.106]                     {
[08:24:59.106]                       inherits <- base::inherits
[08:24:59.106]                       invokeRestart <- base::invokeRestart
[08:24:59.106]                       is.null <- base::is.null
[08:24:59.106]                       muffled <- FALSE
[08:24:59.106]                       if (inherits(cond, "message")) {
[08:24:59.106]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.106]                         if (muffled) 
[08:24:59.106]                           invokeRestart("muffleMessage")
[08:24:59.106]                       }
[08:24:59.106]                       else if (inherits(cond, "warning")) {
[08:24:59.106]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.106]                         if (muffled) 
[08:24:59.106]                           invokeRestart("muffleWarning")
[08:24:59.106]                       }
[08:24:59.106]                       else if (inherits(cond, "condition")) {
[08:24:59.106]                         if (!is.null(pattern)) {
[08:24:59.106]                           computeRestarts <- base::computeRestarts
[08:24:59.106]                           grepl <- base::grepl
[08:24:59.106]                           restarts <- computeRestarts(cond)
[08:24:59.106]                           for (restart in restarts) {
[08:24:59.106]                             name <- restart$name
[08:24:59.106]                             if (is.null(name)) 
[08:24:59.106]                               next
[08:24:59.106]                             if (!grepl(pattern, name)) 
[08:24:59.106]                               next
[08:24:59.106]                             invokeRestart(restart)
[08:24:59.106]                             muffled <- TRUE
[08:24:59.106]                             break
[08:24:59.106]                           }
[08:24:59.106]                         }
[08:24:59.106]                       }
[08:24:59.106]                       invisible(muffled)
[08:24:59.106]                     }
[08:24:59.106]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.106]                   }
[08:24:59.106]                 }
[08:24:59.106]                 else {
[08:24:59.106]                   if (TRUE) {
[08:24:59.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.106]                     {
[08:24:59.106]                       inherits <- base::inherits
[08:24:59.106]                       invokeRestart <- base::invokeRestart
[08:24:59.106]                       is.null <- base::is.null
[08:24:59.106]                       muffled <- FALSE
[08:24:59.106]                       if (inherits(cond, "message")) {
[08:24:59.106]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.106]                         if (muffled) 
[08:24:59.106]                           invokeRestart("muffleMessage")
[08:24:59.106]                       }
[08:24:59.106]                       else if (inherits(cond, "warning")) {
[08:24:59.106]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.106]                         if (muffled) 
[08:24:59.106]                           invokeRestart("muffleWarning")
[08:24:59.106]                       }
[08:24:59.106]                       else if (inherits(cond, "condition")) {
[08:24:59.106]                         if (!is.null(pattern)) {
[08:24:59.106]                           computeRestarts <- base::computeRestarts
[08:24:59.106]                           grepl <- base::grepl
[08:24:59.106]                           restarts <- computeRestarts(cond)
[08:24:59.106]                           for (restart in restarts) {
[08:24:59.106]                             name <- restart$name
[08:24:59.106]                             if (is.null(name)) 
[08:24:59.106]                               next
[08:24:59.106]                             if (!grepl(pattern, name)) 
[08:24:59.106]                               next
[08:24:59.106]                             invokeRestart(restart)
[08:24:59.106]                             muffled <- TRUE
[08:24:59.106]                             break
[08:24:59.106]                           }
[08:24:59.106]                         }
[08:24:59.106]                       }
[08:24:59.106]                       invisible(muffled)
[08:24:59.106]                     }
[08:24:59.106]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.106]                   }
[08:24:59.106]                 }
[08:24:59.106]             }
[08:24:59.106]         }))
[08:24:59.106]     }, error = function(ex) {
[08:24:59.106]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.106]                 ...future.rng), started = ...future.startTime, 
[08:24:59.106]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.106]             version = "1.8"), class = "FutureResult")
[08:24:59.106]     }, finally = {
[08:24:59.106]         if (!identical(...future.workdir, getwd())) 
[08:24:59.106]             setwd(...future.workdir)
[08:24:59.106]         {
[08:24:59.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.106]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.106]             }
[08:24:59.106]             base::options(...future.oldOptions)
[08:24:59.106]             if (.Platform$OS.type == "windows") {
[08:24:59.106]                 old_names <- names(...future.oldEnvVars)
[08:24:59.106]                 envs <- base::Sys.getenv()
[08:24:59.106]                 names <- names(envs)
[08:24:59.106]                 common <- intersect(names, old_names)
[08:24:59.106]                 added <- setdiff(names, old_names)
[08:24:59.106]                 removed <- setdiff(old_names, names)
[08:24:59.106]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.106]                   envs[common]]
[08:24:59.106]                 NAMES <- toupper(changed)
[08:24:59.106]                 args <- list()
[08:24:59.106]                 for (kk in seq_along(NAMES)) {
[08:24:59.106]                   name <- changed[[kk]]
[08:24:59.106]                   NAME <- NAMES[[kk]]
[08:24:59.106]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.106]                     next
[08:24:59.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.106]                 }
[08:24:59.106]                 NAMES <- toupper(added)
[08:24:59.106]                 for (kk in seq_along(NAMES)) {
[08:24:59.106]                   name <- added[[kk]]
[08:24:59.106]                   NAME <- NAMES[[kk]]
[08:24:59.106]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.106]                     next
[08:24:59.106]                   args[[name]] <- ""
[08:24:59.106]                 }
[08:24:59.106]                 NAMES <- toupper(removed)
[08:24:59.106]                 for (kk in seq_along(NAMES)) {
[08:24:59.106]                   name <- removed[[kk]]
[08:24:59.106]                   NAME <- NAMES[[kk]]
[08:24:59.106]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.106]                     next
[08:24:59.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.106]                 }
[08:24:59.106]                 if (length(args) > 0) 
[08:24:59.106]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.106]             }
[08:24:59.106]             else {
[08:24:59.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.106]             }
[08:24:59.106]             {
[08:24:59.106]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.106]                   0L) {
[08:24:59.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.106]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.106]                   base::options(opts)
[08:24:59.106]                 }
[08:24:59.106]                 {
[08:24:59.106]                   {
[08:24:59.106]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.106]                     NULL
[08:24:59.106]                   }
[08:24:59.106]                   options(future.plan = NULL)
[08:24:59.106]                   if (is.na(NA_character_)) 
[08:24:59.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.106]                     .init = FALSE)
[08:24:59.106]                 }
[08:24:59.106]             }
[08:24:59.106]         }
[08:24:59.106]     })
[08:24:59.106]     if (TRUE) {
[08:24:59.106]         base::sink(type = "output", split = FALSE)
[08:24:59.106]         if (TRUE) {
[08:24:59.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.106]         }
[08:24:59.106]         else {
[08:24:59.106]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.106]         }
[08:24:59.106]         base::close(...future.stdout)
[08:24:59.106]         ...future.stdout <- NULL
[08:24:59.106]     }
[08:24:59.106]     ...future.result$conditions <- ...future.conditions
[08:24:59.106]     ...future.result$finished <- base::Sys.time()
[08:24:59.106]     ...future.result
[08:24:59.106] }
[08:24:59.109] Exporting 5 global objects (1.18 KiB) to cluster node #1 ...
[08:24:59.109] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[08:24:59.109] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[08:24:59.109] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #1 ...
[08:24:59.110] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #1 ... DONE
[08:24:59.110] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #1 ...
[08:24:59.110] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #1 ... DONE
[08:24:59.110] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:59.111] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.111] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:24:59.111] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.111] Exporting 5 global objects (1.18 KiB) to cluster node #1 ... DONE
[08:24:59.112] MultisessionFuture started
[08:24:59.112] - Launch lazy future ... done
[08:24:59.112] run() for ‘MultisessionFuture’ ... done
[08:24:59.112] Created future:
[08:24:59.112] MultisessionFuture:
[08:24:59.112] Label: ‘future_by-1’
[08:24:59.112] Expression:
[08:24:59.112] {
[08:24:59.112]     do.call(function(...) {
[08:24:59.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.112]             on.exit(options(oopts), add = TRUE)
[08:24:59.112]         }
[08:24:59.112]         {
[08:24:59.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.112]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.112]             })
[08:24:59.112]         }
[08:24:59.112]     }, args = future.call.arguments)
[08:24:59.112] }
[08:24:59.112] Lazy evaluation: FALSE
[08:24:59.112] Asynchronous evaluation: TRUE
[08:24:59.112] Local evaluation: TRUE
[08:24:59.112] Environment: R_GlobalEnv
[08:24:59.112] Capture standard output: TRUE
[08:24:59.112] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.112] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:59.112] Packages: <none>
[08:24:59.112] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.112] Resolved: FALSE
[08:24:59.112] Value: <not collected>
[08:24:59.112] Conditions captured: <none>
[08:24:59.112] Early signaling: FALSE
[08:24:59.112] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.112] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.123] Chunk #1 of 2 ... DONE
[08:24:59.123] Chunk #2 of 2 ...
[08:24:59.124]  - Finding globals in 'X' for chunk #2 ...
[08:24:59.124] getGlobalsAndPackages() ...
[08:24:59.124] Searching for globals...
[08:24:59.124] 
[08:24:59.124] Searching for globals ... DONE
[08:24:59.124] - globals: [0] <none>
[08:24:59.124] getGlobalsAndPackages() ... DONE
[08:24:59.124]    + additional globals found: [n=0] 
[08:24:59.125]    + additional namespaces needed: [n=0] 
[08:24:59.125]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:59.125]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.125]  - seeds: <none>
[08:24:59.125]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.125] getGlobalsAndPackages() ...
[08:24:59.125] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.125] Resolving globals: FALSE
[08:24:59.125] Tweak future expression to call with '...' arguments ...
[08:24:59.125] {
[08:24:59.125]     do.call(function(...) {
[08:24:59.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.125]             on.exit(options(oopts), add = TRUE)
[08:24:59.125]         }
[08:24:59.125]         {
[08:24:59.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.125]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.125]             })
[08:24:59.125]         }
[08:24:59.125]     }, args = future.call.arguments)
[08:24:59.125] }
[08:24:59.126] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.126] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.126] 
[08:24:59.126] getGlobalsAndPackages() ... DONE
[08:24:59.126] run() for ‘Future’ ...
[08:24:59.127] - state: ‘created’
[08:24:59.127] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.140] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.141]   - Field: ‘node’
[08:24:59.141]   - Field: ‘label’
[08:24:59.141]   - Field: ‘local’
[08:24:59.141]   - Field: ‘owner’
[08:24:59.141]   - Field: ‘envir’
[08:24:59.141]   - Field: ‘workers’
[08:24:59.141]   - Field: ‘packages’
[08:24:59.141]   - Field: ‘gc’
[08:24:59.141]   - Field: ‘conditions’
[08:24:59.141]   - Field: ‘persistent’
[08:24:59.142]   - Field: ‘expr’
[08:24:59.142]   - Field: ‘uuid’
[08:24:59.142]   - Field: ‘seed’
[08:24:59.142]   - Field: ‘version’
[08:24:59.142]   - Field: ‘result’
[08:24:59.142]   - Field: ‘asynchronous’
[08:24:59.142]   - Field: ‘calls’
[08:24:59.142]   - Field: ‘globals’
[08:24:59.142]   - Field: ‘stdout’
[08:24:59.142]   - Field: ‘earlySignal’
[08:24:59.142]   - Field: ‘lazy’
[08:24:59.142]   - Field: ‘state’
[08:24:59.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.143] - Launch lazy future ...
[08:24:59.143] Packages needed by the future expression (n = 0): <none>
[08:24:59.143] Packages needed by future strategies (n = 0): <none>
[08:24:59.143] {
[08:24:59.143]     {
[08:24:59.143]         {
[08:24:59.143]             ...future.startTime <- base::Sys.time()
[08:24:59.143]             {
[08:24:59.143]                 {
[08:24:59.143]                   {
[08:24:59.143]                     {
[08:24:59.143]                       base::local({
[08:24:59.143]                         has_future <- base::requireNamespace("future", 
[08:24:59.143]                           quietly = TRUE)
[08:24:59.143]                         if (has_future) {
[08:24:59.143]                           ns <- base::getNamespace("future")
[08:24:59.143]                           version <- ns[[".package"]][["version"]]
[08:24:59.143]                           if (is.null(version)) 
[08:24:59.143]                             version <- utils::packageVersion("future")
[08:24:59.143]                         }
[08:24:59.143]                         else {
[08:24:59.143]                           version <- NULL
[08:24:59.143]                         }
[08:24:59.143]                         if (!has_future || version < "1.8.0") {
[08:24:59.143]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.143]                             "", base::R.version$version.string), 
[08:24:59.143]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:59.143]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:59.143]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.143]                               "release", "version")], collapse = " "), 
[08:24:59.143]                             hostname = base::Sys.info()[["nodename"]])
[08:24:59.143]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.143]                             info)
[08:24:59.143]                           info <- base::paste(info, collapse = "; ")
[08:24:59.143]                           if (!has_future) {
[08:24:59.143]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.143]                               info)
[08:24:59.143]                           }
[08:24:59.143]                           else {
[08:24:59.143]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.143]                               info, version)
[08:24:59.143]                           }
[08:24:59.143]                           base::stop(msg)
[08:24:59.143]                         }
[08:24:59.143]                       })
[08:24:59.143]                     }
[08:24:59.143]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.143]                     base::options(mc.cores = 1L)
[08:24:59.143]                   }
[08:24:59.143]                   ...future.strategy.old <- future::plan("list")
[08:24:59.143]                   options(future.plan = NULL)
[08:24:59.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.143]                 }
[08:24:59.143]                 ...future.workdir <- getwd()
[08:24:59.143]             }
[08:24:59.143]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.143]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.143]         }
[08:24:59.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.143]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.143]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.143]             base::names(...future.oldOptions))
[08:24:59.143]     }
[08:24:59.143]     if (FALSE) {
[08:24:59.143]     }
[08:24:59.143]     else {
[08:24:59.143]         if (TRUE) {
[08:24:59.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.143]                 open = "w")
[08:24:59.143]         }
[08:24:59.143]         else {
[08:24:59.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.143]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.143]         }
[08:24:59.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.143]             base::sink(type = "output", split = FALSE)
[08:24:59.143]             base::close(...future.stdout)
[08:24:59.143]         }, add = TRUE)
[08:24:59.143]     }
[08:24:59.143]     ...future.frame <- base::sys.nframe()
[08:24:59.143]     ...future.conditions <- base::list()
[08:24:59.143]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.143]     if (FALSE) {
[08:24:59.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.143]     }
[08:24:59.143]     ...future.result <- base::tryCatch({
[08:24:59.143]         base::withCallingHandlers({
[08:24:59.143]             ...future.value <- base::withVisible(base::local({
[08:24:59.143]                 ...future.makeSendCondition <- base::local({
[08:24:59.143]                   sendCondition <- NULL
[08:24:59.143]                   function(frame = 1L) {
[08:24:59.143]                     if (is.function(sendCondition)) 
[08:24:59.143]                       return(sendCondition)
[08:24:59.143]                     ns <- getNamespace("parallel")
[08:24:59.143]                     if (exists("sendData", mode = "function", 
[08:24:59.143]                       envir = ns)) {
[08:24:59.143]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.143]                         envir = ns)
[08:24:59.143]                       envir <- sys.frame(frame)
[08:24:59.143]                       master <- NULL
[08:24:59.143]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.143]                         !identical(envir, emptyenv())) {
[08:24:59.143]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.143]                           inherits = FALSE)) {
[08:24:59.143]                           master <- get("master", mode = "list", 
[08:24:59.143]                             envir = envir, inherits = FALSE)
[08:24:59.143]                           if (inherits(master, c("SOCKnode", 
[08:24:59.143]                             "SOCK0node"))) {
[08:24:59.143]                             sendCondition <<- function(cond) {
[08:24:59.143]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.143]                                 success = TRUE)
[08:24:59.143]                               parallel_sendData(master, data)
[08:24:59.143]                             }
[08:24:59.143]                             return(sendCondition)
[08:24:59.143]                           }
[08:24:59.143]                         }
[08:24:59.143]                         frame <- frame + 1L
[08:24:59.143]                         envir <- sys.frame(frame)
[08:24:59.143]                       }
[08:24:59.143]                     }
[08:24:59.143]                     sendCondition <<- function(cond) NULL
[08:24:59.143]                   }
[08:24:59.143]                 })
[08:24:59.143]                 withCallingHandlers({
[08:24:59.143]                   {
[08:24:59.143]                     do.call(function(...) {
[08:24:59.143]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.143]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.143]                         ...future.globals.maxSize)) {
[08:24:59.143]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.143]                         on.exit(options(oopts), add = TRUE)
[08:24:59.143]                       }
[08:24:59.143]                       {
[08:24:59.143]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.143]                           FUN = function(jj) {
[08:24:59.143]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.143]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.143]                           })
[08:24:59.143]                       }
[08:24:59.143]                     }, args = future.call.arguments)
[08:24:59.143]                   }
[08:24:59.143]                 }, immediateCondition = function(cond) {
[08:24:59.143]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.143]                   sendCondition(cond)
[08:24:59.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.143]                   {
[08:24:59.143]                     inherits <- base::inherits
[08:24:59.143]                     invokeRestart <- base::invokeRestart
[08:24:59.143]                     is.null <- base::is.null
[08:24:59.143]                     muffled <- FALSE
[08:24:59.143]                     if (inherits(cond, "message")) {
[08:24:59.143]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.143]                       if (muffled) 
[08:24:59.143]                         invokeRestart("muffleMessage")
[08:24:59.143]                     }
[08:24:59.143]                     else if (inherits(cond, "warning")) {
[08:24:59.143]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.143]                       if (muffled) 
[08:24:59.143]                         invokeRestart("muffleWarning")
[08:24:59.143]                     }
[08:24:59.143]                     else if (inherits(cond, "condition")) {
[08:24:59.143]                       if (!is.null(pattern)) {
[08:24:59.143]                         computeRestarts <- base::computeRestarts
[08:24:59.143]                         grepl <- base::grepl
[08:24:59.143]                         restarts <- computeRestarts(cond)
[08:24:59.143]                         for (restart in restarts) {
[08:24:59.143]                           name <- restart$name
[08:24:59.143]                           if (is.null(name)) 
[08:24:59.143]                             next
[08:24:59.143]                           if (!grepl(pattern, name)) 
[08:24:59.143]                             next
[08:24:59.143]                           invokeRestart(restart)
[08:24:59.143]                           muffled <- TRUE
[08:24:59.143]                           break
[08:24:59.143]                         }
[08:24:59.143]                       }
[08:24:59.143]                     }
[08:24:59.143]                     invisible(muffled)
[08:24:59.143]                   }
[08:24:59.143]                   muffleCondition(cond)
[08:24:59.143]                 })
[08:24:59.143]             }))
[08:24:59.143]             future::FutureResult(value = ...future.value$value, 
[08:24:59.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.143]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.143]                     ...future.globalenv.names))
[08:24:59.143]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.143]         }, condition = base::local({
[08:24:59.143]             c <- base::c
[08:24:59.143]             inherits <- base::inherits
[08:24:59.143]             invokeRestart <- base::invokeRestart
[08:24:59.143]             length <- base::length
[08:24:59.143]             list <- base::list
[08:24:59.143]             seq.int <- base::seq.int
[08:24:59.143]             signalCondition <- base::signalCondition
[08:24:59.143]             sys.calls <- base::sys.calls
[08:24:59.143]             `[[` <- base::`[[`
[08:24:59.143]             `+` <- base::`+`
[08:24:59.143]             `<<-` <- base::`<<-`
[08:24:59.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.143]                   3L)]
[08:24:59.143]             }
[08:24:59.143]             function(cond) {
[08:24:59.143]                 is_error <- inherits(cond, "error")
[08:24:59.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.143]                   NULL)
[08:24:59.143]                 if (is_error) {
[08:24:59.143]                   sessionInformation <- function() {
[08:24:59.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.143]                       search = base::search(), system = base::Sys.info())
[08:24:59.143]                   }
[08:24:59.143]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.143]                     cond$call), session = sessionInformation(), 
[08:24:59.143]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.143]                   signalCondition(cond)
[08:24:59.143]                 }
[08:24:59.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.143]                 "immediateCondition"))) {
[08:24:59.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.143]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.143]                   if (TRUE && !signal) {
[08:24:59.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.143]                     {
[08:24:59.143]                       inherits <- base::inherits
[08:24:59.143]                       invokeRestart <- base::invokeRestart
[08:24:59.143]                       is.null <- base::is.null
[08:24:59.143]                       muffled <- FALSE
[08:24:59.143]                       if (inherits(cond, "message")) {
[08:24:59.143]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.143]                         if (muffled) 
[08:24:59.143]                           invokeRestart("muffleMessage")
[08:24:59.143]                       }
[08:24:59.143]                       else if (inherits(cond, "warning")) {
[08:24:59.143]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.143]                         if (muffled) 
[08:24:59.143]                           invokeRestart("muffleWarning")
[08:24:59.143]                       }
[08:24:59.143]                       else if (inherits(cond, "condition")) {
[08:24:59.143]                         if (!is.null(pattern)) {
[08:24:59.143]                           computeRestarts <- base::computeRestarts
[08:24:59.143]                           grepl <- base::grepl
[08:24:59.143]                           restarts <- computeRestarts(cond)
[08:24:59.143]                           for (restart in restarts) {
[08:24:59.143]                             name <- restart$name
[08:24:59.143]                             if (is.null(name)) 
[08:24:59.143]                               next
[08:24:59.143]                             if (!grepl(pattern, name)) 
[08:24:59.143]                               next
[08:24:59.143]                             invokeRestart(restart)
[08:24:59.143]                             muffled <- TRUE
[08:24:59.143]                             break
[08:24:59.143]                           }
[08:24:59.143]                         }
[08:24:59.143]                       }
[08:24:59.143]                       invisible(muffled)
[08:24:59.143]                     }
[08:24:59.143]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.143]                   }
[08:24:59.143]                 }
[08:24:59.143]                 else {
[08:24:59.143]                   if (TRUE) {
[08:24:59.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.143]                     {
[08:24:59.143]                       inherits <- base::inherits
[08:24:59.143]                       invokeRestart <- base::invokeRestart
[08:24:59.143]                       is.null <- base::is.null
[08:24:59.143]                       muffled <- FALSE
[08:24:59.143]                       if (inherits(cond, "message")) {
[08:24:59.143]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.143]                         if (muffled) 
[08:24:59.143]                           invokeRestart("muffleMessage")
[08:24:59.143]                       }
[08:24:59.143]                       else if (inherits(cond, "warning")) {
[08:24:59.143]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.143]                         if (muffled) 
[08:24:59.143]                           invokeRestart("muffleWarning")
[08:24:59.143]                       }
[08:24:59.143]                       else if (inherits(cond, "condition")) {
[08:24:59.143]                         if (!is.null(pattern)) {
[08:24:59.143]                           computeRestarts <- base::computeRestarts
[08:24:59.143]                           grepl <- base::grepl
[08:24:59.143]                           restarts <- computeRestarts(cond)
[08:24:59.143]                           for (restart in restarts) {
[08:24:59.143]                             name <- restart$name
[08:24:59.143]                             if (is.null(name)) 
[08:24:59.143]                               next
[08:24:59.143]                             if (!grepl(pattern, name)) 
[08:24:59.143]                               next
[08:24:59.143]                             invokeRestart(restart)
[08:24:59.143]                             muffled <- TRUE
[08:24:59.143]                             break
[08:24:59.143]                           }
[08:24:59.143]                         }
[08:24:59.143]                       }
[08:24:59.143]                       invisible(muffled)
[08:24:59.143]                     }
[08:24:59.143]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.143]                   }
[08:24:59.143]                 }
[08:24:59.143]             }
[08:24:59.143]         }))
[08:24:59.143]     }, error = function(ex) {
[08:24:59.143]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.143]                 ...future.rng), started = ...future.startTime, 
[08:24:59.143]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.143]             version = "1.8"), class = "FutureResult")
[08:24:59.143]     }, finally = {
[08:24:59.143]         if (!identical(...future.workdir, getwd())) 
[08:24:59.143]             setwd(...future.workdir)
[08:24:59.143]         {
[08:24:59.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.143]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.143]             }
[08:24:59.143]             base::options(...future.oldOptions)
[08:24:59.143]             if (.Platform$OS.type == "windows") {
[08:24:59.143]                 old_names <- names(...future.oldEnvVars)
[08:24:59.143]                 envs <- base::Sys.getenv()
[08:24:59.143]                 names <- names(envs)
[08:24:59.143]                 common <- intersect(names, old_names)
[08:24:59.143]                 added <- setdiff(names, old_names)
[08:24:59.143]                 removed <- setdiff(old_names, names)
[08:24:59.143]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.143]                   envs[common]]
[08:24:59.143]                 NAMES <- toupper(changed)
[08:24:59.143]                 args <- list()
[08:24:59.143]                 for (kk in seq_along(NAMES)) {
[08:24:59.143]                   name <- changed[[kk]]
[08:24:59.143]                   NAME <- NAMES[[kk]]
[08:24:59.143]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.143]                     next
[08:24:59.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.143]                 }
[08:24:59.143]                 NAMES <- toupper(added)
[08:24:59.143]                 for (kk in seq_along(NAMES)) {
[08:24:59.143]                   name <- added[[kk]]
[08:24:59.143]                   NAME <- NAMES[[kk]]
[08:24:59.143]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.143]                     next
[08:24:59.143]                   args[[name]] <- ""
[08:24:59.143]                 }
[08:24:59.143]                 NAMES <- toupper(removed)
[08:24:59.143]                 for (kk in seq_along(NAMES)) {
[08:24:59.143]                   name <- removed[[kk]]
[08:24:59.143]                   NAME <- NAMES[[kk]]
[08:24:59.143]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.143]                     next
[08:24:59.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.143]                 }
[08:24:59.143]                 if (length(args) > 0) 
[08:24:59.143]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.143]             }
[08:24:59.143]             else {
[08:24:59.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.143]             }
[08:24:59.143]             {
[08:24:59.143]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.143]                   0L) {
[08:24:59.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.143]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.143]                   base::options(opts)
[08:24:59.143]                 }
[08:24:59.143]                 {
[08:24:59.143]                   {
[08:24:59.143]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.143]                     NULL
[08:24:59.143]                   }
[08:24:59.143]                   options(future.plan = NULL)
[08:24:59.143]                   if (is.na(NA_character_)) 
[08:24:59.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.143]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.143]                     .init = FALSE)
[08:24:59.143]                 }
[08:24:59.143]             }
[08:24:59.143]         }
[08:24:59.143]     })
[08:24:59.143]     if (TRUE) {
[08:24:59.143]         base::sink(type = "output", split = FALSE)
[08:24:59.143]         if (TRUE) {
[08:24:59.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.143]         }
[08:24:59.143]         else {
[08:24:59.143]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.143]         }
[08:24:59.143]         base::close(...future.stdout)
[08:24:59.143]         ...future.stdout <- NULL
[08:24:59.143]     }
[08:24:59.143]     ...future.result$conditions <- ...future.conditions
[08:24:59.143]     ...future.result$finished <- base::Sys.time()
[08:24:59.143]     ...future.result
[08:24:59.143] }
[08:24:59.146] Exporting 5 global objects (1.18 KiB) to cluster node #2 ...
[08:24:59.146] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[08:24:59.147] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[08:24:59.147] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #2 ...
[08:24:59.147] Exporting ‘future.call.arguments’ (152 bytes) to cluster node #2 ... DONE
[08:24:59.148] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #2 ...
[08:24:59.148] Exporting ‘...future.elements_ii’ (271 bytes) to cluster node #2 ... DONE
[08:24:59.148] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:59.148] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.148] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:24:59.149] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.149] Exporting 5 global objects (1.18 KiB) to cluster node #2 ... DONE
[08:24:59.149] MultisessionFuture started
[08:24:59.150] - Launch lazy future ... done
[08:24:59.150] run() for ‘MultisessionFuture’ ... done
[08:24:59.150] Created future:
[08:24:59.150] MultisessionFuture:
[08:24:59.150] Label: ‘future_by-2’
[08:24:59.150] Expression:
[08:24:59.150] {
[08:24:59.150]     do.call(function(...) {
[08:24:59.150]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.150]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.150]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.150]             on.exit(options(oopts), add = TRUE)
[08:24:59.150]         }
[08:24:59.150]         {
[08:24:59.150]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.150]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.150]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.150]             })
[08:24:59.150]         }
[08:24:59.150]     }, args = future.call.arguments)
[08:24:59.150] }
[08:24:59.150] Lazy evaluation: FALSE
[08:24:59.150] Asynchronous evaluation: TRUE
[08:24:59.150] Local evaluation: TRUE
[08:24:59.150] Environment: R_GlobalEnv
[08:24:59.150] Capture standard output: TRUE
[08:24:59.150] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.150] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 271 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:59.150] Packages: <none>
[08:24:59.150] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.150] Resolved: FALSE
[08:24:59.150] Value: <not collected>
[08:24:59.150] Conditions captured: <none>
[08:24:59.150] Early signaling: FALSE
[08:24:59.150] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.150] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.161] Chunk #2 of 2 ... DONE
[08:24:59.161] Launching 2 futures (chunks) ... DONE
[08:24:59.161] Resolving 2 futures (chunks) ...
[08:24:59.162] resolve() on list ...
[08:24:59.162]  recursive: 0
[08:24:59.162]  length: 2
[08:24:59.162] 
[08:24:59.162] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.163] - Validating connection of MultisessionFuture
[08:24:59.163] - received message: FutureResult
[08:24:59.163] - Received FutureResult
[08:24:59.163] - Erased future from FutureRegistry
[08:24:59.163] result() for ClusterFuture ...
[08:24:59.163] - result already collected: FutureResult
[08:24:59.163] result() for ClusterFuture ... done
[08:24:59.163] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.163] Future #1
[08:24:59.163] result() for ClusterFuture ...
[08:24:59.163] - result already collected: FutureResult
[08:24:59.164] result() for ClusterFuture ... done
[08:24:59.164] result() for ClusterFuture ...
[08:24:59.164] - result already collected: FutureResult
[08:24:59.164] result() for ClusterFuture ... done
[08:24:59.164] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:59.164] - nx: 2
[08:24:59.164] - relay: TRUE
[08:24:59.164] - stdout: TRUE
[08:24:59.164] - signal: TRUE
[08:24:59.164] - resignal: FALSE
[08:24:59.164] - force: TRUE
[08:24:59.164] - relayed: [n=2] FALSE, FALSE
[08:24:59.164] - queued futures: [n=2] FALSE, FALSE
[08:24:59.165]  - until=1
[08:24:59.165]  - relaying element #1
[08:24:59.165] result() for ClusterFuture ...
[08:24:59.165] - result already collected: FutureResult
[08:24:59.165] result() for ClusterFuture ... done
[08:24:59.165] result() for ClusterFuture ...
[08:24:59.165] - result already collected: FutureResult
[08:24:59.165] result() for ClusterFuture ... done
[08:24:59.165] result() for ClusterFuture ...
[08:24:59.165] - result already collected: FutureResult
[08:24:59.165] result() for ClusterFuture ... done
[08:24:59.165] result() for ClusterFuture ...
[08:24:59.166] - result already collected: FutureResult
[08:24:59.166] result() for ClusterFuture ... done
[08:24:59.166] - relayed: [n=2] TRUE, FALSE
[08:24:59.166] - queued futures: [n=2] TRUE, FALSE
[08:24:59.166] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:59.166]  length: 1 (resolved future 1)
[08:24:59.192] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.193] - Validating connection of MultisessionFuture
[08:24:59.193] - received message: FutureResult
[08:24:59.193] - Received FutureResult
[08:24:59.193] - Erased future from FutureRegistry
[08:24:59.193] result() for ClusterFuture ...
[08:24:59.193] - result already collected: FutureResult
[08:24:59.193] result() for ClusterFuture ... done
[08:24:59.194] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.194] Future #2
[08:24:59.194] result() for ClusterFuture ...
[08:24:59.194] - result already collected: FutureResult
[08:24:59.194] result() for ClusterFuture ... done
[08:24:59.194] result() for ClusterFuture ...
[08:24:59.194] - result already collected: FutureResult
[08:24:59.194] result() for ClusterFuture ... done
[08:24:59.194] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:59.194] - nx: 2
[08:24:59.194] - relay: TRUE
[08:24:59.194] - stdout: TRUE
[08:24:59.195] - signal: TRUE
[08:24:59.195] - resignal: FALSE
[08:24:59.195] - force: TRUE
[08:24:59.195] - relayed: [n=2] TRUE, FALSE
[08:24:59.195] - queued futures: [n=2] TRUE, FALSE
[08:24:59.195]  - until=2
[08:24:59.195]  - relaying element #2
[08:24:59.195] result() for ClusterFuture ...
[08:24:59.195] - result already collected: FutureResult
[08:24:59.195] result() for ClusterFuture ... done
[08:24:59.195] result() for ClusterFuture ...
[08:24:59.195] - result already collected: FutureResult
[08:24:59.196] result() for ClusterFuture ... done
[08:24:59.196] result() for ClusterFuture ...
[08:24:59.196] - result already collected: FutureResult
[08:24:59.196] result() for ClusterFuture ... done
[08:24:59.196] result() for ClusterFuture ...
[08:24:59.196] - result already collected: FutureResult
[08:24:59.196] result() for ClusterFuture ... done
[08:24:59.196] - relayed: [n=2] TRUE, TRUE
[08:24:59.196] - queued futures: [n=2] TRUE, TRUE
[08:24:59.196] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:59.196]  length: 0 (resolved future 2)
[08:24:59.196] Relaying remaining futures
[08:24:59.197] signalConditionsASAP(NULL, pos=0) ...
[08:24:59.197] - nx: 2
[08:24:59.197] - relay: TRUE
[08:24:59.197] - stdout: TRUE
[08:24:59.197] - signal: TRUE
[08:24:59.197] - resignal: FALSE
[08:24:59.197] - force: TRUE
[08:24:59.197] - relayed: [n=2] TRUE, TRUE
[08:24:59.197] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:59.197] - relayed: [n=2] TRUE, TRUE
[08:24:59.197] - queued futures: [n=2] TRUE, TRUE
[08:24:59.197] signalConditionsASAP(NULL, pos=0) ... done
[08:24:59.198] resolve() on list ... DONE
[08:24:59.198] result() for ClusterFuture ...
[08:24:59.198] - result already collected: FutureResult
[08:24:59.198] result() for ClusterFuture ... done
[08:24:59.198] result() for ClusterFuture ...
[08:24:59.198] - result already collected: FutureResult
[08:24:59.198] result() for ClusterFuture ... done
[08:24:59.198] result() for ClusterFuture ...
[08:24:59.198] - result already collected: FutureResult
[08:24:59.198] result() for ClusterFuture ... done
[08:24:59.198] result() for ClusterFuture ...
[08:24:59.198] - result already collected: FutureResult
[08:24:59.198] result() for ClusterFuture ... done
[08:24:59.199]  - Number of value chunks collected: 2
[08:24:59.199] Resolving 2 futures (chunks) ... DONE
[08:24:59.199] Reducing values from 2 chunks ...
[08:24:59.199]  - Number of values collected after concatenation: 6
[08:24:59.199]  - Number of values expected: 6
[08:24:59.199] Reducing values from 2 chunks ... DONE
[08:24:59.199] future_lapply() ... DONE
[08:24:59.199] future_by_internal() ... DONE
[08:24:59.200] future_by_internal() ...
[08:24:59.201] future_lapply() ...
[08:24:59.203] Number of chunks: 2
[08:24:59.203] getGlobalsAndPackagesXApply() ...
[08:24:59.203]  - future.globals: TRUE
[08:24:59.203] getGlobalsAndPackages() ...
[08:24:59.203] Searching for globals...
[08:24:59.205] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:59.205] Searching for globals ... DONE
[08:24:59.205] Resolving globals: FALSE
[08:24:59.206] The total size of the 1 globals is 762 bytes (762 bytes)
[08:24:59.206] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 762 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (762 bytes of class ‘function’)
[08:24:59.206] - globals: [1] ‘FUN’
[08:24:59.206] - packages: [1] ‘stats’
[08:24:59.206] getGlobalsAndPackages() ... DONE
[08:24:59.206]  - globals found/used: [n=1] ‘FUN’
[08:24:59.206]  - needed namespaces: [n=1] ‘stats’
[08:24:59.207] Finding globals ... DONE
[08:24:59.207]  - use_args: TRUE
[08:24:59.207]  - Getting '...' globals ...
[08:24:59.207] resolve() on list ...
[08:24:59.207]  recursive: 0
[08:24:59.207]  length: 1
[08:24:59.207]  elements: ‘...’
[08:24:59.207]  length: 0 (resolved future 1)
[08:24:59.207] resolve() on list ... DONE
[08:24:59.208]    - '...' content: [n=1] ‘singular.ok’
[08:24:59.208] List of 1
[08:24:59.208]  $ ...:List of 1
[08:24:59.208]   ..$ singular.ok: logi FALSE
[08:24:59.208]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.208]  - attr(*, "where")=List of 1
[08:24:59.208]   ..$ ...:<environment: 0x557b297b5ac8> 
[08:24:59.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.208]  - attr(*, "resolved")= logi TRUE
[08:24:59.208]  - attr(*, "total_size")= num NA
[08:24:59.210]  - Getting '...' globals ... DONE
[08:24:59.211] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:59.211] List of 2
[08:24:59.211]  $ ...future.FUN:function (x, ...)  
[08:24:59.211]  $ ...          :List of 1
[08:24:59.211]   ..$ singular.ok: logi FALSE
[08:24:59.211]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.211]  - attr(*, "where")=List of 2
[08:24:59.211]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:59.211]   ..$ ...          :<environment: 0x557b297b5ac8> 
[08:24:59.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.211]  - attr(*, "resolved")= logi FALSE
[08:24:59.211]  - attr(*, "total_size")= num 19977
[08:24:59.214] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:59.214] getGlobalsAndPackagesXApply() ... DONE
[08:24:59.214] Number of futures (= number of chunks): 2
[08:24:59.214] Launching 2 futures (chunks) ...
[08:24:59.214] Chunk #1 of 2 ...
[08:24:59.214]  - Finding globals in 'X' for chunk #1 ...
[08:24:59.214] getGlobalsAndPackages() ...
[08:24:59.214] Searching for globals...
[08:24:59.215] 
[08:24:59.215] Searching for globals ... DONE
[08:24:59.215] - globals: [0] <none>
[08:24:59.215] getGlobalsAndPackages() ... DONE
[08:24:59.215]    + additional globals found: [n=0] 
[08:24:59.215]    + additional namespaces needed: [n=0] 
[08:24:59.215]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:59.215]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.215]  - seeds: <none>
[08:24:59.215]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.216] getGlobalsAndPackages() ...
[08:24:59.216] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.216] Resolving globals: FALSE
[08:24:59.216] Tweak future expression to call with '...' arguments ...
[08:24:59.216] {
[08:24:59.216]     do.call(function(...) {
[08:24:59.216]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.216]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.216]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.216]             on.exit(options(oopts), add = TRUE)
[08:24:59.216]         }
[08:24:59.216]         {
[08:24:59.216]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.216]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.216]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.216]             })
[08:24:59.216]         }
[08:24:59.216]     }, args = future.call.arguments)
[08:24:59.216] }
[08:24:59.216] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.217] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.217] 
[08:24:59.217] getGlobalsAndPackages() ... DONE
[08:24:59.217] run() for ‘Future’ ...
[08:24:59.217] - state: ‘created’
[08:24:59.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.231] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.231]   - Field: ‘node’
[08:24:59.231]   - Field: ‘label’
[08:24:59.231]   - Field: ‘local’
[08:24:59.231]   - Field: ‘owner’
[08:24:59.231]   - Field: ‘envir’
[08:24:59.232]   - Field: ‘workers’
[08:24:59.232]   - Field: ‘packages’
[08:24:59.232]   - Field: ‘gc’
[08:24:59.232]   - Field: ‘conditions’
[08:24:59.232]   - Field: ‘persistent’
[08:24:59.232]   - Field: ‘expr’
[08:24:59.232]   - Field: ‘uuid’
[08:24:59.232]   - Field: ‘seed’
[08:24:59.232]   - Field: ‘version’
[08:24:59.232]   - Field: ‘result’
[08:24:59.232]   - Field: ‘asynchronous’
[08:24:59.232]   - Field: ‘calls’
[08:24:59.233]   - Field: ‘globals’
[08:24:59.233]   - Field: ‘stdout’
[08:24:59.233]   - Field: ‘earlySignal’
[08:24:59.233]   - Field: ‘lazy’
[08:24:59.233]   - Field: ‘state’
[08:24:59.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.233] - Launch lazy future ...
[08:24:59.233] Packages needed by the future expression (n = 1): ‘stats’
[08:24:59.233] Packages needed by future strategies (n = 0): <none>
[08:24:59.234] {
[08:24:59.234]     {
[08:24:59.234]         {
[08:24:59.234]             ...future.startTime <- base::Sys.time()
[08:24:59.234]             {
[08:24:59.234]                 {
[08:24:59.234]                   {
[08:24:59.234]                     {
[08:24:59.234]                       {
[08:24:59.234]                         base::local({
[08:24:59.234]                           has_future <- base::requireNamespace("future", 
[08:24:59.234]                             quietly = TRUE)
[08:24:59.234]                           if (has_future) {
[08:24:59.234]                             ns <- base::getNamespace("future")
[08:24:59.234]                             version <- ns[[".package"]][["version"]]
[08:24:59.234]                             if (is.null(version)) 
[08:24:59.234]                               version <- utils::packageVersion("future")
[08:24:59.234]                           }
[08:24:59.234]                           else {
[08:24:59.234]                             version <- NULL
[08:24:59.234]                           }
[08:24:59.234]                           if (!has_future || version < "1.8.0") {
[08:24:59.234]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.234]                               "", base::R.version$version.string), 
[08:24:59.234]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:59.234]                                 base::R.version$platform, 8 * 
[08:24:59.234]                                   base::.Machine$sizeof.pointer), 
[08:24:59.234]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.234]                                 "release", "version")], collapse = " "), 
[08:24:59.234]                               hostname = base::Sys.info()[["nodename"]])
[08:24:59.234]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.234]                               info)
[08:24:59.234]                             info <- base::paste(info, collapse = "; ")
[08:24:59.234]                             if (!has_future) {
[08:24:59.234]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.234]                                 info)
[08:24:59.234]                             }
[08:24:59.234]                             else {
[08:24:59.234]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.234]                                 info, version)
[08:24:59.234]                             }
[08:24:59.234]                             base::stop(msg)
[08:24:59.234]                           }
[08:24:59.234]                         })
[08:24:59.234]                       }
[08:24:59.234]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.234]                       base::options(mc.cores = 1L)
[08:24:59.234]                     }
[08:24:59.234]                     base::local({
[08:24:59.234]                       for (pkg in "stats") {
[08:24:59.234]                         base::loadNamespace(pkg)
[08:24:59.234]                         base::library(pkg, character.only = TRUE)
[08:24:59.234]                       }
[08:24:59.234]                     })
[08:24:59.234]                   }
[08:24:59.234]                   ...future.strategy.old <- future::plan("list")
[08:24:59.234]                   options(future.plan = NULL)
[08:24:59.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.234]                 }
[08:24:59.234]                 ...future.workdir <- getwd()
[08:24:59.234]             }
[08:24:59.234]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.234]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.234]         }
[08:24:59.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.234]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.234]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.234]             base::names(...future.oldOptions))
[08:24:59.234]     }
[08:24:59.234]     if (FALSE) {
[08:24:59.234]     }
[08:24:59.234]     else {
[08:24:59.234]         if (TRUE) {
[08:24:59.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.234]                 open = "w")
[08:24:59.234]         }
[08:24:59.234]         else {
[08:24:59.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.234]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.234]         }
[08:24:59.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.234]             base::sink(type = "output", split = FALSE)
[08:24:59.234]             base::close(...future.stdout)
[08:24:59.234]         }, add = TRUE)
[08:24:59.234]     }
[08:24:59.234]     ...future.frame <- base::sys.nframe()
[08:24:59.234]     ...future.conditions <- base::list()
[08:24:59.234]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.234]     if (FALSE) {
[08:24:59.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.234]     }
[08:24:59.234]     ...future.result <- base::tryCatch({
[08:24:59.234]         base::withCallingHandlers({
[08:24:59.234]             ...future.value <- base::withVisible(base::local({
[08:24:59.234]                 ...future.makeSendCondition <- base::local({
[08:24:59.234]                   sendCondition <- NULL
[08:24:59.234]                   function(frame = 1L) {
[08:24:59.234]                     if (is.function(sendCondition)) 
[08:24:59.234]                       return(sendCondition)
[08:24:59.234]                     ns <- getNamespace("parallel")
[08:24:59.234]                     if (exists("sendData", mode = "function", 
[08:24:59.234]                       envir = ns)) {
[08:24:59.234]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.234]                         envir = ns)
[08:24:59.234]                       envir <- sys.frame(frame)
[08:24:59.234]                       master <- NULL
[08:24:59.234]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.234]                         !identical(envir, emptyenv())) {
[08:24:59.234]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.234]                           inherits = FALSE)) {
[08:24:59.234]                           master <- get("master", mode = "list", 
[08:24:59.234]                             envir = envir, inherits = FALSE)
[08:24:59.234]                           if (inherits(master, c("SOCKnode", 
[08:24:59.234]                             "SOCK0node"))) {
[08:24:59.234]                             sendCondition <<- function(cond) {
[08:24:59.234]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.234]                                 success = TRUE)
[08:24:59.234]                               parallel_sendData(master, data)
[08:24:59.234]                             }
[08:24:59.234]                             return(sendCondition)
[08:24:59.234]                           }
[08:24:59.234]                         }
[08:24:59.234]                         frame <- frame + 1L
[08:24:59.234]                         envir <- sys.frame(frame)
[08:24:59.234]                       }
[08:24:59.234]                     }
[08:24:59.234]                     sendCondition <<- function(cond) NULL
[08:24:59.234]                   }
[08:24:59.234]                 })
[08:24:59.234]                 withCallingHandlers({
[08:24:59.234]                   {
[08:24:59.234]                     do.call(function(...) {
[08:24:59.234]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.234]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.234]                         ...future.globals.maxSize)) {
[08:24:59.234]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.234]                         on.exit(options(oopts), add = TRUE)
[08:24:59.234]                       }
[08:24:59.234]                       {
[08:24:59.234]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.234]                           FUN = function(jj) {
[08:24:59.234]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.234]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.234]                           })
[08:24:59.234]                       }
[08:24:59.234]                     }, args = future.call.arguments)
[08:24:59.234]                   }
[08:24:59.234]                 }, immediateCondition = function(cond) {
[08:24:59.234]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.234]                   sendCondition(cond)
[08:24:59.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.234]                   {
[08:24:59.234]                     inherits <- base::inherits
[08:24:59.234]                     invokeRestart <- base::invokeRestart
[08:24:59.234]                     is.null <- base::is.null
[08:24:59.234]                     muffled <- FALSE
[08:24:59.234]                     if (inherits(cond, "message")) {
[08:24:59.234]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.234]                       if (muffled) 
[08:24:59.234]                         invokeRestart("muffleMessage")
[08:24:59.234]                     }
[08:24:59.234]                     else if (inherits(cond, "warning")) {
[08:24:59.234]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.234]                       if (muffled) 
[08:24:59.234]                         invokeRestart("muffleWarning")
[08:24:59.234]                     }
[08:24:59.234]                     else if (inherits(cond, "condition")) {
[08:24:59.234]                       if (!is.null(pattern)) {
[08:24:59.234]                         computeRestarts <- base::computeRestarts
[08:24:59.234]                         grepl <- base::grepl
[08:24:59.234]                         restarts <- computeRestarts(cond)
[08:24:59.234]                         for (restart in restarts) {
[08:24:59.234]                           name <- restart$name
[08:24:59.234]                           if (is.null(name)) 
[08:24:59.234]                             next
[08:24:59.234]                           if (!grepl(pattern, name)) 
[08:24:59.234]                             next
[08:24:59.234]                           invokeRestart(restart)
[08:24:59.234]                           muffled <- TRUE
[08:24:59.234]                           break
[08:24:59.234]                         }
[08:24:59.234]                       }
[08:24:59.234]                     }
[08:24:59.234]                     invisible(muffled)
[08:24:59.234]                   }
[08:24:59.234]                   muffleCondition(cond)
[08:24:59.234]                 })
[08:24:59.234]             }))
[08:24:59.234]             future::FutureResult(value = ...future.value$value, 
[08:24:59.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.234]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.234]                     ...future.globalenv.names))
[08:24:59.234]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.234]         }, condition = base::local({
[08:24:59.234]             c <- base::c
[08:24:59.234]             inherits <- base::inherits
[08:24:59.234]             invokeRestart <- base::invokeRestart
[08:24:59.234]             length <- base::length
[08:24:59.234]             list <- base::list
[08:24:59.234]             seq.int <- base::seq.int
[08:24:59.234]             signalCondition <- base::signalCondition
[08:24:59.234]             sys.calls <- base::sys.calls
[08:24:59.234]             `[[` <- base::`[[`
[08:24:59.234]             `+` <- base::`+`
[08:24:59.234]             `<<-` <- base::`<<-`
[08:24:59.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.234]                   3L)]
[08:24:59.234]             }
[08:24:59.234]             function(cond) {
[08:24:59.234]                 is_error <- inherits(cond, "error")
[08:24:59.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.234]                   NULL)
[08:24:59.234]                 if (is_error) {
[08:24:59.234]                   sessionInformation <- function() {
[08:24:59.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.234]                       search = base::search(), system = base::Sys.info())
[08:24:59.234]                   }
[08:24:59.234]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.234]                     cond$call), session = sessionInformation(), 
[08:24:59.234]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.234]                   signalCondition(cond)
[08:24:59.234]                 }
[08:24:59.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.234]                 "immediateCondition"))) {
[08:24:59.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.234]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.234]                   if (TRUE && !signal) {
[08:24:59.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.234]                     {
[08:24:59.234]                       inherits <- base::inherits
[08:24:59.234]                       invokeRestart <- base::invokeRestart
[08:24:59.234]                       is.null <- base::is.null
[08:24:59.234]                       muffled <- FALSE
[08:24:59.234]                       if (inherits(cond, "message")) {
[08:24:59.234]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.234]                         if (muffled) 
[08:24:59.234]                           invokeRestart("muffleMessage")
[08:24:59.234]                       }
[08:24:59.234]                       else if (inherits(cond, "warning")) {
[08:24:59.234]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.234]                         if (muffled) 
[08:24:59.234]                           invokeRestart("muffleWarning")
[08:24:59.234]                       }
[08:24:59.234]                       else if (inherits(cond, "condition")) {
[08:24:59.234]                         if (!is.null(pattern)) {
[08:24:59.234]                           computeRestarts <- base::computeRestarts
[08:24:59.234]                           grepl <- base::grepl
[08:24:59.234]                           restarts <- computeRestarts(cond)
[08:24:59.234]                           for (restart in restarts) {
[08:24:59.234]                             name <- restart$name
[08:24:59.234]                             if (is.null(name)) 
[08:24:59.234]                               next
[08:24:59.234]                             if (!grepl(pattern, name)) 
[08:24:59.234]                               next
[08:24:59.234]                             invokeRestart(restart)
[08:24:59.234]                             muffled <- TRUE
[08:24:59.234]                             break
[08:24:59.234]                           }
[08:24:59.234]                         }
[08:24:59.234]                       }
[08:24:59.234]                       invisible(muffled)
[08:24:59.234]                     }
[08:24:59.234]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.234]                   }
[08:24:59.234]                 }
[08:24:59.234]                 else {
[08:24:59.234]                   if (TRUE) {
[08:24:59.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.234]                     {
[08:24:59.234]                       inherits <- base::inherits
[08:24:59.234]                       invokeRestart <- base::invokeRestart
[08:24:59.234]                       is.null <- base::is.null
[08:24:59.234]                       muffled <- FALSE
[08:24:59.234]                       if (inherits(cond, "message")) {
[08:24:59.234]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.234]                         if (muffled) 
[08:24:59.234]                           invokeRestart("muffleMessage")
[08:24:59.234]                       }
[08:24:59.234]                       else if (inherits(cond, "warning")) {
[08:24:59.234]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.234]                         if (muffled) 
[08:24:59.234]                           invokeRestart("muffleWarning")
[08:24:59.234]                       }
[08:24:59.234]                       else if (inherits(cond, "condition")) {
[08:24:59.234]                         if (!is.null(pattern)) {
[08:24:59.234]                           computeRestarts <- base::computeRestarts
[08:24:59.234]                           grepl <- base::grepl
[08:24:59.234]                           restarts <- computeRestarts(cond)
[08:24:59.234]                           for (restart in restarts) {
[08:24:59.234]                             name <- restart$name
[08:24:59.234]                             if (is.null(name)) 
[08:24:59.234]                               next
[08:24:59.234]                             if (!grepl(pattern, name)) 
[08:24:59.234]                               next
[08:24:59.234]                             invokeRestart(restart)
[08:24:59.234]                             muffled <- TRUE
[08:24:59.234]                             break
[08:24:59.234]                           }
[08:24:59.234]                         }
[08:24:59.234]                       }
[08:24:59.234]                       invisible(muffled)
[08:24:59.234]                     }
[08:24:59.234]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.234]                   }
[08:24:59.234]                 }
[08:24:59.234]             }
[08:24:59.234]         }))
[08:24:59.234]     }, error = function(ex) {
[08:24:59.234]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.234]                 ...future.rng), started = ...future.startTime, 
[08:24:59.234]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.234]             version = "1.8"), class = "FutureResult")
[08:24:59.234]     }, finally = {
[08:24:59.234]         if (!identical(...future.workdir, getwd())) 
[08:24:59.234]             setwd(...future.workdir)
[08:24:59.234]         {
[08:24:59.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.234]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.234]             }
[08:24:59.234]             base::options(...future.oldOptions)
[08:24:59.234]             if (.Platform$OS.type == "windows") {
[08:24:59.234]                 old_names <- names(...future.oldEnvVars)
[08:24:59.234]                 envs <- base::Sys.getenv()
[08:24:59.234]                 names <- names(envs)
[08:24:59.234]                 common <- intersect(names, old_names)
[08:24:59.234]                 added <- setdiff(names, old_names)
[08:24:59.234]                 removed <- setdiff(old_names, names)
[08:24:59.234]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.234]                   envs[common]]
[08:24:59.234]                 NAMES <- toupper(changed)
[08:24:59.234]                 args <- list()
[08:24:59.234]                 for (kk in seq_along(NAMES)) {
[08:24:59.234]                   name <- changed[[kk]]
[08:24:59.234]                   NAME <- NAMES[[kk]]
[08:24:59.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.234]                     next
[08:24:59.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.234]                 }
[08:24:59.234]                 NAMES <- toupper(added)
[08:24:59.234]                 for (kk in seq_along(NAMES)) {
[08:24:59.234]                   name <- added[[kk]]
[08:24:59.234]                   NAME <- NAMES[[kk]]
[08:24:59.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.234]                     next
[08:24:59.234]                   args[[name]] <- ""
[08:24:59.234]                 }
[08:24:59.234]                 NAMES <- toupper(removed)
[08:24:59.234]                 for (kk in seq_along(NAMES)) {
[08:24:59.234]                   name <- removed[[kk]]
[08:24:59.234]                   NAME <- NAMES[[kk]]
[08:24:59.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.234]                     next
[08:24:59.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.234]                 }
[08:24:59.234]                 if (length(args) > 0) 
[08:24:59.234]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.234]             }
[08:24:59.234]             else {
[08:24:59.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.234]             }
[08:24:59.234]             {
[08:24:59.234]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.234]                   0L) {
[08:24:59.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.234]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.234]                   base::options(opts)
[08:24:59.234]                 }
[08:24:59.234]                 {
[08:24:59.234]                   {
[08:24:59.234]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.234]                     NULL
[08:24:59.234]                   }
[08:24:59.234]                   options(future.plan = NULL)
[08:24:59.234]                   if (is.na(NA_character_)) 
[08:24:59.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.234]                     .init = FALSE)
[08:24:59.234]                 }
[08:24:59.234]             }
[08:24:59.234]         }
[08:24:59.234]     })
[08:24:59.234]     if (TRUE) {
[08:24:59.234]         base::sink(type = "output", split = FALSE)
[08:24:59.234]         if (TRUE) {
[08:24:59.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.234]         }
[08:24:59.234]         else {
[08:24:59.234]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.234]         }
[08:24:59.234]         base::close(...future.stdout)
[08:24:59.234]         ...future.stdout <- NULL
[08:24:59.234]     }
[08:24:59.234]     ...future.result$conditions <- ...future.conditions
[08:24:59.234]     ...future.result$finished <- base::Sys.time()
[08:24:59.234]     ...future.result
[08:24:59.234] }
[08:24:59.237] Exporting 5 global objects (2.08 KiB) to cluster node #1 ...
[08:24:59.237] Exporting ‘...future.FUN’ (762 bytes) to cluster node #1 ...
[08:24:59.237] Exporting ‘...future.FUN’ (762 bytes) to cluster node #1 ... DONE
[08:24:59.238] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #1 ...
[08:24:59.238] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #1 ... DONE
[08:24:59.238] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[08:24:59.238] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[08:24:59.238] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:59.239] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.239] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:24:59.239] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.239] Exporting 5 global objects (2.08 KiB) to cluster node #1 ... DONE
[08:24:59.240] MultisessionFuture started
[08:24:59.240] - Launch lazy future ... done
[08:24:59.240] run() for ‘MultisessionFuture’ ... done
[08:24:59.240] Created future:
[08:24:59.240] MultisessionFuture:
[08:24:59.240] Label: ‘future_by-1’
[08:24:59.240] Expression:
[08:24:59.240] {
[08:24:59.240]     do.call(function(...) {
[08:24:59.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.240]             on.exit(options(oopts), add = TRUE)
[08:24:59.240]         }
[08:24:59.240]         {
[08:24:59.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.240]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.240]             })
[08:24:59.240]         }
[08:24:59.240]     }, args = future.call.arguments)
[08:24:59.240] }
[08:24:59.240] Lazy evaluation: FALSE
[08:24:59.240] Asynchronous evaluation: TRUE
[08:24:59.240] Local evaluation: TRUE
[08:24:59.240] Environment: R_GlobalEnv
[08:24:59.240] Capture standard output: TRUE
[08:24:59.240] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.240] Globals: 5 objects totaling 1.67 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:59.240] Packages: 1 packages (‘stats’)
[08:24:59.240] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.240] Resolved: FALSE
[08:24:59.240] Value: <not collected>
[08:24:59.240] Conditions captured: <none>
[08:24:59.240] Early signaling: FALSE
[08:24:59.240] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.240] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.252] Chunk #1 of 2 ... DONE
[08:24:59.252] Chunk #2 of 2 ...
[08:24:59.252]  - Finding globals in 'X' for chunk #2 ...
[08:24:59.252] getGlobalsAndPackages() ...
[08:24:59.252] Searching for globals...
[08:24:59.253] 
[08:24:59.253] Searching for globals ... DONE
[08:24:59.253] - globals: [0] <none>
[08:24:59.253] getGlobalsAndPackages() ... DONE
[08:24:59.253]    + additional globals found: [n=0] 
[08:24:59.253]    + additional namespaces needed: [n=0] 
[08:24:59.253]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:59.253]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.253]  - seeds: <none>
[08:24:59.253]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.254] getGlobalsAndPackages() ...
[08:24:59.254] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.254] Resolving globals: FALSE
[08:24:59.254] Tweak future expression to call with '...' arguments ...
[08:24:59.254] {
[08:24:59.254]     do.call(function(...) {
[08:24:59.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.254]             on.exit(options(oopts), add = TRUE)
[08:24:59.254]         }
[08:24:59.254]         {
[08:24:59.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.254]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.254]             })
[08:24:59.254]         }
[08:24:59.254]     }, args = future.call.arguments)
[08:24:59.254] }
[08:24:59.254] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.255] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.255] 
[08:24:59.255] getGlobalsAndPackages() ... DONE
[08:24:59.255] run() for ‘Future’ ...
[08:24:59.255] - state: ‘created’
[08:24:59.255] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.270] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.270] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.270]   - Field: ‘node’
[08:24:59.270]   - Field: ‘label’
[08:24:59.270]   - Field: ‘local’
[08:24:59.270]   - Field: ‘owner’
[08:24:59.270]   - Field: ‘envir’
[08:24:59.271]   - Field: ‘workers’
[08:24:59.271]   - Field: ‘packages’
[08:24:59.271]   - Field: ‘gc’
[08:24:59.271]   - Field: ‘conditions’
[08:24:59.271]   - Field: ‘persistent’
[08:24:59.271]   - Field: ‘expr’
[08:24:59.271]   - Field: ‘uuid’
[08:24:59.271]   - Field: ‘seed’
[08:24:59.271]   - Field: ‘version’
[08:24:59.271]   - Field: ‘result’
[08:24:59.271]   - Field: ‘asynchronous’
[08:24:59.272]   - Field: ‘calls’
[08:24:59.272]   - Field: ‘globals’
[08:24:59.272]   - Field: ‘stdout’
[08:24:59.272]   - Field: ‘earlySignal’
[08:24:59.272]   - Field: ‘lazy’
[08:24:59.272]   - Field: ‘state’
[08:24:59.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.272] - Launch lazy future ...
[08:24:59.272] Packages needed by the future expression (n = 1): ‘stats’
[08:24:59.273] Packages needed by future strategies (n = 0): <none>
[08:24:59.273] {
[08:24:59.273]     {
[08:24:59.273]         {
[08:24:59.273]             ...future.startTime <- base::Sys.time()
[08:24:59.273]             {
[08:24:59.273]                 {
[08:24:59.273]                   {
[08:24:59.273]                     {
[08:24:59.273]                       {
[08:24:59.273]                         base::local({
[08:24:59.273]                           has_future <- base::requireNamespace("future", 
[08:24:59.273]                             quietly = TRUE)
[08:24:59.273]                           if (has_future) {
[08:24:59.273]                             ns <- base::getNamespace("future")
[08:24:59.273]                             version <- ns[[".package"]][["version"]]
[08:24:59.273]                             if (is.null(version)) 
[08:24:59.273]                               version <- utils::packageVersion("future")
[08:24:59.273]                           }
[08:24:59.273]                           else {
[08:24:59.273]                             version <- NULL
[08:24:59.273]                           }
[08:24:59.273]                           if (!has_future || version < "1.8.0") {
[08:24:59.273]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.273]                               "", base::R.version$version.string), 
[08:24:59.273]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:59.273]                                 base::R.version$platform, 8 * 
[08:24:59.273]                                   base::.Machine$sizeof.pointer), 
[08:24:59.273]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.273]                                 "release", "version")], collapse = " "), 
[08:24:59.273]                               hostname = base::Sys.info()[["nodename"]])
[08:24:59.273]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.273]                               info)
[08:24:59.273]                             info <- base::paste(info, collapse = "; ")
[08:24:59.273]                             if (!has_future) {
[08:24:59.273]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.273]                                 info)
[08:24:59.273]                             }
[08:24:59.273]                             else {
[08:24:59.273]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.273]                                 info, version)
[08:24:59.273]                             }
[08:24:59.273]                             base::stop(msg)
[08:24:59.273]                           }
[08:24:59.273]                         })
[08:24:59.273]                       }
[08:24:59.273]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.273]                       base::options(mc.cores = 1L)
[08:24:59.273]                     }
[08:24:59.273]                     base::local({
[08:24:59.273]                       for (pkg in "stats") {
[08:24:59.273]                         base::loadNamespace(pkg)
[08:24:59.273]                         base::library(pkg, character.only = TRUE)
[08:24:59.273]                       }
[08:24:59.273]                     })
[08:24:59.273]                   }
[08:24:59.273]                   ...future.strategy.old <- future::plan("list")
[08:24:59.273]                   options(future.plan = NULL)
[08:24:59.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.273]                 }
[08:24:59.273]                 ...future.workdir <- getwd()
[08:24:59.273]             }
[08:24:59.273]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.273]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.273]         }
[08:24:59.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.273]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.273]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.273]             base::names(...future.oldOptions))
[08:24:59.273]     }
[08:24:59.273]     if (FALSE) {
[08:24:59.273]     }
[08:24:59.273]     else {
[08:24:59.273]         if (TRUE) {
[08:24:59.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.273]                 open = "w")
[08:24:59.273]         }
[08:24:59.273]         else {
[08:24:59.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.273]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.273]         }
[08:24:59.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.273]             base::sink(type = "output", split = FALSE)
[08:24:59.273]             base::close(...future.stdout)
[08:24:59.273]         }, add = TRUE)
[08:24:59.273]     }
[08:24:59.273]     ...future.frame <- base::sys.nframe()
[08:24:59.273]     ...future.conditions <- base::list()
[08:24:59.273]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.273]     if (FALSE) {
[08:24:59.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.273]     }
[08:24:59.273]     ...future.result <- base::tryCatch({
[08:24:59.273]         base::withCallingHandlers({
[08:24:59.273]             ...future.value <- base::withVisible(base::local({
[08:24:59.273]                 ...future.makeSendCondition <- base::local({
[08:24:59.273]                   sendCondition <- NULL
[08:24:59.273]                   function(frame = 1L) {
[08:24:59.273]                     if (is.function(sendCondition)) 
[08:24:59.273]                       return(sendCondition)
[08:24:59.273]                     ns <- getNamespace("parallel")
[08:24:59.273]                     if (exists("sendData", mode = "function", 
[08:24:59.273]                       envir = ns)) {
[08:24:59.273]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.273]                         envir = ns)
[08:24:59.273]                       envir <- sys.frame(frame)
[08:24:59.273]                       master <- NULL
[08:24:59.273]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.273]                         !identical(envir, emptyenv())) {
[08:24:59.273]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.273]                           inherits = FALSE)) {
[08:24:59.273]                           master <- get("master", mode = "list", 
[08:24:59.273]                             envir = envir, inherits = FALSE)
[08:24:59.273]                           if (inherits(master, c("SOCKnode", 
[08:24:59.273]                             "SOCK0node"))) {
[08:24:59.273]                             sendCondition <<- function(cond) {
[08:24:59.273]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.273]                                 success = TRUE)
[08:24:59.273]                               parallel_sendData(master, data)
[08:24:59.273]                             }
[08:24:59.273]                             return(sendCondition)
[08:24:59.273]                           }
[08:24:59.273]                         }
[08:24:59.273]                         frame <- frame + 1L
[08:24:59.273]                         envir <- sys.frame(frame)
[08:24:59.273]                       }
[08:24:59.273]                     }
[08:24:59.273]                     sendCondition <<- function(cond) NULL
[08:24:59.273]                   }
[08:24:59.273]                 })
[08:24:59.273]                 withCallingHandlers({
[08:24:59.273]                   {
[08:24:59.273]                     do.call(function(...) {
[08:24:59.273]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.273]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.273]                         ...future.globals.maxSize)) {
[08:24:59.273]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.273]                         on.exit(options(oopts), add = TRUE)
[08:24:59.273]                       }
[08:24:59.273]                       {
[08:24:59.273]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.273]                           FUN = function(jj) {
[08:24:59.273]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.273]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.273]                           })
[08:24:59.273]                       }
[08:24:59.273]                     }, args = future.call.arguments)
[08:24:59.273]                   }
[08:24:59.273]                 }, immediateCondition = function(cond) {
[08:24:59.273]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.273]                   sendCondition(cond)
[08:24:59.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.273]                   {
[08:24:59.273]                     inherits <- base::inherits
[08:24:59.273]                     invokeRestart <- base::invokeRestart
[08:24:59.273]                     is.null <- base::is.null
[08:24:59.273]                     muffled <- FALSE
[08:24:59.273]                     if (inherits(cond, "message")) {
[08:24:59.273]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.273]                       if (muffled) 
[08:24:59.273]                         invokeRestart("muffleMessage")
[08:24:59.273]                     }
[08:24:59.273]                     else if (inherits(cond, "warning")) {
[08:24:59.273]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.273]                       if (muffled) 
[08:24:59.273]                         invokeRestart("muffleWarning")
[08:24:59.273]                     }
[08:24:59.273]                     else if (inherits(cond, "condition")) {
[08:24:59.273]                       if (!is.null(pattern)) {
[08:24:59.273]                         computeRestarts <- base::computeRestarts
[08:24:59.273]                         grepl <- base::grepl
[08:24:59.273]                         restarts <- computeRestarts(cond)
[08:24:59.273]                         for (restart in restarts) {
[08:24:59.273]                           name <- restart$name
[08:24:59.273]                           if (is.null(name)) 
[08:24:59.273]                             next
[08:24:59.273]                           if (!grepl(pattern, name)) 
[08:24:59.273]                             next
[08:24:59.273]                           invokeRestart(restart)
[08:24:59.273]                           muffled <- TRUE
[08:24:59.273]                           break
[08:24:59.273]                         }
[08:24:59.273]                       }
[08:24:59.273]                     }
[08:24:59.273]                     invisible(muffled)
[08:24:59.273]                   }
[08:24:59.273]                   muffleCondition(cond)
[08:24:59.273]                 })
[08:24:59.273]             }))
[08:24:59.273]             future::FutureResult(value = ...future.value$value, 
[08:24:59.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.273]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.273]                     ...future.globalenv.names))
[08:24:59.273]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.273]         }, condition = base::local({
[08:24:59.273]             c <- base::c
[08:24:59.273]             inherits <- base::inherits
[08:24:59.273]             invokeRestart <- base::invokeRestart
[08:24:59.273]             length <- base::length
[08:24:59.273]             list <- base::list
[08:24:59.273]             seq.int <- base::seq.int
[08:24:59.273]             signalCondition <- base::signalCondition
[08:24:59.273]             sys.calls <- base::sys.calls
[08:24:59.273]             `[[` <- base::`[[`
[08:24:59.273]             `+` <- base::`+`
[08:24:59.273]             `<<-` <- base::`<<-`
[08:24:59.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.273]                   3L)]
[08:24:59.273]             }
[08:24:59.273]             function(cond) {
[08:24:59.273]                 is_error <- inherits(cond, "error")
[08:24:59.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.273]                   NULL)
[08:24:59.273]                 if (is_error) {
[08:24:59.273]                   sessionInformation <- function() {
[08:24:59.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.273]                       search = base::search(), system = base::Sys.info())
[08:24:59.273]                   }
[08:24:59.273]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.273]                     cond$call), session = sessionInformation(), 
[08:24:59.273]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.273]                   signalCondition(cond)
[08:24:59.273]                 }
[08:24:59.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.273]                 "immediateCondition"))) {
[08:24:59.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.273]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.273]                   if (TRUE && !signal) {
[08:24:59.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.273]                     {
[08:24:59.273]                       inherits <- base::inherits
[08:24:59.273]                       invokeRestart <- base::invokeRestart
[08:24:59.273]                       is.null <- base::is.null
[08:24:59.273]                       muffled <- FALSE
[08:24:59.273]                       if (inherits(cond, "message")) {
[08:24:59.273]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.273]                         if (muffled) 
[08:24:59.273]                           invokeRestart("muffleMessage")
[08:24:59.273]                       }
[08:24:59.273]                       else if (inherits(cond, "warning")) {
[08:24:59.273]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.273]                         if (muffled) 
[08:24:59.273]                           invokeRestart("muffleWarning")
[08:24:59.273]                       }
[08:24:59.273]                       else if (inherits(cond, "condition")) {
[08:24:59.273]                         if (!is.null(pattern)) {
[08:24:59.273]                           computeRestarts <- base::computeRestarts
[08:24:59.273]                           grepl <- base::grepl
[08:24:59.273]                           restarts <- computeRestarts(cond)
[08:24:59.273]                           for (restart in restarts) {
[08:24:59.273]                             name <- restart$name
[08:24:59.273]                             if (is.null(name)) 
[08:24:59.273]                               next
[08:24:59.273]                             if (!grepl(pattern, name)) 
[08:24:59.273]                               next
[08:24:59.273]                             invokeRestart(restart)
[08:24:59.273]                             muffled <- TRUE
[08:24:59.273]                             break
[08:24:59.273]                           }
[08:24:59.273]                         }
[08:24:59.273]                       }
[08:24:59.273]                       invisible(muffled)
[08:24:59.273]                     }
[08:24:59.273]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.273]                   }
[08:24:59.273]                 }
[08:24:59.273]                 else {
[08:24:59.273]                   if (TRUE) {
[08:24:59.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.273]                     {
[08:24:59.273]                       inherits <- base::inherits
[08:24:59.273]                       invokeRestart <- base::invokeRestart
[08:24:59.273]                       is.null <- base::is.null
[08:24:59.273]                       muffled <- FALSE
[08:24:59.273]                       if (inherits(cond, "message")) {
[08:24:59.273]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.273]                         if (muffled) 
[08:24:59.273]                           invokeRestart("muffleMessage")
[08:24:59.273]                       }
[08:24:59.273]                       else if (inherits(cond, "warning")) {
[08:24:59.273]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.273]                         if (muffled) 
[08:24:59.273]                           invokeRestart("muffleWarning")
[08:24:59.273]                       }
[08:24:59.273]                       else if (inherits(cond, "condition")) {
[08:24:59.273]                         if (!is.null(pattern)) {
[08:24:59.273]                           computeRestarts <- base::computeRestarts
[08:24:59.273]                           grepl <- base::grepl
[08:24:59.273]                           restarts <- computeRestarts(cond)
[08:24:59.273]                           for (restart in restarts) {
[08:24:59.273]                             name <- restart$name
[08:24:59.273]                             if (is.null(name)) 
[08:24:59.273]                               next
[08:24:59.273]                             if (!grepl(pattern, name)) 
[08:24:59.273]                               next
[08:24:59.273]                             invokeRestart(restart)
[08:24:59.273]                             muffled <- TRUE
[08:24:59.273]                             break
[08:24:59.273]                           }
[08:24:59.273]                         }
[08:24:59.273]                       }
[08:24:59.273]                       invisible(muffled)
[08:24:59.273]                     }
[08:24:59.273]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.273]                   }
[08:24:59.273]                 }
[08:24:59.273]             }
[08:24:59.273]         }))
[08:24:59.273]     }, error = function(ex) {
[08:24:59.273]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.273]                 ...future.rng), started = ...future.startTime, 
[08:24:59.273]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.273]             version = "1.8"), class = "FutureResult")
[08:24:59.273]     }, finally = {
[08:24:59.273]         if (!identical(...future.workdir, getwd())) 
[08:24:59.273]             setwd(...future.workdir)
[08:24:59.273]         {
[08:24:59.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.273]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.273]             }
[08:24:59.273]             base::options(...future.oldOptions)
[08:24:59.273]             if (.Platform$OS.type == "windows") {
[08:24:59.273]                 old_names <- names(...future.oldEnvVars)
[08:24:59.273]                 envs <- base::Sys.getenv()
[08:24:59.273]                 names <- names(envs)
[08:24:59.273]                 common <- intersect(names, old_names)
[08:24:59.273]                 added <- setdiff(names, old_names)
[08:24:59.273]                 removed <- setdiff(old_names, names)
[08:24:59.273]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.273]                   envs[common]]
[08:24:59.273]                 NAMES <- toupper(changed)
[08:24:59.273]                 args <- list()
[08:24:59.273]                 for (kk in seq_along(NAMES)) {
[08:24:59.273]                   name <- changed[[kk]]
[08:24:59.273]                   NAME <- NAMES[[kk]]
[08:24:59.273]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.273]                     next
[08:24:59.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.273]                 }
[08:24:59.273]                 NAMES <- toupper(added)
[08:24:59.273]                 for (kk in seq_along(NAMES)) {
[08:24:59.273]                   name <- added[[kk]]
[08:24:59.273]                   NAME <- NAMES[[kk]]
[08:24:59.273]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.273]                     next
[08:24:59.273]                   args[[name]] <- ""
[08:24:59.273]                 }
[08:24:59.273]                 NAMES <- toupper(removed)
[08:24:59.273]                 for (kk in seq_along(NAMES)) {
[08:24:59.273]                   name <- removed[[kk]]
[08:24:59.273]                   NAME <- NAMES[[kk]]
[08:24:59.273]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.273]                     next
[08:24:59.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.273]                 }
[08:24:59.273]                 if (length(args) > 0) 
[08:24:59.273]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.273]             }
[08:24:59.273]             else {
[08:24:59.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.273]             }
[08:24:59.273]             {
[08:24:59.273]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.273]                   0L) {
[08:24:59.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.273]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.273]                   base::options(opts)
[08:24:59.273]                 }
[08:24:59.273]                 {
[08:24:59.273]                   {
[08:24:59.273]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.273]                     NULL
[08:24:59.273]                   }
[08:24:59.273]                   options(future.plan = NULL)
[08:24:59.273]                   if (is.na(NA_character_)) 
[08:24:59.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.273]                     .init = FALSE)
[08:24:59.273]                 }
[08:24:59.273]             }
[08:24:59.273]         }
[08:24:59.273]     })
[08:24:59.273]     if (TRUE) {
[08:24:59.273]         base::sink(type = "output", split = FALSE)
[08:24:59.273]         if (TRUE) {
[08:24:59.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.273]         }
[08:24:59.273]         else {
[08:24:59.273]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.273]         }
[08:24:59.273]         base::close(...future.stdout)
[08:24:59.273]         ...future.stdout <- NULL
[08:24:59.273]     }
[08:24:59.273]     ...future.result$conditions <- ...future.conditions
[08:24:59.273]     ...future.result$finished <- base::Sys.time()
[08:24:59.273]     ...future.result
[08:24:59.273] }
[08:24:59.276] Exporting 5 global objects (2.72 KiB) to cluster node #2 ...
[08:24:59.276] Exporting ‘...future.FUN’ (762 bytes) to cluster node #2 ...
[08:24:59.277] Exporting ‘...future.FUN’ (762 bytes) to cluster node #2 ... DONE
[08:24:59.277] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #2 ...
[08:24:59.277] Exporting ‘future.call.arguments’ (157 bytes) to cluster node #2 ... DONE
[08:24:59.277] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[08:24:59.278] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[08:24:59.278] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:59.278] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.278] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:24:59.279] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.279] Exporting 5 global objects (2.72 KiB) to cluster node #2 ... DONE
[08:24:59.280] MultisessionFuture started
[08:24:59.280] - Launch lazy future ... done
[08:24:59.280] run() for ‘MultisessionFuture’ ... done
[08:24:59.280] Created future:
[08:24:59.280] MultisessionFuture:
[08:24:59.280] Label: ‘future_by-2’
[08:24:59.280] Expression:
[08:24:59.280] {
[08:24:59.280]     do.call(function(...) {
[08:24:59.280]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.280]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.280]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.280]             on.exit(options(oopts), add = TRUE)
[08:24:59.280]         }
[08:24:59.280]         {
[08:24:59.280]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.280]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.280]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.280]             })
[08:24:59.280]         }
[08:24:59.280]     }, args = future.call.arguments)
[08:24:59.280] }
[08:24:59.280] Lazy evaluation: FALSE
[08:24:59.280] Asynchronous evaluation: TRUE
[08:24:59.280] Local evaluation: TRUE
[08:24:59.280] Environment: R_GlobalEnv
[08:24:59.280] Capture standard output: TRUE
[08:24:59.280] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.280] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 762 bytes, DotDotDotList ‘future.call.arguments’ of 157 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:59.280] Packages: 1 packages (‘stats’)
[08:24:59.280] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.280] Resolved: FALSE
[08:24:59.280] Value: <not collected>
[08:24:59.280] Conditions captured: <none>
[08:24:59.280] Early signaling: FALSE
[08:24:59.280] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.280] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.292] Chunk #2 of 2 ... DONE
[08:24:59.292] Launching 2 futures (chunks) ... DONE
[08:24:59.292] Resolving 2 futures (chunks) ...
[08:24:59.292] resolve() on list ...
[08:24:59.292]  recursive: 0
[08:24:59.292]  length: 2
[08:24:59.294] 
[08:24:59.295] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.295] - Validating connection of MultisessionFuture
[08:24:59.295] - received message: FutureResult
[08:24:59.295] - Received FutureResult
[08:24:59.296] - Erased future from FutureRegistry
[08:24:59.296] result() for ClusterFuture ...
[08:24:59.296] - result already collected: FutureResult
[08:24:59.296] result() for ClusterFuture ... done
[08:24:59.296] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.296] Future #1
[08:24:59.296] result() for ClusterFuture ...
[08:24:59.296] - result already collected: FutureResult
[08:24:59.296] result() for ClusterFuture ... done
[08:24:59.296] result() for ClusterFuture ...
[08:24:59.296] - result already collected: FutureResult
[08:24:59.296] result() for ClusterFuture ... done
[08:24:59.297] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:59.297] - nx: 2
[08:24:59.297] - relay: TRUE
[08:24:59.297] - stdout: TRUE
[08:24:59.297] - signal: TRUE
[08:24:59.297] - resignal: FALSE
[08:24:59.297] - force: TRUE
[08:24:59.297] - relayed: [n=2] FALSE, FALSE
[08:24:59.297] - queued futures: [n=2] FALSE, FALSE
[08:24:59.297]  - until=1
[08:24:59.297]  - relaying element #1
[08:24:59.297] result() for ClusterFuture ...
[08:24:59.297] - result already collected: FutureResult
[08:24:59.298] result() for ClusterFuture ... done
[08:24:59.298] result() for ClusterFuture ...
[08:24:59.298] - result already collected: FutureResult
[08:24:59.298] result() for ClusterFuture ... done
[08:24:59.298] result() for ClusterFuture ...
[08:24:59.298] - result already collected: FutureResult
[08:24:59.298] result() for ClusterFuture ... done
[08:24:59.298] result() for ClusterFuture ...
[08:24:59.298] - result already collected: FutureResult
[08:24:59.298] result() for ClusterFuture ... done
[08:24:59.298] - relayed: [n=2] TRUE, FALSE
[08:24:59.298] - queued futures: [n=2] TRUE, FALSE
[08:24:59.299] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:59.299]  length: 1 (resolved future 1)
[08:24:59.326] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.326] - Validating connection of MultisessionFuture
[08:24:59.326] - received message: FutureResult
[08:24:59.326] - Received FutureResult
[08:24:59.326] - Erased future from FutureRegistry
[08:24:59.327] result() for ClusterFuture ...
[08:24:59.327] - result already collected: FutureResult
[08:24:59.327] result() for ClusterFuture ... done
[08:24:59.327] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.327] Future #2
[08:24:59.327] result() for ClusterFuture ...
[08:24:59.327] - result already collected: FutureResult
[08:24:59.327] result() for ClusterFuture ... done
[08:24:59.327] result() for ClusterFuture ...
[08:24:59.327] - result already collected: FutureResult
[08:24:59.327] result() for ClusterFuture ... done
[08:24:59.328] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:59.328] - nx: 2
[08:24:59.328] - relay: TRUE
[08:24:59.328] - stdout: TRUE
[08:24:59.328] - signal: TRUE
[08:24:59.328] - resignal: FALSE
[08:24:59.328] - force: TRUE
[08:24:59.328] - relayed: [n=2] TRUE, FALSE
[08:24:59.328] - queued futures: [n=2] TRUE, FALSE
[08:24:59.328]  - until=2
[08:24:59.328]  - relaying element #2
[08:24:59.328] result() for ClusterFuture ...
[08:24:59.328] - result already collected: FutureResult
[08:24:59.329] result() for ClusterFuture ... done
[08:24:59.329] result() for ClusterFuture ...
[08:24:59.329] - result already collected: FutureResult
[08:24:59.329] result() for ClusterFuture ... done
[08:24:59.329] result() for ClusterFuture ...
[08:24:59.329] - result already collected: FutureResult
[08:24:59.329] result() for ClusterFuture ... done
[08:24:59.329] result() for ClusterFuture ...
[08:24:59.329] - result already collected: FutureResult
[08:24:59.329] result() for ClusterFuture ... done
[08:24:59.329] - relayed: [n=2] TRUE, TRUE
[08:24:59.329] - queued futures: [n=2] TRUE, TRUE
[08:24:59.330] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:59.330]  length: 0 (resolved future 2)
[08:24:59.330] Relaying remaining futures
[08:24:59.330] signalConditionsASAP(NULL, pos=0) ...
[08:24:59.330] - nx: 2
[08:24:59.330] - relay: TRUE
[08:24:59.330] - stdout: TRUE
[08:24:59.330] - signal: TRUE
[08:24:59.330] - resignal: FALSE
[08:24:59.330] - force: TRUE
[08:24:59.330] - relayed: [n=2] TRUE, TRUE
[08:24:59.330] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:59.331] - relayed: [n=2] TRUE, TRUE
[08:24:59.331] - queued futures: [n=2] TRUE, TRUE
[08:24:59.331] signalConditionsASAP(NULL, pos=0) ... done
[08:24:59.331] resolve() on list ... DONE
[08:24:59.331] result() for ClusterFuture ...
[08:24:59.331] - result already collected: FutureResult
[08:24:59.331] result() for ClusterFuture ... done
[08:24:59.331] result() for ClusterFuture ...
[08:24:59.331] - result already collected: FutureResult
[08:24:59.331] result() for ClusterFuture ... done
[08:24:59.331] result() for ClusterFuture ...
[08:24:59.331] - result already collected: FutureResult
[08:24:59.332] result() for ClusterFuture ... done
[08:24:59.332] result() for ClusterFuture ...
[08:24:59.332] - result already collected: FutureResult
[08:24:59.332] result() for ClusterFuture ... done
[08:24:59.332]  - Number of value chunks collected: 2
[08:24:59.332] Resolving 2 futures (chunks) ... DONE
[08:24:59.332] Reducing values from 2 chunks ...
[08:24:59.332]  - Number of values collected after concatenation: 3
[08:24:59.332]  - Number of values expected: 3
[08:24:59.332] Reducing values from 2 chunks ... DONE
[08:24:59.332] future_lapply() ... DONE
[08:24:59.332] future_by_internal() ... DONE
[08:24:59.336] future_by_internal() ...
[08:24:59.337] future_lapply() ...
[08:24:59.339] Number of chunks: 2
[08:24:59.339] getGlobalsAndPackagesXApply() ...
[08:24:59.339]  - future.globals: TRUE
[08:24:59.339] getGlobalsAndPackages() ...
[08:24:59.339] Searching for globals...
[08:24:59.341] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[08:24:59.341] Searching for globals ... DONE
[08:24:59.341] Resolving globals: FALSE
[08:24:59.342] The total size of the 3 globals is 2.07 KiB (2118 bytes)
[08:24:59.342] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.28 KiB of class ‘function’), ‘breaks’ (463 bytes of class ‘numeric’) and ‘wool’ (342 bytes of class ‘numeric’)
[08:24:59.342] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:59.342] - packages: [1] ‘stats’
[08:24:59.342] getGlobalsAndPackages() ... DONE
[08:24:59.342]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[08:24:59.343]  - needed namespaces: [n=1] ‘stats’
[08:24:59.343] Finding globals ... DONE
[08:24:59.343]  - use_args: TRUE
[08:24:59.343]  - Getting '...' globals ...
[08:24:59.343] resolve() on list ...
[08:24:59.343]  recursive: 0
[08:24:59.343]  length: 1
[08:24:59.343]  elements: ‘...’
[08:24:59.344]  length: 0 (resolved future 1)
[08:24:59.344] resolve() on list ... DONE
[08:24:59.344]    - '...' content: [n=0] 
[08:24:59.344] List of 1
[08:24:59.344]  $ ...: list()
[08:24:59.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.344]  - attr(*, "where")=List of 1
[08:24:59.344]   ..$ ...:<environment: 0x557b29f78160> 
[08:24:59.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.344]  - attr(*, "resolved")= logi TRUE
[08:24:59.344]  - attr(*, "total_size")= num NA
[08:24:59.346]  - Getting '...' globals ... DONE
[08:24:59.346] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[08:24:59.346] List of 4
[08:24:59.346]  $ ...future.FUN:function (x)  
[08:24:59.346]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[08:24:59.346]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[08:24:59.346]  $ ...          : list()
[08:24:59.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.346]  - attr(*, "where")=List of 4
[08:24:59.346]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:59.346]   ..$ breaks       :<environment: R_EmptyEnv> 
[08:24:59.346]   ..$ wool         :<environment: R_EmptyEnv> 
[08:24:59.346]   ..$ ...          :<environment: 0x557b29f78160> 
[08:24:59.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.346]  - attr(*, "resolved")= logi FALSE
[08:24:59.346]  - attr(*, "total_size")= num 18867
[08:24:59.350] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:59.350] getGlobalsAndPackagesXApply() ... DONE
[08:24:59.350] Number of futures (= number of chunks): 2
[08:24:59.350] Launching 2 futures (chunks) ...
[08:24:59.351] Chunk #1 of 2 ...
[08:24:59.351]  - Finding globals in 'X' for chunk #1 ...
[08:24:59.351] getGlobalsAndPackages() ...
[08:24:59.351] Searching for globals...
[08:24:59.351] 
[08:24:59.351] Searching for globals ... DONE
[08:24:59.351] - globals: [0] <none>
[08:24:59.351] getGlobalsAndPackages() ... DONE
[08:24:59.351]    + additional globals found: [n=0] 
[08:24:59.352]    + additional namespaces needed: [n=0] 
[08:24:59.352]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:59.352]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.352]  - seeds: <none>
[08:24:59.352]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.352] getGlobalsAndPackages() ...
[08:24:59.352] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.352] Resolving globals: FALSE
[08:24:59.352] Tweak future expression to call with '...' arguments ...
[08:24:59.352] {
[08:24:59.352]     do.call(function(...) {
[08:24:59.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.352]             on.exit(options(oopts), add = TRUE)
[08:24:59.352]         }
[08:24:59.352]         {
[08:24:59.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.352]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.352]             })
[08:24:59.352]         }
[08:24:59.352]     }, args = future.call.arguments)
[08:24:59.352] }
[08:24:59.353] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.353] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.353] 
[08:24:59.353] getGlobalsAndPackages() ... DONE
[08:24:59.354] run() for ‘Future’ ...
[08:24:59.354] - state: ‘created’
[08:24:59.354] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.367] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.368]   - Field: ‘node’
[08:24:59.368]   - Field: ‘label’
[08:24:59.368]   - Field: ‘local’
[08:24:59.368]   - Field: ‘owner’
[08:24:59.368]   - Field: ‘envir’
[08:24:59.368]   - Field: ‘workers’
[08:24:59.368]   - Field: ‘packages’
[08:24:59.368]   - Field: ‘gc’
[08:24:59.368]   - Field: ‘conditions’
[08:24:59.368]   - Field: ‘persistent’
[08:24:59.369]   - Field: ‘expr’
[08:24:59.369]   - Field: ‘uuid’
[08:24:59.369]   - Field: ‘seed’
[08:24:59.369]   - Field: ‘version’
[08:24:59.369]   - Field: ‘result’
[08:24:59.369]   - Field: ‘asynchronous’
[08:24:59.369]   - Field: ‘calls’
[08:24:59.369]   - Field: ‘globals’
[08:24:59.369]   - Field: ‘stdout’
[08:24:59.369]   - Field: ‘earlySignal’
[08:24:59.369]   - Field: ‘lazy’
[08:24:59.369]   - Field: ‘state’
[08:24:59.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.370] - Launch lazy future ...
[08:24:59.370] Packages needed by the future expression (n = 1): ‘stats’
[08:24:59.370] Packages needed by future strategies (n = 0): <none>
[08:24:59.371] {
[08:24:59.371]     {
[08:24:59.371]         {
[08:24:59.371]             ...future.startTime <- base::Sys.time()
[08:24:59.371]             {
[08:24:59.371]                 {
[08:24:59.371]                   {
[08:24:59.371]                     {
[08:24:59.371]                       {
[08:24:59.371]                         base::local({
[08:24:59.371]                           has_future <- base::requireNamespace("future", 
[08:24:59.371]                             quietly = TRUE)
[08:24:59.371]                           if (has_future) {
[08:24:59.371]                             ns <- base::getNamespace("future")
[08:24:59.371]                             version <- ns[[".package"]][["version"]]
[08:24:59.371]                             if (is.null(version)) 
[08:24:59.371]                               version <- utils::packageVersion("future")
[08:24:59.371]                           }
[08:24:59.371]                           else {
[08:24:59.371]                             version <- NULL
[08:24:59.371]                           }
[08:24:59.371]                           if (!has_future || version < "1.8.0") {
[08:24:59.371]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.371]                               "", base::R.version$version.string), 
[08:24:59.371]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:59.371]                                 base::R.version$platform, 8 * 
[08:24:59.371]                                   base::.Machine$sizeof.pointer), 
[08:24:59.371]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.371]                                 "release", "version")], collapse = " "), 
[08:24:59.371]                               hostname = base::Sys.info()[["nodename"]])
[08:24:59.371]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.371]                               info)
[08:24:59.371]                             info <- base::paste(info, collapse = "; ")
[08:24:59.371]                             if (!has_future) {
[08:24:59.371]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.371]                                 info)
[08:24:59.371]                             }
[08:24:59.371]                             else {
[08:24:59.371]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.371]                                 info, version)
[08:24:59.371]                             }
[08:24:59.371]                             base::stop(msg)
[08:24:59.371]                           }
[08:24:59.371]                         })
[08:24:59.371]                       }
[08:24:59.371]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.371]                       base::options(mc.cores = 1L)
[08:24:59.371]                     }
[08:24:59.371]                     base::local({
[08:24:59.371]                       for (pkg in "stats") {
[08:24:59.371]                         base::loadNamespace(pkg)
[08:24:59.371]                         base::library(pkg, character.only = TRUE)
[08:24:59.371]                       }
[08:24:59.371]                     })
[08:24:59.371]                   }
[08:24:59.371]                   ...future.strategy.old <- future::plan("list")
[08:24:59.371]                   options(future.plan = NULL)
[08:24:59.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.371]                 }
[08:24:59.371]                 ...future.workdir <- getwd()
[08:24:59.371]             }
[08:24:59.371]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.371]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.371]         }
[08:24:59.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.371]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.371]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.371]             base::names(...future.oldOptions))
[08:24:59.371]     }
[08:24:59.371]     if (FALSE) {
[08:24:59.371]     }
[08:24:59.371]     else {
[08:24:59.371]         if (TRUE) {
[08:24:59.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.371]                 open = "w")
[08:24:59.371]         }
[08:24:59.371]         else {
[08:24:59.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.371]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.371]         }
[08:24:59.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.371]             base::sink(type = "output", split = FALSE)
[08:24:59.371]             base::close(...future.stdout)
[08:24:59.371]         }, add = TRUE)
[08:24:59.371]     }
[08:24:59.371]     ...future.frame <- base::sys.nframe()
[08:24:59.371]     ...future.conditions <- base::list()
[08:24:59.371]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.371]     if (FALSE) {
[08:24:59.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.371]     }
[08:24:59.371]     ...future.result <- base::tryCatch({
[08:24:59.371]         base::withCallingHandlers({
[08:24:59.371]             ...future.value <- base::withVisible(base::local({
[08:24:59.371]                 ...future.makeSendCondition <- base::local({
[08:24:59.371]                   sendCondition <- NULL
[08:24:59.371]                   function(frame = 1L) {
[08:24:59.371]                     if (is.function(sendCondition)) 
[08:24:59.371]                       return(sendCondition)
[08:24:59.371]                     ns <- getNamespace("parallel")
[08:24:59.371]                     if (exists("sendData", mode = "function", 
[08:24:59.371]                       envir = ns)) {
[08:24:59.371]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.371]                         envir = ns)
[08:24:59.371]                       envir <- sys.frame(frame)
[08:24:59.371]                       master <- NULL
[08:24:59.371]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.371]                         !identical(envir, emptyenv())) {
[08:24:59.371]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.371]                           inherits = FALSE)) {
[08:24:59.371]                           master <- get("master", mode = "list", 
[08:24:59.371]                             envir = envir, inherits = FALSE)
[08:24:59.371]                           if (inherits(master, c("SOCKnode", 
[08:24:59.371]                             "SOCK0node"))) {
[08:24:59.371]                             sendCondition <<- function(cond) {
[08:24:59.371]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.371]                                 success = TRUE)
[08:24:59.371]                               parallel_sendData(master, data)
[08:24:59.371]                             }
[08:24:59.371]                             return(sendCondition)
[08:24:59.371]                           }
[08:24:59.371]                         }
[08:24:59.371]                         frame <- frame + 1L
[08:24:59.371]                         envir <- sys.frame(frame)
[08:24:59.371]                       }
[08:24:59.371]                     }
[08:24:59.371]                     sendCondition <<- function(cond) NULL
[08:24:59.371]                   }
[08:24:59.371]                 })
[08:24:59.371]                 withCallingHandlers({
[08:24:59.371]                   {
[08:24:59.371]                     do.call(function(...) {
[08:24:59.371]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.371]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.371]                         ...future.globals.maxSize)) {
[08:24:59.371]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.371]                         on.exit(options(oopts), add = TRUE)
[08:24:59.371]                       }
[08:24:59.371]                       {
[08:24:59.371]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.371]                           FUN = function(jj) {
[08:24:59.371]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.371]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.371]                           })
[08:24:59.371]                       }
[08:24:59.371]                     }, args = future.call.arguments)
[08:24:59.371]                   }
[08:24:59.371]                 }, immediateCondition = function(cond) {
[08:24:59.371]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.371]                   sendCondition(cond)
[08:24:59.371]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.371]                   {
[08:24:59.371]                     inherits <- base::inherits
[08:24:59.371]                     invokeRestart <- base::invokeRestart
[08:24:59.371]                     is.null <- base::is.null
[08:24:59.371]                     muffled <- FALSE
[08:24:59.371]                     if (inherits(cond, "message")) {
[08:24:59.371]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.371]                       if (muffled) 
[08:24:59.371]                         invokeRestart("muffleMessage")
[08:24:59.371]                     }
[08:24:59.371]                     else if (inherits(cond, "warning")) {
[08:24:59.371]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.371]                       if (muffled) 
[08:24:59.371]                         invokeRestart("muffleWarning")
[08:24:59.371]                     }
[08:24:59.371]                     else if (inherits(cond, "condition")) {
[08:24:59.371]                       if (!is.null(pattern)) {
[08:24:59.371]                         computeRestarts <- base::computeRestarts
[08:24:59.371]                         grepl <- base::grepl
[08:24:59.371]                         restarts <- computeRestarts(cond)
[08:24:59.371]                         for (restart in restarts) {
[08:24:59.371]                           name <- restart$name
[08:24:59.371]                           if (is.null(name)) 
[08:24:59.371]                             next
[08:24:59.371]                           if (!grepl(pattern, name)) 
[08:24:59.371]                             next
[08:24:59.371]                           invokeRestart(restart)
[08:24:59.371]                           muffled <- TRUE
[08:24:59.371]                           break
[08:24:59.371]                         }
[08:24:59.371]                       }
[08:24:59.371]                     }
[08:24:59.371]                     invisible(muffled)
[08:24:59.371]                   }
[08:24:59.371]                   muffleCondition(cond)
[08:24:59.371]                 })
[08:24:59.371]             }))
[08:24:59.371]             future::FutureResult(value = ...future.value$value, 
[08:24:59.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.371]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.371]                     ...future.globalenv.names))
[08:24:59.371]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.371]         }, condition = base::local({
[08:24:59.371]             c <- base::c
[08:24:59.371]             inherits <- base::inherits
[08:24:59.371]             invokeRestart <- base::invokeRestart
[08:24:59.371]             length <- base::length
[08:24:59.371]             list <- base::list
[08:24:59.371]             seq.int <- base::seq.int
[08:24:59.371]             signalCondition <- base::signalCondition
[08:24:59.371]             sys.calls <- base::sys.calls
[08:24:59.371]             `[[` <- base::`[[`
[08:24:59.371]             `+` <- base::`+`
[08:24:59.371]             `<<-` <- base::`<<-`
[08:24:59.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.371]                   3L)]
[08:24:59.371]             }
[08:24:59.371]             function(cond) {
[08:24:59.371]                 is_error <- inherits(cond, "error")
[08:24:59.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.371]                   NULL)
[08:24:59.371]                 if (is_error) {
[08:24:59.371]                   sessionInformation <- function() {
[08:24:59.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.371]                       search = base::search(), system = base::Sys.info())
[08:24:59.371]                   }
[08:24:59.371]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.371]                     cond$call), session = sessionInformation(), 
[08:24:59.371]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.371]                   signalCondition(cond)
[08:24:59.371]                 }
[08:24:59.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.371]                 "immediateCondition"))) {
[08:24:59.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.371]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.371]                   if (TRUE && !signal) {
[08:24:59.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.371]                     {
[08:24:59.371]                       inherits <- base::inherits
[08:24:59.371]                       invokeRestart <- base::invokeRestart
[08:24:59.371]                       is.null <- base::is.null
[08:24:59.371]                       muffled <- FALSE
[08:24:59.371]                       if (inherits(cond, "message")) {
[08:24:59.371]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.371]                         if (muffled) 
[08:24:59.371]                           invokeRestart("muffleMessage")
[08:24:59.371]                       }
[08:24:59.371]                       else if (inherits(cond, "warning")) {
[08:24:59.371]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.371]                         if (muffled) 
[08:24:59.371]                           invokeRestart("muffleWarning")
[08:24:59.371]                       }
[08:24:59.371]                       else if (inherits(cond, "condition")) {
[08:24:59.371]                         if (!is.null(pattern)) {
[08:24:59.371]                           computeRestarts <- base::computeRestarts
[08:24:59.371]                           grepl <- base::grepl
[08:24:59.371]                           restarts <- computeRestarts(cond)
[08:24:59.371]                           for (restart in restarts) {
[08:24:59.371]                             name <- restart$name
[08:24:59.371]                             if (is.null(name)) 
[08:24:59.371]                               next
[08:24:59.371]                             if (!grepl(pattern, name)) 
[08:24:59.371]                               next
[08:24:59.371]                             invokeRestart(restart)
[08:24:59.371]                             muffled <- TRUE
[08:24:59.371]                             break
[08:24:59.371]                           }
[08:24:59.371]                         }
[08:24:59.371]                       }
[08:24:59.371]                       invisible(muffled)
[08:24:59.371]                     }
[08:24:59.371]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.371]                   }
[08:24:59.371]                 }
[08:24:59.371]                 else {
[08:24:59.371]                   if (TRUE) {
[08:24:59.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.371]                     {
[08:24:59.371]                       inherits <- base::inherits
[08:24:59.371]                       invokeRestart <- base::invokeRestart
[08:24:59.371]                       is.null <- base::is.null
[08:24:59.371]                       muffled <- FALSE
[08:24:59.371]                       if (inherits(cond, "message")) {
[08:24:59.371]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.371]                         if (muffled) 
[08:24:59.371]                           invokeRestart("muffleMessage")
[08:24:59.371]                       }
[08:24:59.371]                       else if (inherits(cond, "warning")) {
[08:24:59.371]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.371]                         if (muffled) 
[08:24:59.371]                           invokeRestart("muffleWarning")
[08:24:59.371]                       }
[08:24:59.371]                       else if (inherits(cond, "condition")) {
[08:24:59.371]                         if (!is.null(pattern)) {
[08:24:59.371]                           computeRestarts <- base::computeRestarts
[08:24:59.371]                           grepl <- base::grepl
[08:24:59.371]                           restarts <- computeRestarts(cond)
[08:24:59.371]                           for (restart in restarts) {
[08:24:59.371]                             name <- restart$name
[08:24:59.371]                             if (is.null(name)) 
[08:24:59.371]                               next
[08:24:59.371]                             if (!grepl(pattern, name)) 
[08:24:59.371]                               next
[08:24:59.371]                             invokeRestart(restart)
[08:24:59.371]                             muffled <- TRUE
[08:24:59.371]                             break
[08:24:59.371]                           }
[08:24:59.371]                         }
[08:24:59.371]                       }
[08:24:59.371]                       invisible(muffled)
[08:24:59.371]                     }
[08:24:59.371]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.371]                   }
[08:24:59.371]                 }
[08:24:59.371]             }
[08:24:59.371]         }))
[08:24:59.371]     }, error = function(ex) {
[08:24:59.371]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.371]                 ...future.rng), started = ...future.startTime, 
[08:24:59.371]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.371]             version = "1.8"), class = "FutureResult")
[08:24:59.371]     }, finally = {
[08:24:59.371]         if (!identical(...future.workdir, getwd())) 
[08:24:59.371]             setwd(...future.workdir)
[08:24:59.371]         {
[08:24:59.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.371]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.371]             }
[08:24:59.371]             base::options(...future.oldOptions)
[08:24:59.371]             if (.Platform$OS.type == "windows") {
[08:24:59.371]                 old_names <- names(...future.oldEnvVars)
[08:24:59.371]                 envs <- base::Sys.getenv()
[08:24:59.371]                 names <- names(envs)
[08:24:59.371]                 common <- intersect(names, old_names)
[08:24:59.371]                 added <- setdiff(names, old_names)
[08:24:59.371]                 removed <- setdiff(old_names, names)
[08:24:59.371]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.371]                   envs[common]]
[08:24:59.371]                 NAMES <- toupper(changed)
[08:24:59.371]                 args <- list()
[08:24:59.371]                 for (kk in seq_along(NAMES)) {
[08:24:59.371]                   name <- changed[[kk]]
[08:24:59.371]                   NAME <- NAMES[[kk]]
[08:24:59.371]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.371]                     next
[08:24:59.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.371]                 }
[08:24:59.371]                 NAMES <- toupper(added)
[08:24:59.371]                 for (kk in seq_along(NAMES)) {
[08:24:59.371]                   name <- added[[kk]]
[08:24:59.371]                   NAME <- NAMES[[kk]]
[08:24:59.371]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.371]                     next
[08:24:59.371]                   args[[name]] <- ""
[08:24:59.371]                 }
[08:24:59.371]                 NAMES <- toupper(removed)
[08:24:59.371]                 for (kk in seq_along(NAMES)) {
[08:24:59.371]                   name <- removed[[kk]]
[08:24:59.371]                   NAME <- NAMES[[kk]]
[08:24:59.371]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.371]                     next
[08:24:59.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.371]                 }
[08:24:59.371]                 if (length(args) > 0) 
[08:24:59.371]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.371]             }
[08:24:59.371]             else {
[08:24:59.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.371]             }
[08:24:59.371]             {
[08:24:59.371]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.371]                   0L) {
[08:24:59.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.371]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.371]                   base::options(opts)
[08:24:59.371]                 }
[08:24:59.371]                 {
[08:24:59.371]                   {
[08:24:59.371]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.371]                     NULL
[08:24:59.371]                   }
[08:24:59.371]                   options(future.plan = NULL)
[08:24:59.371]                   if (is.na(NA_character_)) 
[08:24:59.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.371]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.371]                     .init = FALSE)
[08:24:59.371]                 }
[08:24:59.371]             }
[08:24:59.371]         }
[08:24:59.371]     })
[08:24:59.371]     if (TRUE) {
[08:24:59.371]         base::sink(type = "output", split = FALSE)
[08:24:59.371]         if (TRUE) {
[08:24:59.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.371]         }
[08:24:59.371]         else {
[08:24:59.371]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.371]         }
[08:24:59.371]         base::close(...future.stdout)
[08:24:59.371]         ...future.stdout <- NULL
[08:24:59.371]     }
[08:24:59.371]     ...future.result$conditions <- ...future.conditions
[08:24:59.371]     ...future.result$finished <- base::Sys.time()
[08:24:59.371]     ...future.result
[08:24:59.371] }
[08:24:59.374] Exporting 7 global objects (3.33 KiB) to cluster node #1 ...
[08:24:59.374] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ...
[08:24:59.374] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ... DONE
[08:24:59.374] Exporting ‘breaks’ (463 bytes) to cluster node #1 ...
[08:24:59.375] Exporting ‘breaks’ (463 bytes) to cluster node #1 ... DONE
[08:24:59.375] Exporting ‘wool’ (342 bytes) to cluster node #1 ...
[08:24:59.375] Exporting ‘wool’ (342 bytes) to cluster node #1 ... DONE
[08:24:59.375] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:59.376] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:59.376] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[08:24:59.376] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[08:24:59.376] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:59.376] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.377] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:24:59.377] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.377] Exporting 7 global objects (3.33 KiB) to cluster node #1 ... DONE
[08:24:59.377] MultisessionFuture started
[08:24:59.377] - Launch lazy future ... done
[08:24:59.378] run() for ‘MultisessionFuture’ ... done
[08:24:59.378] Created future:
[08:24:59.378] MultisessionFuture:
[08:24:59.378] Label: ‘future_by-1’
[08:24:59.378] Expression:
[08:24:59.378] {
[08:24:59.378]     do.call(function(...) {
[08:24:59.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.378]             on.exit(options(oopts), add = TRUE)
[08:24:59.378]         }
[08:24:59.378]         {
[08:24:59.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.378]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.378]             })
[08:24:59.378]         }
[08:24:59.378]     }, args = future.call.arguments)
[08:24:59.378] }
[08:24:59.378] Lazy evaluation: FALSE
[08:24:59.378] Asynchronous evaluation: TRUE
[08:24:59.378] Local evaluation: TRUE
[08:24:59.378] Environment: 0x557b29fad018
[08:24:59.378] Capture standard output: TRUE
[08:24:59.378] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.378] Globals: 7 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, ...)
[08:24:59.378] Packages: 1 packages (‘stats’)
[08:24:59.378] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.378] Resolved: FALSE
[08:24:59.378] Value: <not collected>
[08:24:59.378] Conditions captured: <none>
[08:24:59.378] Early signaling: FALSE
[08:24:59.378] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.378] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.389] Chunk #1 of 2 ... DONE
[08:24:59.389] Chunk #2 of 2 ...
[08:24:59.390]  - Finding globals in 'X' for chunk #2 ...
[08:24:59.390] getGlobalsAndPackages() ...
[08:24:59.390] Searching for globals...
[08:24:59.390] 
[08:24:59.390] Searching for globals ... DONE
[08:24:59.390] - globals: [0] <none>
[08:24:59.391] getGlobalsAndPackages() ... DONE
[08:24:59.391]    + additional globals found: [n=0] 
[08:24:59.391]    + additional namespaces needed: [n=0] 
[08:24:59.391]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:59.391]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.391]  - seeds: <none>
[08:24:59.391]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.391] getGlobalsAndPackages() ...
[08:24:59.391] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.391] Resolving globals: FALSE
[08:24:59.391] Tweak future expression to call with '...' arguments ...
[08:24:59.392] {
[08:24:59.392]     do.call(function(...) {
[08:24:59.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.392]             on.exit(options(oopts), add = TRUE)
[08:24:59.392]         }
[08:24:59.392]         {
[08:24:59.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.392]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.392]             })
[08:24:59.392]         }
[08:24:59.392]     }, args = future.call.arguments)
[08:24:59.392] }
[08:24:59.392] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.392] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.392] 
[08:24:59.392] getGlobalsAndPackages() ... DONE
[08:24:59.393] run() for ‘Future’ ...
[08:24:59.393] - state: ‘created’
[08:24:59.393] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.406] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.407]   - Field: ‘node’
[08:24:59.407]   - Field: ‘label’
[08:24:59.407]   - Field: ‘local’
[08:24:59.407]   - Field: ‘owner’
[08:24:59.407]   - Field: ‘envir’
[08:24:59.407]   - Field: ‘workers’
[08:24:59.407]   - Field: ‘packages’
[08:24:59.407]   - Field: ‘gc’
[08:24:59.407]   - Field: ‘conditions’
[08:24:59.408]   - Field: ‘persistent’
[08:24:59.408]   - Field: ‘expr’
[08:24:59.408]   - Field: ‘uuid’
[08:24:59.408]   - Field: ‘seed’
[08:24:59.408]   - Field: ‘version’
[08:24:59.408]   - Field: ‘result’
[08:24:59.408]   - Field: ‘asynchronous’
[08:24:59.408]   - Field: ‘calls’
[08:24:59.408]   - Field: ‘globals’
[08:24:59.408]   - Field: ‘stdout’
[08:24:59.408]   - Field: ‘earlySignal’
[08:24:59.408]   - Field: ‘lazy’
[08:24:59.409]   - Field: ‘state’
[08:24:59.409] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.409] - Launch lazy future ...
[08:24:59.409] Packages needed by the future expression (n = 1): ‘stats’
[08:24:59.409] Packages needed by future strategies (n = 0): <none>
[08:24:59.410] {
[08:24:59.410]     {
[08:24:59.410]         {
[08:24:59.410]             ...future.startTime <- base::Sys.time()
[08:24:59.410]             {
[08:24:59.410]                 {
[08:24:59.410]                   {
[08:24:59.410]                     {
[08:24:59.410]                       {
[08:24:59.410]                         base::local({
[08:24:59.410]                           has_future <- base::requireNamespace("future", 
[08:24:59.410]                             quietly = TRUE)
[08:24:59.410]                           if (has_future) {
[08:24:59.410]                             ns <- base::getNamespace("future")
[08:24:59.410]                             version <- ns[[".package"]][["version"]]
[08:24:59.410]                             if (is.null(version)) 
[08:24:59.410]                               version <- utils::packageVersion("future")
[08:24:59.410]                           }
[08:24:59.410]                           else {
[08:24:59.410]                             version <- NULL
[08:24:59.410]                           }
[08:24:59.410]                           if (!has_future || version < "1.8.0") {
[08:24:59.410]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.410]                               "", base::R.version$version.string), 
[08:24:59.410]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:59.410]                                 base::R.version$platform, 8 * 
[08:24:59.410]                                   base::.Machine$sizeof.pointer), 
[08:24:59.410]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.410]                                 "release", "version")], collapse = " "), 
[08:24:59.410]                               hostname = base::Sys.info()[["nodename"]])
[08:24:59.410]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.410]                               info)
[08:24:59.410]                             info <- base::paste(info, collapse = "; ")
[08:24:59.410]                             if (!has_future) {
[08:24:59.410]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.410]                                 info)
[08:24:59.410]                             }
[08:24:59.410]                             else {
[08:24:59.410]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.410]                                 info, version)
[08:24:59.410]                             }
[08:24:59.410]                             base::stop(msg)
[08:24:59.410]                           }
[08:24:59.410]                         })
[08:24:59.410]                       }
[08:24:59.410]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.410]                       base::options(mc.cores = 1L)
[08:24:59.410]                     }
[08:24:59.410]                     base::local({
[08:24:59.410]                       for (pkg in "stats") {
[08:24:59.410]                         base::loadNamespace(pkg)
[08:24:59.410]                         base::library(pkg, character.only = TRUE)
[08:24:59.410]                       }
[08:24:59.410]                     })
[08:24:59.410]                   }
[08:24:59.410]                   ...future.strategy.old <- future::plan("list")
[08:24:59.410]                   options(future.plan = NULL)
[08:24:59.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.410]                 }
[08:24:59.410]                 ...future.workdir <- getwd()
[08:24:59.410]             }
[08:24:59.410]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.410]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.410]         }
[08:24:59.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.410]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.410]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.410]             base::names(...future.oldOptions))
[08:24:59.410]     }
[08:24:59.410]     if (FALSE) {
[08:24:59.410]     }
[08:24:59.410]     else {
[08:24:59.410]         if (TRUE) {
[08:24:59.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.410]                 open = "w")
[08:24:59.410]         }
[08:24:59.410]         else {
[08:24:59.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.410]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.410]         }
[08:24:59.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.410]             base::sink(type = "output", split = FALSE)
[08:24:59.410]             base::close(...future.stdout)
[08:24:59.410]         }, add = TRUE)
[08:24:59.410]     }
[08:24:59.410]     ...future.frame <- base::sys.nframe()
[08:24:59.410]     ...future.conditions <- base::list()
[08:24:59.410]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.410]     if (FALSE) {
[08:24:59.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.410]     }
[08:24:59.410]     ...future.result <- base::tryCatch({
[08:24:59.410]         base::withCallingHandlers({
[08:24:59.410]             ...future.value <- base::withVisible(base::local({
[08:24:59.410]                 ...future.makeSendCondition <- base::local({
[08:24:59.410]                   sendCondition <- NULL
[08:24:59.410]                   function(frame = 1L) {
[08:24:59.410]                     if (is.function(sendCondition)) 
[08:24:59.410]                       return(sendCondition)
[08:24:59.410]                     ns <- getNamespace("parallel")
[08:24:59.410]                     if (exists("sendData", mode = "function", 
[08:24:59.410]                       envir = ns)) {
[08:24:59.410]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.410]                         envir = ns)
[08:24:59.410]                       envir <- sys.frame(frame)
[08:24:59.410]                       master <- NULL
[08:24:59.410]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.410]                         !identical(envir, emptyenv())) {
[08:24:59.410]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.410]                           inherits = FALSE)) {
[08:24:59.410]                           master <- get("master", mode = "list", 
[08:24:59.410]                             envir = envir, inherits = FALSE)
[08:24:59.410]                           if (inherits(master, c("SOCKnode", 
[08:24:59.410]                             "SOCK0node"))) {
[08:24:59.410]                             sendCondition <<- function(cond) {
[08:24:59.410]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.410]                                 success = TRUE)
[08:24:59.410]                               parallel_sendData(master, data)
[08:24:59.410]                             }
[08:24:59.410]                             return(sendCondition)
[08:24:59.410]                           }
[08:24:59.410]                         }
[08:24:59.410]                         frame <- frame + 1L
[08:24:59.410]                         envir <- sys.frame(frame)
[08:24:59.410]                       }
[08:24:59.410]                     }
[08:24:59.410]                     sendCondition <<- function(cond) NULL
[08:24:59.410]                   }
[08:24:59.410]                 })
[08:24:59.410]                 withCallingHandlers({
[08:24:59.410]                   {
[08:24:59.410]                     do.call(function(...) {
[08:24:59.410]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.410]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.410]                         ...future.globals.maxSize)) {
[08:24:59.410]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.410]                         on.exit(options(oopts), add = TRUE)
[08:24:59.410]                       }
[08:24:59.410]                       {
[08:24:59.410]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.410]                           FUN = function(jj) {
[08:24:59.410]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.410]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.410]                           })
[08:24:59.410]                       }
[08:24:59.410]                     }, args = future.call.arguments)
[08:24:59.410]                   }
[08:24:59.410]                 }, immediateCondition = function(cond) {
[08:24:59.410]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.410]                   sendCondition(cond)
[08:24:59.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.410]                   {
[08:24:59.410]                     inherits <- base::inherits
[08:24:59.410]                     invokeRestart <- base::invokeRestart
[08:24:59.410]                     is.null <- base::is.null
[08:24:59.410]                     muffled <- FALSE
[08:24:59.410]                     if (inherits(cond, "message")) {
[08:24:59.410]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.410]                       if (muffled) 
[08:24:59.410]                         invokeRestart("muffleMessage")
[08:24:59.410]                     }
[08:24:59.410]                     else if (inherits(cond, "warning")) {
[08:24:59.410]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.410]                       if (muffled) 
[08:24:59.410]                         invokeRestart("muffleWarning")
[08:24:59.410]                     }
[08:24:59.410]                     else if (inherits(cond, "condition")) {
[08:24:59.410]                       if (!is.null(pattern)) {
[08:24:59.410]                         computeRestarts <- base::computeRestarts
[08:24:59.410]                         grepl <- base::grepl
[08:24:59.410]                         restarts <- computeRestarts(cond)
[08:24:59.410]                         for (restart in restarts) {
[08:24:59.410]                           name <- restart$name
[08:24:59.410]                           if (is.null(name)) 
[08:24:59.410]                             next
[08:24:59.410]                           if (!grepl(pattern, name)) 
[08:24:59.410]                             next
[08:24:59.410]                           invokeRestart(restart)
[08:24:59.410]                           muffled <- TRUE
[08:24:59.410]                           break
[08:24:59.410]                         }
[08:24:59.410]                       }
[08:24:59.410]                     }
[08:24:59.410]                     invisible(muffled)
[08:24:59.410]                   }
[08:24:59.410]                   muffleCondition(cond)
[08:24:59.410]                 })
[08:24:59.410]             }))
[08:24:59.410]             future::FutureResult(value = ...future.value$value, 
[08:24:59.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.410]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.410]                     ...future.globalenv.names))
[08:24:59.410]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.410]         }, condition = base::local({
[08:24:59.410]             c <- base::c
[08:24:59.410]             inherits <- base::inherits
[08:24:59.410]             invokeRestart <- base::invokeRestart
[08:24:59.410]             length <- base::length
[08:24:59.410]             list <- base::list
[08:24:59.410]             seq.int <- base::seq.int
[08:24:59.410]             signalCondition <- base::signalCondition
[08:24:59.410]             sys.calls <- base::sys.calls
[08:24:59.410]             `[[` <- base::`[[`
[08:24:59.410]             `+` <- base::`+`
[08:24:59.410]             `<<-` <- base::`<<-`
[08:24:59.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.410]                   3L)]
[08:24:59.410]             }
[08:24:59.410]             function(cond) {
[08:24:59.410]                 is_error <- inherits(cond, "error")
[08:24:59.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.410]                   NULL)
[08:24:59.410]                 if (is_error) {
[08:24:59.410]                   sessionInformation <- function() {
[08:24:59.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.410]                       search = base::search(), system = base::Sys.info())
[08:24:59.410]                   }
[08:24:59.410]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.410]                     cond$call), session = sessionInformation(), 
[08:24:59.410]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.410]                   signalCondition(cond)
[08:24:59.410]                 }
[08:24:59.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.410]                 "immediateCondition"))) {
[08:24:59.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.410]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.410]                   if (TRUE && !signal) {
[08:24:59.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.410]                     {
[08:24:59.410]                       inherits <- base::inherits
[08:24:59.410]                       invokeRestart <- base::invokeRestart
[08:24:59.410]                       is.null <- base::is.null
[08:24:59.410]                       muffled <- FALSE
[08:24:59.410]                       if (inherits(cond, "message")) {
[08:24:59.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.410]                         if (muffled) 
[08:24:59.410]                           invokeRestart("muffleMessage")
[08:24:59.410]                       }
[08:24:59.410]                       else if (inherits(cond, "warning")) {
[08:24:59.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.410]                         if (muffled) 
[08:24:59.410]                           invokeRestart("muffleWarning")
[08:24:59.410]                       }
[08:24:59.410]                       else if (inherits(cond, "condition")) {
[08:24:59.410]                         if (!is.null(pattern)) {
[08:24:59.410]                           computeRestarts <- base::computeRestarts
[08:24:59.410]                           grepl <- base::grepl
[08:24:59.410]                           restarts <- computeRestarts(cond)
[08:24:59.410]                           for (restart in restarts) {
[08:24:59.410]                             name <- restart$name
[08:24:59.410]                             if (is.null(name)) 
[08:24:59.410]                               next
[08:24:59.410]                             if (!grepl(pattern, name)) 
[08:24:59.410]                               next
[08:24:59.410]                             invokeRestart(restart)
[08:24:59.410]                             muffled <- TRUE
[08:24:59.410]                             break
[08:24:59.410]                           }
[08:24:59.410]                         }
[08:24:59.410]                       }
[08:24:59.410]                       invisible(muffled)
[08:24:59.410]                     }
[08:24:59.410]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.410]                   }
[08:24:59.410]                 }
[08:24:59.410]                 else {
[08:24:59.410]                   if (TRUE) {
[08:24:59.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.410]                     {
[08:24:59.410]                       inherits <- base::inherits
[08:24:59.410]                       invokeRestart <- base::invokeRestart
[08:24:59.410]                       is.null <- base::is.null
[08:24:59.410]                       muffled <- FALSE
[08:24:59.410]                       if (inherits(cond, "message")) {
[08:24:59.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.410]                         if (muffled) 
[08:24:59.410]                           invokeRestart("muffleMessage")
[08:24:59.410]                       }
[08:24:59.410]                       else if (inherits(cond, "warning")) {
[08:24:59.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.410]                         if (muffled) 
[08:24:59.410]                           invokeRestart("muffleWarning")
[08:24:59.410]                       }
[08:24:59.410]                       else if (inherits(cond, "condition")) {
[08:24:59.410]                         if (!is.null(pattern)) {
[08:24:59.410]                           computeRestarts <- base::computeRestarts
[08:24:59.410]                           grepl <- base::grepl
[08:24:59.410]                           restarts <- computeRestarts(cond)
[08:24:59.410]                           for (restart in restarts) {
[08:24:59.410]                             name <- restart$name
[08:24:59.410]                             if (is.null(name)) 
[08:24:59.410]                               next
[08:24:59.410]                             if (!grepl(pattern, name)) 
[08:24:59.410]                               next
[08:24:59.410]                             invokeRestart(restart)
[08:24:59.410]                             muffled <- TRUE
[08:24:59.410]                             break
[08:24:59.410]                           }
[08:24:59.410]                         }
[08:24:59.410]                       }
[08:24:59.410]                       invisible(muffled)
[08:24:59.410]                     }
[08:24:59.410]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.410]                   }
[08:24:59.410]                 }
[08:24:59.410]             }
[08:24:59.410]         }))
[08:24:59.410]     }, error = function(ex) {
[08:24:59.410]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.410]                 ...future.rng), started = ...future.startTime, 
[08:24:59.410]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.410]             version = "1.8"), class = "FutureResult")
[08:24:59.410]     }, finally = {
[08:24:59.410]         if (!identical(...future.workdir, getwd())) 
[08:24:59.410]             setwd(...future.workdir)
[08:24:59.410]         {
[08:24:59.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.410]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.410]             }
[08:24:59.410]             base::options(...future.oldOptions)
[08:24:59.410]             if (.Platform$OS.type == "windows") {
[08:24:59.410]                 old_names <- names(...future.oldEnvVars)
[08:24:59.410]                 envs <- base::Sys.getenv()
[08:24:59.410]                 names <- names(envs)
[08:24:59.410]                 common <- intersect(names, old_names)
[08:24:59.410]                 added <- setdiff(names, old_names)
[08:24:59.410]                 removed <- setdiff(old_names, names)
[08:24:59.410]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.410]                   envs[common]]
[08:24:59.410]                 NAMES <- toupper(changed)
[08:24:59.410]                 args <- list()
[08:24:59.410]                 for (kk in seq_along(NAMES)) {
[08:24:59.410]                   name <- changed[[kk]]
[08:24:59.410]                   NAME <- NAMES[[kk]]
[08:24:59.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.410]                     next
[08:24:59.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.410]                 }
[08:24:59.410]                 NAMES <- toupper(added)
[08:24:59.410]                 for (kk in seq_along(NAMES)) {
[08:24:59.410]                   name <- added[[kk]]
[08:24:59.410]                   NAME <- NAMES[[kk]]
[08:24:59.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.410]                     next
[08:24:59.410]                   args[[name]] <- ""
[08:24:59.410]                 }
[08:24:59.410]                 NAMES <- toupper(removed)
[08:24:59.410]                 for (kk in seq_along(NAMES)) {
[08:24:59.410]                   name <- removed[[kk]]
[08:24:59.410]                   NAME <- NAMES[[kk]]
[08:24:59.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.410]                     next
[08:24:59.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.410]                 }
[08:24:59.410]                 if (length(args) > 0) 
[08:24:59.410]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.410]             }
[08:24:59.410]             else {
[08:24:59.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.410]             }
[08:24:59.410]             {
[08:24:59.410]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.410]                   0L) {
[08:24:59.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.410]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.410]                   base::options(opts)
[08:24:59.410]                 }
[08:24:59.410]                 {
[08:24:59.410]                   {
[08:24:59.410]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.410]                     NULL
[08:24:59.410]                   }
[08:24:59.410]                   options(future.plan = NULL)
[08:24:59.410]                   if (is.na(NA_character_)) 
[08:24:59.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.410]                     .init = FALSE)
[08:24:59.410]                 }
[08:24:59.410]             }
[08:24:59.410]         }
[08:24:59.410]     })
[08:24:59.410]     if (TRUE) {
[08:24:59.410]         base::sink(type = "output", split = FALSE)
[08:24:59.410]         if (TRUE) {
[08:24:59.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.410]         }
[08:24:59.410]         else {
[08:24:59.410]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.410]         }
[08:24:59.410]         base::close(...future.stdout)
[08:24:59.410]         ...future.stdout <- NULL
[08:24:59.410]     }
[08:24:59.410]     ...future.result$conditions <- ...future.conditions
[08:24:59.410]     ...future.result$finished <- base::Sys.time()
[08:24:59.410]     ...future.result
[08:24:59.410] }
[08:24:59.413] Exporting 7 global objects (3.97 KiB) to cluster node #2 ...
[08:24:59.413] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ...
[08:24:59.413] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ... DONE
[08:24:59.413] Exporting ‘breaks’ (463 bytes) to cluster node #2 ...
[08:24:59.414] Exporting ‘breaks’ (463 bytes) to cluster node #2 ... DONE
[08:24:59.414] Exporting ‘wool’ (342 bytes) to cluster node #2 ...
[08:24:59.414] Exporting ‘wool’ (342 bytes) to cluster node #2 ... DONE
[08:24:59.414] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:59.415] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:59.415] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[08:24:59.415] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[08:24:59.415] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:59.416] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.416] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:24:59.416] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.416] Exporting 7 global objects (3.97 KiB) to cluster node #2 ... DONE
[08:24:59.417] MultisessionFuture started
[08:24:59.417] - Launch lazy future ... done
[08:24:59.417] run() for ‘MultisessionFuture’ ... done
[08:24:59.417] Created future:
[08:24:59.417] MultisessionFuture:
[08:24:59.417] Label: ‘future_by-2’
[08:24:59.417] Expression:
[08:24:59.417] {
[08:24:59.417]     do.call(function(...) {
[08:24:59.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.417]             on.exit(options(oopts), add = TRUE)
[08:24:59.417]         }
[08:24:59.417]         {
[08:24:59.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.417]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.417]             })
[08:24:59.417]         }
[08:24:59.417]     }, args = future.call.arguments)
[08:24:59.417] }
[08:24:59.417] Lazy evaluation: FALSE
[08:24:59.417] Asynchronous evaluation: TRUE
[08:24:59.417] Local evaluation: TRUE
[08:24:59.417] Environment: 0x557b29fad018
[08:24:59.417] Capture standard output: TRUE
[08:24:59.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.417] Globals: 7 objects totaling 3.57 KiB (function ‘...future.FUN’ of 1.28 KiB, numeric ‘breaks’ of 463 bytes, factor ‘wool’ of 342 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, ...)
[08:24:59.417] Packages: 1 packages (‘stats’)
[08:24:59.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.417] Resolved: FALSE
[08:24:59.417] Value: <not collected>
[08:24:59.417] Conditions captured: <none>
[08:24:59.417] Early signaling: FALSE
[08:24:59.417] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.417] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.429] Chunk #2 of 2 ... DONE
[08:24:59.429] Launching 2 futures (chunks) ... DONE
[08:24:59.429] Resolving 2 futures (chunks) ...
[08:24:59.429] resolve() on list ...
[08:24:59.429]  recursive: 0
[08:24:59.430]  length: 2
[08:24:59.430] 
[08:24:59.430] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.430] - Validating connection of MultisessionFuture
[08:24:59.431] - received message: FutureResult
[08:24:59.431] - Received FutureResult
[08:24:59.431] - Erased future from FutureRegistry
[08:24:59.431] result() for ClusterFuture ...
[08:24:59.431] - result already collected: FutureResult
[08:24:59.431] result() for ClusterFuture ... done
[08:24:59.431] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.431] Future #1
[08:24:59.431] result() for ClusterFuture ...
[08:24:59.431] - result already collected: FutureResult
[08:24:59.431] result() for ClusterFuture ... done
[08:24:59.432] result() for ClusterFuture ...
[08:24:59.432] - result already collected: FutureResult
[08:24:59.432] result() for ClusterFuture ... done
[08:24:59.432] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:59.432] - nx: 2
[08:24:59.432] - relay: TRUE
[08:24:59.432] - stdout: TRUE
[08:24:59.432] - signal: TRUE
[08:24:59.432] - resignal: FALSE
[08:24:59.432] - force: TRUE
[08:24:59.432] - relayed: [n=2] FALSE, FALSE
[08:24:59.432] - queued futures: [n=2] FALSE, FALSE
[08:24:59.432]  - until=1
[08:24:59.433]  - relaying element #1
[08:24:59.433] result() for ClusterFuture ...
[08:24:59.433] - result already collected: FutureResult
[08:24:59.433] result() for ClusterFuture ... done
[08:24:59.433] result() for ClusterFuture ...
[08:24:59.433] - result already collected: FutureResult
[08:24:59.433] result() for ClusterFuture ... done
[08:24:59.433] result() for ClusterFuture ...
[08:24:59.433] - result already collected: FutureResult
[08:24:59.433] result() for ClusterFuture ... done
[08:24:59.433] result() for ClusterFuture ...
[08:24:59.434] - result already collected: FutureResult
[08:24:59.434] result() for ClusterFuture ... done
[08:24:59.434] - relayed: [n=2] TRUE, FALSE
[08:24:59.434] - queued futures: [n=2] TRUE, FALSE
[08:24:59.434] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:59.434]  length: 1 (resolved future 1)
[08:24:59.461] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.461] - Validating connection of MultisessionFuture
[08:24:59.461] - received message: FutureResult
[08:24:59.462] - Received FutureResult
[08:24:59.462] - Erased future from FutureRegistry
[08:24:59.462] result() for ClusterFuture ...
[08:24:59.462] - result already collected: FutureResult
[08:24:59.462] result() for ClusterFuture ... done
[08:24:59.462] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.462] Future #2
[08:24:59.462] result() for ClusterFuture ...
[08:24:59.462] - result already collected: FutureResult
[08:24:59.462] result() for ClusterFuture ... done
[08:24:59.462] result() for ClusterFuture ...
[08:24:59.463] - result already collected: FutureResult
[08:24:59.463] result() for ClusterFuture ... done
[08:24:59.463] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:59.463] - nx: 2
[08:24:59.463] - relay: TRUE
[08:24:59.463] - stdout: TRUE
[08:24:59.463] - signal: TRUE
[08:24:59.463] - resignal: FALSE
[08:24:59.463] - force: TRUE
[08:24:59.463] - relayed: [n=2] TRUE, FALSE
[08:24:59.463] - queued futures: [n=2] TRUE, FALSE
[08:24:59.463]  - until=2
[08:24:59.464]  - relaying element #2
[08:24:59.464] result() for ClusterFuture ...
[08:24:59.464] - result already collected: FutureResult
[08:24:59.464] result() for ClusterFuture ... done
[08:24:59.464] result() for ClusterFuture ...
[08:24:59.464] - result already collected: FutureResult
[08:24:59.464] result() for ClusterFuture ... done
[08:24:59.464] result() for ClusterFuture ...
[08:24:59.464] - result already collected: FutureResult
[08:24:59.464] result() for ClusterFuture ... done
[08:24:59.464] result() for ClusterFuture ...
[08:24:59.464] - result already collected: FutureResult
[08:24:59.465] result() for ClusterFuture ... done
[08:24:59.465] - relayed: [n=2] TRUE, TRUE
[08:24:59.465] - queued futures: [n=2] TRUE, TRUE
[08:24:59.465] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:59.465]  length: 0 (resolved future 2)
[08:24:59.465] Relaying remaining futures
[08:24:59.465] signalConditionsASAP(NULL, pos=0) ...
[08:24:59.465] - nx: 2
[08:24:59.465] - relay: TRUE
[08:24:59.465] - stdout: TRUE
[08:24:59.465] - signal: TRUE
[08:24:59.465] - resignal: FALSE
[08:24:59.466] - force: TRUE
[08:24:59.466] - relayed: [n=2] TRUE, TRUE
[08:24:59.466] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:59.466] - relayed: [n=2] TRUE, TRUE
[08:24:59.466] - queued futures: [n=2] TRUE, TRUE
[08:24:59.466] signalConditionsASAP(NULL, pos=0) ... done
[08:24:59.466] resolve() on list ... DONE
[08:24:59.466] result() for ClusterFuture ...
[08:24:59.466] - result already collected: FutureResult
[08:24:59.466] result() for ClusterFuture ... done
[08:24:59.466] result() for ClusterFuture ...
[08:24:59.466] - result already collected: FutureResult
[08:24:59.467] result() for ClusterFuture ... done
[08:24:59.467] result() for ClusterFuture ...
[08:24:59.467] - result already collected: FutureResult
[08:24:59.467] result() for ClusterFuture ... done
[08:24:59.467] result() for ClusterFuture ...
[08:24:59.467] - result already collected: FutureResult
[08:24:59.467] result() for ClusterFuture ... done
[08:24:59.467]  - Number of value chunks collected: 2
[08:24:59.467] Resolving 2 futures (chunks) ... DONE
[08:24:59.467] Reducing values from 2 chunks ...
[08:24:59.467]  - Number of values collected after concatenation: 3
[08:24:59.468]  - Number of values expected: 3
[08:24:59.468] Reducing values from 2 chunks ... DONE
[08:24:59.468] future_lapply() ... DONE
[08:24:59.468] future_by_internal() ... DONE
[08:24:59.468] future_by_internal() ...
[08:24:59.469] future_lapply() ...
[08:24:59.471] Number of chunks: 2
[08:24:59.471] getGlobalsAndPackagesXApply() ...
[08:24:59.471]  - future.globals: TRUE
[08:24:59.471] getGlobalsAndPackages() ...
[08:24:59.471] Searching for globals...
[08:24:59.474] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:59.474] Searching for globals ... DONE
[08:24:59.474] Resolving globals: FALSE
[08:24:59.475] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:59.475] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:59.475] - globals: [1] ‘FUN’
[08:24:59.475] 
[08:24:59.475] getGlobalsAndPackages() ... DONE
[08:24:59.475]  - globals found/used: [n=1] ‘FUN’
[08:24:59.476]  - needed namespaces: [n=0] 
[08:24:59.476] Finding globals ... DONE
[08:24:59.476]  - use_args: TRUE
[08:24:59.476]  - Getting '...' globals ...
[08:24:59.476] resolve() on list ...
[08:24:59.476]  recursive: 0
[08:24:59.476]  length: 1
[08:24:59.476]  elements: ‘...’
[08:24:59.477]  length: 0 (resolved future 1)
[08:24:59.477] resolve() on list ... DONE
[08:24:59.477]    - '...' content: [n=0] 
[08:24:59.477] List of 1
[08:24:59.477]  $ ...: list()
[08:24:59.477]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.477]  - attr(*, "where")=List of 1
[08:24:59.477]   ..$ ...:<environment: 0x557b2746d110> 
[08:24:59.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.477]  - attr(*, "resolved")= logi TRUE
[08:24:59.477]  - attr(*, "total_size")= num NA
[08:24:59.479]  - Getting '...' globals ... DONE
[08:24:59.479] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:59.479] List of 2
[08:24:59.479]  $ ...future.FUN:function (object, ...)  
[08:24:59.479]  $ ...          : list()
[08:24:59.479]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.479]  - attr(*, "where")=List of 2
[08:24:59.479]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:59.479]   ..$ ...          :<environment: 0x557b2746d110> 
[08:24:59.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.479]  - attr(*, "resolved")= logi FALSE
[08:24:59.479]  - attr(*, "total_size")= num 19278
[08:24:59.482] Packages to be attached in all futures: [n=0] 
[08:24:59.482] getGlobalsAndPackagesXApply() ... DONE
[08:24:59.482] Number of futures (= number of chunks): 2
[08:24:59.482] Launching 2 futures (chunks) ...
[08:24:59.482] Chunk #1 of 2 ...
[08:24:59.482]  - Finding globals in 'X' for chunk #1 ...
[08:24:59.483] getGlobalsAndPackages() ...
[08:24:59.483] Searching for globals...
[08:24:59.483] 
[08:24:59.483] Searching for globals ... DONE
[08:24:59.483] - globals: [0] <none>
[08:24:59.483] getGlobalsAndPackages() ... DONE
[08:24:59.483]    + additional globals found: [n=0] 
[08:24:59.483]    + additional namespaces needed: [n=0] 
[08:24:59.483]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:59.484]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.484]  - seeds: <none>
[08:24:59.484]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.484] getGlobalsAndPackages() ...
[08:24:59.484] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.484] Resolving globals: FALSE
[08:24:59.484] Tweak future expression to call with '...' arguments ...
[08:24:59.484] {
[08:24:59.484]     do.call(function(...) {
[08:24:59.484]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.484]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.484]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.484]             on.exit(options(oopts), add = TRUE)
[08:24:59.484]         }
[08:24:59.484]         {
[08:24:59.484]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.484]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.484]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.484]             })
[08:24:59.484]         }
[08:24:59.484]     }, args = future.call.arguments)
[08:24:59.484] }
[08:24:59.484] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.485] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.485] 
[08:24:59.485] getGlobalsAndPackages() ... DONE
[08:24:59.485] run() for ‘Future’ ...
[08:24:59.485] - state: ‘created’
[08:24:59.485] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.499]   - Field: ‘node’
[08:24:59.499]   - Field: ‘label’
[08:24:59.499]   - Field: ‘local’
[08:24:59.499]   - Field: ‘owner’
[08:24:59.500]   - Field: ‘envir’
[08:24:59.500]   - Field: ‘workers’
[08:24:59.500]   - Field: ‘packages’
[08:24:59.500]   - Field: ‘gc’
[08:24:59.500]   - Field: ‘conditions’
[08:24:59.500]   - Field: ‘persistent’
[08:24:59.500]   - Field: ‘expr’
[08:24:59.500]   - Field: ‘uuid’
[08:24:59.500]   - Field: ‘seed’
[08:24:59.500]   - Field: ‘version’
[08:24:59.500]   - Field: ‘result’
[08:24:59.500]   - Field: ‘asynchronous’
[08:24:59.501]   - Field: ‘calls’
[08:24:59.501]   - Field: ‘globals’
[08:24:59.501]   - Field: ‘stdout’
[08:24:59.501]   - Field: ‘earlySignal’
[08:24:59.501]   - Field: ‘lazy’
[08:24:59.501]   - Field: ‘state’
[08:24:59.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.501] - Launch lazy future ...
[08:24:59.501] Packages needed by the future expression (n = 0): <none>
[08:24:59.502] Packages needed by future strategies (n = 0): <none>
[08:24:59.502] {
[08:24:59.502]     {
[08:24:59.502]         {
[08:24:59.502]             ...future.startTime <- base::Sys.time()
[08:24:59.502]             {
[08:24:59.502]                 {
[08:24:59.502]                   {
[08:24:59.502]                     {
[08:24:59.502]                       base::local({
[08:24:59.502]                         has_future <- base::requireNamespace("future", 
[08:24:59.502]                           quietly = TRUE)
[08:24:59.502]                         if (has_future) {
[08:24:59.502]                           ns <- base::getNamespace("future")
[08:24:59.502]                           version <- ns[[".package"]][["version"]]
[08:24:59.502]                           if (is.null(version)) 
[08:24:59.502]                             version <- utils::packageVersion("future")
[08:24:59.502]                         }
[08:24:59.502]                         else {
[08:24:59.502]                           version <- NULL
[08:24:59.502]                         }
[08:24:59.502]                         if (!has_future || version < "1.8.0") {
[08:24:59.502]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.502]                             "", base::R.version$version.string), 
[08:24:59.502]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:59.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:59.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.502]                               "release", "version")], collapse = " "), 
[08:24:59.502]                             hostname = base::Sys.info()[["nodename"]])
[08:24:59.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.502]                             info)
[08:24:59.502]                           info <- base::paste(info, collapse = "; ")
[08:24:59.502]                           if (!has_future) {
[08:24:59.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.502]                               info)
[08:24:59.502]                           }
[08:24:59.502]                           else {
[08:24:59.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.502]                               info, version)
[08:24:59.502]                           }
[08:24:59.502]                           base::stop(msg)
[08:24:59.502]                         }
[08:24:59.502]                       })
[08:24:59.502]                     }
[08:24:59.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.502]                     base::options(mc.cores = 1L)
[08:24:59.502]                   }
[08:24:59.502]                   ...future.strategy.old <- future::plan("list")
[08:24:59.502]                   options(future.plan = NULL)
[08:24:59.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.502]                 }
[08:24:59.502]                 ...future.workdir <- getwd()
[08:24:59.502]             }
[08:24:59.502]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.502]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.502]         }
[08:24:59.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.502]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.502]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.502]             base::names(...future.oldOptions))
[08:24:59.502]     }
[08:24:59.502]     if (FALSE) {
[08:24:59.502]     }
[08:24:59.502]     else {
[08:24:59.502]         if (TRUE) {
[08:24:59.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.502]                 open = "w")
[08:24:59.502]         }
[08:24:59.502]         else {
[08:24:59.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.502]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.502]         }
[08:24:59.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.502]             base::sink(type = "output", split = FALSE)
[08:24:59.502]             base::close(...future.stdout)
[08:24:59.502]         }, add = TRUE)
[08:24:59.502]     }
[08:24:59.502]     ...future.frame <- base::sys.nframe()
[08:24:59.502]     ...future.conditions <- base::list()
[08:24:59.502]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.502]     if (FALSE) {
[08:24:59.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.502]     }
[08:24:59.502]     ...future.result <- base::tryCatch({
[08:24:59.502]         base::withCallingHandlers({
[08:24:59.502]             ...future.value <- base::withVisible(base::local({
[08:24:59.502]                 ...future.makeSendCondition <- base::local({
[08:24:59.502]                   sendCondition <- NULL
[08:24:59.502]                   function(frame = 1L) {
[08:24:59.502]                     if (is.function(sendCondition)) 
[08:24:59.502]                       return(sendCondition)
[08:24:59.502]                     ns <- getNamespace("parallel")
[08:24:59.502]                     if (exists("sendData", mode = "function", 
[08:24:59.502]                       envir = ns)) {
[08:24:59.502]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.502]                         envir = ns)
[08:24:59.502]                       envir <- sys.frame(frame)
[08:24:59.502]                       master <- NULL
[08:24:59.502]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.502]                         !identical(envir, emptyenv())) {
[08:24:59.502]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.502]                           inherits = FALSE)) {
[08:24:59.502]                           master <- get("master", mode = "list", 
[08:24:59.502]                             envir = envir, inherits = FALSE)
[08:24:59.502]                           if (inherits(master, c("SOCKnode", 
[08:24:59.502]                             "SOCK0node"))) {
[08:24:59.502]                             sendCondition <<- function(cond) {
[08:24:59.502]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.502]                                 success = TRUE)
[08:24:59.502]                               parallel_sendData(master, data)
[08:24:59.502]                             }
[08:24:59.502]                             return(sendCondition)
[08:24:59.502]                           }
[08:24:59.502]                         }
[08:24:59.502]                         frame <- frame + 1L
[08:24:59.502]                         envir <- sys.frame(frame)
[08:24:59.502]                       }
[08:24:59.502]                     }
[08:24:59.502]                     sendCondition <<- function(cond) NULL
[08:24:59.502]                   }
[08:24:59.502]                 })
[08:24:59.502]                 withCallingHandlers({
[08:24:59.502]                   {
[08:24:59.502]                     do.call(function(...) {
[08:24:59.502]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.502]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.502]                         ...future.globals.maxSize)) {
[08:24:59.502]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.502]                         on.exit(options(oopts), add = TRUE)
[08:24:59.502]                       }
[08:24:59.502]                       {
[08:24:59.502]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.502]                           FUN = function(jj) {
[08:24:59.502]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.502]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.502]                           })
[08:24:59.502]                       }
[08:24:59.502]                     }, args = future.call.arguments)
[08:24:59.502]                   }
[08:24:59.502]                 }, immediateCondition = function(cond) {
[08:24:59.502]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.502]                   sendCondition(cond)
[08:24:59.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.502]                   {
[08:24:59.502]                     inherits <- base::inherits
[08:24:59.502]                     invokeRestart <- base::invokeRestart
[08:24:59.502]                     is.null <- base::is.null
[08:24:59.502]                     muffled <- FALSE
[08:24:59.502]                     if (inherits(cond, "message")) {
[08:24:59.502]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.502]                       if (muffled) 
[08:24:59.502]                         invokeRestart("muffleMessage")
[08:24:59.502]                     }
[08:24:59.502]                     else if (inherits(cond, "warning")) {
[08:24:59.502]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.502]                       if (muffled) 
[08:24:59.502]                         invokeRestart("muffleWarning")
[08:24:59.502]                     }
[08:24:59.502]                     else if (inherits(cond, "condition")) {
[08:24:59.502]                       if (!is.null(pattern)) {
[08:24:59.502]                         computeRestarts <- base::computeRestarts
[08:24:59.502]                         grepl <- base::grepl
[08:24:59.502]                         restarts <- computeRestarts(cond)
[08:24:59.502]                         for (restart in restarts) {
[08:24:59.502]                           name <- restart$name
[08:24:59.502]                           if (is.null(name)) 
[08:24:59.502]                             next
[08:24:59.502]                           if (!grepl(pattern, name)) 
[08:24:59.502]                             next
[08:24:59.502]                           invokeRestart(restart)
[08:24:59.502]                           muffled <- TRUE
[08:24:59.502]                           break
[08:24:59.502]                         }
[08:24:59.502]                       }
[08:24:59.502]                     }
[08:24:59.502]                     invisible(muffled)
[08:24:59.502]                   }
[08:24:59.502]                   muffleCondition(cond)
[08:24:59.502]                 })
[08:24:59.502]             }))
[08:24:59.502]             future::FutureResult(value = ...future.value$value, 
[08:24:59.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.502]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.502]                     ...future.globalenv.names))
[08:24:59.502]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.502]         }, condition = base::local({
[08:24:59.502]             c <- base::c
[08:24:59.502]             inherits <- base::inherits
[08:24:59.502]             invokeRestart <- base::invokeRestart
[08:24:59.502]             length <- base::length
[08:24:59.502]             list <- base::list
[08:24:59.502]             seq.int <- base::seq.int
[08:24:59.502]             signalCondition <- base::signalCondition
[08:24:59.502]             sys.calls <- base::sys.calls
[08:24:59.502]             `[[` <- base::`[[`
[08:24:59.502]             `+` <- base::`+`
[08:24:59.502]             `<<-` <- base::`<<-`
[08:24:59.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.502]                   3L)]
[08:24:59.502]             }
[08:24:59.502]             function(cond) {
[08:24:59.502]                 is_error <- inherits(cond, "error")
[08:24:59.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.502]                   NULL)
[08:24:59.502]                 if (is_error) {
[08:24:59.502]                   sessionInformation <- function() {
[08:24:59.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.502]                       search = base::search(), system = base::Sys.info())
[08:24:59.502]                   }
[08:24:59.502]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.502]                     cond$call), session = sessionInformation(), 
[08:24:59.502]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.502]                   signalCondition(cond)
[08:24:59.502]                 }
[08:24:59.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.502]                 "immediateCondition"))) {
[08:24:59.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.502]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.502]                   if (TRUE && !signal) {
[08:24:59.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.502]                     {
[08:24:59.502]                       inherits <- base::inherits
[08:24:59.502]                       invokeRestart <- base::invokeRestart
[08:24:59.502]                       is.null <- base::is.null
[08:24:59.502]                       muffled <- FALSE
[08:24:59.502]                       if (inherits(cond, "message")) {
[08:24:59.502]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.502]                         if (muffled) 
[08:24:59.502]                           invokeRestart("muffleMessage")
[08:24:59.502]                       }
[08:24:59.502]                       else if (inherits(cond, "warning")) {
[08:24:59.502]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.502]                         if (muffled) 
[08:24:59.502]                           invokeRestart("muffleWarning")
[08:24:59.502]                       }
[08:24:59.502]                       else if (inherits(cond, "condition")) {
[08:24:59.502]                         if (!is.null(pattern)) {
[08:24:59.502]                           computeRestarts <- base::computeRestarts
[08:24:59.502]                           grepl <- base::grepl
[08:24:59.502]                           restarts <- computeRestarts(cond)
[08:24:59.502]                           for (restart in restarts) {
[08:24:59.502]                             name <- restart$name
[08:24:59.502]                             if (is.null(name)) 
[08:24:59.502]                               next
[08:24:59.502]                             if (!grepl(pattern, name)) 
[08:24:59.502]                               next
[08:24:59.502]                             invokeRestart(restart)
[08:24:59.502]                             muffled <- TRUE
[08:24:59.502]                             break
[08:24:59.502]                           }
[08:24:59.502]                         }
[08:24:59.502]                       }
[08:24:59.502]                       invisible(muffled)
[08:24:59.502]                     }
[08:24:59.502]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.502]                   }
[08:24:59.502]                 }
[08:24:59.502]                 else {
[08:24:59.502]                   if (TRUE) {
[08:24:59.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.502]                     {
[08:24:59.502]                       inherits <- base::inherits
[08:24:59.502]                       invokeRestart <- base::invokeRestart
[08:24:59.502]                       is.null <- base::is.null
[08:24:59.502]                       muffled <- FALSE
[08:24:59.502]                       if (inherits(cond, "message")) {
[08:24:59.502]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.502]                         if (muffled) 
[08:24:59.502]                           invokeRestart("muffleMessage")
[08:24:59.502]                       }
[08:24:59.502]                       else if (inherits(cond, "warning")) {
[08:24:59.502]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.502]                         if (muffled) 
[08:24:59.502]                           invokeRestart("muffleWarning")
[08:24:59.502]                       }
[08:24:59.502]                       else if (inherits(cond, "condition")) {
[08:24:59.502]                         if (!is.null(pattern)) {
[08:24:59.502]                           computeRestarts <- base::computeRestarts
[08:24:59.502]                           grepl <- base::grepl
[08:24:59.502]                           restarts <- computeRestarts(cond)
[08:24:59.502]                           for (restart in restarts) {
[08:24:59.502]                             name <- restart$name
[08:24:59.502]                             if (is.null(name)) 
[08:24:59.502]                               next
[08:24:59.502]                             if (!grepl(pattern, name)) 
[08:24:59.502]                               next
[08:24:59.502]                             invokeRestart(restart)
[08:24:59.502]                             muffled <- TRUE
[08:24:59.502]                             break
[08:24:59.502]                           }
[08:24:59.502]                         }
[08:24:59.502]                       }
[08:24:59.502]                       invisible(muffled)
[08:24:59.502]                     }
[08:24:59.502]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.502]                   }
[08:24:59.502]                 }
[08:24:59.502]             }
[08:24:59.502]         }))
[08:24:59.502]     }, error = function(ex) {
[08:24:59.502]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.502]                 ...future.rng), started = ...future.startTime, 
[08:24:59.502]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.502]             version = "1.8"), class = "FutureResult")
[08:24:59.502]     }, finally = {
[08:24:59.502]         if (!identical(...future.workdir, getwd())) 
[08:24:59.502]             setwd(...future.workdir)
[08:24:59.502]         {
[08:24:59.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.502]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.502]             }
[08:24:59.502]             base::options(...future.oldOptions)
[08:24:59.502]             if (.Platform$OS.type == "windows") {
[08:24:59.502]                 old_names <- names(...future.oldEnvVars)
[08:24:59.502]                 envs <- base::Sys.getenv()
[08:24:59.502]                 names <- names(envs)
[08:24:59.502]                 common <- intersect(names, old_names)
[08:24:59.502]                 added <- setdiff(names, old_names)
[08:24:59.502]                 removed <- setdiff(old_names, names)
[08:24:59.502]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.502]                   envs[common]]
[08:24:59.502]                 NAMES <- toupper(changed)
[08:24:59.502]                 args <- list()
[08:24:59.502]                 for (kk in seq_along(NAMES)) {
[08:24:59.502]                   name <- changed[[kk]]
[08:24:59.502]                   NAME <- NAMES[[kk]]
[08:24:59.502]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.502]                     next
[08:24:59.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.502]                 }
[08:24:59.502]                 NAMES <- toupper(added)
[08:24:59.502]                 for (kk in seq_along(NAMES)) {
[08:24:59.502]                   name <- added[[kk]]
[08:24:59.502]                   NAME <- NAMES[[kk]]
[08:24:59.502]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.502]                     next
[08:24:59.502]                   args[[name]] <- ""
[08:24:59.502]                 }
[08:24:59.502]                 NAMES <- toupper(removed)
[08:24:59.502]                 for (kk in seq_along(NAMES)) {
[08:24:59.502]                   name <- removed[[kk]]
[08:24:59.502]                   NAME <- NAMES[[kk]]
[08:24:59.502]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.502]                     next
[08:24:59.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.502]                 }
[08:24:59.502]                 if (length(args) > 0) 
[08:24:59.502]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.502]             }
[08:24:59.502]             else {
[08:24:59.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.502]             }
[08:24:59.502]             {
[08:24:59.502]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.502]                   0L) {
[08:24:59.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.502]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.502]                   base::options(opts)
[08:24:59.502]                 }
[08:24:59.502]                 {
[08:24:59.502]                   {
[08:24:59.502]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.502]                     NULL
[08:24:59.502]                   }
[08:24:59.502]                   options(future.plan = NULL)
[08:24:59.502]                   if (is.na(NA_character_)) 
[08:24:59.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.502]                     .init = FALSE)
[08:24:59.502]                 }
[08:24:59.502]             }
[08:24:59.502]         }
[08:24:59.502]     })
[08:24:59.502]     if (TRUE) {
[08:24:59.502]         base::sink(type = "output", split = FALSE)
[08:24:59.502]         if (TRUE) {
[08:24:59.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.502]         }
[08:24:59.502]         else {
[08:24:59.502]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.502]         }
[08:24:59.502]         base::close(...future.stdout)
[08:24:59.502]         ...future.stdout <- NULL
[08:24:59.502]     }
[08:24:59.502]     ...future.result$conditions <- ...future.conditions
[08:24:59.502]     ...future.result$finished <- base::Sys.time()
[08:24:59.502]     ...future.result
[08:24:59.502] }
[08:24:59.505] Exporting 5 global objects (1.57 KiB) to cluster node #1 ...
[08:24:59.505] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[08:24:59.505] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[08:24:59.505] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:59.506] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:59.506] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[08:24:59.506] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[08:24:59.506] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:59.507] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.507] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:24:59.507] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.507] Exporting 5 global objects (1.57 KiB) to cluster node #1 ... DONE
[08:24:59.508] MultisessionFuture started
[08:24:59.508] - Launch lazy future ... done
[08:24:59.508] run() for ‘MultisessionFuture’ ... done
[08:24:59.508] Created future:
[08:24:59.508] MultisessionFuture:
[08:24:59.508] Label: ‘future_by-1’
[08:24:59.508] Expression:
[08:24:59.508] {
[08:24:59.508]     do.call(function(...) {
[08:24:59.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.508]             on.exit(options(oopts), add = TRUE)
[08:24:59.508]         }
[08:24:59.508]         {
[08:24:59.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.508]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.508]             })
[08:24:59.508]         }
[08:24:59.508]     }, args = future.call.arguments)
[08:24:59.508] }
[08:24:59.508] Lazy evaluation: FALSE
[08:24:59.508] Asynchronous evaluation: TRUE
[08:24:59.508] Local evaluation: TRUE
[08:24:59.508] Environment: 0x557b26064d18
[08:24:59.508] Capture standard output: TRUE
[08:24:59.508] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.508] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:59.508] Packages: <none>
[08:24:59.508] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.508] Resolved: FALSE
[08:24:59.508] Value: <not collected>
[08:24:59.508] Conditions captured: <none>
[08:24:59.508] Early signaling: FALSE
[08:24:59.508] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.508] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.520] Chunk #1 of 2 ... DONE
[08:24:59.520] Chunk #2 of 2 ...
[08:24:59.520]  - Finding globals in 'X' for chunk #2 ...
[08:24:59.520] getGlobalsAndPackages() ...
[08:24:59.520] Searching for globals...
[08:24:59.521] 
[08:24:59.521] Searching for globals ... DONE
[08:24:59.521] - globals: [0] <none>
[08:24:59.521] getGlobalsAndPackages() ... DONE
[08:24:59.521]    + additional globals found: [n=0] 
[08:24:59.521]    + additional namespaces needed: [n=0] 
[08:24:59.521]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:59.521]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.521]  - seeds: <none>
[08:24:59.522]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.522] getGlobalsAndPackages() ...
[08:24:59.522] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.522] Resolving globals: FALSE
[08:24:59.522] Tweak future expression to call with '...' arguments ...
[08:24:59.522] {
[08:24:59.522]     do.call(function(...) {
[08:24:59.522]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.522]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.522]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.522]             on.exit(options(oopts), add = TRUE)
[08:24:59.522]         }
[08:24:59.522]         {
[08:24:59.522]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.522]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.522]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.522]             })
[08:24:59.522]         }
[08:24:59.522]     }, args = future.call.arguments)
[08:24:59.522] }
[08:24:59.522] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.523] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.523] 
[08:24:59.523] getGlobalsAndPackages() ... DONE
[08:24:59.523] run() for ‘Future’ ...
[08:24:59.523] - state: ‘created’
[08:24:59.523] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.537] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.537]   - Field: ‘node’
[08:24:59.537]   - Field: ‘label’
[08:24:59.537]   - Field: ‘local’
[08:24:59.537]   - Field: ‘owner’
[08:24:59.538]   - Field: ‘envir’
[08:24:59.538]   - Field: ‘workers’
[08:24:59.538]   - Field: ‘packages’
[08:24:59.538]   - Field: ‘gc’
[08:24:59.538]   - Field: ‘conditions’
[08:24:59.538]   - Field: ‘persistent’
[08:24:59.538]   - Field: ‘expr’
[08:24:59.538]   - Field: ‘uuid’
[08:24:59.538]   - Field: ‘seed’
[08:24:59.538]   - Field: ‘version’
[08:24:59.538]   - Field: ‘result’
[08:24:59.538]   - Field: ‘asynchronous’
[08:24:59.538]   - Field: ‘calls’
[08:24:59.539]   - Field: ‘globals’
[08:24:59.539]   - Field: ‘stdout’
[08:24:59.539]   - Field: ‘earlySignal’
[08:24:59.539]   - Field: ‘lazy’
[08:24:59.539]   - Field: ‘state’
[08:24:59.539] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.539] - Launch lazy future ...
[08:24:59.539] Packages needed by the future expression (n = 0): <none>
[08:24:59.539] Packages needed by future strategies (n = 0): <none>
[08:24:59.540] {
[08:24:59.540]     {
[08:24:59.540]         {
[08:24:59.540]             ...future.startTime <- base::Sys.time()
[08:24:59.540]             {
[08:24:59.540]                 {
[08:24:59.540]                   {
[08:24:59.540]                     {
[08:24:59.540]                       base::local({
[08:24:59.540]                         has_future <- base::requireNamespace("future", 
[08:24:59.540]                           quietly = TRUE)
[08:24:59.540]                         if (has_future) {
[08:24:59.540]                           ns <- base::getNamespace("future")
[08:24:59.540]                           version <- ns[[".package"]][["version"]]
[08:24:59.540]                           if (is.null(version)) 
[08:24:59.540]                             version <- utils::packageVersion("future")
[08:24:59.540]                         }
[08:24:59.540]                         else {
[08:24:59.540]                           version <- NULL
[08:24:59.540]                         }
[08:24:59.540]                         if (!has_future || version < "1.8.0") {
[08:24:59.540]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.540]                             "", base::R.version$version.string), 
[08:24:59.540]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:59.540]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:59.540]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.540]                               "release", "version")], collapse = " "), 
[08:24:59.540]                             hostname = base::Sys.info()[["nodename"]])
[08:24:59.540]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.540]                             info)
[08:24:59.540]                           info <- base::paste(info, collapse = "; ")
[08:24:59.540]                           if (!has_future) {
[08:24:59.540]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.540]                               info)
[08:24:59.540]                           }
[08:24:59.540]                           else {
[08:24:59.540]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.540]                               info, version)
[08:24:59.540]                           }
[08:24:59.540]                           base::stop(msg)
[08:24:59.540]                         }
[08:24:59.540]                       })
[08:24:59.540]                     }
[08:24:59.540]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.540]                     base::options(mc.cores = 1L)
[08:24:59.540]                   }
[08:24:59.540]                   ...future.strategy.old <- future::plan("list")
[08:24:59.540]                   options(future.plan = NULL)
[08:24:59.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.540]                 }
[08:24:59.540]                 ...future.workdir <- getwd()
[08:24:59.540]             }
[08:24:59.540]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.540]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.540]         }
[08:24:59.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.540]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.540]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.540]             base::names(...future.oldOptions))
[08:24:59.540]     }
[08:24:59.540]     if (FALSE) {
[08:24:59.540]     }
[08:24:59.540]     else {
[08:24:59.540]         if (TRUE) {
[08:24:59.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.540]                 open = "w")
[08:24:59.540]         }
[08:24:59.540]         else {
[08:24:59.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.540]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.540]         }
[08:24:59.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.540]             base::sink(type = "output", split = FALSE)
[08:24:59.540]             base::close(...future.stdout)
[08:24:59.540]         }, add = TRUE)
[08:24:59.540]     }
[08:24:59.540]     ...future.frame <- base::sys.nframe()
[08:24:59.540]     ...future.conditions <- base::list()
[08:24:59.540]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.540]     if (FALSE) {
[08:24:59.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.540]     }
[08:24:59.540]     ...future.result <- base::tryCatch({
[08:24:59.540]         base::withCallingHandlers({
[08:24:59.540]             ...future.value <- base::withVisible(base::local({
[08:24:59.540]                 ...future.makeSendCondition <- base::local({
[08:24:59.540]                   sendCondition <- NULL
[08:24:59.540]                   function(frame = 1L) {
[08:24:59.540]                     if (is.function(sendCondition)) 
[08:24:59.540]                       return(sendCondition)
[08:24:59.540]                     ns <- getNamespace("parallel")
[08:24:59.540]                     if (exists("sendData", mode = "function", 
[08:24:59.540]                       envir = ns)) {
[08:24:59.540]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.540]                         envir = ns)
[08:24:59.540]                       envir <- sys.frame(frame)
[08:24:59.540]                       master <- NULL
[08:24:59.540]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.540]                         !identical(envir, emptyenv())) {
[08:24:59.540]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.540]                           inherits = FALSE)) {
[08:24:59.540]                           master <- get("master", mode = "list", 
[08:24:59.540]                             envir = envir, inherits = FALSE)
[08:24:59.540]                           if (inherits(master, c("SOCKnode", 
[08:24:59.540]                             "SOCK0node"))) {
[08:24:59.540]                             sendCondition <<- function(cond) {
[08:24:59.540]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.540]                                 success = TRUE)
[08:24:59.540]                               parallel_sendData(master, data)
[08:24:59.540]                             }
[08:24:59.540]                             return(sendCondition)
[08:24:59.540]                           }
[08:24:59.540]                         }
[08:24:59.540]                         frame <- frame + 1L
[08:24:59.540]                         envir <- sys.frame(frame)
[08:24:59.540]                       }
[08:24:59.540]                     }
[08:24:59.540]                     sendCondition <<- function(cond) NULL
[08:24:59.540]                   }
[08:24:59.540]                 })
[08:24:59.540]                 withCallingHandlers({
[08:24:59.540]                   {
[08:24:59.540]                     do.call(function(...) {
[08:24:59.540]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.540]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.540]                         ...future.globals.maxSize)) {
[08:24:59.540]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.540]                         on.exit(options(oopts), add = TRUE)
[08:24:59.540]                       }
[08:24:59.540]                       {
[08:24:59.540]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.540]                           FUN = function(jj) {
[08:24:59.540]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.540]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.540]                           })
[08:24:59.540]                       }
[08:24:59.540]                     }, args = future.call.arguments)
[08:24:59.540]                   }
[08:24:59.540]                 }, immediateCondition = function(cond) {
[08:24:59.540]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.540]                   sendCondition(cond)
[08:24:59.540]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.540]                   {
[08:24:59.540]                     inherits <- base::inherits
[08:24:59.540]                     invokeRestart <- base::invokeRestart
[08:24:59.540]                     is.null <- base::is.null
[08:24:59.540]                     muffled <- FALSE
[08:24:59.540]                     if (inherits(cond, "message")) {
[08:24:59.540]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.540]                       if (muffled) 
[08:24:59.540]                         invokeRestart("muffleMessage")
[08:24:59.540]                     }
[08:24:59.540]                     else if (inherits(cond, "warning")) {
[08:24:59.540]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.540]                       if (muffled) 
[08:24:59.540]                         invokeRestart("muffleWarning")
[08:24:59.540]                     }
[08:24:59.540]                     else if (inherits(cond, "condition")) {
[08:24:59.540]                       if (!is.null(pattern)) {
[08:24:59.540]                         computeRestarts <- base::computeRestarts
[08:24:59.540]                         grepl <- base::grepl
[08:24:59.540]                         restarts <- computeRestarts(cond)
[08:24:59.540]                         for (restart in restarts) {
[08:24:59.540]                           name <- restart$name
[08:24:59.540]                           if (is.null(name)) 
[08:24:59.540]                             next
[08:24:59.540]                           if (!grepl(pattern, name)) 
[08:24:59.540]                             next
[08:24:59.540]                           invokeRestart(restart)
[08:24:59.540]                           muffled <- TRUE
[08:24:59.540]                           break
[08:24:59.540]                         }
[08:24:59.540]                       }
[08:24:59.540]                     }
[08:24:59.540]                     invisible(muffled)
[08:24:59.540]                   }
[08:24:59.540]                   muffleCondition(cond)
[08:24:59.540]                 })
[08:24:59.540]             }))
[08:24:59.540]             future::FutureResult(value = ...future.value$value, 
[08:24:59.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.540]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.540]                     ...future.globalenv.names))
[08:24:59.540]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.540]         }, condition = base::local({
[08:24:59.540]             c <- base::c
[08:24:59.540]             inherits <- base::inherits
[08:24:59.540]             invokeRestart <- base::invokeRestart
[08:24:59.540]             length <- base::length
[08:24:59.540]             list <- base::list
[08:24:59.540]             seq.int <- base::seq.int
[08:24:59.540]             signalCondition <- base::signalCondition
[08:24:59.540]             sys.calls <- base::sys.calls
[08:24:59.540]             `[[` <- base::`[[`
[08:24:59.540]             `+` <- base::`+`
[08:24:59.540]             `<<-` <- base::`<<-`
[08:24:59.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.540]                   3L)]
[08:24:59.540]             }
[08:24:59.540]             function(cond) {
[08:24:59.540]                 is_error <- inherits(cond, "error")
[08:24:59.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.540]                   NULL)
[08:24:59.540]                 if (is_error) {
[08:24:59.540]                   sessionInformation <- function() {
[08:24:59.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.540]                       search = base::search(), system = base::Sys.info())
[08:24:59.540]                   }
[08:24:59.540]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.540]                     cond$call), session = sessionInformation(), 
[08:24:59.540]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.540]                   signalCondition(cond)
[08:24:59.540]                 }
[08:24:59.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.540]                 "immediateCondition"))) {
[08:24:59.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.540]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.540]                   if (TRUE && !signal) {
[08:24:59.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.540]                     {
[08:24:59.540]                       inherits <- base::inherits
[08:24:59.540]                       invokeRestart <- base::invokeRestart
[08:24:59.540]                       is.null <- base::is.null
[08:24:59.540]                       muffled <- FALSE
[08:24:59.540]                       if (inherits(cond, "message")) {
[08:24:59.540]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.540]                         if (muffled) 
[08:24:59.540]                           invokeRestart("muffleMessage")
[08:24:59.540]                       }
[08:24:59.540]                       else if (inherits(cond, "warning")) {
[08:24:59.540]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.540]                         if (muffled) 
[08:24:59.540]                           invokeRestart("muffleWarning")
[08:24:59.540]                       }
[08:24:59.540]                       else if (inherits(cond, "condition")) {
[08:24:59.540]                         if (!is.null(pattern)) {
[08:24:59.540]                           computeRestarts <- base::computeRestarts
[08:24:59.540]                           grepl <- base::grepl
[08:24:59.540]                           restarts <- computeRestarts(cond)
[08:24:59.540]                           for (restart in restarts) {
[08:24:59.540]                             name <- restart$name
[08:24:59.540]                             if (is.null(name)) 
[08:24:59.540]                               next
[08:24:59.540]                             if (!grepl(pattern, name)) 
[08:24:59.540]                               next
[08:24:59.540]                             invokeRestart(restart)
[08:24:59.540]                             muffled <- TRUE
[08:24:59.540]                             break
[08:24:59.540]                           }
[08:24:59.540]                         }
[08:24:59.540]                       }
[08:24:59.540]                       invisible(muffled)
[08:24:59.540]                     }
[08:24:59.540]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.540]                   }
[08:24:59.540]                 }
[08:24:59.540]                 else {
[08:24:59.540]                   if (TRUE) {
[08:24:59.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.540]                     {
[08:24:59.540]                       inherits <- base::inherits
[08:24:59.540]                       invokeRestart <- base::invokeRestart
[08:24:59.540]                       is.null <- base::is.null
[08:24:59.540]                       muffled <- FALSE
[08:24:59.540]                       if (inherits(cond, "message")) {
[08:24:59.540]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.540]                         if (muffled) 
[08:24:59.540]                           invokeRestart("muffleMessage")
[08:24:59.540]                       }
[08:24:59.540]                       else if (inherits(cond, "warning")) {
[08:24:59.540]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.540]                         if (muffled) 
[08:24:59.540]                           invokeRestart("muffleWarning")
[08:24:59.540]                       }
[08:24:59.540]                       else if (inherits(cond, "condition")) {
[08:24:59.540]                         if (!is.null(pattern)) {
[08:24:59.540]                           computeRestarts <- base::computeRestarts
[08:24:59.540]                           grepl <- base::grepl
[08:24:59.540]                           restarts <- computeRestarts(cond)
[08:24:59.540]                           for (restart in restarts) {
[08:24:59.540]                             name <- restart$name
[08:24:59.540]                             if (is.null(name)) 
[08:24:59.540]                               next
[08:24:59.540]                             if (!grepl(pattern, name)) 
[08:24:59.540]                               next
[08:24:59.540]                             invokeRestart(restart)
[08:24:59.540]                             muffled <- TRUE
[08:24:59.540]                             break
[08:24:59.540]                           }
[08:24:59.540]                         }
[08:24:59.540]                       }
[08:24:59.540]                       invisible(muffled)
[08:24:59.540]                     }
[08:24:59.540]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.540]                   }
[08:24:59.540]                 }
[08:24:59.540]             }
[08:24:59.540]         }))
[08:24:59.540]     }, error = function(ex) {
[08:24:59.540]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.540]                 ...future.rng), started = ...future.startTime, 
[08:24:59.540]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.540]             version = "1.8"), class = "FutureResult")
[08:24:59.540]     }, finally = {
[08:24:59.540]         if (!identical(...future.workdir, getwd())) 
[08:24:59.540]             setwd(...future.workdir)
[08:24:59.540]         {
[08:24:59.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.540]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.540]             }
[08:24:59.540]             base::options(...future.oldOptions)
[08:24:59.540]             if (.Platform$OS.type == "windows") {
[08:24:59.540]                 old_names <- names(...future.oldEnvVars)
[08:24:59.540]                 envs <- base::Sys.getenv()
[08:24:59.540]                 names <- names(envs)
[08:24:59.540]                 common <- intersect(names, old_names)
[08:24:59.540]                 added <- setdiff(names, old_names)
[08:24:59.540]                 removed <- setdiff(old_names, names)
[08:24:59.540]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.540]                   envs[common]]
[08:24:59.540]                 NAMES <- toupper(changed)
[08:24:59.540]                 args <- list()
[08:24:59.540]                 for (kk in seq_along(NAMES)) {
[08:24:59.540]                   name <- changed[[kk]]
[08:24:59.540]                   NAME <- NAMES[[kk]]
[08:24:59.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.540]                     next
[08:24:59.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.540]                 }
[08:24:59.540]                 NAMES <- toupper(added)
[08:24:59.540]                 for (kk in seq_along(NAMES)) {
[08:24:59.540]                   name <- added[[kk]]
[08:24:59.540]                   NAME <- NAMES[[kk]]
[08:24:59.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.540]                     next
[08:24:59.540]                   args[[name]] <- ""
[08:24:59.540]                 }
[08:24:59.540]                 NAMES <- toupper(removed)
[08:24:59.540]                 for (kk in seq_along(NAMES)) {
[08:24:59.540]                   name <- removed[[kk]]
[08:24:59.540]                   NAME <- NAMES[[kk]]
[08:24:59.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.540]                     next
[08:24:59.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.540]                 }
[08:24:59.540]                 if (length(args) > 0) 
[08:24:59.540]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.540]             }
[08:24:59.540]             else {
[08:24:59.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.540]             }
[08:24:59.540]             {
[08:24:59.540]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.540]                   0L) {
[08:24:59.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.540]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.540]                   base::options(opts)
[08:24:59.540]                 }
[08:24:59.540]                 {
[08:24:59.540]                   {
[08:24:59.540]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.540]                     NULL
[08:24:59.540]                   }
[08:24:59.540]                   options(future.plan = NULL)
[08:24:59.540]                   if (is.na(NA_character_)) 
[08:24:59.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.540]                     .init = FALSE)
[08:24:59.540]                 }
[08:24:59.540]             }
[08:24:59.540]         }
[08:24:59.540]     })
[08:24:59.540]     if (TRUE) {
[08:24:59.540]         base::sink(type = "output", split = FALSE)
[08:24:59.540]         if (TRUE) {
[08:24:59.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.540]         }
[08:24:59.540]         else {
[08:24:59.540]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.540]         }
[08:24:59.540]         base::close(...future.stdout)
[08:24:59.540]         ...future.stdout <- NULL
[08:24:59.540]     }
[08:24:59.540]     ...future.result$conditions <- ...future.conditions
[08:24:59.540]     ...future.result$finished <- base::Sys.time()
[08:24:59.540]     ...future.result
[08:24:59.540] }
[08:24:59.543] Exporting 5 global objects (2.20 KiB) to cluster node #2 ...
[08:24:59.543] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[08:24:59.543] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[08:24:59.543] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:59.544] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:59.544] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[08:24:59.544] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[08:24:59.544] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:59.545] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.545] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:24:59.545] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.545] Exporting 5 global objects (2.20 KiB) to cluster node #2 ... DONE
[08:24:59.546] MultisessionFuture started
[08:24:59.546] - Launch lazy future ... done
[08:24:59.546] run() for ‘MultisessionFuture’ ... done
[08:24:59.546] Created future:
[08:24:59.546] MultisessionFuture:
[08:24:59.546] Label: ‘future_by-2’
[08:24:59.546] Expression:
[08:24:59.546] {
[08:24:59.546]     do.call(function(...) {
[08:24:59.546]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.546]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.546]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.546]             on.exit(options(oopts), add = TRUE)
[08:24:59.546]         }
[08:24:59.546]         {
[08:24:59.546]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.546]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.546]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.546]             })
[08:24:59.546]         }
[08:24:59.546]     }, args = future.call.arguments)
[08:24:59.546] }
[08:24:59.546] Lazy evaluation: FALSE
[08:24:59.546] Asynchronous evaluation: TRUE
[08:24:59.546] Local evaluation: TRUE
[08:24:59.546] Environment: 0x557b26064d18
[08:24:59.546] Capture standard output: TRUE
[08:24:59.546] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.546] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:59.546] Packages: <none>
[08:24:59.546] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.546] Resolved: FALSE
[08:24:59.546] Value: <not collected>
[08:24:59.546] Conditions captured: <none>
[08:24:59.546] Early signaling: FALSE
[08:24:59.546] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.546] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.558] Chunk #2 of 2 ... DONE
[08:24:59.558] Launching 2 futures (chunks) ... DONE
[08:24:59.558] Resolving 2 futures (chunks) ...
[08:24:59.558] resolve() on list ...
[08:24:59.558]  recursive: 0
[08:24:59.558]  length: 2
[08:24:59.558] 
[08:24:59.559] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.559] - Validating connection of MultisessionFuture
[08:24:59.559] - received message: FutureResult
[08:24:59.559] - Received FutureResult
[08:24:59.559] - Erased future from FutureRegistry
[08:24:59.559] result() for ClusterFuture ...
[08:24:59.560] - result already collected: FutureResult
[08:24:59.560] result() for ClusterFuture ... done
[08:24:59.560] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.560] Future #1
[08:24:59.560] result() for ClusterFuture ...
[08:24:59.560] - result already collected: FutureResult
[08:24:59.560] result() for ClusterFuture ... done
[08:24:59.560] result() for ClusterFuture ...
[08:24:59.560] - result already collected: FutureResult
[08:24:59.560] result() for ClusterFuture ... done
[08:24:59.560] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:59.560] - nx: 2
[08:24:59.561] - relay: TRUE
[08:24:59.561] - stdout: TRUE
[08:24:59.561] - signal: TRUE
[08:24:59.561] - resignal: FALSE
[08:24:59.561] - force: TRUE
[08:24:59.561] - relayed: [n=2] FALSE, FALSE
[08:24:59.561] - queued futures: [n=2] FALSE, FALSE
[08:24:59.561]  - until=1
[08:24:59.561]  - relaying element #1
[08:24:59.561] result() for ClusterFuture ...
[08:24:59.561] - result already collected: FutureResult
[08:24:59.561] result() for ClusterFuture ... done
[08:24:59.561] result() for ClusterFuture ...
[08:24:59.562] - result already collected: FutureResult
[08:24:59.562] result() for ClusterFuture ... done
[08:24:59.562] result() for ClusterFuture ...
[08:24:59.562] - result already collected: FutureResult
[08:24:59.562] result() for ClusterFuture ... done
[08:24:59.562] result() for ClusterFuture ...
[08:24:59.562] - result already collected: FutureResult
[08:24:59.562] result() for ClusterFuture ... done
[08:24:59.562] - relayed: [n=2] TRUE, FALSE
[08:24:59.562] - queued futures: [n=2] TRUE, FALSE
[08:24:59.562] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:59.562]  length: 1 (resolved future 1)
[08:24:59.589] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.589] - Validating connection of MultisessionFuture
[08:24:59.590] - received message: FutureResult
[08:24:59.590] - Received FutureResult
[08:24:59.590] - Erased future from FutureRegistry
[08:24:59.590] result() for ClusterFuture ...
[08:24:59.590] - result already collected: FutureResult
[08:24:59.590] result() for ClusterFuture ... done
[08:24:59.590] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.590] Future #2
[08:24:59.590] result() for ClusterFuture ...
[08:24:59.591] - result already collected: FutureResult
[08:24:59.591] result() for ClusterFuture ... done
[08:24:59.591] result() for ClusterFuture ...
[08:24:59.591] - result already collected: FutureResult
[08:24:59.591] result() for ClusterFuture ... done
[08:24:59.591] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:59.591] - nx: 2
[08:24:59.591] - relay: TRUE
[08:24:59.591] - stdout: TRUE
[08:24:59.591] - signal: TRUE
[08:24:59.591] - resignal: FALSE
[08:24:59.591] - force: TRUE
[08:24:59.592] - relayed: [n=2] TRUE, FALSE
[08:24:59.592] - queued futures: [n=2] TRUE, FALSE
[08:24:59.592]  - until=2
[08:24:59.592]  - relaying element #2
[08:24:59.592] result() for ClusterFuture ...
[08:24:59.592] - result already collected: FutureResult
[08:24:59.592] result() for ClusterFuture ... done
[08:24:59.592] result() for ClusterFuture ...
[08:24:59.592] - result already collected: FutureResult
[08:24:59.592] result() for ClusterFuture ... done
[08:24:59.592] result() for ClusterFuture ...
[08:24:59.593] - result already collected: FutureResult
[08:24:59.593] result() for ClusterFuture ... done
[08:24:59.593] result() for ClusterFuture ...
[08:24:59.593] - result already collected: FutureResult
[08:24:59.593] result() for ClusterFuture ... done
[08:24:59.593] - relayed: [n=2] TRUE, TRUE
[08:24:59.593] - queued futures: [n=2] TRUE, TRUE
[08:24:59.593] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:59.593]  length: 0 (resolved future 2)
[08:24:59.593] Relaying remaining futures
[08:24:59.593] signalConditionsASAP(NULL, pos=0) ...
[08:24:59.593] - nx: 2
[08:24:59.593] - relay: TRUE
[08:24:59.594] - stdout: TRUE
[08:24:59.594] - signal: TRUE
[08:24:59.594] - resignal: FALSE
[08:24:59.594] - force: TRUE
[08:24:59.594] - relayed: [n=2] TRUE, TRUE
[08:24:59.594] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:59.594] - relayed: [n=2] TRUE, TRUE
[08:24:59.594] - queued futures: [n=2] TRUE, TRUE
[08:24:59.594] signalConditionsASAP(NULL, pos=0) ... done
[08:24:59.594] resolve() on list ... DONE
[08:24:59.594] result() for ClusterFuture ...
[08:24:59.594] - result already collected: FutureResult
[08:24:59.595] result() for ClusterFuture ... done
[08:24:59.595] result() for ClusterFuture ...
[08:24:59.595] - result already collected: FutureResult
[08:24:59.595] result() for ClusterFuture ... done
[08:24:59.595] result() for ClusterFuture ...
[08:24:59.595] - result already collected: FutureResult
[08:24:59.595] result() for ClusterFuture ... done
[08:24:59.595] result() for ClusterFuture ...
[08:24:59.595] - result already collected: FutureResult
[08:24:59.595] result() for ClusterFuture ... done
[08:24:59.595]  - Number of value chunks collected: 2
[08:24:59.595] Resolving 2 futures (chunks) ... DONE
[08:24:59.596] Reducing values from 2 chunks ...
[08:24:59.596]  - Number of values collected after concatenation: 3
[08:24:59.596]  - Number of values expected: 3
[08:24:59.596] Reducing values from 2 chunks ... DONE
[08:24:59.596] future_lapply() ... DONE
[08:24:59.596] future_by_internal() ... DONE
[08:24:59.597] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[08:24:59.597] future_lapply() ...
[08:24:59.599] Number of chunks: 2
[08:24:59.600] getGlobalsAndPackagesXApply() ...
[08:24:59.600]  - future.globals: TRUE
[08:24:59.600] getGlobalsAndPackages() ...
[08:24:59.600] Searching for globals...
[08:24:59.601] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:59.601] Searching for globals ... DONE
[08:24:59.601] Resolving globals: FALSE
[08:24:59.601] The total size of the 1 globals is 281 bytes (281 bytes)
[08:24:59.602] The total size of the 1 globals exported for future expression (‘FUN()’) is 281 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (281 bytes of class ‘function’)
[08:24:59.602] - globals: [1] ‘FUN’
[08:24:59.602] 
[08:24:59.602] getGlobalsAndPackages() ... DONE
[08:24:59.602]  - globals found/used: [n=1] ‘FUN’
[08:24:59.602]  - needed namespaces: [n=0] 
[08:24:59.602] Finding globals ... DONE
[08:24:59.602]  - use_args: TRUE
[08:24:59.602]  - Getting '...' globals ...
[08:24:59.603] resolve() on list ...
[08:24:59.603]  recursive: 0
[08:24:59.603]  length: 1
[08:24:59.603]  elements: ‘...’
[08:24:59.603]  length: 0 (resolved future 1)
[08:24:59.603] resolve() on list ... DONE
[08:24:59.603]    - '...' content: [n=0] 
[08:24:59.603] List of 1
[08:24:59.603]  $ ...: list()
[08:24:59.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.603]  - attr(*, "where")=List of 1
[08:24:59.603]   ..$ ...:<environment: 0x557b29238620> 
[08:24:59.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.603]  - attr(*, "resolved")= logi TRUE
[08:24:59.603]  - attr(*, "total_size")= num NA
[08:24:59.606]  - Getting '...' globals ... DONE
[08:24:59.606] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:59.606] List of 2
[08:24:59.606]  $ ...future.FUN:function (object, ...)  
[08:24:59.606]  $ ...          : list()
[08:24:59.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:59.606]  - attr(*, "where")=List of 2
[08:24:59.606]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:59.606]   ..$ ...          :<environment: 0x557b29238620> 
[08:24:59.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:59.606]  - attr(*, "resolved")= logi FALSE
[08:24:59.606]  - attr(*, "total_size")= num 18647
[08:24:59.609] Packages to be attached in all futures: [n=0] 
[08:24:59.609] getGlobalsAndPackagesXApply() ... DONE
[08:24:59.609] Number of futures (= number of chunks): 2
[08:24:59.609] Launching 2 futures (chunks) ...
[08:24:59.609] Chunk #1 of 2 ...
[08:24:59.609]  - Finding globals in 'X' for chunk #1 ...
[08:24:59.609] getGlobalsAndPackages() ...
[08:24:59.609] Searching for globals...
[08:24:59.610] 
[08:24:59.610] Searching for globals ... DONE
[08:24:59.610] - globals: [0] <none>
[08:24:59.610] getGlobalsAndPackages() ... DONE
[08:24:59.610]    + additional globals found: [n=0] 
[08:24:59.610]    + additional namespaces needed: [n=0] 
[08:24:59.610]  - Finding globals in 'X' for chunk #1 ... DONE
[08:24:59.610]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.610]  - seeds: <none>
[08:24:59.611]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.611] getGlobalsAndPackages() ...
[08:24:59.611] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.611] Resolving globals: FALSE
[08:24:59.611] Tweak future expression to call with '...' arguments ...
[08:24:59.611] {
[08:24:59.611]     do.call(function(...) {
[08:24:59.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.611]             on.exit(options(oopts), add = TRUE)
[08:24:59.611]         }
[08:24:59.611]         {
[08:24:59.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.611]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.611]             })
[08:24:59.611]         }
[08:24:59.611]     }, args = future.call.arguments)
[08:24:59.611] }
[08:24:59.611] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.612] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.612] 
[08:24:59.612] getGlobalsAndPackages() ... DONE
[08:24:59.612] run() for ‘Future’ ...
[08:24:59.612] - state: ‘created’
[08:24:59.612] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.626] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.626]   - Field: ‘node’
[08:24:59.626]   - Field: ‘label’
[08:24:59.626]   - Field: ‘local’
[08:24:59.626]   - Field: ‘owner’
[08:24:59.627]   - Field: ‘envir’
[08:24:59.627]   - Field: ‘workers’
[08:24:59.627]   - Field: ‘packages’
[08:24:59.627]   - Field: ‘gc’
[08:24:59.627]   - Field: ‘conditions’
[08:24:59.627]   - Field: ‘persistent’
[08:24:59.627]   - Field: ‘expr’
[08:24:59.627]   - Field: ‘uuid’
[08:24:59.627]   - Field: ‘seed’
[08:24:59.627]   - Field: ‘version’
[08:24:59.627]   - Field: ‘result’
[08:24:59.628]   - Field: ‘asynchronous’
[08:24:59.628]   - Field: ‘calls’
[08:24:59.628]   - Field: ‘globals’
[08:24:59.628]   - Field: ‘stdout’
[08:24:59.628]   - Field: ‘earlySignal’
[08:24:59.628]   - Field: ‘lazy’
[08:24:59.628]   - Field: ‘state’
[08:24:59.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.628] - Launch lazy future ...
[08:24:59.628] Packages needed by the future expression (n = 0): <none>
[08:24:59.629] Packages needed by future strategies (n = 0): <none>
[08:24:59.629] {
[08:24:59.629]     {
[08:24:59.629]         {
[08:24:59.629]             ...future.startTime <- base::Sys.time()
[08:24:59.629]             {
[08:24:59.629]                 {
[08:24:59.629]                   {
[08:24:59.629]                     {
[08:24:59.629]                       base::local({
[08:24:59.629]                         has_future <- base::requireNamespace("future", 
[08:24:59.629]                           quietly = TRUE)
[08:24:59.629]                         if (has_future) {
[08:24:59.629]                           ns <- base::getNamespace("future")
[08:24:59.629]                           version <- ns[[".package"]][["version"]]
[08:24:59.629]                           if (is.null(version)) 
[08:24:59.629]                             version <- utils::packageVersion("future")
[08:24:59.629]                         }
[08:24:59.629]                         else {
[08:24:59.629]                           version <- NULL
[08:24:59.629]                         }
[08:24:59.629]                         if (!has_future || version < "1.8.0") {
[08:24:59.629]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.629]                             "", base::R.version$version.string), 
[08:24:59.629]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:59.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:59.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.629]                               "release", "version")], collapse = " "), 
[08:24:59.629]                             hostname = base::Sys.info()[["nodename"]])
[08:24:59.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.629]                             info)
[08:24:59.629]                           info <- base::paste(info, collapse = "; ")
[08:24:59.629]                           if (!has_future) {
[08:24:59.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.629]                               info)
[08:24:59.629]                           }
[08:24:59.629]                           else {
[08:24:59.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.629]                               info, version)
[08:24:59.629]                           }
[08:24:59.629]                           base::stop(msg)
[08:24:59.629]                         }
[08:24:59.629]                       })
[08:24:59.629]                     }
[08:24:59.629]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.629]                     base::options(mc.cores = 1L)
[08:24:59.629]                   }
[08:24:59.629]                   ...future.strategy.old <- future::plan("list")
[08:24:59.629]                   options(future.plan = NULL)
[08:24:59.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.629]                 }
[08:24:59.629]                 ...future.workdir <- getwd()
[08:24:59.629]             }
[08:24:59.629]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.629]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.629]         }
[08:24:59.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.629]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.629]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.629]             base::names(...future.oldOptions))
[08:24:59.629]     }
[08:24:59.629]     if (FALSE) {
[08:24:59.629]     }
[08:24:59.629]     else {
[08:24:59.629]         if (TRUE) {
[08:24:59.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.629]                 open = "w")
[08:24:59.629]         }
[08:24:59.629]         else {
[08:24:59.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.629]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.629]         }
[08:24:59.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.629]             base::sink(type = "output", split = FALSE)
[08:24:59.629]             base::close(...future.stdout)
[08:24:59.629]         }, add = TRUE)
[08:24:59.629]     }
[08:24:59.629]     ...future.frame <- base::sys.nframe()
[08:24:59.629]     ...future.conditions <- base::list()
[08:24:59.629]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.629]     if (FALSE) {
[08:24:59.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.629]     }
[08:24:59.629]     ...future.result <- base::tryCatch({
[08:24:59.629]         base::withCallingHandlers({
[08:24:59.629]             ...future.value <- base::withVisible(base::local({
[08:24:59.629]                 ...future.makeSendCondition <- base::local({
[08:24:59.629]                   sendCondition <- NULL
[08:24:59.629]                   function(frame = 1L) {
[08:24:59.629]                     if (is.function(sendCondition)) 
[08:24:59.629]                       return(sendCondition)
[08:24:59.629]                     ns <- getNamespace("parallel")
[08:24:59.629]                     if (exists("sendData", mode = "function", 
[08:24:59.629]                       envir = ns)) {
[08:24:59.629]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.629]                         envir = ns)
[08:24:59.629]                       envir <- sys.frame(frame)
[08:24:59.629]                       master <- NULL
[08:24:59.629]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.629]                         !identical(envir, emptyenv())) {
[08:24:59.629]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.629]                           inherits = FALSE)) {
[08:24:59.629]                           master <- get("master", mode = "list", 
[08:24:59.629]                             envir = envir, inherits = FALSE)
[08:24:59.629]                           if (inherits(master, c("SOCKnode", 
[08:24:59.629]                             "SOCK0node"))) {
[08:24:59.629]                             sendCondition <<- function(cond) {
[08:24:59.629]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.629]                                 success = TRUE)
[08:24:59.629]                               parallel_sendData(master, data)
[08:24:59.629]                             }
[08:24:59.629]                             return(sendCondition)
[08:24:59.629]                           }
[08:24:59.629]                         }
[08:24:59.629]                         frame <- frame + 1L
[08:24:59.629]                         envir <- sys.frame(frame)
[08:24:59.629]                       }
[08:24:59.629]                     }
[08:24:59.629]                     sendCondition <<- function(cond) NULL
[08:24:59.629]                   }
[08:24:59.629]                 })
[08:24:59.629]                 withCallingHandlers({
[08:24:59.629]                   {
[08:24:59.629]                     do.call(function(...) {
[08:24:59.629]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.629]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.629]                         ...future.globals.maxSize)) {
[08:24:59.629]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.629]                         on.exit(options(oopts), add = TRUE)
[08:24:59.629]                       }
[08:24:59.629]                       {
[08:24:59.629]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.629]                           FUN = function(jj) {
[08:24:59.629]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.629]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.629]                           })
[08:24:59.629]                       }
[08:24:59.629]                     }, args = future.call.arguments)
[08:24:59.629]                   }
[08:24:59.629]                 }, immediateCondition = function(cond) {
[08:24:59.629]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.629]                   sendCondition(cond)
[08:24:59.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.629]                   {
[08:24:59.629]                     inherits <- base::inherits
[08:24:59.629]                     invokeRestart <- base::invokeRestart
[08:24:59.629]                     is.null <- base::is.null
[08:24:59.629]                     muffled <- FALSE
[08:24:59.629]                     if (inherits(cond, "message")) {
[08:24:59.629]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.629]                       if (muffled) 
[08:24:59.629]                         invokeRestart("muffleMessage")
[08:24:59.629]                     }
[08:24:59.629]                     else if (inherits(cond, "warning")) {
[08:24:59.629]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.629]                       if (muffled) 
[08:24:59.629]                         invokeRestart("muffleWarning")
[08:24:59.629]                     }
[08:24:59.629]                     else if (inherits(cond, "condition")) {
[08:24:59.629]                       if (!is.null(pattern)) {
[08:24:59.629]                         computeRestarts <- base::computeRestarts
[08:24:59.629]                         grepl <- base::grepl
[08:24:59.629]                         restarts <- computeRestarts(cond)
[08:24:59.629]                         for (restart in restarts) {
[08:24:59.629]                           name <- restart$name
[08:24:59.629]                           if (is.null(name)) 
[08:24:59.629]                             next
[08:24:59.629]                           if (!grepl(pattern, name)) 
[08:24:59.629]                             next
[08:24:59.629]                           invokeRestart(restart)
[08:24:59.629]                           muffled <- TRUE
[08:24:59.629]                           break
[08:24:59.629]                         }
[08:24:59.629]                       }
[08:24:59.629]                     }
[08:24:59.629]                     invisible(muffled)
[08:24:59.629]                   }
[08:24:59.629]                   muffleCondition(cond)
[08:24:59.629]                 })
[08:24:59.629]             }))
[08:24:59.629]             future::FutureResult(value = ...future.value$value, 
[08:24:59.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.629]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.629]                     ...future.globalenv.names))
[08:24:59.629]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.629]         }, condition = base::local({
[08:24:59.629]             c <- base::c
[08:24:59.629]             inherits <- base::inherits
[08:24:59.629]             invokeRestart <- base::invokeRestart
[08:24:59.629]             length <- base::length
[08:24:59.629]             list <- base::list
[08:24:59.629]             seq.int <- base::seq.int
[08:24:59.629]             signalCondition <- base::signalCondition
[08:24:59.629]             sys.calls <- base::sys.calls
[08:24:59.629]             `[[` <- base::`[[`
[08:24:59.629]             `+` <- base::`+`
[08:24:59.629]             `<<-` <- base::`<<-`
[08:24:59.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.629]                   3L)]
[08:24:59.629]             }
[08:24:59.629]             function(cond) {
[08:24:59.629]                 is_error <- inherits(cond, "error")
[08:24:59.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.629]                   NULL)
[08:24:59.629]                 if (is_error) {
[08:24:59.629]                   sessionInformation <- function() {
[08:24:59.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.629]                       search = base::search(), system = base::Sys.info())
[08:24:59.629]                   }
[08:24:59.629]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.629]                     cond$call), session = sessionInformation(), 
[08:24:59.629]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.629]                   signalCondition(cond)
[08:24:59.629]                 }
[08:24:59.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.629]                 "immediateCondition"))) {
[08:24:59.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.629]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.629]                   if (TRUE && !signal) {
[08:24:59.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.629]                     {
[08:24:59.629]                       inherits <- base::inherits
[08:24:59.629]                       invokeRestart <- base::invokeRestart
[08:24:59.629]                       is.null <- base::is.null
[08:24:59.629]                       muffled <- FALSE
[08:24:59.629]                       if (inherits(cond, "message")) {
[08:24:59.629]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.629]                         if (muffled) 
[08:24:59.629]                           invokeRestart("muffleMessage")
[08:24:59.629]                       }
[08:24:59.629]                       else if (inherits(cond, "warning")) {
[08:24:59.629]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.629]                         if (muffled) 
[08:24:59.629]                           invokeRestart("muffleWarning")
[08:24:59.629]                       }
[08:24:59.629]                       else if (inherits(cond, "condition")) {
[08:24:59.629]                         if (!is.null(pattern)) {
[08:24:59.629]                           computeRestarts <- base::computeRestarts
[08:24:59.629]                           grepl <- base::grepl
[08:24:59.629]                           restarts <- computeRestarts(cond)
[08:24:59.629]                           for (restart in restarts) {
[08:24:59.629]                             name <- restart$name
[08:24:59.629]                             if (is.null(name)) 
[08:24:59.629]                               next
[08:24:59.629]                             if (!grepl(pattern, name)) 
[08:24:59.629]                               next
[08:24:59.629]                             invokeRestart(restart)
[08:24:59.629]                             muffled <- TRUE
[08:24:59.629]                             break
[08:24:59.629]                           }
[08:24:59.629]                         }
[08:24:59.629]                       }
[08:24:59.629]                       invisible(muffled)
[08:24:59.629]                     }
[08:24:59.629]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.629]                   }
[08:24:59.629]                 }
[08:24:59.629]                 else {
[08:24:59.629]                   if (TRUE) {
[08:24:59.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.629]                     {
[08:24:59.629]                       inherits <- base::inherits
[08:24:59.629]                       invokeRestart <- base::invokeRestart
[08:24:59.629]                       is.null <- base::is.null
[08:24:59.629]                       muffled <- FALSE
[08:24:59.629]                       if (inherits(cond, "message")) {
[08:24:59.629]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.629]                         if (muffled) 
[08:24:59.629]                           invokeRestart("muffleMessage")
[08:24:59.629]                       }
[08:24:59.629]                       else if (inherits(cond, "warning")) {
[08:24:59.629]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.629]                         if (muffled) 
[08:24:59.629]                           invokeRestart("muffleWarning")
[08:24:59.629]                       }
[08:24:59.629]                       else if (inherits(cond, "condition")) {
[08:24:59.629]                         if (!is.null(pattern)) {
[08:24:59.629]                           computeRestarts <- base::computeRestarts
[08:24:59.629]                           grepl <- base::grepl
[08:24:59.629]                           restarts <- computeRestarts(cond)
[08:24:59.629]                           for (restart in restarts) {
[08:24:59.629]                             name <- restart$name
[08:24:59.629]                             if (is.null(name)) 
[08:24:59.629]                               next
[08:24:59.629]                             if (!grepl(pattern, name)) 
[08:24:59.629]                               next
[08:24:59.629]                             invokeRestart(restart)
[08:24:59.629]                             muffled <- TRUE
[08:24:59.629]                             break
[08:24:59.629]                           }
[08:24:59.629]                         }
[08:24:59.629]                       }
[08:24:59.629]                       invisible(muffled)
[08:24:59.629]                     }
[08:24:59.629]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.629]                   }
[08:24:59.629]                 }
[08:24:59.629]             }
[08:24:59.629]         }))
[08:24:59.629]     }, error = function(ex) {
[08:24:59.629]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.629]                 ...future.rng), started = ...future.startTime, 
[08:24:59.629]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.629]             version = "1.8"), class = "FutureResult")
[08:24:59.629]     }, finally = {
[08:24:59.629]         if (!identical(...future.workdir, getwd())) 
[08:24:59.629]             setwd(...future.workdir)
[08:24:59.629]         {
[08:24:59.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.629]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.629]             }
[08:24:59.629]             base::options(...future.oldOptions)
[08:24:59.629]             if (.Platform$OS.type == "windows") {
[08:24:59.629]                 old_names <- names(...future.oldEnvVars)
[08:24:59.629]                 envs <- base::Sys.getenv()
[08:24:59.629]                 names <- names(envs)
[08:24:59.629]                 common <- intersect(names, old_names)
[08:24:59.629]                 added <- setdiff(names, old_names)
[08:24:59.629]                 removed <- setdiff(old_names, names)
[08:24:59.629]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.629]                   envs[common]]
[08:24:59.629]                 NAMES <- toupper(changed)
[08:24:59.629]                 args <- list()
[08:24:59.629]                 for (kk in seq_along(NAMES)) {
[08:24:59.629]                   name <- changed[[kk]]
[08:24:59.629]                   NAME <- NAMES[[kk]]
[08:24:59.629]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.629]                     next
[08:24:59.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.629]                 }
[08:24:59.629]                 NAMES <- toupper(added)
[08:24:59.629]                 for (kk in seq_along(NAMES)) {
[08:24:59.629]                   name <- added[[kk]]
[08:24:59.629]                   NAME <- NAMES[[kk]]
[08:24:59.629]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.629]                     next
[08:24:59.629]                   args[[name]] <- ""
[08:24:59.629]                 }
[08:24:59.629]                 NAMES <- toupper(removed)
[08:24:59.629]                 for (kk in seq_along(NAMES)) {
[08:24:59.629]                   name <- removed[[kk]]
[08:24:59.629]                   NAME <- NAMES[[kk]]
[08:24:59.629]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.629]                     next
[08:24:59.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.629]                 }
[08:24:59.629]                 if (length(args) > 0) 
[08:24:59.629]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.629]             }
[08:24:59.629]             else {
[08:24:59.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.629]             }
[08:24:59.629]             {
[08:24:59.629]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.629]                   0L) {
[08:24:59.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.629]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.629]                   base::options(opts)
[08:24:59.629]                 }
[08:24:59.629]                 {
[08:24:59.629]                   {
[08:24:59.629]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.629]                     NULL
[08:24:59.629]                   }
[08:24:59.629]                   options(future.plan = NULL)
[08:24:59.629]                   if (is.na(NA_character_)) 
[08:24:59.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.629]                     .init = FALSE)
[08:24:59.629]                 }
[08:24:59.629]             }
[08:24:59.629]         }
[08:24:59.629]     })
[08:24:59.629]     if (TRUE) {
[08:24:59.629]         base::sink(type = "output", split = FALSE)
[08:24:59.629]         if (TRUE) {
[08:24:59.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.629]         }
[08:24:59.629]         else {
[08:24:59.629]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.629]         }
[08:24:59.629]         base::close(...future.stdout)
[08:24:59.629]         ...future.stdout <- NULL
[08:24:59.629]     }
[08:24:59.629]     ...future.result$conditions <- ...future.conditions
[08:24:59.629]     ...future.result$finished <- base::Sys.time()
[08:24:59.629]     ...future.result
[08:24:59.629] }
[08:24:59.632] Exporting 5 global objects (1.57 KiB) to cluster node #1 ...
[08:24:59.632] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ...
[08:24:59.632] Exporting ‘...future.FUN’ (281 bytes) to cluster node #1 ... DONE
[08:24:59.633] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:59.633] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:59.633] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ...
[08:24:59.633] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #1 ... DONE
[08:24:59.633] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:59.634] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.634] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:24:59.634] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:24:59.634] Exporting 5 global objects (1.57 KiB) to cluster node #1 ... DONE
[08:24:59.635] MultisessionFuture started
[08:24:59.635] - Launch lazy future ... done
[08:24:59.635] run() for ‘MultisessionFuture’ ... done
[08:24:59.635] Created future:
[08:24:59.635] MultisessionFuture:
[08:24:59.635] Label: ‘future_by-1’
[08:24:59.635] Expression:
[08:24:59.635] {
[08:24:59.635]     do.call(function(...) {
[08:24:59.635]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.635]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.635]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.635]             on.exit(options(oopts), add = TRUE)
[08:24:59.635]         }
[08:24:59.635]         {
[08:24:59.635]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.635]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.635]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.635]             })
[08:24:59.635]         }
[08:24:59.635]     }, args = future.call.arguments)
[08:24:59.635] }
[08:24:59.635] Lazy evaluation: FALSE
[08:24:59.635] Asynchronous evaluation: TRUE
[08:24:59.635] Local evaluation: TRUE
[08:24:59.635] Environment: 0x557b29268e80
[08:24:59.635] Capture standard output: TRUE
[08:24:59.635] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.635] Globals: 5 objects totaling 1.14 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 736 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:59.635] Packages: <none>
[08:24:59.635] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.635] Resolved: FALSE
[08:24:59.635] Value: <not collected>
[08:24:59.635] Conditions captured: <none>
[08:24:59.635] Early signaling: FALSE
[08:24:59.635] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.635] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.647] Chunk #1 of 2 ... DONE
[08:24:59.647] Chunk #2 of 2 ...
[08:24:59.647]  - Finding globals in 'X' for chunk #2 ...
[08:24:59.647] getGlobalsAndPackages() ...
[08:24:59.647] Searching for globals...
[08:24:59.648] 
[08:24:59.648] Searching for globals ... DONE
[08:24:59.648] - globals: [0] <none>
[08:24:59.648] getGlobalsAndPackages() ... DONE
[08:24:59.648]    + additional globals found: [n=0] 
[08:24:59.648]    + additional namespaces needed: [n=0] 
[08:24:59.648]  - Finding globals in 'X' for chunk #2 ... DONE
[08:24:59.648]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:24:59.648]  - seeds: <none>
[08:24:59.648]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.648] getGlobalsAndPackages() ...
[08:24:59.649] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.649] Resolving globals: FALSE
[08:24:59.649] Tweak future expression to call with '...' arguments ...
[08:24:59.649] {
[08:24:59.649]     do.call(function(...) {
[08:24:59.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.649]             on.exit(options(oopts), add = TRUE)
[08:24:59.649]         }
[08:24:59.649]         {
[08:24:59.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.649]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.649]             })
[08:24:59.649]         }
[08:24:59.649]     }, args = future.call.arguments)
[08:24:59.649] }
[08:24:59.651] Tweak future expression to call with '...' arguments ... DONE
[08:24:59.652] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:59.652] 
[08:24:59.652] getGlobalsAndPackages() ... DONE
[08:24:59.652] run() for ‘Future’ ...
[08:24:59.652] - state: ‘created’
[08:24:59.652] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:59.666] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:59.666]   - Field: ‘node’
[08:24:59.666]   - Field: ‘label’
[08:24:59.666]   - Field: ‘local’
[08:24:59.666]   - Field: ‘owner’
[08:24:59.666]   - Field: ‘envir’
[08:24:59.666]   - Field: ‘workers’
[08:24:59.666]   - Field: ‘packages’
[08:24:59.667]   - Field: ‘gc’
[08:24:59.667]   - Field: ‘conditions’
[08:24:59.667]   - Field: ‘persistent’
[08:24:59.667]   - Field: ‘expr’
[08:24:59.667]   - Field: ‘uuid’
[08:24:59.667]   - Field: ‘seed’
[08:24:59.667]   - Field: ‘version’
[08:24:59.667]   - Field: ‘result’
[08:24:59.667]   - Field: ‘asynchronous’
[08:24:59.667]   - Field: ‘calls’
[08:24:59.667]   - Field: ‘globals’
[08:24:59.667]   - Field: ‘stdout’
[08:24:59.668]   - Field: ‘earlySignal’
[08:24:59.668]   - Field: ‘lazy’
[08:24:59.668]   - Field: ‘state’
[08:24:59.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:59.668] - Launch lazy future ...
[08:24:59.668] Packages needed by the future expression (n = 0): <none>
[08:24:59.668] Packages needed by future strategies (n = 0): <none>
[08:24:59.669] {
[08:24:59.669]     {
[08:24:59.669]         {
[08:24:59.669]             ...future.startTime <- base::Sys.time()
[08:24:59.669]             {
[08:24:59.669]                 {
[08:24:59.669]                   {
[08:24:59.669]                     {
[08:24:59.669]                       base::local({
[08:24:59.669]                         has_future <- base::requireNamespace("future", 
[08:24:59.669]                           quietly = TRUE)
[08:24:59.669]                         if (has_future) {
[08:24:59.669]                           ns <- base::getNamespace("future")
[08:24:59.669]                           version <- ns[[".package"]][["version"]]
[08:24:59.669]                           if (is.null(version)) 
[08:24:59.669]                             version <- utils::packageVersion("future")
[08:24:59.669]                         }
[08:24:59.669]                         else {
[08:24:59.669]                           version <- NULL
[08:24:59.669]                         }
[08:24:59.669]                         if (!has_future || version < "1.8.0") {
[08:24:59.669]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:59.669]                             "", base::R.version$version.string), 
[08:24:59.669]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:59.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:59.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:59.669]                               "release", "version")], collapse = " "), 
[08:24:59.669]                             hostname = base::Sys.info()[["nodename"]])
[08:24:59.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:59.669]                             info)
[08:24:59.669]                           info <- base::paste(info, collapse = "; ")
[08:24:59.669]                           if (!has_future) {
[08:24:59.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:59.669]                               info)
[08:24:59.669]                           }
[08:24:59.669]                           else {
[08:24:59.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:59.669]                               info, version)
[08:24:59.669]                           }
[08:24:59.669]                           base::stop(msg)
[08:24:59.669]                         }
[08:24:59.669]                       })
[08:24:59.669]                     }
[08:24:59.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:59.669]                     base::options(mc.cores = 1L)
[08:24:59.669]                   }
[08:24:59.669]                   ...future.strategy.old <- future::plan("list")
[08:24:59.669]                   options(future.plan = NULL)
[08:24:59.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:59.669]                 }
[08:24:59.669]                 ...future.workdir <- getwd()
[08:24:59.669]             }
[08:24:59.669]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:59.669]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:59.669]         }
[08:24:59.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:59.669]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:24:59.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:59.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:59.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:59.669]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:59.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:59.669]             base::names(...future.oldOptions))
[08:24:59.669]     }
[08:24:59.669]     if (FALSE) {
[08:24:59.669]     }
[08:24:59.669]     else {
[08:24:59.669]         if (TRUE) {
[08:24:59.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:59.669]                 open = "w")
[08:24:59.669]         }
[08:24:59.669]         else {
[08:24:59.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:59.669]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:59.669]         }
[08:24:59.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:59.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:59.669]             base::sink(type = "output", split = FALSE)
[08:24:59.669]             base::close(...future.stdout)
[08:24:59.669]         }, add = TRUE)
[08:24:59.669]     }
[08:24:59.669]     ...future.frame <- base::sys.nframe()
[08:24:59.669]     ...future.conditions <- base::list()
[08:24:59.669]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:59.669]     if (FALSE) {
[08:24:59.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:59.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:59.669]     }
[08:24:59.669]     ...future.result <- base::tryCatch({
[08:24:59.669]         base::withCallingHandlers({
[08:24:59.669]             ...future.value <- base::withVisible(base::local({
[08:24:59.669]                 ...future.makeSendCondition <- base::local({
[08:24:59.669]                   sendCondition <- NULL
[08:24:59.669]                   function(frame = 1L) {
[08:24:59.669]                     if (is.function(sendCondition)) 
[08:24:59.669]                       return(sendCondition)
[08:24:59.669]                     ns <- getNamespace("parallel")
[08:24:59.669]                     if (exists("sendData", mode = "function", 
[08:24:59.669]                       envir = ns)) {
[08:24:59.669]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:59.669]                         envir = ns)
[08:24:59.669]                       envir <- sys.frame(frame)
[08:24:59.669]                       master <- NULL
[08:24:59.669]                       while (!identical(envir, .GlobalEnv) && 
[08:24:59.669]                         !identical(envir, emptyenv())) {
[08:24:59.669]                         if (exists("master", mode = "list", envir = envir, 
[08:24:59.669]                           inherits = FALSE)) {
[08:24:59.669]                           master <- get("master", mode = "list", 
[08:24:59.669]                             envir = envir, inherits = FALSE)
[08:24:59.669]                           if (inherits(master, c("SOCKnode", 
[08:24:59.669]                             "SOCK0node"))) {
[08:24:59.669]                             sendCondition <<- function(cond) {
[08:24:59.669]                               data <- list(type = "VALUE", value = cond, 
[08:24:59.669]                                 success = TRUE)
[08:24:59.669]                               parallel_sendData(master, data)
[08:24:59.669]                             }
[08:24:59.669]                             return(sendCondition)
[08:24:59.669]                           }
[08:24:59.669]                         }
[08:24:59.669]                         frame <- frame + 1L
[08:24:59.669]                         envir <- sys.frame(frame)
[08:24:59.669]                       }
[08:24:59.669]                     }
[08:24:59.669]                     sendCondition <<- function(cond) NULL
[08:24:59.669]                   }
[08:24:59.669]                 })
[08:24:59.669]                 withCallingHandlers({
[08:24:59.669]                   {
[08:24:59.669]                     do.call(function(...) {
[08:24:59.669]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.669]                       if (!identical(...future.globals.maxSize.org, 
[08:24:59.669]                         ...future.globals.maxSize)) {
[08:24:59.669]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.669]                         on.exit(options(oopts), add = TRUE)
[08:24:59.669]                       }
[08:24:59.669]                       {
[08:24:59.669]                         lapply(seq_along(...future.elements_ii), 
[08:24:59.669]                           FUN = function(jj) {
[08:24:59.669]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.669]                             ...future.FUN(...future.X_jj, ...)
[08:24:59.669]                           })
[08:24:59.669]                       }
[08:24:59.669]                     }, args = future.call.arguments)
[08:24:59.669]                   }
[08:24:59.669]                 }, immediateCondition = function(cond) {
[08:24:59.669]                   sendCondition <- ...future.makeSendCondition()
[08:24:59.669]                   sendCondition(cond)
[08:24:59.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.669]                   {
[08:24:59.669]                     inherits <- base::inherits
[08:24:59.669]                     invokeRestart <- base::invokeRestart
[08:24:59.669]                     is.null <- base::is.null
[08:24:59.669]                     muffled <- FALSE
[08:24:59.669]                     if (inherits(cond, "message")) {
[08:24:59.669]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:59.669]                       if (muffled) 
[08:24:59.669]                         invokeRestart("muffleMessage")
[08:24:59.669]                     }
[08:24:59.669]                     else if (inherits(cond, "warning")) {
[08:24:59.669]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:59.669]                       if (muffled) 
[08:24:59.669]                         invokeRestart("muffleWarning")
[08:24:59.669]                     }
[08:24:59.669]                     else if (inherits(cond, "condition")) {
[08:24:59.669]                       if (!is.null(pattern)) {
[08:24:59.669]                         computeRestarts <- base::computeRestarts
[08:24:59.669]                         grepl <- base::grepl
[08:24:59.669]                         restarts <- computeRestarts(cond)
[08:24:59.669]                         for (restart in restarts) {
[08:24:59.669]                           name <- restart$name
[08:24:59.669]                           if (is.null(name)) 
[08:24:59.669]                             next
[08:24:59.669]                           if (!grepl(pattern, name)) 
[08:24:59.669]                             next
[08:24:59.669]                           invokeRestart(restart)
[08:24:59.669]                           muffled <- TRUE
[08:24:59.669]                           break
[08:24:59.669]                         }
[08:24:59.669]                       }
[08:24:59.669]                     }
[08:24:59.669]                     invisible(muffled)
[08:24:59.669]                   }
[08:24:59.669]                   muffleCondition(cond)
[08:24:59.669]                 })
[08:24:59.669]             }))
[08:24:59.669]             future::FutureResult(value = ...future.value$value, 
[08:24:59.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.669]                   ...future.rng), globalenv = if (FALSE) 
[08:24:59.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:59.669]                     ...future.globalenv.names))
[08:24:59.669]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:59.669]         }, condition = base::local({
[08:24:59.669]             c <- base::c
[08:24:59.669]             inherits <- base::inherits
[08:24:59.669]             invokeRestart <- base::invokeRestart
[08:24:59.669]             length <- base::length
[08:24:59.669]             list <- base::list
[08:24:59.669]             seq.int <- base::seq.int
[08:24:59.669]             signalCondition <- base::signalCondition
[08:24:59.669]             sys.calls <- base::sys.calls
[08:24:59.669]             `[[` <- base::`[[`
[08:24:59.669]             `+` <- base::`+`
[08:24:59.669]             `<<-` <- base::`<<-`
[08:24:59.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:59.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:59.669]                   3L)]
[08:24:59.669]             }
[08:24:59.669]             function(cond) {
[08:24:59.669]                 is_error <- inherits(cond, "error")
[08:24:59.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:59.669]                   NULL)
[08:24:59.669]                 if (is_error) {
[08:24:59.669]                   sessionInformation <- function() {
[08:24:59.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:59.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:59.669]                       search = base::search(), system = base::Sys.info())
[08:24:59.669]                   }
[08:24:59.669]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:59.669]                     cond$call), session = sessionInformation(), 
[08:24:59.669]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:59.669]                   signalCondition(cond)
[08:24:59.669]                 }
[08:24:59.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:59.669]                 "immediateCondition"))) {
[08:24:59.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:59.669]                   ...future.conditions[[length(...future.conditions) + 
[08:24:59.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:59.669]                   if (TRUE && !signal) {
[08:24:59.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.669]                     {
[08:24:59.669]                       inherits <- base::inherits
[08:24:59.669]                       invokeRestart <- base::invokeRestart
[08:24:59.669]                       is.null <- base::is.null
[08:24:59.669]                       muffled <- FALSE
[08:24:59.669]                       if (inherits(cond, "message")) {
[08:24:59.669]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.669]                         if (muffled) 
[08:24:59.669]                           invokeRestart("muffleMessage")
[08:24:59.669]                       }
[08:24:59.669]                       else if (inherits(cond, "warning")) {
[08:24:59.669]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.669]                         if (muffled) 
[08:24:59.669]                           invokeRestart("muffleWarning")
[08:24:59.669]                       }
[08:24:59.669]                       else if (inherits(cond, "condition")) {
[08:24:59.669]                         if (!is.null(pattern)) {
[08:24:59.669]                           computeRestarts <- base::computeRestarts
[08:24:59.669]                           grepl <- base::grepl
[08:24:59.669]                           restarts <- computeRestarts(cond)
[08:24:59.669]                           for (restart in restarts) {
[08:24:59.669]                             name <- restart$name
[08:24:59.669]                             if (is.null(name)) 
[08:24:59.669]                               next
[08:24:59.669]                             if (!grepl(pattern, name)) 
[08:24:59.669]                               next
[08:24:59.669]                             invokeRestart(restart)
[08:24:59.669]                             muffled <- TRUE
[08:24:59.669]                             break
[08:24:59.669]                           }
[08:24:59.669]                         }
[08:24:59.669]                       }
[08:24:59.669]                       invisible(muffled)
[08:24:59.669]                     }
[08:24:59.669]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.669]                   }
[08:24:59.669]                 }
[08:24:59.669]                 else {
[08:24:59.669]                   if (TRUE) {
[08:24:59.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:59.669]                     {
[08:24:59.669]                       inherits <- base::inherits
[08:24:59.669]                       invokeRestart <- base::invokeRestart
[08:24:59.669]                       is.null <- base::is.null
[08:24:59.669]                       muffled <- FALSE
[08:24:59.669]                       if (inherits(cond, "message")) {
[08:24:59.669]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:59.669]                         if (muffled) 
[08:24:59.669]                           invokeRestart("muffleMessage")
[08:24:59.669]                       }
[08:24:59.669]                       else if (inherits(cond, "warning")) {
[08:24:59.669]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:59.669]                         if (muffled) 
[08:24:59.669]                           invokeRestart("muffleWarning")
[08:24:59.669]                       }
[08:24:59.669]                       else if (inherits(cond, "condition")) {
[08:24:59.669]                         if (!is.null(pattern)) {
[08:24:59.669]                           computeRestarts <- base::computeRestarts
[08:24:59.669]                           grepl <- base::grepl
[08:24:59.669]                           restarts <- computeRestarts(cond)
[08:24:59.669]                           for (restart in restarts) {
[08:24:59.669]                             name <- restart$name
[08:24:59.669]                             if (is.null(name)) 
[08:24:59.669]                               next
[08:24:59.669]                             if (!grepl(pattern, name)) 
[08:24:59.669]                               next
[08:24:59.669]                             invokeRestart(restart)
[08:24:59.669]                             muffled <- TRUE
[08:24:59.669]                             break
[08:24:59.669]                           }
[08:24:59.669]                         }
[08:24:59.669]                       }
[08:24:59.669]                       invisible(muffled)
[08:24:59.669]                     }
[08:24:59.669]                     muffleCondition(cond, pattern = "^muffle")
[08:24:59.669]                   }
[08:24:59.669]                 }
[08:24:59.669]             }
[08:24:59.669]         }))
[08:24:59.669]     }, error = function(ex) {
[08:24:59.669]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:59.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:59.669]                 ...future.rng), started = ...future.startTime, 
[08:24:59.669]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:59.669]             version = "1.8"), class = "FutureResult")
[08:24:59.669]     }, finally = {
[08:24:59.669]         if (!identical(...future.workdir, getwd())) 
[08:24:59.669]             setwd(...future.workdir)
[08:24:59.669]         {
[08:24:59.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:59.669]                 ...future.oldOptions$nwarnings <- NULL
[08:24:59.669]             }
[08:24:59.669]             base::options(...future.oldOptions)
[08:24:59.669]             if (.Platform$OS.type == "windows") {
[08:24:59.669]                 old_names <- names(...future.oldEnvVars)
[08:24:59.669]                 envs <- base::Sys.getenv()
[08:24:59.669]                 names <- names(envs)
[08:24:59.669]                 common <- intersect(names, old_names)
[08:24:59.669]                 added <- setdiff(names, old_names)
[08:24:59.669]                 removed <- setdiff(old_names, names)
[08:24:59.669]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:59.669]                   envs[common]]
[08:24:59.669]                 NAMES <- toupper(changed)
[08:24:59.669]                 args <- list()
[08:24:59.669]                 for (kk in seq_along(NAMES)) {
[08:24:59.669]                   name <- changed[[kk]]
[08:24:59.669]                   NAME <- NAMES[[kk]]
[08:24:59.669]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.669]                     next
[08:24:59.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.669]                 }
[08:24:59.669]                 NAMES <- toupper(added)
[08:24:59.669]                 for (kk in seq_along(NAMES)) {
[08:24:59.669]                   name <- added[[kk]]
[08:24:59.669]                   NAME <- NAMES[[kk]]
[08:24:59.669]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.669]                     next
[08:24:59.669]                   args[[name]] <- ""
[08:24:59.669]                 }
[08:24:59.669]                 NAMES <- toupper(removed)
[08:24:59.669]                 for (kk in seq_along(NAMES)) {
[08:24:59.669]                   name <- removed[[kk]]
[08:24:59.669]                   NAME <- NAMES[[kk]]
[08:24:59.669]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:59.669]                     next
[08:24:59.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:59.669]                 }
[08:24:59.669]                 if (length(args) > 0) 
[08:24:59.669]                   base::do.call(base::Sys.setenv, args = args)
[08:24:59.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:59.669]             }
[08:24:59.669]             else {
[08:24:59.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:59.669]             }
[08:24:59.669]             {
[08:24:59.669]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:59.669]                   0L) {
[08:24:59.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:59.669]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:59.669]                   base::options(opts)
[08:24:59.669]                 }
[08:24:59.669]                 {
[08:24:59.669]                   {
[08:24:59.669]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:59.669]                     NULL
[08:24:59.669]                   }
[08:24:59.669]                   options(future.plan = NULL)
[08:24:59.669]                   if (is.na(NA_character_)) 
[08:24:59.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:59.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:59.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:59.669]                     .init = FALSE)
[08:24:59.669]                 }
[08:24:59.669]             }
[08:24:59.669]         }
[08:24:59.669]     })
[08:24:59.669]     if (TRUE) {
[08:24:59.669]         base::sink(type = "output", split = FALSE)
[08:24:59.669]         if (TRUE) {
[08:24:59.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:59.669]         }
[08:24:59.669]         else {
[08:24:59.669]             ...future.result["stdout"] <- base::list(NULL)
[08:24:59.669]         }
[08:24:59.669]         base::close(...future.stdout)
[08:24:59.669]         ...future.stdout <- NULL
[08:24:59.669]     }
[08:24:59.669]     ...future.result$conditions <- ...future.conditions
[08:24:59.669]     ...future.result$finished <- base::Sys.time()
[08:24:59.669]     ...future.result
[08:24:59.669] }
[08:24:59.671] Exporting 5 global objects (2.20 KiB) to cluster node #2 ...
[08:24:59.672] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ...
[08:24:59.672] Exporting ‘...future.FUN’ (281 bytes) to cluster node #2 ... DONE
[08:24:59.672] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:59.673] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:59.673] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ...
[08:24:59.673] Exporting ‘...future.elements_ii’ (1.35 KiB) to cluster node #2 ... DONE
[08:24:59.673] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:59.674] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.674] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:24:59.674] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:24:59.674] Exporting 5 global objects (2.20 KiB) to cluster node #2 ... DONE
[08:24:59.675] MultisessionFuture started
[08:24:59.675] - Launch lazy future ... done
[08:24:59.675] run() for ‘MultisessionFuture’ ... done
[08:24:59.675] Created future:
[08:24:59.675] MultisessionFuture:
[08:24:59.675] Label: ‘future_by-2’
[08:24:59.675] Expression:
[08:24:59.675] {
[08:24:59.675]     do.call(function(...) {
[08:24:59.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:59.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:59.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:59.675]             on.exit(options(oopts), add = TRUE)
[08:24:59.675]         }
[08:24:59.675]         {
[08:24:59.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:59.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:59.675]                 ...future.FUN(...future.X_jj, ...)
[08:24:59.675]             })
[08:24:59.675]         }
[08:24:59.675]     }, args = future.call.arguments)
[08:24:59.675] }
[08:24:59.675] Lazy evaluation: FALSE
[08:24:59.675] Asynchronous evaluation: TRUE
[08:24:59.675] Local evaluation: TRUE
[08:24:59.675] Environment: 0x557b29268e80
[08:24:59.675] Capture standard output: TRUE
[08:24:59.675] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:59.675] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 281 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.35 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:24:59.675] Packages: <none>
[08:24:59.675] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:59.675] Resolved: FALSE
[08:24:59.675] Value: <not collected>
[08:24:59.675] Conditions captured: <none>
[08:24:59.675] Early signaling: FALSE
[08:24:59.675] Owner process: 4a441204-454c-9967-b264-fc52525940b9
[08:24:59.675] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:59.686] Chunk #2 of 2 ... DONE
[08:24:59.687] Launching 2 futures (chunks) ... DONE
[08:24:59.687] Resolving 2 futures (chunks) ...
[08:24:59.687] resolve() on list ...
[08:24:59.687]  recursive: 0
[08:24:59.687]  length: 2
[08:24:59.687] 
[08:24:59.688] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.688] - Validating connection of MultisessionFuture
[08:24:59.688] - received message: FutureResult
[08:24:59.688] - Received FutureResult
[08:24:59.688] - Erased future from FutureRegistry
[08:24:59.688] result() for ClusterFuture ...
[08:24:59.688] - result already collected: FutureResult
[08:24:59.688] result() for ClusterFuture ... done
[08:24:59.688] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.688] Future #1
[08:24:59.689] result() for ClusterFuture ...
[08:24:59.689] - result already collected: FutureResult
[08:24:59.689] result() for ClusterFuture ... done
[08:24:59.689] result() for ClusterFuture ...
[08:24:59.689] - result already collected: FutureResult
[08:24:59.689] result() for ClusterFuture ... done
[08:24:59.689] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:59.689] - nx: 2
[08:24:59.689] - relay: TRUE
[08:24:59.689] - stdout: TRUE
[08:24:59.689] - signal: TRUE
[08:24:59.689] - resignal: FALSE
[08:24:59.689] - force: TRUE
[08:24:59.690] - relayed: [n=2] FALSE, FALSE
[08:24:59.690] - queued futures: [n=2] FALSE, FALSE
[08:24:59.690]  - until=1
[08:24:59.690]  - relaying element #1
[08:24:59.690] result() for ClusterFuture ...
[08:24:59.690] - result already collected: FutureResult
[08:24:59.690] result() for ClusterFuture ... done
[08:24:59.690] result() for ClusterFuture ...
[08:24:59.690] - result already collected: FutureResult
[08:24:59.690] result() for ClusterFuture ... done
[08:24:59.690] result() for ClusterFuture ...
[08:24:59.690] - result already collected: FutureResult
[08:24:59.691] result() for ClusterFuture ... done
[08:24:59.691] result() for ClusterFuture ...
[08:24:59.691] - result already collected: FutureResult
[08:24:59.691] result() for ClusterFuture ... done
[08:24:59.691] - relayed: [n=2] TRUE, FALSE
[08:24:59.691] - queued futures: [n=2] TRUE, FALSE
[08:24:59.691] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:59.691]  length: 1 (resolved future 1)
[08:24:59.718] receiveMessageFromWorker() for ClusterFuture ...
[08:24:59.718] - Validating connection of MultisessionFuture
[08:24:59.718] - received message: FutureResult
[08:24:59.719] - Received FutureResult
[08:24:59.719] - Erased future from FutureRegistry
[08:24:59.719] result() for ClusterFuture ...
[08:24:59.719] - result already collected: FutureResult
[08:24:59.719] result() for ClusterFuture ... done
[08:24:59.719] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:59.719] Future #2
[08:24:59.719] result() for ClusterFuture ...
[08:24:59.719] - result already collected: FutureResult
[08:24:59.719] result() for ClusterFuture ... done
[08:24:59.719] result() for ClusterFuture ...
[08:24:59.720] - result already collected: FutureResult
[08:24:59.720] result() for ClusterFuture ... done
[08:24:59.720] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:59.720] - nx: 2
[08:24:59.720] - relay: TRUE
[08:24:59.720] - stdout: TRUE
[08:24:59.720] - signal: TRUE
[08:24:59.720] - resignal: FALSE
[08:24:59.720] - force: TRUE
[08:24:59.720] - relayed: [n=2] TRUE, FALSE
[08:24:59.720] - queued futures: [n=2] TRUE, FALSE
[08:24:59.720]  - until=2
[08:24:59.721]  - relaying element #2
[08:24:59.721] result() for ClusterFuture ...
[08:24:59.721] - result already collected: FutureResult
[08:24:59.721] result() for ClusterFuture ... done
[08:24:59.721] result() for ClusterFuture ...
[08:24:59.721] - result already collected: FutureResult
[08:24:59.721] result() for ClusterFuture ... done
[08:24:59.721] result() for ClusterFuture ...
[08:24:59.721] - result already collected: FutureResult
[08:24:59.721] result() for ClusterFuture ... done
[08:24:59.721] result() for ClusterFuture ...
[08:24:59.721] - result already collected: FutureResult
[08:24:59.722] result() for ClusterFuture ... done
[08:24:59.722] - relayed: [n=2] TRUE, TRUE
[08:24:59.722] - queued futures: [n=2] TRUE, TRUE
[08:24:59.722] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:59.722]  length: 0 (resolved future 2)
[08:24:59.722] Relaying remaining futures
[08:24:59.722] signalConditionsASAP(NULL, pos=0) ...
[08:24:59.722] - nx: 2
[08:24:59.722] - relay: TRUE
[08:24:59.722] - stdout: TRUE
[08:24:59.722] - signal: TRUE
[08:24:59.722] - resignal: FALSE
[08:24:59.722] - force: TRUE
[08:24:59.723] - relayed: [n=2] TRUE, TRUE
[08:24:59.723] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:59.723] - relayed: [n=2] TRUE, TRUE
[08:24:59.723] - queued futures: [n=2] TRUE, TRUE
[08:24:59.723] signalConditionsASAP(NULL, pos=0) ... done
[08:24:59.723] resolve() on list ... DONE
[08:24:59.723] result() for ClusterFuture ...
[08:24:59.723] - result already collected: FutureResult
[08:24:59.723] result() for ClusterFuture ... done
[08:24:59.723] result() for ClusterFuture ...
[08:24:59.723] - result already collected: FutureResult
[08:24:59.723] result() for ClusterFuture ... done
[08:24:59.724] result() for ClusterFuture ...
[08:24:59.724] - result already collected: FutureResult
[08:24:59.724] result() for ClusterFuture ... done
[08:24:59.724] result() for ClusterFuture ...
[08:24:59.724] - result already collected: FutureResult
[08:24:59.724] result() for ClusterFuture ... done
[08:24:59.724]  - Number of value chunks collected: 2
[08:24:59.724] Resolving 2 futures (chunks) ... DONE
[08:24:59.724] Reducing values from 2 chunks ...
[08:24:59.724]  - Number of values collected after concatenation: 3
[08:24:59.724]  - Number of values expected: 3
[08:24:59.724] Reducing values from 2 chunks ... DONE
[08:24:59.725] future_lapply() ... DONE
[08:24:59.725] future_by_internal() ... DONE
[08:24:59.725] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[08:24:59.726] plan(): Setting new future strategy stack:
[08:24:59.726] List of future strategies:
[08:24:59.726] 1. FutureStrategy:
[08:24:59.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:59.726]    - tweaked: FALSE
[08:24:59.726]    - call: future::plan(oplan)
[08:24:59.727] plan(): nbrOfWorkers() = 1
> 
